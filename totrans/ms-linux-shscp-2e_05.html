<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Alternative Syntax</h1>
                </header>
            
            <article>
                
<p>So far in the scripting journey, we have seen that we can use the <kbd>test</kbd> command to determine a conditional status. We have taken this a little further and discovered that we can also make use of the single square bracket. Here, we will recap the <kbd>test</kbd> command and look at the single square bracket in more detail. After having learned more about the square bracket, we will move onto more advanced variable or parameter management, thus providing defaults and understating quoting issues.</p>
<p>Finally, we are going to see that within advanced shells such as bash, Korn, and Zsh, we can go with double brackets! Making use of the double round parenthesis and double square bracket can simplify the overall syntax and allow the standardization of the use of mathematical symbols.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Recapping <kbd>test</kbd></li>
<li>Providing parameter defaults</li>
<li>When in doubt – quote!</li>
<li>Advanced tests using <kbd>[[</kbd></li>
<li>Arithmetic operations using <kbd>((</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirement</h1>
                </header>
            
            <article>
                
<p>The source code for this chapter can be downloaded from here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter05">https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter05</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recapping the test command</h1>
                </header>
            
            <article>
                
<p>So far, we have used the built-in <kbd>test</kbd> command to drive our conditional statements. Using other options with <kbd>test</kbd>, we can look at the returned value to determine the status of files in the filesystem. Running the <kbd>test</kbd> command without any options will return a false output:</p>
<pre><strong>$ test</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing files</h1>
                </header>
            
            <article>
                
<p>Commonly, we can use <kbd>test</kbd> to check the conditions based around files. For example, to test whether a file is present or not, we can use the <kbd>-e</kbd> option. The following command will test the existence of the <kbd>/etc/hosts</kbd> file:</p>
<pre><strong>test -e /etc/hosts</strong></pre>
<p>We can run this <kbd>test</kbd> again, but this time check that the file not only exists but is a regular file as opposed to having some special purpose. Specific file types can be directories, pipes, and links, among others. The option for a regular file is <kbd>-f</kbd>:</p>
<pre><strong>$ test -f /etc/hosts</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding logic</h1>
                </header>
            
            <article>
                
<p>If we need to open a file from within our script, we test that the file is both a regular file and has the read permission set. To achieve this with <kbd>test</kbd>, we can also include the <kbd>-a</kbd> option to <kbd>AND</kbd> multiple conditions together. In the following example command, we will use the <kbd>-r</kbd> condition to check that the file is readable:</p>
<pre><strong>$ test -f /etc/hosts -a -r /etc/hosts</strong></pre>
<p>Similarly, the use of <kbd>-o</kbd> is supported to <kbd>OR</kbd> two conditions within an expression.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Square brackets as not seen before</h1>
                </header>
            
            <article>
                
<p>As an alternative to the <kbd>test</kbd> command, we can implement the same conditional tests using the single square bracket. Repeating the previous conditional <kbd>test</kbd> and omitting the command itself. We will rewrite this, as shown in the following command:</p>
<pre><strong> $ [ -f /etc/hosts -a -r /etc/hosts ]</strong></pre>
<p>Many times, even as experienced administrators, we are used to language elements and we accept them as they are. I feel many Linux administrators will be surprised to learn that <kbd>[</kbd> is a command for both a shell built-in and a standalone file. Using the <kbd>type</kbd> command, we can verify this:</p>
<pre><strong>$ type -a [</strong></pre>
<p>We can see the output of this command in the following screenshot confirming its existence:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-55 image-border" src="assets/af5fd18f-715b-4990-8093-d42b9adefdcb.png" style="width:18.42em;height:5.17em;"/></div>
<p>The built-in <kbd>[</kbd> command imitates the <kbd>test</kbd> command but it requires a closing bracket.</p>
<p>Now we know a little more about the <kbd>[</kbd> command, which is found in bash and the earlier Bourne shell, we can now continue to add a little command-line list syntax. In addition to the command-line list, we can see the desired functionality working in the following command sample:</p>
<pre><strong>$ FILE=/etc/hosts</strong><br/><strong>$ [ -f $FILE -a -r $FILE ] &amp;&amp; cat $FILE</strong></pre>
<p>Having set the parameter <kbd>FILE</kbd> variable, we can test that it is both a regular file and is readable by the user before attempting to list the file contents. In this way, the script becomes more robust without the need for a complex script logic. We can see the code in use in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-56 image-border" src="assets/9c04243c-1855-4723-b90a-44d825d28e77.png" style="width:32.00em;height:13.17em;"/></div>
<p class="NormalPACKT" style="margin: 3.0pt 0cm .0001pt 0cm"><span>This type of abbreviation is quite common and is easily recognizable. We should always be cautious of using abbreviations if they do not add readability. Our aim in scripting should be to write clear and understandable code and avoid shortcuts if they do not add to this goal.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing parameter defaults</h1>
                </header>
            
            <article>
                
<p>Within bash parameters, there are named spaces in the memory that allow us access to stored values. There are two types of parameters:</p>
<ul>
<li>Variables</li>
<li>Special parameters</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables</h1>
                </header>
            
            <article>
                
<p>We already described what variables are and how to define them in <a href="" target="_blank">Chapter 1</a>, <em>The What and Why of Scripting with Bash</em>.  </p>
<p>Just to refresh your memory, you can define a variable by assigning a value with an equals sign and without any spaces like this:</p>
<pre>#!/bin/bash<br/>myvar=15<br/>myvar2="welcome"</pre>
<p>So nothing new here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Special parameters</h1>
                </header>
            
            <article>
                
<p>Special parameters are the second parameter type and are managed by the shell itself and are presented as read-only. We have come across these before in parameters such as <kbd>$0</kbd> but let's take a look at another <kbd>$-</kbd>. We can expand these parameters to gain an understanding of their use, using the <kbd>echo</kbd> command:</p>
<pre><strong>$ echo "My shell is $0 and the shell options are: $-"</strong></pre>
<p>From the annotated text that I have added, we can understand that the <kbd>$-</kbd> option represents the shell options that are configured. These can be displayed using the set <kbd>-o</kbd> command but it can be read programmatically using <kbd>$-</kbd>.</p>
<p>We can see this in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-57 image-border" src="assets/b4b7bb52-bd42-4f29-acf6-01839cf6d812.png" style="width:34.92em;height:3.83em;"/></div>
<p>The options set here are as follows:</p>
<ul>
<li><kbd>h</kbd>: This is short for hashall; it allows for programs to be found using the <kbd>PATH</kbd> parameter</li>
<li><kbd>i</kbd>: This shows that this is an interactive shell</li>
<li><kbd>m</kbd>: This is short for monitor; it allows the use of the <kbd>bg</kbd> and <kbd>fg</kbd> commands to bring commands in and out of the background</li>
<li><kbd>B</kbd>: This allows the brace expansion or <kbd>mkdirdir{1,2}</kbd>, where we create <kbd>dir1</kbd> and <kbd>dir2</kbd></li>
<li><kbd>H</kbd>: This allows history expansion of running commands, such as <kbd>!501</kbd> to repeat commands from history</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting defaults</h1>
                </header>
            
            <article>
                
<p>Using either the <kbd>test</kbd> command or the brackets, we can provide default values for variables, including command-line parameters. Taking the <kbd>hello4.sh</kbd> script we worked with earlier, we can modify it and set the <kbd>name</kbd> parameter if it is zero bytes:</p>
<pre><strong>#!/bin/bash</strong><br/><strong>name=$1</strong><br/><strong>[ -z $name ] &amp;&amp; name="Anonymous"</strong><br/><strong>echo "Hello $name"</strong><br/><strong>exit 0</strong></pre>
<p>This code is functional but it is our choice how we code in the default value. We can, alternatively, assign a default value directly to the parameter. Consider the following command, where a default assignment is made directly:</p>
<pre><strong>name=${1-"Anonymous"}</strong></pre>
<p>In bash, this is known as <strong>parameter substitution</strong> and can be written in the following pseudo-code:</p>
<pre><strong>${parameter-default}</strong></pre>
<p>Wherever a variable (<kbd>parameter</kbd>) has not been declared and has a null value, the default value will be used. If the parameter has been explicitly declared with a null value, we will use the <kbd>:-</kbd> syntax, as shown in the following example:</p>
<pre><strong>parameter=</strong><br/><strong>${parameter:-default}</strong></pre>
<p>By editing the script now, we can create <kbd>hello8.sh</kbd> to make use of bash parameter substitution to provide the default value:</p>
<pre><strong>#!/bin/bash</strong><br/><strong>#Use parameter substitution to provide default value</strong><br/><strong>name=${1-"Anonymous"}  </strong><br/><strong>echo "Hello $name"</strong><br/><strong>exit 0</strong></pre>
<p>This script and its output, both with and without a supplied value, are shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-58 image-border" src="assets/22032c85-3f5a-457b-bf7f-e7307cb9988e.png" style="width:21.92em;height:12.25em;"/></div>
<p>The <kbd>hello8.sh</kbd> script provides the functionality that we need, with the logic built directly into the parameter assignment. The logic and assignment are <span>now</span><span> </span><span>a single line of code within the script and this is a major step in keeping the script simple and maintaining the readability.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When in doubt – quote!</h1>
                </header>
            
            <article>
                
<p>Having established that variables are a type of parameter, we should always keep this in mind, especially when reading manuals and <em>HOWTOs</em>. Often the documentation refers to parameters and, in doing so, they include variables, as well as the bash special parameters, such as <kbd>$1</kbd> and so on. In keeping with this, we will look at why it is advisable to quote the parameters when we use them on the command line or within scripts. Learning this now can save us a lot of pain and heartache later, especially when we start looking at loops.</p>
<p>First, the correct term that we should use for reading the value of variables is <strong>parameter expansion</strong>. To you and me, this is reading a variable, but to bash this would be too simple. The assignment of a correct name, such as parameter expansion, reduces any ambiguity to its meaning but adds complexity at the same time. In the following example, the first line of command assigns the value of <kbd>fred</kbd> to the <kbd>name</kbd> parameter. The second line of command uses parameter expansion to print the stored value from memory. The <kbd>$</kbd> symbol is used to allow the expansion of the parameter:</p>
<pre><strong>$ name=fred</strong><br/><strong>$ echo "The value is: $name"</strong></pre>
<p class="mce-root">In the example, we have used the double quotes to allow <kbd>echo</kbd> to print the single string as we have used spaces. Without the use of quotes, <kbd>echo</kbd> might have seen this as multiple arguments, the space being the default field separator in most shells, including bash. Often, when we do not think to use quotes, we do not see the spaces directly. Consider the following extract of command-line code that we made use of earlier:</p>
<pre><strong>$ FILE=/etc/hosts</strong><br/><strong>$ [ -f $FILE -a -r $FILE ] &amp;&amp; cat $FILE</strong></pre>
<p>Even though this worked, we may have been a little fortunate, especially if we were populating the <kbd>FILE</kbd> parameter from a list of files that we had not created ourselves. It is quite conceivable that a file can have spaces within its name. Let's now replay this command using a different file. Consider the following command:</p>
<pre><strong>$ FILE="my file"</strong><br/><strong>$ [ -f $FILE -a -r $FILE ] &amp;&amp; cat $FILE</strong></pre>
<p>Even though, structurally, there has been no change to the code, it now fails. This is because we are providing too many arguments to the <kbd>[</kbd> command. The failing result will be the same even if we use the <kbd>test</kbd> command.</p>
<p>Even though we have correctly quoted the assignment of the filename to the parameter <kbd>FILE</kbd>, we have not protected the spaces when the parameter is expanded. We can see the code failing, as it is captured in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-59 image-border" src="assets/93d92de0-8e42-4c20-99b3-575ecdcf2121.png" style="width:31.67em;height:5.33em;"/></div>
<p>We can see that this will not be ready for our scripts. Alas, what we once thought of as robust is now in tatters and, like the Titanic, our code has sunk.</p>
<p>However, a simple solution is to revert to quoting parameter expansion unless specifically not desired. We can make this ship unsinkable with a simple edit to the code:</p>
<pre><strong>$ FILE="my file"</strong><br/><strong>$ [ -f "$FILE" -a -r "$FILE" ] &amp;&amp; cat "$FILE"</strong></pre>
<p>We can now proudly stand on the White Star Line dock, as we see the Titanic II get launched in the following code example, which is captured in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-60 image-border" src="assets/c81415b8-5644-400f-8caf-8364adcd5986.png" style="width:32.75em;height:5.25em;"/></div>
<p>It is truly amazing and sometimes just a little unbelievable what effect these tiny quotes can have. We should never ignore the quotes when expanding variables. To ensure that we drill home this point, we can highlight this phenomenon in another, even simpler, example. Let's take the scenario where we now just want to remove the file. In the first example, we do not use quotes:</p>
<pre><strong>$ rm $FILE</strong></pre>
<p>This code will produce failures as the parameter expansion will lead to the following perceived command:</p>
<pre><strong>$ rm my file</strong></pre>
<p>The code will fail because it is unable to find the <kbd>my</kbd> file or the <kbd>file</kbd> file. Even worse, we could <span>potentially </span><span>be deleting incorrect files if any of the names could</span> be resolved accidentally. However, quoting the parameter expansion will save the day, as we see in the second example:</p>
<pre><strong>$ rm "$FILE"</strong></pre>
<p>This is correctly expanded to the desired command that we illustrate in the following command example:</p>
<pre><strong>$ rm "my file"</strong></pre>
<p>I certainly hope that these examples demonstrate the need for care when expanding parameters and make you aware of the pitfalls.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced tests using [[</h1>
                </header>
            
            <article>
                
<p>The use of the double brackets <kbd>[[ condition ]]</kbd> allows us to do more advanced condition testing but it is not compatible with the Bourne shell. The double brackets were first introduced as a defined keyword in the KornShell and are also available in bash and Zsh. Unlike the single bracket, this is not a command but a keyword. The use of the <kbd>type</kbd> command can confirm this:</p>
<pre><strong>$ type [[<br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">White space</h1>
                </header>
            
            <article>
                
<p>The fact that <kbd>[[</kbd> is not a command is significant where white space is concerned. As a keyword, <kbd>[[</kbd> parses its arguments before bash expands them. As such, a single parameter will always be represented as a single argument. Even though it goes against best practice, <kbd>[[</kbd> can alleviate some of the issues associated with white space within parameter values. Reconsidering the condition we tested earlier, we can omit the quotes when using <kbd>[[</kbd>, as shown in the following example:</p>
<pre><strong>$ echo "The File Contents"&gt;"my file"</strong><br/><strong>$ FILE="my file"</strong><br/><strong>$ [[ -f $FILE &amp;&amp; -r $FILE ]] &amp;&amp; cat "$FILE"</strong></pre>
<p>We still need to quote the parameter when using <kbd>cat</kbd>, as you can see, and we can use quotes within the double brackets but they become optional. Note that we can also use the more traditional <kbd>&amp;&amp;</kbd> and <kbd>||</kbd> to represent <kbd>-a</kbd> and <kbd>-o</kbd> respectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other advanced features</h1>
                </header>
            
            <article>
                
<p>These are some of the extra features that we can include with the double brackets. Even if we lose portability in using them, there are some great features that overcome the loss. Remember that if we only use bash, then we can use the double brackets but can't run our scripts in the Bourne shell. The advanced features that we gain, which are covered in the following sections, include pattern matching and regular expressions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pattern matching</h1>
                </header>
            
            <article>
                
<p>Using the double brackets, we can do more than just match strings, we can use pattern matching. For example, we may need to work exclusively with Perl scripts, files that end with <kbd>.pl</kbd>. We will be able to implement this easily within a condition by including the pattern as a match, as shown in the following example:</p>
<pre><strong>$ [[ $FILE = *.pl ]] &amp;&amp; cp"$FILE" scripts/</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regular expressions</h1>
                </header>
            
            <article>
                
<p>We will talk in dept about regular expressions in a <a href="165453d1-d266-4144-882a-11ded6d1dd98.xhtml" target="_blank">Chapter 11</a>, <em>Regular Expressions</em>, but let's take a small glimpse now.</p>
<p>We could rewrite the last example using a regular expression:</p>
<pre><strong>$ [[ $FILE =~ \.pl$ ]] &amp;&amp; cp "$FILE" scripts/</strong></pre>
<div class="packt_infobox">
<p>As the single dot or period has a special meaning in regular expressions, we need to escape it with <kbd>\</kbd>.</p>
</div>
<p>The following screenshot shows the regular expression matching working with a file called <kbd>my.pl</kbd> and another called <kbd>my.apl</kbd>. The match correctly shows for the file that ends in <kbd>.pl</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-61 image-border" src="assets/84268ff7-79fb-4aa0-8205-1edb1d9f5a3c.png" style="width:34.08em;height:8.33em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regular expression script</h1>
                </header>
            
            <article>
                
<p>Another simple demonstration of conditional testing using regular expressions will be to expose the US and UK spelling of <em>color</em>, being <em>color</em> and <em>colour</em> respectively. We may prompt the user if they want a color or mono output for the script but at the same time cater for both spellings. The line that will do the work in the script is as follows:</p>
<pre><strong>if [[ $REPLY =~ colou?r ]] ; then</strong></pre>
<p>The regular expression caters to both spellings of <em>color</em> by making the <kbd>u</kbd> optional: <kbd>u?</kbd>. Furthermore, we can disable case sensitivity allowing for <em>COLOR</em> and <em>color</em> by setting a shell option:</p>
<pre><strong>shopt -s nocasematch</strong></pre>
<p>This option can be disabled again at the end of the script with the following command:</p>
<pre><strong>shopt -u nocasematch  </strong></pre>
<p>When we use the variable parameters that we have named <kbd>$GREEN</kbd> and <kbd>$RESET</kbd>, we affect the color of the output. The color green will only be shown where we have sourced the color definition file. This is set when we choose the color display. Selecting mono will ensure that the variable parameters are null and have no effect.</p>
<p>The complete script is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-62 image-border" src="assets/75571831-e4dd-4318-bd61-47d8dd661620.png" style="width:32.00em;height:14.75em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arithmetic operations using ((</h1>
                </header>
            
            <article>
                
<p>When using bash and some other advanced shells, we can make use of the <kbd>(( ))</kbd> notation to simplify mathematical operations with scripts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simple math</h1>
                </header>
            
            <article>
                
<p>The double parenthesis construct in bash allows for arithmetic expansion. Using this in the simplest format, we can easily carry out integer arithmetic. This becomes a replacement for the <kbd>let</kbd> built-in. The following examples show the use of the <kbd>let</kbd> command and the double parenthesis to achieve the same result:</p>
<pre><strong>$ a=(( 2 + 3 ))</strong><br/><strong>$ let a=2+3</strong></pre>
<p>In both cases, the <kbd>a</kbd> parameter is populated with the sum of <kbd>2 + 3</kbd>. If you want to write it on a shell script, you need to add a dollar sign before the parentheses:</p>
<pre><strong>#!/bin/bash</strong><br/><strong>echo $(( 2 + 3 ))</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parameter manipulation</h1>
                </header>
            
            <article>
                
<p>Perhaps a little more useful to us in scripting is the C-style parameter manipulation that we can include using the double parenthesis. We can often use this to increment a counter within a loop and also put a limit on the number of times the loop iterates. Consider the following command:</p>
<pre><strong>$ COUNT=1</strong><br/><strong>$ (( COUNT++ ))</strong><br/><strong>echo $COUNT</strong></pre>
<p>Within this example, we first set <kbd>COUNT</kbd> to <kbd>1</kbd> and then we increment it with the <kbd>++</kbd> operator. When it is echoed in the final line, the parameter will have a value of <kbd>2</kbd>. We can see the results in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-64 image-border" src="assets/7cf03547-dc20-44b4-8601-79f0c49c00ec.png" style="width:21.50em;height:6.08em;"/></div>
<p>We can achieve the same result in longhand by using the following syntax:</p>
<pre><strong>$ COUNT=1</strong><br/><strong>$ (( COUNT=COUNT+1 ))</strong><br/><strong>echo $COUNT</strong></pre>
<p>This of course allows for any increment of the <kbd>COUNT</kbd> parameter and not just a single unit increase. Similarly, we can count down using the <kbd>--</kbd> operator, as shown in the following example:</p>
<pre><strong>$ COUNT=10</strong><br/><strong>$ (( COUNT-- ))</strong><br/><strong>echo $COUNT</strong></pre>
<p>We start using a value of <kbd>10</kbd>, reducing the value by <kbd>1</kbd> within the double parentheses.</p>
<div class="packt_infobox">
<p>Note that we do not use the <kbd>$</kbd> to expand the parameters within the parentheses. They are used for parameter manipulation and, as such, we do not need to expand parameters explicitly.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Standard arithmetic tests</h1>
                </header>
            
            <article>
                
<p>Another advantage that we can gain from these double parentheses is with the tests. Rather than having to use <kbd>-gt</kbd> for greater than, we can simply use <kbd>&gt;</kbd>. We can demonstrate this in the following code:</p>
<pre><strong>$(( COUNT &gt; 1 )) &amp;&amp; echo "Count is greater than 1"</strong></pre>
<p>The following screenshot demonstrates this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-66 image-border" src="assets/65fa7cb8-2ece-45dd-abaf-9d71392808d6.png" style="width:42.00em;height:6.67em;"/></div>
<p class="mce-root">It is this standardization, both in the C-style manipulation and tests, that makes the double parenthesis so useful to us. This use extends to both the command line and scripts. We will use this feature extensively when we look at looping constructs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">Within this chapter, I really hope that we have introduced many new and interesting choices to you. This was an area with a wide range where we began by recapping the use of <kbd>test</kbd> and discovered that the <kbd>[</kbd> is a command not a syntax construct. The main effect that it is a command is on white space and we looked at the need to quote variables.</p>
<p class="mce-root">Even though we may commonly call variables variables, we have also seen that their correct name, especially in documentation, is parameters. Reading a variable is a parameter expansion. Understanding parameter expansion can help us understand the use of the keyword <kbd>[[</kbd>. The double square brackets are not commands and do not expand the parameters. This means that we do not need to quote variables even if they do contain white space. Moreover, we can use advanced tests with double square brackets, such as pattern matching or regular expressions.</p>
<p class="mce-root">Finally, we looked at arithmetic expansion and parameter manipulation using the double parenthesis notation. The biggest feature this delivers is the possibility to easily increment and decrement counters.</p>
<p class="mce-root">In the next chapter, we will move onto the looping constructs found in bash and make use of some of our new-found skills from this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How do you subtract 8 from 25 using shell scripting?</li>
<li>What is wrong with the following code? And how can you fix it?</li>
</ol>
<pre style="padding-left: 60px"><strong>$ rm my file</strong></pre>
<ol start="3">
<li class="mce-root">What is the problem with the following code?</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong><br/><strong>a=(( 8 + 4 ))</strong><br/><strong>echo $a</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Please see the following for further reading relating to this chapter:</p>
<ul>
<li><a href="http://tldp.org/LDP/abs/html/arithexp.html">http://tldp.org/LDP/abs/html/arithexp.html</a></li>
<li><a href="http://wiki.bash-hackers.org/commands/classictest">http://wiki.bash-hackers.org/commands/classictest</a></li>
</ul>


            </article>

            
        </section>
    </body></html>