<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Configuring Network Settings" id="aid-I3QM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Configuring Network Settings</h1></div></div></div><p>Sitting here feverishly typing away at the keyboard, I am reasonably hopeful that the title of this chapter may allude in some way to what we will cover. So, I am eager that it will not be too much of a shock when I reveal that we will discover how to configure networking on your RHEL 7 system in this chapter. However, breaking this down a little, we will look at a little more than just networking. Firstly, we will make sure that you are up to speed with how to gain administrative rights in Linux. Although, this has nothing to do with networking, gaining administrative rights becomes the ground for much of what we will do in the book. Once we have finished with the initial rights section, we will then quickly move on to investigate how networking is configured on RHEL 7. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Elevating privileges</li><li class="listitem">Using <code class="literal">ip</code> and <code class="literal">hostnamectl</code></li><li class="listitem">NetworkManager and network scripts</li><li class="listitem">Interacting with NetworkManager</li><li class="listitem">Using the Control Center</li><li class="listitem">Using the <code class="literal">nmtui</code> menu</li><li class="listitem">Interacting with <code class="literal">nmcli</code></li></ul></div><div class="section" title="Elevating privileges"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Elevating privileges</h1></div></div></div><p>As an administrator of the <a id="id14" class="indexterm"/>RHEL server or desktop system, there will be times when root access will be required. The <code class="literal">root</code> user or user ID <code class="literal">0</code> is the local administrator on the system. Although it's possible to log in to the system as a <code class="literal">root</code> user, as with most systems, it's preferred that <code class="literal">root</code> access is gained as required. There are two mechanisms that can be used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The substitute user or the <code class="literal">su</code> command</li><li class="listitem">Using the <code class="literal">sudo</code> command</li></ul></div><p>First, we will look <a id="id15" class="indexterm"/>at the <code class="literal">su</code> command.</p><div class="section" title="The su command"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>The su command</h2></div></div></div><p>When a user issues the <code class="literal">su</code> <a id="id16" class="indexterm"/>command without specifying a username, they will be prompted for the root password. If authentication is successful, they will be presented with a root shell. The following are the valid mechanisms to gain root privileges with <code class="literal">su</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">su -l</code>: This presents a <a id="id17" class="indexterm"/>full login shell for root; all environment variables are set for root. The working directory of a user is changed to become the home directory of the root user, which is usually <code class="literal">/root</code>.</li><li class="listitem"><code class="literal">su</code>: This is the same as <code class="literal">su -l</code>.</li><li class="listitem"><code class="literal">su</code>: This presents a nonlogin shell, where the full profile or environment of the root user is not loaded. The result is that some variables—such as <code class="literal">$USER</code>—are not reset and the current directory remains unchanged. Although presented with the nonlogin shell, the correct root password is still required for authentication.</li></ul></div><p>Using the <code class="literal">su</code> command is a simple way to gain rights. This may be a convenient option for an administrator. For a small environment, this may be acceptable; however, within an enterprise environment, this is not often viable because auditing is limited. It's possible to trace who used the <code class="literal">su</code> command to gain rights; this will be recorded in the <code class="literal">/var/log/secure</code> log file. As all activities from this point forward will be logged as <code class="literal">root</code>, we have no granularity to understand which administrator ran any particular command. The other big downside with this method is that the user will need to know the root password. This again is a big security issue and a complete no-no as far as I am concerned.</p><p>Although we <a id="id18" class="indexterm"/>want to use the <code class="literal">su</code> command, we can control who has access to <code class="literal">su</code> using <span class="strong"><strong>PAM</strong></span> (<span class="strong"><strong>Pluggable Authentication Modules</strong></span>) in conjunction with the <code class="literal">wheel</code> group. By adding users to the special administrative group: <code class="literal">wheel</code>, we can limit access to the <code class="literal">su</code> command to members of that group.</p><p>To add users to the <code class="literal">wheel</code> group, you will need to run <code class="literal"># usermod -a -G wheel &lt;username&gt;</code> as root user, where <code class="literal">&lt;username&gt;</code> is the login name of the account that should be added to the <code class="literal">wheel</code> group. The <code class="literal">-a</code> option is used to append a group to the user's current group membership list.</p><p>To ensure that only members of the <code class="literal">wheel</code> group use the <code class="literal">su</code> command, you must, as <code class="literal">root</code>, edit the <code class="literal">/etc/pam.d/su</code> PAM configuration file. Open the file in your desired text editor—such as <code class="literal">vi</code> or <code class="literal">nano</code>—and uncomment the following line by deleting the <code class="literal">#</code> character from the start of the line:</p><div class="informalexample"><pre class="programlisting">#auth required pam_wheel.so use_uid</pre></div><p>With this change in effect, only members of the <code class="literal">wheel</code> administrative group will be able to use the <code class="literal">su</code> command in order to switch to another user ID.</p><p>Should you so wish, you can make a second change to the <code class="literal">/etc/pam.d/su</code> PAM file in order to ensure easy access to <code class="literal">su</code> for members of the <code class="literal">wheel</code> group. The recommendation for this file will be limited to systems—such as classroom or lab machines—where security is not an issue.</p><p>Edit the <code class="literal">/etc/pam.d/su</code> file and uncomment the following line by deleting the <code class="literal">#</code> character from the start of the line:</p><div class="informalexample"><pre class="programlisting">#auth sufficient pam_wheel.so trust use_uid</pre></div><p>With this change in place, members of the <code class="literal">wheel</code> group are not required to authenticate with a password while using <a id="id19" class="indexterm"/>
<code class="literal">su</code>; this is the default behavior of root.</p><div class="note" title="Note"><h3 class="title"><a id="tip03"/>Tip</h3><p>Both these PAM edits are consistent across Red Hat variants that we have discussed: RHEL 7, CentOS 7, and Fedora 21. Additionally, by default, the <code class="literal">root</code> user is part of the <code class="literal">wheel</code> group.</p></div></div><div class="section" title="Delegating with the sudo command"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Delegating with the sudo command</h2></div></div></div><p>In my opinion, using the <a id="id20" class="indexterm"/>
<code class="literal">sudo</code> system is another approach and a more secure way of delegating administrative privileges. This system serves as a mechanism of preceding administrative commands with <code class="literal">sudo</code> and fine-grained delegation through the <code class="literal">/etc/sudoers</code> file.</p><p>Once users are trusted and tasks are delegated to them in the <code class="literal">/etc/sudoers</code> file, they can then run commands trusted to them using <code class="literal">sudo</code>. The basic command syntax is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo &lt;command&gt;</strong></span>
</pre></div><p>In the preceding example, <code class="literal">&lt;command&gt;</code> will be replaced by the administrative command normally reserved for root user, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo useradd bob</strong></span>
</pre></div><p>The command string listed previously allows a trusted user to create a new user account: <code class="literal">bob</code>. It will be normal for a user to be prompted for their password when a command with <code class="literal">sudo</code> is first run. The system defaults to cache their credentials for 5 minutes. In this way, should they need to run several commands as a root user using <code class="literal">sudo</code> over a short time period, they will be prompted just once for their password.</p><p>With <code class="literal">sudo</code>, we do not need to divulge the root user's password to our administrators or delegate a specific command or group of commands to individuals or groups.</p><p>To delegate rights for a user called <code class="literal">sally</code> to be able to run the <code class="literal">useradd</code> command along with the <code class="literal">passwd</code> command, an entry can be added to the <code class="literal">/etc/sudoers</code> file. We can also prevent <code class="literal">sally</code> from changing the root password within the same entry. This will be similar to the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sally ALL=(root) /sbin/useradd, /bin/passwd , !/bin/passwd root</strong></span>
</pre></div><p>Editing should be implemented as <code class="literal">root</code> using the <code class="literal">visudo</code> command. In this way, changes are verified before they are saved (preventing corruption of the file). More detailed configuration examples can be obtained by consulting the <code class="literal">man</code> pages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ man sudoers</strong></span>
</pre></div><p>By default, with <code class="literal">sudo</code>, members of the <code class="literal">wheel</code> administrative group are permitted to run all commands without any additional administrative effort.</p><p>To elevate security in <a id="id21" class="indexterm"/>order to acquire the password of the user to be entered for each <code class="literal">sudo</code> command and overwrite the default timeout of 5 minutes, use <code class="literal">visudo</code> and add the following line to the <code class="literal">/etc/sudoers</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Default    timestamp_timeout=0</strong></span>
</pre></div><p>For the rest of the book, administrative commands will be run as a standard user and prefixed with the <code class="literal">sudo</code> command. The user will be a member of the <code class="literal">wheel</code> group. In this manner, we hope to set best practice with security at the heart of your thinking.</p></div></div></div>
<div class="section" title="Using ip and hostnamectl"><div class="titlepage" id="aid-J2B82"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Using ip and hostnamectl</h1></div></div></div><p>Many <a id="id22" class="indexterm"/>administrators on Linux have become used to using the <code class="literal">ifconfig</code> command in order to display and set IP addresses on Linux hosts. Although the <code class="literal">ifconfig</code> <a id="id23" class="indexterm"/>command is still valid, it's marked as obsolete in favor of the <code class="literal">ip</code> command. For Microsoft Windows administrators who move to Linux, the use of <code class="literal">ifconfig</code> becomes the obvious choice. As <code class="literal">ipconfig</code> closely resembles the Windows command line, I encourage you to learn the ongoing <code class="literal">ip</code> command and all that it has to offer. Using either the <code class="literal">ifconfig</code> or <code class="literal">ip</code> command on RHEL 7 will also introduce new, consistent device names. This may come as a little shock to those used to <code class="literal">/dev/eth0</code>.</p><p>Finally, we will look at something very new to RHEL using the <code class="literal">hostnamectl</code> command. This can be used to set the <code class="literal">hostname</code> for the current session and persistently in a single shot, rather than using the <code class="literal">hostname</code> command and editing the <code class="literal">/etc/hostname</code> file.</p><div class="section" title="Consistent naming for network devices"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Consistent naming for network devices</h2></div></div></div><p>With the hardware that we have on servers and desktops, we now see far more use of multiport interface <a id="id24" class="indexterm"/>cards and <span class="strong"><strong>LOM</strong></span> (<span class="strong"><strong>LAN on motherboard</strong></span>) interfaces. If you rely on the more traditional <code class="literal">eth0</code> and <code class="literal">eth1</code> naming scheme, all this will <a id="id25" class="indexterm"/>lead to inconsistent network device naming.</p><p>Within RHEL 7 and the related family of similar distributions, <code class="literal">udev</code> supports a number of different naming schemes for network devices. This defaults to the assignment of fixed names based on firmware, topology, and location information returned from the device itself. In this way, the naming is related to the physical device itself and remains consistent and predictable even in the advent of failed hardware that is replaced. What we need to achieve is the avoidance of any possibility of the <code class="literal">eth0</code> device becoming <code class="literal">eth1</code> and vice versa. The disadvantage is that the name can be longer and less easily remembered. With reference to the RHEL 7.1 system that we will use throughout the course of this book, the single Ethernet interface on the VMWare hosted system is named as <code class="literal">eno16777736</code>.</p><p>The naming aspect is managed by <code class="literal">systemd</code>, the new initialization daemon, and supports the following naming <a id="id26" class="indexterm"/>schemes when detecting hardware during the boot phase:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Scheme 1</strong></span>: This scheme specifies names that can incorporate firmware or the BIOS information returned from onboard devices. These names can take the form of <code class="literal">enoxxx</code> (letter <code class="literal">o</code> as in onboard). If this fails, the naming system falls back to scheme 2.</li><li class="listitem"><span class="strong"><strong>Scheme 2</strong></span>: This scheme specifies names that can incorporate firmware or the BIOS information returned from PCI Express slot cards. These names can take the form of <code class="literal">ensxxx</code>. If this fails, the naming system falls back to scheme 3.</li><li class="listitem"><span class="strong"><strong>Scheme 3</strong></span>: This scheme specifies names that can incorporate the physical location of the connector—such as the slot address—on the motherboard. These names can take the form of <code class="literal">enpxxx</code>. If this fails, the naming system falls back to scheme 5 (note that scheme 4 is optional).</li><li class="listitem"><span class="strong"><strong>Scheme 4</strong></span>: This scheme identifies names based on the <span class="strong"><strong>MAC</strong></span> (<span class="strong"><strong>Media Access Control</strong></span>) address of the <span class="strong"><strong>NIC</strong></span> (<span class="strong"><strong>Network Interface Card</strong></span>) and selected by the administrator by setting the <code class="literal">HWADDR</code> (hardware address) attribute in the network configuration file. These names take the form of the name supplied within the interface configuration file's <code class="literal">DEVICE</code> attribute. For example, if you want to rename a LOM interface card from <code class="literal">eno16777736</code> to <code class="literal">internal</code>, working as root, you <a id="id27" class="indexterm"/>will edit the <code class="literal">/etc/sysconfig/network-scripts/ifcfg-eno16777736</code> file. You will be required to add the <code class="literal">HWADDR</code> attribute and edit the <code class="literal">DEVICE</code> attribute so that the file reads similar to the following extract:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>HWADDR="00:0c:29:57:ef:c4" #Using the MAC address for your NICDEVICE="internal"</strong></span>
</pre></div></li><li class="listitem"><span class="strong"><strong>Scheme 5</strong></span>: If all else fails, the naming system will fall back to the traditional kernel unpredictable naming scheme, such as <code class="literal">eth0</code>, <code class="literal">eth1</code>, and so on.</li></ul></div><p>To summarize, each interface device will normally have a two character prefix. This denotes the protocol type of <a id="id28" class="indexterm"/>the NIC. The following list illustrates these prefixes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">en</code>: This denotes Ethernet</li><li class="listitem"><code class="literal">wl</code>: This denotes wireless LAN</li><li class="listitem"><code class="literal">ww</code>: This denotes Wide Area Wireless</li></ul></div><p>The character that follows the prefix denotes the naming scheme used and the type of hardware detected, as shown in the following table:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Position 3 of device name</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">o</code>
</p>
</td><td valign="top">
<p>This is the onboard device</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">s</code>
</p>
</td><td valign="top">
<p>This is the hot-plug slot</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">p</code>
</p>
</td><td valign="top">
<p>This is the PCI or USB device</p>
</td></tr></tbody></table></div></div><div class="section" title="A real-life network device naming example"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>A real-life network device naming example</h2></div></div></div><p>In order to <a id="id29" class="indexterm"/>show you the consistent network device naming system on a physical machine and a virtual machine we have been using so far, we will venture out to my Dell laptop that runs on the Fedora 21 workstation. This has a wired network card (which is not currently connected) and a wireless port (which is the active connection). Using the <code class="literal">ip address show</code> command, we can see two physical interfaces and the local or the <code class="literal">loopback</code> interface:</p><div class="mediaobject"><img src="../Images/image00192.jpeg" alt="A real-life network device naming example"/></div><p style="clear:both; height: 1em;"> </p><p>When we look at device names and ignore the local interface: <code class="literal">lo</code>, we see interface <code class="literal">2</code> as <code class="literal">enp9s0</code> and <a id="id30" class="indexterm"/>interface <code class="literal">3</code> as <code class="literal">wlp12s0</code>.</p><p>
<span class="strong"><strong>For Interface 2</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The wired Ethernet is <code class="literal">en</code></li><li class="listitem">The PCI bus address is <code class="literal">p9</code></li><li class="listitem">The slot number is <code class="literal">s0</code></li></ul></div><p>We can view this PCI device using the <code class="literal">lspci</code> command; the command and output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lspci | grep 09:00.0</strong></span>
<span class="strong"><strong>09:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5755M Gigabit Ethernet PCI Express (rev 02)</strong></span>
</pre></div><p>We can see this does relate to the physical device mentioned in the naming scheme (PCI Bus <code class="literal">9</code> and slot <code class="literal">0</code> in the Ethernet card).</p><p>
<span class="strong"><strong>For Interface 3:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The wireless Ethernet is <code class="literal">wl</code></li><li class="listitem">The PCI bus address is <code class="literal">p12</code></li><li class="listitem">The slot number is <code class="literal">s0</code></li></ul></div><p>Again, using <code class="literal">lspci</code> and <code class="literal">grep</code>, we can see this device. The PCI bus (<code class="literal">12</code>) in hexadecimal appears as <code class="literal">0c</code> from the output of <code class="literal">lspci</code> because this uses hexadecimal and the device naming scheme uses decimal values:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lspci | grep 0c:00.0</strong></span>
<span class="strong"><strong>0c:00.0 Network controller: Intel Corporation PRO/Wireless 3945ABG [Golan] Network Connection (rev 02)</strong></span>
</pre></div></div><div class="section" title="Disabling consistent network device naming"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Disabling consistent network device naming</h2></div></div></div><p>For simplicity, especially where you have a single interface, you may preferably use the traditional name (<code class="literal">eth0</code>). You may also have legacy software that requires this naming scheme. These <a id="id31" class="indexterm"/>legacy names can still be used, as you learned when using the naming scheme 4. Adding the <code class="literal">HWADDR</code> attribute to the network configuration file and either renaming the <code class="literal">/etc/syconfig/network-scripts/ifcfg-eth0</code> file or configuring the <code class="literal">DEVICE</code> name attribute with a value of <code class="literal">eth0</code> will help you achieve your goal.</p><p>To set this globally across the system for all interfaces, you will be required to use additional kernel parameters at boot time. This can be set via <code class="literal">GRUB2</code> in the <code class="literal">/etc/default/grub</code> file. The <code class="literal">GRUB_CMDLINE_LINUX</code> line should be changed to the following code, appending the <code class="literal">biosdevname</code> and <code class="literal">net.ifname</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /etc/default/grub</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00193.jpeg" alt="Disabling consistent network device naming"/></div><p style="clear:both; height: 1em;"> </p><p>Once the file is edited and saved, we can update the <code class="literal">GRUB2</code> configuration with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo grub2-mkconfig -o /boot/grub/grub.cfg</strong></span>
</pre></div><p>We then need to reboot our system to see that the view changes to interface names:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo shutdown -r now</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip04"/>Tip</h3><p>It's strongly recommended that you persevere with the consistent names and accept that this naming scheme addresses the inconsistent nature of device-naming that the traditional kernel names previously presented to administrators.</p></div><p>For the rest of this book, we will use the standard naming system associated with the single NIC on the <a id="id32" class="indexterm"/>RHEL 7.1 system, that is, <code class="literal">eno16777736</code>.</p></div><div class="section" title="Using the ip command to display configurations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Using the ip command to display configurations</h2></div></div></div><p>We started this <a id="id33" class="indexterm"/>chapter outlining with the fact that the preferred command to use to display and configure the IP address configuration from the command line on RHEL 7.1 is <code class="literal">ip</code>. The <code class="literal">ip</code> command is part of the <code class="literal">iproute</code> RPM package and replaces the now obsolete <code class="literal">ifconfig</code> command, which is part of the net-tools RPM. The <code class="literal">ifconfig</code> command is still installed, but <code class="literal">ip</code> is preferred.</p><p>We can display the IP address for all interfaces, using the <code class="literal">address show</code> option for the <code class="literal">ip</code> command. This can be implemented in one of the three ways, shown as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">$ ip address show</code></li><li class="listitem"><code class="literal">$ ip a s</code></li><li class="listitem"><code class="literal">$ ip a</code></li></ul></div><p>We start with the verbose use of options, where the full <code class="literal">address show</code> command is used. This can be abbreviated to <code class="literal">a s</code>, or as the default action is <code class="literal">show</code> for the address command, just use <code class="literal">ip a</code>. Extending this a little, we can display the IP address for just a single interface or a single protocol as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ip a s eno1677736</strong></span>
<span class="strong"><strong>$ ip -4 a s eno1677736</strong></span>
<span class="strong"><strong>$ ip -6 a s eno1677736</strong></span>
</pre></div><p>The following screenshot displays the command and output from the demonstration system when you view the IPv4 address for the configured NIC:</p><div class="mediaobject"><img src="../Images/image00194.jpeg" alt="Using the ip command to display configurations"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="tip05"/>Tip</h3><p>The use of the <a id="id34" class="indexterm"/>dynamic term within the third line of the <code class="literal">scope global dynamic eno16777766</code> output is indicative of an address assigned via <span class="strong"><strong>DHCP</strong></span> (<span class="strong"><strong>Dynamic Host Control Protocol</strong></span>).</p></div><p>To view the transmission statistics for this same interface, we change to the <code class="literal">link</code> option, as shown in the <a id="id35" class="indexterm"/>following command line and output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ip -s link show eno16777736</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00195.jpeg" alt="Using the ip command to display configurations"/></div><p style="clear:both; height: 1em;"> </p><p>We can already start to feel the flexibility associated with this command, but we are not restricted to just <code class="literal">link</code> and <code class="literal">address</code> as options. In the following commands, we first view the route table and <a id="id36" class="indexterm"/>then the <span class="strong"><strong>ARP</strong></span> (<span class="strong"><strong>Address Resolution Protocol</strong></span>) cache. Each command is shown in the verbose form and then short form. The shortened form is especially useful if you can't spell neighbor:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ip route show</strong></span>
<span class="strong"><strong>$ ip r</strong></span>
<span class="strong"><strong>$ ip neighbor show</strong></span>
<span class="strong"><strong>$ ip n</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip06"/>Tip</h3><p>The ARP cache displays the MAC addresses of the devices that you have connected to that exist on the same network.</p></div></div><div class="section" title="Using the ip command to implement configuration changes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Using the ip command to implement configuration changes</h2></div></div></div><p>As a stalwart <a id="id37" class="indexterm"/>at displaying the configuration information, the <code class="literal">ip</code> command is a dab hand at changing the IP address's dynamic configuration too, this time using <code class="literal">add</code> in place of <code class="literal">show</code>. For example, to add an additional IPv4 address to our interface, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo ip address add 192.168.140.3/24 dev eno16777736</strong></span>
</pre></div><p>We can now view this information using the <code class="literal">show</code> command we looked at previously, as shown in the following command and output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ip -4 a s eno16777736</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00196.jpeg" alt="Using the ip command to implement configuration changes"/></div><p style="clear:both; height: 1em;"> </p><p>When we look carefully at the output, we can see the DHCP address we had before and the additional address we have just applied. Although these settings have been added only for this session, on a restart of the network or interface, we will revert to the single DHCP assigned address.</p><p>To restart all interfaces using network services, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl restart network.service</strong></span>
</pre></div><p>If we have more than one interface in the system and we are using the NetworkManager service, which is <a id="id38" class="indexterm"/>the default interface, we can stop and start a single interface using the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nmcli dev disconnect eno16777736</strong></span>
<span class="strong"><strong>$ sudo nmcli con up ifname eno16777736</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip07"/>Tip</h3><p>There will be much more information on the <code class="literal">nmcli</code> command later in this chapter.</p></div><p>So, although we can add IP addresses dynamically to our running system, if we want the change or changes to be permanent, then we need to add the configuration information to the configuration file.</p></div><div class="section" title="Persisting network configuration changes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Persisting network configuration changes</h2></div></div></div><p>To change from the <a id="id39" class="indexterm"/>DHCP assigned address we are using on the demonstration RHEL 7.1 system, we will assign a static address in the network configuration file related to our <code class="literal">/etc/sysconfig/network-scripts/ifcfg-eno16777736</code> interface. To edit the text file, you can use your favored text editor: <code class="literal">vi</code> or <code class="literal">nano</code>; here, we will use <code class="literal">vi</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo vi /etc/sysconfig/network-scripts/ifcfg-eno16777736</strong></span>
</pre></div><p>After editing the file in the preceding command line, it should read similar to the following file content. Of course, with any pertinent information to your network being set as opposed to IP addresses, we use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>TYPE="Ethernet"</strong></span>
<span class="strong"><strong>BOOTPROTO="none" #Change from dhcp to none</strong></span>
<span class="strong"><strong>DEVICE="eno16777736" #use your device name</strong></span>
<span class="strong"><strong>ONBOOT="yes"</strong></span>
<span class="strong"><strong>PEERDNS="yes"</strong></span>
<span class="strong"><strong>PEERROUTES="yes"</strong></span>
<span class="strong"><strong>IPADDR="192.168.40.3" #use the IP Address that you want to assign</strong></span>
<span class="strong"><strong>NETMASK="255.255.255.0" #Use the appropriate subnet mask</strong></span>
<span class="strong"><strong>DNS1="192.168.40.2" #the address or your DNS server</strong></span>
<span class="strong"><strong>GATEWAY="192.168.40.2" #the default gateway to use</strong></span>
<span class="strong"><strong>DEFROUTE="yes"</strong></span>
<span class="strong"><strong>IPV4_FAILURE_FATAL="no"</strong></span>
<span class="strong"><strong>IPV6INIT="yes"</strong></span>
<span class="strong"><strong>IPV6_AUTOCONF="yes"</strong></span>
<span class="strong"><strong>IPV6_DEFROUTE="yes"</strong></span>
<span class="strong"><strong>IPV6_FAILURE_FATAL="no"</strong></span>
<span class="strong"><strong>NAME="eno16777736" #use your device name</strong></span>
<span class="strong"><strong>UUID="980c9e81-f018-42ae-9272-1233873f9135" #use your device UUID</strong></span>
<span class="strong"><strong>IPV6_PEERDNS="yes"</strong></span>
<span class="strong"><strong>IPV6_PEERROUTES="yes"</strong></span>
<span class="strong"><strong>IPV6_PRIVACY="no"</strong></span>
</pre></div><p>As always, take care when editing files. In reality, much of the file can stay as it is because we edit changes to just the following one line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>BOOTPROTO="none"</strong></span>
</pre></div><p>Add four new lines:</p><div class="informalexample"><pre class="programlisting">IPADDR="192.168.40.3" #use the IP Address that you want to assign
NETMASK="255.255.255.0" #Use the appropriate subnet mask
DNS1="192.168.40.2" #the address or your DNS server
GATEWAY="192.168.40.2" #the default gateway to use</pre></div><p>With the changes made and saved, we need to refresh NetworkManager using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nmcli connection reload</strong></span>
</pre></div><p>This will re-cache the network configuration files. With this done, we can stop and start the following interface:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nmcli dev disconnect eno16777736</strong></span>
<span class="strong"><strong>$ sudo nmcli con up ifname eno16777736</strong></span>
</pre></div><p>Alternatively, just restart the network service as we did before. This single command replaces three commands here. However, it disrupts all interfaces. So, the following command should <a id="id40" class="indexterm"/>only be used where we have a single interface:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl restart network.service</strong></span>
</pre></div><p>Now that we have a static IPv4 address configured for our interface, we will now see that we lose the keyword <code class="literal">dynamic</code> from the output from the <code class="literal">ip address show</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ip -4 a s eno16777736</strong></span>
</pre></div><p>We have now seen how we can successfully configure IPv4 settings from the command line and through configuration files. We will now move on to the final part of the network configuration: the hostname.</p></div><div class="section" title="Configuring the RHEL 7 hostname with hostnamectl"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Configuring the RHEL 7 hostname with hostnamectl</h2></div></div></div><p>With the <a id="id41" class="indexterm"/>advent of <code class="literal">systemd</code> on RHEL 7 and its derivatives, we have a brand new way to display and set the hostname using the <code class="literal">hostnamectl</code> command. The advantage of this tool is that the static name and the transient name can be configured in one step.</p><p>We will edit the <code class="literal">/etc/hostname</code> file and add the new static hostname. This is then read by the kernel at system startup and displayed as the transient hostname, which is often used as <a id="id42" class="indexterm"/>part of your BASH shell prompt. The transient hostname can be displayed and set using the <code class="literal">hostname</code> command. This was a two part process: using <code class="literal">hostname</code> to set the transient name maintained by the kernel and editing the <code class="literal">/etc/hostname</code> file to ensure that it persisted across reboots.</p><p>With RHEL 7, we have these two hostnames and a third hostname: the pretty name. The pretty name can display UTF-8 characters that allow you to embed spaces and apostrophes. The pretty name, when set, is stored in the <code class="literal">/etc/machine-info</code> file.</p><p>To display the configured hostname, the <code class="literal">hostnamectl</code> command can be used. The pretty name will only be displayed if the configured hostname contains characters that cannot make up part of the static hostname. In the same way, the <code class="literal">/etc/machine-info</code> file will only exist if the pretty name is used to store a name incompatible with the <code class="literal">/etc/hostname</code> file:</p><p>To display the <a id="id43" class="indexterm"/>hostname as a standard user, the <a id="id44" class="indexterm"/>following command can be issued:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ hostnamectl</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00197.jpeg" alt="Configuring the RHEL 7 hostname with hostnamectl"/></div><p style="clear:both; height: 1em;"> </p><p>As spaces are used in the hostname, the <span class="strong"><strong>Pretty hostname</strong></span> will show. The <span class="strong"><strong>Pretty</strong></span> and the <span class="strong"><strong>Static</strong></span> names relate to the <code class="literal">/etc/machine-info</code> and <code class="literal">/etc/hostname</code> file respectively and can be used in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /etc/machine-info /etc/hostname</strong></span>
</pre></div><p>The output for the preceding command line results in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PRETTY_HOSTNAME="Red Hat 7-1.tup.com"</strong></span>
<span class="strong"><strong>redhat7-1.tup.com</strong></span>
</pre></div><p>To configure the hostname using <code class="literal">hostnamectl</code>, we use the <code class="literal">set-name</code> option, as shown in the following command. This command does not need to be prefaced as <code class="literal">sudo</code> if the user is a member of the <code class="literal">wheel</code> administrative group, but the user will be prompted for their password. These permissions are configured using the policy kit:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ hostnamectl set-hostname "Red Hat 7.tup.com"</strong></span>
</pre></div><p>This will set all three names; to see the transient name, a new shell should be initiated by running <a id="id45" class="indexterm"/>the <code class="literal">bash</code> command. To set individual names, include the correct option to <code class="literal">hostnamectl</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>--transient</strong></span>
<span class="strong"><strong>--static</strong></span>
<span class="strong"><strong>--pretty</strong></span>
</pre></div></div></div>
<div class="section" title="Introduction to the Red Hat NetworkManager" id="aid-K0RQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Introduction to the Red Hat NetworkManager</h1></div></div></div><p>The <code class="literal">NetworkManager</code> <a id="id46" class="indexterm"/>service has been a part of RHEL since version 6 and in its simplest form allows users to configure network configuration settings (such as <a id="id47" class="indexterm"/>joining Wi-Fi networks). Of course, this is really necessary when we consider laptop users with a Fedora or an RHEL laptop. This service extends well beyond the GUI and to server products installed with or without the X Server environment.</p><p>The <code class="literal">NetworkManager</code> service that ships with RHEL 7 is a dynamic network control and configuration daemon to keep network interfaces active while they remain available. As we have seen, the <code class="literal">NetworkManager</code> service not only maintains support for the traditional <code class="literal">ifcfg-</code> file type, but also extends this support to additional profiles. In this way, we can easily have a static IP address configuration for your laptop for different offices that you may visit, rather than relying on DHCP on each site.</p><p>Configuration of the <code class="literal">NetworkManager</code> service can be maintained via the GUI control center or from the <code class="literal">nmtui</code> command line menu. We have also seen that we can avoid the menu, enabling scripting events from the command line, using the <code class="literal">nmcli</code> command.</p><p>To query the status of the <code class="literal">NetworkManager</code> service, we can use the <code class="literal">systemctl</code> utility, as shown in the following command and the associated output screenshot:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl status NetworkManager.service</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00198.jpeg" alt="Introduction to the Red Hat NetworkManager"/></div><p style="clear:both; height: 1em;"> </p><p>Users and administrators can interact with the NetworkManager service by using one of the following utilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The GNOME notification area icon</li><li class="listitem">The GNOME <a id="id48" class="indexterm"/>network settings control center</li><li class="listitem">The <code class="literal">nmtui</code> <a id="id49" class="indexterm"/>menu</li><li class="listitem">The <code class="literal">nmcli</code> <a id="id50" class="indexterm"/>command-line tool</li></ul></div></div>
<div class="section" title="Interacting with the NetworkManager using the Control Center" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Interacting with the NetworkManager using the Control Center</h1></div></div></div><p>If you are using <a id="id51" class="indexterm"/>RHEL, CentOS, or Fedora on a <a id="id52" class="indexterm"/>graphical environment, then with the GNOME control center, we can interact with the NetworkManger service. We can also access network settings from the notifications area icon. This can be seen in the following screenshot on the RHEL 7.1 system:</p><div class="mediaobject"><img src="../Images/image00199.jpeg" alt="Interacting with the NetworkManager using the Control Center"/></div><p style="clear:both; height: 1em;"> </p><p>To access the same, but through the control center, we can use the <span class="strong"><strong>SUPER</strong></span> key. In the search dialog box, we <a id="id53" class="indexterm"/>will enter <code class="literal">control network</code>, as seen in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00200.jpeg" alt="Interacting with the NetworkManager using the Control Center"/></div><p style="clear:both; height: 1em;"> </p><p>Once we have accessed <span class="strong"><strong>Network Settings</strong></span>, it's possible to simply disable all wireless interfaces with the traditional <span class="strong"><strong>Airplane Mode</strong></span>. In this way, you can be assured of not plummeting to your certain death during takeoff and landing and still enjoy your game of <span class="emphasis"><em>Candy Crush Saga</em></span>.</p><p>On the left-hand <a id="id54" class="indexterm"/>side panel, we can view the current known interfaces and the <span class="strong"><strong>Network proxy</strong></span> settings. Here, we can add web proxies if required. On the RHEL 7.1 system we are using in this book, we see two network interface groups on the left-hand side panel:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Wired</strong></span></li><li class="listitem"><span class="strong"><strong>Unknown</strong></span></li></ul></div><p>In the graphic, the <span class="strong"><strong>Wired</strong></span> interface represents my gigabit Ethernet card and the <span class="strong"><strong>Unknown</strong></span> interface represents the local loopback connection. If your system includes a wireless card, you may well see <span class="strong"><strong>Wi-Fi</strong></span> as an option too. While selecting the <span class="strong"><strong>Wired</strong></span> interface from the left-hand side panel, the right-side panel will display your current network profiles. As we have only one profile, the name of this profile is not shown, but this will represent the default system profile we configured previously in this chapter: <code class="literal">eno16777736</code>.</p><p>From the bottom of the right-side panel, we can create additional profiles with the <span class="strong"><strong>Add Profile</strong></span> button, whereas the gearwheel in the bottom right-side corner will allow you to alter the <a id="id55" class="indexterm"/>properties of the current profile. All <a id="id56" class="indexterm"/>of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00201.jpeg" alt="Interacting with the NetworkManager using the Control Center"/></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="Adding a new profile with the Control Center" id="aid-LTSU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Adding a new profile with the Control Center</h1></div></div></div><p>More useful for <a id="id57" class="indexterm"/>mobile systems, such as laptop devices and tablets, we may configure profiles to easily load network configuration information specific to the location where you use the device. For example, if you are using a laptop at home, you may have a specific static IP address set, whereas when at work, you may have a DHCP-assigned address. Profiles can handle this situation easily and effortlessly.</p><p>Using the <span class="strong"><strong>Add Profile</strong></span> button from the Network Settings control center, we are presented with the <span class="strong"><strong>New Profile</strong></span> dialog box. From the left-side panel, we can select an option from the following given options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Security</strong></span></li><li class="listitem"><span class="strong"><strong>Identity</strong></span></li><li class="listitem"><span class="strong"><strong>IPv4</strong></span></li><li class="listitem"><span class="strong"><strong>IPv6</strong></span></li></ul></div><p>We will create a new profile for DHCP for when at home; if you remember, we set a static IPv4 address earlier in the section using the traditional <code class="literal">ifcfg- script</code> located in the <code class="literal">/etc/sysconfig/network-scripts</code> directory. We will retain this setting and additionally allow ourselves to switch from the static address to DHCP and back as required.</p><p>Selecting the <span class="strong"><strong>Identity</strong></span> option from the left-side panel, we will set <span class="strong"><strong>Name</strong></span> to <code class="literal">home-DHCP</code>. From the drop-down list, choose <span class="strong"><strong>MAC Address</strong></span> associated with the interface that we want to assign to this profile. Finally, we can deselect the checkbox to <span class="strong"><strong>Connect automatically</strong></span> so that the default connection will still be the static assignment we chose earlier. We <a id="id58" class="indexterm"/>can manually select this profile as required. We can leave all the other settings as they are; this includes the automatic DHCP assignment of addresses for the <span class="strong"><strong>IPv4</strong></span> and <span class="strong"><strong>IPv6</strong></span> settings. Navigate to the bottom-right corner of the open dialog box and select the <span class="strong"><strong>Add</strong></span> button to create a profile. The following screenshot shows the settings that we have chosen:</p><div class="mediaobject"><img src="../Images/image00202.jpeg" alt="Adding a new profile with the Control Center"/></div><p style="clear:both; height: 1em;"> </p><p>Having created the new profile, we can easily select between two profiles using the GNOME notification panel, which simplifies the transition between differing networks. In the following screenshot, we can see the currently selected <span class="strong"><strong>eno16777736</strong></span> profile and how we can switch <a id="id59" class="indexterm"/>to the newly created <span class="strong"><strong>home-DHCP</strong></span> profile:</p><div class="mediaobject"><img src="../Images/image00203.jpeg" alt="Adding a new profile with the Control Center"/></div><p style="clear:both; height: 1em;"> </p><p>We have now seen how we can set the network profile information using graphical tools on RHEL 7.1. For those <a id="id60" class="indexterm"/>running on RHEL or Fedora without the X server, we can easily manage the <code class="literal">NetworkManager</code> connection using the <code class="literal">nmtui</code> ncurses menu.</p></div>
<div class="section" title="Interacting with the NetworkManager using nmtui" id="aid-MSDG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Interacting with the NetworkManager using nmtui</h1></div></div></div><p>Just as with the <a id="id61" class="indexterm"/>GUI profile management <a id="id62" class="indexterm"/>within the GNOME control center, we can use the text user interface provided by the <code class="literal">nmtui</code> command. This is the traditional blue screen command-line menu provided by the ncurses system. If the command is not available on your system, then it can be installed using <code class="literal">yum</code>, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo yum install NetworkManager-tui</strong></span>
</pre></div><p>Once installed, the NetworkManager menu can be accessed using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nmtui</strong></span>
</pre></div><p>If you are using PuTTY to connect to your server via SSH, then in order to ensure that the menu border show correctly, you should set the <span class="strong"><strong>Character set translation</strong></span> option to <span class="strong"><strong>UTF-8</strong></span>. This can be found in connection settings and <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Translation</strong></span>.</p><p>The <span class="strong"><strong>NetworkManager</strong></span> menu displayed on the RHEL 7.1 system used in this book looks clean, if <a id="id63" class="indexterm"/>a little simple, and is displayed in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00204.jpeg" alt="Interacting with the NetworkManager using nmtui"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">nmtui</code> command also offers shortcut wrappers to specific tasks within the menu. These take the form of the <code class="literal">nmtui-edit</code>, <code class="literal">nmtui-connect</code>, and <code class="literal">nmtui-hostname</code> commands. The <a id="id64" class="indexterm"/>first two commands are useful when you already know the name of the connection profile you want to activate or edit, whereas the last command sets the hostname system-wide.</p><p>To activate the home-DHCP profile we created previously, we will issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nmtui-connect home-DHCP</strong></span>
</pre></div><p>This will effectively switch from the static IP address to the automatically allocated DHCP address. You should issue this command from the console and not remotely as you will lose your connection when the address is changed from static to DHCP.</p><p>This can also be used to connect to a new Wi-Fi SSID, should you be geeky enough to be using a command line-only version of Fedora while at Starbucks:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nmtui-connect Coffee-Shop-Wifi</strong></span>
</pre></div><p>To change the properties of the same connection profile, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nmtui-edit home-DHCP</strong></span>
</pre></div><p>This will open up the <a id="id65" class="indexterm"/>property page for the <a id="id66" class="indexterm"/>homeDHCP connection profile in readiness for editing purposes. To open the hostname menu page for editing purposes, you can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nmtui-hostname</strong></span>
</pre></div></div>
<div class="section" title="Extreme interaction with NetworkManager using nmcli" id="aid-NQU21"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Extreme interaction with NetworkManager using nmcli</h1></div></div></div><p>For those <a id="id67" class="indexterm"/>who <a id="id68" class="indexterm"/>believe that the only true form of Linux is without the aid of menus, using solely the wisdom handed down to you through your Jedi parentage, we have the extreme sport of <code class="literal">nmcli</code>. Joking aside, working with the <code class="literal">NetworkManager</code> in this way, without interaction of menus, will allow you to make changes in scripts, which can then be implemented across many systems.</p><p>As a simple starter, we can use <code class="literal">nmcli</code> to scan for available Wi-Fi networks; the output should show you the Wi-Fi SSID and strength as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nmcli device wifi list</strong></span>
</pre></div><p>This procedure is greatly simplified compared to the traditional command-line mechanism we have used before to display SSIDs with the <code class="literal">iw</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo iw wlp12s0 scan | grep SSID</strong></span>
<span class="strong"><strong>        SSID: hobbit</strong></span>
<span class="strong"><strong>        SSID: virginmedia1671684</strong></span>
<span class="strong"><strong>        SSID: VM260970-2G</strong></span>
<span class="strong"><strong>        SSID: virginmedia9066074</strong></span>
<span class="strong"><strong>        SSID: Edinburgh2013</strong></span>
<span class="strong"><strong>        SSID: TALKTALK-4C89F0</strong></span>
</pre></div><p>The process with <code class="literal">nmcli</code> is simplified for us, as the <code class="literal">NetworkManager</code> can use the configured <code class="literal">polkit</code> permissions. These permissions or actions (using the <code class="literal">polkit</code> language) are configured by the system administrator and are not meant to be changed by users. The policy file is located at the <code class="literal">/usr/share/polkit-1/actions/org.freedesktop.NetworkManager.policy</code> location.</p><p>We can use <code class="literal">nmcli</code> to <a id="id69" class="indexterm"/>display configured <a id="id70" class="indexterm"/>permissions with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nmcli general permissions</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00205.jpeg" alt="Extreme interaction with NetworkManager using nmcli"/></div><p style="clear:both; height: 1em;"> </p><p>Should we want to be able to create a connection for the wired interface when it's up and available, we can do so with <code class="literal">nmcli</code>. This can also be easily scripted across many devices as and when required. Firstly, we create the connection profile, as shown in the following command and output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nmcli connection add con-name wired-home \</strong></span>
<span class="strong"><strong> ifname enp9s0 type ethernet ip4 192.168.0.8 gw4 192.168.0.1</strong></span>

<span class="strong"><strong>          Connection 'wired-home' (e17cb6b7-685f-4cf2-9e8b-16cbfae1f73a) successfully added.</strong></span>
</pre></div><p>This command is greatly simplified when you know the fact that tab completion is enabled even for subcommands and values—such as <code class="literal">enp9s0</code>—that we add as a value to <code class="literal">ifname</code>.</p><p>To complete the task, we need to add the DNS configuration to the connection profile, which we can affect with the use of the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nmcli connection modify wired-home ipv4.dns "192.168.0.3 8.8.8.8"</strong></span>
</pre></div><p>We can now display the properties with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nmcli -p connection show wired-home</strong></span>
</pre></div><p>The <code class="literal">-p</code> option used here is for the pretty output; for the terse output, <code class="literal">-t</code> may be implemented. Either way, the output is too verbose to show as part of the book.</p><p>We have now replicated creating a connection profile that we first saw when we started with the control center. We <a id="id71" class="indexterm"/>do not pretend that this is <a id="id72" class="indexterm"/>easy, but being able to script this presents a multitude of options not available with any form of interactive menu, be that the text menu from <code class="literal">nmtui</code> or the GUI from the control center.</p></div>
<div class="section" title="Summary" id="aid-OPEK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, we have really established a baseline of knowledge that we need to begin to understand networking on the RHEL 7 family. To begin with, you learned how to gain and manage privileges on RHEL using <code class="literal">su</code> and <code class="literal">sudo</code>. Further, we looked at how to restrict the use of <code class="literal">su</code> to members of the <code class="literal">wheel</code> group with PAM. We have also begun our administration in the way that we mean to continue, using <code class="literal">sudo</code> to manage administrative tasks rather than logging in as root or using <code class="literal">su</code>.</p><p>With the ground knowledge of rights set, we moved on to understand the new naming conventions of network devices on the Red Hat release. We learned why it's preferred, compared to traditional names before moving on to the network configuration.</p><p>To configure network interfaces, we can use traditional <code class="literal">ifcfg-</code> scripts and these are used by default. We can extend this to additional network profiles that are probably most useful with mobile devices—such as laptops—that connect to different network locations. We saw how these can be configured in many different ways from menus to raw command-line tools.</p><p>Next up, we will look at how to configure key network services, such as DNS, DHCP, and SMTP.</p></div></body></html>