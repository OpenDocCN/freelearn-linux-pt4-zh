- en: Chapter 2. Setting Up Your CoreOS Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CoreOS can be installed on a variety of platforms such as bare metal servers,
    cloud provider's virtual machines, physical servers, and so on. This chapter describes
    in detail how to bring up your first CoreOS environment focusing on deploying
    CoreOS on a Virtual Machine. When deploying in a virtualization environment, tools
    such as Vagrant come in very handy in managing CoreOS virtual machines. **Vagrant**
    enables setting up CoreOS with multiple nodes even on single laptops or workstations
    easily with minimum configuration. Vagrant supports VirtualBox, a commonly used
    virtualization application. Both Vagrant and VirtualBox are available for multiple
    architecture, such as Intel or AMD, and operating systems such as Windows, Linux,
    Solaris, and Mac.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers setting up CoreOS on VirtualBox, VMware VSphere, and the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: VirtualBox installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoreOS on VMware VSphere setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GIT is used for downloading all the required software mentioned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GIT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the latest version of GIT installation as per the host operating system
    from [http://www.vagrantup.com/downloads.html](http://www.vagrantup.com/downloads.html).
    After the download is complete, start the installation. The installation of GIT
    using this procedure is useful for Mac and Windows. For all Linux distributions,
    the GIT client is available through its package manager. For example, if the operation
    system is CentOS, the package manager `yum` can be used to install GIT.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VirtualBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the latest version of VirtualBox as per the host operating system and
    architecture from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
    After the download is complete, start the installation.
  prefs: []
  type: TYPE_NORMAL
- en: During installation, continue with the default options. VirtualBox installation
    resets the host machine's network adapters during installation. This will result
    in the network connection toggle. After the installation is successful, Installer
    will print the status of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant provides a mechanism to install and configure a development, test, or
    production environment. Vagrant works with various virtualization applications
    such as VirtualBox, VMware, AWS and so on. All installation, setup information,
    configuration, and dependencies are maintained in a file and virtual machine can
    be configured and brought up using a simple Vagrant command. This also helps to
    automate the process of installation and configuration of machines using commonly
    available scripting languages. Vagrant helps in creating an environment that is
    exactly the same across users and deployments. Vagrant also provides simple commands
    to manage the virtual machines. In the context of CoreOS, Vagrant will help to
    create multiple machines of the CoreOS cluster with ease and with the same environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vagrant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download and install the latest version of Vagrant from [http://www.vagrantup.com/downloads](http://www.vagrantup.com/downloads).
    Choose default settings during installation.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Vagrant configuration file contains the configuration and provisioning information
    of the virtual machines. The configuration filename is `Vagrantfile` and the file
    syntax is `Ruby`. The configuration file can be present in any of the directory
    levels starting from the current working directory. The file in the current working
    directory is read first, then the file (if present) in one directory level back,
    and so on until `/`. Files are merged as they are read. For most of the configuration
    parameters, newer settings overwrite the older settings except for a few parameters
    where they are appended.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Vagrantfile` template and other associated files can be *cloned* from the
    GIT repository ([https://github.com/coreos/coreos-vagrant.git](https://github.com/coreos/coreos-vagrant.git)).
    Run the following command from the terminal to clone the repository. Note that
    the procedure to start a terminal may vary from OS to OS. For example, in Windows,
    the terminal for running GIT commands is by running `Git` `Bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A directory, `coreos-vagrant`, is created after `git clone`. Along with other
    files associated to the `Git` repository, the directory contains `Vagrantfile`,
    `user-data.sample`, and `config.rb.sample`. Rename `user-data.sample` to `user-data`
    and `config.rb.sample` to `config.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Vagrantfile` contains template configuration to create and configure the CoreOS
    virtual machine using VirtualBox. `Vagrantfile` includes the `config.rb` file
    using the `require` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Cloud-config
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**cloud config** files are special files that get executed by the `cloud-init`
    process when the CoreOS system starts or when the configuration is dynamically
    updated. Typically, the cloud config file contains the various OS level configuration
    of the docker container such as networking, user administration, systemd units
    and so on. For CoreOS, `user-data` is the name of the `cloud-config` file and
    is present inside the base directory of the `vagrant` folder. The `systemd units`
    files are configuration files containing information about a process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cloud-config` file uses the YAML file format. A `cloud-config` file must
    contain `#cloud-config` as the first line, followed by an associative array that
    has zero or more of the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`coreos`: This key provides configuration of the services provided by CoreOS.
    Configuration for some of the important services are described next:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etc2`: This key replaces the previously used `etc` service. The parameters
    for `etc2` are used to generate the systemd unit drop-in file for `etcd2` services.
    Some of the important parameters of the `etc2` configuration are:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discovery`: This specifies the unique token used to identify all the etcd
    members forming a cluster. The unique token can be generated by accessing the
    free discovery service ([https://discovery.etcd.io/new?sizhttp://e=<clustersize>](https://discovery.etcd.io/new?sizhttp://e=<clustersize>)).
    This is used when the discovery mechanism is used to identify cluster etcd members
    in cases where IP addresses of all the nodes are not known beforehand. The token
    generated is also called the discovery URL. The discovery service helps clusters
    to connect to each other using `initial-advertise-peer-urls` provided by each
    member by storing the connected etcd members, the size of the cluster, and other
    metadata against the discovery URL. For more information regarding forming the
    CoreOS cluster, refer to [Chapter 3](part0026_split_000.html#OPEK1-31555e2039a14139a7f00b384a5a2dd8
    "Chapter 3. Creating Your CoreOS Cluster and Managing the Cluster"), *Creating
    Your CoreOS Cluster and Managing the Cluster*.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial-advertise-peer-urls`: This specifies the member''s own peer URLs that
    are advertised to the cluster. The IP should be accessible to all etcd members.
    Depending on accessibility, a public and/or private IP can be used.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`advertise-client-urls`: This specifies the member''s own client URLs that
    are advertised to the cluster. The IP should be accessible to all etcd members.
    Depending on accessibility, a public and/or private IP can be used.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`listen-client-urls`: This specifies the list of self URLs on which the member
    is listening for client traffic. All advertised client URLs should be part of
    this configuration.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`listen-peer-urls`: This specifies the list of self URLs on which the member
    is listening for peer traffic. All advertised peer URLs should be part of this
    configuration.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: On some platforms, the providing IP can be automated by using *templating feature*.
    Instead of providing actual IP addresses, the fields `$public_ipv4` or `$private_ipv4`
    can be provided.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$public_ipv4` is a substitution variable for the public IPV4 address of the
    machine.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$private_ipv4` is a substitution variable for the private IPV4 address of
    the machine.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is sample `coreos` configuration in the `cloud-config` file:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`fleet`: The parameters for fleet are used to generate environment variables
    for the fleet service. The fleet service manages the running of containers on
    clusters. Some of the important parameters of the fleet configuration are:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd_servers`: This provides the list of URLs through which etcd services
    can be reached. The URLs configured should be one of the `listen-client-urls`
    for etcd services.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`public_ip`: The IP address that should be published with the local machine''s
    state.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is a sample fleet configuration in the `cloud-config` file:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`flannel`: The parameters for flannel are used to generate environment variables
    for the flannel service. The flannel service provides communication between containers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locksmith`: The parameters for locksmith are used to generate environment
    variables for the locksmith service. The locksmith service provides reboot management
    of clusters.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`: These parameters manipulate settings related to how CoreOS instances
    are updated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Units`: These parameters specify the set of systemd units that need to be
    started after boot-up. Some of the important parameters of unit configuration
    are:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**name**: This specifies the name of the service.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**command**: This parameter specifies the command to execute on the unit: start,
    stop, reload, restart, try-restart, reload-or-restart, reload-or-try-restart.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**enable**: This flag (true/false) specifies if the Install section of the
    unit file has to be ignored or not.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**drop-ins**: This contains a list of the unit''s drop-in files. Each unit
    information set contains *name*, which specifies the unit''s drop-in files, and
    *content*, which is plain text representing the unit''s drop-in file.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is a sample unit configuration in the `cloud-config` file:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`ssh_authorized_keys`: This parameter specifies the public SSH keys that will
    be authorized for the core user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hostname`: This specifies the hostname of the member.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users`: This specifies the list of users to be created or updated on the member.
    Each user information contains name, password, homedir, shell, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write_files`: This specifies the list of files that are to be created on the
    member. Each file information contains path, permission, owner, content, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manage_etc_hosts`: This specifies the content of the `/etc/hosts` file for
    local name resolution. Currently, only localhost is supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The config.rb configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This file contains information to configure the CoreOS cluster. This file provides
    the configuration value for the parameters used by `Vagrantfile`. `Vagrantfile`
    accesses the configuration by including the `config.rb` file. The following are
    the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$num_instances`: This parameter specifies the number of nodes in the cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$shared_folders`: This parameter specifies the list of shared folder paths
    on the host machine along with the respective path on the member'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$forwarded_ports`: This specifies the port forwarding from the member to the
    host machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$vm_gui`: This flag specifies if GUI is to be set up for the member'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$vm_memory`: This parameter specifies the memory for the member in MBs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$vm_cpus`: This specifies the number of CPUs to be allocated for the member'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$instance_name_prefix`: This parameter specifies the prefix to be used for
    the member name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$update_channel`: This parameter specifies the update channel (alpha, beta,
    and so on) for CoreOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a sample `config.rb` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Starting a CoreOS VM using Vagrant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the `config.rb` and `user-config` files are updated with the actual configuration
    parameter, execute the command `vagrant up` in the directory where configuration
    files are present to start the CoreOS VM image. Once the `vagrant up` command
    is successfully executed, the CoreOS in the VM environment is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The VM is running. To stop this VM, you can run `vagrant halt` to shut it down
    forcefully, or you can run `vagrant suspend` to simply suspend the virtual machine.
    In either case, to restart it again, simply run `vagrant up`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up CoreOS on VMware vSphere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VMware vSphere is a server virtualization platform that uses VMware's ESX/ESXi
    hypervisor. VMware VSphere provides complete platform, toolsets and virtualization
    infrastructure to provide and manage virtual machines in bare metal. VMware vSphere
    consists of VMware vCenter Server and VMware vSphere Client. VMware vCenter Server
    manages the virtual as well as the physical resources. VMware vSphere Client provides
    a GUI to install and manage virtual machines in bare metal.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VMware vSphere Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the latest version of VMware vSphere Client installation as per the
    host operating system and architecture from [http://vsphereclient.vmware.com/vsphereclient/1/9/9/3/0/7/2/VMware-viclient-all-5.5.0-1993072.exe](http://vsphereclient.vmware.com/vsphereclient/1/9/9/3/0/7/2/VMware-viclient-all-5.5.0-1993072.exe).
    After the download is complete, start the installation. During installation, continue
    with the default options.
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is complete, open the VMware vSphere Client application.
    This opens a new GUI. In the **IP address** / **Name** field, enter the IP address/hostname
    to directly manage a single host. Enter the IP address/hostname of vCenter Server
    to manage multiple hosts. In the **User name** and **Password** field, enter the
    username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the latest version of the CoreOS image from [http://stable.release.core-os.net/amd64-usr/current/coreos_production_vmware_ova.ova](http://stable.release.core-os.net/amd64-usr/current/coreos_production_vmware_ova.ova).
    Once the download is complete, the next step is to create the VM image using the
    downloaded `ova` file. The steps to create the VM image are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the VMware vSphere Client application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter IP address, username and password as mentioned earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **File** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Deploy OVF Template**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This opens a new Wizard. Specify the location of the `ova` file that was downloaded
    earlier. Click on **Next.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the name of the VM and inventory location in the **Name and Location**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the host/server where this VM is to be deployed in the **Host/Cluster**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the location where the VM image should be stored in the **Storage**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the disk format in the **Disk Format** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next**. It takes a while to deploy the VM image.![Installing VMware
    vSphere Client](img/00011.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the VM image is deployed in the VMware server, we need to start the CoreOS
    VM with the appropriate `cloud-config` file having required configuration property.
    The `cloud-config` file in VMware vSphere should be specified by attaching a config-drive
    which is an `iso` file with filesystem labeled `config-2` by attaching CD-ROMs
    or new drives. The following are the commands to create the `iso` file in a Linux-based
    operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder, say `/tmp/new-drive/openstack/latest`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the `user_data` file, which is the `cloud-config` file, into the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `iso` file using the command `mkisofs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the `config-drive` file is created, perform the following steps to attach
    the `config` file to the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: Transfer the `iso` image to the machine wherein the VMware vSphere Client program
    is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open VMware vSphere Client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the CoreOS VM and go to the **Summary** tab of the VM as shown in the
    following screenshot:![Installing VMware vSphere Client](img/00012.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click over the **Datastore** section and click on **Browse Datastore**.
    This will open a new window called **Datastore Browser**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the folder named `iso`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Upload file to Datastore** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `iso` file in the local machine and upload the `iso` file to the
    **Datastore**.![Installing VMware vSphere Client](img/00013.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to attach the `iso` file as a `cloud-config` file for the
    VM. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **CoreOS VM** and right-click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **CD/DVD drive 1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right-hand side, select **Device Status** as **Connected** as well as
    **Connect at power on**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Datastore ISO File** and select the uploaded `iso` file from the
    data store.![Installing VMware vSphere Client](img/00014.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `iso` file is uploaded and attached to the VM, start the VM. The CoreOS
    VM the VMware environment is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux Containers, as described before, provide a lightweight or stripped-down
    version of OS within the host OS. Applications can be installed on Linux Containers
    and can be ported to any host OS supporting Linux Containers. A user doesn't have
    to care about releasing different software for different target machines. Multiple
    Linux Containers can be created on a host OS, thus providing the capability to
    run multiple instances of software on the same machine independent of each other.
    Imagine software using a large number of ports and a tedious configuration file.
    In a traditional approach, the user has to carefully create the configuration
    file for each instance so that they don't conflict with another instance. In Linux
    Containers, the same configuration file would work on all Container instances.
    This helps with faster deployment and simpler operation.
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers are primarily Linux Containers that are capable of running
    a single application by design. They have the capability to run on any machine
    with Docker installed. Docker can be installed over a variety of machines running
    different operating systems such as Linux or Mac and thus making the application
    portable. Let's understand some Docker concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker image is a read-only template. Usually, images contain an OS snapshot,
    but Docker images can contain anything, such as a database and OS or application.
    They are read only and are shared across multiple Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Images can be created from scratch, or from an existing image listed on docker
    hub. **Docker hub** is a public `Docker Registry` that hosts docker images that
    can be downloaded and used. We can also set up a private docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: Images have a unique ID and a unique human-readable name and tag pair. Images
    can be called, for example, `ubuntu:latest`, `ubuntu:precise`, `django:1.6`, `django:1.7`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Docker uses **Union File System** to combine layers of images to form a single
    Docker image. Union File System allows files and directories in different filesystems
    to be overlaid over a single filesystem. A docker image starts with the base image,
    usually a standard OS image over which other layers of images are appended. Each
    layer provides additional functionalities over the previous layers. Upon image
    changes, only impact layers need to be provided instead of the complete image.
  prefs: []
  type: TYPE_NORMAL
- en: Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Containers** are created from the Docker Image. Container holds everything
    required for an application to run, such as user files, metadata, user applications,
    and so on. To expose the service provided by the containers, Docker allows exposing
    specific ports of a container.'
  prefs: []
  type: TYPE_NORMAL
- en: Volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As described before, Docker images are layers of read-only Union filesystems.
    When we start a container, additionally a read-write layer is created over the
    top of the read-only layer as there may be a requirement to modify a file (for
    instance). When some modification is made, data is present in both the read-write
    and read-only layers. This is required so that the image used in the container
    remains unchanged. The scope of this read-write layer is only until the container
    exists. Once the container is deleted, the read-write layer is destroyed and the
    read-only (unchanged) image is available for reuse. **Volumes** provide a mechanism
    to manage data within and across containers. They also provide a mechanism to
    share data from the host machine to the container, thus enabling data to be outside
    the container. Data can be directly shared from the host folder or from another
    container. It's recommended to create a data-only container and share data from
    that container.
  prefs: []
  type: TYPE_NORMAL
- en: Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker containers can connect to each other using the network port mappings
    created while containers are created. This brings some element of hardcoding as
    the ports are preconfigured. Container links can also be used by linking the source
    container to the recipient container using container names. Docker exposes connectivity
    information for the source container to the recipient container through environment
    variables and by modifying the `/etc/hosts` file. The environment variables are
    prefixed with the link name and follow naming convention to help the recipient
    identify the interface details (such as protocol used, IP address, port, and so
    on). The `/etc/hosts` file is updated with the source container IP address and
    the hostname as the container name.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker can also be installed on a variety of platforms, virtual machines and
    cloud providers. Docker contains two components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Client: The user invokes Docker Client to start, stop, and manage the
    Docker container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Daemon: Docker Client interfaces with Docker Daemon to actually start,
    stop, and manage the Docker container. Docker Daemon can only run on Linux machines.
    So if Docker is installed on Windows or Mac, Docker Daemon runs inside Linux Virtual
    Machine (for instance, in VirtualBox).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways to create a Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker File and the Docker `build` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the pre-built docker images from dockerhub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sample Docker image using Docker File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to create Docker containers through Docker
    File. Docker File has obvious benefits. Docker File helps automate the build process,
    it can be version controlled for the project, and inline comments serve as help
    for beginners and many others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the simple Docker File that creates a docker image using the
    CentOS base image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Docker File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Docker File contains the instructions used by Docker to build the images. The
    Docker File takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The instructions are run in order. The lines beginning with `#` are treated
    as comments and are not executed. Environment variables can also be used as variables
    in instruction arguments. Some of the important instructions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`: This sets the base image for the Docker image. This is the first instruction.
    Arguments can be in any one of the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If `tag` or `digest` is not provided, the latest image is selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`RUN`: This instruction specifies the commands to be executed for building
    the container. Typical usages of `RUN` instructions are updating the base image
    with OS patches, installing specific packages, updating system configuration,
    and so on. Each command runs in a separate layer on top of the current image and
    committed. The committed image is then used for the next step. Arguments can be
    in any one of the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this form, `command` is executed within shell /`bin/sh -c`. Shell `/bin/sh
    –c` is the default `ENTRYPOINT` for docker:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this form, `command` is executed directly without invoking a shell.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ENTRYPOINT`: This specifies the executable and its corresponding parameters
    when docker is started. Any parameters that are passed during the starting of
    docker are appended to `ENTRYPOINT` and executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arguments can be in any one of the following formats:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ENTRYPOINT ["executable", "param1", "param2"]`: In this format, command is
    executed directly without invoking a shell.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT <command> <paramters>`: In this format, command is executed within
    shell `/bin/sh -c`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD`: This specifies the defaults (that is, executable, shell, and command-line
    parameters) for the containers to be executed when docker is started. This is
    different from `RUN` as `RUN` instructions are only executed during building an
    image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arguments can be in any one of the following format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CMD ["executable","param1","param2"]`: This format is used when `ENTRYPOINT`
    is not provided. Command is executed here without a shell.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD ["param1","param2"]`: This format is used when `ENTRYPOINT` is provided
    with a default command. The parameters provided here are appended to `ENTRYPOINT`
    and executed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD command param1 param2` (shell form): In this format, command is executed
    within shell `/bin/sh -c`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only one `CMD` instruction is executed. If multiple `CMD` instructions are provided,
    the last instruction is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`EXPOSE`: This specifies the list of listening ports on which Docker is listening.
    The format of this field is: `EXPOSE <port> [<port>...]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VOLUME`: This specifies the mount path in the container and the external directories
    from the host machine or volumes from another container. The format of this field
    is: `VOLUME <directory> [<directory>…]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling the Docker image from Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Docker Hub** is a community-driven docker image hosting service provided
    by Docker that has capabilities for public and private content. Already there
    are more than 100,000 images available in the Docker Hub registry. Instead of
    building docker images using Docker File, docker images can be directly downloaded
    from Docker Hub. The docker `pull` command is used to pull the images directly
    from Docker Hub and the format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running Docker Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by running an already existing system command from the Docker
    container. The Docker container in this example prints the system information
    and exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `run` parameter runs Docker containers. The image name is provided as `centos`.
    During the first run, if the image is not available in the local machine, the
    latest-version `centos` image is downloaded from the public image registry Docker
    Hub. Since no version of the image was specified, the latest version was chosen.
    If a specific version is required to be installed, it can also be provided, for
    example, `centos:6.6`. The `uname –a` command is then executed inside the container
    using the default `ENTRYPOINT` `/bin/sh -c`. After the command execution is completed,
    the container exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a more sophisticated Docker File container that executes the
    `RUN` instruction to install a package over the base image and listens for a TCP
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Port `12345` from the container is mapped to port `12344` on the host. If the
    host tries to connect on `12344`, a connection gets established on the container.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were able to set up and run CoreOS with a single machine
    using Vagrant and VirtualBox. We were also able to create and run Docker images.
    In due process, we familiarized ourselves with the important configuration files
    and their contents.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to set up a CoreOS cluster with multiple
    machines. We will also learn how machines are discovered and services are scheduled
    on those machines.
  prefs: []
  type: TYPE_NORMAL
