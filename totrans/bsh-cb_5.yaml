- en: Scripts for System Administration Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering and aggregating system information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering network information and connectivity diagnostics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring basic network connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring directories and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing and archiving files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating files from RAM to storage for log rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Linux iptables for a firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing SQL databases remotely or locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating SSH keys for password less remote access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and configuring cron jobs for task scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating users and groups systematically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about performing system administration tasks common to nearly
    all users and we'll be looking at logs, archiving them, job/task management, network
    connectivity, securing systems using a firewall (IPtables), monitoring directories
    for changes, and creating users. We will also acknowledge that users and administrators
    often have to access resources from other systems for resources such as SQL or
    they have to use SSH to log in to another system using only cryptographic keys—no
    passwords required!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also serves as a crash course on some critical components in today's
    computing environment: **networking**.  Users might not know what a port is, an
    IP address, or how to find **network interfaces** (**NICs**) on their computer.
    By the end of this chapter, beginners should be able to configure a network, and
    will have an improved level of competency when working with a network terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering and aggregating system information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss the `dmidecode` Linux tool, which will
    gather information about the system such as CPU information, server, memory, and
    networking.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, we need to remember a few concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use some commands that will give us information about the Kernel,
    Linux distribution, physical server information, system uptime, network information,
    memory information, and CPU information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using this, anyone can create scripts to gather system information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can get details about the Linux distribution that you are working on. These
    distributions have a release file that you can locate in the `/etc/` folder. Now,
    open a terminal and enter the following command to get the information regarding
    the Linux distribution you are working on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding option has an alternative, and the alternative is the version
    file that''s present in the `/proc` folder. So, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command to get the Kernel''s information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'System `uptime`: for information about this, create a script called `server_uptime.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will run the following commands to get the physical server''s information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will run the following command to get the CPU''s information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can get each CPU's information from the `cpuinfo` file, which is present
    in the `/proc` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network information: We are going to get the IP address by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the MAC address, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You may replace `ens33` with `eth0`, depending on your network interface's information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory information: To get the total number of slots, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the total populated slots, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the total unpopulated slots, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After running the `cat /etc/*-release` command, press *Enter* and you will
    get the output according to your Linux distribution. In my case, the output is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an alternate way to get system information. You can get the system
    information by running a version file from the `/proc` directory. After running
    the command, press *Enter*, and you will get the output according to your Linux
    distribution. In my case, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`uname` is the tool that we are using to gather this information. Press *Enter*
    after running the command and you will get the Kernel information. In my case,
    the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Execute the `$ bash server_uptime.sh` script—press *Enter* at the prompt and
    you will get the uptime of the server.
  prefs: []
  type: TYPE_NORMAL
- en: To get the physical server information, we used the `dmidecode` tool. The first
    command is used to get the manufacturer's information, the second command is to
    get the model name, and the third command gets the serial number. While running
    a `dmidecode` command, you must be the root user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output snippet will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To get each CPU’s information, we created a script. Execute the `$ sudo bash
    cpu_info.sh` script—press *Enter* at the prompt and you will get information for
    each CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output snippet will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Network information: We ran the `ip` command to get the IP address and MAC
    address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory information: We used the `dmidecode` tool to get the memory information
    such as the total number of slots, and the total populated and unpopulated slots.
    You must be the root user to run this command.'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering network information and connectivity diagnostics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to test IPv4's connectivity and write scripts
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, we need to remember a few concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The If..Else condition case in shell scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP address of the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`curl` command must be installed (you can install it by using the following
    command: `sudo apt install curl`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of this section is to show you how you can check network connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a terminal and create the `test_ipv4.sh`script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to test IP connectivity and DNS, create a script called `test_ip_dns.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, create a script called `test_web.sh` to test web connectivity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Execute the script as `$ bash test_ipv4.sh`. Here, we are checking the connection
    with the `8.8.8.8`  IP address. For that, we use the `ping` command in the `if`
    condition. If the condition is `true,` we will get the statement written and printed
    on the screen as an if block. If not, the statement in `else` will be printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the script as `$ bash test_ip_dns.sh`. Here, we are testing the connectivity
    using the hostname. We are also passing the `ping` command in the `if` condition
    and checking if the network is up or not. If the condition is `true`, we will
    get the statement written in an `if` block that's printed on the screen. If not,
    the statement in `else` will be printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the script as `$ bash test_web.sh`. Here, we are testing the web connectivity.
    We use the `case` statement here. We are using the curl tool in this case, which
    is used to transfer data to and from a server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring basic network connectivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to configure basic network connectivity using
    `wpa_supplicant`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, we need to remember a few concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether `wpa_supplicant` is installed or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should know the SSID and password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that you have to run your program as a root user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a script called `wifi_conn.sh` and write the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the script using `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Monitoring directories and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`inotify` is a tool in Linux which is used to report when a file system event
    occurs. Using `inotify`, you can monitor individual files or directories.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have the `inotify` tool installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a script called `inotify_example.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `inotifywait` command is mostly used in shell scripting. The main purpose
    of the inotify tool is to monitor the directories and new files. It also monitors
    the changes in the files.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing and archiving files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a difference between a compressed and an archive file. So, what is
    an archive file? It is a collection of files and directories that are stored in
    a single file. An archive file is not a compressed file.
  prefs: []
  type: TYPE_NORMAL
- en: What is a compressed file? This is a collection of files and directories stored
    in one file. It uses less disk space for storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to discuss two compression tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bzip2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have files to archive and compress.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s see how we can compress the files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at compression with the help of `bzip2`. Decide which
    file to compress and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `bzip2`, we can compress multiple files and directories at the same time.
    Just separate them by putting a space between each of them. You can compress it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use `zip` for compression. By using the zip compression tool,
    files are compressed individually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After running the preceding command, the file to be compressed or the directory
    to be compressed, such as `files_zip` will be compressed and you will get a compressed
    file called `file_name.zip`. The `-r` option includes all the files in the `files_dir`
    directory recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s discuss how to archive files:'
  prefs: []
  type: TYPE_NORMAL
- en: An archive file contains more than one file or directory. **Tar** is used to
    archive files without compression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two archiving modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-x`: extract an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c`: create an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f`: FILE name of the archive—you must specify this unless using tape drive
    for archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v`: Be verbose, list all files being archived/extracted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-z`: Create/extract archive with gzip/gunzip'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-j`: Create/extract archive with bzip2/bunzip2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-J`: Create/extract archive with XZ'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a TAR file, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are representing a file, which is created when we use the `tar`
    command. Its name is `filename.tar`. We can specify the directory or file in which
    we are putting archive files. We must specify it after inserting `filename.tar`.
    Multiple files and directories can archive at the same time, just leave a space
    between the file and directory names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After executing the preceding command, all the contents from work and school
    directories will be stored in the new file `filename.tar`.
  prefs: []
  type: TYPE_NORMAL
- en: After running the preceding command, all the contents from work and school subdirectories
    will be stored in the new file `filename.tar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is used to list the contents of a TAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the contents of a TAR file, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This command is used for extraction and it will not remove the TAR file. However,
    in your current working directory, you will find the unarchived contents.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**bzip2** is used to compress the files and folder at the same time. Just issue
    the command in the terminal and the files will be compressed. After the compression,
    the compressed file will get the extension `.bz2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**zip** compress the files individually and then collects them in a single
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: A TAR file is a collection of different files and directories, which combines
    them into one file. TAR is used for creating backups and archives.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating files from RAM to storage for log rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss the logrotate Linux tool. Using this
    tool, administration of systems becomes easy. The systems generate large number
    of log files. This allows for automatic rotation, removal, compression, and mailing
    of log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can handle each and every log file. We can handle them daily, weekly, and
    monthly. Using this tool, we can keep logs longer with less disk space. The default
    configuration file is `/etc/logrotate.conf`. Run the following command to see
    the contents of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use logrotator, you must be aware of the `logrotate` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to look at an example configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two options for managing log files:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new configuration file and store it in `/etc/logrotate.d/`. This configuration
    file will be executed daily along with other standard jobs. This will be with
    root privileges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new configuration file and execute it independently. This will execute
    with non-root privileges. This way, you can execute it manually, at whatever times
    you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding configuration to /etc/logrotate.d/
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will configure a web server. This puts information like `access.log`
    and `error.log` into the `/var/log/example-app`. It will act as a data user or
    group.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add some configuration to `/etc/logrotate.d/`, first open up a new file
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code in `example-app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the new configuration directives in this file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create 0640 www-data www-data`: After rotation, this will create a new empty
    log file with specified permissions for the owner and group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sharedscripts`: This means that configuration scripts are run only once per
    run instead of there being a rotation for each file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postrotate` to `endscript`: This particular block has a script that has code
    for running after the log file is rotated. Using this, our application can switch
    over to the newly created log file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can customize the `.config` file according to our needs and then save that
    file in `/etc/logrotate.d`. For that, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, logrotate will point the standard configuration
    file, and then it will be on debug mode. It will give us the information about
    the files which logrotate is handling.
  prefs: []
  type: TYPE_NORMAL
- en: Using Linux iptables for a firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to set up a firewall using iptables. **iptables**
    is the standard firewall software present in most Linux distributions. We are
    going to use these set of rules to filter the network traffic. You can protect
    the server from unwanted traffic by filtering the data packets by specifying the
    source or destination IP address, port addresses, protocol types, network interfaces,
    and so on. We can configure this for accepting, rejecting, or forwarding network
    packets.
  prefs: []
  type: TYPE_NORMAL
- en: Rules are arranged in chains. By default, there are three chains (input, output,
    and forward). The input chain handles incoming traffic, while the output chain
    handles outgoing traffic. The forward chain handles routing traffic. Each chain
    has a default policy to adhere to if network packets do not match any policy inside
    the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please check that the following requirements are satisfied before proceeding
    to the next activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Root privileges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH access (command line access to the server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you have gt and looptools installed in your Linux environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic skills for working on a Linux environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to see some of the `iptables` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to list all the rules that are set on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow incoming traffic from a specific port, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This rule will allow incoming traffic from port `4321`. The firewall needs to
    be restarted to make this rule effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `iptables`, you can block the incoming traffic. For that, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If any new rules are added in the `iptables`, we should save them first. Otherwise,
    after a system reboot, they will disappear. Run the following command to saving
    the `iptables` after adding new rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The default file where rules are saved might differ depending on which Linux
    distribution you are working on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can save rules in a specific file by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can restore these rules that are saved in the file. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using iptables, we can control the incoming traffic, drop the traffic on a specific
    port, and add new rules and save them.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing SQL databases remotely or locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to automate SQL queries by connecting
    to a server using a shell script. Bash scripting is used for automating things.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that `mysql`, `postgres`, and `sqlite` are installed. Ensure that
    the user is created in MySQL and that you have granted permission to that user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL queries in script: We are going to write a script called `mysql_version.sh`
    to get the latest version of MySQL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to create a script called `create_database.sh` to create
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLite queries in script: Now, we are going to create a `sqlite` database.
    You can create the `sqlite` database by simply writing `sqlite3` and a name for
    the database. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to create a table in the `sqlite` console. Enter `sqlite3
    testdb` and press *Enter—*you will see the sqlite3 console. Now, write the `create
    table` command to create a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Postgres queries in scripting: Now, we are going to check the postgresql database
    version. Here, `testdb` is our database name, which is what we created earlier.
    For that, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to create a table. For that, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are creating bash scripts to check the version of a database and to create
    a new database. In these scripts, we are using the root user and there is a password
    present right after `-p` for that user. You can use the `root` user or else you
    can create a new user, assign a password to it, and use that user in your scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SQLite software provides us with a simple command-line interface. Using this
    interface, we can manually enter and execute SQL commands. You can list the database
    using the dot (`.`) operator. `.databases` and `.tables` are used to list all
    the tables in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In PostgreSQL, first we are changing the user from student to postgres. Then,
    we enter `psql` to start the `postgres` command-line console. In that console,
    we must create the `testdb` database. To come out of the console, run the `\quit`
    command. Now, once again, start the `testdb` console by typing `psql testdb` and
    pressing *Enter.* Now, create a table in that database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating SSH keys for password less remote access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to log in without a password using
    SSH. **SSH** is an open source network protocol and is used to log in to the remote
    servers to perform some actions. We can use the SSH protocol to transfer files
    from one computer to another. SSH uses public key cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have SSH access.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we are going to create a SSH key. The `ssh-keygen` command is used to
    create a SSH key. Run the command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will copy the SSH public key to the remote host. Run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can log in to the remote host without a password. Run the `ssh` command
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Creating and configuring cron Jobs for task scheduling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to configure Cron Jobs. We are going
    to use crontab to set up a Cron Job.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your terminal and go to the `/etc` folder and check the `/cron` folders.
    You will see the following cron folders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/etc/cron.hourly`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/cron.daily`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/cron.weekly`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/cron.monthly`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we will copy our shell script into one the preceding folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you need to run your shell script to run daily, place it in the `cron.daily`
    folder. If you need to run it hourly, place it in the `cron.hourly` folder, and
    so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Example: Write a script and place it in the `cron.daily` folder. Make the script
    executable by giving the necessary permissions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the `crontab` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Enter* and it will ask for the editor of your type. By default, it will
    open `vi` editor. In my case, I selected `nano`. Now, create a `cron` command.
    The syntax for creating the `cron` command is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of minutes after the hour (0 to 59)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The hour in military time (24 hour) format (0 to 23)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The day of the month (1 to 31)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The month (1 to 12)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The day of the week (0 or 7 is Sunday, or use the appropriate name)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The command to run
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you enter `*` in all options before the script name, you script will execute,
    every minute of every hour, of every day of the month, of every month and every
    day in the week.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following line in your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can list the existing jobs by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove the existing Cron Job, delete the line that contains your Cron Job
    and save it. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used the `crontab` command to add and delete the Cron Job. Use the appropriate
    settings to execute your script daily, hourly, monthly, and weekly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating users and groups systematically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to create users and groups through
    a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create a script to add a user. The `useradd` command is used to
    create a user. We are going to use the `while` loop, which will read our `.csv`
    file, and we will use the `for` loop to add each user that's present in that `.csv`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script using `add_user.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have used `while` and `for` loops. The `while` loop will
    read our `.csv` file. It will create arrays for each column. We used `-d` for
    the home directory, `-s` for the bash shell, and `-p` for the password.
  prefs: []
  type: TYPE_NORMAL
