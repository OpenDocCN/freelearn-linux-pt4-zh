<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Putting It All Together"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Putting It All Together</h1></div></div></div><p>Over the past eight chapters, we've explored the elements and concepts of a full-featured home security system that you'd expect to have installed in your property. It's been presented in a modular fashion so that you can choose which features you want for your system, to allow you to make it as compact and basic or large and complex as you require.</p><p>Fundamentally, the idea behind a home security system is to detect whether particular zone inputs are triggered high or low by an external sensor, be that a switch, motion detector, or water detector. At the end of the day, as far as the control software is concerned, the type of sensor is irrelevant and the system software's job is to simply check the state of its inputs and alert accordingly.</p><p>In this final chapter, we're going to put all of the concepts together to come up with a security system framework and write the control scripts around it. This is what we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining a high-level overview of our system, detailing the connected elements</li><li class="listitem" style="list-style-type: disc">Building the entire modular security system framework control script, exploring the code in detail</li><li class="listitem" style="list-style-type: disc">Delving into some detailed shell scripting techniques to perform certain tasks</li><li class="listitem" style="list-style-type: disc">Learning how to make our system automatically start at boot-time</li><li class="listitem" style="list-style-type: disc">Preventing the burning out of our SD card by creating a RAM-based file system</li></ul></div><div class="section" title="Alarm system diagram"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec58"/>Alarm system diagram</h1></div></div></div><p>So that we don't get lost in this process, the first thing I recommend is to come up with a complete system diagram<a id="id375" class="indexterm"/> that we can follow. I do this for any system I design and put together <a id="id376" class="indexterm"/>so that it can be built in a structured way, and easily documented and modified.</p><p>For the home security system in this chapter, I have come up with the following system diagram that we will look to as a framework. The whole concept is designed to be modular, so you can come up with your own system to suit your requirements and implement<a id="id377" class="indexterm"/> it accordingly, using the scripts presented in this chapter.</p><div class="mediaobject"><img src="graphics/B04579_09_01.jpg" alt="Alarm system diagram"/><div class="caption"><p>The final home security system diagram</p></div></div><div class="section" title="Overview of the system elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec72"/>Overview of the system elements</h2></div></div></div><p>The preceding system <a id="id378" class="indexterm"/>diagram comprises the elements and modules<a id="id379" class="indexterm"/> that we have discussed in previous chapters. Here's a quick recap of these:</p><div class="section" title="A +12V power supply"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec23"/>A +12V power supply</h3></div></div></div><p>This is the primary power supply to our system, which we will obtain from an external mains adapter that could be<a id="id380" class="indexterm"/> <span class="strong"><strong>battery-backed</strong></span>. This supply needs to be smooth and regulated to ensure that it <a id="id381" class="indexterm"/>remains stable for the system as currently drawn.</p><p>All of the alarm wiring and sensors will be supplied with this power, as will peripherals such as sounders and bells, which usually operate from a 12V supply. <a class="link" href="ch05.html" title="Chapter 5. Adding a Passive Infrared Motion Sensor">Chapter 5</a>, <span class="emphasis"><em>Adding a Passive Infrared Motion Sensor</em></span> discussed the merits of using a 12V supply for the alarm circuits.</p></div><div class="section" title="A +3.3V power supply"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec24"/>A +3.3V power supply</h3></div></div></div><p>This supply is a regulated +3.3V supply for the digital port expander circuit; it also provides the logical alarm<a id="id382" class="indexterm"/> zone inputs via an opto-coupler. The +3.3V power supply can be derived from either the +12V supply (recommended), or the +5V supply from the Raspberry Pi's GPIO connector, using a voltage regulator chosen according to how much current you need.</p><p>
<a class="link" href="ch03.html" title="Chapter 3. Extending Your Pi to Connect More Things">Chapter 3</a>, <span class="emphasis"><em>Extending Your Pi to Connect More Things</em></span>, showed you how to build a +3.3V regulated supply.</p></div><div class="section" title="The opto-isolator input module"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec25"/>The opto-isolator input module</h3></div></div></div><p>This will isolate the +12V zone input power lines from the port expander and GPIO digital inputs, which <a id="id383" class="indexterm"/>should only have a maximum of +3.3V presented to them when triggered high.</p><p>The circuit for these opto-isolated input modules was discussed and shown in <a class="link" href="ch05.html" title="Chapter 5. Adding a Passive Infrared Motion Sensor">Chapter 5</a>, <span class="emphasis"><em>Adding a Passive Infrared Motion Sensor</em></span>.</p></div><div class="section" title="The port expander"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec26"/>The port expander</h3></div></div></div><p>The port expander is our main digital input/output system that will take the alarm zone inputs and transmit<a id="id384" class="indexterm"/> them to the Raspberry Pi using the I2C bus, or allow the Raspberry Pi to switch outputs on and off.</p><p>We built our MCP23017-based port expander circuit in <a class="link" href="ch03.html" title="Chapter 3. Extending Your Pi to Connect More Things">Chapter 3</a>, <span class="emphasis"><em>Extending Your Pi to Connect More Things</em></span> and configured the software for it in <a class="link" href="ch04.html" title="Chapter 4. Adding a Magnetic Contact Sensor">Chapter 4</a>, <span class="emphasis"><em>Adding a Magnetic Contact Sensor</em></span>.</p></div><div class="section" title="An arm/disarm switch"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec27"/>An arm/disarm switch</h3></div></div></div><p>The arm/disarm input overrides the arm/disarm <a id="id385" class="indexterm"/>
<span class="strong"><strong>soft-switch</strong></span> function on our web-based control panel, and is a switch (key, digital keypad, or otherwise) connected to GP0 directly on the <a id="id386" class="indexterm"/>Raspberry Pi's GPIO connector.</p><p>Remember to connect any switch circuit appropriately to the GPIO pin to avoid damage to your Raspberry Pi. This was discussed in <a class="link" href="ch02.html" title="Chapter 2. Connecting Things to Your Pi with GPIO">Chapter 2</a>, <span class="emphasis"><em>Connecting Things to Your Pi with GPIO</em></span>.</p></div><div class="section" title="Alarm outputs"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec28"/>Alarm outputs</h3></div></div></div><p>In our system, we have<a id="id387" class="indexterm"/> several output devices that are controlled by our Raspberry Pi via output driver circuits. We have an output for an entry/exit buzzer, an armed status LED, an alarm bell, and an alarm LED indicator.</p><p>These are switched on and off by our Raspberry Pi GPIO connector via driver circuits that allow us to drive high current and inductive loads using the GPIO pins. These driver circuits, based around TIP120 Darlington transistors, were discussed in <a class="link" href="ch06.html" title="Chapter 6. Adding Cameras to Our Security System">Chapter 6</a>, <span class="emphasis"><em>Adding Cameras to Our Security System</em></span> and <a class="link" href="ch08.html" title="Chapter 8. A Miscellany of Things">Chapter 8</a>, <span class="emphasis"><em>A Miscellany of Things</em></span>.</p></div></div></div></div>
<div class="section" title="Designing the control scripts"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec59"/>Designing the control scripts</h1></div></div></div><p>Before we start writing the scripts to control our alarm systems, it is probably a good idea to outline the <a id="id388" class="indexterm"/>
<span class="strong"><strong>high-level</strong></span> process for the system. The <a id="id389" class="indexterm"/>following <span class="strong"><strong>flow-chart</strong></span> helps us picture how our<a id="id390" class="indexterm"/> system should work, and the various logical decisions our script needs to make.</p><p>The flowchart might look a bit complicated with all its lines in different directions, but it's actually pretty linear and in a downward direction. Referring to the flowchart, it shows the following tasks that the control script will be doing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sitting quietly until the system is armed either by the hardware key switch or the web-based panel's soft switch.</li><li class="listitem" style="list-style-type: disc">When the system is first armed, it will sound the exit buzzer for a pre-determined amount of time before actually arming the system. This gives you a chance to leave the property or disarm the system again, before it starts monitoring the inputs.</li><li class="listitem" style="list-style-type: disc">Once the system is armed, the armed LED will be switched on and the system will wait to see if any of the alarm zone inputs are triggered. It will also wait to see if the alarm is disarmed on your return to the property. We can optionally put an entry timer in here on the entry zone to delay before triggering the alarm.</li><li class="listitem" style="list-style-type: disc">If the alarm is ultimately triggered, then the main alarm bell will be switched on, as well as the exit buzzer. The main bell should only sound for a while, depending on environmental restrictions in your neighborhood, and so, this will be <a id="id391" class="indexterm"/>switched off after a pre-defined period, but the internal buzzer will stay on.</li><li class="listitem" style="list-style-type: disc">When triggered, the system will then wait for you to disarm it, before resetting it.<div class="mediaobject"><img src="graphics/B04579_09_02.jpg" alt="Designing the control scripts"/><div class="caption"><p>The control script flowchart</p></div></div></li></ul></div></div>
<div class="section" title="Building the control script"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Building the control script</h1></div></div></div><p>Now that we have designed our system the way we want it to work, we can start writing our Bash <span class="strong"><strong>control script</strong></span>. As before, we'll locate our scripts in the folder, <code class="literal">/etc/pi-alarm</code>, which, you'll remember from <a class="link" href="ch07.html" title="Chapter 7. Building a Web-Based Control Panel">Chapter 7</a>, <span class="emphasis"><em>Building a Web-Based Control Panel</em></span>, is also where our Web-based control panel writes its configuration status file, <code class="literal">alarm.cfg</code> to. We'll be<a id="id392" class="indexterm"/> referring to that file in our scripts too.</p><p>In this script, we are going to use the<a id="id393" class="indexterm"/> <span class="strong"><strong>bc</strong></span> tool (the Bash command-line <span class="strong"><strong>calculator</strong></span>) to convert <span class="strong"><strong>hex</strong></span> values to <span class="strong"><strong>binary</strong></span>. It's not installed by default, so you'll need to get the package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get update</strong></span>
<span class="strong"><strong>$ sudo apt-get install bc</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>Our script file is quite long so, as before, you might want to sit on the sofa and write it on your laptop using something such as Notepad++. Remember, however, if you're using a PC, ensure that the end-of-line (EOL) format is converted to the Unix format, otherwise the Bash script won't run on the Pi when you copy it across. Notepad++ will do this for you.</p></div></div><div class="section" title="Exploring the script code"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec73"/>Exploring the script code</h2></div></div></div><p>I'm now going to<a id="id394" class="indexterm"/> walk you through the various sections of the control script code I've written, which will be used as a framework for our system. I say "framework" because, while it will provide you with a fully functional control script for the <a id="id395" class="indexterm"/>system, it can be modified and extended to suit your particular requirements.</p><p>The following code listings are all part of the single bash script, <code class="literal">alarm-control.sh</code>, that can be downloaded in full with comments from the Packt Publishing website.</p><div class="section" title="Declarations"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec29"/>Declarations</h3></div></div></div><p>We'll start off by<a id="id396" class="indexterm"/> setting up the <a id="id397" class="indexterm"/>various <span class="strong"><strong>control variables</strong></span> needed to track the system's state:</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
#/etc/pi-alarm/alarm-control.sh

ALM_BELL_DURATION=600    #duration in seconds the alarm bell should sound for
ALM_EXIT_DELAY=30    #entry/exit zone delay in seconds
ALM_KEY_ARMED=0    #status of the arm/disarm key switch
ALM_SYS_ARMED=0    #armed status of the system

ALM_ZONE_INPUT_READ=""      #this will store the value of the zone inputs read
ALM_ZONE_INPUT_STAT="00000000"    #binary representation of the inputs (b7-b0)
ALM_ZONE_INPUT_PREV=""      #previous zone input status
ALM_ZONE_TRIGGER=0    #this will be set to 1 if one or more zones is triggered
ALM_ZONES_STAT=(0 0 0 0 0 0 0 0)    #dynamic array of normalised zone status (z1 to z8 order) - 1 is triggered

STAT_RET_VAL=""    #return value from functions</pre></div><p>Because we could face the situation whereby a HIGH or a LOW input could represent a triggered zone, depending on its configuration and wiring, I have introduced an array of <span class="emphasis"><em>normalized</em></span> status flags in the variable, <code class="literal">ALM_ZONES_STAT</code>, which will be the definitive state as far as the <a id="id398" class="indexterm"/>script is concerned. We'll look at the function that deals with this later.</p></div><div class="section" title="Updating config settings"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec30"/>Updating config settings</h3></div></div></div><p>In <a class="link" href="ch07.html" title="Chapter 7. Building a Web-Based Control Panel">Chapter 7</a>, <span class="emphasis"><em>Building a Web-Based Control Panel</em></span>, we introduced the configuration file, <code class="literal">alarm.cfg</code>, which stores the system status and configuration for the benefit of the Web-based control panel. This file not only needs to be read by the main control script to get any settings made using the control panel, but also needs to be updated with status values from the main control script so that they can be presented back to the control panel, essentially exchanging <a id="id399" class="indexterm"/>data between the two sub-systems.</p><p>Therefore, we're going to include a helper function that contains the same code called by the Web page PHP script to update this file from the control panel:</p><div class="informalexample"><pre class="programlisting">#This helper function will update the alarm config
#file with the specified value (alarm.cfg) so that
#the Web panel can know the latest status
function almUpdateConfigSetting()
{
  #$1 - Setting Name
  #$2 - Setting Value
  sudo sed -i "s/^\($1\s*= *\).*/\1$2/" /etc/pi-alarm/alarm.cfg
}</pre></div></div><div class="section" title="Setting up the GPIO"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec31"/>Setting up the GPIO</h3></div></div></div><p>We now need to <a id="id400" class="indexterm"/>set up the Raspberry Pi's GPIO pins for our purposes, as outlined by the earlier system diagram. The following commands were first discussed in <a class="link" href="ch02.html" title="Chapter 2. Connecting Things to Your Pi with GPIO">Chapter 2</a>, <span class="emphasis"><em>Connecting Things to Your Pi with GPIO</em></span>:</p><div class="informalexample"><pre class="programlisting"># GPIO SET UP ###################################
#Set up the Raspberry Pi GPIO pins
#Refer to Chapter 2 for info
#D0 (GPIO17) Arm/Disarm Key Input
sudo echo 17 &gt; /sys/class/gpio/export
sudo echo in &gt; /sys/class/gpio/gpio17/direction

#D4 (GPIO23) Armed LED Output
sudo echo 23 &gt; /sys/class/gpio/export
sudo echo out &gt; /sys/class/gpio/gpio23/direction
sudo echo 0 &gt; /sys/class/gpio/gpio23/value

#D5 (GPIO24) Exit Buzzer Output
sudo echo 24 &gt; /sys/class/gpio/export
sudo echo out &gt; /sys/class/gpio/gpio24/direction
sudo echo 0 &gt; /sys/class/gpio/gpio24/value

#D6 (GPIO25) Alarm LED Output
sudo echo 25 &gt; /sys/class/gpio/export
sudo echo out &gt; /sys/class/gpio/gpio25/direction
sudo echo 0 &gt; /sys/class/gpio/gpio25/value

#D7 (GPIO4)  Alarm Bell Output
sudo echo 4 &gt; /sys/class/gpio/export
sudo echo out &gt; /sys/class/gpio/gpio4/direction
sudo echo 0 &gt; /sys/class/gpio/gpio4/value</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>Note that you can <a id="id401" class="indexterm"/>only <span class="strong"><strong>export</strong></span> a GPIO pin once, unless it has been subsequently <span class="strong"><strong>unexported</strong></span>. Therefore, you might see the error, <code class="literal">echo: write error: Device or resource busy</code>, if you re-run the script when it tries to export the pin again. You can safely ignore<a id="id402" class="indexterm"/> this.</p></div></div><p>We'll also throw in a few helper functions that will easily allow us to switch on or off various outputs to simplify<a id="id403" class="indexterm"/> the main code. I'm a big fan of implementing functions, however simple, as they keep the code modular, reusable, and simpler to read in most cases:</p><div class="informalexample"><pre class="programlisting">#This helper function will switch a specified GPIO output on or off
function almSetGPIOValue()
{
  #$1 - GPIO pin number
  #$2 - Value
  sudo echo $2 &gt; /sys/class/gpio/gpio$1/value
}
#Helper functions to switch on and off the outputs
function almSetArmedLED()
{
  #$1 - 0 or 1 (Off or On)
  almSetGPIOValue 23 $1
  echo "[ALM] Armed LED set to $1"
}
function almSetExitBuzzer()
{
  #$1 - 0 or 1 (Off or On)
  almSetGPIOValue 24 $1
  echo "[ALM] Exit Buzzer set to $1"
}
function almSetAlarmLED()
{
  #$1 - 0 or 1 (Off or On)
  almSetGPIOValue 25 $1
  echo "[ALM] Alarm Trigger LED set to $1"
}
function almSetAlarmBell()
{
  #$1 - 0 or 1 (Off or On)
  almSetGPIOValue 4 $1
  echo "[ALM] Alarm Bell set to $1"
}</pre></div><p>And, we'll add a helper function<a id="id404" class="indexterm"/> that will read the ARM switch status from the D0 (GPIO17) of the Raspberry Pi and from the web-console to see if the ARM soft switch has been set:</p><div class="informalexample"><pre class="programlisting">#this function returns whether the system is armed via
#either the web console or key switch
function almGetArmedSwitchStatus()
{
  STAT_RET_VAL="0"
  #read arm key switch input from 
  local L_VAL=$(sudo cat /sys/class/gpio/gpio17/value)
  if [ $L_VAL -eq 1 ]; then
    #system has been armed with key switch
    echo "[ALM] System ARMED with key switch"
    ALM_KEY_ARMED=1
    almUpdateConfigSetting "SYSTEM_ARMED" "1" #set system armed console flag
    STAT_RET_VAL="1"
  else
    #read system armed value from web console config file
    if [ $SYSTEM_ARMED == 1 ]; then
      echo "[ALM] System ARMED with web console"
      STAT_RET_VAL="1"
    fi
  fi
}</pre></div></div><div class="section" title="Setting up the I2C port expander"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec32"/>Setting up the I2C port expander</h3></div></div></div><p>The next few lines of code set up the I2C port expander to set all of the pins, on both Port A and Port B, as inputs. In our system here, we're only using Port A, but this allows us to have another 8 inputs if we<a id="id405" class="indexterm"/> want to expand our system. We originally looked at this in <a class="link" href="ch04.html" title="Chapter 4. Adding a Magnetic Contact Sensor">Chapter 4</a>, <span class="emphasis"><em>Adding a Magnetic Contact Sensor</em></span>:</p><div class="informalexample"><pre class="programlisting"># PORT EXPANDER SET UP ##########################
#Refer to Chapter 4 for more information about the I2C bus

#We will set up I/O BUS A as all inputs
sudo i2cset -y 1 0x20 0x00 0xFF

#Whilst we're not using BUS B in our system,
#we can set that up as all inputs too
sudo i2cset -y 1 0x20 0x01 0xFF</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>If you don't have your I2C port expander attached, then you'll see the following error when you try to run these commands: <span class="emphasis"><em>Error: Write failed</em></span>
</p></div></div></div><div class="section" title="Decoding the zone inputs status"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec33"/>Decoding the zone inputs status</h3></div></div></div><p>The next function is a big one—and key to our system. It will read the Port A value from the I2C port<a id="id406" class="indexterm"/> expander. It'll be returned as a hexadecimal value, so we need to convert this to a binary value with a 0 or 1 flag representing each input bit. We'll use the <code class="literal">bc</code> tool installed earlier to do this.</p><p>Once we have the status of each input bit, we then normalize the status by determining whether a 0 or a 1 determines a positive trigger. The resulting output is the array, <code class="literal">ALM_ZONES_STAT</code>, which contains the status of each zone—with a 1 representing a positive triggered zone de-facto:</p><div class="informalexample"><pre class="programlisting">#This function will read the port inputs and set the
#status of each zone
function almReadZoneInputs()
{
  #preserve previous zone status
  ALM_ZONE_INPUT_PREV=$ALM_ZONE_INPUT_STAT
  #read the 8-bit hex value of port a
  ALM_ZONE_INPUT_READ=$(sudo i2cget -y 1 0x20 0x12)

  if [[ $ALM_ZONE_INPUT_READ = *"Error"* ]]; then
    #An error occurred reading the I2C bus - set default value
    ALM_ZONE_INPUT_READ="0x00"
  fi

  #remove the 0x at the start of the value to get the hex value
  local L_HEX=${ALM_ZONE_INPUT_READ:2}
  #convert the hex value to binary
  local L_BIN=$(echo "obase=2; ibase=16; $L_HEX" | bc )
  #zero pad the binary to represent all 8 bits (b7-b0)
  ALM_ZONE_INPUT_STAT=$(printf "%08d" $L_BIN)

  echo "[ALM] Zone I/O Status: $ALM_ZONE_INPUT_STAT ($ALM_ZONE_INPUT_READ)"

  #check each zone input to see if it's in a triggered state
  #a triggered state may be either 1 or 0 depending on the input's configuration
  #you'll need to set the logic here accordingly for each input
  #the ALM_ZONES_STAT array contains the definitive trigger value for each input

  #zone 1 test (bit 0)
  local L_FLG=${ALM_ZONE_INPUT_STAT:7:1}
  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[0]=0; else ALM_ZONES_STAT[0]=1; fi

  #zone 2 test (bit 1)
  local L_FLG=${ALM_ZONE_INPUT_STAT:6:1}
  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[1]=0; else ALM_ZONES_STAT[1]=1; fi
  #zone 3 test (bit 2)
  local L_FLG=${ALM_ZONE_INPUT_STAT:5:1}
  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[2]=0; else ALM_ZONES_STAT[2]=1; fi

  #zone 4 test (bit 3)
  local L_FLG=${ALM_ZONE_INPUT_STAT:4:1}
  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[3]=0; else ALM_ZONES_STAT[3]=1; fi

  #zone 5 test (bit 4)
  local L_FLG=${ALM_ZONE_INPUT_STAT:3:1}
  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[4]=0; else ALM_ZONES_STAT[4]=1; fi

  #zone 6 test (bit 5)
  local L_FLG=${ALM_ZONE_INPUT_STAT:2:1}
  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[5]=0; else ALM_ZONES_STAT[5]=1; fi

  #zone 7 test (bit 6)
  local L_FLG=${ALM_ZONE_INPUT_STAT:1:1}
  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[6]=0; else ALM_ZONES_STAT[6]=1; fi

  #zone 8 test (bit 7)
  local L_FLG=${ALM_ZONE_INPUT_STAT:0:1}
  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[7]=0; else ALM_ZONES_STAT[7]=1; fi

  echo "[ALM] Zone Trigger Status: $ALM_ZONES_STAT[*]"
}</pre></div></div><div class="section" title="Initialization"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec34"/>Initialization</h3></div></div></div><p>Now that we have declared our module-level variables and helper functions, we will start our main routine. First, we'll initialize the system that clears the <code class="literal">SYSTEM_ARMED</code> status and reads in the initial <a id="id407" class="indexterm"/>settings from the config file:</p><div class="informalexample"><pre class="programlisting"># initialise system #########
echo "[ALM] Initialising system..."
almUpdateConfigSetting "SYSTEM_ARMED" "0" #clear system armed console flag
sleep 1
sudo cat /etc/pi-alarm/alarm.cfg
sleep 1
echo "[ALM] Initialising done"
#############################</pre></div></div><div class="section" title="The system monitoring loop"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec35"/>The system monitoring loop</h3></div></div></div><p>The script then jumps<a id="id408" class="indexterm"/> into a never-ending loop that will be the main control system, monitoring the arm/disarm status and, when armed, monitoring the zone input status and responding accordingly:</p><div class="informalexample"><pre class="programlisting"># loop continuously###########
while true
do

  # wait for system to be armed ###############
  echo "[ALM] Alarm now in STAND-BY state - waiting to be armed"
  almSetArmedLED 0 #switch off armed LED
  STAT_RET_VAL="0"
  while [[ $STAT_RET_VAL = "0" ]]; do  
    sleep 1
    #read the control panel status file
    . /etc/pi-alarm/alarm.cfg
    almGetArmedSwitchStatus #result is returned in STAT_RET_VAL
    echo -n "*" # indicate standby mode
  done
  #############################################</pre></div></div><div class="section" title="Arming the system"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec36"/>Arming the system</h3></div></div></div><p>When the system<a id="id409" class="indexterm"/> goes into the ARMED state, it will first switch on the exit buzzer and then wait for a pre-determined amount of time. This will give you time to leave the property or disarm the system:</p><div class="informalexample"><pre class="programlisting">  # perform exit delay ########################
  echo "[ALM] Alarm now in EXIT DELAY state"
  almSetExitBuzzer 1 #switch on exit buzzer
  COUNTER=$ALM_EXIT_DELAY
  while [[ $STAT_RET_VAL = "1" &amp;&amp; $COUNTER -gt 0 ]]; do
    sleep 1
    #read the control panel status file
    . /etc/pi-alarm/alarm.cfg
    almGetArmedSwitchStatus #result is returned in STAT_RET_VAL
    COUNTER-=1
    echo -n "X$COUNTER " # indicate exit mode
  done
  almSetExitBuzzer 0 #switch off exit buzzer
  #############################################

  # system now armed - monitor inputs #########
  ALM_SYS_ARMED=1
  echo "[ALM] Alarm now in ARMED state"  
  almSetArmedLED 1 #switch on armed LED

  #read the control panel status file
  . /etc/pi-alarm/alarm.cfg  
  almReadZoneInputs  # &gt; ALM_ZONES_STAT[x]</pre></div></div><div class="section" title="Monitoring the zones"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec37"/>Monitoring the zones</h3></div></div></div><p>Once armed, the system will monitor the zone inputs in a continuous loop until either the system is disarmed, or <a id="id410" class="indexterm"/>a zone input is triggered. When a zone is triggered, it will check against the <code class="literal">ZONE_ENABLE_n</code> configuration to see if that zone has been disabled (this is done in the Web-based control panel). If the zone is not disabled, then the alarm system is deemed triggered.</p><p>The <code class="literal">ZONE_STATUS_n</code> setting is also updated here so that the web-based control panel indicates which zone or zones have been triggered:</p><div class="informalexample"><pre class="programlisting">  #check each zone input to set if it's enable
  #and has been triggered  
  #NUM_ZONES setting is stored in alarm.cfg

  while [[ $ALM_SYS_ARMED -eq 1 ]]; do
    echo -n "A" #indicate armed mode

    ALM_ZONE_TRIGGER=0  
    for (( i=$NUM_ZONES; i&gt;0; i-- )); do  
      if [[ $ALM_ZONES_STAT[$i-1] -eq 1 ]]; then
        #zone has been triggered
        echo "[ALM] Zone $i TRIGGERED"
        E_VAR="ZONE_ENABLE_$i"
        E_VAL=`echo "$E_VAR"` #get zone enabled status loaded from alarm.cfg

        if [[ $E_VAL -eq 1 ]]; then
          #zone is enabled
          ALM_ZONE_TRIGGER=1 #set alarm triggered flag
          echo "[ALM] Zone $i ENABLED - alarm will be triggered"
          almUpdateConfigSetting "ZONE_STATUS_$i" "1" 

          ## YOU CAN INSERT CODE HERE TO TAKE CAMERA IMAGE IF YOU WANT##
          ## REFER BACK TO CHAPTER 6 ##

        fi
      fi
    done

    . /etc/pi-alarm/alarm.cfg
    almGetArmedSwitchStatus #result is returned in STAT_RET_VAL</pre></div></div><div class="section" title="Entry delay"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec38"/>Entry delay</h3></div></div></div><p>When an alarm zone is triggered, it will first check whether it was the entry/exit zone that was triggered. If it was, then the system will delay before sounding the main alarm to give you a chance to disarm<a id="id411" class="indexterm"/> the system. Only the entry buzzer will sound at this time:</p><div class="informalexample"><pre class="programlisting">    if [[ $ALM_ZONE_TRIGGER -eq 1 ]]; then
      # alarm has been triggered    
      almSetAlarmLED 1
      echo "[ALM] A zone has been triggered"
      
      #####################################
      # ZONE 1 is the ENTRY zone - if that's triggered then delay
      if [[ $ALM_ZONES_STAT[0] -eq 1 ]]; then
        # perform entry delay ###########
        echo "[ALM] Alarm now in ENTRY state"
        setExitBuzzer 1 #switch on entry/exit buzzer
        
        COUNTER=$ALM_EXIT_DELAY  
        STAT_RET_VAL="0"
        while [[ $STAT_RET_VAL = "1" &amp;&amp; $COUNTER -gt 0 ]]; do
          echo -n "E$COUNTER " #indicate entry mode
          sleep 1
          #read the control panel status file
          . /etc/pi-alarm/alarm.cfg
          almGetArmedSwitchStatus #result is returned in STAT_RET_VAL    
          COUNTER-=1
        done
      fi
      #####################################</pre></div></div><div class="section" title="Sounding the main alarm"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec39"/>Sounding the main alarm</h3></div></div></div><p>If, at this point, the system hasn't been disarmed, then we need to sound the main bell. We have a duration limit for sounding the bell to cater to environmental noise restrictions; we<a id="id412" class="indexterm"/> wouldn't want the alarm sounding for hours, annoying the neighbors until we got home. At this point, you can also add code from <a class="link" href="ch06.html" title="Chapter 6. Adding Cameras to Our Security System">Chapter 6</a>, <span class="emphasis"><em>Adding Cameras to Our Security System</em></span>, if you want to be sent an alert email to your mobile device:</p><div class="informalexample"><pre class="programlisting">      #####################################
      # STAY in TRIGGERED mode until system has been disarmed
      if [[ $STAT_RET_VAL = "1" ]]; then
        #alarm has not been disabled
        almSetAlarmBell 1 #switch on alarm bell
        echo "[ALM] Alarm now in TRIGGERED state"

        ## YOU CAN INSERT CODE HERE TO SEND YOU AN EMAIL IF YOU WANT##
        ## REFER BACK TO CHAPTER 6 ##

        COUNTER=0
        STAT_RET_VAL="0"
        while [[ $STAT_RET_VAL = "1" ]]; do
          echo -n "T$COUNTER " #indicate triggered mode
          sleep 1
          #read the control panel status file
          . /etc/pi-alarm/alarm.cfg
          almGetArmedSwitchStatus #result is returned in STAT_RET_VAL    
          
          COUNTER+=1
          if [[ $COUNTER -gt $ALM_BELL_DURATION ]]; then
            almSetAlarmBell 0 #switch off alarm bell            
            echo "[ALM] Bell has been switched OFF"
          fi          
        done
      fi
      #####################################</pre></div></div><div class="section" title="Disarming and resetting the system"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec40"/>Disarming and resetting the system</h3></div></div></div><p>When we disarm the <a id="id413" class="indexterm"/>system, we need to reset its status and <a id="id414" class="indexterm"/>complete the monitoring loop so that we can start all over again and wait for it to be re-armed:</p><div class="informalexample"><pre class="programlisting">      # alarm has been disarmed ##########
      echo "[ALM] Alarm has been DISARMED"
      ALM_SYS_ARMED=0
      almSetAlarmBell 0 #switch off alarm bell
      almSetExitBuzzer 0 #switch off exit buzzer
      almSetAlarmLED 0
      almSetArmedLED 0 #switch off armed LED
      
      #####################################
    fi

  done
  #############################################
  
done
#############################################</pre></div></div><div class="section" title="We're done (almost)…"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec41"/>We're done (almost)…</h3></div></div></div><p>And there we have it: a framework for an entire alarm control script on our Raspberry Pi. Additional features that you may want to implement within your script could include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sending a photo or <a id="id415" class="indexterm"/>video clip from a zone's camera when it's triggered</li><li class="listitem" style="list-style-type: disc">Sending an email alert with status details when the alarm has been triggered</li><li class="listitem" style="list-style-type: disc">Writing a regular log file recording historical status information</li><li class="listitem" style="list-style-type: disc">Adding additional environmental sensors to port B<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>Each of the script blocks is taken from the single script file, <code class="literal">alarm-control.sh</code>, so you should be able to put all of the described pieces together into one file to have a fully functional script.</p></div></div></li></ul></div><p>As always, before we can run it we need to give the script execute rights:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo chmod 777 /etc/pi-alarm/alarm-control.sh</strong></span>
</pre></div><p>After we copy the script to our Raspberry Pi, this is what we should see in our <code class="literal">/etc/pi-alarm</code> folder:</p><div class="informalexample"><pre class="programlisting">pi@raspberrypi ~ $ ls -1 /etc/pi-alarm
alarm.cfg
alarm-control.sh
update-alarm-setting.sh</pre></div></div></div></div>
<div class="section" title="Automatically starting the system"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Automatically starting the system</h1></div></div></div><p>Now, obviously, we<a id="id416" class="indexterm"/> don't want to have to manually start the alarm control script each time the Raspberry Pi boots up, for example, after a power failure—for a start, we may not even be there. Therefore, we need to set up our operating system so that it will automatically start up the <code class="literal">alarm-control.sh</code> script at boot time.</p><p>To do this, we need to edit the <code class="literal">rc.local</code> file using Nano:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nano /etc/rc.local</strong></span>
</pre></div><p>Before the line containing <code class="literal">exit 0</code>, insert the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo /etc/pi-alarm/alarm-control.sh &amp;</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>The <code class="literal">&amp;</code> symbol at the end of the line is important because it will then make the script run in a different process, otherwise the <code class="literal">rc.local</code> script would never exit.</p></div></div><p>Your <code class="literal">rc.local</code> file should<a id="id417" class="indexterm"/> now look something like this:</p><div class="informalexample"><pre class="programlisting">#!/bin/sh -e
#
# rc.local
#
# This script is executed at the end of each multiuser runlevel.
# Make sure that the script will "exit 0" on success or any other
# value on error.
#
# In order to enable or disable this script just change the execution
# bits.
#
# By default this script does nothing.

# Print the IP address
_IP=$(hostname -I) || true
if [ "$_IP" ]; then
  printf "My IP address is %s\n" "$_IP"
fi

sudo /etc/pi-alarm/alarm-control.sh &amp;
exit 0</pre></div><p>The operating system runs the <code class="literal">rc.local</code> script after the system boots up, so you can put anything in there that you want to happen automatically at this time.</p></div>
<div class="section" title="Preserving the SD card"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Preserving the SD card</h1></div></div></div><p>One final topic I want to share with you is that of preserving your Raspberry Pi's SD card. SD<a id="id418" class="indexterm"/> cards have a finite write cycle, and continuous writing to the card will eventually burn it out. If we're going to be writing lots of log file entries and taking lots of camera images, we will want to protect our SD card in order to maintain the integrity and reliability of our system; using the system RAM instead can help us with this.</p><div class="section" title="Creating a RAM-based file system"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec74"/>Creating a RAM-based file system</h2></div></div></div><p>Our Raspberry Pi has plenty of fast system RAM available to us (1Gb on the latest models) that isn't susceptible to this write burn-out issue. Therefore, I'm going to show you how to allocate some of it to create a temporary disk in memory, which we can write files to that we don't <a id="id419" class="indexterm"/>need kept on the SD card. Such files would include the, quite large, camera image files that will be emailed out of the system— which, therefore, don't need to be stored permanently. You should also consider any log files that are regularly written to, which would then be shipped off the <a id="id420" class="indexterm"/>system at regular intervals.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>Remember that this is a RAM-based file system, so content will be lost when the Raspberry Pi shuts down or reboots. So, don't store any data here that you want to persist after a restart.</p></div></div><p>Let's create a Bash script file called <code class="literal">setup-ramfs.sh</code>, and copy it to our <code class="literal">/etc/pi-alarm</code> folder:</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
#/etc/pi-alarm/setup-ramfs.sh

RAM_DISK="/ramfs"
RAM_DISK_SIZE=64M

# Create RAM Disk ##########################
if [ ! -z "$RAM_DISK" ]; then
  echo "[INIT] Creating RAM Disk... $RAM_DISK"
  mkdir -p $RAM_DISK
  chmod 777 $RAM_DISK
  mount -t tmpfs -o size=$RAM_DISK_SIZE tmpts $RAM_DISK/
  echo "[INIT] RAM Disk created at $RAM_DISK"  
fi
############################################</pre></div><p>
<code class="literal">setup-ramfs.sh</code> RAM disk creation script</p><p>Running the preceding script will create a RAM disk folder at <code class="literal">/ramfs</code>—you can treat it just like any other folder; it's just that it resides in the system memory rather than on the SD card:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /ramfs</strong></span>
<span class="strong"><strong>$ ls</strong></span>
</pre></div><p>You can call this script from the <code class="literal">alarm-control.sh</code> script as part of the initialization process by including the line:</p><div class="informalexample"><pre class="programlisting">. /etc/pi-alarm/setup-ramfs.sh</pre></div></div></div>
<div class="section" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec63"/>Conclusion</h1></div></div></div><p>The Raspberry Pi is a powerful little beast and a great platform for building low-cost, but highly capable, embedded systems. The interfaces built into its GPIO connector make it easy to bolt on modules using simple low-cost electronics and a bit of configuration to create very functional and flexible systems. The inclusion of a dedicated camera interface and networking interfaces give you everything you could possible need for an Internet-connected home security system.</p><p>I've covered a lot <a id="id421" class="indexterm"/>of topics in this book, and I could have gone on and on, but I hope that what I have presented has been done in a structured and methodical way, and has given you the tools and techniques to carry on this journey so that you are able to create the perfect home security system for your needs.</p><div class="section" title="Tips for building systems"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec75"/>Tips for building systems</h2></div></div></div><p>As a systems guy who has to work with many different technologies and disciplines on a day-to-day basis, I just want to leave you with the following thoughts to consider, if you choose to build upon the<a id="id422" class="indexterm"/> system we've put together in this book, which, of course, I hope you will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a high-level diagram of your proposed system first—a bit like the one I produced earlier in this chapter.</li><li class="listitem" style="list-style-type: disc">Define everything in a modular way so that you can build and test your system in small chunks. This makes it much easier to spot issues early on.</li><li class="listitem" style="list-style-type: disc">Building the system using smaller modules makes it easier to re-use and replace circuits and code, and don't be afraid to mix-and-match technologies using what's best for the individual module.</li><li class="listitem" style="list-style-type: disc">Don't try to re-invent the wheel—use existing code and circuit resources that are proven to work. This makes it much quicker to get things working and minimizes the number of times you have to hit your head against a brick wall. I call it blagging.</li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Summary</h1></div></div></div><p>Well, we've reached the end of our journey to build a fully functional and extensible home security system using the mighty Raspberry Pi mini-PC. In this final chapter, we put together all of the elements and concepts from the previous chapters to create a home security framework, both from a hardware and software perspective.</p><p>In particular, this chapter guided us toward building a modular framework for our home security system, implementing features that you would find in any commercially available system, and also things that you don't see out there. We walked through the complete control script, exploring its various sections and understanding how they fit into our system.</p><p>We also learned how to automatically start-up our home security system script when our Raspberry Pi boots up, and how data is shared between the Pi and the web-based control panel in real-time via the configuration file. Finally, we looked at how to prevent our SD card from burning out by creating a rather useful RAM-based temporary file system.</p></div></body></html>