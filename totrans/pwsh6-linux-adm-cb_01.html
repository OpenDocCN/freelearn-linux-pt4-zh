<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installation, Reference and Help</h1>
                </header>
            
            <article>
                
<p><span>In this chapter we're going to cover the following recipes:</span></p>
<ol>
<li>Installing PowerShell</li>
<li>Fetching help information in PowerShell</li>
<li>Fetching help information for a specific cmdlet</li>
<li>Updating help</li>
<li>Searching help for keywords</li>
<li>Looking for help information specific to a parameter</li>
<li>Exploring the <kbd>about_</kbd> topics</li>
<li>Discovering cmdlets</li>
<li>Finding modules</li>
<li>Installing modules from the repository</li>
<li>Listing the various providers in PowerShell</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>It all begins with the installation of PowerShell on your system. Installation of PowerShell is simple and straightforward. Since PowerShell is open source, its source code is available on the arguably largest platform for open source projects, GitHub. At the moment, Windows, Debian (and Ubuntu), RedHat Linux (and CentOS), Fedora and macOS are officially supported by <strong>the PowerShell project</strong>. Arch Linux and Kali Linux are supported by the community. Community support is also available for the AppImage edition of PowerShell that can be used on most of the modern-day Linux distributions.</p>
<div class="packt_infobox">An AppImage is a way of packaging applications to run on Linux distributions. Every application has its dependencies. On Linux, the package managers manage the installation of the dependencies while installing the packages. An AppImage package, on the other hand, packs all the necessary dependencies within itself. An AppImage can run in <strong>portable</strong> mode, or be installed on the system, based on user preference.</div>
<p>PowerShell is, as of writing of this chapter, experimentally available for Windows on ARM and Raspbian Stretch.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing PowerShell</h1>
                </header>
            
            <article>
                
<p>Basically, in Linux, it should be fairly simple to get the source code and build the application from the source code using make. This approach should work for PowerShell as well. However, as noted above, official support and community support are available only for a few distributions. We would focus on installing PowerShell on Ubuntu and CentOS since they are two of the most popular Linux distributions.</p>
<p>PowerShell is available in two releases: stable and preview. The stable releases are suitable for production environment since they're more reliable. The preview releases are for test environments where the administrators are allowed to feel a little adventurous, and are willing to report bugs they come across along with providing feedback on the capabilities.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Getting ready to install PowerShell on your computer is simple. You simply need a working Linux computer, which you have administrator privileges on. Depending on what mode you pick to install PowerShell, you may or may not need a package manager. Chances are, your Linux distribution already has a package manager available.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>As discussed, we will look at the procedure to install PowerShell on Ubuntu (and its derivatives) as well as CentOS (and its derivatives).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installation on Ubuntu</h1>
                </header>
            
            <article>
                
<p>There really are many ways to install PowerShell on your computer. Since we're installing PowerShell on Ubuntu, we shall look at two ways to do it. The first is by adding Microsoft's key and registering the repository and then using the Advanced Package Tool (APT) to install PowerShell, and the other, directly using the .deb package from GitHub.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing from the repository</h1>
                </header>
            
            <article>
                
<p>The last version of Ubuntu that PowerShell has an official package for is Ubuntu 17.04. If you have Ubuntu 17.04, use the steps below to install PowerShell. Otherwise, it is suggested that you use the direct download method.</p>
<ol>
<li>The first step is to import the GPG keys for the public repository:</li>
</ol>
<pre style="padding-left: 90px">curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -</pre>
<ol start="2">
<li>Now that the key has been added, register the repository---this repository is maintained by Microsoft.</li>
</ol>
<pre style="padding-left: 90px">sudo curl -o /etc/apt/sources.list.d/microsoft.list https://packages.microsoft.com/config/ubuntu/17.04/prod.list</pre>
<ol start="3">
<li>Update the package list using the following command.</li>
</ol>
<pre style="padding-left: 90px">sudo apt update</pre>
<ol start="4">
<li>Next, install PowerShell.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">sudo apt install -y powershell</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing via direct download</h1>
                </header>
            
            <article>
                
<p class="mce-root">Follow the steps below to install PowerShell on Ubuntu:</p>
<ol>
<li>Go to <a href="https://github.com/powershell/powershell">https://github.com/powershell/powershell</a>.</li>
<li>Scroll down to the table that contains the list of Linux distributions officially supported by the PowerShell team.</li>
<li>Click on the relevant link: <kbd>.deb</kbd> under Downloads (stable)—we will stick to the stable release.</li>
<li>Read the installation instructions if you need additional information.</li>
<li>Run the .deb file with <kbd>gdebi</kbd> or <kbd>eddy</kbd> or one such package installer to complete the installation.</li>
</ol>
<p class="mce-root">If you aren't running one of the distributions supported officially by the Team or by the community, use the AppImage. Follow steps 1 and 2 from above, and:</p>
<ol>
<li>Click on Many Linux distributions | AppImage to download the Ap-pImage file. An AppImage file is a an application, packaged with all the dependencies required to run the application.</li>
<li>Save the AppImage file at a convenient location.</li>
<li>Once the download completes, navigate to the download location and run the AppImage.</li>
<li>If you get a prompt asking if you would like PowerShell installed, choose the response appropriate to your environment.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installation on CentOS</h1>
                </header>
            
            <article>
                
<p>Installation of PowerShell on CentOS 7 (or RedHat 7) also has two methods: the repository and direct download. The process is similar to that of installation on Ubuntu Linux.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing from the repository</h1>
                </header>
            
            <article>
                
<p>To begin installation:</p>
<ol>
<li>First, register the Microsoft repository.</li>
</ol>
<pre style="padding-left: 90px">curl https://packages.microsoft.com/config/rhel/7/prod.repo | sudo tee /etc/yum.repos.d/microsoft.repo</pre>
<ol start="2">
<li>Next, install PowerShell using <kbd>yum</kbd>.</li>
</ol>
<pre style="padding-left: 90px">sudo yum install -y powershell</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing via direct download</h1>
                </header>
            
            <article>
                
<p class="mce-root">Follow the steps below to install PowerShell on CentOS:</p>
<ol>
<li>Go to <a href="https://github.com/powershell/powershell">https://github.com/powershell/powershell</a>.</li>
<li>Scroll down to the table that contains the list of Linux distributions officially supported by the PowerShell team.</li>
<li>Click on the relevant link: <kbd>.rpm</kbd> under Downloads (stable)—we will stick to the stable release.</li>
<li>Read the installation instructions if you need additional information.</li>
<li>Install the RPM package using the following command (assuming your download is at <kbd>~/Downloads</kbd> and your PWD is <kbd>~/Downloads</kbd>.</li>
</ol>
<pre style="padding-left: 90px">sudo yum install &lt;the-downloaded-file.rpm&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the AppImage package</h1>
                </header>
            
            <article>
                
<p>Using the AppImage is much simpler.</p>
<ol>
<li>Go to <a href="https://github.com/powershell/powershell">https://github.com/powershell/powershell</a>.</li>
<li>Scroll down to the Get PowerShell section, and find the AppImage link under community-supported distributions.</li>
<li>Download the AppImage and place it at a convenient location.</li>
<li>Run <kbd>chmod a+x PowerShell-&lt;version&gt;-&lt;architecture&gt;.AppImage</kbd> to make the AppImage executable.</li>
<li>Call the AppImage to run PowerShell. You may be asked if you'd like the AppImage installed on your computer. Select Yes if you would like that.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The package manager installs the package with all its dependencies and makes the relevant commands available for use.</p>
<p>In case of the AppImage package, the dependencies are all bundled into the package (including .NET Core), and the package can either run in portable mode on your computer, or can be installed and called. Launch PowerShell by running <kbd>pwsh</kbd> to take a look.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 2.5: Comparing Windows PowerShell and PowerShell</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Fetching Help Information in PowerShell</h1>
                </header>
            
            <article>
                
<p>Commands in PowerShell are called cmdlets (pronounced: command-lets). Cmdlets come pre-packaged with all the necessary help information, just like the help available for any of the Linux commands. The difference is that there's a separate cmdlet available to get you the necessary help; help is not a switch in PowerShell.</p>
<p>Before we begin, let's launch the Terminal (launch any of the terminal emulators available on your computer). Let's now type <kbd>pwsh</kbd> to call PowerShell. Proceed with the steps below once you get the PS prompt.</p>
<p>To get help information in PowerShell:</p>
<p>Enter <kbd>Get-Help</kbd> at the prompt to get an overview of the help system in PowerShell. You would see an output like this:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f608603b-ab54-460d-996d-23861db19141.png" width="1812" height="1044"/></div>
<p>PowerShell cmdlets are built with help information written in them. Running <kbd>Get-Help</kbd> without any arguments would simply show you basic information on help available in PowerShell, which is not quite remarkable. Let us look at another recipe to leverage <kbd>Get-Help</kbd> a little better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Fetching Help Information for a Specific Cmdlet</h1>
                </header>
            
            <article>
                
<p>While Get-Help shows information about help itself, it can also take in other cmdlets as arguments and show help for them. Let's pick <kbd>Get-Command</kbd> as an example and get help on the cmdlet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>At the prompt, type in the following:</li>
</ol>
<pre style="padding-left: 90px">Get-Help Get-Command</pre>
<ol start="2">
<li>You'd get an output like this:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/0f4996e6-5ed6-4bfe-a7da-c37a3cfc3d03.png" width="1812" height="1044"/></div>
<ol start="3">
<li>You can even get complete help on a cmdlet, including information about each of the parameter that you can use with the cmdlet; information such as whether the parameter is positional, mandatory and so on. We shall see in detail about each of these as we move into administration using PowerShell. To get full help on the cmdlet, enter:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Help Get-Command -Full</pre>
<ol start="4">
<li>To see examples of how to use the cmdlet, enter:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Help Get-Command -Examples</pre>
<ol start="5">
<li>To read help information online, enter:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Help Get-Command -Online</pre>
<div class="packt_infobox">Notice that parameters are grouped in the output under SYNTAX. We can see two such groups in this case. These groups are called <strong>Parameter Sets</strong>. Parameter sets tell us which parameters can be grouped together. Two parameters not appearing within the same parameter set cannot be used together.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When you run the cmdlet, <kbd>Get-Help</kbd> with another cmdlet as the argument, <kbd>Get-Help</kbd> fetches help information for the cmdlet that was passed as the argument; <kbd>Get-Command</kbd> in this case. We shall see in the later chapters how arguments are handled. For now, we're simply calling the help for an arbitrary cmdlet.</p>
<p>If you notice the output, you'd see the name of the cmdlet, the syntax to use with the cmdlet, the alias available for the cmdlet and more online help if required. Full and Examples are switches which tell PowerShell the level of help you need. These are mutually exclusive; you cannot run <kbd>-Full</kbd> and <kbd>-Examples</kbd> at the same time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 2.6: Listing out the aliases and using them in place of cmdlets</li>
<li>Recipe 1.4: Updating help</li>
<li>Recipe 1.3: Fetching help information for a specific cmdlet (Information about Parameter Sets)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Updating Help</h1>
                </header>
            
            <article>
                
<p>Help information in PowerShell is dynamic. In most situations, PowerShell goes online to fetch the latest help. However, it is also possible to store the help files offline. This can be done using the cmdlet, <kbd>Update-Help</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To download the help files for the locally-installed PowerShell modules:</p>
<ol>
<li>Type <kbd>exit</kbd> to exit PowerShell. This is so that you can relaunch PowerShell with elevated privileges.</li>
<li>Enter <kbd>sudo pwsh</kbd> to launch PowerShell as a super-user.</li>
<li>At the <kbd>PS</kbd> prompt, run <kbd>Update-Help</kbd>.</li>
<li>Wait for the update progress bar to appear. The bar will fill as the help files download to your computer.</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img src="Images/0475c76f-4e54-4f67-a125-cc9b7bd7f082.png" width="1812" height="964"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>PowerShell goes online to fetch help information every time you run the Get-Help cmdlet—the help files are not stored offline. This is primarily to ensure that only the latest help is referred. Besides, viewing help online also does not occupy space on the local computer.</p>
<p>In some cases, however, it is necessary that help information be stored for offline access. In such situations, it would make sense to download and store the help files.</p>
<p>One of the reasons this action requires elevated privileges is that the help information is stored within the shell. Therefore, non-administrators may not be able to update help without administrator intervention.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Searching Help for Keywords</h1>
                </header>
            
            <article>
                
<p>Linux administrators are very comfortable using <kbd>grep</kbd> to search for specific text patterns in any textual output. PowerShell, as we know, returns only <strong>object</strong>—PowerShell treats text as an object as well.</p>
<p>While converting an object into text diminishes the power of PowerShell, it still is necessary in some scenarios. In this case, we shall look for the keyword, “common” in the help output.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let us begin the process of searching by first getting the help information for a cmdlet:</p>
<ol>
<li>Launch PowerShell by entering <kbd>pwsh</kbd> at the terminal.</li>
<li>At the prompt, type in:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Help Get-Command</pre>
<p style="padding-left: 60px">This should give you helpful information on the specified cmdlet.</p>
<ol start="3">
<li>Convert the output into text using the Out-String cmdlet along with the -Stream switch to return one string at a time rather than the whole of the help information as a single string. This way, we'd be able to run string matching more efficiently and get shorter search results.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Help Get-Command | Out-String -Stream</pre>
<ol start="4">
<li>There won't be a noticeable difference at the moment. Add the Select-String cmdlet to perform the grep-like operation.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Help Get-Command | Out-String -Stream | Select-String 'common'</pre>
<ol start="5">
<li>This gives you an output with the exact line that has the string, ‘common' in it.</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/f417912f-ba4f-4748-a45f-ce68acc26dfc.png" width="1812" height="1004"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>At the first step, we simply get the help information for the Get-Command cmdlet. This output is an object—performing a text lookup operation is best done when the output is text. Out-String converts this output into a plain string; the only issue is that the whole block of text is one single string. A text lookup this way may not be really helpful. We use the -String switch to break the large string into smaller pieces (paragraphs in this case). Next, we use the Select-String along with the keyword to select the string that contains our keyword.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Looking for help information specific to a parameter</h1>
                </header>
            
            <article>
                
<p>As we saw in the previous sections, PowerShell's help output could be a little overwhelming. We run <kbd>Get-Help</kbd> with the <kbd>-Full</kbd> switch when we need information on the parameters in the cmdlet whose help information we want to access. However, this lists out all the parameters. What if we wanted information on only a single parameter?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Discovering Cmdlets</h1>
                </header>
            
            <article>
                
<p>So far, we saw how to get help on cmdlets. We used the Get-Command cmdlet as the example argument. We would now use Get-Command to discover cmdlets in PowerShell. Get-Help and Get-Command thus become the most important cmdlets when you need any help information in PowerShell.</p>
<p>PowerShell is like plain English—PowerShell follows the Verb-Noun format in cmdlet naming, which makes the cmdlets sound like plain English commands. PowerShell even uses what's known as <strong>approved verbs</strong>, that ensures that verbs follow a convention when naming cmdlets. The nouns, on the other hand, can be arbitrary.</p>
<div class="packt_tip">Most programmers would suggest learning to <q>think in the language</q>. This, combined with muscle memory (which helps you remember the keys on the keyboard), makes programming as well as scripting faster. PowerShell's structure being like English helps a lot in this regard; it's easy to think in PowerShell. For instance, if you would like to know the current date, all you have to say is, <kbd>Get-Date</kbd>, and PowerShell will print the date and time on the screen for you.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let us look at how to get information only about the <kbd>Noun</kbd> parameter of <kbd>Get-Help</kbd>.</p>
<ol>
<li>Invoke PowerShell by running <kbd>pwsh</kbd> on the terminal window.</li>
<li>At the prompt, enter <kbd>Get-Help Get-Command</kbd> to look for basic help information on the cmdlet.</li>
<li>Note down the parameter which you want more information about. Let's pick the parameter <kbd>Noun</kbd> as an example.</li>
<li>Enter the following command at the prompt:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Help Get-Command -Parameter Noun</pre>
<p>The output contains information specific to the <kbd>Noun</kbd> parameter:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/35e5d79d-da5e-48da-a3a1-2a533159bf7b.png" width="1812" height="1004"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This is a classic example of object filtering. Since the output of most PowerShell cmdlets are objects, it is easy to select the necessary object and discard the rest from the output.</p>
<p>When we run <kbd>Get-Help</kbd> with the cmdlet we need help about and the specific parameter of the cmdlet we are looking for, we get a filtered help specific to the cmdlet in question. In our case, we picked the Noun parameter of <kbd>Get-Command</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exploring the About_ Topics</h1>
                </header>
            
            <article>
                
<p>Documentation is one of the key strengths of PowerShell. While not all modules have complete documentation, all of the first-party modules do, along with the well-done third-party ones. By default, PowerShell itself has exhaustive documentation built within it.</p>
<p>In this recipe, we would look for <kbd>about_</kbd> topics, pick one of the topics from the output and read more about the subject we picked.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let us begin with listing out all the <kbd>about_*</kbd> helpfiles.</p>
<ol>
<li>Invoke PowerShell using the command, <kbd>pwsh</kbd>.</li>
<li>Enter <kbd>Get-Help about_*</kbd> to list out all the <kbd>about_*</kbd> helpfiles.</li>
</ol>
<pre style="padding-left: 90px">Name                              Category  Module                    Synopsis<br/>----                              --------  ------                    --------<br/>about_Aliases                     HelpFile<br/>about_Arithmetic_Operators        HelpFile<br/>about_Arrays                      HelpFile<br/>about_Assignment_Operators        HelpFile<br/>about_Automatic_Variables         HelpFile<br/>.<br/>.<br/>.<br/>about_Wildcards                   HelpFile</pre>
<ol start="3">
<li>Pick out the topic you'd like to read about—we pick <kbd>about_Modules</kbd>.</li>
<li>Enter <kbd>Get-Help about_Modules</kbd> to read up on PowerShell modules.</li>
</ol>
<pre style="padding-left: 90px">ABOUT MODULES<br/><br/>Short Description<br/>Explains how to install, import, and use PowerShell modules.<br/><br/>Long Description<br/>A module is a package that contains PowerShell commands, such as cmdlets,<br/>providers, functions, workflows, variables, and aliases.<br/><br/>People who write commands can use modules to organize their commands and<br/>share them with others. People who receive modules can add the commands in<br/>the modules to their PowerShell sessions and use them just like the<br/>built-in commands.<br/>.<br/>.<br/>.<br/>How to Find the Commands in a Module<br/><br/>Use the Get-Command cmdlet to find all available commands. You can use the<br/>parameters of the Get-Command cmdlet to filter commands such as by module,<br/>name, and noun.<br/>.<br/>.<br/>.<br/>The following modules (or snap-ins) are installed with PowerShell. *<br/>CimCmdlets * Microsoft.PowerShell.Archive * Microsoft.PowerShell.Core *<br/>Microsoft.PowerShell.Diagnostics * Microsoft.PowerShell.Host *<br/>Microsoft.PowerShell.Management...</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>Get-Help</kbd> gives you information about cmdlets if the cmdlet is passed as an argument. In cases where you know only a part of the name of the cmdlet, you can use a combination of characters and wildcards to list out cmdlets that match the search string (<kbd>about_*</kbd> in our case).</p>
<p>Now, we pick the topic we would like to read about and enter that specific <kbd>about_</kbd> topic. Now, <kbd>Get-Help</kbd> shows the complete documentation about the topic.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Get-Command can help determine the best cmdlet for a task. To find cmdlets, follow the steps below:</p>
<ol>
<li>At the Terminal, type <kbd>pwsh</kbd> to invoke PowerShell.</li>
<li>Enter Get-Command to get a list of all cmdlets available in PowerShell. The number of cmdlets returned would change based on when you last updated PowerShell and the modules you've loaded.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Command</pre>
<p style="padding-left: 60px">This may not be particularly useful—what would you do with a list of commands if you were looking for something to list out the currently-running processes?</p>
<ol start="3">
<li>A process is a noun. We want a list of cmdlets that work on <em>processes</em>. At the prompt, type:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Command -Noun Process</pre>
<p style="padding-left: 60px">Note that in PowerShell, the noun is in the singular form. Therefore, it's Process and not Processes.</p>
<ol start="4">
<li>If you would like to further narrow down the list of cmdlets returned, add the verb as well.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Command -Verb Get -Noun Process</pre>
<ol start="5">
<li>If you're feeling lazy, or unsure of the exact conventions, you could even use the wildcard.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Command -Noun Proc*</pre>
<ol start="6">
<li>If you'd rather not write so much, and you're almost sure you know the partial cmdlet, you can straight away use wildcard search.</li>
<li>If you know the name of the module which contains the cmdlet, you can even use the Module parameter when invoking <kbd>Get-Command</kbd>.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Command -Noun Process -Module Microsoft.PowerShell.Management</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>PowerShell has the capability to identify the verb and the noun in cmdlets, based on the first occurrence of hyphen. Anything that appears before the first hyphen is the verb, and anything that appears after, is the noun. When cmdlets are loaded from modules, PowerShell identifies the verbs and the nouns in them. The search promptly returns the cmdlets based on the search specifications. Filters based on the name of the verb, noun or even the module restrict the search accordingly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding Modules</h1>
                </header>
            
            <article>
                
<p>Loosely coupling the components is one of the keys to success of a framework. PowerShell follows this principle as well. All cmdlets are packaged within modules. The modules can be first-party-provided, created by you, or even third-party-created.</p>
<p>Installation of modules, which could've been a hassle in the past, has been streamlined today. PowerShell now comes pre-packaged with a package manager called, <kbd>PowerShellGet</kbd>, that connects to the PowerShell gallery (<a href="https://www.powershellgallery.com">https://www.powershellgallery.com</a>). The PowerShell gallery is an online repository that contains modules, scripts and other utilities that administrators can download and install in order to extend PowerShell's capabilities.</p>
<p>While it is possible to download PowerShell modules from third-party sites, our focus in this book would be the PowerShell repository.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To find modules in the PowerShell repository, follow these steps:</p>
<ol>
<li>Launch PowerShell by running <kbd>pwsh</kbd> on the Terminal.</li>
<li>Look for the command pertaining to modules.</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/98edfcda-d148-4d35-a041-807f5ddd86f9.png" width="1812" height="1004"/></div>
<p style="padding-left: 60px">Notice the list of commands available to work with modules. Some of them are of the cmdlet type, while others are functions.</p>
<ol start="3">
<li>Filter the output further, using the verb.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-Command -Noun Module -Verb Find</pre>
<p style="padding-left: 60px">You get <kbd>Find-Module</kbd> as the output.</p>
<ol start="4">
<li>Enter the following to list out all the modules.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Find-Module</pre>
<p style="padding-left: 60px">The list begins to appear. The search results are way too many. Press <kbd>Ctrl + C</kbd> to abort the execution.</p>
<ol start="5">
<li>Search for a module to help you work with Docker containers.</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/788be588-8afd-4bb8-9de4-0fe6ccba964e.png" width="1812" height="1004"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Hundreds of modules, scripts and Desired State Configuration resources have been registered with the <kbd>PSGallery</kbd> repository. Microsoft now recommends using the repository for module management. Using the <kbd>Find-Module</kbd> cmdlet, PowerShell makes a connection to the repository and gets a list of all available modules. Then, it runs a search on the returned results based on the criteria you mention.</p>
<p>You can also similarly find scripts that can perform repetitive tasks. To find scripts, use the <kbd>Find-Script</kbd> cmdlet. It works similar to the <kbd>Find-Module</kbd> cmdlet, except that it finds individual scripts rather than modules.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Modules from the Repository</h1>
                </header>
            
            <article>
                
<p>Now that we know how to find modules, we can proceed with getting modules and installing them. All cmdlets pertaining to <kbd>PowerShellGet</kbd> are packaged in the module called, <kbd>PowerShellGet</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We now know the name of the module that would let us manage our Docker infrastructure. Let us now try to install the module.</p>
<ol>
<li>Installation of modules may require elevated privileges. Open PowerShell with <kbd>sudo</kbd>.</li>
</ol>
<pre style="padding-left: 90px">$ sudo pwsh</pre>
<ol start="2">
<li>Now run the following command to install the Docker module from the repository.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Install-Module Docker</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/b41b716d-f624-482c-8474-96b30d3b2e87.png" width="1812" height="1004"/></div>
<ol start="3">
<li class="mce-root">In some cases, you may want to save the module locally before you install it.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Save-Module Docker ~/PsModules</pre>
<p style="padding-left: 60px">This way, you can simply import the module in portable mode and run the cmdlets without having to install the module in any of the system directories.</p>
<ol start="4">
<li>To import the downloaded module, run:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Import-Module ~/PsModules/Docker/1.3.2/Docker.psm1</pre>
<ol start="5">
<li>To update the installed module, run:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Update-Module Docker</pre>
<ol start="6">
<li>To remove an installed module, run:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Uninstall-Module Docker</pre>
<p>Most of these functionalities work with scripts published to the PowerShellGet repository as well. Just replace Module with Script in the cmdlet and that should do the trick—you can find, save, install, update and uninstall scripts the same way you do modules.</p>
<p>Downloaded scripts need not necessarily be installed; they can be directly called. We will see this in the later sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>What PowerShell really does when running the <kbd>Install-Module</kbd> is, save the module files in one of the locations that PowerShell looks for modules by default.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe: Module discovery paths in PowerShell (Creating custom modules)</li>
<li>Recipe 3.11: Calling a PowerShell script</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Listing the Various Providers in PowerShell</h1>
                </header>
            
            <article>
                
<p>One more concept before we start preparing for administration using PowerShell would be to understand <strong>providers</strong>.</p>
<p>Providers in PowerShell are a great example of the concept of <strong>overloading</strong> in object-oriented programming. In essence, a provider is a program that logically represents non-file-system drives as though they were drives. For instance, on Windows, the Registry is a database of configuration. In PowerShell, the Registry is a provider; this way, administrators can use PowerShell to navigate and manipulate Registry keys as though they were files. This capability is available on Linux as well, however, the providers are not as many as found on Windows.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To list out the providers in PowerShell, follow these steps:</p>
<ol>
<li>Run <kbd>pwsh</kbd> to load PowerShell on the Terminal.</li>
<li>Run the command:</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Get-PsProvider</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/f36012e9-b8ba-4762-9952-de78c5ce0ab4.png" width="1812" height="1004"/></div>
<p style="padding-left: 60px">Note the providers available in PowerShell, and the drives and capabilities found <em>within</em> these providers.</p>
<ol start="3">
<li>Navigate to the Alias: drive.</li>
</ol>
<pre style="padding-left: 90px" class="Code">PS&gt; Set-Location Alias:</pre>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/e52ce58e-5686-4671-816a-3cdff1cc4004.png" width="1812" height="1004"/></div>
<div class="packt_infobox">Notice the preceding colon after the drive name (Alias: and not Alias). This is important to indicate to PowerShell that you're switching drives. Without the colon, PowerShell would simply try to look for a directory called Alias in your present working directory.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As of now, PowerShell providers don't seem to work as intended, in Linux. However, in due course, this should be fixed.</p>
<p>Providers wrap the non-file-system like structures into themselves and present them to PowerShell as though they were files and directories. These allow you to navigate complex structures as though they were simply files and directories, which are easier managed using the commands that work on the file system, such as <kbd>Get-ChildItem</kbd>.</p>
<p>The <kbd>Capabilities</kbd> column in the output show capabilities such as <kbd>Credentials</kbd>, <kbd>ShouldProcess</kbd> and <kbd>Filter</kbd> for each of the providers. This means that the providers support passing credentials to the core, availability of parameters such as <kbd>-WhatIf</kbd> and <kbd>-Confirm</kbd> (which are part of <kbd>ShouldProcess</kbd>) and the ability to filter output using the <kbd>-Filter</kbd> parameter. We shall learn about each of these in the following chapters.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe: <kbd>ShouldProcess</kbd> capabilities such as <kbd>-Confirm</kbd> and <kbd>-WhatIf</kbd> (Functions)</li>
<li>Recipe: Using the <kbd>-Filter</kbd> parameter</li>
</ol>


            </article>

            
        </section>
    </div>



  </body></html>