- en: Chapter 1. The Build System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the host system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Poky
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a build directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your first image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the Freescale Yocto ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing support for Freescale hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Wandboard images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting your Wandboard's first boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring network booting for a development setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing downloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing the shared state cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a package feed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using build history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with build statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Yocto project ([http://www.yoctoproject.org/](http://www.yoctoproject.org/))
    is an embedded Linux distribution builder that makes use of several other open
    source projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Yocto project provides a reference build system for embedded Linux, called
    **Poky**, which has the **BitBake** and **OpenEmbedded-Core** (**OE-Core**) projects
    at its base. The purpose of Poky is to build the components needed for an embedded
    Linux product, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: A bootloader image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux kernel image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A root filesystem image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toolchains and **software development kits** (**SDKs**) for application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these, the Yocto project covers the needs of both system and application
    developers. When the Yocto project is used as an integration environment for bootloaders,
    the Linux kernel, and user space applications, we refer to it as system development.
  prefs: []
  type: TYPE_NORMAL
- en: For application development, the Yocto project builds SDKs that enable the development
    of applications independently of the Yocto build system.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto project makes a new release every six months. The latest release at
    the time of this writing is Yocto 1.7.1 Dizzy, and all the examples in this book
    refer to the 1.7.1 release.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Yocto release comprises the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Poky, the reference build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A build appliance; that is, a VMware image of a host system ready to use Yocto
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Application Development Toolkit** (**ADT**) installer for your host system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for the different supported platforms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prebuilt toolchains
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prebuilt packaged binaries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prebuilt images
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Yocto 1.7.1 release is available to download from [http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the host system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will explain how to set up a host Linux system to use the Yocto
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recommended way to develop an embedded Linux system is using a native Linux
    workstation. Development work using virtual machines is discouraged, although
    they may be used for demo and test purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Yocto builds all the components mentioned before from scratch, including the
    cross-compilation toolchain and the native tools it needs, so the Yocto build
    process is demanding in terms of processing power and both hard drive space and
    I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Although Yocto will work fine on machines with lower specifications, for professional
    developer's workstations, it is recommended to use **symmetric multiprocessing**
    (**SMP**) systems with 8 GB or more system memory and a high capacity, fast hard
    drive. Build servers can employ distributed compilation, but this is out of the
    scope of this book. Due to different bottlenecks in the build process, there does
    not seem to be much improvement above 8 CPUs or around 16 GB RAM.
  prefs: []
  type: TYPE_NORMAL
- en: The first build will also download all the sources from the Internet, so a fast
    Internet connection is also recommended.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Yocto supports several distributions, and each Yocto release will document
    a list of the supported ones. Although the use of a supported Linux distribution
    is strongly advised, Yocto is able to run on any Linux system if it has the following
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Git 1.7.8 or greater
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tar 1.24 or greater
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 2.7.3 or greater (but not Python 3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yocto also provides a way to install the correct version of these tools by either
    downloading a *buildtools-tarball* or building one on a supported machine. This
    allows virtually any Linux distribution to be able to run Yocto, and also makes
    sure that it will be possible to replicate your Yocto build system in the future.
    This is important for embedded products with long-term availability requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This book will use the Ubuntu 14.04 **Long-Term Stable** (**LTS**) Linux distribution
    for all examples. Instructions to install on other Linux distributions can be
    found on the *Supported Linux Distributions* section of the *Yocto Project Development
    Manual*, but the examples will only be tested with Ubuntu 14.04 LTS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure you have the required package dependencies installed for Yocto
    and to follow the examples in the book, run the following command from your shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: The example code in the book can be accessed through several GitHub repositories
    at [https://github.com/yoctocookbook](https://github.com/yoctocookbook). Follow
    the instructions on GitHub to obtain a copy of the source in your computer.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding command will use `apt-get`, the **Advanced Packaging Tool** (**APT**),
    command-line tool. It is a frontend of the **dpkg** package manager that is included
    in the Ubuntu distribution. It will install all the required packages and their
    dependencies to support all the features of the Yocto project.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If build times are an important factor for you, there are certain steps you
    can take when preparing your disks to optimize them even further:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the `build` directories on their own disk partition or a fast external
    drive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the ext4 filesystem but configure it not to use journalism on your Yocto-dedicated
    partitions. Be aware that power losses may corrupt your build data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mount the filesystem in such a way that read times are not written/recorded
    on file reads, disable write barriers, and delay committing filesystem changes
    with the following mount options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do not build on network-mounted drives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These changes reduce the data integrity safeguards, but with the separation
    of the `build` directories to their own disk, failures would only affect temporary
    build data, which can be erased and regenerated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete Yocto project installation instructions for Ubuntu and other supported
    distributions can be found on the *Yocto Project Reference Manual* at [http://www.yoctoproject.org/docs/1.7.1/ref-manual/ref-manual.html](http://www.yoctoproject.org/docs/1.7.1/ref-manual/ref-manual.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Poky
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will explain how to set up your host Linux system with Poky, the
    Yocto project reference system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Poky uses the OpenEmbedded build system, and as such, uses the BitBake tool,
    a task scheduler written in Python which forked from Gentoo's Portage tool. You
    can think of BitBake as the make utility in Yocto. It will parse the configuration
    and recipe metadata, schedule a task list, and run through it.
  prefs: []
  type: TYPE_NORMAL
- en: BitBake is also the command-line interface to Yocto.
  prefs: []
  type: TYPE_NORMAL
- en: Poky and BitBake are two of the open source projects used by Yocto. The Poky
    project is maintained by the Yocto community. You can download Poky from its Git
    repository at [http://git.yoctoproject.org/cgit/cgit.cgi/poky/](http://git.yoctoproject.org/cgit/cgit.cgi/poky/).
  prefs: []
  type: TYPE_NORMAL
- en: Development discussions can be followed and contributed to by visiting the development
    mailing list at [https://lists.yoctoproject.org/listinfo/poky](https://lists.yoctoproject.org/listinfo/poky).
  prefs: []
  type: TYPE_NORMAL
- en: BitBake, on the other hand, is maintained by both the Yocto and OpenEmbedded
    communities, as the tool is used by both. BitBake can be downloaded from its Git
    repository at [http://git.openembedded.org/bitbake/](http://git.openembedded.org/bitbake/).
  prefs: []
  type: TYPE_NORMAL
- en: Development discussions can be followed and contributed to by visiting the development
    mailing list at [http://lists.openembedded.org/mailman/listinfo/bitbake-devel](http://lists.openembedded.org/mailman/listinfo/bitbake-devel).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Poky build system only supports virtualized QEMU machines for the following
    architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: ARM (qemuarm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: x86 (qemux86)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: x86-64 (qemux86-64)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerPC (qemuppc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MIPS (qemumips, qemumips64)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from these, it also supports some reference hardware **Board Support
    Packages** (**BSPs**), representative of the architectures just listed. These
    are those BSPs:'
  prefs: []
  type: TYPE_NORMAL
- en: Texas Instruments Beaglebone (beaglebone)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freescale MPC8315E-RDB (mpc8315e-rdb)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intel x86 based PCs and devices (genericx86 and genericx86-64)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubiquiti Networks EdgeRouter Lite (edgerouter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To develop on different hardware, you will need to complement Poky with hardware-specific
    Yocto layers. This will be covered later on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Poky project incorporates a stable BitBake release, so to get started with
    Yocto, we only need to install Poky in our Linux host system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you can also install BitBake independently through your distribution's
    package management system. This is not recommended and can be a source of problems,
    as BitBake needs to be compatible with the metadata used in Yocto. If you have
    installed BitBake from your distribution, please remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current Yocto release is 1.7.1, or Dizzy, so we will install that into
    our host system. We will use the `/opt/yocto` folder as the installation path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous instructions will use Git (the source code management system command-line
    tool) to clone the Poky repository, which includes BitBake, into a new `poky`
    directory on our current path, and point it to the Dizzy stable branch.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Poky contains three metadata directories, `meta`, `meta-yocto`, and `meta-yocto-bsp`,
    as well as a template metadata layer, `meta-skeleton`, that can be used as a base
    for new layers. Poky''s three metadata directories are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`meta`: This directory contains the OpenEmbedded-Core metadata, which supports
    the ARM, x86, x86-64, PowerPC, MIPS, and MIPS64 architectures and the QEMU emulated
    hardware. You can download it from its Git repository at [http://git.openembedded.org/openembedded-core/](http://git.openembedded.org/openembedded-core/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development discussions can be followed and contributed to by visiting the development
    mailing list at [http://lists.openembedded.org/mailman/listinfo/openembedded-core](http://lists.openembedded.org/mailman/listinfo/openembedded-core).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`meta-yocto`: This contains Poky''s distribution-specific metadata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta-yocto-bsp`: This contains metadata for the reference hardware boards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is documentation about Git, the distributed version control system, at
    [http://git-scm.com/doc](http://git-scm.com/doc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a build directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before building your first Yocto image, we need to create a `build` directory
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: The build process, on a host system as outlined before, can take up to one hour
    and need around 20 GB of hard drive space for a console-only image. A graphical
    image, like `core-image-sato`, can take up to 4 hours for the build process and
    occupy around 50 GB of space.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to do is create a `build` directory for our project,
    where the build output will be generated. Sometimes, the `build` directory may
    be referred to as the project directory, but `build` directory is the appropriate
    Yocto term.
  prefs: []
  type: TYPE_NORMAL
- en: There is no right way to structure the `build` directories when you have multiple
    projects, but a good practice is to have one `build` directory per architecture
    or machine type. They can all share a common `downloads` folders, and even a shared
    state cache (this will be covered later on), so keeping them separate won't affect
    the build performance, but it will allow you to develop on multiple projects simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: To create a `build` directory, we use the `oe-init-build-env` script provided
    by Poky. The script needs to be sourced into your current shell, and it will set
    up your environment to use the OpenEmbedded/Yocto build system, including adding
    the BitBake utility to your path. You can specify a `build` directory to use or
    it will use `build` by default. We will use `qemuarm` for this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The script will change to the specified directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As `oe-init-build-env` only configures the current shell, you will need to source
    it on every new shell. But, if you point the script to an existing `build` directory,
    it will set up your environment but won't change any of your existing configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake is designed with a client/server abstraction, so we can also start
    a memory resident server and connect a client to it. With this setup, loading
    cache and configuration information each time is avoided, which saves some overhead.
    To run a memory resident BitBake that will always be available, you can use the
    `oe-init-build-env-memres` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here `12345` is the local port to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use both BitBake flavors simultaneously, as this can be a source of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then kill the memory resident BitBake by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both scripts call the `scripts/oe-setup-builddir` script inside the `poky` directory
    to create the `build` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'On creation, the `build` directory contains a `conf` directory with the following
    three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bblayers.conf`: This file lists the metadata layers to be considered for this
    project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local.conf`: This file contains the project-specific configuration variables.
    You can set common configuration variables to different projects with a `site.conf`
    file, but this is not created by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateconf.cfg`: This file contains the directory that includes the template
    configuration files used to create the project. By default it uses the one pointed
    to by the `templateconf` file in your Poky installation directory, which is `meta-yocto/conf`
    by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To start a build from scratch, that's all the `build` directory needs.
  prefs: []
  type: TYPE_NORMAL
- en: Erasing everything apart from these files will recreate your build from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify a different template configuration file to use when you create
    your `build` directory using the `TEMPLATECONF` variable; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `TEMPLATECONF` variable needs to refer to a directory containing templates
    for both `local.conf` and `bblayer.conf`, but named `local.conf.sample` and `bblayers.conf.sample`.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we can use the unmodified default project configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Building your first image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before building our first image, we need to decide what type of image we want
    to build. This recipe will introduce some of the available Yocto images and provide
    instructions to build a simple image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Poky contains a set of default target images. You can list them by executing
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A full description of the different images can be found on the *Yocto Project
    Reference Manual*. Typically, these default images are used as a base and customized
    for your own project needs. The most frequently used base default images are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`core-image-minimal`: This is the smallest BusyBox-, sysvinit-, and udev-based
    console-only image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-image-full-cmdline`: This is the BusyBox-based console-only image with
    full hardware support and a more complete Linux system, including bash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-image-lsb`: This is a console-only image that is based on Linux Standard
    Base compliance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-image-x11`: This is the basic X11 Windows-system-based image with a graphical
    terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-image-sato`: This is the X11 Window-system-based image with a SATO theme
    and a GNOME Mobile desktop environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-image-weston`: This is a Wayland protocol and Weston reference compositor-based
    image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will also find images with the following suffixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev`: These images are suitable for development work, as they contain headers
    and libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sdk`: These images include a complete SDK that can be used for development
    on the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initramfs`: This is an image that can be used for a RAM-based root filesystem,
    which can optionally be embedded with the Linux kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build an image, we need to configure the `MACHINE` we are building it for
    and pass its name to BitBake. For example, for the `qemuarm` machine, we would
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could export the `MACHINE` variable to the current shell environment
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But the preferred and persistent way to do it is to edit the `conf/local.conf`
    configuration file to change the default machine to `qemuarm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can just execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you pass a target recipe to BitBake, it first parses the following configuration
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conf/bblayers.conf`: This file is used to find all the configured layers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf/layer.conf`: This file is used on each configured layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta/conf/bitbake.conf`: This file is used for its own configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf/local.conf`: This file is used for any other configuration the user may
    have for the current build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf/machine/<machine>.conf`: This file is the machine configuration; in our
    case, this is `qemuarm.conf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf/distro/<distro>.conf`: This file is the distribution policy; by default,
    this is the `poky.conf` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And then BitBake parses the target recipe that has been provided and its dependencies.
    The outcome is a set of interdependent tasks that BitBake will then execute in
    order.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most developers won''t be interested in keeping the whole build output for
    every package, so it is recommended to configure your project to remove it with
    the following configuration in your `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: But at the same time, configuring it for all packages means that you won't be
    able to develop or debug them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a list of packages to exclude from cleaning by adding them to the
    `RM_WORK_EXCLUDE` variable. For example, if you are going to do BSP work, a good
    setting might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you can use a custom template `local.conf.sample` configuration
    file in your own layer to keep these configurations and apply them for all projects
    so that they can be shared across all developers.
  prefs: []
  type: TYPE_NORMAL
- en: Once the build finishes, you can find the output images on the `tmp/deploy/images/qemuarm`
    directory inside your `build` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, images are not erased from the `deploy` directory, but you can
    configure your project to remove the previously built version of the same image
    by adding the following to your `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test run your images on the QEMU emulator by executing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `runqemu` script included in Poky's `scripts` directory is a launch wrapper
    around the QEMU machine emulator to simplify its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Freescale Yocto ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw, Poky metadata starts with the `meta`, `meta-yocto`, and `meta-yocto-bsp`
    layers, and it can be expanded by using more layers.
  prefs: []
  type: TYPE_NORMAL
- en: An index of the available OpenEmbedded layers that are compatible with the Yocto
    project is maintained at [http://layers.openembedded.org/](http://layers.openembedded.org/).
  prefs: []
  type: TYPE_NORMAL
- en: An embedded product's development usually starts with hardware evaluation using
    a manufacturer's reference board design. Unless you are working with one of the
    reference boards already supported by Poky, you will need to extend Poky to support
    your hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to do is to select which base hardware your design is going
    to be based on. We will use a board that is based on a Freescale i.MX6 **System
    on Chip** (**SoC**) as a starting point for our embedded product design.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe gives an overview of the support for Freescale hardware in the Yocto
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SoC manufacturer (in this case, Freescale) has a range of reference design
    boards for purchase, as well as official Yocto-based software releases. Similarly,
    other manufacturers that use Freescale's SoCs offer reference design boards and
    their own Yocto-based software releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting the appropriate hardware to base your design on is one of the most
    important design decisions for an embedded product. Depending on your product
    needs, you will decide to either:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a production-ready board, like a **single-board computer** (**SBC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a module and build your custom carrier board around it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Freescale's SoC directly and design your own board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the times, a production-ready board will not match the specific requirements
    of an professional embedded system, and the process of designing a complete carrier
    board using Freescale's SoC would be too time consuming. So, using an appropriate
    module that already solves the most technically challenging design aspects is
    a common choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the characteristics that are important to consider are:'
  prefs: []
  type: TYPE_NORMAL
- en: Industrial temperature ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long-term availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precertified wireless and Bluetooth (if applicable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Yocto community layers that support Freescale-based boards are called `meta-fsl-arm`
    and `meta-fsl-arm-extras`. The selection of boards that are supported on `meta-fsl-arm`
    is limited to Freescale reference designs, which would be the starting point if
    you are considering designing your own carrier board around Freescale's SoC. Boards
    from other vendors are maintained on the `meta-fsl-arm-extras` layer.
  prefs: []
  type: TYPE_NORMAL
- en: There are other embedded manufacturers that use `meta-fsl-arm`, but they have
    not integrated their boards in the `meta-fsl-arm-extras` community layer. These
    manufacturers will keep their own BSP layers, which depend on `meta-fsl-arm`,
    with specific support for their hardware. An example of this is Digi International
    and its ConnectCore 6 module, which is based on the i.MX6 SoC.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand Freescale Yocto ecosystem, we need to start with the Freescale
    community BSP, comprising the `meta-fsl-arm` layer with support for Freescale
    reference boards, and its companion, `meta-fsl-arm-extra`, with support for boards
    from other vendors, and its differences with the official Freescale Yocto releases
    that Freescale offers for their reference designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some key differences between the community and Freescale Yocto releases:'
  prefs: []
  type: TYPE_NORMAL
- en: Freescale releases are developed internally by Freescale without community involvement
    and are used for BSP validation on Freescale reference boards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freescale releases go through an internal QA and validation test process, and
    they are maintained by Freescale support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freescale releases for a specific platform reach a maturity point, after which
    they are no longer worked on. At this point, all the development work has been
    integrated into the community layer and the platforms are further maintained by
    the Freescale BSP community.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freescale Yocto releases are not Yocto compatible, while the community release
    is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freescale's engineering works very closely with the Freescale BSP community
    to make sure that all development in their official releases is integrated in
    the community layer in a reliable and quick manner.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the best option is to use the Freescale BSP community release but stay
    with the U-Boot and Linux kernel versions that were released as part of the manufacturer's
    stable BSP release.
  prefs: []
  type: TYPE_NORMAL
- en: This effectively means that you get the latest updates to the Linux kernel and
    U-Boot from the manufacturer while simultaneously getting the latest updates to
    the root filesystem from the community, extending the lifetime of your product,
    and making sure you are up to date with applications, bug fixes, and security
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: This takes advantage of the manufacturer's QA process for the system components
    that are closer to the hardware, and makes it possible to use the manufacturer's
    support while simultaneously getting user space updates from the community. The
    Freescale BSP community is also very responsive and active, so problems can usually
    be worked on with them to benefit all parts.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Freescale BSP community extends Poky with the following layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`meta-fsl-arm`: This is the community layer that supports Freescale reference
    designs. It has a dependency on OpenEmbedded-Core. Machines in this layer will
    be maintained even after Freescale stops active development on them. You can download
    `meta-fsl-arm` from its Git repository at [http://git.yoctoproject.org/cgit/cgit.cgi/meta-fsl-arm/](http://git.yoctoproject.org/cgit/cgit.cgi/meta-fsl-arm/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development discussions can be followed and contributed to by visiting the development
    mailing list at [https://lists.yoctoproject.org/listinfo/meta-freescale](https://lists.yoctoproject.org/listinfo/meta-freescale).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `meta-fsl-arm` layer pulls both the Linux kernel and the U-Boot source
    from Freescale''s repositories using the following links:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Freescale Linux kernel Git** **repository**: [http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/](http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Freescale** **U-Boot Git repository**: [http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/](http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Linux kernel and U-Boot versions are available, but keeping the manufacturer's
    supported version is recommended.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `meta-fsl-arm` layer includes Freescale''s proprietary binaries to enable
    some hardware features – most notably its hardware graphics, multimedia, and encryption
    capabilities. To make use of these capabilities, the end user needs to accept
    Freescale''s **End-User License Agreement** (**EULA**), which is included in the
    `meta-fsl-arm` layer. To accept the license, the following line needs to be added
    to the project''s `conf/local.conf` configuration file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`meta-fsl-arm-extra`: This layer adds support for other community-maintained
    boards; for example, the Wandboard. To download the layer''s content, you may
    visit [https://github.com/Freescale/meta-fsl-arm-extra/](https://github.com/Freescale/meta-fsl-arm-extra/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta-fsl-demos`: This layer adds a metadata layer for demonstration target
    images. To download the layer''s content, you may visit [https://github.com/Freescale/meta-fsl-demos](https://github.com/Freescale/meta-fsl-demos).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Freescale uses another layer on top of the layers above for their official
    software releases: `meta-fsl-bsp-release`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`meta-fsl-bsp-release`: This is a Freescale-maintained layer that is used in
    the official Freescale software releases. It contains modifications to both `meta-fsl-arm`
    and `meta-fsl-demos`. It is not part of the community release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information, refer to the FSL community BSP release notes available
    at [http://freescale.github.io/doc/release-notes/1.7/](http://freescale.github.io/doc/release-notes/1.7/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing support for Freescale hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will install the community Freescale BSP Yocto release that
    adds support for Freescale hardware to our Yocto installation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With so many layers, manually cloning each of them and adding them to your project's
    `conf/bblayers.conf` file is cumbersome. The community is using the `repo` tool
    developed by Google for their community Android to ease the installation of Yocto.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `repo` in your host system, type in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `repo` tool is a Python utility that parses an XML file, called `manifest`,
    with a list of Git repositories. The `repo` tool is then used to manage those
    repositories as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For example, we will use `repo` to download all the repositories listed in
    the previous recipe to our host system. For that, we will point it to the Freescale
    community BSP `manifest` for the Dizzy release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `manifest` file shows all the installation paths and repository sources
    for the different components that are going to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `manifest` file is a list of the different layers that are needed for the
    Freescale community BSP release. We can now use `repo` to install it. Run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can optionally pass a `-jN` argument to sync if you have a multicore machine
    for multithreaded operations; for example, you could pass `repo sync -j8` in an
    8-core host system.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To list the hardware boards supported by the different layers, we may run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And to list the newly introduced target images, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The community Freescale BSP release introduces the following new target images:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fsl-image-mfgtool-initramfs`: This is a small, RAM-based `initramfs` image
    used with the Freescale manufacturing tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsl-image-multimedia`: This is a console-only image that includes the `gstreamer`
    multimedia framework over the framebuffer, if applicable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsl-image-multimedia-full`: This is an extension of `fsl-image-multimedia`,
    but extends the `gstreamer` multimedia framework to include all available plugins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsl-image-machine-test`: This is an extension on `fsl-image-multimedia-full`
    for testing and benchmarking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qte-in-use-image`: This is a graphical image that includes support for Qt4
    over the framebuffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qt-in-use-image`: This is a graphical image that includes support for Qt4
    over the X11 Windows system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instructions to use the `repo` tool, including using `repo` with proxy servers,
    can be found in the Android documentation at [https://source.android.com/source/downloading.html](https://source.android.com/source/downloading.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Wandboard images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building images for one of the supported boards (for example, `Wandboard Quad`)
    follows the same process we described earlier for the QEMU machines, with the
    exception of using the `setup-environment` script, which is a wrapper around `oe-init-build-env`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build an image for the `wandboard-quad` machine, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current version of the `setup-environment` script only works if the `build`
    directory is under the installation folder; in our case, `/opt/yocto/fsl-community-bsp`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setup-environment` script will create a `build` directory, set up the `MACHINE`
    variable, and prompt you to accept the Freescale EULA as described earlier. Your
    `conf/local.conf` configuration file will be updated both with the specified machine
    and the EULA acceptance variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that if you close your terminal session, you will need to set up the
    environment again before being able to use BitBake. You can safely rerun the `setup-environment`
    script as seen previously, as it will not touch an existing `conf/local.conf`
    file. Run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting image, `core-image-minimal.sdcard`, which is created inside the
    `build` directory, can be programmed into a microSD card, inserted into the primary
    slot in the Wandboard CPU board, and booted using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, `/dev/sdN` corresponds to the device node assigned to the microSD card
    in your host system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when running the `dd` command, as it could harm your machine. You
    need to be absolutely sure that the *sdN* device corresponds to your microSD card
    and not a drive on your development machine.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find more information regarding the `repo` tool on Android's documentation
    at [https://source.android.com/source/using-repo.html](https://source.android.com/source/using-repo.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting your Wandboard's first boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have problems booting your image, follow this recipe to troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without the microSD card inserted, plug in a microUSB-to-USB cable to the USB
    OTG interface of your Wandboard. Check the `lsusb` utility on your Linux host
    to see whether the Wandboard appears as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you don't see this, try a different power supply. It should be 5V, 10W.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure you connect a NULL modem serial cable between the RS232 connector
    in your Wandboard target and a serial port on your Linux host. Then open a terminal
    program like minicom with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to add your user to the dialout group, or try to run the command
    as sudo. This should open a 115200 8N1 serial connection. The serial device may
    vary in your Linux host. For example, a USB-to-serial adapter may be detected
    as `/dev/ttyUSB0`. Also, make sure both hardware and software flow control are
    disabled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Insert the microSD card image to the module slot, not the base board, as the
    latter is only used for storage and not for booting, and power it. You should
    see the U-Boot banner in the minicom session output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not, you may have a problem with the serial communication. By default, the
    Ethernet interface in the FSL community BSP image is configured to request an
    address by DHCP, so you can use that to connect to the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you have a DHCP server running on the test network where the target
    is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use a packet sniffer like **Wireshark** to capture a network trace on
    your Linux host and filter packages like the `bootp` protocol. At the least, you
    should see some broadcasts from your target, and if you use an Ethernet hub, you
    should also see the DHCP replies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Optionally, you can log in to your DHCP server and check the logs to see if
    a new IP address has been assigned. If you see an IP address being assigned, you
    might want to consider adding an SSH server, like **Dropbear**, to your core-image-minimal
    image so that you can establish a network connection with the target. You can
    do this by adding the following line to the `conf/local.conf` configuration file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the space after the initial quote.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After building and reprogramming, you can then start an SSH session to the
    Wandboard from your Linux host with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The connection should automatically log in without a password prompt.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try to program the default microSD card images from [http://www.wandboard.org/index.php/downloads](http://www.wandboard.org/index.php/downloads)
    to make sure the hardware and your setup is valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to reprogram your microSD card. Make sure you are using the correct images
    for your board (for example, do not mix dual and quad images). Also, try different
    cards and card readers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps will have your Wandboard start booting, and you should have some
    output in your serial connection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If everything else fails, you can verify the position of the bootloader on
    your microSD card. You can dump the contents of the first blocks of your microSD
    card with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a U-Boot header at offset 0x400\. That''s the offset where the
    i.MX6 boot ROM will be looking for the bootloader when bootstrapped to boot from
    the microSD interface. Use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can recognize the U-Boot header by dumping the U-Boot image from your build.
    Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Configuring network booting for a development setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most professional i.MX6 boards will have an internal **embedded MMC** (**eMMC**)
    flash memory, and that would be the recommended way to boot firmware. The Wandboard
    is not really a product meant for professional use, so it does not have one. But
    neither the eMMC nor the microSD card are ideal for development work, as any system
    change would involve a reprogramming of the firmware image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ideal setup for development work is to use both TFTP and NFS servers in
    your host system and to only store the U-Boot bootloader in either the eMMC or
    a microSD card. With this setup, the bootloader will fetch the Linux kernel from
    the TFTP server and the kernel will mount the root filesystem from the NFS server.
    Changes to either the kernel or the root filesystem are available without the
    need to reprogram. Only bootloader development work would need you to reprogram
    the physical media.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a TFTP server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not already running a TFTP server, follow the next steps to install
    and configure a TFTP server on your Ubuntu 14.04 host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tftpd-hpa` configuration file is installed in `/etc/default/tftpd-hpa`.
    By default, it uses `/var/lib/tftpboot` as the root `TFTP` folder. Change the
    folder permissions to make it accessible to all users using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now copy the Linux kernel and device tree from your `build` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Installing an NFS server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not already running an NFS server, follow the next steps to install
    and configure one on your Ubuntu 14.04 host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `/nfsroot` directory as the root for the NFS server, so we
    will "untar" the target''s root filesystem from our Yocto `build` directory in
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will configure the NFS server to export the `/nfsroot` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then restart the NFS server for the configuration changes to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boot the Wandboard and stop at the U-Boot prompt by pressing any key on the
    serial console. Then run through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get an IP address by DHCP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can configure a static IP address with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the IP address of your host system, where the TFTP and NFS servers
    have been set up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the root filesystem mount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the Linux kernel and device tree filenames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have configured a static IP address, you need to disable DHCP on boot
    by running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the U-Boot environment to the microSD card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform a network boot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Linux kernel and device tree will be fetched from the TFTP server, and the
    root filesystem will be mounted by the kernel from the NFS share after getting
    a DHCP address from your network (unless using static IP addresses).
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to log in with the root user without a password prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing downloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will usually work on several projects simultaneously, probably for different
    hardware platforms or different target images. In such cases, it is important
    to optimize the build times by sharing `downloads`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The build system runs a search for downloaded sources in a number of places:'
  prefs: []
  type: TYPE_NORMAL
- en: It tries the local `downloads` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It looks into the configured premirrors, which are usually local to your organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then tries to fetch from the upstream source as configured in the package
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it checks the configured mirrors. Mirrors are public alternate locations
    for the source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a package source is not found in any of the these four, the package build
    will fail with an error. Build warnings are also issued when upstream fetching
    fails and mirrors are tried, so that the upstream problem can be looked at.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto project maintains a set of mirrors to isolate the build system from
    problems with the upstream servers. However, when adding external layers, you
    could be adding support for packages that are not in the Yocto project's mirror
    servers, or other configured mirrors, so it is recommended that you keep a local
    premirror to avoid problems with source availability.
  prefs: []
  type: TYPE_NORMAL
- en: The default Poky setting for a new project is to store the downloaded package
    sources on the current `build` directory. This is the first place the build system
    will run a search for source `downloads`. This setting can be configured in your
    project's `conf/local.conf` file with the `DL_DIR` configuration variable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To optimize the build time, it is recommended to keep a shared `downloads`
    directory between all your projects. The `setup-environment` script of the `meta-fsl-arm`
    layer changes the default `DL_DIR` to the `fsl-community-bsp` directory created
    by the `repo` tool. With this setup, the `downloads` folder will already be shared
    between all the projects in your host system. It is configured as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A more scalable setup (for instance, for teams that are remotely distributed)
    is to configure a premirror. For example, adding the following to your `conf/local.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A usual setup is to have a build server serve its `downloads` directory. The
    build server can be configured to prepare tarballs of the Git directories to avoid
    having to perform Git operations from upstream servers. This setting in your `conf/local.conf`
    file will affect the build performance, but this is usually acceptable in a build
    server. Add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: An advantage of this setup is that the build server's `downloads` folder can
    also be backed up to guarantee source availability for your products in the future.
    This is especially important in embedded products with long-term availability
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test this setup, you may check to see whether a build is possible
    just by using the premirrors with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This setting in your `conf/local.conf` file can also be distributed across the
    team with the `TEMPLATECONF` variable during the project's creation.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the shared state cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Yocto project builds everything from source. When you create a new project,
    only the configuration files are created. The build process then compiles everything
    from scratch, including the cross-compilation toolchain and some native tools
    important for the build.
  prefs: []
  type: TYPE_NORMAL
- en: This process can take a long time, and the Yocto project implements a shared
    state cache mechanism that is used for incremental builds with the aim to build
    only the strictly necessary components for a given change.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, the build system calculates a checksum of the given input
    data to a task. If the input data changes, the task needs to be rebuilt. In simplistic
    terms, the build process generates a run script for each task that can be checksummed
    and compared. It also keeps track of a task's output, so that it can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: A package recipe can modify the shared state caching to a task; for example,
    to always force a rebuild by marking it as `nostamp`. A more in-depth explanation
    of the shared state cache mechanism can be found in the *Yocto Project Reference
    Manual* at [http://www.yoctoproject.org/docs/1.7.1/ref-manual/ref-manual.html](http://www.yoctoproject.org/docs/1.7.1/ref-manual/ref-manual.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the build system will use a shared state cache directory called
    `sstate-cache` on your `build` directory to store the cached data. This can be
    changed with the `SSTATE_DIR` configuration variable in your `conf/local.conf`
    file. The cached data is stored in directories named with the first two characters
    of the hash. Inside, the filenames contain the whole task checksum, so the cache
    validity can be ascertained just by looking at the filename. The build process
    set scene tasks will evaluate the cached data and use it to accelerate the build
    if valid.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to start a build from a clean state, you need to remove both the
    `sstate-cache` directory and the `tmp` directory.
  prefs: []
  type: TYPE_NORMAL
- en: You can also instruct BitBake to ignore the shared state cache by using the
    `--no-setscene` argument when running it.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good practice to keep backups of clean shared state caches (for example,
    from a build server), which can be used in case of shared state cache corruption.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sharing a shared state cache is possible; however, it needs to be approached
    with care. Not all changes are detected by the shared state cache implementation,
    and when this happens, some or all of the cache needs to be invalidated. This
    can cause problems when the state cache is being shared.
  prefs: []
  type: TYPE_NORMAL
- en: The recommendation in this case depends on the use case. Developers working
    on Yocto metadata should keep the shared state cache as default, separated per
    project.
  prefs: []
  type: TYPE_NORMAL
- en: However, validation and testing engineers, kernel and bootloader developers,
    and application developers would probably benefit from a well-maintained shared
    state cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure an NFS share drive to be shared among the development team to
    speed up the builds, you can add the following to your `conf/local.conf` configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The expression `PATH` in this example will get substituted by the build system
    with a directory named with the hash's first two characters.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a package feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An embedded system project seldom has the need to introduce changes to the Yocto
    build system. Most of the time and effort is spent in application development,
    followed by a lesser amount in maybe kernel and bootloader development.
  prefs: []
  type: TYPE_NORMAL
- en: As such, a whole system rebuild is probably done very few times. A new project
    is usually built from a prebuilt shared state cache, and application development
    work only needs to be done to perform full or incremental builds of a handful
    of packages.
  prefs: []
  type: TYPE_NORMAL
- en: Once the packages are built, they need to be installed on the target system
    for testing. Emulated machines are fine for application development, but most
    hardware-related work needs to be done on embedded hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An option is to manually copy the build binaries to the target's root filesystem,
    either copying it to the NFS share on the host system the target is mounting its
    root filesystem from (as explained in the *Configuring network booting for a development
    setup* recipe earlier) or using any other method like SCP, FTP, or even a microSD
    card.
  prefs: []
  type: TYPE_NORMAL
- en: This method is also used by IDEs like Eclipse when debugging an application
    you are working on. However, this method does not scale well when you need to
    install several packages and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next option would be to copy the packaged binaries (that is, the RPM, deb,
    or ipk packages) to the target''s filesystem and then use the target''s package
    management system to install them. For this to work, your target''s filesystem
    needs to be built with package management tools. Doing this is as easy as adding
    the `package-management` feature to your root filesystem; for example, you may
    add the following line to your project''s `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So for an RPM package, you will copy it to the target and use the **rpm** or
    **smart** utilities to install it. The smart package management tool is GPL licensed
    and can work with a variety of package formats.
  prefs: []
  type: TYPE_NORMAL
- en: However, the most optimized way to do this is to convert your host system package's
    output directory into a package feed. For example, if you are using the default
    RPM package format, you may convert `tmp/deploy/rpm` in your `build` directory
    into a package feed that your target can use to update.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, you need to configure an HTTP server on your computer that
    serves the packages.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You also need to make sure that the generated packages are correctly versioned,
    and that means updating the recipe revision, **PR**, with every change. It is
    possible to do this manually, but the recommended—and compulsory way if you want
    to use package feeds—is to use a PR server.
  prefs: []
  type: TYPE_NORMAL
- en: However, the PR server is not enabled by default. The packages generated without
    a PR server are consistent with each other but offer no update guarantees for
    a system that is already running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest PR server configuration is to run it locally on your host system.
    To do this, you add the following to your `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: With this setup, update coherency is guaranteed for your feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to share your feed with other developers, or you are configuring
    a build server or package server, you would run a single instance of the PR server
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And you will update the project''s build configuration to use the centralized
    PR server, editing `conf/local.conf` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Also, if you are using a shared state cache as described before, all of the
    contributors to the shared state cache need to use the same PR server.
  prefs: []
  type: TYPE_NORMAL
- en: Once the feed's integrity is guaranteed, we need to configure an HTTP server
    to serve the feed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use `lighttpd` for this example, as it is lightweight and easy to configure.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, the document root specified in the `/etc/lighttpd/lighttpd.conf`
    configuration file is `/var/www/`, so we only need a symlink to our package feed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, reload the configuration as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refresh the package index. This needs to be done manually to update the package
    feed after every build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need to configure our target filesystem with the new package feeds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the setup is ready, we will be able to query and update packages from
    the target''s root filesystem with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this change persistent in the target''s root filesystem, we can configure
    the package feeds at compilation time by using the `PACKAGE_FEED_URIS` variable
    in `conf/local.conf` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information and a user manual for the smart utility can be found at [https://labix.org/smart/](https://labix.org/smart/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using build history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When maintaining software for an embedded product, you need a way to know what
    has changed and how it is going to affect your product.
  prefs: []
  type: TYPE_NORMAL
- en: On a Yocto system, you may need to update a package revision (for instance,
    to fix a security vulnerability), and you need to make sure what the implications
    of this change are; for example, in terms of package dependencies and changes
    to the root filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Build history enables you to do just that, and we will explore it in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable build history, add the following to your `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following enables information gathering, including dependency graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code enables the storage of build history in a local Git
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: The Git repository location can be set by the `BUILDHISTORY_DIR` variable, which
    by default is set to a `buildhistory` directory on your `build` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `buildhistory` tracks changes to packages, images, and SDKs. This
    is configurable using the `BUILDHISTORY_FEATURES` variable. For example, to track
    only image changes, add the following to your `conf/local.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also track specific files and copy them to the `buildhistory` directory.
    By default, this includes only `/etc/passwd` and `/etc/groups`, but it can be
    used to track any important files like security certificates. The files need to
    be added with the `BUILDHISTORY_IMAGE_FILES` variable in your `conf/local.conf`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Build history will slow down the build, increase the build size, and may also
    grow the Git directory to an unmanageable size. The recommendation is to enable
    it on a build server for software releases, or in specific cases, such as when
    updating production software.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When enabled, it will keep a record of the changes to each package and image
    in the form of a Git repository in a way that can be explored and analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a package, it records the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Package and recipe revision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an image, it records the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Build configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of files that includes ownership and permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of installed packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And for an SDK, it records the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: SDK configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of both host and target files, including ownership and permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of installed packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the build history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inspecting the Git directory with the build history can be done in several
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Git tools like gitk or git log.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **buildhistory-diff** command-line tool, which displays the differences
    in a human-readable format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Django-1.4-based web interface. You will need to import the build history
    data to the application's database after every build. The details are available
    at [http://git.yoctoproject.org/cgit/cgit.cgi/buildhistory-web/tree/README](http://git.yoctoproject.org/cgit/cgit.cgi/buildhistory-web/tree/README).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To maintain the build history, it's important to optimize it and avoid it from
    growing over time. Periodic backups of the build history and clean-ups of older
    data are important to keep the build history repository at a manageable size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `buildhistory` directory has been backed up, the following process
    will trim it and keep only the most recent history:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy your repository to a temporary RAM filesystem (`tmpfs`) to speed things
    up. Check the output of the `df -h` command to see which directories are `tmpfs`
    filesystems and how much space they have available, and use one. For example,
    in Ubuntu, the `/run/shm` directory is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a graft point for a commit one month ago with no parents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the graft point permanent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clone a new repository to clean up the remaining Git objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the old `buildhistory` directory with the new cleaned one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with build statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build system can collect build information per task and image. The data
    may be used to identify areas of optimization of build times and bottlenecks,
    especially when new recipes are added to the system. This recipe will explain
    how the build statistics work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable the collection of statistics, your project needs to inherit the `buildstats`
    class by adding it to `USER_CLASSES` in your `conf/local.conf` file. By default,
    the `fsl-community-bsp` build project is configured to enable them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You can configure the location of these statistics with the `BUILDSTATS_BASE`
    variable, and by default it is set to the `buildstats` folder in the `tmp` directory
    under the `build` directory (`tmp/buildstats`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `buildstats` folder contains a folder per image with the build stats under
    a `timestamp` folder. Under it will be a subdirectory per package in your built
    image, and a `build_stats` file that contains:'
  prefs: []
  type: TYPE_NORMAL
- en: Host system information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root filesystem location and size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average CPU usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The accuracy of the data depends on the download directory, `DL_DIR`, and the
    shared state cache directory, `SSTATE_DIR`, existing on the same partition or
    volume, so you may need to configure them accordingly if you are planning to use
    the build data.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example `build-stats` file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'These disk statistics come from the Linux kernel disk I/O stats ([https://www.kernel.org/doc/Documentation/iostats.txt](https://www.kernel.org/doc/Documentation/iostats.txt)).
    The different elements are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadsComp`: This is the total number of reads completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadsMerged`: This is the total number of adjacent reads merged'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SectRead`: This is the total number of sectors read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeReads`: This is the total number of milliseconds spent reading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WritesComp`: This is the total number of writes completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SectWrite`: This is the total number of sectors written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeWrite`: This is the total number of milliseconds spent writing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IOinProgress`: This is the total number of I/Os in progress when reading `/proc/diskstats`'
  prefs: []
  type: TYPE_NORMAL
- en: '`TimeIO`: This is the total number of milliseconds spent performing I/O'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WTimeIO`: This is the total number of weighted time while performing I/O'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And inside each package, we have a list of tasks; for example, for `ncurses-5.9-r15.1`,
    we have the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`do_compile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_fetch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_package_write_rpm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_populate_lic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_rm_work`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_configure`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_install`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_packagedata`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_patch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_populate_sysroot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_unpack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each one of them contain, in the same format as earlier, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Build time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk stats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also obtain a graphical representation of the data using the `pybootchartgui.py`
    tool included in the Poky source. From your project''s `build` folder, you can
    execute the following command to obtain a `bootchart.png` graphic in `/tmp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Debugging the build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe of this chapter, we will explore the different methods available
    to debug problems with the build system and its metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's first introduce some of the usual use cases on a debugging session.
  prefs: []
  type: TYPE_NORMAL
- en: Finding recipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A good way to check whether a specific package is supported in your current
    layers is to search for it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This will recursively search all layers for the BusyBox pattern. You can limit
    the search to recipes and append files by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Dumping BitBake's environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When developing or debugging package or image recipes, it is very common to
    ask BitBake to list its environment both globally and for a specific target, be
    it a package or image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To dump the global environment and `grep` for a variable of interest (for example,
    `DISTRO_FEATURES`), use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, to locate the source directory for a specific package recipe like
    BusyBox, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also execute the following command to locate the working directory
    for a package or image recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Using the development shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake offers the `devshell` task to help developers. It is executed with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: It will unpack and patch the source, and open a new terminal (it will autodetect
    your terminal type or it can be set with `OE_TERMINAL`) in the target source directory,
    which has the environment correctly setup.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While in a graphical environment, devshell opens a new terminal or console
    window, but if we are working on a non-graphical environment, like telnet or SSH,
    you may need to specify `screen` as your terminal in your `conf/local.conf` configuration
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Inside the devshell, you can run development commands like `configure` and `make`
    or invoke the cross-compiler directly (use the `$CC` environment variable, which
    has been set up already).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The starting point for debugging a package build error is the BitBake error
    message printed on the build process. This will usually point us to the task that
    failed to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all the tasks available for a given recipe, with descriptions, we execute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to recreate the error, you can force a build with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can ask BitBake to force-run only a specific task using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Task log and run files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To debug the build errors, BitBake creates two types of useful files per shell
    task and stores them in a `temp` folder in the working directory. Taking BusyBox
    as an example, we would look into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: And find a list of log and run files. The filename format is
  prefs: []
  type: TYPE_NORMAL
- en: '`log.do_<task>.<pid>`'
  prefs: []
  type: TYPE_NORMAL
- en: and `run.do_<task>.<pid>`.
  prefs: []
  type: TYPE_NORMAL
- en: But luckily, we also have symbolic links, without the `pid` part, that link
    to the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: The log files will contain the output of the task, and that is usually the only
    information we need to debug the problem. The run file contains the actual code
    executed by BitBake to generate the log mentioned before. This is only needed
    when debugging complex build issues.
  prefs: []
  type: TYPE_NORMAL
- en: Python tasks, on the other hand, do not currently write files as described previously,
    although it is planned to do so in the future. Python tasks execute internally
    and log information to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Adding logging to recipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake recipes accept either bash or Python code. Python logging is done through
    the `bb` class and uses the standard logging Python library module. It has the
    following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bb.plain`: This uses `logger.plain`. It can be used for debugging, but should
    not be committed to the source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.note`: This uses `logger.info`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.warn`: This uses `logger.warn`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.error`: This uses `logger.error`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.fatal`: This uses `logger.critical` and exits BitBake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.debug`: This should be passed log level as the first argument and uses
    `logger.debug`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To print debug output from bash in our recipes, we need to use the `logging`
    class by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `logging` class is inherited by default by all recipes containing `base.bbclass`,
    so we don''t usually have to inherit it explicitly. We will then have access to
    the following bash functions, which will output to the log files (not to the console)
    in the `temp` directory inside the working directory as described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bbplain`: This function outputs literally what''s passed in. It can be used
    in debugging but should not be committed to a recipe source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bbnote`: This function prints with the `NOTE` prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bbwarn`: This prints a non-fatal warning with the `WARNING` prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bberror`: This prints a non-fatal error with the `ERROR` prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bbfatal`: This function halts the build and prints an error message as with
    `bberror`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bbdebug`: This function prints debug messages with log level passed as the
    first argument. It is used with the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The bash functions mentioned here do not log to the console but only to the
    log files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Looking at dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can ask BitBake to print the current and provided versions of packages
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Another common debugging task is the removal of unwanted dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an overview of pulled-in dependencies, you can use BitBake''s verbose
    output by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'To analyze what dependencies are pulled in by a package, we can ask BitBake
    to create DOT files that describe these dependencies by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The DOT format is a text description language for graphics that is understood
    by the **GraphViz** open source package and all the utilities that use it. DOT
    files can be visualized or further processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can omit dependencies from the graph to produce more readable output. For
    example, to omit dependencies from `glibc`, you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding commands have been run, we get three files in the current
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package-depends.dot`: This file shows the dependencies between runtime targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pn-depends.dot`: This file shows the dependencies between recipes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`task-depends.dot`: This file shows the dependencies between tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a `pn-buildlist` file with a list of packages that would be built
    by the given target.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the `.dot` files to postscript files (`.ps`), you may execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the most useful way to display dependency data is to ask BitBake to
    display it graphically with the dependency explorer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The result may be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking at dependencies](img/5186OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugging BitBake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is not common to have to debug BitBake itself, but you may find a bug in
    BitBake and want to explore it by yourself before reporting it to the BitBake
    community. For such cases, you can ask BitBake to output the debug information
    at three different levels with the `-D` flag. To display all the debug information,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Error reporting tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you will find a build error on a Yocto recipe that you have not modified.
    The first place to check for errors is the community itself, but before launching
    your mail client, head to [http://errors.yoctoproject.org](http://errors.yoctoproject.org).
  prefs: []
  type: TYPE_NORMAL
- en: This is a central database of user-reported errors. Here, you may check whether
    someone else is experiencing the same problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can submit your own build failure to the database to help the community
    debug the problem. To do so, you may use the `report-error` class. Add the following
    to your `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: By default, the error information is stored under `tmp/log/error-report` under
    the `build` directory, but you can set a specific location with the `ERR_REPORT_DIR`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the error reporting tool is activated, a build error will be captured
    in a file in the `error-report` folder. The build output will also print a command
    to send the error log to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: When this command is executed, it will report back with a link to the upstream
    error.
  prefs: []
  type: TYPE_NORMAL
- en: You can set up a local error server, and use that instead by passing a server
    argument. The error server code and setting up details can be found at [http://git.yoctoproject.org/cgit/cgit.cgi/error-report-web/tree/README](http://git.yoctoproject.org/cgit/cgit.cgi/error-report-web/tree/README).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you can use Linux utilities to parse Yocto's metadata and build output,
    BitBake lacks a command base UI for common tasks. One project that aims to provide
    it is `bb`, which is available at [https://github.com/kergoth/bb](https://github.com/kergoth/bb).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, you need to clone the repository locally by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Then run the `bb/bin/bb init` command, which prompts you to add a bash command
    to your `~/.bash_profile` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can either do that or execute it in your current shell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You will first need to set up your environment as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the commands only work with a populated work directory, so you may need
    to remove the `rm_work` class if you want to use `bb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the tasks that are made easier by the `bb` utility are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exploring the contents of a package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Searching for a pattern in the recipes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Displaying either the global BitBake environment or the environment for a specific
    package and grepping for a specific variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
