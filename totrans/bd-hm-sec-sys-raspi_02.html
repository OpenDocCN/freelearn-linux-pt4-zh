<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Connecting Things to Your Pi with GPIO"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Connecting Things to Your Pi with GPIO</h1></div></div></div><p>The Raspberry Pi has lots of ways to connect things to it, such as plugging things into the USB ports, connecting devices to the on-board camera and display ports, and connecting things to the various interfaces that make <a id="id54" class="indexterm"/>up the <span class="strong"><strong>GPIO connector</strong></span>. As part of our home security project, we'll be focusing mainly on connecting things to the GPIO connector.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Examining the GPIO connector and what each of the pins does</li><li class="listitem" style="list-style-type: disc">Learning about the I2C and SPI buses that will be used in later chapters</li><li class="listitem" style="list-style-type: disc">Connecting an LED and a switch safely to the data pins, and accessing these data pins using simple scripts</li><li class="listitem" style="list-style-type: disc">Understanding the USB ports and their limitations</li></ul></div><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Prerequisites</h1></div></div></div><p>Along with your<a id="id55" class="indexterm"/> Raspberry Pi, you'll need the following parts for the projects in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A breadboard</li><li class="listitem" style="list-style-type: disc">An LED</li><li class="listitem" style="list-style-type: disc">A 220 ohm resistor (red, red, black)</li><li class="listitem" style="list-style-type: disc">A 10K ohm resistor (brown, black, orange)</li><li class="listitem" style="list-style-type: disc">A pushbutton or toggle switch</li><li class="listitem" style="list-style-type: disc">A hook-up wire:<div class="mediaobject"><img src="graphics/B04579_02_09.jpg" alt="Prerequisites"/><div class="caption"><p>Our little collection of parts</p></div></div></li></ul></div></div></div>
<div class="section" title="Say hello to the GPIO"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Say hello to the GPIO</h1></div></div></div><p>The GPIO<a id="id56" class="indexterm"/> connector is the large group of pins on the edge of your Raspberry Pi board. On earlier models, there were 26 pins that made up this connector. But, ever since the Model B+, there have been 40 pins, although the first 26 pins are identical to the previous models, and it's these 26 pins we'll be working with. You won't need to worry about the rest of the pins.</p><p>Essentially, the GPIO connector provides<a id="id57" class="indexterm"/> access to following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Power supplies</li><li class="listitem" style="list-style-type: disc">Digital I/O pins</li><li class="listitem" style="list-style-type: disc">I2C bus</li><li class="listitem" style="list-style-type: disc">SPI bus</li><li class="listitem" style="list-style-type: disc">UART Serial bus</li></ul></div><p>Some of the pins on the GPIO have more than one purpose, depending on how they are programmed. The following diagram is a reference guide to all of the pins on the GPIO. The GPIO numbers on the yellow labels relate directly to those on the Broadcom chip, and are numbers<a id="id58" class="indexterm"/> generally used within the scripts.</p><div class="mediaobject"><img src="graphics/B04579_02_01.jpg" alt="Say hello to the GPIO"/></div><div class="section" title="Digital I/O pins"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Digital I/O pins</h2></div></div></div><p>The GPIO has 8 <a id="id59" class="indexterm"/>digital input/output pins available for use. These can<a id="id60" class="indexterm"/> be used to switch things on and off (in output mode), and also to detect when external things are switched on and off (input mode). Each pin can be configured independently for input or output operation, and I have labelled them <span class="strong"><strong>D0</strong></span> to <span class="strong"><strong>D7</strong></span> in the preceding diagram.</p><p>Obviously, if we were to use each of these pins to drive or sense an individual device, we would be limited to a maximum of 8 devices that could be connected to our home security system. In many scenarios, this is probably not enough, so in the next chapter we'll learn how to use the GPIO to connect many more things to our Raspberry Pi.</p></div><div class="section" title="The I2C bus"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>The I2C bus</h2></div></div></div><p>The <span class="strong"><strong>Inter-Integrated Circuit</strong></span> (<span class="strong"><strong>I2C</strong></span>) bus is a low-speed interface that can connect multiple devices <a id="id61" class="indexterm"/>and simple sensors using a 2-wire interface without the need for a separate clock or device select line. Typically, this <a id="id62" class="indexterm"/>bus can operate at speeds up to 100kbit/s. We'll be covering this in the next chapter to help us expand our digital I/O and connect more things.</p></div><div class="section" title="The SPI bus"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>The SPI bus</h2></div></div></div><p>The <span class="strong"><strong>Serial Peripheral Interface</strong></span> (<span class="strong"><strong>SPI</strong></span>) bus is a synchronous two-way serial connection between a master and<a id="id63" class="indexterm"/> a slave device. It can<a id="id64" class="indexterm"/> be used to access more complex sensors or drive displays.</p><p>The master device provides the synchronization, and each transmission is synchronized by a clock pulse on <span class="strong"><strong>SCLK</strong></span> (GPIO11/pin 23). Data is transmitted on the <span class="strong"><strong>MOSI</strong></span> (master-out-slave-in) and <span class="strong"><strong>MISO</strong></span> (master-in-slave-out) (pins 19 and 21 respectively).</p></div><div class="section" title="The UART serial bus"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>The UART serial bus</h2></div></div></div><p>The <span class="strong"><strong>Universal Asynchronous Receiver and Transmitter</strong></span> (<span class="strong"><strong>UART</strong></span>) bus is a way to communicate<a id="id65" class="indexterm"/> with external devices over a serial data connection, and is a common way for the Raspberry Pi to<a id="id66" class="indexterm"/> access data from devices such as GPS modules, which often come with serial connections. It can be a little bit fiddly getting the Pi set up to communicate with UART-connected devices, as it's also tied in with the operating system's serial console.</p></div><div class="section" title="USB ports"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>USB ports</h2></div></div></div><p>We're probably all <a id="id67" class="indexterm"/>familiar with <span class="strong"><strong>Universal Serial Bus</strong></span> (<span class="strong"><strong>USB</strong></span>) ports<a id="id68" class="indexterm"/> as we use them to connect all sorts of things to our PCs, such as keyboards, mouses, and hard disks. On the Raspberry Pi, it's just the same; we can connect keyboards, mouses, and dongles to give us Wi-Fi and Bluetooth connectivity.</p><div class="mediaobject"><img src="graphics/B04579_02_08.jpg" alt="USB ports"/><div class="caption"><p>Official Raspberry Pi USB Wi-Fi Dongle</p></div></div><p>On earlier Raspberry <a id="id69" class="indexterm"/>Pi models, the amount of current that the ports delivered was pretty low and caused all sorts of problems if too much current was drawn by the connected devices. This was significantly improved from the model B+ onwards, and it's now possible to connect GSM/LTE dongles<a id="id70" class="indexterm"/> without any problems.</p><p>There are still limitations, however, if you want to connect things such as hard disk drives; these can still draw more current than what can be supplied by the Raspberry Pi USB ports, so it's recommended that a powered USB hub or USB power injector be used when connecting these types of devices to your Pi.</p></div><div class="section" title="Power connections"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Power connections</h2></div></div></div><p>The GPIO connector also <a id="id71" class="indexterm"/>provides access to the on-board power supplies. The +5V connection (pins 2 and 4) is essentially the +5V input from the external power supply connected to the micro-USB power port. This can be used to power small external circuits if necessary, although it is recommended that an additional external +5V supply be used if significant current is required.</p><p>The +3.3V supply (pins 1 and 17) is the output from the on-board 3.3V regulator and provides a small amount of current up to 50mA. If you need to draw more than 50mA for your external circuits, then you should use an external power supply. I'll show you how to build one later in this book.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>The I/O pins on<a id="id72" class="indexterm"/> the Raspberry Pi operate at 3.3V levels. Connecting voltages higher than this to the pins could irreversibly damage your Pi. If you follow the instructions in this book, then everything should be fine, but randomly connecting things to<a id="id73" class="indexterm"/> your Pi that use lots of power will break it!</p></div></div></div></div>
<div class="section" title="Getting acquainted with the GPIO"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Getting acquainted with the GPIO</h1></div></div></div><p>Before we<a id="id74" class="indexterm"/> embark on connecting lots of things to our Pi board, it might be a good idea to just get acquainted with the GPIO through a couple of simple projects that will help us understand how to interact with the digital I/O pins using shell scripts.</p><div class="section" title="Let there be light"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Let there be light</h2></div></div></div><p>This simple<a id="id75" class="indexterm"/> little project shows how to connect a GPIO output to an LED, and switch it on and off using shell commands.</p><p>The following diagram shows how to connect up the circuit using a breadboard:</p><div class="mediaobject"><img src="graphics/B04579_02_02.jpg" alt="Let there be light"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>The pretty diagram that you just saw was produced using a free software tool from fritzing, which<a id="id76" class="indexterm"/> is an open-source hardware initiative to make electronics accessible as creative material for anyone. Download it from <a class="ulink" href="http://fritzing.org">fritzing.org</a>.</p></div></div><p>The LED anode (the positive side) is connected to the <span class="strong"><strong>D0</strong></span> digital I/O (pin 11 of the connector or GPIO17). When this pin is switched on, it will provide a 3.3V supply to the LED.</p><p>The LED is connected<a id="id77" class="indexterm"/> to the Ground pin via a 220R resistor on the cathode (negative side). The resistor limits the voltage to the LED and the current through it, otherwise it would burn out, as you can only supply up to about 2V to LEDs. With a current of around 10mA being drawn by the LED on a 3.3V supply, a 220R resistor works well to protect both it and the GPIO.</p><p>Here's the circuit diagram for it:</p><div class="mediaobject"><img src="graphics/B04579_02_03.jpg" alt="Let there be light"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>
<span class="strong"><strong>Calculating LED Resistor Values…</strong></span>
</p><p>While this book<a id="id78" class="indexterm"/> is not really a course on electronics theory, I thought it would be handy to show you how to work out the resistor values for LEDs using Ohms Law, as we'll be covering this again later.</p><p>As I mentioned, a typical LED will drop about 2V across it, although this varies according to color and type. This is called the forward voltage of the device or VLED.</p><p>The current required by an LED is around 10mA, again depending on its specification. We'll call this current flowing through the LED, ILED.</p><p>Essentially, the voltage across the resistor will be the supply voltage minus the voltage drop across the LED (for example,.2V). So, if we have a 12V supply (VS), the voltage across the resistor will be 10V (VS – VLED).</p><p>According to Ohms Law, the resistance R is the voltage across it divided by the current flowing through it: R = V / I. As we require 10mA flowing through it, with a voltage of 10V across it, the resistance required is 10V divided by 0.01A, which is 1,000 ohms or 1K.</p><p>In summary, R = (VS-VLED) / ILED.</p></div></div><p>Now, to turn the LED <a id="id79" class="indexterm"/>on and off: the GPIO pins are actually mapped as devices in the Linux file system, so using shell commands is easy, although there are many libraries available out there that allow you to control the GPIO using Python, for example. However, so that you don't have to learn a new language, we're going to do everything using shell commands.</p><p>The <span class="strong"><strong>D0</strong></span> pin that we are connected to is actually GPIO17 as far as the Raspberry Pi is concerned (take a look at the previous diagram for reference). The first thing we need to do is create file access to this GPIO pin. We do this with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo echo 17 &gt; /sys/class/gpio/export</strong></span>
</pre></div><p>We then have to set the pin's direction to out:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo echo out &gt; /sys/class/gpio/gpio17/direction</strong></span>
</pre></div><p>Next we can switch the pin on to turn the LED on:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo echo 1 &gt; /sys/class/gpio/gpio17/value</strong></span>
</pre></div><p>To switch the LED off, we use this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo echo 0 &gt; /sys/class/gpio/gpio17/value</strong></span>
</pre></div><p>Once we've finished with a GPIO port we can remove its file access:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo echo 17 &gt; /sys/class/gpio/unexport</strong></span>
</pre></div><div class="section" title="Getting flashy…"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Getting flashy…</h3></div></div></div><p>We can put these commands together in a single Bash script to create a flashing LED. To create the flashy script, create a new text file in<a id="id80" class="indexterm"/> <span class="strong"><strong>nano</strong></span> or some other text editor. Or, as I usually do (don't forget<a id="id81" class="indexterm"/> that I'm quite lazy), create the text file on your laptop, and then copy it to the remote Pi using <span class="strong"><strong>WinSCP</strong></span> (although, read my<a id="id82" class="indexterm"/> note in the box that follows if you want to prevent some heartache).</p><p>The following is the code listing for <code class="literal">led-flash.sh</code>:</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
sudo echo 17 &gt; /sys/class/gpio/export
sudo echo out &gt; /sys/class/gpio/gpio17/direction
# loop forever
while true
do
  sudo echo 1 &gt; /sys/class/gpio/gpio17/value
  sleep 0.5
  sudo echo 0 &gt; /sys/class/gpio/gpio17/value
  sleep 0.5
done</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>If you use Windows to create your files, remember to save your files with the end-of-line format being Linux (a single <code class="literal">0x0a</code> or Line Feed character) rather than Windows (<code class="literal">0x0a + 0x0d</code> or Line Feed + Carriage Return characters), otherwise you might find that your Bash script does not run properly on the Raspberry Pi. Text editors on Windows, such as the excellent Notepad++, will convert your script line ends for you.</p></div></div><p>Run the script by calling <code class="literal">led-flash.sh</code> (assuming that's what you've called it). If you're in the same directory as the script, this can be done by typing the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo bash ./led-flash.sh</strong></span>
</pre></div><p>Since this is an endless loop with the LED flashing on and off at half second intervals, you'll need to break out of it by using <span class="emphasis"><em>CTRL</em></span> + <span class="emphasis"><em>C</em></span> to stop the script.</p><p>Don't forget to remove the GPIO pin from file access by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo echo 17 &gt; /sys/class/gpio/unexport</strong></span>
</pre></div><p>Otherwise, you'll see the error, <code class="literal">echo:</code> <code class="literal">write</code> <code class="literal">error:</code> <code class="literal">Device</code> <code class="literal">or</code> <code class="literal">resource</code> <code class="literal">busy</code>, if you re-run the script, as the first line tries to set GPIO17 for file access again.</p></div></div><div class="section" title="Adding a switch"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Adding a switch</h2></div></div></div><p>In this project, we'll see how to connect a switch to a GPIO input and write a shell script to read the state <a id="id83" class="indexterm"/>of the switch—that is, whether it's switched on or off.</p><p>Connect a switch to your Pi's GPIO27 pin, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/B04579_02_04.jpg" alt="Adding a switch"/></div><div class="section" title="Pulling yourself together"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Pulling yourself together</h3></div></div></div><p>A really important thing to realize about GPIO inputs is that they are in what's called a <span class="emphasis"><em>floating state</em></span>. This means<a id="id84" class="indexterm"/> that, as far as the operating system is concerned, it doesn't know what its reference state is unless it is presented with a known voltage.</p><p>This is where our resistor comes into play—it pulls up the GPIO pin to a known voltage of 3.3V, which gives it a default state of HIGH (or binary <code class="literal">1</code>).</p><p>When the pushbutton switch is pressed, this takes the GPIO pin to 0V, which is a LOW state (or binary <code class="literal">0</code>).</p><p>Here's the circuit diagram for our GPIO switch:</p><div class="mediaobject"><img src="graphics/B04579_02_05.jpg" alt="Pulling yourself together"/></div></div><div class="section" title="The detection script"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>The detection script</h3></div></div></div><p>Now that we've connected the switch to our Raspberry Pi, we need to write a little script that will detect when the switch has been pushed.</p><p>It's similar<a id="id85" class="indexterm"/> to the previous LED script shown, but this time we'll set the GPIO pin as an input and read its logic level.</p><p>In this project, we've connected our switch to <span class="strong"><strong>D2</strong></span>, which is <span class="strong"><strong>GPIO27</strong></span> (again, refer to the earlier GPIO pin-out diagram). As before, we need to create file access for the pin by entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo echo 27 &gt; /sys/class/gpio/export</strong></span>
</pre></div><p>And now, set its direction to <code class="literal">in</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo echo in &gt; /sys/class/gpio/gpio27/direction</strong></span>
</pre></div><p>We're now ready to read its value, and we can do this with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo cat /sys/class/gpio/gpio17/value</strong></span>
</pre></div><p>You'll notice that it will have returned <code class="literal">1</code>, or a high state. This is because of the pull-up resistor we were talking about earlier. This means that its default state, when the switch isn't pushed, is high.</p><p>When the switch is pushed, the value should be read as <code class="literal">0</code> or low. If you have more than two hands, you can try this by pushing the button and re-running the command. Or, we can just create a script<a id="id86" class="indexterm"/> to poll the switch state.</p><p>The code listing for <code class="literal">poll-switch.sh</code> is as follows:</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
sudo echo 27 &gt; /sys/class/gpio/export
sudo echo in &gt; /sys/class/gpio/gpio27/direction

# loop forever
while true
do
  # read the switch state
  SWITCH=$(sudo cat /sys/class/gpio/gpio27/value)

  if [ $SWITCH == 1 ]; then
    #switch not pushed so wait for a second
    sleep 1
  else
    #switch was pushed
    echo "You've pushed my button"
  fi
done</pre></div><p>When you run the script and then push the button, you should see <code class="literal">You've pushed my button</code> scrolling up the console screen until you stop pressing it.</p><p>Don't forget that, once we've finished with the GPIO port, we can remove its file access:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo echo 27 &gt; /sys/class/gpio/unexport</strong></span>
</pre></div><p>We've now seen how to easily read a switch input, and the same circuit and script can be used to read other sensors, such as door contact switches, reed switches, or anything else that has an on and off state.</p></div></div></div>
<div class="section" title="The most elaborate light switch in the world"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>The most elaborate light switch in the world</h1></div></div></div><p>By combining the two little projects earlier, we can now create a system that will do something useful when the pushbutton switch is pushed—for example, switching on the LED that we also have <a id="id87" class="indexterm"/>connected. Granted, we could just connect the LED directly to the switch and a battery, but not only would that be boring, it would defeat the point of what we're trying to do, which is programmatically sensing and controlling things.</p><p>Here's the breadboard<a id="id88" class="indexterm"/> layout for our elaborate light switch:</p><div class="mediaobject"><img src="graphics/B04579_02_06.jpg" alt="The most elaborate light switch in the world"/></div><p>And here's the<a id="id89" class="indexterm"/> circuit diagram:</p><div class="mediaobject"><img src="graphics/B04579_02_07.jpg" alt="The most elaborate light switch in the world"/></div><div class="section" title="The illuminating script"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>The illuminating script</h2></div></div></div><p>Our full<a id="id90" class="indexterm"/> Bash script for our elaborate light switch is demonstrated next. This will loop endlessly, detecting the state of the switch GPIO pin, and will turn on the LED GPIO pin when the switch is pushed.</p><p>The code listing for <code class="literal">light-switch.sh </code>is as follows:</p><div class="informalexample"><pre class="programlisting">#!/bin/bash

#set up the LED GPIO pin
sudo echo 17 &gt; /sys/class/gpio/export
sudo echo out &gt; /sys/class/gpio/gpio17/direction

#set up the switch GPIO pin
sudo echo 27 &gt; /sys/class/gpio/export
sudo echo in &gt; /sys/class/gpio/gpio27/direction

# loop forever
while true
do
  # read the switch state
  SWITCH=$(sudo cat /sys/class/gpio/gpio27/value)

  #0=Pushed 1=Not Pushed
  if [ $SWITCH = "1" ]
  then
    #switch not pushed so turn off LED pin
    sudo echo 0 &gt; /sys/class/gpio/gpio17/value
  else
    #switch was pushed so turn on LED pin
    sudo echo 1 &gt; /sys/class/gpio/gpio17/value
  fi
  #short delay
  sleep 0.5
done</pre></div><p>So, here we are—we have a script that will detect an input state and do something in response; in this case, it will switch on an LED. We're now forming the basis of how we are going to put<a id="id91" class="indexterm"/> together our home security system.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Remember, don't connect anything to your Raspberry Pi in place of the LED, such as a buzzer or any other device that consumes lots of current. This is likely to irreversibly render your board dead. We'll look at ways, later on in this book, to control devices with higher power requirements.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we introduced various ways to connect your Raspberry Pi to the outside world by looking at the various interfaces available on the GPIO. We've understood how to connect things to the digital pins on your Raspberry Pi's GPIO connector, and control and read them using simple Bash scripts. In particular, we've safely and properly connected a switch to a digital input pin, which will form the foundation for our home security detection circuits.</p><p>In the next chapter, we'll look at ways to expand the number of things we can connect to our Raspberry Pi, overcoming the limitation of having just the 8 digital pins available to us on the GPIO by tapping into other interfaces on the GPIO and building our own input/output expansion board.</p></div></body></html>