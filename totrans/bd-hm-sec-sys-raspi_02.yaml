- en: Chapter 2. Connecting Things to Your Pi with GPIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi has lots of ways to connect things to it, such as plugging
    things into the USB ports, connecting devices to the on-board camera and display
    ports, and connecting things to the various interfaces that make up the **GPIO
    connector**. As part of our home security project, we'll be focusing mainly on
    connecting things to the GPIO connector.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the GPIO connector and what each of the pins does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the I2C and SPI buses that will be used in later chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting an LED and a switch safely to the data pins, and accessing these
    data pins using simple scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the USB ports and their limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along with your Raspberry Pi, you''ll need the following parts for the projects
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 220 ohm resistor (red, red, black)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 10K ohm resistor (brown, black, orange)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pushbutton or toggle switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hook-up wire:![Prerequisites](img/B04579_02_09.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our little collection of parts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Say hello to the GPIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GPIO connector is the large group of pins on the edge of your Raspberry
    Pi board. On earlier models, there were 26 pins that made up this connector. But,
    ever since the Model B+, there have been 40 pins, although the first 26 pins are
    identical to the previous models, and it's these 26 pins we'll be working with.
    You won't need to worry about the rest of the pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, the GPIO connector provides access to following:'
  prefs: []
  type: TYPE_NORMAL
- en: Power supplies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital I/O pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I2C bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPI bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UART Serial bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the pins on the GPIO have more than one purpose, depending on how they
    are programmed. The following diagram is a reference guide to all of the pins
    on the GPIO. The GPIO numbers on the yellow labels relate directly to those on
    the Broadcom chip, and are numbers generally used within the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Say hello to the GPIO](img/B04579_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Digital I/O pins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GPIO has 8 digital input/output pins available for use. These can be used
    to switch things on and off (in output mode), and also to detect when external
    things are switched on and off (input mode). Each pin can be configured independently
    for input or output operation, and I have labelled them **D0** to **D7** in the
    preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, if we were to use each of these pins to drive or sense an individual
    device, we would be limited to a maximum of 8 devices that could be connected
    to our home security system. In many scenarios, this is probably not enough, so
    in the next chapter we'll learn how to use the GPIO to connect many more things
    to our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: The I2C bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Inter-Integrated Circuit** (**I2C**) bus is a low-speed interface that
    can connect multiple devices and simple sensors using a 2-wire interface without
    the need for a separate clock or device select line. Typically, this bus can operate
    at speeds up to 100kbit/s. We'll be covering this in the next chapter to help
    us expand our digital I/O and connect more things.
  prefs: []
  type: TYPE_NORMAL
- en: The SPI bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Serial Peripheral Interface** (**SPI**) bus is a synchronous two-way serial
    connection between a master and a slave device. It can be used to access more
    complex sensors or drive displays.
  prefs: []
  type: TYPE_NORMAL
- en: The master device provides the synchronization, and each transmission is synchronized
    by a clock pulse on **SCLK** (GPIO11/pin 23). Data is transmitted on the **MOSI**
    (master-out-slave-in) and **MISO** (master-in-slave-out) (pins 19 and 21 respectively).
  prefs: []
  type: TYPE_NORMAL
- en: The UART serial bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Universal Asynchronous Receiver and Transmitter** (**UART**) bus is a
    way to communicate with external devices over a serial data connection, and is
    a common way for the Raspberry Pi to access data from devices such as GPS modules,
    which often come with serial connections. It can be a little bit fiddly getting
    the Pi set up to communicate with UART-connected devices, as it's also tied in
    with the operating system's serial console.
  prefs: []
  type: TYPE_NORMAL
- en: USB ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're probably all familiar with **Universal Serial Bus** (**USB**) ports as
    we use them to connect all sorts of things to our PCs, such as keyboards, mouses,
    and hard disks. On the Raspberry Pi, it's just the same; we can connect keyboards,
    mouses, and dongles to give us Wi-Fi and Bluetooth connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: '![USB ports](img/B04579_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Official Raspberry Pi USB Wi-Fi Dongle
  prefs: []
  type: TYPE_NORMAL
- en: On earlier Raspberry Pi models, the amount of current that the ports delivered
    was pretty low and caused all sorts of problems if too much current was drawn
    by the connected devices. This was significantly improved from the model B+ onwards,
    and it's now possible to connect GSM/LTE dongles without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: There are still limitations, however, if you want to connect things such as
    hard disk drives; these can still draw more current than what can be supplied
    by the Raspberry Pi USB ports, so it's recommended that a powered USB hub or USB
    power injector be used when connecting these types of devices to your Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Power connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GPIO connector also provides access to the on-board power supplies. The
    +5V connection (pins 2 and 4) is essentially the +5V input from the external power
    supply connected to the micro-USB power port. This can be used to power small
    external circuits if necessary, although it is recommended that an additional
    external +5V supply be used if significant current is required.
  prefs: []
  type: TYPE_NORMAL
- en: The +3.3V supply (pins 1 and 17) is the output from the on-board 3.3V regulator
    and provides a small amount of current up to 50mA. If you need to draw more than
    50mA for your external circuits, then you should use an external power supply.
    I'll show you how to build one later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The I/O pins on the Raspberry Pi operate at 3.3V levels. Connecting voltages
    higher than this to the pins could irreversibly damage your Pi. If you follow
    the instructions in this book, then everything should be fine, but randomly connecting
    things to your Pi that use lots of power will break it!
  prefs: []
  type: TYPE_NORMAL
- en: Getting acquainted with the GPIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we embark on connecting lots of things to our Pi board, it might be a
    good idea to just get acquainted with the GPIO through a couple of simple projects
    that will help us understand how to interact with the digital I/O pins using shell
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Let there be light
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simple little project shows how to connect a GPIO output to an LED, and
    switch it on and off using shell commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how to connect up the circuit using a breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let there be light](img/B04579_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pretty diagram that you just saw was produced using a free software tool
    from fritzing, which is an open-source hardware initiative to make electronics
    accessible as creative material for anyone. Download it from [fritzing.org](http://fritzing.org).
  prefs: []
  type: TYPE_NORMAL
- en: The LED anode (the positive side) is connected to the **D0** digital I/O (pin
    11 of the connector or GPIO17). When this pin is switched on, it will provide
    a 3.3V supply to the LED.
  prefs: []
  type: TYPE_NORMAL
- en: The LED is connected to the Ground pin via a 220R resistor on the cathode (negative
    side). The resistor limits the voltage to the LED and the current through it,
    otherwise it would burn out, as you can only supply up to about 2V to LEDs. With
    a current of around 10mA being drawn by the LED on a 3.3V supply, a 220R resistor
    works well to protect both it and the GPIO.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the circuit diagram for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let there be light](img/B04579_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Calculating LED Resistor Values…**'
  prefs: []
  type: TYPE_NORMAL
- en: While this book is not really a course on electronics theory, I thought it would
    be handy to show you how to work out the resistor values for LEDs using Ohms Law,
    as we'll be covering this again later.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned, a typical LED will drop about 2V across it, although this varies
    according to color and type. This is called the forward voltage of the device
    or VLED.
  prefs: []
  type: TYPE_NORMAL
- en: The current required by an LED is around 10mA, again depending on its specification.
    We'll call this current flowing through the LED, ILED.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the voltage across the resistor will be the supply voltage minus
    the voltage drop across the LED (for example,.2V). So, if we have a 12V supply
    (VS), the voltage across the resistor will be 10V (VS – VLED).
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Ohms Law, the resistance R is the voltage across it divided by
    the current flowing through it: R = V / I. As we require 10mA flowing through
    it, with a voltage of 10V across it, the resistance required is 10V divided by
    0.01A, which is 1,000 ohms or 1K.'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, R = (VS-VLED) / ILED.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to turn the LED on and off: the GPIO pins are actually mapped as devices
    in the Linux file system, so using shell commands is easy, although there are
    many libraries available out there that allow you to control the GPIO using Python,
    for example. However, so that you don''t have to learn a new language, we''re
    going to do everything using shell commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **D0** pin that we are connected to is actually GPIO17 as far as the Raspberry
    Pi is concerned (take a look at the previous diagram for reference). The first
    thing we need to do is create file access to this GPIO pin. We do this with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have to set the pin''s direction to out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we can switch the pin on to turn the LED on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch the LED off, we use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve finished with a GPIO port we can remove its file access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting flashy…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can put these commands together in a single Bash script to create a flashing
    LED. To create the flashy script, create a new text file in **nano** or some other
    text editor. Or, as I usually do (don't forget that I'm quite lazy), create the
    text file on your laptop, and then copy it to the remote Pi using **WinSCP** (although,
    read my note in the box that follows if you want to prevent some heartache).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code listing for `led-flash.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use Windows to create your files, remember to save your files with the
    end-of-line format being Linux (a single `0x0a` or Line Feed character) rather
    than Windows (`0x0a + 0x0d` or Line Feed + Carriage Return characters), otherwise
    you might find that your Bash script does not run properly on the Raspberry Pi.
    Text editors on Windows, such as the excellent Notepad++, will convert your script
    line ends for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script by calling `led-flash.sh` (assuming that''s what you''ve called
    it). If you''re in the same directory as the script, this can be done by typing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since this is an endless loop with the LED flashing on and off at half second
    intervals, you'll need to break out of it by using *CTRL* + *C* to stop the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to remove the GPIO pin from file access by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, you'll see the error, `echo:` `write` `error:` `Device` `or` `resource`
    `busy`, if you re-run the script, as the first line tries to set GPIO17 for file
    access again.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, we'll see how to connect a switch to a GPIO input and write
    a shell script to read the state of the switch—that is, whether it's switched
    on or off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect a switch to your Pi''s GPIO27 pin, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a switch](img/B04579_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pulling yourself together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A really important thing to realize about GPIO inputs is that they are in what's
    called a *floating state*. This means that, as far as the operating system is
    concerned, it doesn't know what its reference state is unless it is presented
    with a known voltage.
  prefs: []
  type: TYPE_NORMAL
- en: This is where our resistor comes into play—it pulls up the GPIO pin to a known
    voltage of 3.3V, which gives it a default state of HIGH (or binary `1`).
  prefs: []
  type: TYPE_NORMAL
- en: When the pushbutton switch is pressed, this takes the GPIO pin to 0V, which
    is a LOW state (or binary `0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the circuit diagram for our GPIO switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pulling yourself together](img/B04579_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The detection script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we've connected the switch to our Raspberry Pi, we need to write a
    little script that will detect when the switch has been pushed.
  prefs: []
  type: TYPE_NORMAL
- en: It's similar to the previous LED script shown, but this time we'll set the GPIO
    pin as an input and read its logic level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we''ve connected our switch to **D2**, which is **GPIO27**
    (again, refer to the earlier GPIO pin-out diagram). As before, we need to create
    file access for the pin by entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, set its direction to `in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to read its value, and we can do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that it will have returned `1`, or a high state. This is because
    of the pull-up resistor we were talking about earlier. This means that its default
    state, when the switch isn't pushed, is high.
  prefs: []
  type: TYPE_NORMAL
- en: When the switch is pushed, the value should be read as `0` or low. If you have
    more than two hands, you can try this by pushing the button and re-running the
    command. Or, we can just create a script to poll the switch state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code listing for `poll-switch.sh` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When you run the script and then push the button, you should see `You've pushed
    my button` scrolling up the console screen until you stop pressing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget that, once we''ve finished with the GPIO port, we can remove
    its file access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We've now seen how to easily read a switch input, and the same circuit and script
    can be used to read other sensors, such as door contact switches, reed switches,
    or anything else that has an on and off state.
  prefs: []
  type: TYPE_NORMAL
- en: The most elaborate light switch in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By combining the two little projects earlier, we can now create a system that
    will do something useful when the pushbutton switch is pushed—for example, switching
    on the LED that we also have connected. Granted, we could just connect the LED
    directly to the switch and a battery, but not only would that be boring, it would
    defeat the point of what we're trying to do, which is programmatically sensing
    and controlling things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the breadboard layout for our elaborate light switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The most elaborate light switch in the world](img/B04579_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s the circuit diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The most elaborate light switch in the world](img/B04579_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The illuminating script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our full Bash script for our elaborate light switch is demonstrated next. This
    will loop endlessly, detecting the state of the switch GPIO pin, and will turn
    on the LED GPIO pin when the switch is pushed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code listing for `light-switch.sh` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, here we are—we have a script that will detect an input state and do something
    in response; in this case, it will switch on an LED. We're now forming the basis
    of how we are going to put together our home security system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, don't connect anything to your Raspberry Pi in place of the LED, such
    as a buzzer or any other device that consumes lots of current. This is likely
    to irreversibly render your board dead. We'll look at ways, later on in this book,
    to control devices with higher power requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced various ways to connect your Raspberry Pi to
    the outside world by looking at the various interfaces available on the GPIO.
    We've understood how to connect things to the digital pins on your Raspberry Pi's
    GPIO connector, and control and read them using simple Bash scripts. In particular,
    we've safely and properly connected a switch to a digital input pin, which will
    form the foundation for our home security detection circuits.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at ways to expand the number of things we can
    connect to our Raspberry Pi, overcoming the limitation of having just the 8 digital
    pins available to us on the GPIO by tapping into other interfaces on the GPIO
    and building our own input/output expansion board.
  prefs: []
  type: TYPE_NORMAL
