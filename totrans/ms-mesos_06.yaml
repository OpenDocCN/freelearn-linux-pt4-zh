- en: Chapter 6. Mesos Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. Mesos框架
- en: 'This chapter walks the reader through the concept and features of Mesos frameworks
    in detail. It also provides a detailed overview of the Mesos API, including the
    new HTTP Scheduler API, and provides the recipe for building custom frameworks
    on Mesos. The following topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细讲解了Mesos框架的概念和功能。还提供了Mesos API的详细概述，包括新的HTTP调度器API，并提供了在Mesos上构建自定义框架的具体方案。本章将涵盖以下主题：
- en: Introduction to Mesos frameworks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos框架简介
- en: Framework authentication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架认证
- en: Framework authorization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架授权
- en: Access Control Lists (ACLs)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制列表（ACL）
- en: The scheduler HTTP API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器HTTP API
- en: Building custom distributed frameworks on Mesos
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mesos上构建自定义分布式框架
- en: Introduction to Mesos frameworks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos框架简介
- en: 'A Mesos framework sits between Mesos and the application and acts as a layer
    for managing task scheduling and execution. As its implementation is application-specific,
    the term is often used to refer to the application itself. Earlier, a Mesos framework
    could interact with the Mesos API using only the libmesos C++ library, due to
    which other language bindings were developed for Java, Scala, Python, and Go among
    others, which leveraged libmesos heavily. Since v0.19.0, changes made to the HTTP-based
    protocol enabled developers to develop frameworks using the language they wanted
    without having to rely on the C++ code. A framework consists of two components:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos框架位于Mesos与应用程序之间，充当管理任务调度和执行的层。由于其实现是应用程序特定的，因此该术语通常用于指代应用程序本身。早期，Mesos框架只能通过libmesos
    C++库与Mesos API进行交互，因此开发了其他语言绑定，例如Java、Scala、Python和Go等，这些语言绑定大量依赖libmesos。从v0.19.0版本开始，对基于HTTP的协议进行了更改，开发者可以使用他们想要的编程语言来开发框架，而不必依赖C++代码。一个框架由两个组件组成：
- en: A scheduler
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个调度器
- en: An executor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个执行者
- en: The **scheduler** is responsible for taking decisions on the resource offers
    made to it and tracking the current state of the cluster. Communication with the
    Mesos master is handled by the `SchedulerDriver` module, which registers the framework
    with the master, launches tasks, and passes messages to other components.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**调度器**负责对它所接收到的资源提供做出决策，并跟踪集群的当前状态。与Mesos主节点的通信由`SchedulerDriver`模块处理，该模块负责将框架注册到主节点、启动任务并向其他组件传递消息。'
- en: The second component, **Executor**, as its name suggests, is responsible for
    the execution of tasks on the slave nodes. Communication with the slaves is handled
    by the `ExecutorDriver` module, which is also responsible for sending status updates
    to the scheduler.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件，**执行者**，顾名思义，负责在从属节点上执行任务。与从属节点的通信由`ExecutorDriver`模块处理，该模块还负责向调度器发送状态更新。
- en: Frameworks – Authentication, authorization, and access control
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架 – 认证、授权和访问控制
- en: 'From the user''s perspective, authentication, authorization, and access control
    often appear to be the same thing because they are typically implemented together.
    However, there are some important distinctions between them. Some of these are
    listed below to provide better clarity on what each of these concepts means:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，认证、授权和访问控制通常被认为是同一回事，因为它们通常一起实现。然而，它们之间有一些重要的区别。以下列出了一些区别，以帮助更清楚地理解这些概念的含义：
- en: '**Authentication:** Authentication is a process by which you verify that someone
    or something is who or what they claim to be, respectively. It typically involves
    implementing one or more methods of demonstrating identity. The result of an authentication
    procedure is normally a yes/no answer.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证：** 认证是一个过程，旨在验证某人或某物是否如其所声称的那样。它通常涉及实现一种或多种证明身份的方法。认证过程的结果通常是一个“是/否”答案。'
- en: '**Authorization:** Authorization is used to establish whether the application
    or user (already authenticated) is allowed to perform the requested task. It is
    used to define and determine what an authenticated application/user can and cannot
    do. An authorization module typically includes a mechanism for defining rules
    (such as roles, privileges, and so on).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权：** 授权用于确定应用程序或用户（已经通过身份验证）是否被允许执行请求的任务。它用于定义和确定经过身份验证的应用程序/用户可以做什么以及不能做什么。一个授权模块通常包括一个定义规则的机制（如角色、权限等）。'
- en: '**Access Control:** Access Control is the process of ensuring that nonauthenticated
    or unauthorized applications/users cannot bypass the system and perform restricted
    actions. It typically involves implementing a variety of security features to
    ensure that no loopholes are present in the system.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制**：访问控制是确保未认证或未授权的应用程序/用户无法绕过系统并执行受限操作的过程。它通常涉及实现多种安全功能，以确保系统中没有安全漏洞。'
- en: Framework authentication
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架认证
- en: Framework authentication support for Mesos was added v0.15 onward, and slave
    authentication support was introduced in v0.19\. This is a very useful feature
    to prevent unauthorized applications from running on Mesos.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Mesos v0.15 开始，添加了对框架认证的支持，v0.19 引入了从节点认证支持。这是一个非常有用的功能，可以防止未授权的应用程序在 Mesos
    上运行。
- en: For a framework to register with the Mesos master, it needs to be authenticated.
    Similarly, the authentication of slaves is necessary for them to be able to register
    with the master as otherwise, unauthorized processes could launch **Distributed
    Denial of Service** (**DDoS**) attacks, obtain task information, and so on. It
    also prohibits rogue access to the `/teardown` HTTP endpoint so that the frameworks
    can't be illegally terminated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使框架能够注册到 Mesos 主节点，必须先进行认证。类似地，认证从节点也是必需的，否则它们无法注册到主节点，因为未授权的进程可能发起 **分布式拒绝服务**
    (**DDoS**) 攻击、获取任务信息等。这还防止了恶意访问 `/teardown` HTTP 端点，确保框架不会被非法终止。
- en: The **Cyrus Simple Authentication and Security Layer** (**SASL**) library, a
    flexible framework with support for various mechanisms, such as CRAM-MD5, Plain,
    GSSAPI, and so on, is leveraged by Mesos to enable authentication. The **CRAM-MD5**
    mechanism is currently supported by Mesos though users have the ability to implement
    their own modules as well. CRAM-MD5 implements a shared secret authentication
    mechanism in which a principal (in this case, the framework) and authenticator
    (Mesos) share a mutually known "secret" key with each other to encrypt and decrypt
    information. Whenever the framework communicates with Mesos, it is asked to decrypt
    or encrypt information successfully using this "secret" key so that Mesos can
    understand that it is really the authorized framework that wishes to communicate
    with it. It should be noted that this is not the same as the framework user, which
    is what an executor uses to run tasks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cyrus 简单认证与安全层** (**SASL**) 库是一个灵活的框架，支持多种认证机制，如 CRAM-MD5、Plain、GSSAPI 等，Mesos
    利用该库实现认证功能。当前 Mesos 支持 **CRAM-MD5** 机制，但用户也可以实现自己的模块。CRAM-MD5 实现了一种共享密钥认证机制，在这种机制中，主体（在此案例中为框架）和认证者（Mesos）共享一个彼此已知的“秘密”密钥，用于加密和解密信息。每当框架与
    Mesos 通信时，它都需要成功地使用该“秘密”密钥来解密或加密信息，以便 Mesos 确认其确实是授权的框架在与之通信。需要注意的是，这与框架用户不同，框架用户是执行任务的执行器所使用的身份。'
- en: Configuration options
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置选项
- en: 'The authentication module uses the following configuration options:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 认证模块使用以下配置选项：
- en: 'Masters:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点：
- en: '`--[no-]authenticate`: If `true`, then the registration of authenticated frameworks
    is permitted. If `false`, then other frameworks can register as well.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--[no-]authenticate`：如果为`true`，则允许已认证框架的注册。如果为`false`，则其他框架也可以注册。'
- en: '`--[no-]authenticate_slaves`: If `true`, then the registration of authenticated
    slaves is permitted. If `false`, then other slaves can register as well.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--[no-]authenticate_slaves`：如果为`true`，则允许已认证从节点的注册。如果为`false`，则其他从节点也可以注册。'
- en: '`--authenticators`: This is used to specify which authentication mechanism
    needs to be used to authenticate the master, with CRAM-MD5 being the default.
    The `–modules` option may be used to add other mechanisms as well.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--authenticators`：用于指定需要用于认证主节点的认证机制，默认使用 CRAM-MD5。`–modules` 选项也可以用来添加其他认证机制。'
- en: '`--credentials`: This is used to specify the location of the file containing
    a valid credentials list and can be optional based on which mechanism is employed
    for authentication.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--credentials`：用于指定包含有效凭据列表的文件位置，具体是否需要取决于使用的认证机制。'
- en: 'Slaves:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从节点：
- en: '`--authenticate`: This is used to specify which authentication mechanism needs
    to be used to authenticate the slave, with CRAM-MD5 being the default.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--authenticate`：用于指定需要用于认证从节点的认证机制，默认使用 CRAM-MD5。'
- en: '`--credential`: This is used to specify the location of the file containing
    the credentials, which needs to be used to determine the slave.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--credential`：用于指定包含凭据的文件的位置，该凭据用于确定从属节点。'
- en: Framework authorization
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架授权
- en: Authorization refers to the process of determining whether an already authenticated
    user has the required permissions to execute the requested task or access specific
    resources. Since Mesos 0.24, the authorization API has been modularized so that
    system administrators can implement authorization backend/protocols of their choice
    (Lightweight directory access protocol or LDAP, for example).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 授权指的是确定已经通过身份验证的用户是否具有执行请求任务或访问特定资源的所需权限的过程。从 Mesos 0.24 开始，授权 API 被模块化，系统管理员可以实现他们选择的授权后台/协议（例如轻量级目录访问协议或
    LDAP）。
- en: When starting the master, authorization can be configured by specifying the
    `--acls` flag.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 启动主节点时，可以通过指定`--acls`标志来配置授权。
- en: 'The following authorizations are currently supported:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当前支持以下授权：
- en: The registration of frameworks with specified roles
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有指定角色的框架注册
- en: Task launching by frameworks as authorized users
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架作为授权用户启动任务
- en: The shutting down of frameworks by authorized principals
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权主体关闭框架
- en: Quota setting by authorized principals
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权主体设置配额
- en: Reservation and freeing up of resources by authorized principals
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权主体的资源预留和释放
- en: Creation and destruction of persistent volumes by authorized principals
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权主体创建和销毁持久化卷
- en: Access Control Lists (ACLs)
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制列表（ACLs）
- en: '**Access Control Lists** or **ACLs** are used to implement *authorization*
    capabilities in Mesos. An ACL needs to be defined in the JSON format for each
    of the six supported authorizations mentioned before. In every ACL, a list of
    Subjects need to be defined that can carry out Actions on a group of Objects.
    The Mesos master then checks these to confirm whether a request received by it
    is an authorized one or not.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问控制列表**（**ACLs**）用于在 Mesos 中实现*授权*功能。每个之前提到的六种支持的授权都需要以 JSON 格式定义 ACL。在每个
    ACL 中，必须定义一个主体列表，这些主体可以对一组对象执行操作。Mesos 主节点随后检查这些 ACL，以确认它接收到的请求是否是授权的。'
- en: 'The supported Actions list is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的操作列表如下：
- en: '`register_frameworks`: This is used for framework registration'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register_frameworks`：用于框架注册'
- en: '`run_tasks`: This is used to run tasks'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_tasks`：用于运行任务'
- en: '`shutdown_frameworks`: This is used to terminate frameworks'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown_frameworks`：用于终止框架'
- en: '`set_quotas`: This is used for quota setting'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_quotas`：用于配额设置'
- en: '`reserve_resources`: This is used for resource reservation'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reserve_resources`：用于资源预留'
- en: '`unreserve_resources` : This is used to free up resources'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unreserve_resources`：用于释放资源'
- en: '`create_volumes`: This is used to create persistent volumes'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_volumes`：用于创建持久化卷'
- en: '`destroy_volumes`: This is used to destroy persistent volumes'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy_volumes`：用于销毁持久化卷'
- en: 'The supported `Subjects` list is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的`主体`列表如下：
- en: '`principals`: These can be of two types:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`principals`：这些可以分为两种类型：'
- en: Framework principals
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架主体
- en: Usernames
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: 'The supported `Objects` list is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的`对象`列表如下：
- en: '`roles`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roles`'
- en: '`users`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`'
- en: '`framework_principals`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`framework_principals`'
- en: '`resources`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`'
- en: '`reserver_principals`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reserver_principals`'
- en: '`volume_types`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume_types`'
- en: '`creator_principals`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`creator_principals`'
- en: For example, when a framework attempts to register with the master, it checks
    the `register_frameworks` ACLs to verify that the framework attempting to register
    with it is authorized to receive resources offers for the specified role. The
    scheduler is terminated, and an error message is sent if the framework is an unauthorized
    one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一个框架尝试注册到主节点时，系统会检查 `register_frameworks` ACL，验证尝试注册的框架是否被授权接收指定角色的资源报价。如果框架未授权，调度器将终止，并发送错误消息。
- en: Another example is that of a framework trying to launch a set of tasks. In this
    case, the `run_tasks` ACLs are checked to verify that the framework is permitted
    to run the required tasks and as the specified user. A `TASK_LOST` message is
    sent back if the framework is unauthorized and the tasks do not get launched.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是一个框架尝试启动一组任务的情况。在这种情况下，会检查 `run_tasks` ACL 以验证框架是否被允许运行所需的任务，并且作为指定的用户。如果框架没有授权，系统会发送一个
    `TASK_LOST` 消息，任务不会启动。
- en: For more information, visit [http://mesos.apache.org/documentation/latest/authorization/](http://mesos.apache.org/documentation/latest/authorization/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请访问 [http://mesos.apache.org/documentation/latest/authorization/](http://mesos.apache.org/documentation/latest/authorization/)。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ACLs are checked in setup order; that is, the first relevant ACL is used to
    determine the request authorization status.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ACL 按照设置顺序进行检查；即使用第一个相关的 ACL 来确定请求的授权状态。
- en: The `ACLs.permissive` field determines how a nonmatching request should be treated.
    The default is `true`, which means that if no matching ACL exists, then the request
    is authorized.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACLs.permissive` 字段决定如何处理不匹配的请求。默认值为 `true`，意味着如果没有匹配的 ACL，请求将被授权。'
- en: Examples
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'A few examples of how to implement ACLs are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 ACL 的几个示例如下：
- en: 'The `A` and `B` frameworks can run tasks as user `U`. Take a look at the following
    code:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A` 和 `B` 框架可以作为用户 `U` 运行任务。请看以下代码：'
- en: '[PRE0]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The framework `A` can run tasks only as user `guest` and no other user, as
    demonstrated by the following code:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架 `A` 只能以用户 `guest` 运行任务，不能以其他用户运行，代码如下所示：
- en: '[PRE1]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The framework `A` can only register with the `X` role but no other roles. Also,
    no other framework can register with any roles, as in the following code:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架 `A` 只能注册 `X` 角色，不能注册其他角色。此外，其他框架也不能注册任何角色，具体代码如下：
- en: '[PRE2]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Mesos API
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos API
- en: Mesos provides an API to allow developers to build custom frameworks that can
    run on top of the underlying distributed infrastructure. Refer to the *API details*
    section in [Chapter 1](ch01.html "Chapter 1. Introducing Mesos"), *Introducing
    Mesos* for a detailed explanation of the Mesos API. The detailed steps involved
    in developing bespoke frameworks leveraging this API will be described in the
    subsequent section with the help of an example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 提供了一个 API，允许开发者构建自定义框架，可以在底层分布式基础设施上运行。有关 Mesos API 的详细解释，请参阅 [第 1 章](ch01.html
    "第 1 章：Mesos 简介")中的 *API 详情* 部分。利用该 API 开发定制框架的详细步骤将在后续章节中通过示例进行描述。
- en: Mesos also implements an **actor style message-passing programming model** to
    enable nonblocking communication between different Mesos components and leverages
    protocol buffers for the same.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 还实现了 **演员式消息传递编程模型**，以实现不同 Mesos 组件之间的非阻塞通信，并利用协议缓冲区实现这一目标。
- en: In addition, there is also a new scheduler HTTP API that was recently introduced,
    and it will be briefly discussed in the next section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，最近还推出了新的调度器 HTTP API，接下来将简要讨论。
- en: The scheduler HTTP API
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度器 HTTP API
- en: Since Mesos version 0.24.0, experimental support has been introduced for a new
    HTTP API (only scheduler for the time being). The Mesos master hosts the `api/v1/scheduler`
    endpoint with which the scheduler communicates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Mesos 版本 0.24.0 起，引入了对新的 HTTP API（目前仅支持调度器）的实验性支持。Mesos 主节点托管 `api/v1/scheduler`
    端点，调度器通过该端点与主节点进行通信。
- en: Request Calls
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求调用
- en: 'The master currently accepts the following request calls:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点当前接受以下请求调用：
- en: Subscribe
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅
- en: The scheduler `sends` a `Subscribe` message, including the relevant framework
    information such as name and so on, via an `HTTP POST` request to enable communication
    with the master. The response includes a subscription confirmation and details
    such as the framework ID, which will be used in all subsequent communications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器通过`HTTP POST`请求发送一个`Subscribe`消息，包含相关的框架信息，例如名称等，以便与主节点进行通信。响应包括订阅确认和框架 ID
    等详细信息，后续所有的通信都会使用该 ID。
- en: 'The `SUBSCRIBE` request (JSON) is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUBSCRIBE` 请求（JSON）如下：'
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `SUBSCRIBE` response (JSON) is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUBSCRIBE` 响应（JSON）如下：'
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: TEARDOWN
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TEARDOWN
- en: The scheduler sends this request when it wants to shut itself. When it receives
    this request, Mesos will terminate all executors, killing all the running tasks
    in the process. It will then proceed to remove the framework and end all communication
    between the Mesos master and scheduler.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器在希望关闭自己时发送此请求。接收到此请求后，Mesos 将终止所有执行器，终止所有正在运行的任务。然后，Mesos 会移除框架并结束主节点与调度器之间的所有通信。
- en: 'The `TEARDOWN` request (JSON) is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEARDOWN` 请求（JSON）如下：'
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `TEARDOWN` response is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEARDOWN` 响应如下：'
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ACCEPT
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ACCEPT
- en: When the scheduler wants to accept the resource offers made by the Mesos master,
    it sends this request. The operations that the scheduler intends to carry out
    are included as parameters in the request (for example, launch task, create volumes,
    and reserve resources).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当调度器想要接受 Mesos 主节点提供的资源时，它会发送此请求。调度器打算执行的操作作为参数包含在请求中（例如，启动任务、创建卷和保留资源）。
- en: 'The `ACCEPT` request (JSON) is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACCEPT` 请求（JSON）如下：'
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `ACCEPT` response is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACCEPT` 响应如下：'
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: DECLINE
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DECLINE
- en: When the scheduler wants to decline the resource offers made by the Mesos master,
    it sends this request.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当调度器想要拒绝 Mesos 主节点提供的资源时，它会发送此请求。
- en: 'The `DECLINE` request (JSON) is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECLINE` 请求（JSON）如下：'
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `DECLINE` response is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECLINE` 响应如下：'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: REVIVE
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REVIVE
- en: If any filters are set by prior accept or decline requests, then the scheduler
    can send a revive call to remove them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的接受或拒绝请求设置了过滤器，则调度器可以发送 revive 调用来移除它们。
- en: 'The `REVIVE` request (JSON) is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`REVIVE` 请求（JSON）如下：'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `REVIVE` response is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`REVIVE` 响应如下：'
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: KILL
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KILL
- en: If a specific task needs to be killed, then the scheduler can send a `KILL`
    request. If a custom executor is present, then the request is passed on to this
    executor, in which it can be processed. If the master is unaware of the task that
    is requested to be killed, it will generate a `Task_Lost` message.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要终止特定任务，则调度器可以发送 `KILL` 请求。如果存在自定义执行器，则请求将传递给该执行器，由其处理。如果主节点未知道需要终止的任务，它将生成
    `Task_Lost` 消息。
- en: 'The `KILL` request (JSON) is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`KILL` 请求（JSON）如下：'
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `KILL` response is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`KILL` 响应如下：'
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: SHUTDOWN
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SHUTDOWN
- en: This newly introduced call is sent by the scheduler when it wants to end specific
    custom executors.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当调度器希望结束特定自定义执行器时，会发送此新引入的调用。
- en: 'The `SHUTDOWN` request (JSON) is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHUTDOWN` 请求（JSON）如下：'
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `SHUTDOWN` response is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHUTDOWN` 响应如下：'
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ACKNOWLEDGE
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ACKNOWLEDGE
- en: When a status update needs to be acknowledged, the scheduler sends this request.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要确认状态更新时，调度器发送此请求。
- en: 'The `ACKNOWLEDGE` request (JSON) is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACKNOWLEDGE` 请求（JSON）如下：'
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `ACKNOWLEDGE` response is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACKNOWLEDGE` 响应如下：'
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: RECONCILE
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RECONCILE
- en: When the status nonterminal tasks needs to be queried, the scheduler sends this
    request. For every task in the list, an Update event is sent back by the master.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要查询状态非终结任务时，调度器发送此请求。对于列表中的每个任务，主节点会返回一个更新事件。
- en: 'The `RECONCILE` request (JSON) is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`RECONCILE` 请求（JSON）如下：'
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `RECONCILE` response is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`RECONCILE` 响应如下：'
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: MESSAGE
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MESSAGE
- en: If arbitrary binary data needs to be sent to the executor, the scheduler makes
    use of this request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将任意二进制数据发送到执行器，调度器使用此请求。
- en: 'The `MESSAGE` request (JSON) is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`MESSAGE` 请求（JSON）如下：'
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `MESSAGE` response is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`MESSAGE` 响应如下：'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: REQUEST
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REQUEST
- en: This is used by the scheduler to request resources from the master.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调度器向主节点请求资源时使用的。
- en: 'The `REQUEST` request (JSON) is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`REQUEST` 请求（JSON）如下：'
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `REQUEST` response is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`REQUEST` 响应如下：'
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Response events
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应事件
- en: The master currently sends the following events as responses.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点当前作为响应发送以下事件。
- en: SUBSCRIBED
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SUBSCRIBED
- en: 'When a `Subscribe` request is made by the scheduler, the first event sent by
    the master is the `Subscribed` event. The format is given as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当调度器发出 `Subscribe` 请求时，主节点发送的第一个事件是 `Subscribed` 事件。格式如下所示：
- en: 'The `SUBSCRIBED` event (JSON) is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUBSCRIBED` 事件（JSON）如下：'
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: OFFERS
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OFFERS
- en: The master sends this event whenever it can offer frameworks a new set of resources.
    Every offer corresponds to a group of resources on a slave. The resources are
    assumed to be allocated till the scheduler makes an `Accept` or `Decline` call
    to the master. The offer is rescinded if a slave is lost or times out.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当主节点能够向框架提供一组新资源时，它会发送此事件。每个 offer 对应于一个从属节点上的资源组。假设这些资源已经分配，直到调度器向主节点发出 `Accept`
    或 `Decline` 调用。如果丢失从属节点或超时，offer 会被撤销。
- en: 'The `OFFERS` event (JSON) is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`OFFERS` 事件（JSON）如下：'
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: RESCIND
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RESCIND
- en: When an offer's validity expires (for example, when the slave mentioned in the
    offer is lost) the master sends this event to rescind the offer. If the scheduler
    makes any calls in the future, these are considered invalid.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 offer 的有效期到期（例如，当 offer 中提到的从属节点丢失时），主节点会发送此事件撤销该 offer。如果调度器在未来做出任何调用，这些
    offer 会被视为无效。
- en: 'The `RESCIND` event (JSON) is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESCIND` 事件（JSON）如下：'
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: UPDATE
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: The master sends this event if the executor creates a status update regarding
    the running tasks. For example, if the `Task_Finished` update is generated, then
    the master can release the resources given to the task for use elsewhere.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行器创建了有关正在运行任务的状态更新，主节点会发送此事件。例如，如果生成了`Task_Finished`更新，主节点可以释放分配给任务的资源以供其他地方使用。
- en: 'The `UPDATE` event (JSON) is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE` 事件（JSON）如下：'
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: MESSAGE
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息
- en: The Mesos master forwards executor-generated messages to the scheduler without
    interpretation or delivery guarantee by passing the `Message` event. If the message
    delivery fails for any reason, the executor needs to resend the request.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 主节点通过传递 `Message` 事件，将执行器生成的消息转发给调度器，不进行解释或交付保证。如果消息传递因任何原因失败，执行器需要重新发送请求。
- en: 'The `MESSAGE` event (JSON) is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`MESSAGE` 事件（JSON）如下：'
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: FAILURE
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 失败
- en: The master sends this event upon slave removal or executor termination.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点在从属节点移除或执行器终止时发送此事件。
- en: 'The `FAILURE` event (JSON) is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`FAILURE` 事件（JSON）如下：'
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ERROR
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误
- en: The master sends this event upon the occurrence of an error (for example, a
    framework with the given role unauthorized to subscribe to the requested resources).
    The recommendation is that the framework should abort upon the receipt of this
    event and the resubscribe.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点在发生错误时发送此事件（例如，某个角色的框架未经授权订阅请求的资源）。推荐做法是框架在收到此事件后应中止并重新订阅。
- en: 'The `ERROR` event (JSON) is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`ERROR` 事件（JSON）如下：'
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: HEARTBEAT
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 心跳
- en: The master sends this event at periodic intervals to communicate to the scheduler
    that an established subscribed connection is alive. This helps make sure that
    a live connection is not terminated due to insufficient data movement.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点在固定时间间隔内发送此事件，以通知调度器已建立的订阅连接处于活动状态。这有助于确保活跃连接不会因数据传输不足而被终止。
- en: 'The `HEARTBEAT` event (JSON) is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEARTBEAT` 事件（JSON）如下：'
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For more information regarding the scheduler HTTP API, visit [http://mesos.apache.org/documentation/latest/scheduler-http-api/](http://mesos.apache.org/documentation/latest/scheduler-http-api/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有关调度器 HTTP API 的更多信息，请访问 [http://mesos.apache.org/documentation/latest/scheduler-http-api/](http://mesos.apache.org/documentation/latest/scheduler-http-api/)。
- en: Building a custom framework on Mesos
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Mesos 上构建自定义框架
- en: 'As we already know, a Mesos framework is an application running on Mesos. In
    this module, we will see how we can create our own Mesos framework. For the sake
    of simplicity, we will create a simple Java application to calculate the value
    of *pi*. A Mesos framework consists of the following three components:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，Mesos 框架是运行在 Mesos 上的应用程序。在本模块中，我们将了解如何创建我们自己的 Mesos 框架。为了简化起见，我们将创建一个简单的
    Java 应用程序来计算 *pi* 的值。一个 Mesos 框架由以下三个组件组成：
- en: '**Driver**: This is the piece of code that submits tasks to the framework'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**驱动程序**：这是将任务提交到框架的代码部分'
- en: '**Executor:** This is the piece of code that is launched on the Mesos slave
    nodes to run the framework''s tasks'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行器**：这是在 Mesos 从属节点上启动的用于运行框架任务的代码部分'
- en: '**Scheduler**: This is the piece of code that registers with the master, asks
    for resources from it, and runs tasks on the executor'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器**：这是与主节点注册、向其请求资源并在执行器上运行任务的代码部分'
- en: Now, let's take a look at how we can develop each of these components to build
    a custom Mesos framework in the following sections.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在接下来的章节中开发这些组件以构建自定义的 Mesos 框架。
- en: Driver implementation
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驱动程序实现
- en: 'The driver program is the one that creates the **executor information**. The
    executor information consists of an `executorID` being a String value and a command
    that is executed through the Linux `/bin/sh-c` command. This can be implemented
    in our Java code as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序程序是创建 **执行器信息** 的程序。执行器信息由 `executorID`（一个字符串值）和通过 Linux `/bin/sh-c` 命令执行的命令组成。这可以在我们的
    Java 代码中实现，如下所示：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we used Google Protocol Buffers to communicate with Mesos and craft the
    executor information with the Builder pattern.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 Google 协议缓冲区与 Mesos 通信，并使用构建者模式构造执行器信息。
- en: 'Now that we have the executor information ready, next in line is information
    about the framework. This contains information such as under which Unix user the
    tasks should be launched (which can be set to the default if we leave the field
    empty) and the failover time, which makes the master wait before removing the
    framework in case of scheduler failure. These two properties are set using the
    `.setUser` and `.setFailOverTimeout` calls, which would look as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了执行器信息，接下来是框架信息。框架信息包括任务应该以哪个 Unix 用户身份启动（如果我们留空该字段，可以使用默认设置）以及故障恢复时间，这使得主节点在调度器失败时会等待一段时间，然后再移除框架。这两个属性通过
    `.setUser` 和 `.setFailOverTimeout` 调用设置，代码如下：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now initialize the `Scheduler` with the number of tasks that are submitted
    to the executor to run our program. This is done with the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以初始化 `Scheduler`，并将提交给执行器的任务数量传递给它，以便运行我们的程序。以下是实现的代码：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`PiScheduler` is instantiated with one task as we only require one task to
    compute it.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`PiScheduler` 被实例化时只有一个任务，因为我们只需要一个任务来计算它。'
- en: '`MesosSchedulerDriver` is used to launch and kill tasks on Mesos. It also manages
    the life cycle of our scheduler with the `start`, `stop`, and `wait for tasks
    to finish` calls. This is done with the following piece of code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`MesosSchedulerDriver` 用于在 Mesos 上启动和终止任务。它还通过 `start`、`stop` 和 `等待任务完成` 调用来管理调度器的生命周期。以下是实现的代码：'
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we have discussed all the parts of the driver program, let''s assemble
    them all together and take a look at how the real code looks. This is shown as
    follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了驱动程序的所有部分，让我们将它们整合在一起，看看实际的代码是如何写的。如下所示：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Executor implementation
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行器实现
- en: '`PiExecutor` is our executor component. We will need to implement the *Executor*
    interface and override a few methods. Here, we will focus on the core method,
    that is, the `launchTask()` call—which is the call to actually compute the value
    of `pi` in our case. We will also need to set a few properties of our task within
    this function, which are explained as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`PiExecutor` 是我们的执行器组件。我们需要实现 *Executor* 接口并重写一些方法。在这里，我们将重点讨论核心方法，即 `launchTask()`
    调用——在我们的例子中，这是实际计算 `pi` 值的调用。我们还需要在这个方法中设置任务的一些属性，具体如下：'
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now create a `PiExecutor` class by implementing the `Executor` class
    and overriding the default methods. The complete code is given as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过实现 `Executor` 类并重写默认方法来创建一个 `PiExecutor` 类。完整代码如下：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Scheduler implementation
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度器实现
- en: We will now discuss the scheduler implementation, which is responsible for the
    framework's scheduling. We will create `PiScheduler`, which actually implements
    the Scheduler interface of Mesos. We will focus on overriding the `resourceOffer()`,
    `statusUpdate()`, and `frameworkMessage()` methods, which form a core part of
    `PiScheduler`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论调度器实现，它负责框架的调度。我们将创建 `PiScheduler`，它实际上实现了 Mesos 的 Scheduler 接口。我们将专注于重写
    `resourceOffer()`、`statusUpdate()` 和 `frameworkMessage()` 方法，这些方法构成了 `PiScheduler`
    的核心部分。
- en: 'The complete code is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码如下：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Running the framework
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行框架
- en: 'We need to package the jar with all the dependencies in order to run the framework.
    For this, we can create a `build.sbt` file with Mesos and log4j as dependencies.
    This will look similar to the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 JAR 文件与所有依赖项一起打包，以便运行框架。为此，我们可以创建一个 `build.sbt` 文件，并将 Mesos 和 log4j 作为依赖项。这将类似于以下内容：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now create an uber jar with the following `sbt` command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下 `sbt` 命令创建一个 Uber JAR 文件：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we will run the program with the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下命令运行程序：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that we specified the Mesos master URI as an argument to our `PiDriver`
    program.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在 `PiDriver` 程序中将 Mesos 主节点的 URI 作为参数指定。
- en: 'Once we run the program, you will see the following output in the Terminal:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，您将在终端中看到以下输出：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Running the framework](img/B05186_06_01.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![运行框架](img/B05186_06_01.jpg)'
- en: 'We can also see the framework being registered in the Mesos master UI, which
    runs on port `5050`, as shown in the following screenshot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到框架已经在 Mesos 主节点的 UI 中注册，Mesos 主节点运行在 `5050` 端口，截图如下：
- en: '![Running the framework](img/B05186_06_02.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![运行框架](img/B05186_06_02.jpg)'
- en: 'We can also see the single task that calculated the value of Pi has finished
    in the same UI if we click on the framework ID:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击框架 ID，仍然可以在相同的 UI 中看到计算 Pi 值的单个任务已经完成：
- en: '![Running the framework](img/B05186_06_03.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![运行框架](img/B05186_06_03.jpg)'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you should have a fair idea of framework security
    features such as authorization, authentication, and access control in Mesos. You
    should also now be able to use the Mesos API to build your own custom application/framework
    on Mesos. In addition, the experimental scheduler HTTP API was also introduced
    in this chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你应该对 Mesos 中的框架安全功能有一个基本了解，比如授权、认证和访问控制。同时，你也应该能够使用 Mesos API 构建你自己的自定义应用程序/框架。此外，本章还介绍了实验性调度器
    HTTP API。
- en: In the next chapter, we will explore some interesting projects, such as Myriad
    (YARN on Mesos) and Kubernetes on Mesos. We will also discuss how to deploy containerized
    apps using Docker and how a continuous integration process can be set up using
    Jenkins on Mesos.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨一些有趣的项目，如 Myriad（在 Mesos 上的 YARN）和 Kubernetes 在 Mesos 上的部署。我们还将讨论如何使用
    Docker 部署容器化应用，以及如何在 Mesos 上使用 Jenkins 设置持续集成流程。
