- en: Lets Make a Process Chat
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来制作一个进程图
- en: '**Inter-process Communication** (**IPC**) is a nice way to describe the fact
    that processes talk to each other, exchange data, and can then react accordingly.
    This kind of chatting can be held between a parent and a child process, between
    processes on the same host, and between programs on different hosts. Processes
    exchange data in a different ways; for instance, if we think about it, when we
    SSH to a remote server, our client is communicating with the remote host and actually
    exchanging data back and forth. The same happens when you pipe the output of a
    command into the standard input of another one; these are ways, sometimes monodirectional,
    sometimes bidirectional, to put different processes into communicating and enhancing
    what we can do with our Bash environment.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程间通信**（**IPC**）是一个很好的方式来描述进程如何相互交流、交换数据并据此作出反应。这种“聊天”可以发生在父进程和子进程之间，在同一主机上的进程之间，或不同主机上的程序之间。进程可以通过不同的方式交换数据；例如，当我们通过SSH连接到远程服务器时，客户端与远程主机通信并实际交换数据。这与将一个命令的输出通过管道传递给另一个命令的标准输入时是一样的；这些方式，有时是单向的，有时是双向的，是让不同进程进行通信并增强我们在Bash环境中执行操作的手段。'
- en: There are different ways to accomplish IPC, some more familiar, some less, but
    all are effective to a certain extent, and we already saw some examples during
    this book. So, now we will go through few pages which will describe a bit more
    in depth how processes can interact and how can use the IPC to enhance our scripts,
    focusing on those methods that we can access using Bash, starting with the so-called
    **pipes**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成IPC的方式有很多种，其中有些更为熟悉，有些不太常见，但它们在一定程度上都是有效的，我们在本书中已经看到了一些例子。那么，现在我们将继续讲解几页，深入描述进程如何互动，以及如何利用IPC来增强我们的脚本，重点介绍我们可以通过Bash访问的那些方法，首先从所谓的**管道**开始。
- en: Pipes
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: 'We can describe a pipeline as a sequence of processes tied together by `stdout`
    and `stdin` so that the output of one process becomes the input of the following
    one. This is a simple form of IPC, commonly known as anonymous pipe, and it is
    a one-way form of communicating: whatever comes from standard output of the preceding
    process flows into the standard input of the following one; nothing comes back
    from the latter to the former.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将管道描述为一系列由`stdout`和`stdin`连接在一起的进程，这样一个进程的输出就成为下一个进程的输入。这是一种简单的进程间通信（IPC）形式，通常称为匿名管道，它是单向的通信方式：前一个进程的标准输出所产生的内容流入下一个进程的标准输入；后一个进程不会向前一个进程返回任何内容。
- en: 'Let''s see an example that will clarify the concept of anonymous pipe, staring
    with a simple `ps` command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来进一步澄清匿名管道的概念，从一个简单的`ps`命令开始：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have a simple listing with some commands: `PID`, `TTY`, and `CMD`. Let''s
    say we want to trim down the output to just `PID` and `CMD`. We could alter the
    output using some `ps` switches, but who remembers them? It''s easier to use something
    that is capable of mangling the text and gives us the result we want, so why not
    use `awk`? The problem here is that `awk` works on the text it receives from the
    input, reading a file for instance. But we can cut corners, linking its standard
    input to the `ps` standard output by means of the pipe character `|`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的命令列表：`PID`、`TTY`和`CMD`。假设我们只想将输出裁剪为`PID`和`CMD`。我们可以使用一些`ps`选项来修改输出，但谁记得这些选项呢？使用一种能够处理文本并提供我们想要结果的工具会更简单，那为什么不使用`awk`呢？这里的问题是，`awk`处理它从输入中接收到的文本，例如读取一个文件。但我们可以绕过这一点，通过管道符号`|`将它的标准输入与`ps`的标准输出连接起来：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, `awk` accepted the output of `ps` as the input and printed to the `stdout`
    the first and fourth field only, being the blank character the standard field
    separator. As mentioned earlier, we can chain more than two processes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`awk`接受了`ps`的输出作为输入，并只打印第一个和第四个字段，空格字符作为标准字段分隔符。如前所述，我们可以将多个进程串联起来：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, we piped the output of the previous set of commands through `tail`,
    which actually got the first line (`PID CMD`) removed and printed to `stdout`.
    Then, we piped this output through the `stdin` of `wc`, which then printed the
    count of the lines we received in `stdin`. This is possible because all the processes
    are in the same environment since each command at the right end of a pipe runs
    in a subshell of the main shell and shares the same file descriptors. Thus, it
    is just matter of writing the data to the open descriptor of the parent process;
    and the child will be able to read them in the same order it was written: with
    a kernel buffer to hold the bits waiting to be read.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将前一组命令的输出通过`tail`命令进行了管道处理，`tail`实际上移除了第一行（`PID CMD`）并将其打印到`stdout`。然后，我们将这个输出通过`wc`命令的`stdin`传递，它随后输出了我们从`stdin`接收到的行数。这是可能的，因为所有进程都在同一环境中运行，右侧管道中的每个命令都在主
    shell 的子进程中运行，并共享相同的文件描述符。因此，只需将数据写入父进程的打开描述符；子进程就能按写入的顺序读取数据：借助内核缓冲区来存放等待读取的位。
- en: 'Nice and handy, but there are some serious restrictions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 很方便且实用，但也有一些严重的限制：
- en: The processes must reside on the same host
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程必须在同一主机上
- en: 'The processes must be active on an overlapping span of time: the preceding
    process must be producing output while the following one is reading'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程必须在重叠的时间段内活动：前一个进程必须在生成输出时，后一个进程才能读取
- en: 'The communication is one way only: the data descends the chain and never climbs
    back the ladder'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信是单向的：数据沿着链条向下流动，永远不会再爬回梯子上
- en: 'We can overcome some of these restrictions using pipes, which are often referred
    to as FIFO pipes due to the way they work. They rely on the creating a file, which
    then any number of processes can access, and this introduces a huge difference
    with respect to the anonymous pipe. It lasts as long as the processes involved
    last, while a named pipe lasts as long as the file exists; and this can last as
    long as the system is not rebooted or the file itself. We can create a file using
    either `mkfifo` or `mknode`, and use the I/O redirection to read or write as shown
    in the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用管道来克服一些限制，管道通常被称为FIFO管道，因为它们的工作方式。它们依赖于创建一个文件，任何数量的进程都可以访问这个文件，这与匿名管道有着巨大的不同。命名管道的生命周期取决于文件的存在，而匿名管道则依赖于进程的生命周期；命名管道只要文件存在就会持续，直到系统重启或文件被删除。我们可以使用`mkfifo`或`mknod`创建一个文件，并通过I/O重定向来读取或写入数据，示例如下：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's follow the flow of the script. The first thing we want to be sure of is
    that our named pipe is in place, so we test for a particular kind of file called `-p`,
    a pipe. If it does not exist, the script creates it using `mknod $pipefile p`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟随脚本的流程。首先，我们要确保命名管道已正确创建，因此我们测试一个名为`-p`的特殊文件，它是一个管道。如果它不存在，脚本将通过`mknod $pipefile
    p`命令创建它。
- en: 'The `p` added at the end of the command line ensures the creation of the file
    as a pipe and not as a regular one. Then, we want the script to keep reading from
    the file we open so we use an infinite loop: *true is always true*. Inside the
    infinite loop, we have the `read row $pipefile` instruction, which reads from
    the pipe file line by line and stores the content into the `row` variable. So
    far, so good. If we jump to the end of the script, we can see that it just echoes
    whatever we input but there is a tiny check in between; if we input `exit`,  the
    program will exit. Let''s run in one terminal our new script:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行末尾加上的`p`确保创建的是一个管道文件，而不是一个常规文件。然后，我们希望脚本不断从我们打开的文件中读取，所以我们使用一个无限循环：*true始终为真*。在这个无限循环中，我们有`read
    row $pipefile`指令，它逐行从管道文件中读取内容并将其存储到`row`变量中。到目前为止，一切正常。如果我们跳到脚本的最后，我们会看到它仅回显我们输入的内容，但中间有一个小的检查；如果我们输入`exit`，程序将退出。让我们在一个终端中运行我们的新脚本：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will see our prompt flashing without giving us the command line back: the
    script is trapped in an infinite loop reading from the named pipe and will not
    terminate until we type `exit` into its standard input. Now, using the output
    redirection, let''s send some stuff into the pipe file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到我们的提示符在不停闪烁，而不再返回命令行：脚本被困在无限循环中，正在从命名管道读取数据，直到我们在标准输入中输入`exit`才会终止。现在，使用输出重定向，我们将一些内容发送到管道文件中：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s see what is on the terminal running our script:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行脚本的终端显示了什么：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's it. The script echoed all the text we sent to the `pipe` file; and when
    it encountered the `quit` string, it just exited, giving us a nice message. This
    example is quite easy and can be replicated using simple files, but switch the
    context and think about multiple processes coordinating their actions writing
    and reading from a pipe, sending and reading data, keywords, commands from the
    pipe, and doing something in a graceful order. All without using an intermediary
    temporary file but a pipe that will disappear upon the system reboot without the
    need for all processes to run at the same time. Processes can be triggered by
    cron jobs manually, by other applications, or by running indefinitely in a loop.
    It does not matter, as everything is async. We have a means to connect processes
    in an asynchronous way and both ways, since each process can both send and receive
    data. This means, we instruct other processes and feed them with data, or are instructed
    and get fed with data when needed. All this is really useful but there is something
    more barebone than this when it comes to IPC, not really an inter-process communication
    since we are going to use redirections to plain files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。脚本回显了我们发送到`pipe`文件的所有文本；当它遇到`quit`字符串时，它就退出了，并给出了一个友好的提示信息。这个例子非常简单，可以通过简单的文件进行复制，但如果切换上下文，想象多个进程协调它们的操作，从管道中写入和读取数据、关键字、命令，并按优雅的顺序做事。所有这些都不需要使用中间临时文件，而是通过一个管道，这个管道在系统重启后会消失，且无需所有进程同时运行。进程可以由cron任务手动触发，由其他应用程序触发，或在循环中无限运行。无论是哪种方式，都不重要，因为一切都是异步的。我们有一种方式以异步的方式连接进程，并且是双向的，因为每个进程既可以发送数据，也可以接收数据。这意味着，我们指示其他进程并向其提供数据，或者在需要时被指示并获取数据。所有这一切都非常有用，但在IPC（进程间通信）方面，还有比这更基础的方式，实际上它并不是真正的进程间通信，因为我们将使用重定向到普通文件。
- en: Redirection to a file
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向到文件
- en: 'Well, redirecting the output of a process is not what an IPC means, but it
    can be used as such in an asynchronous way: have one process redirect its output
    to a file and have another one read from the same file later on; and this can
    be a way to exchange information between the two processes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，重定向一个进程的输出并不意味着IPC，但它可以以异步的方式用作IPC：一个进程将它的输出重定向到一个文件，另一个进程稍后从同一个文件中读取；这可以成为两个进程之间交换信息的一种方式：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example, we just stored a filename into a variable. We created the
    file with `touch`, and then stored the filename into the `controller` file. Once
    we had the filename into the `controller` file, we had it read line by line and
    each line was stored into the `line` variable. Finally, the content of the line
    variable is used to zip the file pointed by the `myfile` variable:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们仅仅将一个文件名存储到一个变量中。我们通过`touch`创建了文件，然后将文件名存储到`controller`文件中。将文件名存入`controller`文件后，我们按行读取文件，每一行的内容被存储到`line`变量中。最后，`line`变量的内容用于压缩由`myfile`变量指向的文件：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have all the files in place and `tar` just followed the instructions
    stored by `echo` in the `controller` file. This is quite a trivial example, and
    it can be expanded as much as we wish. Notice that in this way, there are no special
    files needed, and the processes can be unrelated and can be executed any time
    without any need for concurrency. Probably this kind of IPC is not so surprising,
    but if we pay enough attention, we can find other interesting ways to make processes
    talk to each others, for instance, **command substitution**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经准备好了所有的文件，而`tar`仅仅按照`echo`在`controller`文件中存储的指令执行。这是一个相当简单的例子，可以根据需要进行扩展。注意，这种方式不需要任何特殊的文件，进程之间可以没有关联，且可以随时执行，无需任何并发性。或许这种IPC方式并不令人惊讶，但如果我们足够留心，仍然可以找到其他有趣的方式让进程之间相互通信，比如**命令替换**。
- en: The command substitution
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令替换
- en: 'We already saw what a command substitution is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了什么是命令替换：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of a command gets stored as a string into a variable, and it is
    then available to be used in any way we need. So, for instance, we could well
    do this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个命令的输出会作为字符串存储到一个变量中，然后可以在任何需要的地方使用它。所以，举个例子，我们可以这么做：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, we used the command substitution to perform a test on a `tar`
    file whose name was provided by means of a variable. The output of the command
    substitution was then fed as an argument to echo, which showed us the outcome
    of the `tar` command. We could use an even more complex command inside the command
    substitution bit, but beware of some issues with escaping since what happens inside
    the parentheses is not always what we would expect.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了命令替代对一个`tar`文件进行测试，该文件的名称通过变量提供。命令替代的输出随后作为参数传递给`echo`命令，`echo`显示了`tar`命令的结果。我们也可以在命令替代部分使用更复杂的命令，但要小心转义问题，因为括号内发生的事情并不总是我们预期的。
- en: Is this a valid way to make processes communicate with each other? Yes, it is.
    Is it handy? Not so much. Command substitution can be tricky in a complex task,
    and we have the same limitations we saw for other methods since it is a one-way
    flow. That said, it is widely used in Bash scripts to provide a quick access to
    command paths or just store some information in variables, such as the actual
    date on the system or whatever small bit of information we need. We have other
    options to feed the output of a process to the standard input of another, but
    sometimes we do not take enough time to think at all the ways we have to accomplish
    this goal. For example, using the process substitution.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是让进程彼此通信的有效方式吗？是的，是的。方便吗？不完全是。在复杂任务中，命令替代可能会变得复杂，而且由于它是单向流，我们面临与其他方法相同的限制。也就是说，它在Bash脚本中被广泛使用，用于快速访问命令路径或将某些信息存储在变量中，例如系统上的实际日期或我们需要的任何小信息。我们有其他选项可以将进程的输出传递给另一个进程的标准输入，但有时我们没有花足够的时间去思考所有可用的方式。例如，使用进程替代。
- en: The process substitution
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程替代
- en: 'The **process substitution** is a handy way to feed the output of multiple
    commands/processes to the input of another process. The standard way to manage
    a process substitution goes along with the following syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程替代**是一种方便的方法，用于将多个命令/进程的输出传递给另一个进程的输入。管理进程替代的标准方式遵循以下语法：'
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Mind the space between `<`,`>`, and the parentheses; there is no space at all:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`<`、`>`和括号之间的空格；中间不能有任何空格：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the output of `ps -fj` has been given as an input to `wc -l`,
    which counted `5` lines in the output. Notice `/dev/fd/63`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`ps -fj`的输出被作为输入传递给了`wc -l`，后者计算了输出中的`5`行。注意`/dev/fd/63`。
- en: 'This is the file descriptor used by the process substitution to feed the results
    of the process inside the parentheses to another process. So, file descriptors
    in `/dev/fd` are used to feed data, and this is useful, especially for those commands
    that cannot take advantage of pipes, because they expect data to be read from
    a file and not fed from the standard input. A classic example of a multiprocess
    feed as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是进程替代使用的文件描述符，它将括号内进程的结果传递给另一个进程。因此，`/dev/fd`中的文件描述符用于传递数据，这在一些无法利用管道的命令中尤其有用，因为这些命令期望从文件中读取数据，而不是从标准输入中接收数据。以下是一个多进程数据传输的经典例子：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We just created a couple of test directory and in the first directory, we made
    `5` empty files, in the second, `3`. Then, we just fed `diff` with the output
    of the `ls` command issued on both `test 1` and `test 2` directories. The utility
    then just showed us all the files available in `test 1` but not in `test 2`, as
    we had issued it on the two real directories. It is handy, but consider its scope
    carefully since the command substitution remains available in a function until
    this returns. Talking about scope, process substitution is a good way to avoid
    a common pitfall when piping command to a loop in a subshell:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了几个测试目录，在第一个目录中，我们创建了`5`个空文件，在第二个目录中，创建了`3`个。然后，我们将`diff`命令与对`test 1`和`test
    2`目录执行`ls`命令的输出配合使用。该工具随后向我们展示了`test 1`中存在但`test 2`中没有的所有文件，正如我们在两个真实目录上执行命令一样。它很方便，但请仔细考虑其作用范围，因为命令替代在函数内部可用，直到该函数返回。说到作用范围，进程替代是避免将命令管道传递给子Shell循环时常见陷阱的好方法：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Piping is actually executing the loop inside a subshell, and this will have
    all the variables inside the loop being available in the subshell only. The value
    of `main_variable` will be modified in the inner loop but once we exit it, we
    go back to the main value since each variable value set in the inner loop cannot
    be sent back to the calling environment:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 管道操作实际上是在子进程中执行循环，这会导致循环中的所有变量仅在子进程中可用。`main_variable`的值将在内部循环中被修改，但一旦我们退出循环，它会恢复为主值，因为在子进程中设置的每个变量值无法传回调用环境：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see, `main_variable` changes inside the subshell, where the loop after
    the pipe is executed; but it is unaffected on the main shell. Subshells can be
    really tricky, because you may not realize you are spawning them and so be unaware
    of what the real outcome will be. Even setting some environment variable will
    not help us in preventing this issue.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`main_variable`在子Shell中发生了变化，而管道后的循环被执行；但它不会影响主Shell。子Shell可能非常棘手，因为你可能没有意识到自己在创建它们，因此不清楚最终的结果是什么。即使设置某些环境变量也无法帮助我们避免这个问题。
- en: Environment variables
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量
- en: 'Let''s call it a proof of concept more than a real means to have processes
    communicate with each other. Who would really want to mess with the environment?
    Anyway, we are exploring some viable means to IPC, so we can take this in account
    even though we will not use it in the first instance. Let''s have a look at `env`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称之为一个概念验证，而不是一种真实的进程间通信方式。谁会真的想要弄乱环境变量呢？无论如何，我们正在探索一些可行的进程间通信方法，所以我们可以考虑它，尽管在初始阶段我们不会使用它。让我们看一下`env`：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We trimmed out the content of the `LS_COLORS` variable, but even so, one outstanding
    issue is that the output is a bit crowded and holds a lot of information, most
    of it vital for our login session. So, first advice, let's be really cautious
    when tinkering with the `environment` variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们裁剪了`LS_COLORS`变量的内容，但即便如此，仍然有一个突出的问题，就是输出有些杂乱，包含了很多信息，其中大部分对于我们的登录会话至关重要。所以，首先的建议是，
    tinkering时一定要对`environment`变量保持谨慎。
- en: 'One thing we must keep in mind is that there is a big difference between a
    `shell` variable and an `environment` one; let''s see an example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住的一点是，`shell`变量和`environment`变量之间有很大的区别；让我们来看一个例子：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Executing it, we will get this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 执行它后，我们将得到如下结果：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And now we will tinker with the environment:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试操作环境：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And they are the same, since the nested shell shared the environment variables
    of the parent shell:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是相同的，因为嵌套的Shell共享了父Shell的环境变量：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What we get from this example concerns the normal use of variables. There is
    no real difference between shell and environment variables: both are accessible
    by sub processes/shells and both are unaffected by subshell manipulations. The
    real difference stands out when we have a subprocess which is executed by an `execve()`
    system call: in this case, the shell variable is not be passed through. We will
    have to export it to make it available to the subshell. If we want to have fun,
    there is something even trickier than this. A new keyword introduced with Bash
    4.0 can reveal itself as a nice playground for our experiments.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们看到的是有关变量正常使用的内容。Shell 变量和环境变量之间没有真正的区别：两者都可以被子进程/子Shell访问，并且都不会受到子Shell操作的影响。真正的区别出现在当我们有一个通过`execve()`系统调用执行的子进程时：在这种情况下，Shell
    变量不会传递给子进程。我们需要将其导出，才能使其在子Shell中可用。如果我们想玩得更开心，还有比这更复杂的事情。Bash 4.0引入了一个新关键词，它可以为我们的实验提供一个有趣的“游乐场”。
- en: Coprocesses
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协处理进程
- en: 'Introduced with Bash 4.0, the coproc keyword allow allows the user to run a
    process in the background in an asyncronous subshell. During the execution of
    the process, a pipe is established between the calling shell and the coprocess.
    The best results are obtained with programs which can be run in a CLI and can
    read from `stdin` and write to `stdout`, better if with an unbuffered stream.
    The syntax for coprocess is here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 4.0引入的`coproc`关键词允许用户在异步子Shell中后台运行一个进程。在进程执行期间，调用Shell和协处理进程之间会建立一个管道。最佳结果适用于可以在CLI中运行的程序，这些程序能够从`stdin`读取并写入到`stdout`，最好是使用无缓冲流。`coprocess`的语法如下：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The bits within parentheses are optional, but if you specify a name, `coproc`
    will create a coprocess with the name. If no name is given, it will be defaulted
    to `COPROC`; and we must not define any name if the following is a simple command,
    otherwise it will be treated as the first word of the command. The process ID
    of the shell executing the coprocess is stored in a variable called `NAME_PID`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 括号内的内容是可选的，但如果指定了一个名称，`coproc`将创建一个带有该名称的协程。如果没有给出名称，默认将使用`COPROC`；如果以下是一个简单的命令，我们不能定义任何名称，否则它会被当作命令的第一个单词来处理。执行协程的Shell的进程ID存储在名为`NAME_PID`的变量中：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We executed an infinite loop and its `PID` is shown as `31067`; let''s check
    whether we can read it from `COPROC_PID`, which is the default name for the variable
    when no name has been provided:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了一个无限循环，它的`PID`显示为`31067`；我们来检查是否能从`COPROC_PID`中读取它，这是当没有提供名称时变量的默认名称：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we can easily get the `PID` value from the `COPROC_PID` variable. When
    coprocess is executed the shell instances an array variable named after `NAME`,
    which holds two pieces of information:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以轻松地从`COPROC_PID`变量获取`PID`值。当执行协程时，Shell会实例化一个名为`NAME`的数组变量，存储两部分信息：
- en: '**NAME[0]**: This holds the output file descriptor for coprocess'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NAME[0]**：这是协程的输出文件描述符'
- en: '**NAME[1]**: This holds the input file descriptor for coprocess'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NAME[1]**：这是协程的输入文件描述符'
- en: 'So, we can read and write using the file descriptors, which in our example
    are here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用文件描述符进行读写，在我们的示例中它们如下：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another way to see what files are open for the current process is this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种查看当前进程打开了哪些文件的方法是：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In our case, do this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，做如下操作：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These pipes are in place before any redirection a user could specify on the
    command line, so the file descriptors can be used as arguments for the commands
    issued on the command line, and redirections can be used to feed or retrieve data;
    but beware that the file descriptors do not get inherited by subshells. That said,
    we can feed data to coprocess simply using the following syntax:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些管道是在用户在命令行上指定任何重定向之前就已经建立的，所以文件描述符可以作为命令行上发出的命令的参数使用，重定向可以用来传递或获取数据；但需要注意的是，文件描述符不会被子Shell继承。也就是说，我们可以通过以下语法向协程传递数据：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'While we can use `read` to retrieve data from coprocess as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样使用`read`从协程中获取数据：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Before having a look a simple example, we have to keep in mind a few points:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看一个简单的例子之前，我们必须记住几个要点：
- en: Most of the commands in Linux are buffered when used without a user interaction.
    And this fools us into reading from the `coproc` file descriptors. To make some
    simple experiments, the `bc` util works fine; or use `awk` with `fflush()` or
    the `unbuffer` command from the `expect` package to have unbuffered output.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux中，大多数命令在没有用户交互的情况下是被缓冲的。这让我们在从`coproc`文件描述符读取时感到困惑。为了进行一些简单的实验，`bc`工具很好用；或者使用带有`fflush()`的`awk`，或使用`expect`包中的`unbuffer`命令来获得无缓冲的输出。
- en: There can be only one active coproc at time.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一时间只能有一个活动的协程。
- en: We can use the `wait` built-in to wait for coprocess to terminate.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`wait`内建命令来等待协程终止。
- en: 'That said, let''s see how can we can interact with a process in the background:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，接下来我们来看看如何与后台进程交互：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To trick `coproc` into letting us use a name we created a list with only one
    command followed by `;` then we made it a bit easier to work with file descriptors,
    storing them in two meaningful variables. So, we will not fiddle with `0` and
    `1`. In the next step, we echoed a `bc` multiplication to the `stdin` of `bc`
    using its file descriptor, and read it with the `-u` option, which is exactly
    the option needed for reading from file descriptors. As the last step, we printed
    the out variable in which we previously stored the result of the multiplication,
    printed by `bc` on its standard output.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`coproc`接受我们创建的名称，我们创建了一个只包含一个命令并后跟`;`的列表，然后通过将文件描述符存储在两个有意义的变量中，我们简化了与文件描述符的操作。所以，我们不再处理`0`和`1`。在下一步中，我们将`bc`的乘法运算通过其文件描述符回显到`bc`的`stdin`，并使用`-u`选项读取它，`-u`选项正是读取文件描述符所需的选项。最后一步，我们打印了先前存储了乘法结果的输出变量，这个结果是由`bc`打印在其标准输出上的。
- en: There is actually one last way to make different processes talk to each other;
    can we recall it? Yes, we already saw it at the very beginning of this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其实还有最后一种方式可以让不同的进程相互通信；我们能回想起来吗？是的，我们在本书一开始就已经看到了它。
- en: /dev/tcp and /dev/udp
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /dev/tcp 和 /dev/udp
- en: If we look inside the `/dev` directory, we find lots of files that represent
    physical devices that can be hardware or not. These device files can represent
    partitions; loopback is used to access plain files as if they were block devices.
    ISO files, for example, can be mounted as if they were CD-ROMs. Some of this device
    files are quite unusual, but we have already heard of them, for instance, `/dev/null`, `/dev/zero`, `/dev/urandom`, `/dev/tcp`,
    and `/dev/tcp`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `/dev` 目录，我们会发现许多文件代表物理设备，这些设备可能是硬件设备，也可能不是。这些设备文件可以代表分区；回环设备用于将普通文件当作块设备来访问。例如，ISO
    文件可以像 CD-ROM 一样被挂载。有些设备文件非常不常见，但我们已经听说过它们，例如 `/dev/null`、`/dev/zero`、`/dev/urandom`、`/dev/tcp`
    和 `/dev/tcp`。
- en: 'These are called pseudo-devices, and they represent and provide access to some
    *facilities*. For instance, all this is moved or redirected to the `/dev/null`
    fall in a *black hole* and disappears, whereas `/dev/urandom` is a good way to
    get a random string when needed:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为伪设备，它们代表并提供对一些*设施*的访问。例如，所有这些都被移到或重定向到 `/dev/null`，它掉入一个*黑洞*并消失，而 `/dev/urandom`
    是一个在需要时获取随机字符串的好方法：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With `/dev/tcp` or `/dev/udp`, we get access to a socket through which we can
    communicate to network services locally or remotely. For our examples, we will
    focus on TCP sockets, since they are more interesting to use for our experiments.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `/dev/tcp` 或 `/dev/udp`，我们可以通过一个套接字与本地或远程的网络服务进行通信。对于我们的示例，我们将专注于 TCP 套接字，因为它们更适合我们的实验。
- en: 'Then what is a socket? Imagine a socket as a pipe between two multistorey buildings.
    To put this pipe in place, you have to know the civic number of each building
    and which floor of one must be connected to which floor of the other. The same
    is for a network socket which is identified by two tuples:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是套接字呢？想象一个套接字是连接两栋多层建筑之间的一根管道。要将这根管道安装到位，你必须知道每栋建筑的门牌号，以及必须将哪个楼层与另一栋楼的哪个楼层连接。网络套接字也是如此，它由两个元组标识：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So, Bash is able to set up a connection to a network service as long as we
    provide at least the remote end of the communication channel, the IP or hostname,
    and the port to cling to. Easy, isn''t it, but how to do it? The right syntax
    is the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Bash 只要我们提供至少远程端的通信通道、IP 或主机名，以及要连接的端口，就能建立与网络服务的连接。这很简单，不是吗？但是怎么做呢？正确的语法如下：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`<` means opening the socket for reading, `>` for writing, and `<>` for both.
    There isn''t a big difference between the IP or hostname, but we must pay attention
    to which file descriptors we are going to use. We have 10 file descriptors available,
    from 0 to 9, but since, `0 = stdin`, `1 = stdout`, `2 = stderr` are already bound,
    we cannot use them. So, we are left with seven file descriptors, from 3 to 9\.
    So, let''s try an easy example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`<` 表示打开用于读取的套接字，`>` 表示用于写入，`<>` 表示同时用于读取和写入。IP 或主机名之间没有太大区别，但我们必须注意将使用哪些文件描述符。我们有
    10 个文件描述符可用，从 0 到 9，但由于 `0 = stdin`、`1 = stdout`、`2 = stderr` 已经被绑定，我们不能使用它们。所以，剩下的文件描述符是
    3 到 9。现在，让我们尝试一个简单的例子：'
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We just read the time over the internet, connecting to an Italian time server
    in an easy way, but we can do something even more complicated; let's recall an
    example we made in the first chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过互联网读取了时间，连接到一个意大利的时间服务器，方式非常简单，但我们还能做更复杂的事情；让我们回顾一下第一章中做过的一个例子。
- en: 'Let''s open a socket in read/write mode to a web server and assign a file descriptor
    called `9`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以读/写模式打开一个套接字连接到一个 web 服务器，并将文件描述符指定为 `9`：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we are going to write a request to it using the HTTP/1.1 syntax as if
    we were a real web browser:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 HTTP/1.1 语法向它发送请求，就像我们是一个真实的 web 浏览器一样：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We just requested a simple HTML file created for this example; so since we
    requested it, it is time to read this page through the file descriptor called
    `9`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚请求了一个为这个示例创建的简单 HTML 文件；因为我们请求了它，所以现在是通过文件描述符 `9` 来读取该页面的时候了：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we could interact with a remote server as if it was a local file, using
    `print` and `cat` to push and pull content. All locally, but definitely remotely.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以像操作本地文件一样与远程服务器互动，使用 `print` 和 `cat` 来推送和拉取内容。完全是本地操作，但实际上是远程操作。
- en: There is indeed one last way to have fun when we want to tinker with IPC; even
    though this is not a proper IPC means, it is so much fun that we cannot avoid
    talking about Netcat.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，还有一种方式可以在想要搞弄 IPC 时玩得很开心；尽管这不是一种正式的 IPC 手段，但它太有趣了，以至于我们不能不提到 Netcat。
- en: Netcat
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netcat
- en: We could even never have been using this tool but no one probably can say they
    never heard about it being called the *TCP/IP Swiss army knife* and that for its
    versatility. You can literally have hours of fun just exploring all the possibilities
    it enables. That said, `netcat` is a utility, which reads and writes over the
    network using either TCP or UDP protocol; and what makes it really handy is its
    ability to keep up the connection until the remote side of the connection is shut
    down. This makes it different from most of the applications, which just stop working
    after the last bit of data has been delivered. `netcat` is different; it keeps
    both ends of the communication channel in touch even if there is nothing passing
    through, so you can use it for repeated dispatches.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可能从未使用过这个工具，但没人能说他们从没听过它被称为 *TCP/IP 瑞士军刀*，这是因为它的多功能性。你可以花几个小时仅仅探索它所支持的所有可能性。话说回来，`netcat`
    是一个使用 TCP 或 UDP 协议在网络上读取和写入数据的工具；它真正方便的地方在于，它能够保持连接直到远程端断开。这使得它不同于大多数应用程序，它们在最后一段数据传输完毕后就停止工作。`netcat`
    不一样；它能保持通信通道两端的连接，即使没有数据传输，因此你可以用它来进行重复的数据发送。
- en: 'The Netcat can be used either in a server or client mode and from inside scripts
    too by adding network facilities to them. So many things, but the best way to
    understand what we can do with it is to run some examples. So, the first step
    will be opening a connection to a remote server inside a term, which can be split
    in two panels such as *terminator.* Last bit, remember that Netcat cannot be installed
    by default on our system, but distributions have a package for it. So, once the
    utility is installed, let''s open two `xterm`, or split terminators into two panels
    and connect to a remote server. On the remote server, check for an open port,
    usually something around `8000` (`8080` being a port widely used for proxies)
    or `9000` would be nice; a command like this executed as root can tell us whether
    the port we are looking for is available:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat 可以在服务器模式或客户端模式下使用，也可以通过在脚本中添加网络功能来使用。所以有很多功能，理解它的最佳方式是运行一些示例。因此，第一步是在终端中打开与远程服务器的连接，终端可以被分为两个面板，如*terminator*。最后一点，记住
    Netcat 默认无法安装在我们的系统上，但各个发行版有相关的安装包。因此，一旦工具安装完成，打开两个 `xterm`，或将 terminator 分成两个面板并连接到远程服务器。在远程服务器上，检查一个开放的端口，通常是
    `8000`（`8080` 是一个常用于代理的端口）或者 `9000`，这类端口通常比较合适；可以通过执行以下命令检查我们想要的端口是否可用：
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Netstat simply lists all the tcp ports in listen mode, showing the numeric
    port numbers; and then we grep over the port we want to check. If it returns nothing,
    the port is free. Second step, often forgotten, is that we are sure the port is
    not blocked by our local firewall. This is because we are mastering Bash and *have* a
    firewall in place even on our local desktop. We will talk more about securing
    our boxes later on, but, for now, let''s assume we have a simple but reliable
    firewall in place such as `ufw`. To enable port `900` , we can just give the following
    command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Netstat 会列出所有处于监听模式的 TCP 端口，显示端口的数字编号；然后我们使用 grep 来查找我们要检查的端口。如果返回为空，说明该端口是空闲的。第二步，通常被遗忘的是，我们需要确保该端口没有被本地防火墙阻塞。这是因为我们正在掌握
    Bash 并且*已经*在本地桌面上部署了防火墙。我们稍后会讨论如何保护我们的计算机，但现在假设我们已经有了一个简单但可靠的防火墙，比如 `ufw`。要启用
    `900` 端口，我们只需要执行以下命令：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Rule added, it is the sixth in our chain, but it can have any other number
    depending on how many other rules you have. Remember that to delete a rule, you
    just have to run this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 规则已添加，它是我们链中的第六条，但它可以是任何其他编号，取决于你有多少条其他规则。记住，要删除规则，只需运行以下命令：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We used the rule number; you can use the rule name `allow 9000/tcp` as you
    wish. Now that we have a free port unblocked, we can run `netcat` in listening
    mode on the remote server:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了规则编号，你也可以根据需要使用规则名称 `allow 9000/tcp`。现在，我们已经解除了端口的阻塞，可以在远程服务器上以监听模式运行 `netcat`：
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will start `netcat` in listening mode, and `-l` will be ready to accept
    connections on port `-p 9000` in a verbose detailed mode `-vv`. We will not have
    our prompt back because `netcat` keeps running in the foreground, monopolizing
    the terminal. Now, on the local system, let''s run `netcat` in client mode:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以监听模式启动 `netcat`，并且 `-l` 会准备好接受 `-p 9000` 端口的连接，以详细模式 `-vv` 启动。我们将无法返回提示符，因为
    `netcat` 会在前台运行，独占终端。现在，在本地系统上，让我们以客户端模式运行 `netcat`：
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Great, the connection is opened on both sides. Notice that we invoked Netcat
    both with the `netcat` command and `nc;` we can choose whatever we prefer. Once
    the connection is established, we will see a message like this on the listening
    side:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，连接在两端都已打开。请注意，我们使用了`netcat`命令和`nc`两种方式来调用 Netcat；我们可以选择任何一种。连接建立后，我们将在监听端看到如下信息：
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The message called `Unknown host` must not bother us; Netcat makes a reverse
    lookup to check the hostname the connection is coming from. Being a test environment
    we did not set any internal DNS resolution. If you do not want to tinker with
    DNS, a simple solution is to open the `/etc/hosts` file on the server side operating
    system and add a line such as `192.168.0.5 spoton`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为`Unknown host`的消息不应打扰我们；Netcat 会进行反向查找，检查连接来源的主机名。由于这是一个测试环境，我们没有设置任何内部 DNS
    解析。如果你不想动 DNS，可以通过在服务器端操作系统上打开`/etc/hosts`文件，并添加一行，如`192.168.0.5 spoton`，来解决问题。
- en: 'Being `192.168.0.t` the IP address of the client the connection is coming from
    and `spoton` the hostname we want it to be identified and resolved by `netcat`
    on the server side. If you don''t want the DNS resolution, add `-n` on the server
    and the client side, and you will work with IP. So now, let''s retry the connection:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`192.168.0.t` 是客户端的 IP 地址，连接来自该地址，而`spoton`是我们希望服务器端通过`netcat`识别和解析的主机名。如果你不想使用
    DNS 解析，可以在服务器和客户端上都加上`-n`选项，这样你将只使用 IP 地址。那么现在，让我们重新尝试连接：'
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This looks better, doesn''t it? Let''s just type something on the client, and
    whatever we input will be echoed on the server side. We can pause and type at
    a later time; meanwhile, the channel will be up and running waiting for our input:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来更好了，是吗？我们只需在客户端输入一些内容，无论输入什么都会在服务器端回显。我们可以暂停并稍后输入；与此同时，通道将保持开启并等待我们的输入：
- en: '![](img/00043.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: 'The client is on the left panel and gets echoed on the right panel, onto the
    server side. Now something spooky; on the server side, type this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在左侧面板上，右侧面板上将其回显到服务器端。现在有些神秘的东西；在服务器端，输入这个：
- en: '[PRE44]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'What we just did is use the `-c` switch to tell `netcat` to execute right after
    the connection the command specified as argument. The command will be passed to
    `/bin/sh -c` for execution with no further check, and if you do not have the `sh`
    shell installed, just use `-e` to have the command executed. Now, on the client
    side, let''s execute this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才所做的是使用`-c`开关告诉`netcat`在连接建立后立即执行作为参数指定的命令。该命令将传递给`/bin/sh -c`进行执行，不做任何进一步检查，如果你没有安装`sh`
    shell，只需使用`-e`来执行命令。现在，在客户端，执行如下操作：
- en: '[PRE45]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The connection has been established right after the `date` command has been
    issued; so, in our client, we can see the output of the command and the date and
    time on the server side. It does not seem spooky, does it? It is just `date`,
    what harm can it do? Okay, let''s modify the server argument and be ready to freak
    out:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 连接在执行`date`命令后立即建立；所以，在我们的客户端，我们可以看到命令的输出以及服务器端的日期和时间。这看起来不那么神秘，对吧？这只是`date`，能有什么害处呢？好吧，我们来修改服务器的参数，准备好吓一跳吧：
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Interesting, at each connection, we will execute a Bash shell. Let''s open
    it on the client side:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在每次连接时，我们都会执行一个 Bash shell。让我们在客户端打开它：
- en: '[PRE47]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s give some innocent commands in the client:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在客户端输入一些无害的命令：
- en: '[PRE48]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Okay, this is a date, but where are we?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个日期，但我们在哪里？
- en: '[PRE49]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Nice, but who are we?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但我们到底是谁？
- en: '[PRE50]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So, we are `root` but on which side?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们是`root`，但我们站在哪一边？
- en: '[PRE51]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Ouch, we are `root` on the server, and we issued commands as a superuser with
    no authentication required. Since this is really dangerous, use this option with
    extreme care. Maybe just for fun and testing and nothing else, we just showed
    it to highlight the potentials and the risks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们在服务器上是`root`，并且我们以超级用户身份发出了命令，不需要任何身份验证。由于这非常危险，请务必小心使用此选项。或许只是为了娱乐和测试，除此之外没有别的，我们这样做只是为了突出它的潜力和风险。
- en: 'What else can we do? Let''s create a file on the client side:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能做什么？让我们在客户端创建一个文件：
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'On the server side, let''s start `netcat`, this time with no verbose mode since
    we do not need it if you do not want to debug the connection and redirect the
    output to `testfile.txt`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们开始`netcat`，这次不使用详细模式，因为如果你不想调试连接，且希望将输出重定向到`testfile.txt`，就不需要详细模式：
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We used unprivileged users. We do not need to use `root` if we do not want to
    bind the so-called reserved or system ports; the ports below `1024` are used for
    providing service, such as`22` for SSH, `80` for HTTP, and so forth.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了没有特权的用户。如果我们不想绑定所谓的保留或系统端口，就不需要使用`root`；低于`1024`的端口用于提供服务，例如`22`用于SSH，`80`用于HTTP等。
- en: 'Now, back on the client side, let''s feed the client with the content of `testfile`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到客户端，让我们把`testfile`的内容输入给客户端：
- en: '[PRE54]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We added a timeout of 2 seconds for the connection so that once the file content
    is dispatched, it will close the connection after 3 seconds. Once on the server
    side, we see this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为连接添加了2秒的超时，这样一旦文件内容传输完毕，它将在3秒后关闭连接。服务器端看到的内容是：
- en: '[PRE55]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We are done and we just have to interrupt Netcat with a *Ctrl *+ *C *and check
    the content of `filetest.txt`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了，只需按*Ctrl* + *C*中断Netcat，并检查`filetest.txt`的内容：
- en: '[PRE56]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And that''s it, the content of the file has been transferred to the server
    and saved on `testfile.txt`. But what if we wanted to transfer whole directories
    or bunches of file? We cannot adopt the same strategy because all the output would
    be redirected to a single file, and this won''t work. So, on the server side,
    let''s first create a test `dir`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，文件的内容已经传输到服务器并保存在`testfile.txt`中。但是如果我们想传输整个目录或一堆文件呢？我们不能采用相同的策略，因为所有输出都会被重定向到一个文件，这样是行不通的。那么，在服务器端，首先让我们创建一个测试用的`dir`：
- en: '[PRE57]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s run Netcat:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 Netcat：
- en: '[PRE58]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This will run `tar` on the input with the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对输入运行`tar`，命令如下：
- en: '`x`: It extracts files from the archive received in input'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：从输入的归档中提取文件。'
- en: '`p`: It preserves permissions on files'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`：它保持文件的权限。'
- en: '`z`: It filters the received archive through `gzp`, essentially uncrompressing
    it'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z`：它通过`gzp`过滤接收到的归档，实质上是解压它。'
- en: '`f`: File archive to work on. In our case everything goes to the `stdout`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`：工作文件归档。在我们的例子中，一切都被发送到`stdout`。'
- en: '`-`: The last dash means it will work on the data coming from the `stdin` instead
    of looking for a file on the filesystem'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`：最后一个破折号意味着它将处理来自`stdin`的数据，而不是在文件系统中查找文件。'
- en: 'On the client side, let''s enter a directory with some files and subdirectories
    we want to transfer and have a look at their properties:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，让我们进入一个包含我们想要传输的文件和子目录的目录，并查看它们的属性：
- en: '[PRE59]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, on the client side, let''s run Netcat:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在客户端，运行 Netcat：
- en: '[PRE60]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `tar` command is executed with the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`tar`命令执行时，使用以下参数：'
- en: '`c`: Create an archive.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：创建一个归档。'
- en: '`z`: Compress it filtering through `gzip`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z`：通过`gzip`进行压缩。'
- en: '`f`: File archive to work on. In our case, it will get the name from the input.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`：工作文件归档。在我们的例子中，它将从输入中获取文件名。'
- en: '`-`: The last dash means it will work on the data coming from the `stdin` instead
    of looking for a file on the filesystem.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`：最后一个破折号意味着它将处理来自`stdin`的数据，而不是在文件系统中查找文件。'
- en: 'We gave all the visible files and directories as input to `tar`; we could also
    use single or multiple files and directory names if we just wanted to copy a few
    of them. Once the command is given, we should see something like this on the server
    side:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把所有可见的文件和目录作为输入提供给`tar`；如果我们只想复制其中一些文件，也可以使用单个或多个文件和目录名。一旦命令执行，我们应该会在服务器端看到类似的输出：
- en: '[PRE61]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It seems the files and directories have been transferred. Let''s exit Netcat
    and check this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来文件和目录已经传输完毕。让我们退出 Netcat 并检查一下：
- en: '[PRE62]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'That''s it, all the files and directories are copied and permissions preserved.
    There are so many things we can do with Netcat that probably it would deserve
    a book on its own; we are just scratching the surface and having fun:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，所有文件和目录都已复制，并且权限已被保留。Netcat 有许多功能，可能值得写一本专门的书；我们现在只是略微触及其表面，享受这个过程：
- en: '[PRE63]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can just use it as a simple port scanner with `-z`, which will prevent the
    reception of any data from the remote server and `-w 1` to timeout the connection
    in case the remote port does not provide a reply. You can add `-n` to prevent
    the DNS resolution and specify a port not only by its number but also with its
    name or specify a range of ports to be checked specifying *lower_port_number:higher_port_number*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`-z`将其用作简单的端口扫描器，这将阻止从远程服务器接收任何数据，并且通过`-w 1`在远程端口没有回复时超时连接。你还可以添加`-n`来防止DNS解析，并通过端口号或名称指定端口，或者指定一个端口范围进行检查，格式为*lower_port_number:higher_port_number*：
- en: '[PRE64]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If we do not know or remember the ports associated to the main services, we
    can retrieve a list from the `/etc/services` file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道或记不得与主要服务相关的端口，可以从`/etc/services`文件中检索端口列表。
- en: Well, do we need a proxy?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们需要代理吗？
- en: '[PRE65]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this case, we used `ncat`, a sort of Netcat on steroids, which can overcome
    a limit in Netcat. It has a one direction pipe, so we can send but not read from
    the server while proxying. Once `ncat` executes Netcat, managing the flow, we
    can connect to port `9999` on localhost and ask for a page:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了`ncat`，它是一个类似于Netcat的工具，但功能更强大，能够克服Netcat的限制。它有一个单向管道，因此在代理时我们可以发送数据，但不能从服务器读取数据。一旦`ncat`执行了Netcat并管理了数据流，我们就可以连接到本地主机的`9999`端口，并请求一个页面：
- en: '[PRE66]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We just cut a part of the output with the whole page and highlighted the commands
    we gave to retrieve the page. Anyway, instead of `ncat`, we could use Netcat with
    a named pipe:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是截取了输出的一部分，包含了整个页面，并突出显示了我们给出的命令来获取页面。无论如何，除了使用`ncat`，我们还可以使用带命名管道的Netcat：
- en: '[PRE67]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, simply use the output redirection to have a bidirectional channel:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，简单地使用输出重定向来建立一个双向通道：
- en: '[PRE68]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now, telnet to localhost on port `9999` and perform the same get as in the other
    example or, better, fire up your internet browser and point it to `http://localhost:9999`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用telnet连接到本地主机的`9999`端口，并执行与另一个示例中相同的get请求，或者更好的是，启动你的互联网浏览器并将其指向`http://localhost:9999`。
- en: 'One more thing before leaving this chapter, did you ever fancy a quick, easy
    server at your disposal? Let''s start creating a small HTML page:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开本章之前，还有一件事，你是否曾经想过拥有一个简单、快速的服务器随时可用？让我们开始创建一个简单的HTML页面：
- en: '[PRE69]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, an infinite loop will help Netcat to serve us the page:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个无限循环将帮助Netcat为我们提供页面：
- en: '[PRE70]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Last step, let's open `http://localhost:9999` in our favorite internet browser.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，让我们在我们喜欢的互联网浏览器中打开`http://localhost:9999`。
- en: 'The page will be served because it was pushed by a web server, as we can see
    from the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面将被提供，因为它是由Web服务器推送的，正如我们从以下截图中看到的：
- en: '![](img/00044.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: The HTML page we just created is being served as if it was pushed by a real
    web server.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚创建的HTML页面正在作为一个真实的Web服务器推送的页面一样提供。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Letting services talk to each other is not so difficult and can be real fun,
    especially if we know how to redirect the flows and spice things up with the right
    tools. Did we see everything Bash has to offer regarding IPC? No, and this is
    one of the best things about the shell: we can accomplish the same task in different
    ways, and there are so many things to do that a chapter would not be enough. Once
    again, this is the best thing in shell: we start off with some examples, learn
    how to work with the commands and utilities, and then expand our knowledge trying
    new experiments, tinkering with options and arguments, and mastering the tools
    we have been offered.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让服务相互通信并不是那么难，甚至可以非常有趣，尤其是当我们知道如何重定向流并使用正确的工具增添一些趣味时。我们是否已经看到了Bash在IPC方面的所有功能？没有，而这正是Shell的魅力之一：我们可以以不同的方式完成同一任务，且有太多的事情可以做，一章根本不够。再一次，这就是Shell的最佳之处：我们从一些示例开始，学习如何使用命令和工具，然后通过尝试新实验、调整选项和参数，扩展我们的知识，掌握我们拥有的工具。
- en: We pushed IPC so far that Netcat became a simple web server, pushing a page
    over the network so that we could actually display it in a browser. This is amazing,
    and it is quite the limit of what Bash can do, but we will try to stretch these
    boundaries in the next chapter by taking a look at how we can create simple daemons
    and offer services with Bash.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将IPC推到极限，以至于Netcat变成了一个简单的Web服务器，通过网络推送页面，以便我们能够在浏览器中显示它。这是非常令人惊讶的，它实际上是Bash所能做到的极限，但我们将在下一章尝试突破这些界限，看看如何使用Bash创建简单的守护进程并提供服务。
