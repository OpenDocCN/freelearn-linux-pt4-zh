- en: Plug into the Real World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are moving into the real world now, creating something that can turn out
    handy for your daily routine; during this process, we will have a look at the
    common pitfalls in coding and how to make our script reliable. Be it a short or
    long script, we must always ask ourselves the same questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What do we really want to accomplish?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much time do we have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have all the resources needed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have the knowledge required for the task?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start coding with a Nagios plugin, which will give us a broad understanding
    of how this monitoring system is and how to make a script dynamically interact
    with other programs.
  prefs: []
  type: TYPE_NORMAL
- en: What is Nagios?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Nagios** is one of the most widely adopted open source IT infrastructure
    monitoring tools, whose main interesting feature is the fact that it does not
    know how to monitor anything. Well, it sounds like a joke, but actually Nagios
    can be defined as an evaluating core, which takes some information as input and
    reacts accordingly. How is this information gathered? It is not the main concern
    of this tool and this leads us to an interesting point: Nagios leaves the task
    of getting the monitored data to an external plugin, which knows the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: How to connect to the monitored services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to collect the data from the monitored services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to evaluate the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inform Nagios if the values gathered are beyond or in the boundaries to raise
    an alarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a plugin does a lot of things and one would ask oneself what does Nagios
    do then? Imagine it as an exchange pod where information is flowing in and out
    and decisions are taken based on the configurations set; the core triggers the
    plugin to monitor a service; the plugin itself returns some information and Nagios
    takes a decision about:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to raise an alarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send a notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whom to notify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For how long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What, if any action is taken in order to get back to normality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core Nagios program does everything except actually knock at the door of
    a service, ask for information, and decide whether this information shows some
    issues or not.
  prefs: []
  type: TYPE_NORMAL
- en: Active and passive checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how to code a plugin, we have first to grasp how, on a broad scale,
    a Nagios check works. There are two different kinds of checks.
  prefs: []
  type: TYPE_NORMAL
- en: Active checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on a time range, or manually triggered, an active check sees a plugin
    actively connecting to a service and collecting information. A typical example
    could be for a plugin to check the disk space: once invoked, it interfaces with
    (usually) the operating system, executes a `df` command, works on the output,
    extracts the value related to the disk space, evaluates it against some thresholds,
    and reports back a status, such as OK, WARNING, CRITICAL, or UNKNOWN.'
  prefs: []
  type: TYPE_NORMAL
- en: Passive checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this case, Nagios does not trigger anything but waits to be contacted by
    some means by the service, which must be monitored. It seems quite confusing,
    but let''s make a real-life example. How would you monitor if a disk backup has
    been completed successfully? One quick answer would be: knowing when the backup
    task starts and how long it lasts, we can define a time and invoke a script to
    check the task at that given hour.'
  prefs: []
  type: TYPE_NORMAL
- en: Nice, but when we plan something, we must have a full understanding of how real
    life goes, and a backup is not our little pet in the living room, it's rather
    a beast, which does what it wants. A backup can last a variable amount of time
    depending on an unpredictable factor.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, your typical backup task would copy 1 TB of data in 2 hours, starting
    at 03:00, out of a 6 TB disk. So, the next backup task would start at 03:00+02:00=05:00
    AM, give or take some minutes. And you set up an active check for it at 05:30,
    and it works well for a couple of months. Then, one early morning, you receive
    a notification on your smartphone that the backup is in CRITICAL. You wake up,
    connect to the backup console and see that at 06:00 in the morning, you are asleep
    and the backup task has not even been started by the console. Then, you have to
    wait until 08:00 AM until some of your colleagues show up at the office to find
    out that the day before the disk, your backup has been filled with 2 extra TB
    of data due to an unscheduled data transfer. So, the backup task preceding the
    one you are monitoring lasted not for a couple of hours but 6 hours, and the task
    you are monitoring then started at 09:30 AM.
  prefs: []
  type: TYPE_NORMAL
- en: Long story short, your active check has been fired up too early; that is why
    it failed. Maybe your are tempted to move your schedule some hours ahead, but
    simply do not do it, as these time slots are not sliding frames. If you move your
    check ahead, you should then move all the checks for the subsequent tasks ahead.
    You do it in one week, the project manager will ask someone to delete the 2 TB
    excess (useless for the project now), and your schedules will be 2 hours ahead,
    making your monitoring useless. So, as we insisted before, planning and analyzing
    the context is the key factor in making a good script and, in this case, a good
    plugin. We have a service that does not run 24/7 like a web service or a mail
    service; what is specific to the backup is that it is run periodically, but we
    do not know exactly when.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best approach to this kind of monitoring is letting the service itself
    notify us when it finished its task and what was its outcome. This is usually
    accomplished using the ability of most backup programs to send a **Simple Network
    Monitoring Protocol** (**SNMP**) trap to a destination to inform it of the outcome;
    and in our case it would be the Nagios server, which would have been configured
    to receive the trap and analyze. Add to this an event horizon so that if you do
    not receive the specific trap in, let''s say, 24 hours, we raise an alarm anyway
    and you are covered: whenever the backup task gets completed or when it times
    out, we receive a notification.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Nagios notifications flowchart
  prefs: []
  type: TYPE_NORMAL
- en: Returning code and thresholds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before coding a plugin, we must face some concepts that will be the stepping
    stone of our Nagios code base, one of these being the return codes of the plugin
    itself. As we already discussed, once the plugin collects the data about how the
    service is going, it evaluates these data and determines if the situation falls
    under one of the following status:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Return code** | **Status** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | OK | The plugin checked the service and the results that are inside
    the acceptable range. |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | WARNING | The plugin checked the service and the results that are above
    a WARNING threshold. We must keep an eye on the service. |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | CRITICAL | The plugin checked the service and the results that are
    above a CRITICAL threshold or the service not responding. We must react now. |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | UNKNOWN | Either we passed the wrong arguments to the plugin or there
    is some internal error in it. |'
  prefs: []
  type: TYPE_TB
- en: 'So, our plugin will check a service, evaluate the results, and based on a threshold,
    will return to Nagios one of the values listed in the tables and a meaningful
    message, like we can see in the description column in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the service check in red and the message in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, we can see that some checks are green, meaning okay, and
    they have an explicative message in the description section. What we see in this
    section is the output of the plugin written in the `stdout`; and it is what we
    will craft as a response to Nagios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention to the SSH check: it is red and is failing because it is checking
    the service at the default port, which is `22`, but on this server the `ssh` daemon
    is listening on a different port. This leads us to a consideration: our plugin
    will need a command line parser able to receive some configuration options and
    some threshold limits as well, because we need to know what to check, where to
    check, and what are the acceptable working limits for a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Where**: In Nagios, there can be a host without service checks (except for
    the implicit host alive carried on by a ping), but no services without a host
    to be performed onto. So, any plugin must receive on the command line the indication
    of the host to be run against, be it a dummy host but there must be one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How**: This is where our coding comes in; we will have to write the lines
    of code that instruct the plugin how to connect to the server, query, collect,
    and parse the answer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What**: We must instruct the plugin, usually with some meaningful options
    on the command line, on what are the acceptable working limits so that it can
    evaluate them and decide to notify us with an OK, WARNING, or CRITICAL message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That is all for our script: who to notify, when, how, how many times, and so
    forth. These are tasks carried on by the core; a Nagios plugin is unaware of all
    of this. What it really must know for effective monitoring is what are the correct
    values that identify a working service. We can pass to our script two different
    kinds of value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: This is a series of numeric values with a starting and ending point,
    like from 3 to 7 or from one number to infinite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Threshold**: It is a range with an associated alert level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, when our plugins perform checks, they collect a numeric value that is within
    or outside a range, based on the threshold we impose; then, based on the evaluation,
    it replies to Nagios with a return code and a message. How do we specify some
    ranges on the command line? Essentially in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the range starts from `0`, the part from `:` to the left can be omitted.
    The `start_value` must always be a lower number than `end_value`.
  prefs: []
  type: TYPE_NORMAL
- en: If the range starts with `start_value`, it means from that number to infinity.
    Negative infinity can be specified using `~`.
  prefs: []
  type: TYPE_NORMAL
- en: An alert is generated when the collected value resides outside the range specified,
    comprised of the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: If `@` is specified, the alert is generated if the value resides inside the
    range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some practical examples of how we would call our script, imposing
    some thresholds:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plugin call** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `./my_plugin -c 10` | CRITICAL if less than `0` or higher than `10` |'
  prefs: []
  type: TYPE_TB
- en: '| `./my_plugin -w 10:20` | WARNING if less than `10` or higher than `20` |'
  prefs: []
  type: TYPE_TB
- en: '| `/my_plugin -w ~:15 -c 16` | WARNING if between -infinite and `15`, critical
    from `16` and higher |'
  prefs: []
  type: TYPE_TB
- en: '| `./my_plugin -c 35:` | CRITICAL if the value collected is below `35` |'
  prefs: []
  type: TYPE_TB
- en: '| `./my_plugin -w @100:200` | CRITICAL if the value is from `100` to `200`,
    OK otherwise |'
  prefs: []
  type: TYPE_TB
- en: 'We covered the basic requirements for our plugin that in its simplest form
    should be called with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We already talked about the need to relate a check to a host; we can do this
    either by using a hostname or hostaddress. It is up to us what to use, but we
    will not fill in this piece of information, because it will be drawn by the service
    configuration as a standard macro. We just introduced a new concept, service configuration,
    which is essential in making our script work in Nagios, so let''s briefly see
    what we are talking about. A caveat before starting our journey on Nagios configurations:
    this is not a book on Nagios, so we will not cover all the complex bits and parts.
    We will touch all the topics needed to make our script do its job and with a working
    Nagios installation; we will be able to activate our new plugin quickly. Let''s
    see now how to configure a plugin to make it work under Nagios, so then we will
    be able to focus on our script without any distractions.'
  prefs: []
  type: TYPE_NORMAL
- en: Command and service definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the base of everything in Nagios is a plugin, the minion who carries out the
    job of retrieving the information, evaluating it, raising the alarm, and providing
    a meaningful message. Left alone, Nagios does not know how to call a plugin, what
    options to pass to it or how to handle it, so we need a command definition, which
    defines how the script will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take as an example the command definition for the `ssh` service check,
    which is failing because the port used for the check is not the one the daemon
    is listening on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see here a command definition named `command_name check_ssh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s keep `check_ssh` in mind, because it will be the handle we will use
    to refer to this command definition later on. As we can see, this definition is
    really short; it defines a handle, and, most importantly, the command line to
    call the plugin. In this case, it is really easy: the plugin accepts the host
    address and that is enough for a basic check. Look at  `$HOSTADDRESS$`. This is
    one of the so-called **Nagios standard macros:** essentially a place holder, which
    will be instantiated by Nagios with the host address of the host you will associate
    the service making use of this command. Nothing complicated so far, let''s move
    onto the service definition, making use of this command definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `ssh` service definition introduces something new, and this is the inheritance
    of properties by the Nagios objects. As we discussed previously, the script carries
    out the checking, evaluation, and alarm raising; the core does all the rest, and
    lots of stuff. Looking at this service definition, it does not seem a lot, but
    focus on the first line named `use generic-service`. This rings a bell. Looking
    at the definition, it seems that `generic-service` is actually a template, doesn't
    it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Well, as we can see, there is a lot we can define service-wise, just so much
    to clutter a service definition so we hide the complexity in a template and recall
    it, like sourcing a library. Once the template is imported, all its definition
    will apply to the service that called it and if we want to modify some values
    from the template, we just write them in the service definition with the new values,
    because if we have multiple definitions with the same name and different values,
    the closest to the final object wins. So, a definition at the service level wins
    over a definition in the template. We will not explain all the definitions in
    the template, as they are not useful for our goal, since our script will rely
    on the generic service definition without any alterations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the service definition and have a look at the second line `host_name`
    localhost. We already mentioned the fact that each service check must refer to
    one (or more) host, so here is where we see what host this service applies to.
    We could also have used `hostgroup_name name_of_the_hostgroup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a single check to multiple hosts enclosed in a host group definition.
    Let''s move onto the `service_description` ssh. As for the command definition,
    this is the handle used to refer to this service definition throughout Nagios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where we call the command definition passing optional arguments. In
    our predefined configuration, there are no parameters to give to the command,
    so nothing special. With this line, the service definition recalls the syntax
    defined in the command definition called by the handled, and optionally passes
    some arguments to it. All the configurations for services, commands, hosts, and
    templates follow the same structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can then have the different definitions on one files closed in their snippets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just saw how the ssh check works in Nagios, but it actually does not work,
    since it throws us an error. What we would need is a way to change the port that
    the service is being checked on. How do we accomplish this task? By simply bearing
    in mind that the actual plugin is the star here, it will drive all our efforts,
    so let''s invoke it and see what it has to say. Let''s have a look at the command
    line definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we know where the script is, so let''s call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'What we see here is that the script accepts some arguments and options on the
    command line, but each script is usually coded with a full help message invoked
    by a `-h` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's keep in mind this help, because it is something we will have to implement
    in our plugin. Anyway, what we see, among other options is that we can actually
    change the port the service is being checked on using the option: `-p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check where our `ssh` server is listening for connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we know that our `ssh` daemon is listening on port `1472`. So we have to
    make a manual check to be sure on how to invoke the plugin with the new parameters
    and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It worked we processed `-H localhost` to identify which host we are executing
    our check against and `-p 1472` to query the correct port for this `ssh` daemon
    configuration. Now, let''s pay attention to the reply from the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the standard structure of the message provided by a Nagios plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the service (SSH).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Service status (OK).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Message given by the service being checked (or a message we crafted ourselves).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then there is something we never saw before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a pipe, followed by one or more labels, time in our example, and some
    values usually related to how the service is working. Whatever is written, it
    is not a Nagios concern, since it will not process this part of the output line.
    These values are there for third-party applications such as `pnp4nagios` or Nagios
    graph to process them and eventually draw out some performance graphics.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Nagios shows the performance data but does not really make use of it
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see later how a graph for a service looks like, now let''s remember
    one thing: the output of a plugin is usually one line long and even though you
    have a multiline output, it is always better to stick to a simple message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the definition of the SSH service check, and let''s
    see how to modify it to enable a different port check. This is the `check_ssh` command
    that we have already seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the definition of an arbitrary port check, we have to modify the
    `command_line` row so that it will accept the new `-p` parameter with an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did is simple: we just added a `-p` followed by `$ARG1$`. What is this
    new bit? In Nagios, you can pass whatever arguments you want to a script, and
    you refer to them using a positional variable. Think of `$ARG1$` as  `$1` for
    a standard bash script; it identifies the first argument passed to the command
    line. Bear in mind that options like `-p` are not counted as arguments. So `$ARG2$`
    will be the second positional argument, `$ARG3$` the third, and so on. Do not
    forget the leading and trailing dollar signs. So, we modified the way Nagios can
    call the plugin, and now we can pass it an extra argument. What is left is to
    actually provide the extra argument to the script; this is done by modifying the
    service definition for `ssh`. We previously had this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition must be modified so that we can store and pass the port number
    to the command, so this is how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The exclamation mark (`!`) after the command name is a standard field separator
    and identifies the different positional arguments passed to the plugin. Let''s
    make an example modifying the `command_line` of `ssh` to accept it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We must modify the command line to accept five parameters instead of one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The modification is quite straightforward, we just wrote down all the switches
    and their arguments using the positional `$ARGn$` variables. Now that the command
    line is ready to accept the new values, we must fill in the placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Not so complicated; each argument must be written in the order expected by
    the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-p` | `-` | `-P` | `-t` |'
  prefs: []
  type: TYPE_TB
- en: '| `1472` | `4` | `2.0` | `30` |'
  prefs: []
  type: TYPE_TB
- en: One thing to bear in mind is that the standard macros do not play a positional
    parameters so they do not have to be taken in to account when counting the slot
    indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all the bits in order, with the right switches and values,
    we have to write our new configuration down. Okay, but where? The location of
    the configuration files differs from distribution to distribution and the way
    the files are fragmented too: some distributions have commands and service definitions
    inside a host file along with the host definition, some others have fragmented
    in single files. How do we deal with it? Let the Nagios process tell you how it
    reads the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ps` command shows us that Nagios is reading its main configuration directives
    from`/etc/nagios3/nagios.cfg`. So, it is worth having a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a standard section in the Nagios main configuration file, and you will
    find it in each and every installation, so pay attention to the lines that are
    not commented out by a `#` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, from the main configuration file, we can see that the configurations are
    stored in one file and two directories. Since we are dealing with a command plugin
    modification, we start from `cfg_dir=/etc/nagios-plugins/config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking for a file that cold bear an `ssh` configuration, let''s move to `root:~$
    cd /etc/nagios-plugins/config` and `grep` for `ssh` in each file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Just `egrep -l` will print only the names of the files where a match has been
    found; if you are not sure and want to see the actual matched line, use `-ir`
    instead of `-lr` , and you will see a lot more information. Anyway, between the
    two files, it seems pretty clear that the one we will have to modify is `ssh.cfg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open it and go to the end of the file, adding our new command definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As appears evident, we changed `command_name`; since there cannot be two command
    definitions with the same handle, we just chose something unique for our purposes.
    It will not be displayed to users, so it does not need to be fancy, just useful
    and meaningful. Let's save the file and proceed to define a new service configuration;
    from the main configuration file, it seems quite clear we have to look into `cfg_dir=/etc/nagios3/conf.d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s move to this directory: `root:~$ cd /etc/nagios3/conf.d`, and `grep`
    for `ssh` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, it is not clear what is bearing what, so an extended `grep` will
    be handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is clear that `hostgroups_nagios.cfg` bears the configurations related
    to the host groups, and among those, the configuration of the group of hosts that
    are being checked for the `ssh` service. The second file, `services_nagios2.cfg`,
    holds the configuration for the ssh service check, so let''s open it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here is the `ssh` service check configuration we were looking for. In a production
    environment, we would have to estimate the impact of our configuration, since
    if we now modify this definition, it will apply to all the servers we are checking
    against. Notice `hostgroup_name ssh-servers`, we are checking a group of servers
    being this group populated by one or one thousand servers is not important.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a production or a staging scenario, we would have to see which servers we
    are checking for the ssh service, understand if our modifications will have some
    odd effects on some of them, and if so, tear these servers out of the new check
    and create a special group for them using the old definition for them. In our
    case, since this is a demo installation and has `localhost` as the only group
    member, we can just modify the existing configuration and go with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition is quite similar to the one we crafted before; just here we
    are in a real scenario. Nagios is configured to apply this check on a hostgroup
    instead of a single server, but since the hostgroup is made by one server only,
    the localhost, the two definitions have the same scope. What we are left with
    is to force Nagios to reload the definitions so that our new configurations will
    be read by the core. A reload or restart will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now edit the `/etc/nagios3/nagios.cfg` file and enable the following configuration
    bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With `0` meaning disabled and `1` enabled, we just told Nagios to accept external
    command, so we can reload the configuration `service nagios3 reload`, go to the
    service name, and enter the server details page. Here we just have to click on Re-schedule
    the next check of this service.
  prefs: []
  type: TYPE_NORMAL
- en: Let's select Force check and commit; a new check will be forced whatever schedule
    is at play.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Debian and Ubuntu standard Nagios installation, you could face `Error:
    Could not stat() command file ''/var/lib/nagios3/rw/nagios.cmd''! `'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you try to force a check. You can solve it with the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you face any issues with your plugin, enable `debug` mode in `/etc/nagios3/nagios.cfg` 
    by setting the following configuration bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a lot of information written in the `debug` file, which in
    our installation is in `/var/log/nagios3/nagios.debug` file, which is important
    to understand what is going on, but they will slow down the system a bit, so we
    must keep the debug on only for the time it is needed, then we must revert to
    the normal logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Nagios reload will enforce the activation of the new configuration. But let''s
    have a look at what the debug log has to say about our new modified command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It is clear how Nagios builds up the command line piece by piece, so we can
    understand how it parses all our definitions and how it allocates the value we
    passed through the service definition itself. If we take the last row, copy and
    paste the command line of the final output, and execute it on the server, we are
    monitoring the service onto this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the service checked, a status (OK), and performance data as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our SSH service check now works and we have performance data too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance data is a useful bit of information that can give you some ready-made
    projections on service running pattern, once you plot it on a chart. With such
    data and charts we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adopt a service capacity management strategy**: Since we can easily forecast
    the consumption curve for a service, we can predict when it will be time to upgrade
    the hardware needed to provision it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find out usage patterns**: A service can be used in a uneven pattern. For
    example, a company mail server is most used during office hours and less during
    the night or weekends; disk space for a data warehouse server is used more during
    the data consolidation batches than during other moments. So, a service that appears
    adequate while you are checking it can be under-equipped in other moments: a graph
    will show you how the usage curve moves over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find failures at a glance**: Watching at the gaps into the graph, you can
    easily spot service interruptions, and selecting the piece of graph you want to
    inspect can be exploded in detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create fancy reports for management**: Seems a joke but busy management prefers
    to have a comprehensive glance at services than pages and pages of numeric data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's quickly see how to install one of this graphing tools. Since this
    is not a book on Nagios, we will not go into much detail, but we are going to
    see only what is needed to enable this third-party service and have our plugin
    performance data graphed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start editing the `/etc/nagios3/nagios.cfg` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for the following snippets of configuration and modify them so the final
    result will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We enabled the performance processing data and defined the name of the commands,
    which will deal with them; the next logical step is to define the commands we
    just pointed out. Edit the `/etc/nagios3/commands.cfg` file and add the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We are working on a Debian installation, so the paths and file names may differ
    when using some other distribution or installing from sources.
  prefs: []
  type: TYPE_NORMAL
- en: Comment out any pre-existing snippets sporting `command_name process-host-perfdata`
    and `command_name process-service-perfdata`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the new ones, as the old ones are useless for our purposes, so
    again comment them out. Now that we have the command in place and the data will
    be processed as intended, we have to tell Nagios how to trigger the chart visualization.
    So, time to edit `/etc/nagios3/conf.d/services_nagios2.cfg` and modify the previously
    edited ssh service check configuration so that now it appears as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We added an action URL configuration line so that Nagios will draw a small
    clickable icon close to the service name. So, let''s restart Nagios and go to
    the service page just to find out something new:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the action_url string to any service configurations will make this new
    icon appear
  prefs: []
  type: TYPE_NORMAL
- en: 'The icon is clickable, so we just click it and the result is similar to the
    one in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: SSH service check performance data are now graphed
  prefs: []
  type: TYPE_NORMAL
- en: From now on, our performance data will be graphed, so our Nagios environment
    is ready to host our first Nagios plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Nagios plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time now to start working to our first Nagios plugin, and it does not really
    matter what we are going check here, since what we are interested in is how to
    deal with the exchange between Nagios and the plugin, more than how and what we
    are going to monitor. Once we are done with the script, we will be able to reuse
    its framework to create whatever script we want, so let's start.
  prefs: []
  type: TYPE_NORMAL
- en: Our project involves checking the status of the local disk using the **Self-Monitoring,
    Analysis, and Reporting Technology **(**S.M.A.R.T.**), which we can think of as
    a system embedded in most hard disks and solid state disks, whose task is to anticipate
    and prevent issues and failures. So, a plugin able to query the S.M.A.R.T. system
    can be used to trap some forthcoming failures, notify the user, and even take
    advantage of the response mechanism in Nagios to trigger some scripts or programs,
    for example copying all the data from the soon to fail disk to somewhere else
    before it get lost.
  prefs: []
  type: TYPE_NORMAL
- en: Our first step in this project will be installing the `smartmontools` package
    in our distribution. In Debian and Ubuntu, the package is called `smartmontools`;
    it can be different in other distribution. What we are looking for is a package
    holding the `smartctl` utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the program our plugin will rely on, and it is the actual utility querying
    the for the disk information, so our first step will be to find which disks are
    attached to our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are; our system has one disk and its name is `sda`. If we want to find
    out something more about our disk, we can install `hwinfo` and run it as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have been introduced to our disk, we have to see if it is polite
    enough to answer our S.M.A.R.T requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'That is a lot of information taken from you hard disk and, bottom line, most
    of it is useless to you. For the sake of our little project, we will take just
    a little information into account and this is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our plugin will take just these three pieces of information into account
    with three different thresholds:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Control** | **OK** | **WARNING** | **CRITICAL** |'
  prefs: []
  type: TYPE_TB
- en: '| SMART overall-health self-assessment test result | PASSED |  | !CRITICAL
    |'
  prefs: []
  type: TYPE_TB
- en: '| Temperature | 40: | @41:49 | :50 |'
  prefs: []
  type: TYPE_TB
- en: '| Self-test execution status | 0 |  | !0 |'
  prefs: []
  type: TYPE_TB
- en: We start planning our script. For the `overall-health`, we have an OK value,
    but no WARNING since whatever value we have different from `PASSED` means to us
    a critical situation. For the temperature, we can adjust the threshold to our
    working environment. Usually a value up to 40 degrees Celsius is considered optimal.
    From 41 to 50 is deemed acceptable, meaning it can cause some damage to the disk
    in the long run, so we are in a WARNING condition--not yet lethal, but we must
    keep an eye on it.
  prefs: []
  type: TYPE_NORMAL
- en: Everything from 50 Celsius and above is considered extremely dangerous to the
    health of your disk, so we shall trigger a CRITICAL condition and have someone
    to react as soon as possible. `Self-test execution status` tells us if the last
    self test on the drive was successful or completed with errors, and so anything
    other than 0 (successful) will trigger a critical condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We identified the information that will trigger the status in Nagios; we planned
    our threshold, now before actually writing the plugin we need to find a way to
    reliably collect the data that will be evaluated against the threshold. Here some
    regular expressions will come in handy, so let''s start with the overall health,
    calling the  `smartcl` utility with a filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple one liner gets the full output from `smartctl`, then pipes it to
    the input of `grep`, which selects and outputs only the line containing the words
    `overall-health`. The output is finally passed to `awk`, which takes the input
    and divides it into columns, each field separated by blanks, and then prints out
    the sixth field, which shows `PASSED`. Then something like this would trap the
    result of the overall check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we can double-check this with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: That is, the command substitution got the output of the whole command line into
    the `H_CHECK` variable, and we could print it too.
  prefs: []
  type: TYPE_NORMAL
- en: 'One recommendation here. When it comes to variables, you can use whatever notation
    you want, it is up to you, but bear in mind some rules of thumb:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep the variable name short and meaningful**:A variable name like `THIS_IS_THE.OVER-ALL.RESULT`
    will clutter your code, so `H_HEALTH` is compact and meaningful'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use lower, capital, or camelcase like `OverAllHealth`, but be consistent
    with your choice**:Stick to whatever you chose throughout your script, so it will
    be easier to identify variables in your code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use keywords, utility of built-in names, or anything reserved for
    your variable names**:It will make your script unreliable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now it is time to get the value of the temperature in our disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s get this into a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to check for `Self-test execution status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And trap the resulting value in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a way to gather the information we want, it is time to put
    some boundaries on our investigations. What if the disk does not exist? What if
    it does not support S.M.A.R.T.? And our script will need to call `smartctl` as
    root, so we will get advantage of `sudo` to ease the process. So, let''s start
    with the first lines of the script, which holds the sha-bang, license, author,
    and first variables. Remember to change the code to whatever suits you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the sha-bang and a licence with author, nothing special, so let''s
    move on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the path for each utility we use the command substitution with which:
    this latter will give us back the path to the utility. The only drawback is that
    it will give no path if the utility is not in the `$PATH` environment of the user,
    but this is not a big deal except for `smartctl`, which is not in`$PATH` ; we
    just give the full path manually. We do not check `echo` command, since it is
    a built-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Who remembers the correct status codes returned by a Nagios plugin? Better
    have them stored in some handy variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, a bit of a caution. If the script does not receive a value for the WARNING
    and CRITICAL thresholds, it will be assigned automatically from a predefined value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have some headings in place, let''s check if our utilities are
    correctly pointed to by the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first function of our script, and its job is quite straightforward:
    it checks if the path pointed by `#SMARTCTL` leads to a file; if not, it prints
    a WARNING message and exits with an error. In our prototype, we print a message
    even if the path is valid, but in the final stage, we will put a debug condition
    to activate or deactivate this kind of extra message, since Nagios does not accept
    such a message. We will also have a debug option that will make visible the inner
    computation of our script, if needed. Let''s test what''s done so far, making
    the script executable and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check adding two fake variables to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And then run the script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The script exits at the first variable that does not hold a correct path to
    a file, so let''s delete it, remove it from the function, and run the script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Again, the script exits at the first variable met that does not hold a path
    to a file with an error code; and we printed it on the standard out. This behavior
    suits us since we want the script to stop its execution if something prevents
    it from running correctly, and we want meaningful advice, so we can amend it using
    the hints it provides. We do not need fake variables anymore, so let's clear them
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, check whether the disk we are inspecting really exists, so let''s add
    some more stuff to our script. First, a variable to hold the path to the disk
    we want to monitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s check if the path we just specified leads to a real block device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple file test on the path tells us whether this is a block device or not.
    Is it enough just to know if a path leads to a block device? No, because a disk
    is a block device, but a block device is not necessarily a disk, it can be a tape
    drive for instance. Anyway, we do not need a specific test looking for a disk,
    since the next function will check S.M.A.R.T. capabilities for the device. Only
    a S.M.A.R.T.-enabled hard disk will pass this test, and no other kinds of block
    device have this capability, so here we will sort out which is which. Before proceeding,
    let''s write a verbosity switch for our functions so that we will be able to print
    informative messages on `stdout`. Let''s start creating a variable, which will
    hold the status value for the verbosity switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s rewrite the `path_exists` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, time to test the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: All the messages are printed out, but what happens if we change the value of
    verbosity to `0` like `VERB=${VERB:=0}`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call the script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'All the messages from the `path_exists` function are now silenced. How did
    we do it? Simply using the the arithmetic `(( ))` operator, which returns true
    as exit status if it evaluates to a non-zero value. We used two different ways
    to manage the verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This compact notation has a smaller impact on the flow of our script and is
    prefered when we have to execute a short list of commands. In this case, if `$VERB`
    evaluates to not zero, a simple echo is executed, so this notation fits the case.
    When we have to execute a longer list of commands, we can choose a more readable
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can append more commands under the echo, and they all will
    be executed if `$VERB` evaluates to a non-zero value: cascading more commands
    on a list will make the code more readable and easy to maintain. But, well, the
    second verbose switch is not really useful because that part of the code traps
    an issue and comes into play when the path does not point to a file, and we always
    want to see an error message when we have an issue, regardless of the verbosity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, clear it out, as it was just an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the verbosity switch to the `disk_exists` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice (`:`) in the code. It is a placeholder for us to fill in with a S.M.A.R.T.
    capability checking code. As of now, if the path leads to a block device, the
    script does nothing (`:`). How do we check if a device is S.M.A.R.T. enabled?
    We can rely on the `smartctl` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Great, the output of `smartctl` sports two lines, on one we have the info about
    whether the device has S.M.A.R.T. capability or not and the second informs us
    whether it is enabled or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be wary while working with the output of a command: it can change upon different
    versions, so always check first the full output of the command itself before trying
    to trap some information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know where to look, it is just a simple matter to trap the bits of
    information we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Cutting the output of `smartctl` and grabbing the content of the fourth field
    only gave us the two keywords we were looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of them must be in the output for our check to pass, so let''s rewrite
    the first part of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We will make use of `awk` and `grep`, so we added them to a couple of handy
    variables. Notice that we are parsing the output of the utility (`smartctl`) and
    this can change in the future releases of the program, so we store in variables
    the fields we are working on. This way, if the output-related keywords change,
    we will modify them just once in our script. Now, just before the `disk_exists`
    function, we create a new code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We are just putting in a function that we did on the command line, but now,
    we store the output into an array. We start with simple constructs and check whether
    they work correctly. Once we are confident, we move to more complex solutions.
    Now, we must call the function with an argument; let''s do it at the end of the
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Our script is grabbing the two keywords we were looking for.
    Now, we can go further and work on the keyword so that if they are not in the
    output of `smartctl`, our script will exit with an error; and we start adding
    something at the beginning of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SMART_IND` array contains the keyword we need to trap to be sure we have
    a drive with S.M.A.R.T. capabilities, so now we have to craft our function to
    take an advantage of this new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'So, basically we grep the output of `smartctl` on the `IS_SMART` value, then
    hold the results in the `IS_SMART` array. We have two nested loops: the outer
    cycles through the values of `IS_SMART` and the inner through the values of `SMART_IND`.
    Every time two indicators match, a counter is incremented. At the end of the loop,
    if the counter is not equal to the length of `SMART_IND`, we know that we could
    not match the exact number of indicators. In some cases, you will not have that
    nice smart support string, so we can use an alternative indicator to match, in
    case the first string is not shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Maybe less, maybe more, better to exit with an error and check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens if we run this script on a system with a disk,
    which does not support SMART:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Fair enough, when the script detects no SMART capabilities, it exits cleanly
    giving us a meaningful message. Now, since the smart check can be carried on only
    if there is a valid disk, we will call the `smart_enabled` function from inside
    the `disk_exists` function. So, let''s move the `smart_enabled` function call
    from the bottom of our script to the `disk_exists` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: To be available inside the `disk_exists` function, the `smart_enable` function
    must be defined beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We made a good amount of checks, now it is time to create our check function,
    which will deal with three different times of measurements:'
  prefs: []
  type: TYPE_NORMAL
- en: Overall health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, our function must accept at least three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with something easy, implementing just the overall-check monitoring,
    starting with some new variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing really difficult, we just grep the output, put it into a variable,
    and see whether it matches our anchor (`PASSED`). If it does, the script exits
    with a `STATE_OK` value, and if not, it throws `STATE_CRITICAL`. Let''s have a
    look, but change the verbosity to `0` beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an acceptable plugin response, and if we passed this to Nagios, it
    would show a green OK field on the web UI, so we reached a milestone: we have
    our first good plugin reply. Now, since all the errors must be trapped by Nagios,
    let''s allocats `exit 1` with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'So, all the previous error message must now become optional like in the `path_exists()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We can see a slight change in the function; since we called `disk_exists` from
    inside `path_exists()`, we chained the functions so that when we have a successful
    outcome, we call the next function in a row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, we have a function to check the `overall-health` parameter, and it also
    gives us a correct Nagios message and exit code; but this is one out of three
    possible checks, so we have to make this one element in our series. So, what should
    we do if we want to make this a part of a wider range of tests? Since these are
    three checks only, we can easily group them in a `if/then/elif/fi` construct,
    but let''s start with a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a branch selector; if we do not specify anything, it will take the
    value of `HEALTH` and trigger one of the three checks; now let''s see the new
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The new code checks for how many arguments have been passed as input, if they
    are not exactly two, it throws an error and exit with  `STATE_UNKNOWN`. If we
    have two arguments, then it goes on checking if the first argument is a function
    selector and what its value. We filled in just the first function, created some
    placeholders for the other two, and got a catchall in case none of the acceptable
    values for a function selector have been entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed with the self-check function, which is quite similar to
    the `overall-health`, but first some variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You can already figure out what these are used for; we just to have to keep
    in mind we are using a lot of variable to customize the commands as much as we
    can, since we are working with a utility output, and this output can change from
    version to version. It usually stays quite the same over minor releases, but by
    using plenty of variable, we will be able to modify our script quickly if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We filled in our placeholder. This function is similar to the first one, the
    only real difference is the arithmetic evaluation performed and a check on the
    value to match and that must be a number. Calling the function with the `SELFCHECK`
    keyword will show us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, now it is time for the last check, which is quite different from the
    other two, since it requires a check against some thresholds. We start with some
    variables as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we use the code itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit more complex than the other two checks. First, we check that
    the value of `WARNING_THRESHOLD` is lower than `CRITICAL_THRESHOLD`; and we do
    it using a small command line calculator and an arithmetic evaluation. Then, we
    check that `T_CHECK` holds a numeric value since we are talking about degrees Celsius (the
    hard disk temperature is commonly reported in Celsius). Once we are free from
    such hindrances, we can proceed to check the value of `T_CHECK` against the threshold in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test the script with different values for the WARNING and CRITICAL thresholds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, our thresholds are set pretty well and the same is for the precedence
    of values, so we are quite fine. Notice the performance data; since this is a
    temperature indicator, we can later have it plotted on Nagios if we wish. The
    last step here is to create a command line parser to get all the required values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We started with the print usage. In case the user does input some wrong options,
    we give them a hint of what to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, isn''t it? But how do we call that function and manage the input? Let''s
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: What do we do in this block? While the number of arguments on the command line
    is higher than zero, we parse the command line itself, and check the options using
    the case construct. Every time we match a value, we instantiate a variable and
    shift the command line, so we are ready to process the next option; this is our
    command line parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our plugin is ready to serve our purposes, we have to copy it to the
    plugins directory `root:~$ cp check_my_smart.sh /usr/lib/nagios/plugins/`; now
    let''s check the ownership and access right to it. The one shown here should suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the script is in place, we have to tell Nagios how to call it, so a command
    definition is needed. Let''s move to the command configurations directory `cd
    /etc/nagios-plugins/config/` and create the `check_my_smart.cfg` file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We won't repeat it, but always check for the user access rights on files. If
    you are not confident about which rights to use, look at the similar files in
    the directory you are working on. But be aware of what you concede.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use `sudo` since the `smartctl` utility needs the root privileges
    to access disk information. The disk and module options must be given on the service
    configuration, but the WARNING and CRITICAL values are optional. Time to modify `/etc/sudoers`
    and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the Nagios user now is able to call the `smartctl` utility as root without
    being asked for any passwords. This, though, requires a little change in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This will enable our script to call `smartctl` as the root user. A little homework:
    try to trap and deal with the chance we did not enable `sudo` for the Nagios user.
    How would your manage this problem? Let''s move on and write our services definitions
    in `/etc/nagios3/conf.d/localhost_nagios2.cfg`, and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We configured three new service checks, but only one needs an `action_url` ,
    as only the temperature check gives us some values that change over time and can
    be usefully graphed. Now, all that is left is to restart Nagios using `service
    nagios3 restart` and check whether everything is fine, as we can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our new three checks are online and the disk seems a bit overheated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s just check whether our temperature check is producing some performance
    data and it is being graphed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are keeping an eye on the temperature, thanks to our new graph.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just saw how to handle a problem in a real scenario by analyzing our goal,
    planning the methods and tools we needed to accomplish it, and taking care of
    the issues on the path to our solution. We worked on our outcome in small steps,
    consecutive and joined all the bits once ready, so we did not face a cumbersome
    whole big problem, but solved what we encountered at each step by learning how
    to proceed and avoid overthinking. Now, we are ready to proceed and work on something
    quite useful nowadays: our personal Slack poster utility.'
  prefs: []
  type: TYPE_NORMAL
