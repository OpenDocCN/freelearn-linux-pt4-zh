- en: Remote Connections over SSH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 SSH 进行远程连接
- en: What is SSH?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 SSH？
- en: 'The common answer to such questions is to use a secure shell and use SSH. The
    only drawback is that SSH is not a shell; it is actually a protocol often referred
    to SSH1 and SSH2: two different versions of the same protocol, incompatible with
    each other. Actually, nowadays, we are mostly dealing with SSH version 2 and OpenSSH
    server; it is the server program from the OpenBSD Project, which is available
    for a number of platforms.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的问题，常见的答案是使用安全外壳并使用 SSH。唯一的缺点是，SSH 并不是一个外壳；它实际上是一个协议，通常称为 SSH1 和 SSH2：这两个版本的协议彼此不兼容。实际上，现在我们主要使用的是
    SSH 版本 2 和 OpenSSH 服务器；它是 OpenBSD 项目的服务器程序，适用于多种平台。
- en: 'What are the benefits of SSH and why should we use it? Short story long, SSH
    grants three main facilities:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 的好处是什么，为什么我们要使用它？简而言之，SSH 提供了三个主要功能：
- en: '**Authentication**: This means it can make us sure of the identity of the other
    party. So, when someone tries to connect to our SSH server, the server will be
    able to obtain a digital proof of identity of the remote party prior to giving
    it access to the system.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：这意味着它可以确保我们知道对方的身份。因此，当有人试图连接到我们的 SSH 服务器时，服务器能够在授予其系统访问权限之前，获取远程方的数字身份证明。'
- en: '**Encryption**: Older protocols such as Telnet and FTP are nice and easy to
    use, but they have a huge drawback since they send data in clear, so if someone
    could not breach a server, they could always try to eavesdrop on the data to and
    from it. SSH addresses this issue by encrypting the data, so it cannot be read
    so easily.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：像 Telnet 和 FTP 这样的旧协议简单易用，但它们有一个巨大的缺点，即它们以明文方式传输数据，因此如果有人无法攻破服务器，他们仍然可以尝试窃听与服务器之间的数据传输。SSH
    通过加密数据来解决这个问题，从而使数据不容易被读取。'
- en: '**Integrity**: It prevents tampering. If anyone intercepts the data and modifies
    it in transit, SSH will notice it.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：它防止篡改。如果有人拦截数据并在传输过程中修改它，SSH 将能够察觉到。'
- en: 'A typical SSH connection goes through a series of steps involving establishing
    a session and authenticating:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 SSH 连接经过一系列步骤，包括建立会话和身份验证：
- en: '**Session**: The server listens to a port, usually port `22`. The client contacts
    the server, which replies with the supported protocol versions. If any version
    is supported both by the client and the server, the connection continues. The
    server provides a host key, which is a proof of identity; and if it has been already
    recorded by the client on a previous session, it gets compared with the saved
    copy. The client and the server negotiate a session key, which will be used to
    encrypt the session (a symmetric key).'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：服务器监听一个端口，通常是端口 `22`。客户端联系服务器，服务器回复支持的协议版本。如果客户端和服务器都支持某个版本，连接将继续。服务器提供一个主机密钥，作为身份的证明；如果客户端在之前的会话中已记录该密钥，则会与保存的副本进行比较。客户端和服务器协商一个会话密钥，用于加密会话（对称密钥）。'
- en: 'Once a secure channel has been established, the client authenticates to the
    server with a number of options such as Kerberos; it is host-based but usually
    uses one of the following methods:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了安全通道，客户端通过多种选项（如 Kerberos）进行身份验证；它是基于主机的，但通常使用以下几种方法之一：
- en: '**Password**: The user must have a password-protected account on the remote
    server. This is probably the easiest way for the setup, but it holds some drawbacks
    such as we have to remember the username and password used on the remote host,
    and it makes it more difficult to automate logins into a script.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：用户必须在远程服务器上拥有一个受密码保护的账户。这可能是设置过程最简单的方式，但它也有一些缺点，比如我们需要记住远程主机上的用户名和密码，并且它使得自动化登录脚本变得更加困难。'
- en: '**Public key**: Not to be confused with the encryption key, the public key
    method actually relies on a pair of SSH keys, one public and one private. One
    interesting thing is that the public key can be used to encrypt the data, which
    will be decrypted only by the private key. So, this is an asymmetric encryption
    since the two keys serve different purposes, and we cannot use the public key
    to decrypt data encrypted with the same public key. And there is no way to create
    a private key from a public one, so it becomes safe and easy to distribute the
    public key: whoever gets the public key can encrypt the data, but only those ones
    with the corresponding private key can decrypt it. So, it becomes safe to share
    the public key while the private one must be kept secret and unaccessible.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公钥加密**：不要与加密密钥混淆，公钥方法实际上依赖于一对SSH密钥，一个公钥和一个私钥。一个有趣的地方是，公钥可以用来加密数据，只有私钥才能解密。因此，这是一种非对称加密，因为这两个密钥有不同的作用，我们不能使用公钥解密用相同公钥加密的数据。而且无法从公钥推导出私钥，因此公钥的分发变得安全且简单：任何获得公钥的人都可以加密数据，但只有持有对应私钥的人才能解密数据。因此，公钥可以安全地共享，而私钥必须保密且无法访问。'
- en: 'It is interesting to have a look at how the two different kinds of encryptions
    are used during an SSH session:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 看看SSH会话中如何使用两种不同加密方式非常有趣：
- en: '**Symmetric encryption**: Used to encrypt all the data flowing through an SSH
    session, it relies on the Diffie-Hellman (or related) algorithm and relies on
    a large prime number, which works as follows:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称加密**：用于加密所有通过SSH会话传输的数据，它依赖于Diffie-Hellman（或相关）算法，并依赖一个大素数，过程如下：'
- en: At the beginning of the session, both clients and servers chose a large prime
    number, which is used as a seed value. Then, the client and server chose one encryption
    generator such as AES and another prime number, which is not communicated to the
    other party.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在会话开始时，客户端和服务器都会选择一个大素数，作为种子值。然后，客户端和服务器选择一个加密生成器，如AES，以及另一个素数，且该素数不会传递给对方。
- en: Now, we have a shared prime number, two private prime numbers, and an encryption
    generator, so each party derives a public key from its private prime number that
    it can share with the other side.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了共享的素数、两个私有素数和一个加密生成器，因此每一方可以从其私有素数派生出一个公钥，并与另一方共享。
- en: Once shared, each party decrypts the other's public key, the algorithm, its
    private prime number, and the shared prime number to create a new master secret
    key that is the same for both, so it can be used to encrypt from both parts the
    subsequent traffic.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦共享，双方都解密对方的公钥、算法、私有素数以及共享的素数，从而创建一个新的主密钥，该密钥对双方都是相同的，可以用于加密双方后续的流量。
- en: In between, the process of establishing a master key involves the server using
    his host key to sign the data used in the transaction, and so it authenticates
    with the client, which now can trust the server.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此过程中，建立主密钥的过程涉及服务器使用其主机密钥对交易中使用的数据进行签名，从而实现对客户端的身份验证，客户端现在可以信任该服务器。
- en: '**Asymmetric encryption**: It is used in the authentication stage to authenticate
    the client onto the server. As we see, one of the the authentication methods is
    carried through a pair of keys, one public and one private:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非对称加密**：用于身份验证阶段，以便将客户端认证到服务器。如我们所见，其中一种身份验证方法是通过一对密钥完成的，一个公钥和一个私钥：'
- en: The client starts sending the ID of the pair of keys it wants to use for the
    authentication and a username.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端开始发送它希望用于身份验证的密钥对ID和用户名。
- en: The server then checks whether the user account is available on the system and
    if inside there is a `.ssh` directory containing an `authorized_keys` file. If
    the file is available, it should contain the public keys stored by the server,
    so the ID sent by the client is matched against the IDs of the keys stored in
    this file.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器随后检查用户账户是否在系统中可用，并且检查是否存在包含`authorized_keys`文件的`.ssh`目录。如果该文件存在，它应该包含服务器存储的公钥，因此客户端发送的ID会与存储在该文件中的公钥ID进行匹配。
- en: If the public key of the client is found, it is used to encrypt a random number
    that is then sent back to the client.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到客户端的公钥，它将用于加密一个随机数，然后返回给客户端。
- en: The client, which generated the public key, holds its secret key, and so it
    can decrypt the packet sent by the server and obtain the secret random number.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端生成公钥并持有其私钥，因此它可以解密服务器发送的数据包并获得秘密随机数。
- en: On the client side, a random number is combined with the session key, and then
    hashed to obtain its MD5 hash value.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端，一组随机数会与会话密钥结合，然后进行哈希计算得到其MD5哈希值。
- en: The MD5 hash value is then sent back to the server, which then uses the session
    key and the original random number to calculate the MD5 hash value on its own.
    If the two hash values match, it means that the client has the private key corresponding
    to the public key used to encrypt the random number and so the client is authenticated.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，MD5哈希值会被发送回服务器，服务器使用会话密钥和原始随机数来计算MD5哈希值。如果这两个哈希值匹配，就意味着客户端拥有与用来加密随机数的公钥对应的私钥，从而完成客户端认证。
- en: '**MD5 hashing**: We just hinted about MD5 hashing, so let''s briefly explain
    what it is all about without drilling too much, since there are entire books on
    cryptographic and hashing algorithms. A hashing function is used to map a bunch
    of data with an arbitrary size to a fixed size. It is like creating a fingerprint
    of something but with a peculiar property: you can map the original data to a
    fixed size value using a hashing function, but you cannot map back from the fixed
    size value to the original data. Long story short, a hashing function is a one-way
    function. MD5 is an algorithm used by the hash function to produce a 128-bit hash
    value: whatever is the size of the hashed data, the MD5 hashed value produced
    will be 128 bits long--no more, no less. Although created as a cryptographic means,
    MD5 has proved itself vulnerable to different attacks, and so, it is used nowadays
    to check the integrity of the data, downloaded from a safe site and that has not
    been intentionally tampered.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MD5哈希**：我们刚刚提到MD5哈希，接下来简要解释一下它的原理，虽然有大量关于加密和哈希算法的书籍。哈希函数用于将任意大小的数据映射到固定大小。这就像是创建一个物体的指纹，但有一个特别的性质：你可以使用哈希函数将原始数据映射到一个固定大小的值，但不能从该固定大小的值反向映射回原始数据。简单来说，哈希函数是单向的。MD5是一个用于生成128位哈希值的算法：无论哈希数据的大小如何，生成的MD5哈希值总是128位——不多也不少。尽管MD5是作为加密手段创建的，但它已被证明易受各种攻击，因此现在通常用于检查数据的完整性，例如验证从安全网站下载的数据未被篡改。'
- en: 'SSH can give us a secure channel to work over the network, avoiding having
    the data being captured by third parties and having us securely authenticated.
    Most of the time, we are dealing with an OpenSSH server, but when it comes to
    clients, there are plenty of them for any operating systems: from command-line
    programs to graphical ones such as putty. It''s just on us to choose whatever
    we find more ergonomic. Once we have chosen our preferred client, we can connect
    to the server; and since the most secure method is using public keys, we will
    see in the next chapter how to set up a passwordless connection to an SSH server.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SSH为我们提供了一个安全的通道，通过网络工作，避免数据被第三方截获，并确保我们的身份被安全认证。大多数时候，我们处理的是OpenSSH服务器，但当谈到客户端时，各种操作系统都有很多选择：从命令行程序到图形界面程序，如putty。最终，选择哪个客户端完全取决于我们自己的偏好，只要我们觉得它更符合使用习惯。一旦选择了合适的客户端，我们就可以连接到服务器；而最安全的方法是使用公钥认证，在下一章中我们将看到如何设置无密码的SSH连接。
- en: Configuration files
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: 'Before playing with ssh and having a look at what it can do for us, let''s
    take some time to see what are the most relevant files that are used to manage
    the ssh service and client. The configuration files for the SSHD daemon are usually
    stored in `/etc/ssh` where we can find some interesting files:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用ssh并查看它为我们提供的功能之前，先花点时间看看用于管理ssh服务和客户端的最相关文件。SSHD守护进程的配置文件通常存储在`/etc/ssh`目录下，在那里我们可以找到一些有趣的文件：
- en: '`moduli`: This file contains the prime numbers and generators used by sshd
    in the Diffie-Hellman group exchange key exchange method, which is needed to create
    the shared session master encryption key.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduli`：该文件包含了ssh服务器在Diffie-Hellman组交换密钥交换方法中使用的质数和生成器，用于创建共享的会话主加密密钥。'
- en: '`sshd_config`: This is the configuration file for the ssh daemon. We will have
    a closer look at it later to see some interesting and useful directives, which
    alter the way we connect to a remote server.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sshd_config`：这是ssh守护进程的配置文件。我们稍后会更详细地查看它，了解一些有趣且有用的指令，它们可以改变我们连接远程服务器的方式。'
- en: '`ssh_config`: This is the system-wide SSH client configuration file that is
    used when no user-specific configuration file is found in the user home directory
    `~/.ssh/config`. We will see later on what we can do with it.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_config`：这是系统范围的 SSH 客户端配置文件，在用户主目录 `~/.ssh/config` 中没有找到特定用户配置文件时会使用它。稍后我们将看到如何使用它。'
- en: '`ssh_host_dsa_key`: This is the DSA private key used by the sshd daemon.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_dsa_key`：这是 sshd 守护进程使用的 DSA 私钥。'
- en: '`ssh_host_dsa_key_pub`: This is the DSA public key used by the sshd daemon.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_dsa_key_pub`：这是 sshd 守护进程使用的 DSA 公钥。'
- en: '`ssh_host_rsa_key`: This is the RSA private key used by the sshd daemon.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_rsa_key`：这是 sshd 守护进程使用的 RSA 私钥。'
- en: '`ssh_host_rsa_key_pub`: This is the RSA public key used by the sshd daemon.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_rsa_key_pub`：这是 sshd 守护进程使用的 RSA 公钥。'
- en: '`ssh_host_key`: This the RSA private key used by sshd for the SSH version 1
    protocol.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_key`：这是 sshd 用于 SSH 版本 1 协议的 RSA 私钥。'
- en: '`ssh_host_key.pub`: This is the RSA public key used by sshd for the SSH version
    1 protocol.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_key.pub`：这是 sshd 用于 SSH 版本 1 协议的 RSA 公钥。'
- en: '`ssh_host_ecdsa_key`: This is the ECDSA private key used by the sshd daemon.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_ecdsa_key`：这是 sshd 守护进程使用的 ECDSA 私钥。'
- en: '`ssh_host_ecdsa_key.pub`: This is the ECDSA public key used by the sshd daemon.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_ecdsa_key.pub`：这是 sshd 守护进程使用的 ECDSA 公钥。'
- en: '`ssh_host_ed25519_key`: This is the ED25519 private key used by the sshd daemon.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_ed25519_key`：这是 sshd 守护进程使用的 ED25519 私钥。'
- en: '`ssh_host_ed25519_key.pub`: This is the ED25519 public key used by the sshd
    daemon.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_host_ed25519_key.pub`：这是 sshd 守护进程使用的 ED25519 公钥。'
- en: 'What are all these RSA, DSA, ECDSA, and ED25519 acronyms associated to the
    host keys? These acronyms refer to public key cryptosystems used for the authentication
    keys and open a world of holy wars: some say that **Digital Signature Algorithm
    (DSA)** is slower when encrypting but faster when decrypting compared to RSA (acronym
    from the name of the researchers behind this algorithm, Ron Rivest, Adi Shamir,
    and Leonard Adleman from MIT ), which is deemed to be much more secure than DSA,
    while **Elliptic Curve Digital Signature Algorithm** (**ECDSA**) and **Edwards-curve
    Digital Signature Algorithm** (**ed25519**) are newcomers on the scene. All these
    are digital signature schemes that use different properties such as prime numbers
    or elliptic curves to ensure that the encryption itself is unbreakable, or more
    realistically, computationally unfeasible or not so likely. So, before proceeding,
    let''s make a point: we cannot be sure that some encryption is really unbreakable,
    and we cannot be sure for how long some of them that nowadays look safe will be
    so in the future.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与主机密钥相关的 RSA、DSA、ECDSA 和 ED25519 缩写分别代表什么？这些缩写指的是用于身份验证密钥的公钥密码体制，涉及了许多争论：有人说
    **数字签名算法（DSA）** 在加密时较慢，但在解密时比 RSA（这个算法的名字源自于其研究者 MIT 的 Ron Rivest、Adi Shamir 和
    Leonard Adleman）更快，而 RSA 被认为比 DSA 更安全，另外 **椭圆曲线数字签名算法** (**ECDSA**) 和 **Edwards
    曲线数字签名算法** (**ed25519**) 是新兴的算法。这些都是数字签名方案，利用不同的特性如质数或椭圆曲线，确保加密本身是不可破解的，或者更现实地说，是计算上不可行或不太可能。因此，在继续之前，必须明确一点：我们不能确定某种加密方式真的是不可破解的，也无法确定现在看似安全的加密方式未来是否依旧安全。
- en: 'So, we can make an educated guess and chose an algorithm that is computationally
    expensive and allegedly without any backdoor from anyone. So, keeping in mind
    that we are never 100% safe, we can make our choice with some OpenSSH Project
    recommendations in mind:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以做出明智的猜测，选择一个计算量大的且据称没有任何后门的算法。因此，虽然我们永远无法做到百分之百的安全，但我们可以根据一些 OpenSSH
    项目的建议做出选择：
- en: OpenSSH 7.0 deprecated DSA due to its weakness. So, we can safely discard this
    algorithm.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSH 7.0 因为其弱点弃用了 DSA 算法。因此，我们可以安全地抛弃这个算法。
- en: Do not use keys smaller than 1024\. This makes sense, since longer keys can
    be computationally heavier, but for everyday use, they do not give a relevant
    added hindrance.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用小于 1024 位的密钥。这样做是有道理的，因为较长的密钥计算上会更重，但对于日常使用来说，它们并不会带来显著的额外负担。
- en: Do not use cyphers, such as Blowfish, CBC, RC4, MD5 based HMAC algorithms and
    RIPE-MD160 HMAC.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用如 Blowfish、CBC、RC4、基于 MD5 的 HMAC 算法和 RIPE-MD160 HMAC 等密码。
- en: Do not use SSH version 1, as it is deprecated and not supported.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用 SSH 版本 1，因为它已经被弃用并且不再受支持。
- en: Use ECDA or ED25519, and if it not possible, we can create an RSA key of at
    least 2048 or 4096.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ECDA 或 ED25519，如果不可行，可以创建至少 2048 或 4096 位的 RSA 密钥。
- en: Quite complex, isn't it? Well, a rule of thumb to understand what NOT to use
    is to read the Release Notes page of the OpenSSH project we can find at  [http://www.openssh.com/releasenotes.html](http://www.openssh.com/releasenotes.html) and
    have a look at the Future deprecation notice section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 够复杂了吧？嗯，要理解哪些不应该使用的一条经验法则是阅读我们可以在 [http://www.openssh.com/releasenotes.html](http://www.openssh.com/releasenotes.html)
    找到的 OpenSSH 项目的发布说明页面，然后查看 “未来弃用通知” 部分。
- en: 'Whatever we find here will be deprecated and eventually abandoned in the next
    releases, so even if we do not drill down into the details of the mathematics
    behind the encryption algorithms, we can trust the OpenSSH project and not use
    whatever is deprecated in any releases. When it comes to ciphers, these are algorithms
    that take chunks of plain data and create bits of obfuscated data. It suffices
    to say that even in this case, some holy wars are in play, with some major algorithms
    being considered weaker and some stronger:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们在这里找到什么，它都将在未来的发布版本中被弃用和废弃，因此，即使我们不深入研究加密算法背后的数学细节，我们也可以信任 OpenSSH 项目，不使用任何在任何版本中已弃用的内容。在密码学中，这些是一些算法，它们接受一块明文数据并生成一些混淆数据。可以说即使在这种情况下，也存在一些神圣战争，一些主要的算法被认为是较弱的，一些较强的算法被认为是较强的：
- en: '**Digital Encryption Standard (DES)**: Well regarded in the past, this is not
    really considered safe anymore due to the small keys used.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据加密标准（DES）**：在过去曾被广泛认可，但由于使用小密钥，现在不再被认为是安全的。'
- en: '**Triple DES**: This is based on DES and considered safer but not really efficient
    nowadays.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Triple DES**：基于 DES，被认为比较安全，但在现今效率不高。'
- en: '**Advanced Encryption Standard (AES) or Rijndael**: This is a quite recent
    algorithm and well regarded. AES-256, for instance, is used in TLS/SSL, and it
    is considered safe.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级加密标准（AES）或 Rijndael**：这是一个相对较新的算法，并且被广泛认可。例如，AES-256 在 TLS/SSL 中使用，被认为是安全的。'
- en: '**IDEA**: This is a viable algorithm but due to patent use it is not so widespread.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDEA**：这是一个可行的算法，但由于专利使用的原因，它没有广泛应用。'
- en: '**Twofish**: Using blocks of 128 bits and a variable length key, it is one
    of the choices for our encryption needs.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Twofish**：使用 128 位块和可变长度密钥，它是我们加密需求的选择之一。'
- en: '**Serpent**: If you do not have any ideas on what to choose, and cannot use
    AES, go with this, it has a block size of 128 bits and keys of 128, 192, and 256
    bits. Slower than other options but safe: a block cipher with a block size of
    128 bits.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Serpent**：如果您不知道选择什么，且不能使用 AES，可以选择 Serpent。它的块大小为 128 位，密钥长度为 128、192 和
    256 位。比其他选项慢，但安全性较高：它是一个块大小为 128 位的块密码。'
- en: 'After this short digression, we can proceed to having a look at another set
    of SSH config files that are optionally located on the user `.ssh` config directory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段简短的插曲之后，我们可以继续查看位于用户 `.ssh` 配置目录中的另一组 SSH 配置文件（可选）：
- en: '`authorized_keys`: In this file, we can find the list of the public keys that
    give access to the server. As we saw earlier, when a client tries to connect to
    the server, it looks for the account and if it exists, looks in the `.ssh/authorized_keys`
    file in the user home directory for the ID of the key pair provided by the client.
    If the ID is found, the client is authenticated with the user and key provided.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorized_keys`：在此文件中，我们可以找到授予服务器访问权限的公钥列表。正如我们前面看到的，当客户端尝试连接到服务器时，它会寻找帐户，并且如果存在，则在用户主目录中的
    `.ssh/authorized_keys` 文件中查找客户端提供的密钥对的 ID。如果找到 ID，则使用客户端提供的用户和密钥进行身份验证。'
- en: '`authorized_keys`: This file holds a list of authorized public keys for servers.
    When the client connects to a server, the server authenticates the client by checking
    its signed public key stored within this file.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorized_keys`: 该文件保存了服务器的授权公钥列表。当客户端连接到服务器时，服务器通过检查存储在此文件中的签名公钥来对客户端进行身份验证。'
- en: '`known_hosts`: This file contains the host public keys of the server that the
    client had already accessed. When the server sends to the client their host public
    key, it has looked inside this file to see if it corresponds to the previously
    stored public key for the remote host.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`known_hosts`：这个文件包含客户端已经访问过的服务器的主机公钥。当服务器向客户端发送他们的主机公钥时，它已经在此文件中查找，看看它是否对应于远程主机的先前存储的公钥。'
- en: '`config`: It holds the ssh client configuration for the user. It is really
    important in the passwordless connections since it helps to automate the connections.
    We will see more about it later.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：它保存了用户的 SSH 客户端配置。在无密码连接中非常重要，因为它有助于自动化连接。稍后我们会详细了解更多。'
- en: '`id_dsa`: This holds the DSA private key for the user.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id_dsa`：这保存了用户的 DSA 私钥。'
- en: '`id_dsa.pub`: This holds the DSA public key for the user.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id_dsa.pub`：这是用户的 DSA 公钥。'
- en: '`id_rsa`: This holds the RSA private key for the user.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id_rsa`：这是用户的 RSA 私钥。'
- en: '`id_rsa.pub`: This holds the RSA public key for the user.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id_rsa.pub`：这是用户的 RSA 公钥。'
- en: '`Identity`: This contains the RSA private key of the user for SSH version 1.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Identity`：这是 SSH 版本 1 中用户的 RSA 私钥。'
- en: '`Identity.pub`: This contains the RSA public key of the user for SSH version
    1.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Identity.pub`：这是 SSH 版本 1 中用户的 RSA 公钥。'
- en: These are files we could find on a host, but probably we will not find all of
    them, for instance, not all the keys will be there; and we will have to create
    them taking the chance to give them some more meaningful names. Something we are
    sure to find on a remote host and interest us is the `sshd_config` file. Since
    this will help us to modify the way the daemon will offer the SSH server, let's
    have a look at it more in detail, covering some of the most interesting directives.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可能在主机上找到的文件，但可能并不是所有文件都存在，例如，并非所有密钥都会在那里；我们需要创建它们并给它们一些更有意义的名称。在远程主机上我们可以确定会找到并对我们有用的文件是
    `sshd_config` 文件。因为它帮助我们修改守护进程提供 SSH 服务的方式，让我们更详细地查看它，涵盖一些最有趣的指令。
- en: The sshd_config file
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sshd_config 文件
- en: 'We will have a look at the directives that can be the most useful for our everyday
    service usage, but if we need to know all the details about all the configuration
    options, we can just invoke `man`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一些对日常服务使用最有用的指令，但如果我们需要了解所有配置选项的详细信息，只需调用 `man` 命令：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The main SSH daemon configuration file is located at the `/etc/ssh/sshd_config` event,
    though we can specify any file at the daemon startup using the `-f` option on
    the command line. That said, let''s go through and have a look at the most interesting
    configuration bits:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 SSH 守护进程配置文件位于 `/etc/ssh/sshd_config`，但我们也可以在守护进程启动时使用命令行的 `-f` 选项指定任何文件。话虽如此，让我们逐步了解并查看最有趣的配置部分：
- en: '`AcceptEnv`: This allows the client to copy the environment variable into the
    session environment sent by the client. It can be useful, but it can also be dangerous,
    and the default is not to accept any client environment variable.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AcceptEnv`：此指令允许客户端将环境变量复制到会话环境中并发送给客户端。它可能很有用，但也可能很危险，默认情况下不接受任何客户端环境变量。'
- en: '`AllowGroups`: By default, the log in is only allowed for members from all
    groups available on the system, but with this directive, you can restrict it to
    only to the users whose primary or secondary groups matches the groups listed,
    even using a pattern, as we will see later. We can use group names only; no ID
    and the access directives are processed in this order: `DenyUsers`, `AllowUsers`,
    `DenyGroups`, `AllowGroups`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllowGroups`：默认情况下，只有系统上所有组的成员才能登录，但通过这个指令，你可以将登录权限限制为那些主组或次组与列出的组匹配的用户，甚至可以使用模式匹配，稍后我们会看到。我们只能使用组名，不能使用组
    ID，访问指令的处理顺序是：`DenyUsers`、`AllowUsers`、`DenyGroups`、`AllowGroups`。'
- en: '`AllowUsers`: By default, all users with a valid account are allowed to log
    in, but with this directive, we can restrict the access to only those members
    who match an account name or a patter. We can specify user names only and not
    IDs. We can also specify a member as `user@host` so that the restrictions will
    be applied not only to the account name but also to the origin host. This can
    be written in the CDIR/mask format. The access directives are processed in this
    order: `DenyUsers`, `AllowUsers`, `DenyGroups`, `AllowGroups`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllowUsers`：默认情况下，所有拥有有效账户的用户都可以登录，但通过这个指令，我们可以将访问限制为那些账户名或模式匹配的成员。我们只能指定用户名，不能使用
    ID。我们还可以指定成员为 `user@host`，这样限制不仅会应用于账户名，还会应用于源主机。这个可以用 CDIR/掩码格式书写。访问指令的处理顺序是：`DenyUsers`、`AllowUsers`、`DenyGroups`、`AllowGroups`。'
- en: '`AuthenticationMethods`: We can specify the authentication methods that a user
    must successfully go through to be given access to the system. It defaults to
    *any* meaning that the user must successfully authenticate once to any of the
    available methods. If any authentication methods combination is listed, for instance,
    `password`, `publickey`, `keyboard-interactive`, `publickey`, the user will be
    forced to authenticate through all the authentication methods at least once and
    in the order they are listed. So, in the example show, the user has to successfully
    authenticate with the `publickey` method and then at least with a password. The
    `keyboad-interactive` method is a generic authentication, which relies on facilities
    such as PAM, RADIUS, and RSA Secure ID and can be limited by appending a column
    followed by the `bsdauth`, `pam`, or `skey` keywords. If the `publickey` method
    is used more than once, such as `publickey` and `publickey`, two different public
    keys will be required to successfully authenticate. Whatever method is listed,
    it then must be enabled in the configuration.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticationMethods`: 我们可以指定用户必须成功通过的认证方法才能获得系统访问权限。默认值为*any*，意味着用户只需成功通过任何一种可用的认证方法。如果列出了任何认证方法的组合，例如`password`、`publickey`、`keyboard-interactive`、`publickey`，则用户将被要求至少按顺序成功通过所有认证方法一次。因此，在示例中，用户必须先使用`publickey`方法成功认证，然后至少使用密码认证。`keyboard-interactive`方法是一种通用认证，依赖于诸如PAM、RADIUS和RSA
    Secure ID等设施，并且可以通过在其后附加`bsdauth`、`pam`或`skey`等关键字来限制。如果`publickey`方法被使用多次，例如`publickey`和`publickey`，则需要两个不同的公共密钥才能成功认证。无论列出的是哪种方法，必须在配置中启用该方法。'
- en: '`AuthorizedKeysFile`: Sometimes, we just put our client public authentication
    key in the `authorized_keys` file inside the `user ~./ssh` directory and nothing
    happens. Well, one of the issues could be originated by this directive, since
    it is here where the name of the file is defined. The default value is `.ssh/authorized_keys
    .ssh/authorized_keys2`, but we can also find some tokens such as `%h/.ssh/authorized_keys`,
    with `%h` standing for the home directory of the account autenticating; or we
    can also see `%%` , which stands for a simple `%` while a `%u` is replaced by
    the username. Once the tokens are expanded, the result is taken either as the
    full path to the file or the path relative to the user home directory.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthorizedKeysFile`: 有时，我们只需将客户端的公共认证密钥放在`user ~./ssh`目录中的`authorized_keys`文件内，什么也不会发生。其实，这个问题可能是由此指令引起的，因为文件名就是在这里定义的。默认值是`.ssh/authorized_keys
    .ssh/authorized_keys2`，但我们还可以找到一些标记，例如`%h/.ssh/authorized_keys`，其中`%h`表示正在认证的账户的主目录；或者我们也可以看到`%%`，表示一个简单的`%`，而`%u`则被用户名替代。一旦标记被扩展，结果将作为文件的完整路径或相对于用户主目录的路径来处理。'
- en: '`Banner`: This is a nice option to show a message to the user before he authenticates.
    If `none` is supplied, no banner is shown. It is only available for SSH-2 and
    defaults to none.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Banner`: 这是一个很好的选项，用于在用户身份验证之前向用户显示消息。如果提供`none`，则不会显示横幅。此选项仅适用于SSH-2，默认值为none。'
- en: '`ChallengeResponseAuthentication`: This allows the challenge-response authentication.
    It defaults to `yes`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChallengeResponseAuthentication`: 这允许挑战-响应认证。默认值为`yes`。'
- en: '`ChrootDirectory`: By specifying the full path to a directory, we can `chroot`
    a user into it after he successfully authenticates. It is not an easy task though
    since the directory must be owned by root and not writable by anyone else. In
    addition, we must provide some files required for a session, such as the shell,
    `/dev/null`, `/dev/zero`, `/dev/arandom`, `/dev/stdin`, `/dev/stdout`, `/dev/stderr`,
    and `/dev/ttyx`. We can also find some tokens such as `%h` standing for the home
    directory of the account authenticating; or we can also see `%%` , which stands
    for a simple `%` while a `%u` is replaced by the username.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChrootDirectory`: 通过指定目录的完整路径，我们可以在用户成功认证后将其`chroot`到该目录。然而，这并不是一项简单的任务，因为该目录必须由root拥有，且不可由其他任何人写入。此外，我们还需要提供会话所需的一些文件，例如shell、`/dev/null`、`/dev/zero`、`/dev/arandom`、`/dev/stdin`、`/dev/stdout`、`/dev/stderr`和`/dev/ttyx`。我们还可以找到一些标记，如`%h`，代表正在认证的账户的主目录；或者我们也可以看到`%%`，表示一个简单的`%`，而`%u`则被用户名替代。'
- en: '`Ciphers`: This allows us to specify the ciphers allowed for SSH-2\. This is
    a good point to restrict the number and kind of ciphers we want to deal with.
    The default cipher list, comma separated, is `aes128-ctr,aes192-ctr`, `aes256-ctr`, `aes128cm@openssh.com`, `aes256-gcm@openssh.com`,
    and `chacha20-poly1305@openssh.com`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ciphers`：此项允许我们指定SSH-2所允许的加密算法。这是一个很好的方法来限制我们希望使用的加密算法的数量和种类。默认的加密算法列表，以逗号分隔，包含`aes128-ctr,aes192-ctr`,`aes256-ctr`,`aes128cm@openssh.com`,`aes256-gcm@openssh.com`和`chacha20-poly1305@openssh.com`。'
- en: '`ClientAliveCountMax`: This is the number of the client alive messages that
    can be sent without the daemon receiving any reply from the client. When the max
    is hit, the daemon will disconnect the client. The default value is `3`; and this
    option is available only for SSH-2.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientAliveCountMax`：这是可以发送的客户端存活消息的数量，在此期间守护进程没有收到来自客户端的任何回复。当达到最大值时，守护进程将断开与客户端的连接。默认值为`3`；此选项仅适用于SSH-2。'
- en: '`ClientAliveInterval`: This is the time interval, in seconds, after which if
    the client does not send any messages, the server will send itself a message through
    the encrypted channel to the client to push for a reply. The default is `0`. So,
    let''s say that we set this option to `5` and the previous `ClientAliveCountMax`
    to `12`; the client will be disconnected after `60` seconds.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientAliveInterval`：这是一个时间间隔，以秒为单位，表示如果客户端在此时间内未发送任何消息，服务器将通过加密通道向客户端发送一条消息，要求客户端回复。默认值是`0`。举个例子，假设我们将此选项设置为`5`，并将之前的`ClientAliveCountMax`设置为`12`，那么客户端将在`60`秒后被断开连接。'
- en: '`DenyGroups`: By default, members from all the groups are allowed to authenticate
    but with this directive, we can restrict them to a list of space-separated groups.
    So, the authentication is unavailable for those users whose primary or supplementary
    groups is listed in this directive or matched through a pattern.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DenyGroups`：默认情况下，所有组的成员都被允许进行身份验证，但通过此指令，我们可以将它们限制为一个由空格分隔的组列表。因此，对于那些其主组或附加组出现在此指令中或通过模式匹配的用户，将无法进行身份验证。'
- en: 'We already mentioned the pattern available in `sshd config`, and this breaks
    down essentially to two characters:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了`sshd config`中可用的模式，这本质上分为两个字符：
- en: '*** matches 0 or more characters**: Something like `192.168.*` will match all
    the IP addresses starting with `192.168` ; or `*.foo.com` will match all the third-level
    domains for `foo.com` as well as the second-level domain called foo.com.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*** 匹配0个或多个字符**：类似于`192.168.*`，将匹配所有以`192.168`开头的IP地址；或者`*.foo.com`将匹配所有`foo.com`的三级域名以及名为foo.com的二级域名。'
- en: '**? matches exactly one character**: So, for instance, `192.16?.1` will match
    all the IPS from `192.160.1` to `192.168.9.1`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**? 匹配一个字符**：例如，`192.16?.1`将匹配从`192.160.1`到`192.168.9.1`的所有IP地址。'
- en: '**Pattern list**: As the name states, this is a list of patterns delimited
    by commands. The single patterns can be negated by a leading exclamation mark;
    for example, `!*.noway.foo.com,*.foo.com` would allow the all the third-level
    domains for `foo.com` except those containing a noway right before `.foo.com`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式列表**：顾名思义，这是一个由命令分隔的模式列表。单个模式可以通过前导的感叹号来否定；例如，`!*.noway.foo.com,*.foo.com`会允许所有`foo.com`的三级域名，除了那些在`.foo.com`之前包含`noway`的域名。'
- en: 'Groups must be specified by their name, not by their numeric ID; and the order
    in which this directive is processed is: `DenyUsers`, `AllowUsers`, `DenyGroups`,
    and  `AllowGroups`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 组必须通过名称指定，而不能通过数字ID指定；此指令的处理顺序为：`DenyUsers`、`AllowUsers`、`DenyGroups`和`AllowGroups`。
- en: '`DenyUsers`: Followed by a list of user name patterns separated by a space,
    this directive disallows the log in for those user accounts which match the listed
    patterns. As usual, only the names of the users and not their ID can be specified
    and by default all users are allowed to log in. We can also specify a member as
    `ser@host` so that the restrictions will be applied not only to the account name
    but also to the origin host; this can be written also in the CDIR/mask format.
    The access directives are processed in this order: `DenyUsers`, `AllowUsers`,
    `DenyGroups`, and `AllowGroups`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DenyUsers`：跟随一个由空格分隔的用户名模式列表，此指令禁止与列出模式匹配的用户账户登录。像往常一样，只能指定用户的名称，而不能指定其ID，默认情况下所有用户都可以登录。我们还可以指定`ser@host`形式的成员，以便限制不仅适用于账户名，还适用于来源主机；这也可以用CDIR/mask格式写入。访问指令按以下顺序处理：`DenyUsers`、`AllowUsers`、`DenyGroups`和`AllowGroups`。'
- en: '`DisableForwarding`: This directive disables all kinds of forwardings such
    as X11, TCP, ssh-agent, and `StreamLocal`. This is a nice directive to use if
    we want to trim down the service and make it safer.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisableForwarding`：此指令禁用所有类型的转发，如X11、TCP、ssh-agent和`StreamLocal`。如果我们希望精简服务并提高安全性，这是一个很好的指令。'
- en: '`ForceCommand`: This overrides any command sent by the client or listed in
    the `~/.ssh/rc` of the authenticating account; and it forces the execution of
    the command listed in this directive. The command is executed through the account
    shell with the `-c` option. This defaults to `no`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForceCommand`：此指令会覆盖客户端发送的任何命令或认证账户`~/.ssh/rc`中列出的命令；并强制执行该指令中列出的命令。该命令通过账户的shell以`-c`选项执行。默认值为`no`。'
- en: '`HostbasedAuthentication`: This allows/denies the authentication based on `rhosts`
    or `hostS_equive` along with a successful public `jkey` client host authentication.
    The default is `no/`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostbasedAuthentication`：此指令允许/拒绝基于`rhosts`或`hostS_equive`以及成功的公钥`jkey`客户端主机认证的认证。默认值为`no`。'
- en: '`HostKey`: This directive specifies the file the private host key is kept in.
    By default, the locations are `/etc/ssh/ssh_host_rsa_key`, `/etc/ssh/ssh_host_ecdsa_key`,
    and `/etc/ssh/ssh_host_ed25519_key`. We can have multiple host keys defined for
    a single host. but it is important that the files holding them are not world or
    group accessible.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostKey`：此指令指定保存私有主机密钥的文件。默认位置为`/etc/ssh/ssh_host_rsa_key`、`/etc/ssh/ssh_host_ecdsa_key`和`/etc/ssh/ssh_host_ed25519_key`。我们可以为单一主机定义多个主机密钥，但重要的是这些文件不能被全局或组访问。'
- en: '`KbdInteractiveAuthentication`: This allows/denies the keyboard-interactive
    authentication. The default value is drawn from `ChallengeResponseAuthentication` ,
    which is usually set to `yes`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KbdInteractiveAuthentication`：允许/禁止键盘交互式认证。默认值来自`ChallengeResponseAuthentication`，通常设置为`yes`。'
- en: '`KerberosAuthentication`: This allows/denies the validation through a Kerberos
    server of the password provided by the client. The default value is `no`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KerberosAuthentication`：此指令允许/拒绝通过Kerberos服务器验证客户端提供的密码。默认值为`no`。'
- en: '`ListenAddress`: This lists the addresses SSH daemon will be listening on.
    We can use an IPv4/IPv6 address, a hostname, or a list of them and follow them
    with an optional port, such as following:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListenAddress`：列出了SSH守护进程将监听的地址。我们可以使用IPv4/IPv6地址、主机名或它们的列表，并可选择性地在后面跟上端口，如下所示：'
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If no ports are specified, sshd will listen on those listed in the ports directive.
    The default configuration is to listen to all local addresses:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定端口，sshd将监听在`ports`指令中列出的端口。默认配置是监听所有本地地址：
- en: '`LoginGraceTime`: This is a timeout in seconds for the user to complete the
    log in process. It defaults to 120 seconds; with 0, we can disable the timeout.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginGraceTime`：这是用户完成登录过程的超时时间（秒）。默认值为120秒；若设置为0，则可以禁用超时。'
- en: '`LogLevel`: In case of any issues, we can modify the verbosity of the logs
    generated by sshd. The default level is `INFO` , but we can set it to any of `QUIET`,
    `FATAL`, `ERROR`, `INFO`, `VERBOSE`, `DEBUG`, `DEBUG1`, `DEBUG2`, `DEBUG3`. `DEBUG` and
    `DEBUG1` are equivalent while each `DEBUGx` enables a higher level of verbosity.
    `DEBUG` is not advised since it can disclose too many private informations related
    to the users.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogLevel`：在出现任何问题时，我们可以修改sshd生成的日志的详细程度。默认级别为`INFO`，但我们可以将其设置为`QUIET`、`FATAL`、`ERROR`、`INFO`、`VERBOSE`、`DEBUG`、`DEBUG1`、`DEBUG2`、`DEBUG3`中的任何一个。`DEBUG`和`DEBUG1`等效，而每增加一个`DEBUGx`，日志的详细程度会更高。由于`DEBUG`可能泄露太多与用户相关的私人信息，因此不推荐使用。'
- en: '`Match`: With this directive, we can use conditional statements so that if
    they are satisfied, the following configuration lines will override the one in
    the main configuration block. If a keyword/configuration block appears in more
    than one match clause, only the first instance is taken in account. As a matching
    criteria, we can use the following directives: user, group, host, local address,
    local port, address, or all for all of them. We can match against a single value,
    a comma separated list and we can also use wildcards and negation operators.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Match`：使用此指令，我们可以使用条件语句，以便在条件满足时，后续的配置行将覆盖主配置块中的配置。如果一个关键字/配置块出现在多个匹配条件中，只有第一个实例会被考虑作为有效。作为匹配标准，我们可以使用以下指令：user、group、host、local
    address、local port、address，或者使用all匹配所有条件。我们可以匹配单个值、逗号分隔的列表，并且还可以使用通配符和否定操作符。'
- en: '`MaxAuthTries`: This limits the maximum number or authentication attempts per
    single connection. Once half of the threshold is hit, the subsequent failed attempts
    are logged. It defaults to `6`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxAuthTries`：此选项限制每个连接的最大身份验证尝试次数。一旦达到阈值的一半，后续的失败尝试会被记录。默认值为`6`。'
- en: '`PasswordAuthentication`: This allows/denies password authentication. This
    defaults to yes.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PasswordAuthentication`：此选项允许/拒绝密码身份验证。默认值为`yes`。'
- en: '`PermitEmptyPasswords`: This allows/denies the use of empty passwords when
    password authentication is enabled. This is not safe to set to `yes` and defaults
    to `no`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PermitEmptyPasswords`：此选项允许/拒绝在启用密码身份验证时使用空密码。将此选项设置为`yes`并不安全，默认值为`no`。'
- en: '`PermitRootLogin`: This lets a user log in as root. It can have the following
    values: `yes`, `prohibit-password`, `without-password`, `forced-commands-only`,
    and `no`. If set to `prohibit-password` or `without-password`, the `password`
    and `keyboard-interactive` authentications are not available for user root; if
    set to `forced-commands-only`, a log in with public key authentication is allowed
    but only if a command is specified.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PermitRootLogin`：此选项允许用户以root身份登录。它可以有以下值：`yes`、`prohibit-password`、`without-password`、`forced-commands-only`和`no`。如果设置为`prohibit-password`或`without-password`，则`password`和`keyboard-interactive`身份验证对于root用户不可用；如果设置为`forced-commands-only`，则允许通过公钥认证登录，但仅在指定了命令的情况下。'
- en: '`PermitTTY`: This allows/denies the use of a `pty` (pseudo terminal) for the
    session. This defaults to `yes`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PermitTTY`：此选项允许/拒绝使用`pty`（伪终端）进行会话。默认值为`yes`。'
- en: '`PermitTunnel`: This allows/denies the *tun* device forwarding. It takes `yes`,
    `point-to-point`, `ethernet` or `no` as arguments. `Yes` enables both `point-to-point`
    and `ethernet` forwarding. This defaults to `no`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PermitTunnel`：此选项允许/拒绝*tun*设备转发。它接受`yes`、`point-to-point`、`ethernet`或`no`作为参数。`Yes`启用`point-to-point`和`ethernet`转发。默认值为`no`。'
- en: '`PermitUserRC`: If set to `yes`, the commands inside `~/.ssh/rc` are executed.
    This defaults to `yes`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PermitUserRC`：如果设置为`yes`，则会执行`~/.ssh/rc`中的命令。默认值为`yes`。'
- en: '`Port`: This specifies the port number the SSH daemon will listen on. This
    defaults to `22`, but we should move this port to some higher number to avoid
    most of the script kiddies around trying to automatically deface the service.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Port`：此选项指定SSH守护进程监听的端口号。默认值为`22`，但我们应该将此端口更改为较高的数字，以避免大多数脚本小子尝试自动破坏服务。'
- en: '`PubkeyAuthentication`: This allows/denies public key authentication. This
    defaults to `yes`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PubkeyAuthentication`：此选项允许/拒绝公钥身份验证。默认值为`yes`。'
- en: '`StrictModes`: This enables/disables file mode and ownership checks on the
    account''s files and home directory before letting the log in process go through.
    If it is set to `yes`, it checks for a world-writable user `.ssh` directory or
    a world writable `home` directory, and if we leave our files or directories world-writable,
    the log in is denied. This does not apply to `ChrootDirectory` , whose permissions
    and ownership are always checked.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StrictModes`：此选项在登录过程中检查账户文件和主目录的文件模式和所有权。如果设置为`yes`，则会检查是否存在对全体用户可写的`.ssh`目录或`home`目录，如果文件或目录对全体用户可写，则拒绝登录。此选项不适用于`ChrootDirectory`，其权限和所有权始终会被检查。'
- en: '`Subsystem`: This enables the execution of an external subsystem, usually an
    `sftp-server`. The syntax is a subsystem name followed by a command with an optional
    argument to be executed on a subsystem invocation. This defaults to the `no` subsystem
    configured.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subsystem`：此选项启用外部子系统的执行，通常是`sftp-server`。语法是子系统名称后跟一个命令，命令可以带有可选参数，在调用子系统时执行。默认值为配置的`no`子系统。'
- en: '`SyslogFacility`: We can use any of these `syslog` facilities to log the messages
    from the SSH daemon: `DAEMON`, `USER`, `AUTH`, `LOCAL0`, `LOCAL1`, `LOCAL2`, `LOCAL3`,
    `LOCAL4`, `LOCAL5`, `LOCAL6`, and `LOCAL7`. This defaults to `AUTH`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyslogFacility`：我们可以使用以下任一`syslog`设施记录来自SSH守护进程的消息：`DAEMON`、`USER`、`AUTH`、`LOCAL0`、`LOCAL1`、`LOCAL2`、`LOCAL3`、`LOCAL4`、`LOCAL5`、`LOCAL6`、`LOCAL7`。默认值为`AUTH`。'
- en: '`TCPKeepAlive`: This enables the server to send `TCP keepalive` to the client
    so that it will be able to detect any disconnection. This is not an easy choice:
    a temporary routing issue could lead to a forced disconnection from the server;
    but without a `keepalive`, a connection could hang indefinitely if the client
    disconnects or dies. This defaults to `yes`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TCPKeepAlive`：此选项启用服务器向客户端发送`TCP keepalive`，以便检测是否断开连接。这不是一个简单的选择：临时路由问题可能导致与服务器的强制断开；但是如果没有`keepalive`，当客户端断开或崩溃时，连接可能会无限期挂起。默认值为`yes`。'
- en: '`UseDNS`: This forces the SSH daemon to resolve, the host name through a DNS
    facility and check whether it resolves to the IP address of the client connecting.
    If this option is set to `no`, the usage of `from= in ~/.ssh/authorized_keys`
    still does not support host names but IP addresses only; and the same is applicable
    for the Match Host directive. Setting this option to `yes` can cause delays in
    authentication due to the DNS resolution task. Defaults to `yes`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseDNS`：此选项强制 SSH 守护进程通过 DNS 服务解析主机名，并检查它是否解析到连接客户端的 IP 地址。如果设置为 `no`，则在 `~/.ssh/authorized_keys`
    中使用 `from=` 仍然不支持主机名，只支持 IP 地址；同样适用于 Match Host 指令。将此选项设置为 `yes` 可能会导致认证时的延迟，因为需要进行
    DNS 解析。默认值为 `yes`。'
- en: '`UsePAM`: This enables/disables the Pluggable Authentication Module interface.
    Defaults to `no`. If set to `yes`, it will enable the authentication through PAM
    using `ChallengeResponseAuthentication` and `PasswordAuthentication`, along with
    the PAM account and session modules, so one of these must be disabled. Interestingly,
    enabling PAM will allow the SSH daemon to run as an unprivileged user. This defaults
    to `no`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsePAM`：此选项启用/禁用可插拔认证模块接口。默认值为 `no`。如果设置为 `yes`，则会通过 PAM 启用认证，使用 `ChallengeResponseAuthentication`
    和 `PasswordAuthentication`，并配合 PAM 账户和会话模块，因此必须禁用其中一个。有趣的是，启用 PAM 会使 SSH 守护进程以非特权用户身份运行。默认值为
    `no`。'
- en: '`UsePrivilegeSeparation`: If this is enabled, after the user''s log in, the
    SSH daemon will create a child process with the privileges of the authenticated
    user. It can take `yes`, `no` ,  or `sandbox` as arguments. If `sandbox` is selected,
    further mandatory restrictions are performed on the syscalls the child can perform
    so that it will be more difficult to use a compromised child to attack hosts or
    the local kernel. This defaults to sanbox.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsePrivilegeSeparation`：如果启用此选项，用户登录后，SSH 守护进程会创建一个拥有认证用户权限的子进程。它可以接受 `yes`、`no`
    或 `sandbox` 作为参数。如果选择 `sandbox`，会对子进程的系统调用执行更多强制性限制，从而使得利用受损的子进程攻击主机或本地内核更加困难。默认值为
    `sandbox`。'
- en: '`X11Forwarding`: This allows/denies X11 forwarding. If set to `yes`, it can
    expost X11 to attacks, so this option must be taken with care. Defaults to `no`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X11Forwarding`：此选项允许/禁止 X11 转发。如果设置为 `yes`，可能会将 X11 暴露于攻击之下，因此必须谨慎使用此选项。默认值为
    `no`。'
- en: We just saw some of the configurations on the server side, but we can alter
    how we interact with the SSH daemon configuring the client too, so let's have
    a look at the most interesting options from the client side.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了一些服务器端的配置，但我们也可以通过配置客户端来改变与 SSH 守护进程的交互方式，因此让我们来看看客户端最有趣的一些选项。
- en: ssh_config
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ssh_config
- en: 'On the client side, we have a few ways to configure how a connection will be
    held:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们有几种方式来配置连接的保持方式：
- en: From the command line, passing options to the client while invoking it
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行传递选项给客户端时
- en: From the configuration file inside the user's home directory `~/.ssh/config`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户主目录中的配置文件 `~/.ssh/config` 中
- en: From the system-wide configuration file in `/etc/ssh/ssh_config`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从系统范围的配置文件 `/etc/ssh/ssh_config` 中
- en: For the configuration files, we must bear in mind that only the first value
    obtained for each directive will be used; so if we give the same directive multiple
    times, only the first one will be evaluated. So, we must keep the more specific
    options at the beginning of the configuration file while the broader one will
    be pushed toward the end.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置文件，我们必须记住，每个指令只会使用第一个获得的值；因此，如果多次指定同一指令，只有第一个会被评估。所以，我们必须将更具体的选项放在配置文件的前面，而更宽泛的选项则放在后面。
- en: 'As we will see in the next paragraph, where we will examine a practical use
    of the client configuration, the file is segmented into sections whose boundaries
    are delimited by the `Host` directive: whatever configuration directive is listed
    below the keyword will belong to the host specified, until the next Host declaration.
    Each line in the file contains a configuration directive and value, optionally
    enclosed in double quotes when containing spaces; lines starting with `#` or blank
    are considered comments. Multiple values can be separated by a whitespace or `=`.
    With these caveats in mind, let''s have a look at the most interesting keywords
    in the client configuration file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一段中看到的，我们将检查客户端配置的实际使用，文件被分成了多个部分，这些部分的边界由`Host`指令限定：任何在该关键字下列出的配置指令都将属于指定的主机，直到下一个`Host`声明为止。文件中的每一行包含一个配置指令及其值，如果值中包含空格，则可选择性地用双引号括起来；以`#`或空白开头的行被视为注释。多个值可以用空格或`=`分隔。牢记这些注意事项，让我们来看看客户端配置文件中最有趣的关键字：
- en: '`Host`: This directive can take a host name as an argument or a pattern, which
    can be negated with `!`. If `*` the following directives apply to all hosts. Whatever
    pattern or name is given here, it should match the host name we would give on
    the command line to connect to the remote host. All the directives following the
    `Host` keyword will be applied only to the host defined, up to the next `Host`
    or `Match` directive. If a host/pattern value is negated, all the directives for
    that host(s) are negated.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host`：此指令可以接受一个主机名作为参数，或者一个模式，可以用`!`来取反。如果是`*`，则后续指令适用于所有主机。这里给出的模式或名称应该与我们在命令行中连接远程主机时使用的主机名相匹配。所有在`Host`关键字后面的指令仅适用于定义的主机，直到下一个`Host`或`Match`指令为止。如果主机/模式值被取反，则所有针对该主机的指令也被取反。'
- en: '`Match`: This limits the scope of the following directives, up to the next
    `Match` or `Host` declaration, to be applied only when the values specified are
    satisfied. The values can be `all` , which always matches or one or more among
    `canonical`, `exec`, `host`, `originalhost`, `user`, and `localuser`. The `all`
    value must appear alone or right after canonical, which are the only two options
    not requiring an argument. Values can be negated using `!`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Match`：此指令限制后续指令的适用范围，直到下一个`Match`或`Host`声明为止，只有在满足指定值时才会应用。值可以是`all`，表示总是匹配，或者是`canonical`、`exec`、`host`、`originalhost`、`user`和`localuser`中的一个或多个。`all`值必须单独出现或紧接着`canonical`，这两种选项不需要参数。值可以使用`!`来取反。'
- en: '`canonical`: This is matched when the configuration file is reparsed after
    the hostname canonicalization has taken place (we will see in a while what it
    means).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canonical`：当配置文件在主机名标准化之后重新解析时，匹配此项（稍后我们将看到它的含义）。'
- en: '`exec`: Executes a command using the account''s shell; and if its `exit` status
    is zero then the condition is evaluated as `true`. If the command contains a whitespace
    then it must be quoted; it can accept tokens as arguments (we will see in a while
    what it means).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`：使用账户的shell执行命令；如果命令的`exit`状态为零，则条件被评估为`true`。如果命令包含空格，则必须加引号；它可以接受作为参数的令牌（稍后我们将看到它的含义）。'
- en: '`host`: This matches against the destination hostname, after any substitution
    operated by the `Hostname` or `CanonicalizeHostname` options. It can accept a
    comma-separated list, wildcards, and negation (`!`). For instance, take a look
    here:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：这与目标主机名匹配，在任何通过`Hostname`或`CanonicalizeHostname`选项进行的替换后。它可以接受逗号分隔的列表、通配符和取反（`!`）。例如，看看这里：'
- en: '[PRE2]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will use the identity file called  `foo.identity` only if the target host
    has the `foo.com` hostname and the the port equals to `9999`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅在目标主机的主机名为`foo.com`且端口号为`9999`时，使用名为`foo.identity`的身份文件。
- en: '`originalhost`: This is matched against the hostname specified on the client
    command line.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`originalhost`：这与客户端命令行上指定的主机名匹配。'
- en: '`user`: This matches against the username used to log in on the remote host.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：这与用于在远程主机上登录的用户名匹配。'
- en: '`localuser`: This is matched against the local (client side) user running an
    SSH client.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localuser`：这与运行SSH客户端的本地（客户端侧）用户匹配。'
- en: '`BatchMode`: Useful for unattended log in from a script. If it is set to `yes`,
    no passphrases or passwords will be asked for and the `ServerAliveIntervall` will
    be set to `300` seconds in Debian. This defaults to `no`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BatchMode`：用于脚本中的无人值守登录。如果设置为`yes`，则不会要求输入密码或密码短语，并且在Debian中，`ServerAliveInterval`将设置为`300`秒。默认值为`no`。'
- en: '`BindAddress`: Useful in client machines which have more than one IP address
    assigned; it specifies the source address for the connection. Does not work if
    `UsePrivilegedPort` is set to `yes`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BindAddress`：在分配了多个IP地址的客户端机器中很有用；它指定连接的源地址。如果`UsePrivilegedPort`设置为`yes`，则此选项无效。'
- en: '`CanonicalDomains`: Used with `CanonicalizeHostname`; it sets a list of domain
    suffixes to search for the remote host to connect to.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanonicalDomains`：与`CanonicalizeHostname`一起使用；它设置一个域名后缀列表，用于搜索远程主机以进行连接。'
- en: '`CanonicalizeFallbackLocal`: If set to `yes`, the client will attemp to look
    up an unqualified hostname using the search rule of the client system. If set
    to `no` and `CanonicalizeHostname` is set to `yes` , it will fail immediately
    if the remote hostname cannot be found in any of the domains listed by `CanonicalDomains`.
    Defaults to `yes`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanonicalizeFallbackLocal`：如果设置为`yes`，客户端将尝试使用客户端系统的搜索规则查找不完全的主机名。如果设置为`no`，且`CanonicalizeHostname`设置为`yes`，当远程主机名无法在`CanonicalDomains`列出的任何域中找到时，将立即失败。默认为`yes`。'
- en: '`CanonicalizeHostname`: Enables the canonicalization rewriting the hostname.
    If set to `no`, the local resolver will manage the hostname lookup; if set to
    `always`, it will rewrite the unqualified hostnames using the domains listed in
    `CanonicalDomains`. The `CanonicalizePermittedCNAMEs` rules will be applied. If
    set to `yes`, the canonicalization will be performed for those connections which
    do not use a `ProxyCommand` directive.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanonicalizeHostname`：启用主机名的规范化重写。如果设置为`no`，本地解析器将管理主机名查找；如果设置为`always`，它将使用`CanonicalDomains`中列出的域名重写不完全的主机名。`CanonicalizePermittedCNAMEs`规则将会被应用。如果设置为`yes`，将对那些不使用`ProxyCommand`指令的连接执行规范化。'
- en: '`CanonicalizePermittedCNAMEs`: Lists the rules that must be followed during
    hostname canonicalization. The rules can have one of more of the following arguments:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanonicalizePermittedCNAMEs`：列出在主机名规范化过程中必须遵循的规则。这些规则可以包含以下一个或多个参数：'
- en: '`source_domains:target_domains`: The first being a list of patterns for domains
    that may follow the hostname in canonicalization; `target_domains` is a list of
    patterns of domains that the former domains may resolve to.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source_domains:target_domains`：前者是一个域名模式的列表，表示在规范化过程中可能跟随主机名的域；`target_domains`是一个域名模式的列表，表示前述域可能解析为的域。'
- en: '`CertificateFile`: Lists the file where to load the certificate file for the
    corresponding private key pointed to by the `IntentityFile` directive.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CertificateFile`：列出加载证书文件的路径，该文件对应由`IntentityFile`指令指向的私钥。'
- en: '`CheckHostIP`: Defines whether the client will check for the host IP in the
    `known_hosts` file for DNS spoofing prevention, adding the IP of the remote host
    to the `~/.ssh/known_hosts` file. Defaults to `yes`.'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CheckHostIP`：定义客户端是否在`known_hosts`文件中检查主机IP，以防止DNS欺骗，并将远程主机的IP添加到`~/.ssh/known_hosts`文件中。默认为`yes`。'
- en: '`ConnectionAttempts`: The number of connection tries per second before exiting.
    Defaults to `1`.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionAttempts`：每秒的连接尝试次数，达到指定次数后退出。默认为`1`。'
- en: '`ConnectTimeout`: Timeout in seconds for a connection try.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectTimeout`：连接尝试的超时时间，单位为秒。'
- en: '`ForwardX11`: Enables X11 redirection over the connection and sets the DISPLAY
    value. Defaults to `no`.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForwardX11`：启用通过连接的X11重定向并设置DISPLAY值。默认为`no`。'
- en: '`GatewayPorts`: Allows/denies the connection of remote hosts to local forwarded
    ports. Defaults to `no`, meaning that the local forwarded ports bind to the loopback
    device address. If set to `yes`, they are bound to the `*` address.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GatewayPorts`：允许/禁止远程主机连接到本地转发端口。默认为`no`，表示本地转发端口绑定到回环设备地址。如果设置为`yes`，它们将绑定到`*`地址。'
- en: '`GlobalKnownHostsFile`: Sets one or more file (separated by whitespaces) where
    the host keys are kept. Defaults to the default `/etc/ssh/ssh_known_hosts` and
    `/etc/ssh/ssh_known_hosts2`.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GlobalKnownHostsFile`：设置一个或多个文件（用空格分隔），用于存储主机密钥。默认为默认的`/etc/ssh/ssh_known_hosts`和`/etc/ssh/ssh_known_hosts2`。'
- en: '`HostKeyAlias`: Sets an alias to be used instead of the hostname when searching
    or saving the host key in the `hostkey` file.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostKeyAlias`：设置一个别名，在搜索或保存主机密钥到`hostkey`文件时使用，而不是主机名。'
- en: '`HostName`: Points to the real hostname of the remote host that we are going
    to log in. We can use this field to create a meaningful alias for the remote host,
    either using numeric IPS, tokens (we will see them later), or short names.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostName`：指向我们将要登录的远程主机的实际主机名。我们可以使用此字段为远程主机创建一个有意义的别名，可以使用数字IP、标记（稍后会看到）或简短的名称。'
- en: '`IdentityFile`: Defines the file the authentication identity is read from.
    Defaults to `~/.ssh/identity` for SSH-1, and `~/.ssh/id_dsa`, `~/.ssh/id_ecdsa`,
    `~/.ssh/id_ed25519` and `~/.ssh/id_rsa` for SSH-2\. If no certificates have been
    associated using the `CertificateFile` directive, SSH will try to read a file
    whose name is crafted by adding `-cert.pub` to the name listed under `IdentityFile`.
    Tokens can be used as argument; and it is possible to repeatedly use this directive
    to add more identity files to the list of the ones tried.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IdentityFile`: 定义身份认证信息读取的文件。对于SSH-1，默认为`~/.ssh/identity`，对于SSH-2，默认为`~/.ssh/id_dsa`、`~/.ssh/id_ecdsa`、`~/.ssh/id_ed25519`和`~/.ssh/id_rsa`。如果没有使用`CertificateFile`指令关联证书，SSH将尝试读取一个文件，其文件名通过在`IdentityFile`列出的名称后添加`-cert.pub`来构造。可以使用令牌作为参数；可以多次使用此指令来添加更多要尝试的身份文件。'
- en: '`Include`: Includes the configuration files listed. If a file is not pointed
    to by an absolute path, it is meant to be located under `~/.ssh` if included in
    a user configuration or under `/etc/ssh` if included in the system-wide configuration
    file. Wildcards can be used, and this directive can be listed as an argument for
    the `match` and `host` keywords for conditional includes.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Include`: 包含列出的配置文件。如果文件没有指向绝对路径，则应位于用户配置中的`~/.ssh`或系统范围配置文件中的`/etc/ssh`下。可以使用通配符，并且此指令可以作为`match`和`host`关键字的参数列出以进行条件包含。'
- en: '`LocalCommand`: We can write a command to be executed with the user shell once
    the local client has successfully connected to the remote host. It accepts the
    tokens, but it is ignored unless `PermitLocalCommand` is enabled.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalCommand`: 一旦本地客户端成功连接到远程主机，我们可以编写要在用户shell中执行的命令。接受令牌，但除非启用了`PermitLocalCommand`，否则将被忽略。'
- en: '`LocalForward`: Enables the forwarding of a TCP local port over a secure connection
    to the remote host and port. It accepts two arguments: `[local_address:]port`
    and `remote_host:port`.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalForward`: 启用本地TCP端口通过安全连接转发到远程主机和端口。接受两个参数：`[local_address:]port`和`remote_host:port`。'
- en: We can specify more than one forwarding but only a superuser can bind a local
    privileged port. The local port is bound to the address drawn from the `GatewayPorts`
    directive if not specified as an argument. If the localhost is given, the listening
    port will be accessible only from the local client machine; and an empty address
    means `*`, so the port will be accessible on all the interfaces.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定多个转发，但只有超级用户可以绑定本地特权端口。如果未指定作为参数，本地端口将绑定到从`GatewayPorts`指令获取的地址。如果给定了localhost，则只能从本地客户端机器访问监听端口；空地址表示`*`，因此端口将在所有接口上可访问。
- en: '`NumberOfPasswordPrompts`: Defines how many times a password is asked for before
    declaring the login process as failed, the argument can be an integer which defaults
    to `3`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberOfPasswordPrompts`: 定义在登录过程中询问密码的次数，在宣布登录过程失败之前。参数可以是默认为`3`的整数。'
- en: '`Port`: This is the port on the remote server that the client will try to connect
    to. Defaults to `22`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Port`: 这是客户端将尝试连接的远程服务器上的端口。默认为`22`。'
- en: '`PreferredAuthentications`: Defines the order in which the client will try
    different authentication methods. Defaults to `gssapi-with-mic`,`hostbased`,`publickey`,
    `keyboard-interactive`, and `password`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreferredAuthentications`: 定义客户端尝试不同身份验证方法的顺序。默认为`gssapi-with-mic`、`hostbased`、`publickey`、`keyboard-interactive`和`password`。'
- en: '`Protocol`: Defines the protocol supported by the client in order of preference.
    If more than one is listed, they must be separated by a command. If a preferred
    protocol fails, the next in the list will be tried. Defaults to `2`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protocol`: 定义客户端按优先顺序支持的协议。如果列出了多个，则必须用逗号分隔。如果首选协议失败，将尝试列表中的下一个。默认为`2`。'
- en: '`ProxyCommand`: Defines the command used to connect to the remote server; and
    it is executed with the exec directive of the user''s shell. Really useful used
    with `netcat` to proxy connections. Accepts tokens.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProxyCommand`: 定义用于连接远程服务器的命令；使用用户shell的exec指令执行。与`netcat`一起使用时非常有用来代理连接。接受令牌。'
- en: '`RemoteForward`: Enables the forwarding of a TCP port on the remote host on
    a secure connection to a port on the local machine. It accepts two arguments: `[local_address:]port`
    and `remote_host:port`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteForward`: 启用远程主机上TCP端口的转发，通过安全连接到本地计算机上的端口。接受两个参数：`[local_address:]port`和`remote_host:port`。'
- en: We can specify more than one forwarding by only logging as a superuser on the
    remote host lets us bind a remote privileged port. If this is not specified, `local_address`
    is bound to the loop-back device. And if no remote host is specified, or `*` is
    used, then the forwarded port will be accessible on all interfaces on the remote
    host. To specify a remote address, we must enable the directive `GatewayPorts`
    in `sshd_config`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过仅以超级用户身份登录远程主机来指定多个转发，这允许我们绑定远程特权端口。如果没有指定，`local_address` 将绑定到回环设备。如果未指定远程主机，或使用
    `*`，则转发端口将在远程主机的所有接口上都能访问。要指定远程地址，必须在 `sshd_config` 中启用 `GatewayPorts` 指令。
- en: '`ServerAliveCountMax`: Defines the maximum number of server alive messages
    without receiving a reply from the remote host. Once the threshold is hit, the
    session is disconnected. These kinds of messages are way different from the `TCPKeepAlive`
    messages: the first one is sent over the encrypted channel, and so is not spoofable,
    while the second is in clear and can be spoofed. Defaults to `3`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerAliveCountMax`：定义在未收到远程主机回复的情况下，最大服务器存活消息的数量。一旦达到该阈值，会话将断开。此类消息与 `TCPKeepAlive`
    消息大不相同：前者通过加密通道发送，因此无法伪造，而后者是明文的，可以伪造。默认为 `3`。'
- en: '`ServerAliveInterval`: Defines a timeout in seconds, after which the client
    will send a message through the secure channel. Defines a timeout in seconds after
    which if no data have been received the client will send a message to the server
     through the secure channel requesting a response. Defaults to `0`, meaning that
    no messages will ever be sent.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerAliveInterval`：定义一个超时值（以秒为单位），超过该时间后，客户端将通过安全通道发送一条消息。如果在指定的时间内未接收到数据，客户端将通过安全通道向服务器发送请求响应的消息。默认为
    `0`，表示永不发送消息。'
- en: '`StrictHostKeyChecking`: If this is set to `yes`, two things will happen:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StrictHostKeyChecking`：如果设置为 `yes`，将发生两件事：'
- en: The client will never automatically add a host key to the `~/.ssh/known_hosts`
    file.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端将永远不会自动将主机密钥添加到 `~/.ssh/known_hosts` 文件中。
- en: The client will refuse to connect to a remote host whose key has changed from
    the one stored in the `known_hosts` file.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端将拒绝连接到远程主机，其密钥与存储在 `known_hosts` 文件中的密钥不同。
- en: If this is set to `yes`, the client will automatically add the new keys while
    if set to ask, which is the default value the client will ask the user to confirm
    the addition of the key to the `known_hosts` file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置为 `yes`，客户端将自动添加新密钥；如果设置为 `ask`，即默认值，客户端将提示用户确认是否将密钥添加到 `known_hosts` 文件。
- en: '`TCPKeepAlive`: Enables/disables the keepalive messages sent by the client
    to the remote host. Defaults to `yes` ; and this will allow the client to detect
    network disconnections or remote host crashing. It is largely used in scripts
    for unattended disconnection detection.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TCPKeepAlive`：启用/禁用客户端发送到远程主机的保持活动消息。默认为 `yes`；这将允许客户端检测到网络断开或远程主机崩溃的情况。它在脚本中广泛用于无人值守的断开连接检测。'
- en: '`Tunnel`: Enables forwarding between the client and the remote host for the
    tun device. Arguments can be `yes`, `point-to-point`, `ethernet` , or `no`. Defaults
    to `yes` , which enables the default point-to-point mode.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tunnel`：启用客户端与远程主机之间的转发，以供 tun 设备使用。参数可以是 `yes`、`point-to-point`、`ethernet`
    或 `no`。默认为 `yes`，即启用默认的点对点模式。'
- en: '`TunnelDevice`: Defines which tun devices to open both for the client and the
    remote host. The argument is specified as `client_tun:[host_tun]`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TunnelDevice`：定义要为客户端和远程主机打开的 tun 设备。参数指定为 `client_tun:[host_tun]`。'
- en: Devices can be addressed by their numerical ID or using `any` , which will force
    the usage of the next available tun device. If no `host_tun` is defined, it defaults
    to `any`. The default is `any:any`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 设备可以通过其数字 ID 或使用 `any` 来进行寻址，这将强制使用下一个可用的 tun 设备。如果未定义 `host_tun`，则默认为 `any`。默认值为
    `any:any`。
- en: '`UsePrivilegedPort`: Enables/disables the usage of a privileged port of the
    outgoing connection. If it is set to `yes`, ssh must be `setuid root` since this
    is the only user who is able to use privileged ports. Defaults to `no`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsePrivilegedPort`：启用/禁用出站连接的特权端口使用。如果设置为 `yes`，则 ssh 必须是 `setuid root`，因为只有该用户可以使用特权端口。默认为
    `no`。'
- en: '`User`: Specifies the username of the remote account to log in.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`：指定用于登录的远程帐户的用户名。'
- en: '`UserKnownHostsFile`: Defines one or more files for the user''s `host_key`
    database. If more than one file is specified, it must be separated by a whitespace.
    Defaults to `~/.ssh/known_hosts`, `~/.ssh/known_hosts2`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserKnownHostsFile`：定义一个或多个用户的 `host_key` 数据库文件。如果指定了多个文件，它们必须用空格分开。默认值为 `~/.ssh/known_hosts`
    和 `~/.ssh/known_hosts2`。'
- en: '`TOKENS`: We referred to them in some of the configuration directives, and
    these are special character combinations that can be expanded during the SSH session:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TOKENS`：我们在一些配置指令中提到过它们，它们是可以在 SSH 会话中展开的特殊字符组合：'
- en: '`%%`: This is expanded to a literal `%`'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%%`：展开为字面量 `%`。'
- en: '`%C`: Short for `%l%h%p%r`'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%C`：是 `%l%h%p%r` 的缩写。'
- en: '`%d`: Expands to the home directory of the user on the client side'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%d`：展开为客户端用户的主目录。'
- en: '`%h`: This is the hostname of the remote host'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%h`：远程主机的主机名。'
- en: '`%i`: Expands to the local user ID'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%i`：展开为本地用户 ID。'
- en: '`%L`: Hostname of the client'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%L`：客户端的主机名。'
- en: '`%l`: Hostname of the client, domain included, including the domain name'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%l`：客户端的主机名，包括域名。'
- en: '`%n`: Original hostname of the remote host as given on the command line'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%n`：命令行中给出的远程主机的原始主机名。'
- en: '`%p`: Port on the remote host'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%p`：远程主机的端口。'
- en: '`%r`: Username on the remote host'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%r`：远程主机的用户名。'
- en: '`%u`: Username on the client side'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%u`：客户端的用户名。'
- en: 'These tokens are accepted in a different extent as arguments to different configuration
    directives:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些令牌在作为不同配置指令的参数时接受不同的扩展：
- en: '`Match exec` makes use of `%%`, `%h`, `%L`, `%l`, `%n`, `%p`, `%r`, `%u`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Match exec` 使用 `%%`、`%h`、`%L`、`%l`、`%n`、`%p`、`%r`、`%u`。'
- en: '`CertificateFile` makes use of `%%`, `%d`, `%h`, `%l`, `%r`, and `%u`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CertificateFile` 使用 `%%`、`%d`、`%h`、`%l`、`%r` 和 `%u`。'
- en: '`ControlPath` makes use of `%%`, `%C`, `%h`, `%i`, `%L`, `%l`, `%n`, `%p`,
    `%r`, `%u`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlPath` 使用 `%%`、`%C`、`%h`、`%i`、`%L`、`%l`、`%n`、`%p`、`%r`、`%u`。'
- en: '`HostName` makes use of `%%` and `%h`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostName` 使用 `%%` 和 `%h`。'
- en: '`IdentityAgent` and `IdentityFile` make use of `%%`, `%d`, `%h`, `%l`, `%r`,
    `%u`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IdentityAgent` 和 `IdentityFile` 使用 `%%`、`%d`、`%h`、`%l`、`%r`、`%u`。'
- en: '`LocalCommand` makes use of `%%`, `%C`, `%d`, `%h`, `%l`, `%n`, `%p`, `%r`,
    `%u`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalCommand` 使用 `%%`、`%C`、`%d`、`%h`、`%l`、`%n`、`%p`、`%r`、`%u`。'
- en: '`ProxyCommand` makes use of `%%`, `%h`, `%p`, and `%r`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProxyCommand` 使用 `%%`、`%h`、`%p` 和 `%r`。'
- en: Some of the directives that we listed for `sshd_config` , which were also available
    on the `ssh_config` file, were omitted for brevity's sake. We tried to be as tidy
    as possible before going to the next paragraph, where you will learn how to create
    passwordless connections using some of the directives that we just examined so
    far.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列出的某些指令在 `sshd_config` 中，而在 `ssh_config` 文件中也可用，为了简洁起见，这些指令被省略了。我们在进入下一段之前尽量整理得尽可能简洁，在下一段中你将学习如何使用我们刚才检查过的一些指令来创建无密码连接。
- en: Passwordless connections
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无密码连接
- en: '[PRE3]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What do we need to set up such a nice connection method? We have  a few actors
    in place: we have to check the server setup, generate some keys, and configure
    the client.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置哪些内容来实现这种便捷的连接方法？我们有几个角色需要配置：我们必须检查服务器设置、生成一些密钥，并配置客户端。
- en: Configuring the server
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器
- en: 'Let''s start from the server opening the `/etc/ssh/ssd_config`  file and checking
    the following configuration directives:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器开始，打开 `/etc/ssh/ssd_config` 文件，检查以下配置指令：
- en: '[PRE4]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s start with the port. The standard port for the SSH service is `22` ,
    and it is at this value that most of the script kiddies around will probe your
    SSH daemon with some automated tools; so if you have a server publicly available,
    change the value to an unprivileged port such as `9527` . Thus, a lot of these
    attacks will simply be ineffective:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从端口开始。SSH 服务的标准端口是 `22`，这是大多数脚本小子会使用自动化工具来扫描你的 SSH 守护进程的端口；因此，如果你的服务器是公开可用的，建议将端口更改为非特权端口，例如
    `9527`。这样，很多这些攻击将变得无效：
- en: '[PRE5]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we need to bind the service to a specific address on our server, this is
    the directive we need to work on; we simply uncomment and fill in the appropriate
    value:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将服务绑定到服务器上的特定地址，这是我们需要操作的指令；我们只需取消注释并填写合适的值：
- en: '[PRE6]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We do not think to use version 1 of the protocol, not even as a second choice.
    We stay safe and go along protocol version 2:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算使用协议版本 1，甚至不作为第二选择。我们保持安全，使用协议版本 2：
- en: '[PRE7]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ever wondered where the system-wide host keys are? Here, they are, and we can
    also decide to change names and path if we need to.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经想过系统范围的主机密钥在哪里吗？这里就是它们的位置，我们还可以根据需要决定更改名称和路径。
- en: '[PRE8]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Definitely! We want to work with unprivileged processes so that no super user
    privileges can be exploited.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对的！我们希望与非特权进程一起工作，以避免任何超级用户权限被滥用。
- en: '[PRE9]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Just give us some time to log in.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们一些时间来登录。
- en: '[PRE10]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One safe practice is to limit the log in to the root account on a remote host
    to key-based authentication. This way, an intruder will not able to break in by
    just guessing a password; he will need the client's secret key to enter, and the
    key is safely stored on our client, not on the server. Anyway, if we want to remotely
    set up a passwordless authentication for the root account, we must allow root
    logins with passwords. Once we are sure everything works, we will restrict without-password.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全的做法是将远程主机的root账户登录限制为基于密钥的认证。这样，入侵者就无法仅凭猜测密码突破进入；他需要客户端的私钥才能进入，而该密钥是安全存储在客户端，而不是服务器上。无论如何，如果我们想要为root账户设置无密码认证的远程登录，我们必须允许root账户使用密码登录。一旦确保一切正常，我们会限制不使用密码的登录。
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is so easy to forget some world-writable permission on the home directory
    or on our ssh configuration files and keys, so better to enable this directive;
    and it will prevent us to log in if the home directory of the remote user we log
    in has some unsafe permissions set.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记在主目录或SSH配置文件和密钥上设置世界可写权限，所以最好启用这个指令；它会防止我们在远程用户的主目录权限设置不安全时登录。
- en: '[PRE12]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Well, we are working on that so better to be sure this is set to `yes`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们正在处理这个问题，因此最好确保这个设置为`yes`。
- en: '[PRE13]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's note down where our public key must be stored. The token tells us they
    are in the `.ssh` directory inside the home of the accounts the file `authorized_keys`
    is in the home directory of the account we used to login into the system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记下公共密钥必须存储的位置。令牌告诉我们它们位于`.ssh`目录中，该目录位于存放`authorized_keys`文件的账户的主目录下。
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Just for safety, let''s ditch the host authentication:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全考虑，让我们丢弃主机身份验证：
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's check this. We must never switch this to yes unless we want logins without
    passwords. But who would want this?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下。除非我们希望无密码登录，否则绝不应将其切换为`yes`。但谁会想要这样呢？
- en: '[PRE16]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are a few reasons why we would like to set this to `yes`. One is that,
    with this on, the SSH daemon cannot be run as root; and this is a safe option.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将其设置为`yes`有几个原因。其中一个原因是，启用此选项后，SSH守护进程不能以root身份运行；这是一个安全的选项。
- en: 'Once we have the config bits in place, let''s check that we also have the host
    keys that we need to proof the server identity to the client. As we can read from
    the configuration file, on the remote host, we should have a key for each algorithm
    supported in `/etc/ssh`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置好相关项，我们来检查是否也拥有需要的主机密钥，以便向客户端证明服务器身份。根据配置文件的内容，在远程主机上，我们应该有每个支持的算法对应的密钥，存放在`/etc/ssh`目录中：
- en: '[PRE17]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There they are! So, we are fine. They usually get created when we install the
    OpenSSH server from our distribution packages, but we can also decide to create
    our very own host key. Let''s see how. First, let''s have a look at the fingerprint
    of one of the keys:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它们！所以我们没问题。它们通常在我们从发行版包安装OpenSSH服务器时创建，但我们也可以选择创建我们自己的主机密钥。让我们看看如何做。首先，我们来看看其中一个密钥的指纹：
- en: '[PRE18]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We used ssh-keygen, a utility which does a lot of things, from creating a key
    to modifying it or, as in this case, having a look at it. The first field of the
    resulting sting tells us the bit length of the key, the second sports the actual
    key, the third points to the file holding this key, and finally comes the encryption
    method.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`ssh-keygen`，这是一种做很多事情的工具，从创建密钥到修改它，或者像本例中那样查看它。结果字符串的第一个字段告诉我们密钥的位长，第二个字段显示实际的密钥，第三个字段指向保存该密钥的文件，最后是加密方法。
- en: '![](img/00045.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: Using the -lv options will give you a nice ASCII fingerprint of the key
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用-lv选项将为你提供密钥的ASCII指纹
- en: 'But let''s say we do not trust the existing keys, and we want to create a new
    pair set of them:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们不信任现有的密钥，我们想要创建一对新的密钥：
- en: '[PRE19]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Is this easy? Yes, it is:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这容易吗？是的，很容易：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here are the new key files; let''s check the same key again:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的密钥文件；让我们再检查一下相同的密钥：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The two keys are different:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个密钥是不同的：
- en: '[PRE22]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We took advantage of the `-A` option of ssh-keygen, which automatically creates
    a missing key for each type (`rsa1`, `rsa`, `dsa`, `ecdsa`, and `ed25519`). The
    keys are created with the default bit size, with no password, and with the default
    comments. Now, let''s say again that we want to create our very own `ecdsa` host
    key pair:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用了`ssh-keygen`的`-A`选项，它会自动为每种类型（`rsa1`、`rsa`、`dsa`、`ecdsa`和`ed25519`）创建缺失的密钥。密钥会以默认位大小创建，不带密码，并且带有默认注释。现在，再次假设我们想要创建我们自己的`ecdsa`主机密钥对：
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](img/00046.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: Our new ecdsa host key has been created
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新ECDSA主机密钥已经创建
- en: 'We created our new host key using some simple options:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一些简单的选项创建了新的主机密钥：
- en: '`-t`: This selects the type of the `keyboard-interactive`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`：此选项用于选择 `keyboard-interactive` 的类型。'
- en: '`-a`: This option can be selected when saving a key in the ed25519 format or
    with any SSH-2 key when the `-o` option is selected. It specifies the number of
    **Key Derivation Function** (**KDF**) rounds to use to encrypt the private password.
    It makes the passphrase check slower and more resistant to a brute force attack.
    The higher the integer, the slower the check. It defaults to `64` , which is really
    good; we just got insane with `1000`.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`：当将密钥保存为 ed25519 格式，或在选择 `-o` 选项时保存任何 SSH-2 密钥时，可以选择此选项。它指定用于加密私钥密码的 **密钥衍生函数**（**KDF**）轮数。它使密码短语检查变得更慢，并且对暴力破解攻击更具抵抗力。整数越高，检查越慢。默认为
    `64`，这个设置已经很好了；我们将其设为 `1000` 以获得更高的安全性。'
- en: '`-b`: Bit length of the key. Ecdsa can have a size of 256, 384, or 521 bit.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`：密钥的比特长度。Ecdsa 可以有 256、384 或 521 位的大小。'
- en: '`-C`: Is a comment you can associate to the key.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-C`：是您可以与密钥关联的注释。'
- en: '`-f`: Is the path to the file that will hold the new key.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：是将保存新密钥的文件路径。'
- en: '`-o`: Saves the SSH-2 private key in the new OpenSSH format rather than the
    usual PEM format. The new format is more resistant to brute force attack, but
    it is not supported by OpenSSH versions lower than 6.5\. The ed25519 keys are
    always saved in the new format, so they do not require this option on the command
    line.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o`：将 SSH-2 私钥保存为新的 OpenSSH 格式，而不是通常的 PEM 格式。新格式对暴力破解攻击更具抵抗力，但不支持低于 6.5 版本的
    OpenSSH。ed25519 密钥总是以新格式保存，因此它们不需要在命令行中使用此选项。'
- en: 'Now, it is time to make the new key available to the server by adding it to
    the main sshd configuration file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候通过将新密钥添加到主 sshd 配置文件中，让新密钥对服务器可用：
- en: '[PRE24]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s restrict the permissions on the keys:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们限制密钥的权限：
- en: '[PRE25]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, no one other than root will be able to access the keys and configuration
    files:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，除了 root 之外，其他任何人都无法访问密钥和配置文件：
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We notice two things:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到两点：
- en: We created a private key whose name does not end with `_key`. We did this on
    purpose to differentiate it from the prebuilt keys. The `key` filename can be
    whatever we want, but better give it a meaningful value.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个私钥，其名称未以 `_key` 结尾。我们故意这么做，是为了将其与预先构建的密钥区分开来。`key` 文件名可以是任何我们想要的内容，但最好给它一个有意义的值。
- en: '`ssh-keygen` automatically added a trailing `.pub` to the private key file
    name and used the resulting name for the public key filename.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh-keygen` 自动将 `.pub` 后缀添加到私钥文件名，并使用生成的名称作为公钥文件名。'
- en: 'Safe permissions for ssh keys are:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 密钥的安全权限是：
- en: '`700` for the `.ssh` directory, and'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`700` 对于 `.ssh` 目录，以及'
- en: '`600` for the key files inside the `.ssh` directory.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`600` 对于 `.ssh` 目录中的密钥文件。'
- en: 'Now, let''s reload or restart the service to get the new key available for
    the SSH daemon:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新加载或重启服务，以便新的密钥可以供 SSH 守护进程使用：
- en: '[PRE27]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Wow, it is working, let''s see the logs:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，它工作了，让我们看看日志：
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are almost there. The daemon successfully started but refused to load the
    host key. What happened? Simply, we gave a passphrase during the key creation;
    and  to load the key, a passphrase must be given but the daemon cannot interact
    and fill it in. We must remove the passphrase:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们差不多完成了。守护进程成功启动，但拒绝加载主机密钥。发生了什么？简单来说，我们在创建密钥时给定了一个密码短语；为了加载密钥，必须提供密码短语，但守护进程无法与之交互并填写它。我们必须删除密码短语：
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The program will ask for the old password, and when it comes to fill in a new
    one, let''s just hit the *Enter* key twice so that no password will be added to
    the private key. Now, let''s restart and check:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会要求输入旧密码，当需要填写新密码时，我们只需按两次 *Enter* 键，这样就不会为私钥添加密码。现在，让我们重启并检查：
- en: '`root:# systemctl restart ssh ; systemctl status ssh ; tail -n3 /var/log/syslog`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`root:# systemctl restart ssh ; systemctl status ssh ; tail -n3 /var/log/syslog`'
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, it is really fine, the key has been loaded.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切正常，密钥已经加载。
- en: Preparing the remote account
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备远程账户
- en: 'Let''s use a scenario where we will create a completely new user; whatever
    we will do here will be applicable to a preexisting user. First, let''s create
    our new user test user on the remote host, and let''s configure it so that it
    will be available through key authentication only:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要创建一个全新的用户，接下来的操作同样适用于预先存在的用户。首先，我们在远程主机上创建一个新的用户 `test_user`，并将其配置为仅通过密钥认证进行访问：
- en: '[PRE31]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So, we just created the `test_user` account and provided it with a `home` directory:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们刚创建了 `test_user` 账户，并为其提供了一个 `home` 目录：
- en: '[PRE32]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that there is no `.ssh` at the moment. Now, since we do want this account
    to be accessible only using a key, let''s lock it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前还没有`.ssh`。现在，由于我们希望此账户仅能通过密钥访问，因此让我们将其锁定：
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `-l` option in `passwd` locks the account using a nice trick. When we create
    an account, `passwd` asks for it; and then it encrypts the password and writes
    it into the `/etc/shadow` file, as we can see in a `shadow` file before locking:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`passwd`中的`-l`选项使用一个巧妙的技巧来锁定账户。当我们创建账户时，`passwd`会要求输入密码；然后它会加密密码并将其写入`/etc/shadow`文件，如我们在锁定前看到的`shadow`文件：'
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The fields of the `shadow` file can be interpreted as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`shadow`文件的各个字段可以按如下方式解释：'
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will not go into the details of each field, a simple *man shadow* will give
    us all the information we need. What really matters is the second field holding
    the encrypted password. When a user tries to log in, the password they provide
    is encrypted and checked against the second field of the `/etc/shadow` file: if
    they match, the password is correct; if not, then the password is not correct
    and the user log in is refused. Have a look at the same string after the account
    has been locked:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算详细解释每个字段，一个简单的*man shadow*就能提供我们需要的所有信息。真正重要的是第二个字段，它保存着加密的密码。当用户尝试登录时，他们提供的密码会被加密，并与`/etc/shadow`文件的第二个字段进行比对：如果匹配，则密码正确；如果不匹配，则密码错误，用户登录被拒绝。看看账户锁定后的同一行：
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There is something new: the password field has `!` at the beginning, actually
    changing its value. And here is the trick: a character such as `!` or `*` can
    never be a result of the `crypt(3)` function used by `passwd` to encrypt the user
    password, so adding an exclamation mark makes the value unmatchable. Whatever
    value the user fills in, `passwd` will never be able to generate an exclamation
    mark; so, practically, the account is locked.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有新变化：密码字段前面加了`!`，实际上改变了其值。这里的技巧是：像`!`或`*`这样的字符永远不会是`passwd`使用`crypt(3)`函数加密用户密码的结果，因此添加感叹号使得该值无法匹配。无论用户输入什么值，`passwd`都无法生成感叹号；因此，实际上账户被锁定。
- en: 'Just for the setup, let''s enable the account again with a temporary password:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为设置 purposes，让我们用临时密码再次启用该账户：
- en: '[PRE37]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We need to log in with a password to copy over our client public identity key.
    Once done, we will lock the account again.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用密码登录才能复制我们的客户端公钥。完成后，我们将再次锁定该账户。
- en: So, now we have a username we can use and a port: `9999`. We can jump back to
    the client and create our configuration.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以使用的用户名和端口：`9999`。我们可以返回客户端并创建我们的配置。
- en: Configuring the client
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置客户端
- en: Back to our client; let's enter the `home` directory of the user we want to
    set up the connection for. Let's say that `local_user` wants to connect as `test_user`
    on the remote host called **spoton**.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 回到客户端；让我们进入我们想要为其设置连接的用户的`home`目录。假设`local_user`希望作为`test_user`连接到名为**spoton**的远程主机。
- en: 'Let''s go to the `local_user` home directory, `local_user:~$ cd /home/local_user`, and
    have a look at what is inside it:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入`local_user`的主目录，`local_user:~$ cd /home/local_user`，并查看其中的内容：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Well, the usual file for a new account, but there is a problem:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新账户的常见文件，但存在一个问题：
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have no identity file set, so we need to uncomment one of those lines; and
    if we want, we can also change the file name. For now, we will just add this line
    to the `ssh_config` file:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有设置身份文件，因此需要取消注释其中一行；如果需要，我们也可以更改文件名。暂时，我们将这行添加到`ssh_config`文件中：
- en: '[PRE40]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We just modified the file name to make it clear that it will be used for the
    remote host named spoton. We could have different identity files for connecting
    to more than one remote server or as different users to the same server. So, it
    is better to find a meaningful name for the key file, one that will remind us
    what it is used for. Now that we have a reference in the client config file, we
    must create the `.ssh` directory:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是修改了文件名，以便明确它将用于名为spoton的远程主机。我们可以为连接多个远程服务器或作为不同用户连接同一服务器使用不同的身份文件。因此，最好为密钥文件找到一个有意义的名称，这样可以提醒我们它的用途。现在，我们在客户端配置文件中已有了参考，接下来我们必须创建`.ssh`目录：
- en: '[PRE41]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Set the right access permissions:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正确的访问权限：
- en: '[PRE42]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s enter the `.ssh` directory and create our key; to keep things easy,
    we will not force a password on the private key:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入`.ssh`目录并创建我们的密钥；为了简化操作，我们不会对私钥强制设置密码：
- en: '[PRE43]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We used a smaller key size of 384, since at 512, we can face some issues and
    the key can be refused with a message like this from the client when invoking
    it with the `-vvv` option:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了更小的密钥大小384，因为在512时，我们可能会遇到一些问题，当客户端使用`-vvv`选项调用时，密钥可能会被拒绝，并显示类似这样的消息：
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we have a key pair, one public, and one private:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一对密钥，一个公钥，一个私钥：
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The access rights are not good for the pub key, so better fix it to a safer
    `600`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥的访问权限设置不正确，所以最好将其修复为更安全的`600`：
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, as we already know, the private key must be kept safe on the client; but
    we must copy the public key over the remote host, and add it to `~/.ssh/authorized_keys` of `test_user`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，私钥必须在客户端上安全存储；但是我们必须将公钥复制到远程主机，并将其添加到`test_user`的`~/.ssh/authorized_keys`中。
- en: We have actually two ways to do it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们有两种方法来做这件事。
- en: Manually, copy the public key over to the remote server; copy it into the authorized_keys
    file and fix the access rights. Or, you can use the `ssh-copy-id` utility.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 手动操作，将公钥复制到远程服务器；将其复制到`authorized_keys`文件中并修复访问权限。或者，你可以使用`ssh-copy-id`工具。
- en: 'Let''s use this second method:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用第二种方法：
- en: '[PRE47]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now try logging in to the machine:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试登录到机器：
- en: '[PRE48]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Check to make sure that only the key(s) you wanted were added.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 检查确保只有你想要的密钥被添加。
- en: 'Everything seems fine, so let''s connect to the remote system as `test_user`
    using the password we set. Check that in the home directory inside the `.ssh`
    subdirectory, there is an `authorized_keys` file with our public key inside:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都正常，所以让我们使用设置的密码，以`test_user`身份连接到远程系统。在主目录下的`.ssh`子目录中检查，是否有一个`authorized_keys`文件，并且其中包含我们的公钥：
- en: '[PRE49]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The file is actually there with the correct access settings. Let''s have a
    look inside it:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 文件实际上已经存在，并且有正确的访问设置。我们来看看里面的内容：
- en: '[PRE50]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It looks like the right key; let''s log out and have a look at the `local_user`
    public identity key:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是正确的密钥；我们注销并查看`local_user`的公钥身份：
- en: '[PRE51]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'So, we just have to try the connection to the remote host using the identity
    file we created; but first, we have to make sure we allowed the port called `9999`
    on the remote host. Once we are sure that nothing is in between, we can just issue
    on the client side:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们只需尝试使用我们创建的身份文件连接到远程主机；但首先，我们需要确保已经在远程主机上允许了`9999`端口。一旦确认没有任何中断，我们就可以在客户端侧执行：
- en: '[PRE52]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'That''s it! We just logged in without any passwords, but this is still cumbersome.
    You have to point to the identity file and remember the port and the address.
    Not really handy, but we can improve our experience by taking advantage of the
    local configuration file that the client expects inside the `.ssh` directory of
    the local account. So, inside `/home/local_user/.ssh`, let''s create a file called `config`
    and write the following directives:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们刚刚无需任何密码登录，但这仍然不够方便。你仍然需要指定身份文件，并记住端口和地址。这样不太方便，但我们可以通过利用客户端在本地账户`.ssh`目录中期望的本地配置文件来改善我们的体验。所以，在`/home/local_user/.ssh`中，让我们创建一个名为`config`的文件，并写入以下指令：
- en: '[PRE53]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We have two sections, one of which applies to any host and one more specific
    for the host -spoton. Any time we want to add another host, we just have to copy
    and paste the host specific section, change the `Host`, `HostKeyAlias`, `Hostname`,
    `IdentityFile`, `User`, and, if needed, `Port` and that is all. The config file
    will grow with specific sections and our connections will be simply as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个部分，其中一个适用于任何主机，另一个则更具体地适用于主机-spoton。每当我们想要添加另一个主机时，只需复制并粘贴主机特定的部分，修改`Host`、`HostKeyAlias`、`Hostname`、`IdentityFile`、`User`，如果需要，还可以修改`Port`，就这样。配置文件将随着特定部分的增加而扩展，我们的连接将简单如下：
- en: '[PRE54]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'That''s all, it is just matter to invoke SSH with the alias specified in `Host`
    and we connect, no passwords, ports, addresses, or identity files were requested.
    Last bit, let''s lock the remote user:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，关键是通过在`Host`中指定的别名调用SSH，我们就能连接，不需要密码、端口、地址或身份文件。最后一点，让我们锁定远程用户：
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let''s check the account status:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查账户状态：
- en: '[PRE56]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `L` shows us that the account is locked. So, we can go back to the client
    and try to connect again:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`L`表示账户已被锁定。因此，我们可以返回客户端再次尝试连接：'
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here we are. The remote `test_user` account is locked, no one can use it locally
    or from a remote connection using a password. No one except the one who has the
    right private key; in this case, on our client called `local_user` .
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。远程`test_user`账户已被锁定，任何人都无法使用密码本地登录或通过远程连接登录。除非是拥有正确私钥的人；在这种情况下，我们的客户端名为`local_user`。
- en: We can play so many tricks with ssh that you could write an entire book on it,
    but we will limit our fun to a couple of nice functions offered by this tool.
    Proxying and tunneling we will see in the next paragraph.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用ssh玩很多花样，甚至可以写一本书，但我们将把乐趣限制在这个工具提供的几个有趣功能上。代理和隧道功能将在下一个段落中介绍。
- en: Proxies and tunnels
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理和隧道
- en: 'Let''s say we need a quick way to exit our network bypassing the firewall settings.
    Our machine cannot make any HTTP/HTTPS connection, but we can reach another remote
    host, which has a free access to the Internet. So, let''s see a practical example.
    First, let''s use `curl` to grab a remote page:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一种快速的方式绕过防火墙设置退出我们的网络。我们的机器无法进行任何HTTP/HTTPS连接，但我们可以访问另一台远程主机，它可以自由访问互联网。那么，来看一个实际的例子。首先，我们使用`curl`抓取一个远程页面：
- en: '[PRE58]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We just grabbed the [www.packtpub.com](https://www.packtpub.com/) home page;
    nice, isn''t it? Now, just for fun, root let''s use a simple firewall such as `ufw`
    to block any outgoing connection to port `80`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚抓取了[www.packtpub.com](https://www.packtpub.com/)的主页；不错吧？现在，为了好玩，root我们使用一个简单的防火墙`ufw`来阻止任何指向端口`80`的外发连接：
- en: '[PRE59]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let''s try to run the `curl` command once again; it will hang, since we
    denied any outgoing connections to any IP on port `80`. But now let''s give the
    following command:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次尝试运行`curl`命令；它将挂起，因为我们已阻止任何指向端口`80`的外发连接。但现在，让我们输入以下命令：
- en: '[PRE60]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Warning:** Permanently added `spoton,[192.168.0.5]:9999 (ECDSA)` to the list
    of known hosts.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：** 已永久将`spoton,[192.168.0.5]:9999 (ECDSA)`添加到已知主机列表中。'
- en: 'And then:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '[PRE61]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We omitted the rest of the HTML code, but it is the same as for the previous
    `curl` command, since we grabbed the same page. What happened? We invoked ssh
    with some options:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了其余的HTML代码，但它与之前的`curl`命令相同，因为我们抓取了相同的页面。发生了什么？我们使用了一些选项来调用ssh：
- en: '`-f`: This forces ssh to the background just before the command execution.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：这会在命令执行之前强制将ssh放到后台。'
- en: '`-N`: This prevents ssh from executing any command on the remote host, since
    we are just proxying.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-N`：这可以防止ssh在远程主机上执行任何命令，因为我们只是进行代理。'
- en: '`-D`: Followed by `[local_address]:port`, defines a local dynamic port forwarding
    and allocates a socket to listen for requests. When a connection is made to this
    port, this is forwarded over the secure connection to the remote host, while the
    application protocol is used to understand where to connect to from the remote
    machine. So, SSH will perform as a SOCKS server supporting the SOCKS4 and SOCKS5
    protocols. If used frequently, port forwarding can be set into the account `ssh
    config` file. Just notice that only a superuser can forward a privileged port.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-D`：后跟`[local_address]:port`，定义一个本地动态端口转发，并分配一个套接字监听请求。当连接到此端口时，它会通过安全连接转发到远程主机，同时应用协议将用于判断从远程机器连接到哪里。因此，SSH将作为一个支持SOCKS4和SOCKS5协议的SOCKS服务器。如果经常使用，端口转发可以设置到账户的`ssh
    config`文件中。只需注意，只有超级用户才能转发特权端口。'
- en: 'We then used `spoton` as the destination, since we have a config snippet saved
    for it so we do not need to specify addresses or password. But if we had no config,
    we would have written this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将`spoton`作为目标，因为我们已经保存了相应的配置片段，所以不需要指定地址或密码。但如果没有配置，我们将会写成这样：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Fill in the user password when asked for. Once we have our SOCKS proxy on, we
    can then configure any applications such as curl, Chrome, and Firefox to make
    use of it.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统提示时，输入用户密码。一旦我们的SOCKS代理启动，我们就可以配置任何应用程序，例如curl、Chrome和Firefox，来使用它。
- en: We do not like a SOCKS proxy? So, why not simply tunnel everything into a secure
    connection?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 不喜欢SOCKS代理？那么，为什么不直接将所有流量隧道化到一个安全连接中呢？
- en: '[PRE63]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now let''s make a call:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们发起一个调用：
- en: '[PRE64]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: What is interesting here is the `-L` option, which forces the connections to
    the given TCP port (`8888`) to be forwarded over the encrypted channel to the
    remote host (`spoton`); and port (`9999`) or Unix socket, which then connects
    to the final host (`www.anomali.com`) on the port designated (`443`). As for the
    proxy, if we use this feature frequently, we can set it up into the account ssh
    config file, while we can optionally specify a local address to bind the local
    port (in brackets if IPv6). The spoton can be replaced by the remote account name
    at the remote address and port, as shown in the previous example. Notice that
    we used a redirection on HTTP, but this is a tunnel, so we can use whatever protocol
    we want, not just HTTP.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是`-L`选项，它强制将连接到指定的 TCP 端口（`8888`）的数据通过加密通道转发到远程主机（`spoton`）；然后是端口（`9999`）或
    Unix 套接字，接着连接到最终主机（`www.anomali.com`）上指定的端口（`443`）。至于代理，如果我们频繁使用此功能，可以将其设置到账户的
    SSH 配置文件中，另外我们可以选择指定一个本地地址来绑定本地端口（如果是 IPv6，则使用括号）。`spoton`可以替换为远程地址和端口上的远程账户名，如前面的示例所示。注意，我们在
    HTTP 上使用了重定向，但这实际上是一个隧道，因此我们可以使用任何协议，而不仅仅是 HTTP。
- en: 'But we can do even something fancier: we can let someone access a remote host
    through us. So, on the local machine, we just give the following command:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以做得更高级：我们可以让别人通过我们访问远程主机。所以，在本地机器上，我们只需执行以下命令：
- en: '[PRE65]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, on `spoton`, we will use, `curl` command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`spoton`上，我们将使用`curl`命令：
- en: '[PRE66]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'That is, we access `www.anomali.com` from `spoton` through our local machine;
    and that is what `-R` allows us to do: forward the connections on the remote host
    (`spoton`) on the remote port (`8181`) to the local machine, and from there to
    the external site (`www.anomali.com`). We then had to use the `-k` option with
    curl to prevent it complaining about an insecure connection, since the mismatch
    from the apparent URL and the external site SSL certificate. As a last word, we
    must remember to re-enable the ports we closed with the firewall before moving
    on.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们通过本地机器从`spoton`访问`www.anomali.com`；这正是`-R`选项允许我们做的：将远程主机（`spoton`）上的远程端口（`8181`）的连接转发到本地机器，然后从本地机器转发到外部站点（`www.anomali.com`）。接着我们使用了`-k`选项与
    curl 配合，防止它因连接不安全而报错，因为显式 URL 与外部站点 SSL 证书不匹配。最后，我们必须记得在继续之前重新启用之前关闭的防火墙端口。
- en: 'Nice, isn''t it? Before leaving this chapter, let''s indulge in some other
    tricks just to have fun. Let''s go back to our public key stored in the `test_user
    authorized_keys` on `spoton` , and let''s add something at the beginning of the
    key:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，不是吗？在离开这一章节之前，让我们再玩一些其他的小技巧，纯粹为了好玩。我们回到存储在`spoton`上`test_user authorized_keys`中的公钥，并在密钥的开头添加一些内容：
- en: '[PRE67]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We simply added a command to the key: each time we use this key to log in,
    the command will be executed. Since the user is unprivileged and the command requires
    to be run by root, we are using `sudo`, so let''s add the following file to `/etc/sudoers.d/`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是给密钥添加了一个命令：每次使用该密钥登录时，命令都会被执行。由于用户没有特权，而该命令需要由 root 用户运行，我们使用了`sudo`，因此我们需要将以下文件添加到`/etc/sudoers.d/`目录中：
- en: '[PRE68]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The name of the file does not matter; it is the content that makes the difference,
    enabling `test_user` to run `/sbin/ifconfig eth0` as root. This way, we will concede
    a small and restricted privilege. Now, from our local machine as `local_user`,
    let''s connect to `spoton` using the public key that we created:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的名称并不重要，重要的是内容，它使得`test_user`能够以 root 身份运行`/sbin/ifconfig eth0`。通过这种方式，我们将赋予其一个小而有限的权限。现在，从我们的本地机器作为`local_user`，让我们使用创建的公钥连接到`spoton`：
- en: '[PRE69]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can create dedicated users/keys to restart services, check logs, execute
    whatever maintenance task, and we will just have to fire up the connection without
    bothering about permissions and commands.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建专门的用户/密钥来重新启动服务、查看日志、执行任何维护任务，接着我们只需启动连接，而不必担心权限和命令问题。
- en: 'Do we need to run a graphical application that we do not have installed and
    cannot install, but we know it is available on a remote host? We must be sure
    that the X11 forwarding is enabled in our user `ssh config` file:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要运行一个我们没有安装且无法安装的图形化应用程序，但我们知道它在远程主机上可用怎么办？我们必须确保在我们的用户`ssh config`文件中启用了
    X11 转发：
- en: '[PRE70]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The forwarding is enabled on the remote server:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 转发功能已在远程服务器上启用：
- en: '[PRE71]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Obviously, on the remote server, there must be `Xorg` installed along with
    the `xauth` utility; and if we are using the same key, we have to clean it from
    the command snipped and revert to the original value. Once we are sure, we just
    type this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在远程服务器上，必须安装`Xorg`以及`xauth`工具；如果我们使用相同的密钥，必须将其从命令片段中清除并恢复到原始值。一旦确认无误，我们只需输入以下内容：
- en: '[PRE72]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In a few seconds, Firefox will be up and running on the remote host, but its
    window will be displayed on our local system.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，Firefox 将在远程主机上启动并运行，但其窗口将显示在我们的本地系统上。
- en: Summary
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We just scratched the surface of what we can actually do with SSH. There are
    so many things such as `ssh-agent`, `ssh-add`, and `ssh-keyring`, and so many
    complex and tricky things to do that a chapter cannot hold everything. Anyway,
    this is a starting point; and once we get familiar on the usage of both the server
    and the client, we can start a journey in the esoteric world of encrypted connections,
    jumphosts, proxies, and whatever we need or we want to know. As of now, we need
    to step further to another topic that will show us how to set up scheduled jobs
    to execute our script in a timely manner and how to properly log their execution
    so that we will be always able to understand what is going on with our creations.
    It's time for timed jobs, time to explore the at, cron and logging facilities.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚触及了通过 SSH 可以做的事情的皮毛。比如`ssh-agent`、`ssh-add`和`ssh-keyring`，还有许多复杂且棘手的操作，以至于单独一章无法涵盖所有内容。不管怎样，这只是一个起点；一旦我们熟悉了服务器和客户端的使用，就可以开始探索加密连接、跳板主机、代理等领域的深奥世界，了解我们需要知道或想要知道的任何事情。现在，我们需要进一步探讨如何设置定时任务来及时执行我们的脚本，并如何正确记录它们的执行，以便我们始终能够理解我们的创作过程中发生了什么。是时候了解定时任务了，探索`at`、`cron`和日志记录功能了。
