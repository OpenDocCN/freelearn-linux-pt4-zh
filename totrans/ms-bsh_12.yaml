- en: Remote Connections over SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is SSH?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The common answer to such questions is to use a secure shell and use SSH. The
    only drawback is that SSH is not a shell; it is actually a protocol often referred
    to SSH1 and SSH2: two different versions of the same protocol, incompatible with
    each other. Actually, nowadays, we are mostly dealing with SSH version 2 and OpenSSH
    server; it is the server program from the OpenBSD Project, which is available
    for a number of platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the benefits of SSH and why should we use it? Short story long, SSH
    grants three main facilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: This means it can make us sure of the identity of the other
    party. So, when someone tries to connect to our SSH server, the server will be
    able to obtain a digital proof of identity of the remote party prior to giving
    it access to the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption**: Older protocols such as Telnet and FTP are nice and easy to
    use, but they have a huge drawback since they send data in clear, so if someone
    could not breach a server, they could always try to eavesdrop on the data to and
    from it. SSH addresses this issue by encrypting the data, so it cannot be read
    so easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: It prevents tampering. If anyone intercepts the data and modifies
    it in transit, SSH will notice it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical SSH connection goes through a series of steps involving establishing
    a session and authenticating:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Session**: The server listens to a port, usually port `22`. The client contacts
    the server, which replies with the supported protocol versions. If any version
    is supported both by the client and the server, the connection continues. The
    server provides a host key, which is a proof of identity; and if it has been already
    recorded by the client on a previous session, it gets compared with the saved
    copy. The client and the server negotiate a session key, which will be used to
    encrypt the session (a symmetric key).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once a secure channel has been established, the client authenticates to the
    server with a number of options such as Kerberos; it is host-based but usually
    uses one of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Password**: The user must have a password-protected account on the remote
    server. This is probably the easiest way for the setup, but it holds some drawbacks
    such as we have to remember the username and password used on the remote host,
    and it makes it more difficult to automate logins into a script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public key**: Not to be confused with the encryption key, the public key
    method actually relies on a pair of SSH keys, one public and one private. One
    interesting thing is that the public key can be used to encrypt the data, which
    will be decrypted only by the private key. So, this is an asymmetric encryption
    since the two keys serve different purposes, and we cannot use the public key
    to decrypt data encrypted with the same public key. And there is no way to create
    a private key from a public one, so it becomes safe and easy to distribute the
    public key: whoever gets the public key can encrypt the data, but only those ones
    with the corresponding private key can decrypt it. So, it becomes safe to share
    the public key while the private one must be kept secret and unaccessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is interesting to have a look at how the two different kinds of encryptions
    are used during an SSH session:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symmetric encryption**: Used to encrypt all the data flowing through an SSH
    session, it relies on the Diffie-Hellman (or related) algorithm and relies on
    a large prime number, which works as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the beginning of the session, both clients and servers chose a large prime
    number, which is used as a seed value. Then, the client and server chose one encryption
    generator such as AES and another prime number, which is not communicated to the
    other party.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have a shared prime number, two private prime numbers, and an encryption
    generator, so each party derives a public key from its private prime number that
    it can share with the other side.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once shared, each party decrypts the other's public key, the algorithm, its
    private prime number, and the shared prime number to create a new master secret
    key that is the same for both, so it can be used to encrypt from both parts the
    subsequent traffic.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In between, the process of establishing a master key involves the server using
    his host key to sign the data used in the transaction, and so it authenticates
    with the client, which now can trust the server.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Asymmetric encryption**: It is used in the authentication stage to authenticate
    the client onto the server. As we see, one of the the authentication methods is
    carried through a pair of keys, one public and one private:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client starts sending the ID of the pair of keys it wants to use for the
    authentication and a username.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The server then checks whether the user account is available on the system and
    if inside there is a `.ssh` directory containing an `authorized_keys` file. If
    the file is available, it should contain the public keys stored by the server,
    so the ID sent by the client is matched against the IDs of the keys stored in
    this file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the public key of the client is found, it is used to encrypt a random number
    that is then sent back to the client.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The client, which generated the public key, holds its secret key, and so it
    can decrypt the packet sent by the server and obtain the secret random number.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the client side, a random number is combined with the session key, and then
    hashed to obtain its MD5 hash value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MD5 hash value is then sent back to the server, which then uses the session
    key and the original random number to calculate the MD5 hash value on its own.
    If the two hash values match, it means that the client has the private key corresponding
    to the public key used to encrypt the random number and so the client is authenticated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**MD5 hashing**: We just hinted about MD5 hashing, so let''s briefly explain
    what it is all about without drilling too much, since there are entire books on
    cryptographic and hashing algorithms. A hashing function is used to map a bunch
    of data with an arbitrary size to a fixed size. It is like creating a fingerprint
    of something but with a peculiar property: you can map the original data to a
    fixed size value using a hashing function, but you cannot map back from the fixed
    size value to the original data. Long story short, a hashing function is a one-way
    function. MD5 is an algorithm used by the hash function to produce a 128-bit hash
    value: whatever is the size of the hashed data, the MD5 hashed value produced
    will be 128 bits long--no more, no less. Although created as a cryptographic means,
    MD5 has proved itself vulnerable to different attacks, and so, it is used nowadays
    to check the integrity of the data, downloaded from a safe site and that has not
    been intentionally tampered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SSH can give us a secure channel to work over the network, avoiding having
    the data being captured by third parties and having us securely authenticated.
    Most of the time, we are dealing with an OpenSSH server, but when it comes to
    clients, there are plenty of them for any operating systems: from command-line
    programs to graphical ones such as putty. It''s just on us to choose whatever
    we find more ergonomic. Once we have chosen our preferred client, we can connect
    to the server; and since the most secure method is using public keys, we will
    see in the next chapter how to set up a passwordless connection to an SSH server.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before playing with ssh and having a look at what it can do for us, let''s
    take some time to see what are the most relevant files that are used to manage
    the ssh service and client. The configuration files for the SSHD daemon are usually
    stored in `/etc/ssh` where we can find some interesting files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`moduli`: This file contains the prime numbers and generators used by sshd
    in the Diffie-Hellman group exchange key exchange method, which is needed to create
    the shared session master encryption key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sshd_config`: This is the configuration file for the ssh daemon. We will have
    a closer look at it later to see some interesting and useful directives, which
    alter the way we connect to a remote server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_config`: This is the system-wide SSH client configuration file that is
    used when no user-specific configuration file is found in the user home directory
    `~/.ssh/config`. We will see later on what we can do with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_dsa_key`: This is the DSA private key used by the sshd daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_dsa_key_pub`: This is the DSA public key used by the sshd daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_rsa_key`: This is the RSA private key used by the sshd daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_rsa_key_pub`: This is the RSA public key used by the sshd daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_key`: This the RSA private key used by sshd for the SSH version 1
    protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_key.pub`: This is the RSA public key used by sshd for the SSH version
    1 protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_ecdsa_key`: This is the ECDSA private key used by the sshd daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_ecdsa_key.pub`: This is the ECDSA public key used by the sshd daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_ed25519_key`: This is the ED25519 private key used by the sshd daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_host_ed25519_key.pub`: This is the ED25519 public key used by the sshd
    daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What are all these RSA, DSA, ECDSA, and ED25519 acronyms associated to the
    host keys? These acronyms refer to public key cryptosystems used for the authentication
    keys and open a world of holy wars: some say that **Digital Signature Algorithm
    (DSA)** is slower when encrypting but faster when decrypting compared to RSA (acronym
    from the name of the researchers behind this algorithm, Ron Rivest, Adi Shamir,
    and Leonard Adleman from MIT ), which is deemed to be much more secure than DSA,
    while **Elliptic Curve Digital Signature Algorithm** (**ECDSA**) and **Edwards-curve
    Digital Signature Algorithm** (**ed25519**) are newcomers on the scene. All these
    are digital signature schemes that use different properties such as prime numbers
    or elliptic curves to ensure that the encryption itself is unbreakable, or more
    realistically, computationally unfeasible or not so likely. So, before proceeding,
    let''s make a point: we cannot be sure that some encryption is really unbreakable,
    and we cannot be sure for how long some of them that nowadays look safe will be
    so in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can make an educated guess and chose an algorithm that is computationally
    expensive and allegedly without any backdoor from anyone. So, keeping in mind
    that we are never 100% safe, we can make our choice with some OpenSSH Project
    recommendations in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH 7.0 deprecated DSA due to its weakness. So, we can safely discard this
    algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use keys smaller than 1024\. This makes sense, since longer keys can
    be computationally heavier, but for everyday use, they do not give a relevant
    added hindrance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use cyphers, such as Blowfish, CBC, RC4, MD5 based HMAC algorithms and
    RIPE-MD160 HMAC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use SSH version 1, as it is deprecated and not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use ECDA or ED25519, and if it not possible, we can create an RSA key of at
    least 2048 or 4096.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quite complex, isn't it? Well, a rule of thumb to understand what NOT to use
    is to read the Release Notes page of the OpenSSH project we can find at  [http://www.openssh.com/releasenotes.html](http://www.openssh.com/releasenotes.html) and
    have a look at the Future deprecation notice section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever we find here will be deprecated and eventually abandoned in the next
    releases, so even if we do not drill down into the details of the mathematics
    behind the encryption algorithms, we can trust the OpenSSH project and not use
    whatever is deprecated in any releases. When it comes to ciphers, these are algorithms
    that take chunks of plain data and create bits of obfuscated data. It suffices
    to say that even in this case, some holy wars are in play, with some major algorithms
    being considered weaker and some stronger:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital Encryption Standard (DES)**: Well regarded in the past, this is not
    really considered safe anymore due to the small keys used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Triple DES**: This is based on DES and considered safer but not really efficient
    nowadays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced Encryption Standard (AES) or Rijndael**: This is a quite recent
    algorithm and well regarded. AES-256, for instance, is used in TLS/SSL, and it
    is considered safe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IDEA**: This is a viable algorithm but due to patent use it is not so widespread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Twofish**: Using blocks of 128 bits and a variable length key, it is one
    of the choices for our encryption needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serpent**: If you do not have any ideas on what to choose, and cannot use
    AES, go with this, it has a block size of 128 bits and keys of 128, 192, and 256
    bits. Slower than other options but safe: a block cipher with a block size of
    128 bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After this short digression, we can proceed to having a look at another set
    of SSH config files that are optionally located on the user `.ssh` config directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`authorized_keys`: In this file, we can find the list of the public keys that
    give access to the server. As we saw earlier, when a client tries to connect to
    the server, it looks for the account and if it exists, looks in the `.ssh/authorized_keys`
    file in the user home directory for the ID of the key pair provided by the client.
    If the ID is found, the client is authenticated with the user and key provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authorized_keys`: This file holds a list of authorized public keys for servers.
    When the client connects to a server, the server authenticates the client by checking
    its signed public key stored within this file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`known_hosts`: This file contains the host public keys of the server that the
    client had already accessed. When the server sends to the client their host public
    key, it has looked inside this file to see if it corresponds to the previously
    stored public key for the remote host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: It holds the ssh client configuration for the user. It is really
    important in the passwordless connections since it helps to automate the connections.
    We will see more about it later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id_dsa`: This holds the DSA private key for the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id_dsa.pub`: This holds the DSA public key for the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id_rsa`: This holds the RSA private key for the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id_rsa.pub`: This holds the RSA public key for the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Identity`: This contains the RSA private key of the user for SSH version 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Identity.pub`: This contains the RSA public key of the user for SSH version
    1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are files we could find on a host, but probably we will not find all of
    them, for instance, not all the keys will be there; and we will have to create
    them taking the chance to give them some more meaningful names. Something we are
    sure to find on a remote host and interest us is the `sshd_config` file. Since
    this will help us to modify the way the daemon will offer the SSH server, let's
    have a look at it more in detail, covering some of the most interesting directives.
  prefs: []
  type: TYPE_NORMAL
- en: The sshd_config file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have a look at the directives that can be the most useful for our everyday
    service usage, but if we need to know all the details about all the configuration
    options, we can just invoke `man`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The main SSH daemon configuration file is located at the `/etc/ssh/sshd_config` event,
    though we can specify any file at the daemon startup using the `-f` option on
    the command line. That said, let''s go through and have a look at the most interesting
    configuration bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AcceptEnv`: This allows the client to copy the environment variable into the
    session environment sent by the client. It can be useful, but it can also be dangerous,
    and the default is not to accept any client environment variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowGroups`: By default, the log in is only allowed for members from all
    groups available on the system, but with this directive, you can restrict it to
    only to the users whose primary or secondary groups matches the groups listed,
    even using a pattern, as we will see later. We can use group names only; no ID
    and the access directives are processed in this order: `DenyUsers`, `AllowUsers`,
    `DenyGroups`, `AllowGroups`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowUsers`: By default, all users with a valid account are allowed to log
    in, but with this directive, we can restrict the access to only those members
    who match an account name or a patter. We can specify user names only and not
    IDs. We can also specify a member as `user@host` so that the restrictions will
    be applied not only to the account name but also to the origin host. This can
    be written in the CDIR/mask format. The access directives are processed in this
    order: `DenyUsers`, `AllowUsers`, `DenyGroups`, `AllowGroups`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthenticationMethods`: We can specify the authentication methods that a user
    must successfully go through to be given access to the system. It defaults to
    *any* meaning that the user must successfully authenticate once to any of the
    available methods. If any authentication methods combination is listed, for instance,
    `password`, `publickey`, `keyboard-interactive`, `publickey`, the user will be
    forced to authenticate through all the authentication methods at least once and
    in the order they are listed. So, in the example show, the user has to successfully
    authenticate with the `publickey` method and then at least with a password. The
    `keyboad-interactive` method is a generic authentication, which relies on facilities
    such as PAM, RADIUS, and RSA Secure ID and can be limited by appending a column
    followed by the `bsdauth`, `pam`, or `skey` keywords. If the `publickey` method
    is used more than once, such as `publickey` and `publickey`, two different public
    keys will be required to successfully authenticate. Whatever method is listed,
    it then must be enabled in the configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthorizedKeysFile`: Sometimes, we just put our client public authentication
    key in the `authorized_keys` file inside the `user ~./ssh` directory and nothing
    happens. Well, one of the issues could be originated by this directive, since
    it is here where the name of the file is defined. The default value is `.ssh/authorized_keys
    .ssh/authorized_keys2`, but we can also find some tokens such as `%h/.ssh/authorized_keys`,
    with `%h` standing for the home directory of the account autenticating; or we
    can also see `%%` , which stands for a simple `%` while a `%u` is replaced by
    the username. Once the tokens are expanded, the result is taken either as the
    full path to the file or the path relative to the user home directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Banner`: This is a nice option to show a message to the user before he authenticates.
    If `none` is supplied, no banner is shown. It is only available for SSH-2 and
    defaults to none.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChallengeResponseAuthentication`: This allows the challenge-response authentication.
    It defaults to `yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChrootDirectory`: By specifying the full path to a directory, we can `chroot`
    a user into it after he successfully authenticates. It is not an easy task though
    since the directory must be owned by root and not writable by anyone else. In
    addition, we must provide some files required for a session, such as the shell,
    `/dev/null`, `/dev/zero`, `/dev/arandom`, `/dev/stdin`, `/dev/stdout`, `/dev/stderr`,
    and `/dev/ttyx`. We can also find some tokens such as `%h` standing for the home
    directory of the account authenticating; or we can also see `%%` , which stands
    for a simple `%` while a `%u` is replaced by the username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ciphers`: This allows us to specify the ciphers allowed for SSH-2\. This is
    a good point to restrict the number and kind of ciphers we want to deal with.
    The default cipher list, comma separated, is `aes128-ctr,aes192-ctr`, `aes256-ctr`, `aes128cm@openssh.com`, `aes256-gcm@openssh.com`,
    and `chacha20-poly1305@openssh.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClientAliveCountMax`: This is the number of the client alive messages that
    can be sent without the daemon receiving any reply from the client. When the max
    is hit, the daemon will disconnect the client. The default value is `3`; and this
    option is available only for SSH-2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClientAliveInterval`: This is the time interval, in seconds, after which if
    the client does not send any messages, the server will send itself a message through
    the encrypted channel to the client to push for a reply. The default is `0`. So,
    let''s say that we set this option to `5` and the previous `ClientAliveCountMax`
    to `12`; the client will be disconnected after `60` seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DenyGroups`: By default, members from all the groups are allowed to authenticate
    but with this directive, we can restrict them to a list of space-separated groups.
    So, the authentication is unavailable for those users whose primary or supplementary
    groups is listed in this directive or matched through a pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We already mentioned the pattern available in `sshd config`, and this breaks
    down essentially to two characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*** matches 0 or more characters**: Something like `192.168.*` will match all
    the IP addresses starting with `192.168` ; or `*.foo.com` will match all the third-level
    domains for `foo.com` as well as the second-level domain called foo.com.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**? matches exactly one character**: So, for instance, `192.16?.1` will match
    all the IPS from `192.160.1` to `192.168.9.1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pattern list**: As the name states, this is a list of patterns delimited
    by commands. The single patterns can be negated by a leading exclamation mark;
    for example, `!*.noway.foo.com,*.foo.com` would allow the all the third-level
    domains for `foo.com` except those containing a noway right before `.foo.com`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Groups must be specified by their name, not by their numeric ID; and the order
    in which this directive is processed is: `DenyUsers`, `AllowUsers`, `DenyGroups`,
    and  `AllowGroups`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DenyUsers`: Followed by a list of user name patterns separated by a space,
    this directive disallows the log in for those user accounts which match the listed
    patterns. As usual, only the names of the users and not their ID can be specified
    and by default all users are allowed to log in. We can also specify a member as
    `ser@host` so that the restrictions will be applied not only to the account name
    but also to the origin host; this can be written also in the CDIR/mask format.
    The access directives are processed in this order: `DenyUsers`, `AllowUsers`,
    `DenyGroups`, and `AllowGroups`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DisableForwarding`: This directive disables all kinds of forwardings such
    as X11, TCP, ssh-agent, and `StreamLocal`. This is a nice directive to use if
    we want to trim down the service and make it safer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ForceCommand`: This overrides any command sent by the client or listed in
    the `~/.ssh/rc` of the authenticating account; and it forces the execution of
    the command listed in this directive. The command is executed through the account
    shell with the `-c` option. This defaults to `no`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostbasedAuthentication`: This allows/denies the authentication based on `rhosts`
    or `hostS_equive` along with a successful public `jkey` client host authentication.
    The default is `no/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostKey`: This directive specifies the file the private host key is kept in.
    By default, the locations are `/etc/ssh/ssh_host_rsa_key`, `/etc/ssh/ssh_host_ecdsa_key`,
    and `/etc/ssh/ssh_host_ed25519_key`. We can have multiple host keys defined for
    a single host. but it is important that the files holding them are not world or
    group accessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KbdInteractiveAuthentication`: This allows/denies the keyboard-interactive
    authentication. The default value is drawn from `ChallengeResponseAuthentication` ,
    which is usually set to `yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KerberosAuthentication`: This allows/denies the validation through a Kerberos
    server of the password provided by the client. The default value is `no`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListenAddress`: This lists the addresses SSH daemon will be listening on.
    We can use an IPv4/IPv6 address, a hostname, or a list of them and follow them
    with an optional port, such as following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If no ports are specified, sshd will listen on those listed in the ports directive.
    The default configuration is to listen to all local addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginGraceTime`: This is a timeout in seconds for the user to complete the
    log in process. It defaults to 120 seconds; with 0, we can disable the timeout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogLevel`: In case of any issues, we can modify the verbosity of the logs
    generated by sshd. The default level is `INFO` , but we can set it to any of `QUIET`,
    `FATAL`, `ERROR`, `INFO`, `VERBOSE`, `DEBUG`, `DEBUG1`, `DEBUG2`, `DEBUG3`. `DEBUG` and
    `DEBUG1` are equivalent while each `DEBUGx` enables a higher level of verbosity.
    `DEBUG` is not advised since it can disclose too many private informations related
    to the users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Match`: With this directive, we can use conditional statements so that if
    they are satisfied, the following configuration lines will override the one in
    the main configuration block. If a keyword/configuration block appears in more
    than one match clause, only the first instance is taken in account. As a matching
    criteria, we can use the following directives: user, group, host, local address,
    local port, address, or all for all of them. We can match against a single value,
    a comma separated list and we can also use wildcards and negation operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxAuthTries`: This limits the maximum number or authentication attempts per
    single connection. Once half of the threshold is hit, the subsequent failed attempts
    are logged. It defaults to `6`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PasswordAuthentication`: This allows/denies password authentication. This
    defaults to yes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitEmptyPasswords`: This allows/denies the use of empty passwords when
    password authentication is enabled. This is not safe to set to `yes` and defaults
    to `no`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitRootLogin`: This lets a user log in as root. It can have the following
    values: `yes`, `prohibit-password`, `without-password`, `forced-commands-only`,
    and `no`. If set to `prohibit-password` or `without-password`, the `password`
    and `keyboard-interactive` authentications are not available for user root; if
    set to `forced-commands-only`, a log in with public key authentication is allowed
    but only if a command is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitTTY`: This allows/denies the use of a `pty` (pseudo terminal) for the
    session. This defaults to `yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitTunnel`: This allows/denies the *tun* device forwarding. It takes `yes`,
    `point-to-point`, `ethernet` or `no` as arguments. `Yes` enables both `point-to-point`
    and `ethernet` forwarding. This defaults to `no`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitUserRC`: If set to `yes`, the commands inside `~/.ssh/rc` are executed.
    This defaults to `yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Port`: This specifies the port number the SSH daemon will listen on. This
    defaults to `22`, but we should move this port to some higher number to avoid
    most of the script kiddies around trying to automatically deface the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PubkeyAuthentication`: This allows/denies public key authentication. This
    defaults to `yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StrictModes`: This enables/disables file mode and ownership checks on the
    account''s files and home directory before letting the log in process go through.
    If it is set to `yes`, it checks for a world-writable user `.ssh` directory or
    a world writable `home` directory, and if we leave our files or directories world-writable,
    the log in is denied. This does not apply to `ChrootDirectory` , whose permissions
    and ownership are always checked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subsystem`: This enables the execution of an external subsystem, usually an
    `sftp-server`. The syntax is a subsystem name followed by a command with an optional
    argument to be executed on a subsystem invocation. This defaults to the `no` subsystem
    configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SyslogFacility`: We can use any of these `syslog` facilities to log the messages
    from the SSH daemon: `DAEMON`, `USER`, `AUTH`, `LOCAL0`, `LOCAL1`, `LOCAL2`, `LOCAL3`,
    `LOCAL4`, `LOCAL5`, `LOCAL6`, and `LOCAL7`. This defaults to `AUTH`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TCPKeepAlive`: This enables the server to send `TCP keepalive` to the client
    so that it will be able to detect any disconnection. This is not an easy choice:
    a temporary routing issue could lead to a forced disconnection from the server;
    but without a `keepalive`, a connection could hang indefinitely if the client
    disconnects or dies. This defaults to `yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseDNS`: This forces the SSH daemon to resolve, the host name through a DNS
    facility and check whether it resolves to the IP address of the client connecting.
    If this option is set to `no`, the usage of `from= in ~/.ssh/authorized_keys`
    still does not support host names but IP addresses only; and the same is applicable
    for the Match Host directive. Setting this option to `yes` can cause delays in
    authentication due to the DNS resolution task. Defaults to `yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsePAM`: This enables/disables the Pluggable Authentication Module interface.
    Defaults to `no`. If set to `yes`, it will enable the authentication through PAM
    using `ChallengeResponseAuthentication` and `PasswordAuthentication`, along with
    the PAM account and session modules, so one of these must be disabled. Interestingly,
    enabling PAM will allow the SSH daemon to run as an unprivileged user. This defaults
    to `no`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsePrivilegeSeparation`: If this is enabled, after the user''s log in, the
    SSH daemon will create a child process with the privileges of the authenticated
    user. It can take `yes`, `no` ,  or `sandbox` as arguments. If `sandbox` is selected,
    further mandatory restrictions are performed on the syscalls the child can perform
    so that it will be more difficult to use a compromised child to attack hosts or
    the local kernel. This defaults to sanbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X11Forwarding`: This allows/denies X11 forwarding. If set to `yes`, it can
    expost X11 to attacks, so this option must be taken with care. Defaults to `no`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We just saw some of the configurations on the server side, but we can alter
    how we interact with the SSH daemon configuring the client too, so let's have
    a look at the most interesting options from the client side.
  prefs: []
  type: TYPE_NORMAL
- en: ssh_config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the client side, we have a few ways to configure how a connection will be
    held:'
  prefs: []
  type: TYPE_NORMAL
- en: From the command line, passing options to the client while invoking it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the configuration file inside the user's home directory `~/.ssh/config`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the system-wide configuration file in `/etc/ssh/ssh_config`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the configuration files, we must bear in mind that only the first value
    obtained for each directive will be used; so if we give the same directive multiple
    times, only the first one will be evaluated. So, we must keep the more specific
    options at the beginning of the configuration file while the broader one will
    be pushed toward the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will see in the next paragraph, where we will examine a practical use
    of the client configuration, the file is segmented into sections whose boundaries
    are delimited by the `Host` directive: whatever configuration directive is listed
    below the keyword will belong to the host specified, until the next Host declaration.
    Each line in the file contains a configuration directive and value, optionally
    enclosed in double quotes when containing spaces; lines starting with `#` or blank
    are considered comments. Multiple values can be separated by a whitespace or `=`.
    With these caveats in mind, let''s have a look at the most interesting keywords
    in the client configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Host`: This directive can take a host name as an argument or a pattern, which
    can be negated with `!`. If `*` the following directives apply to all hosts. Whatever
    pattern or name is given here, it should match the host name we would give on
    the command line to connect to the remote host. All the directives following the
    `Host` keyword will be applied only to the host defined, up to the next `Host`
    or `Match` directive. If a host/pattern value is negated, all the directives for
    that host(s) are negated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Match`: This limits the scope of the following directives, up to the next
    `Match` or `Host` declaration, to be applied only when the values specified are
    satisfied. The values can be `all` , which always matches or one or more among
    `canonical`, `exec`, `host`, `originalhost`, `user`, and `localuser`. The `all`
    value must appear alone or right after canonical, which are the only two options
    not requiring an argument. Values can be negated using `!`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canonical`: This is matched when the configuration file is reparsed after
    the hostname canonicalization has taken place (we will see in a while what it
    means).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec`: Executes a command using the account''s shell; and if its `exit` status
    is zero then the condition is evaluated as `true`. If the command contains a whitespace
    then it must be quoted; it can accept tokens as arguments (we will see in a while
    what it means).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host`: This matches against the destination hostname, after any substitution
    operated by the `Hostname` or `CanonicalizeHostname` options. It can accept a
    comma-separated list, wildcards, and negation (`!`). For instance, take a look
    here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will use the identity file called  `foo.identity` only if the target host
    has the `foo.com` hostname and the the port equals to `9999`.
  prefs: []
  type: TYPE_NORMAL
- en: '`originalhost`: This is matched against the hostname specified on the client
    command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: This matches against the username used to log in on the remote host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localuser`: This is matched against the local (client side) user running an
    SSH client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BatchMode`: Useful for unattended log in from a script. If it is set to `yes`,
    no passphrases or passwords will be asked for and the `ServerAliveIntervall` will
    be set to `300` seconds in Debian. This defaults to `no`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BindAddress`: Useful in client machines which have more than one IP address
    assigned; it specifies the source address for the connection. Does not work if
    `UsePrivilegedPort` is set to `yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanonicalDomains`: Used with `CanonicalizeHostname`; it sets a list of domain
    suffixes to search for the remote host to connect to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanonicalizeFallbackLocal`: If set to `yes`, the client will attemp to look
    up an unqualified hostname using the search rule of the client system. If set
    to `no` and `CanonicalizeHostname` is set to `yes` , it will fail immediately
    if the remote hostname cannot be found in any of the domains listed by `CanonicalDomains`.
    Defaults to `yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanonicalizeHostname`: Enables the canonicalization rewriting the hostname.
    If set to `no`, the local resolver will manage the hostname lookup; if set to
    `always`, it will rewrite the unqualified hostnames using the domains listed in
    `CanonicalDomains`. The `CanonicalizePermittedCNAMEs` rules will be applied. If
    set to `yes`, the canonicalization will be performed for those connections which
    do not use a `ProxyCommand` directive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanonicalizePermittedCNAMEs`: Lists the rules that must be followed during
    hostname canonicalization. The rules can have one of more of the following arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source_domains:target_domains`: The first being a list of patterns for domains
    that may follow the hostname in canonicalization; `target_domains` is a list of
    patterns of domains that the former domains may resolve to.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CertificateFile`: Lists the file where to load the certificate file for the
    corresponding private key pointed to by the `IntentityFile` directive.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CheckHostIP`: Defines whether the client will check for the host IP in the
    `known_hosts` file for DNS spoofing prevention, adding the IP of the remote host
    to the `~/.ssh/known_hosts` file. Defaults to `yes`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectionAttempts`: The number of connection tries per second before exiting.
    Defaults to `1`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectTimeout`: Timeout in seconds for a connection try.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ForwardX11`: Enables X11 redirection over the connection and sets the DISPLAY
    value. Defaults to `no`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GatewayPorts`: Allows/denies the connection of remote hosts to local forwarded
    ports. Defaults to `no`, meaning that the local forwarded ports bind to the loopback
    device address. If set to `yes`, they are bound to the `*` address.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GlobalKnownHostsFile`: Sets one or more file (separated by whitespaces) where
    the host keys are kept. Defaults to the default `/etc/ssh/ssh_known_hosts` and
    `/etc/ssh/ssh_known_hosts2`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostKeyAlias`: Sets an alias to be used instead of the hostname when searching
    or saving the host key in the `hostkey` file.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostName`: Points to the real hostname of the remote host that we are going
    to log in. We can use this field to create a meaningful alias for the remote host,
    either using numeric IPS, tokens (we will see them later), or short names.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IdentityFile`: Defines the file the authentication identity is read from.
    Defaults to `~/.ssh/identity` for SSH-1, and `~/.ssh/id_dsa`, `~/.ssh/id_ecdsa`,
    `~/.ssh/id_ed25519` and `~/.ssh/id_rsa` for SSH-2\. If no certificates have been
    associated using the `CertificateFile` directive, SSH will try to read a file
    whose name is crafted by adding `-cert.pub` to the name listed under `IdentityFile`.
    Tokens can be used as argument; and it is possible to repeatedly use this directive
    to add more identity files to the list of the ones tried.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Include`: Includes the configuration files listed. If a file is not pointed
    to by an absolute path, it is meant to be located under `~/.ssh` if included in
    a user configuration or under `/etc/ssh` if included in the system-wide configuration
    file. Wildcards can be used, and this directive can be listed as an argument for
    the `match` and `host` keywords for conditional includes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalCommand`: We can write a command to be executed with the user shell once
    the local client has successfully connected to the remote host. It accepts the
    tokens, but it is ignored unless `PermitLocalCommand` is enabled.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalForward`: Enables the forwarding of a TCP local port over a secure connection
    to the remote host and port. It accepts two arguments: `[local_address:]port`
    and `remote_host:port`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can specify more than one forwarding but only a superuser can bind a local
    privileged port. The local port is bound to the address drawn from the `GatewayPorts`
    directive if not specified as an argument. If the localhost is given, the listening
    port will be accessible only from the local client machine; and an empty address
    means `*`, so the port will be accessible on all the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '`NumberOfPasswordPrompts`: Defines how many times a password is asked for before
    declaring the login process as failed, the argument can be an integer which defaults
    to `3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Port`: This is the port on the remote server that the client will try to connect
    to. Defaults to `22`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreferredAuthentications`: Defines the order in which the client will try
    different authentication methods. Defaults to `gssapi-with-mic`,`hostbased`,`publickey`,
    `keyboard-interactive`, and `password`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protocol`: Defines the protocol supported by the client in order of preference.
    If more than one is listed, they must be separated by a command. If a preferred
    protocol fails, the next in the list will be tried. Defaults to `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProxyCommand`: Defines the command used to connect to the remote server; and
    it is executed with the exec directive of the user''s shell. Really useful used
    with `netcat` to proxy connections. Accepts tokens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoteForward`: Enables the forwarding of a TCP port on the remote host on
    a secure connection to a port on the local machine. It accepts two arguments: `[local_address:]port`
    and `remote_host:port`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can specify more than one forwarding by only logging as a superuser on the
    remote host lets us bind a remote privileged port. If this is not specified, `local_address`
    is bound to the loop-back device. And if no remote host is specified, or `*` is
    used, then the forwarded port will be accessible on all interfaces on the remote
    host. To specify a remote address, we must enable the directive `GatewayPorts`
    in `sshd_config`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ServerAliveCountMax`: Defines the maximum number of server alive messages
    without receiving a reply from the remote host. Once the threshold is hit, the
    session is disconnected. These kinds of messages are way different from the `TCPKeepAlive`
    messages: the first one is sent over the encrypted channel, and so is not spoofable,
    while the second is in clear and can be spoofed. Defaults to `3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServerAliveInterval`: Defines a timeout in seconds, after which the client
    will send a message through the secure channel. Defines a timeout in seconds after
    which if no data have been received the client will send a message to the server
     through the secure channel requesting a response. Defaults to `0`, meaning that
    no messages will ever be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StrictHostKeyChecking`: If this is set to `yes`, two things will happen:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client will never automatically add a host key to the `~/.ssh/known_hosts`
    file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The client will refuse to connect to a remote host whose key has changed from
    the one stored in the `known_hosts` file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If this is set to `yes`, the client will automatically add the new keys while
    if set to ask, which is the default value the client will ask the user to confirm
    the addition of the key to the `known_hosts` file.
  prefs: []
  type: TYPE_NORMAL
- en: '`TCPKeepAlive`: Enables/disables the keepalive messages sent by the client
    to the remote host. Defaults to `yes` ; and this will allow the client to detect
    network disconnections or remote host crashing. It is largely used in scripts
    for unattended disconnection detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tunnel`: Enables forwarding between the client and the remote host for the
    tun device. Arguments can be `yes`, `point-to-point`, `ethernet` , or `no`. Defaults
    to `yes` , which enables the default point-to-point mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TunnelDevice`: Defines which tun devices to open both for the client and the
    remote host. The argument is specified as `client_tun:[host_tun]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Devices can be addressed by their numerical ID or using `any` , which will force
    the usage of the next available tun device. If no `host_tun` is defined, it defaults
    to `any`. The default is `any:any`.
  prefs: []
  type: TYPE_NORMAL
- en: '`UsePrivilegedPort`: Enables/disables the usage of a privileged port of the
    outgoing connection. If it is set to `yes`, ssh must be `setuid root` since this
    is the only user who is able to use privileged ports. Defaults to `no`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User`: Specifies the username of the remote account to log in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserKnownHostsFile`: Defines one or more files for the user''s `host_key`
    database. If more than one file is specified, it must be separated by a whitespace.
    Defaults to `~/.ssh/known_hosts`, `~/.ssh/known_hosts2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOKENS`: We referred to them in some of the configuration directives, and
    these are special character combinations that can be expanded during the SSH session:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%%`: This is expanded to a literal `%`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%C`: Short for `%l%h%p%r`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%d`: Expands to the home directory of the user on the client side'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%h`: This is the hostname of the remote host'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%i`: Expands to the local user ID'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%L`: Hostname of the client'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%l`: Hostname of the client, domain included, including the domain name'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%n`: Original hostname of the remote host as given on the command line'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%p`: Port on the remote host'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%r`: Username on the remote host'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%u`: Username on the client side'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These tokens are accepted in a different extent as arguments to different configuration
    directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Match exec` makes use of `%%`, `%h`, `%L`, `%l`, `%n`, `%p`, `%r`, `%u`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CertificateFile` makes use of `%%`, `%d`, `%h`, `%l`, `%r`, and `%u`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ControlPath` makes use of `%%`, `%C`, `%h`, `%i`, `%L`, `%l`, `%n`, `%p`,
    `%r`, `%u`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostName` makes use of `%%` and `%h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IdentityAgent` and `IdentityFile` make use of `%%`, `%d`, `%h`, `%l`, `%r`,
    `%u`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalCommand` makes use of `%%`, `%C`, `%d`, `%h`, `%l`, `%n`, `%p`, `%r`,
    `%u`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProxyCommand` makes use of `%%`, `%h`, `%p`, and `%r`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the directives that we listed for `sshd_config` , which were also available
    on the `ssh_config` file, were omitted for brevity's sake. We tried to be as tidy
    as possible before going to the next paragraph, where you will learn how to create
    passwordless connections using some of the directives that we just examined so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: Passwordless connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we need to set up such a nice connection method? We have  a few actors
    in place: we have to check the server setup, generate some keys, and configure
    the client.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start from the server opening the `/etc/ssh/ssd_config`  file and checking
    the following configuration directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the port. The standard port for the SSH service is `22` ,
    and it is at this value that most of the script kiddies around will probe your
    SSH daemon with some automated tools; so if you have a server publicly available,
    change the value to an unprivileged port such as `9527` . Thus, a lot of these
    attacks will simply be ineffective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to bind the service to a specific address on our server, this is
    the directive we need to work on; we simply uncomment and fill in the appropriate
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not think to use version 1 of the protocol, not even as a second choice.
    We stay safe and go along protocol version 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Ever wondered where the system-wide host keys are? Here, they are, and we can
    also decide to change names and path if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Definitely! We want to work with unprivileged processes so that no super user
    privileges can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Just give us some time to log in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: One safe practice is to limit the log in to the root account on a remote host
    to key-based authentication. This way, an intruder will not able to break in by
    just guessing a password; he will need the client's secret key to enter, and the
    key is safely stored on our client, not on the server. Anyway, if we want to remotely
    set up a passwordless authentication for the root account, we must allow root
    logins with passwords. Once we are sure everything works, we will restrict without-password.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is so easy to forget some world-writable permission on the home directory
    or on our ssh configuration files and keys, so better to enable this directive;
    and it will prevent us to log in if the home directory of the remote user we log
    in has some unsafe permissions set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Well, we are working on that so better to be sure this is set to `yes`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's note down where our public key must be stored. The token tells us they
    are in the `.ssh` directory inside the home of the accounts the file `authorized_keys`
    is in the home directory of the account we used to login into the system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Just for safety, let''s ditch the host authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's check this. We must never switch this to yes unless we want logins without
    passwords. But who would want this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There are a few reasons why we would like to set this to `yes`. One is that,
    with this on, the SSH daemon cannot be run as root; and this is a safe option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the config bits in place, let''s check that we also have the host
    keys that we need to proof the server identity to the client. As we can read from
    the configuration file, on the remote host, we should have a key for each algorithm
    supported in `/etc/ssh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There they are! So, we are fine. They usually get created when we install the
    OpenSSH server from our distribution packages, but we can also decide to create
    our very own host key. Let''s see how. First, let''s have a look at the fingerprint
    of one of the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We used ssh-keygen, a utility which does a lot of things, from creating a key
    to modifying it or, as in this case, having a look at it. The first field of the
    resulting sting tells us the bit length of the key, the second sports the actual
    key, the third points to the file holding this key, and finally comes the encryption
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the -lv options will give you a nice ASCII fingerprint of the key
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s say we do not trust the existing keys, and we want to create a new
    pair set of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Is this easy? Yes, it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the new key files; let''s check the same key again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The two keys are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We took advantage of the `-A` option of ssh-keygen, which automatically creates
    a missing key for each type (`rsa1`, `rsa`, `dsa`, `ecdsa`, and `ed25519`). The
    keys are created with the default bit size, with no password, and with the default
    comments. Now, let''s say again that we want to create our very own `ecdsa` host
    key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our new ecdsa host key has been created
  prefs: []
  type: TYPE_NORMAL
- en: 'We created our new host key using some simple options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-t`: This selects the type of the `keyboard-interactive`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a`: This option can be selected when saving a key in the ed25519 format or
    with any SSH-2 key when the `-o` option is selected. It specifies the number of
    **Key Derivation Function** (**KDF**) rounds to use to encrypt the private password.
    It makes the passphrase check slower and more resistant to a brute force attack.
    The higher the integer, the slower the check. It defaults to `64` , which is really
    good; we just got insane with `1000`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b`: Bit length of the key. Ecdsa can have a size of 256, 384, or 521 bit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-C`: Is a comment you can associate to the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: Is the path to the file that will hold the new key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o`: Saves the SSH-2 private key in the new OpenSSH format rather than the
    usual PEM format. The new format is more resistant to brute force attack, but
    it is not supported by OpenSSH versions lower than 6.5\. The ed25519 keys are
    always saved in the new format, so they do not require this option on the command
    line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, it is time to make the new key available to the server by adding it to
    the main sshd configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s restrict the permissions on the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So, no one other than root will be able to access the keys and configuration
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We notice two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a private key whose name does not end with `_key`. We did this on
    purpose to differentiate it from the prebuilt keys. The `key` filename can be
    whatever we want, but better give it a meaningful value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh-keygen` automatically added a trailing `.pub` to the private key file
    name and used the resulting name for the public key filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Safe permissions for ssh keys are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`700` for the `.ssh` directory, and'
  prefs: []
  type: TYPE_NORMAL
- en: '`600` for the key files inside the `.ssh` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s reload or restart the service to get the new key available for
    the SSH daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow, it is working, let''s see the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost there. The daemon successfully started but refused to load the
    host key. What happened? Simply, we gave a passphrase during the key creation;
    and  to load the key, a passphrase must be given but the daemon cannot interact
    and fill it in. We must remove the passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will ask for the old password, and when it comes to fill in a new
    one, let''s just hit the *Enter* key twice so that no password will be added to
    the private key. Now, let''s restart and check:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root:# systemctl restart ssh ; systemctl status ssh ; tail -n3 /var/log/syslog`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is really fine, the key has been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the remote account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use a scenario where we will create a completely new user; whatever
    we will do here will be applicable to a preexisting user. First, let''s create
    our new user test user on the remote host, and let''s configure it so that it
    will be available through key authentication only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we just created the `test_user` account and provided it with a `home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there is no `.ssh` at the moment. Now, since we do want this account
    to be accessible only using a key, let''s lock it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-l` option in `passwd` locks the account using a nice trick. When we create
    an account, `passwd` asks for it; and then it encrypts the password and writes
    it into the `/etc/shadow` file, as we can see in a `shadow` file before locking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields of the `shadow` file can be interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not go into the details of each field, a simple *man shadow* will give
    us all the information we need. What really matters is the second field holding
    the encrypted password. When a user tries to log in, the password they provide
    is encrypted and checked against the second field of the `/etc/shadow` file: if
    they match, the password is correct; if not, then the password is not correct
    and the user log in is refused. Have a look at the same string after the account
    has been locked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There is something new: the password field has `!` at the beginning, actually
    changing its value. And here is the trick: a character such as `!` or `*` can
    never be a result of the `crypt(3)` function used by `passwd` to encrypt the user
    password, so adding an exclamation mark makes the value unmatchable. Whatever
    value the user fills in, `passwd` will never be able to generate an exclamation
    mark; so, practically, the account is locked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for the setup, let''s enable the account again with a temporary password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We need to log in with a password to copy over our client public identity key.
    Once done, we will lock the account again.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have a username we can use and a port: `9999`. We can jump back to
    the client and create our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back to our client; let's enter the `home` directory of the user we want to
    set up the connection for. Let's say that `local_user` wants to connect as `test_user`
    on the remote host called **spoton**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to the `local_user` home directory, `local_user:~$ cd /home/local_user`, and
    have a look at what is inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the usual file for a new account, but there is a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have no identity file set, so we need to uncomment one of those lines; and
    if we want, we can also change the file name. For now, we will just add this line
    to the `ssh_config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We just modified the file name to make it clear that it will be used for the
    remote host named spoton. We could have different identity files for connecting
    to more than one remote server or as different users to the same server. So, it
    is better to find a meaningful name for the key file, one that will remind us
    what it is used for. Now that we have a reference in the client config file, we
    must create the `.ssh` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the right access permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s enter the `.ssh` directory and create our key; to keep things easy,
    we will not force a password on the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a smaller key size of 384, since at 512, we can face some issues and
    the key can be refused with a message like this from the client when invoking
    it with the `-vvv` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a key pair, one public, and one private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The access rights are not good for the pub key, so better fix it to a safer
    `600`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, as we already know, the private key must be kept safe on the client; but
    we must copy the public key over the remote host, and add it to `~/.ssh/authorized_keys` of `test_user`.
  prefs: []
  type: TYPE_NORMAL
- en: We have actually two ways to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Manually, copy the public key over to the remote server; copy it into the authorized_keys
    file and fix the access rights. Or, you can use the `ssh-copy-id` utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this second method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try logging in to the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Check to make sure that only the key(s) you wanted were added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything seems fine, so let''s connect to the remote system as `test_user`
    using the password we set. Check that in the home directory inside the `.ssh`
    subdirectory, there is an `authorized_keys` file with our public key inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The file is actually there with the correct access settings. Let''s have a
    look inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like the right key; let''s log out and have a look at the `local_user`
    public identity key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we just have to try the connection to the remote host using the identity
    file we created; but first, we have to make sure we allowed the port called `9999`
    on the remote host. Once we are sure that nothing is in between, we can just issue
    on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! We just logged in without any passwords, but this is still cumbersome.
    You have to point to the identity file and remember the port and the address.
    Not really handy, but we can improve our experience by taking advantage of the
    local configuration file that the client expects inside the `.ssh` directory of
    the local account. So, inside `/home/local_user/.ssh`, let''s create a file called `config`
    and write the following directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two sections, one of which applies to any host and one more specific
    for the host -spoton. Any time we want to add another host, we just have to copy
    and paste the host specific section, change the `Host`, `HostKeyAlias`, `Hostname`,
    `IdentityFile`, `User`, and, if needed, `Port` and that is all. The config file
    will grow with specific sections and our connections will be simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all, it is just matter to invoke SSH with the alias specified in `Host`
    and we connect, no passwords, ports, addresses, or identity files were requested.
    Last bit, let''s lock the remote user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check the account status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `L` shows us that the account is locked. So, we can go back to the client
    and try to connect again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here we are. The remote `test_user` account is locked, no one can use it locally
    or from a remote connection using a password. No one except the one who has the
    right private key; in this case, on our client called `local_user` .
  prefs: []
  type: TYPE_NORMAL
- en: We can play so many tricks with ssh that you could write an entire book on it,
    but we will limit our fun to a couple of nice functions offered by this tool.
    Proxying and tunneling we will see in the next paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: Proxies and tunnels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we need a quick way to exit our network bypassing the firewall settings.
    Our machine cannot make any HTTP/HTTPS connection, but we can reach another remote
    host, which has a free access to the Internet. So, let''s see a practical example.
    First, let''s use `curl` to grab a remote page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We just grabbed the [www.packtpub.com](https://www.packtpub.com/) home page;
    nice, isn''t it? Now, just for fun, root let''s use a simple firewall such as `ufw`
    to block any outgoing connection to port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to run the `curl` command once again; it will hang, since we
    denied any outgoing connections to any IP on port `80`. But now let''s give the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning:** Permanently added `spoton,[192.168.0.5]:9999 (ECDSA)` to the list
    of known hosts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We omitted the rest of the HTML code, but it is the same as for the previous
    `curl` command, since we grabbed the same page. What happened? We invoked ssh
    with some options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f`: This forces ssh to the background just before the command execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-N`: This prevents ssh from executing any command on the remote host, since
    we are just proxying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-D`: Followed by `[local_address]:port`, defines a local dynamic port forwarding
    and allocates a socket to listen for requests. When a connection is made to this
    port, this is forwarded over the secure connection to the remote host, while the
    application protocol is used to understand where to connect to from the remote
    machine. So, SSH will perform as a SOCKS server supporting the SOCKS4 and SOCKS5
    protocols. If used frequently, port forwarding can be set into the account `ssh
    config` file. Just notice that only a superuser can forward a privileged port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then used `spoton` as the destination, since we have a config snippet saved
    for it so we do not need to specify addresses or password. But if we had no config,
    we would have written this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Fill in the user password when asked for. Once we have our SOCKS proxy on, we
    can then configure any applications such as curl, Chrome, and Firefox to make
    use of it.
  prefs: []
  type: TYPE_NORMAL
- en: We do not like a SOCKS proxy? So, why not simply tunnel everything into a secure
    connection?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s make a call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: What is interesting here is the `-L` option, which forces the connections to
    the given TCP port (`8888`) to be forwarded over the encrypted channel to the
    remote host (`spoton`); and port (`9999`) or Unix socket, which then connects
    to the final host (`www.anomali.com`) on the port designated (`443`). As for the
    proxy, if we use this feature frequently, we can set it up into the account ssh
    config file, while we can optionally specify a local address to bind the local
    port (in brackets if IPv6). The spoton can be replaced by the remote account name
    at the remote address and port, as shown in the previous example. Notice that
    we used a redirection on HTTP, but this is a tunnel, so we can use whatever protocol
    we want, not just HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can do even something fancier: we can let someone access a remote host
    through us. So, on the local machine, we just give the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, on `spoton`, we will use, `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, we access `www.anomali.com` from `spoton` through our local machine;
    and that is what `-R` allows us to do: forward the connections on the remote host
    (`spoton`) on the remote port (`8181`) to the local machine, and from there to
    the external site (`www.anomali.com`). We then had to use the `-k` option with
    curl to prevent it complaining about an insecure connection, since the mismatch
    from the apparent URL and the external site SSL certificate. As a last word, we
    must remember to re-enable the ports we closed with the firewall before moving
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nice, isn''t it? Before leaving this chapter, let''s indulge in some other
    tricks just to have fun. Let''s go back to our public key stored in the `test_user
    authorized_keys` on `spoton` , and let''s add something at the beginning of the
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply added a command to the key: each time we use this key to log in,
    the command will be executed. Since the user is unprivileged and the command requires
    to be run by root, we are using `sudo`, so let''s add the following file to `/etc/sudoers.d/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the file does not matter; it is the content that makes the difference,
    enabling `test_user` to run `/sbin/ifconfig eth0` as root. This way, we will concede
    a small and restricted privilege. Now, from our local machine as `local_user`,
    let''s connect to `spoton` using the public key that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We can create dedicated users/keys to restart services, check logs, execute
    whatever maintenance task, and we will just have to fire up the connection without
    bothering about permissions and commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do we need to run a graphical application that we do not have installed and
    cannot install, but we know it is available on a remote host? We must be sure
    that the X11 forwarding is enabled in our user `ssh config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The forwarding is enabled on the remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, on the remote server, there must be `Xorg` installed along with
    the `xauth` utility; and if we are using the same key, we have to clean it from
    the command snipped and revert to the original value. Once we are sure, we just
    type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In a few seconds, Firefox will be up and running on the remote host, but its
    window will be displayed on our local system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just scratched the surface of what we can actually do with SSH. There are
    so many things such as `ssh-agent`, `ssh-add`, and `ssh-keyring`, and so many
    complex and tricky things to do that a chapter cannot hold everything. Anyway,
    this is a starting point; and once we get familiar on the usage of both the server
    and the client, we can start a journey in the esoteric world of encrypted connections,
    jumphosts, proxies, and whatever we need or we want to know. As of now, we need
    to step further to another topic that will show us how to set up scheduled jobs
    to execute our script in a timely manner and how to properly log their execution
    so that we will be always able to understand what is going on with our creations.
    It's time for timed jobs, time to explore the at, cron and logging facilities.
  prefs: []
  type: TYPE_NORMAL
