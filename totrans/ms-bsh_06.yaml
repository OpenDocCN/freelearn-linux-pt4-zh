- en: Iterations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代
- en: What we have seen so far enables us to interact with the user, process the input,
    and provide some output based on conditions we imposed. All of this is fine; and
    if the user calls our scripts with some arguments, we can store them in an array
    and process given that we know how many options they are passing to the command
    line. We must know in advance how many items the user will provide us with, otherwise
    we will lose those in excess. This is where an iterative construct comes in play.
    Since we already saw some examples, it can enumerate the content of an array and
    let us process its content without knowing in advance the number of items stored.
    In this chapter, we will have a look at how to use the `for` loop and *while/until*
    loop to get a strong grip on the data the user provides us with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的使我们能够与用户互动，处理输入，并根据我们设定的条件提供输出。所有这些都很好；如果用户带着一些参数调用我们的脚本，我们可以将它们存储在数组中并进行处理，前提是我们知道他们传递给命令行的选项数量。我们必须事先知道用户将提供多少项，否则我们会丢失多余的项。这时，迭代结构就派上用场了。因为我们已经看过一些示例，它可以枚举数组的内容，并让我们在不知道存储了多少项的情况下处理这些内容。在本章中，我们将看看如何使用
    `for` 循环和 *while/until* 循环来充分利用用户提供的数据。
- en: The for loop
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: 'The `for` loop is one of the most used structures when it comes to a Bash script
    and enables us to repeat one of more actions on each single item in a list. Its
    basic structure can be outlined as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环是 Bash 脚本中最常用的结构之一，它使我们能够对列表中的每个单独项执行一个或多个操作。它的基本结构可以概括如下：'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, we use a placeholder, which will take at each round of the loop one of
    the values in the list of items, which will then be processed in the `do` section.
    Once all the list is scanned through, the loop is done, and we exit it. Let''s
    start with a simple and nice example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们使用了一个占位符，它将在循环的每一轮中获取列表项中的一个值，然后在 `do` 部分进行处理。当列表被扫描完后，循环结束，我们退出它。让我们从一个简单且漂亮的例子开始：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And now let''s execute it:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行它：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Actually, quite straightforward, but notice that the list can be the result
    of any kind of operations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，这非常简单，但要注意列表可以是任何操作的结果：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, we used a brace expansion to get a countdown with a step of 2:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了大括号扩展来得到一个步长为 2 的倒计时：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can have a `for` loop on one line as well:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将 `for` 循环写在一行中：
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nice, isn''t it? Now let''s do something a bit more complex. Let''s say we
    want to write the following list:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 漂亮，不是吗？现在让我们做一些更复杂的事情。假设我们要写出以下列表：
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'How can we do this? Let''s try with a simple loop and see what happens:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该怎么做呢？让我们尝试用一个简单的循环，看看会发生什么：
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s run it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行它：
- en: '[PRE8]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Not exactly what we wanted. Well, not at all because the script does not know
    how to tell what is a city, what is a nation, and what goes with what. We have
    to find a way to qualify our items; and we can do it using their position. Here
    we have the set built-in, which enables us to assign the content of a variable
    to a positional parameter. We will just use it in a fancy way:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是我们想要的结果。嗯，完全不是，因为脚本不知道如何区分城市、国家以及它们之间的关系。我们必须找到一种方法来标定这些项；我们可以通过它们的位置来做到这一点。这里我们使用了内置的
    set 命令，它使我们能够将变量的内容分配给位置参数。我们将以一种有趣的方式使用它：
- en: '[PRE9]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now let''s run the script:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行脚本：
- en: '[PRE10]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is much better, and it is exactly what we were looking for; but how did
    we reach our goal? The first step was grouping the related items into double quotes,
    so for instance, `Belfast` goes with `UK`. The tricky part was using the set built-in
    with `--`, which forces the values following it to be assigned to positional parameters
    even though they start with a dash and if no arguments are given the positional
    parameters get unset. So, since we have groups of two: city and nation, we have
    `$1` and `$2`; one holding the city and the other having the nation. From there
    on, it was just a matter of printing the positional parameters. We can go even
    further without specifying a list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多，正是我们想要的结果；但是我们是怎么实现的呢？第一步是将相关项分组并加上双引号，比如，`Belfast` 和 `UK` 一起。棘手的部分是使用
    `set` 内置命令与 `--`，它强制将后续的值分配给位置参数，即使它们以短横线开头，如果没有提供参数，位置参数将被清空。因此，由于我们有两个一组的项：城市和国家，我们有
    `$1` 和 `$2`；一个表示城市，另一个表示国家。从那时起，剩下的就是打印这些位置参数的事了。我们甚至可以不指定列表来继续：
- en: '[PRE11]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we can provide the arguments on the command line; the script will take
    its input from `$@)`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在命令行上提供参数；脚本将从 `$@` 获取输入：
- en: '[PRE12]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we discussed before, the list can be anything: a variable, a brace expression,
    fixed values, the result of a command substitution, anything that creates a list
    of value through which we iterate:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，列表可以是任何东西：一个变量，一个大括号表达式，固定的值，命令替换的结果，任何通过迭代的值创建列表的东西：
- en: '[PRE13]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, the list is provided by the counter function, which prints
    out the result of a brace expansion. We then take the value returned by the function
    through the `echo` command and use it as a list to iterate on:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，列表是由计数器函数提供的，该函数输出大括号展开的结果。然后，我们通过`echo`命令获取函数返回的值，并将其作为列表进行迭代：
- en: '[PRE14]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Do not forget the C-style:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记 C 风格：
- en: '[PRE15]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we have a decreasing counter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有一个递减的计数器：
- en: '[PRE16]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What we saw so far allows us to cycle through structures of data and work on
    them as long as we have some items to process, but we do not know yet how to work
    on something until a condition is met or not, so this is the topic for the next
    paragraph where we will see how to keep our script alive until something happens.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的内容让我们能够遍历数据结构并对其进行操作，只要我们有一些项目需要处理，但我们还不知道如何在某个条件成立或不成立之前进行操作，所以下一段将讨论如何保持脚本在某些事情发生之前保持运行。
- en: Let's do something while, until…
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '让我们做一些事情，直到…… '
- en: 'The `for` loop is a great option to enumerate the contents provided by the
    user, but it is not so handy when it comes to handling a number of options whose
    number is not known beforehand. In this case, we would find more interesting kinds
    of loops, which would allow us to cycle until a certain condition is met or while
    a certain situation persists, for instance, while the user inputs something or
    until a threshold is met. So, let''s see which constructs can help us:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环是一个很好的选择，用来枚举用户提供的内容，但当需要处理一组预先无法知道数量的选项时，它就不太方便了。在这种情况下，我们会发现一些更有趣的循环结构，它们允许我们在满足某个条件之前或在某种情况持续存在时进行循环，例如，用户输入某些内容时，或者直到达到某个阈值为止。所以，让我们看看哪些结构可以帮助我们：'
- en: '[PRE17]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At a first glance, the difference between the `while` and `for` loops is evident:
    the latter is based on a placeholder that each time takes a value from a list
    and we work on that value, the former is triggered while conditions last. Let''s
    make an example starting with a `for` loop:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，`while` 和 `for` 循环的区别很明显：后者基于一个占位符，每次从列表中获取一个值并对该值进行操作，而前者在条件满足时触发。让我们通过一个从
    `for` 循环开始的示例来说明：
- en: '[PRE18]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is a simple counter, from 1 to 5, and we already saw it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的计数器，从 1 到 5，我们已经看过它：
- en: '[PRE19]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s rewrite it using a `while` loop:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `while` 循环重写它：
- en: '[PRE20]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s see if the output is the same:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出是否相同：
- en: '[PRE21]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Well, the output is exactly the same. Now, we will speak about another loop
    constructor, the `until` loop, which cycles on a list until a condition is met.
    Its structure is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，输出是完全相同的。接下来，我们将讨论另一种循环结构，`until` 循环，它在条件满足之前对列表进行循环。其结构如下：
- en: '[PRE22]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The structure is similar to the `while` loop, just the conditions change: `while`
    lasts as long as a condition is met, `until` lasts until a condition is met. To
    better understand the difference, let''s rewrite the example in the `until` form:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结构与 `while` 循环类似，只是条件不同：`while` 在条件成立时持续运行，`until` 在条件成立时停止运行。为了更好地理解区别，让我们将示例重写为
    `until` 形式：
- en: '[PRE23]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we can see from the code, until we do not reach a value of `i` higher than
    `5`, we print its value and increase it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看到，直到 `i` 的值大于 `5` 之前，我们打印它的值并增加它：
- en: '[PRE24]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Looks familiar, doesn''t it? So we can recap the three kinds of loop under
    the following conditions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很熟悉，不是吗？那么我们可以总结出三种类型的循环，条件如下：
- en: '`for` iterates on the values taken from a list'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 在从列表中获取的值上进行迭代'
- en: '`while` executes the loop until the condition is `false`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 在条件为 `false` 时执行循环'
- en: '`until` executes the loop while the condition is `false`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until` 在条件为 `false` 时执行循环'
- en: Exiting the loop with break and continue
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 break 和 continue 退出循环
- en: 'This gives us some nice opportunities, such as infinite loops:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一些不错的机会，比如无限循环：
- en: '[PRE25]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since `true` always evaluates as true, the condition is always verified so
    we have an infinite execution of the `do/done` clause; press *Ctrl+ C* to exit
    from the loop. An infinite loop looks like something nasty, but it opens a new
    scenario for our scripts, since we can make them run or wait for something for
    as long as we want. Actually, if we do not use a couple of loop control commands:
    `break` will exit the loop and `continue` will restart it, jumping over the remaining
    commands. Let''s see an example of creating a hypothetical backup program menu:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`true`始终计算为真，因此条件始终会被验证，从而导致`do/done`语句块的无限执行；按*Ctrl+C*退出循环。无限循环看起来像是一个麻烦的事情，但它为我们的脚本打开了一个新的场景，因为我们可以让它们运行或等待某个事件，直到我们希望的时间。实际上，如果我们不使用一些循环控制命令：`break`将退出循环，`continue`将重新启动循环，跳过剩余的命令。让我们看看创建一个假设的备份程序菜单的示例：
- en: '[PRE26]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s see what we did. We opened a `while true` loop, so whatever is inside
    it will be executed over and over. We then used a *here* document to have a nice
    menu to display to the user and a `read` option to ask the user for a choice to
    evaluate the input. Any choice except for `quit` will do nothing but display a
    message and wait for 3 seconds, after which the cycle restarts, clearing the screen
    and showing the menu once again (this is the reason for the `sleep` command).
    The only exception is if the customer hits `0`,`Q`, or `q`: in this case a message
    is displayed and the loop is exited:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 来看看我们做了什么。我们打开了一个`while true`循环，所以其中的内容会一遍又一遍地执行。然后，我们使用了*here*文档来展示一个漂亮的菜单给用户，并使用`read`选项让用户选择并评估输入。除非用户选择`quit`，否则任何选择都会什么也不做，仅显示一条消息并等待3秒，之后循环重新开始，清空屏幕并再次显示菜单（这就是`sleep`命令的作用）。唯一的例外是如果客户选择了`0`、`Q`或`q`：在这种情况下，会显示一条消息并退出循环：
- en: '[PRE27]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice that we exit a loop, not necessarily the entire script. This is a nice
    old style menu, which has its advantages over graphical ones: easier to code,
    easier to maintain, and less resources consumed, but most of all, it does not
    require a graphical monitor to be displayed: it works well on character monitors
    and over serial connections. For the `continue` instruction, the action flow is
    quite different, since it resumes iteration for the main `for`, `while`, `until`,
    or `select` loop. When used in a `for` loop the variable takes the value of the
    next element in the list of conditions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们退出的是循环，而不一定是整个脚本。这是一个经典的老式菜单，它相较于图形菜单有一些优势：更容易编写、更容易维护、消耗的资源更少，但最重要的是，它不需要图形显示器：它在字符显示器和串行连接上运行良好。对于`continue`指令，操作流程非常不同，因为它会恢复主`for`、`while`、`until`或`select`循环的迭代。当用于`for`循环时，变量将取列表中条件的下一个元素的值：
- en: '[PRE28]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our code will enumerate from 0 to 10 and print the values met, except when
    it hits the number 4: in this case, the `continue` will force the `for` loop to
    skip the value and proceed from 5:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将从0枚举到10并打印出遇到的值，除了当它遇到数字4时：在这种情况下，`continue`将迫使`for`循环跳过该值并从5继续：
- en: '[PRE29]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Time to give our client a menu
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是时候给我们的客户端一个菜单了
- en: 'In this chapter, we are looking at different ways to play with loops in order
    to work on the pieces of information the user provides us with. From a simple
    menu, we moved onto something fancier and better looking; and now, it is time
    to take a step further and have a look at the `select` construct whose task is
    to let us create menu in an effortless way. Its syntax is similar to the for construct:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的方式来处理循环，以便处理用户提供给我们的信息。从一个简单的菜单开始，我们转向了更华丽、外观更佳的方式；现在，是时候更进一步，看看`select`构造，它的任务是让我们轻松创建菜单。它的语法与`for`构造相似：
- en: '[PRE30]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, as we can see, this construct is very similar to `for` and sports a list,
    which gets expanded on the standard error in a series of elements preceded by
    a number. If we omit the `in list` part, the list gets constructed from the positional
    parameters given on the command line, such as if we used `[in $@]`. Once the elements
    in the list are printed, a `PS3` prompt is shown and a line from the `stdin` is
    read and stored into the REPLY variable. If something is read on the line, each
    word is displayed along with a number; if the line is empty the prompt is displayed
    again, but `if` and `EOF` characters are given as an input (*Ctrl+D*) the loop
    is exited. As a shortcut, you can use `break` to exit. Let''s see an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们所看到的，这个结构与`for`非常相似，并支持列表，在标准错误中展开为一系列以数字开头的元素。如果省略了`in list`部分，列表将从命令行中给定的位置参数构建，例如，如果我们使用了`[in
    $@]`。一旦打印出列表中的元素，将显示`PS3`提示，并读取并存储到`REPLY`变量中的`stdin`行。如果读取了行上的内容，则每个单词都会显示出来并附带一个数字；如果行为空，则再次显示提示，但给出`if`和`EOF`字符作为输入（*Ctrl+D*）时退出循环。作为快捷方式，您可以使用`break`退出。让我们看一个例子：
- en: '[PRE31]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This easy script will show you a menu of choices taken from the `in list` and
    wait for a selection. Once the user inputs a selection, it is echoed and the loop
    starts again showing the available options:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本将向您展示一个从`in list`中获取的选项菜单，并等待选择。一旦用户输入选择，它就会被回显，并且循环再次开始，显示可用选项：
- en: '[PRE32]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we can see, there is no control on what the user provided us with, so this
    is something we have to implement by ourselves. Also, the prompt is the least
    sexy thing we have ever seen, but we can alter it giving a value to the `PS3`
    variable, so just add `PS3="Your choice is: "` right below the sha-bang. Save
    and rerun the script:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们所看到的，我们无法控制用户向我们提供的内容，所以这是我们必须自己实现的事情。此外，提示是我们见过的最不性感的东西，但我们可以通过为`PS3`变量赋值来更改它，所以只需在sha-bang下面添加`PS3="Your
    choice is: "`。保存并重新运行脚本：'
- en: '[PRE33]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Way better now. Great, now another small issue: the script never exits, so
    how can we force it to exit? Let''s see some interesting modifications:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了。很好，现在另一个小问题：脚本永远不会退出，所以我们如何强制它退出呢？让我们看一些有趣的修改：
- en: '[PRE34]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We nested a case construct inside the `select` so that we can evaluate the
    choice given by the user and react accordingly. In any case, we just print out
    the choice made by the user, but if he selects `4`, we print the choice and exit
    with `break`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`select`内嵌套了一个`case`结构，这样我们就可以评估用户给出的选择并做出相应反应。无论如何，我们只是打印出用户的选择，但如果他选择了`4`，我们会打印出选择并使用`break`退出：
- en: '[PRE35]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But we can do something more interesting than this, especially if we want to
    interact with the system. Let''s again aim to make a backup script and take advantage
    of what we just did:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以做得更有趣，特别是如果我们想与系统进行交互。让我们再次尝试制作一个备份脚本，并利用我们刚刚做的事情：
- en: '[PRE36]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We used `while true` to make the main loop so that the script will be always
    running unless we explicitly exit from it, then with a *here* document, we show
    a neat menu to the user and then a case construct to provide a way to evaluate
    the answers given by the user in the next step. The first option in the `case`
    statement clears the screen and embeds a select structure, also it provides a
    list of files to work on using a filename expansion. Since we do not know in advance
    how many files we will have in the current directory, and we cannot modify the
    list, we can rely on a trick, creating a file called `EXIT` at the beginning of
    the script and deleting at the end of it. The output will be something like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`while true`创建了主循环，这样脚本将始终运行，除非我们明确退出它，然后使用*here*文档，向用户显示一个整洁的菜单，然后使用`case`结构来评估用户在下一步中给出的答案。`case`语句中的第一个选项清除屏幕并嵌入一个选择结构，还提供了使用文件名扩展来操作文件列表的方法。由于我们事先不知道当前目录中会有多少文件，并且不能修改列表，我们可以依赖一个技巧，在脚本开始时创建一个名为`EXIT`的文件，并在脚本结束时删除它。输出将类似于这样：
- en: '[PRE37]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And select option 1:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择选项1：
- en: '![](img/00007.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpeg)'
- en: The files are automatically numbered along without the EXIT placeholder. The
    files in the directory are all numbered, and our EXIT strategy shows up even though
    it is not the last option; but renaming it would allow us to place it wherever
    we want. Inside `select`, we find another case, since we want to evaluate the
    answer given by the user and work on the right file. So, if the user does not
    select the option corresponding to EXIT, we do not break out from the loop clearing
    out the file, but proceed by compressing it and exiting to the main loop, which
    will show up the main menu. All of this is nice, but did you realize that there
    is a big issue at play here? What happens if you select one option that is not
    really available in the select menu?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 文件会自动编号，而没有EXIT占位符。目录中的文件都会被编号，并且我们的EXIT策略会显示出来，尽管它不是最后一个选项；但是重命名它会让我们将它放在任何我们想要的位置。在`select`中，我们找到另一个case，因为我们要评估用户给出的答案，并处理正确的文件。所以，如果用户没有选择与EXIT对应的选项，我们不会从循环中退出并清理文件，而是继续压缩它，并退出到主循环，这会显示主菜单。所有这些都很好，但你意识到这里存在一个大问题吗？如果你选择一个在select菜单中并不存在的选项会发生什么？
- en: '[PRE38]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Well, it is to be expected since we did not provide a real check on the input,
    or better, we are checking only what we expected to receive, not the unexpected.
    So let''s modify the default option for the inner case statement:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是可以预料的，因为我们没有对输入进行真正的检查，或者更准确地说，我们只检查了我们预期接收的内容，而不是意外的内容。所以让我们修改默认选项以适应内部的case语句：
- en: '[PRE39]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We simply added a check to the content passed through `$file variable`: if
    the variable does not hold anything and does not point to any filename, we display
    a message, wait for three seconds, and then restart the loop. We could also use
    read instead of just waiting to force the user to press a key to continue; and
    this would leave the warning message displayed until the user reacts.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅仅在传递给`$file variable`的内容中添加了一个检查：如果该变量为空且不指向任何文件名，我们将显示一条消息，等待三秒钟，然后重新启动循环。我们也可以使用`read`，而不仅仅是等待，这样可以强制用户按下一个键继续；这将使警告消息保持显示，直到用户做出反应。
- en: 'As we can see from the various examples, there is more than one way to create
    a user menu in Bash; and in the coming chapters, we will use them and make them
    even more fancier. But talking about user interaction, we have one topic left
    to face and it is quite interesting: dealing with how to manage the command line
    argument passed to our scripts. So, if we do not want to show a menu, but want
    to receive arguments on the command line, how do we do it? We already saw something,
    but there is a nice built-in that can ease our job, so it is time to have a look
    at `getops`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从各个示例中我们可以看到，创建用户菜单在 Bash 中有不止一种方法；在接下来的章节中，我们将使用这些方法并让它们变得更加华丽。但谈到用户交互时，我们还有一个话题需要面对，而且它非常有趣：如何处理传递给脚本的命令行参数。所以，如果我们不想显示菜单，而是希望在命令行接收参数，我们该如何操作呢？我们已经看到过一些内容，但有一个很好的内建功能可以让我们的工作更加轻松，现在是时候看看`getops`了。
- en: CLI, passing the arguments to the command line
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI，将参数传递给命令行
- en: 'Geopts is a Bash built-in widely used to efficiently parse switches and arguments
    passed on the command line of a script. We already saw other ways to accomplish
    this task, but getops makes it quite easy to handle it, since it can automatically
    recognize the switches and argument passed to the script. Its syntax is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Geopts 是一个 Bash 内建命令，广泛用于高效地解析传递给脚本的开关和参数。我们已经看到过其他完成此任务的方法，但`getops`使得处理它变得非常简单，因为它可以自动识别传递给脚本的开关和参数。它的语法如下：
- en: '[PRE40]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first thing we pass to `getops` is a string of options, the classical `-a
    -x -f` of whatever you want, without any leading dash, such as `getops axf` or
    also `getops ax:f`. If you see an option followed by a colon, this means that
    the option is meant to have an argument such as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`getops`的第一个是选项的字符串，即经典的`-a -x -f`之类的，没有任何前导的破折号，比如`getops axf`或`getops
    ax:f`。如果你看到某个选项后面跟着一个冒号，这意味着该选项需要一个参数，如下所示：
- en: '[PRE41]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In our example, `-x` has an argument while `-a` is a simple switch, or we can
    also call it **flag** that can just be there or not, but it does not require any
    arguments. The options can be specified as lower or upper characters or digits.
    The `getops` built-in has some predefined variables for its internal use:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`-x`有一个参数，而`-a`是一个简单的开关，或者我们也可以称之为**标志**，它可以存在也可以不存在，但不需要任何参数。选项可以用小写或大写字母，或者数字来指定。`getops`内建有一些预定义变量供其内部使用：
- en: '`OPTARG` holds the argument for an option or the flag for an unknown option.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTARG`保存着选项的参数或未知选项的标志。'
- en: '`OPTBIND` holds the index for the next option to parse.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTBIND`保存下一个要解析的选项的索引。'
- en: '`OPTERR` holds 0 or 1 and sets the display of error messages from `getops`.
    The default value is 1, so messages are displayed here.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTERR`的值为0或1，用来设置`getops`的错误信息显示。默认值为1，所以这里会显示错误信息。'
- en: 'As it is quite clear, `getops` is useful for parsing short options, but it
    cannot process the long style options, so `-a` is okay, but `--all `will not be
    parsed. It''s a limit, but it is just a matter of style. Let''s see a simple example
    and by commenting on it, we will have a look at how `getops` works on the field:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`getops`适用于解析短选项，但它无法处理长选项样式，因此`-a`是可以的，但`--all`则无法解析。这是一个限制，但也只是风格问题。我们来看一个简单的例子，边注释边看`getops`在实际应用中是如何工作的：
- en: '[PRE42]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, our script starts with a while loop, and this is due to the fact that `getops`
    exits with a status called `fail` when there is nothing to parse, and this condition
    is met when it reaches the first non option argument or when it hits a `--`. Next,
    we see the `getops` built-in followed by `ax:f`, which means it expects this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的脚本以一个while循环开始，这是因为当`getops`遇到无法解析的内容时，它会退出并返回一个名为`fail`的状态，这个条件会在遇到第一个非选项参数或遇到`--`时触发。接下来，我们看到的是`getops`内建命令，后面跟着`ax:f`，意味着它期望如下：
- en: '[PRE43]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`getops` will read all the options up to the first non-option argument and
    store them in a variable that in our case is named option. Now, the last part
    is a bit tricky. Have a look at `getopts ":ax:f"`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`getops`会读取所有选项，直到遇到第一个非选项参数，并将其存储在一个变量中，在我们的例子里叫做option。现在，最后这一部分有点复杂。看一下`getopts
    ":ax:f"`。'
- en: Did you notice`:` before the first option? It disables the standard error messages
    for getops and alters the way the standard variables are used.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到第一个选项前的`:`了吗？它禁用了getops的标准错误信息，并改变了标准变量的使用方式。
- en: In case of an invalid option, the variable (`option` in our example) is used
    to store the `?` character, which highlights the error; and `OPTARG` is instanced
    with the invalid character provided by the user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选项无效，变量（在我们的例子中是`option`）会用`?`字符来存储错误信息；同时，`OPTARG`会存储用户提供的无效字符。
- en: 'In case of an argument, the variable is instanced with a colon `:` and `OPTARG`
    holds the option character. Let''s run this script with the different options
    to see how it works:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有参数，变量会通过冒号`:`进行实例化，而`OPTARG`会保存选项字符。让我们用不同的选项运行这个脚本，看看它是如何工作的：
- en: '[PRE44]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Nice, but do not get fooled, we have two main issues here, do you see them?
    Let''s have a look at the first one:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但不要被愚弄，我们这里有两个主要问题，你能看出来吗？我们来看看第一个问题：
- en: '[PRE45]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Well, no switches were given, no output at all, and this is not good at all:
    remember not to leave your user without a feedback, never. Always have your script
    to show something to the user, so he knows he did something and will not try to
    invoke it repeatedly. We can manage this situation adding just before the while
    loop a small fragment of code, which counts the arguments on the command line:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，没有给出任何开关，没有输出，这样可不行：记住，绝不能让用户没有任何反馈。永远让你的脚本给用户显示一些东西，让他们知道他们做了什么，否则他们可能会反复尝试调用。我们可以通过在while循环前添加一个小片段代码来处理这种情况，该片段用于统计命令行上的参数个数：
- en: '[PRE46]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Nothing special, we just checked if the number of arguments passed to the command
    line is equal to `0` and whether this is the case we echo a message and exit with
    an error:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么特别的，我们只是检查传递给命令行的参数数量是否等于`0`，如果是的话，我们就输出一条信息并以错误状态退出：
- en: '[PRE47]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`Hello` is an argument passed to the command line, but `-a` does not accept
    the `options` argument, so how do we retrieve `Hello`? Notice that there is a
    difference between these two invocations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello`是传递给命令行的一个参数，但`-a`不接受`options`参数，那么我们该如何获取`Hello`呢？请注意，这两个调用之间是有区别的：'
- en: '[PRE48]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The first `Hello` is the argument of an option and the second is a simple argument
    on the command line, which is not related to an option, since `-a` does not accept
    any arguments. And so, we were able to reach `Hello` the first time, but not on
    the second scenario. How can we overcome this limitation? Let''s rewrite the previous
    example adding the following lines at the end of the script:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`Hello`是一个选项的参数，而第二个是命令行上的一个简单参数，它与选项无关，因为`-a`不接受任何参数。因此，我们第一次能够处理到`Hello`，但在第二种情况下却无法处理。我们该如何克服这个限制呢？让我们重写之前的例子，并在脚本的末尾添加以下几行：
- en: '[PRE49]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now let''s run the script again:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次运行脚本：
- en: '[PRE50]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And here we are. Notice the use of shift that helped us in retrieving the argument;
    this trick is based upon the value hold by `OPTIND`, which corresponds to the
    number of options parsed by the last call of `getops`. If we recall how `getops`
    works: each time it is invoked, it puts the next option in the variable used to
    hold them, initializing it if does not exist and the index of the next argument
    to parse into the `OPTIND` variable. So, `OPTIND` at the first run has `1` as
    its argument. Bear in mind that `OPTIND` is never reset by the shell, so if you
    have to make multiple calls to `getops`, it is up to you to reinitialize the variable
    to `1`. Then, we use shift to deal with the positional parameter, since this built-in
    is able to shift the positional parameters on the left by the number specified
    as its argument. So `shift "$((OPTIND-1))"` shifts the positional parameter of
    the next argument of `getops` back to one position. Let''s rewrite a part of the
    previous script:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。注意到我们使用了 `shift`，它帮助我们获取了参数；这个技巧基于 `OPTIND` 存储的值，它对应于 `getops` 最后一次调用时解析的选项数量。如果我们回顾一下
    `getops` 的工作原理：每次调用时，它将下一个选项放入用于存储选项的变量中，如果该变量不存在，则会进行初始化，并将下一个要解析的参数的索引存入 `OPTIND`
    变量。因此，第一次运行时，`OPTIND` 的值为 `1`。请记住，`OPTIND` 永远不会被 shell 重置，因此如果你需要多次调用 `getops`，你需要自己将该变量重新初始化为
    `1`。然后，我们使用 `shift` 来处理位置参数，因为这个内建函数可以根据指定的参数将位置参数向左移动。因此，`shift "$((OPTIND-1))"`
    会将下一个 `getops` 参数的位置向左移一个位置。让我们重写上一部分脚本：
- en: '[PRE51]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, run it again:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行它：
- en: '[PRE52]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'But at the end of the script, we have this left on the command line: `Hello`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在脚本的最后，我们在命令行上留下了这个：`Hello`。
- en: 'So, what happens? When you run the script, `OPTIND` starts with a value of
    `1` and gets incremented by `1` each time `getops` gets called. So, since we have
    two options to process on the command line, at the end of the `getops` loop, the
    value of `OPTIND` will be 2+1, so we have 3\. Now, if we shift the command line
    of `"$((OPTIND-1))"`, it means that we move the command-line arguments of 2 slots
    (3-1) to the left. Bear in mind that when you shift the positional arguments to
    the left, they get essentially lost and so what you are left with is the rest
    of the arguments. In our case, if we move the positional arguments of 2 on the
    left, we get rid of `-f` and `-a`; and we are left with the first non-option argument,
    `"Hello"`. Here we are! If we now print the content of the command line `$@` after
    the loop, we are left exactly with `Hello`. Now, it''s time to build up the tools
    we will use in the next chapters and pull together all the bits and parts you
    learned so far. First things first: the script will become more complex, and it
    will tend to clutter a bit, so if we recall what we saw in the first chapters
    about sourcing a file, what we will do now is create a library to hold all the
    common functions and settings that we are going to use frequently. Adopting this
    style will help to keep our scripts neat and simple and to master their content
    with less effort. So, first things first, let''s create a library file that we
    will call `library.lib` and start writing some functions in it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么呢？当你运行脚本时，`OPTIND` 的初始值为 `1`，每次调用 `getops` 时，`OPTIND` 会增加 `1`。因此，既然我们在命令行上有两个选项需要处理，在
    `getops` 循环结束时，`OPTIND` 的值将是 2+1，也就是 3。现在，如果我们对命令行使用 `"$((OPTIND-1))"` 进行移位，这意味着我们将命令行的参数向左移动了
    2 个位置（3-1）。请记住，当你将位置参数向左移时，它们基本上会丢失，剩下的就是其余的参数。在我们的例子中，如果我们将位置参数向左移动 2 个位置，我们就去掉了
    `-f` 和 `-a`，剩下的就是第一个非选项参数，`"Hello"`。就是这样！如果我们在循环后打印命令行内容 `$@`，结果就是 `Hello`。现在，是时候建立我们将在接下来的章节中使用的工具，并将到目前为止学到的所有部分汇集起来了。首先：脚本将变得更复杂，并且可能会变得有些凌乱。所以，如果我们回顾一下前几章关于引用文件的内容，我们现在做的是创建一个库来存放所有我们将频繁使用的公共函数和设置。采用这种风格将帮助我们保持脚本的整洁和简洁，并更轻松地掌握其内容。所以，首先，创建一个我们称之为
    `library.lib` 的库文件，并开始在其中编写一些函数：
- en: '[PRE53]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let''s rewrite the first part of the previous script in the following
    way:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以如下方式重写前面脚本的第一部分：
- en: '[PRE54]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And time to run the script without any options:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在没有任何选项的情况下运行脚本了：
- en: '[PRE55]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As we can see, the check on the zero length input has been moved to the library,
    then sourced back to the main script. So, now, we have two advantages:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，零长度输入的检查已被移至库中，然后再引用回主脚本。所以，现在我们有了两个优点：
- en: Less rows in our primary script
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的主脚本中行数更少了
- en: The `non_zero_function` is now available to all the scripts that will source
    the library we just created
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`non_zero_function` 现在对所有将引用我们刚创建的库的脚本都可用'
- en: 'But now, it is time for something fancy. Ever wanted to give some spice to
    your output? Just modify this library in the following way:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，是时候来点花样了。有没有想过为输出增添一些亮点？只需按以下方式修改这个库：
- en: '[PRE56]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We added some ANSI color code to our library assigning them to a meaningful
    variable name and also created a small `color_print` function. ANSI escape code
    or sequences are methods to manage colors and attributes on text terminals and
    are represented by a string starting with the ESC character (033 in octal), followed
    by a character between 64 to 95 in the ASCII range. W just added a few foreground
    colors, but by googling, you will find a lengthy list of escaped characters that
    you can assign to background colors, bold characters, reverse, and so forth. The
    `color_print` function is just a tiny example of what can be done with these control
    codes and it makes use of `printf`, which is a bit more flexible than `echo` even
    though `echo -e` will deal with escaped characters and will be good enough to
    print colors and attributes. Notice that the `color_print` functions ends `printf`
    with  `''33[0m''`, which is a reset control character that will revert to default
    all the changes you made to the output: once you modify a color or an attribute,
    everything will be printed with that alteration until you explicitly reset to
    default using the reset escape sequence. Now, it is time to take advantage of
    what we just saw and modify the script we just created so that it ends this way:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向库中添加了一些 ANSI 颜色码，并将它们分配给有意义的变量名，还创建了一个小的 `color_print` 函数。ANSI 转义码或序列是用来管理文本终端上颜色和属性的方法，它们以
    ESC 字符（八进制 033）开头，后面跟着一个 ASCII 范围内 64 到 95 之间的字符。我们仅添加了一些前景颜色，但通过谷歌搜索，你会找到一长串可以分配给背景色、粗体字符、反转等的转义字符。`color_print`
    函数仅仅是利用这些控制码能够做的事情的一个小例子，它使用了 `printf`，虽然 `echo -e` 也能处理转义字符，足以用来打印颜色和属性，但 `printf`
    更加灵活。请注意，`color_print` 函数在 `printf` 结束时使用了 `'33[0m'`，这是一个重置控制字符，会将你对输出所做的所有更改恢复为默认设置：一旦你修改了颜色或属性，所有内容都会按照这些修改进行打印，直到你明确使用重置转义序列恢复为默认值。现在，是时候利用我们刚刚学到的东西，修改我们刚刚创建的脚本，让它以这种方式结束：
- en: '[PRE57]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'There are two different examples on how to use the escape codes to manage the
    output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个不同的示例，展示了如何使用转义码来管理输出：
- en: '[PRE58]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The word `But` is preceded by the value of the variable `Green` that we sourced
    from the library and it is closed by the `CReset` variable value, so echo will
    turn the output to green foreground right before writing `But` and revert to the
    standard color, usually white, right after thanks to the reset escape sequence.
    Then, right before printing the command-line arguments, it switches to `Red` to
    revert back once finished. The last line is printed using the `color_print` function
    sourced from the library file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 单词 `But` 前面是我们从库中获取的 `Green` 变量的值，后面跟着 `CReset` 变量值，所以 echo 会在打印 `But` 之前将输出切换到绿色前景色，并在重置转义序列的作用下，在打印完成后恢复为标准颜色（通常是白色）。然后，在打印命令行参数之前，它会切换到
    `Red`，完成后再次恢复。最后一行是使用从库文件中获取的 `color_print` 函数打印的：
- en: '[PRE59]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As we can see from the function definition, it accepts two arguments, the escape
    code and the string to print trailing them with a reset code; in our case we selected
    `Yellow`, so let''s see what is the outcome in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数定义中我们可以看到，它接受两个参数，一个是转义码，另一个是要打印的字符串，后面跟着一个重置码；在我们的案例中我们选择了 `Yellow`，那么让我们看看接下来的截图中会有什么样的结果：
- en: '![](img/00008.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: Inline escape codes or ad hoc functions kicks up our output
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 内联转义码或临时函数让我们的输出更具表现力
- en: 'Nice, isn''t it? There are actually many ways to color your output using Bash,
    from interacting with the dialog program, which will give you curses such as interface:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不错吧？其实使用 Bash 给输出加上颜色有很多方法，比如通过与 dialog 程序交互，它会给你一个类似 curses 的界面：
- en: '[PRE60]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![](img/00009.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: 'This is a simple message box, which reminds me of the old Linux installers to
    zenity that will give you a GTK+ interface:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的消息框，它让我想起了老版 Linux 安装程序中的 zenity，它会为你提供一个 GTK+ 界面：
- en: '[PRE61]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![](img/00010.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: Zenity allows you to create beautiful interfaces using GTK+ decorations
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Zenity 允许你使用 GTK+ 装饰创建漂亮的界面
- en: 'What we can use depends on the level of interaction we want to have with the
    customer; for instance, scripts dealing with services probably will not need any
    fancy stuff. And on our concerns about portability: to use dialog and zenity you
    have to install them; they are not shipped by default with a Linux system. For zenity,
    keep in mind that it only show its goodness on a graphical interface; if you go
    over serial or text-based terminals, it will show you curses such as interface
    at best. If you want to use something more advanced than ANSII escape code, you
    can resort to the `tput` command, which is shipped with Linux; and by using the
    `terminfo` or `termcap` databases, it enables you to interact with the terminal
    in a more interesting way:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的东西取决于我们希望与客户进行的交互级别；例如，处理服务的脚本可能不需要任何花哨的东西。关于可移植性的考虑：要使用 dialog 和 zenity，你必须安装它们；它们并不默认随
    Linux 系统一起提供。对于 zenity，请记住，它只在图形界面上显示其优点；如果通过串口或基于文本的终端运行，它最多只会显示像 curses 这样的界面。如果你想使用比
    ANSII 转义码更先进的东西，可以使用 `tput` 命令，它随 Linux 提供；通过使用 `terminfo` 或 `termcap` 数据库，它可以让你以更有趣的方式与终端进行交互：
- en: '[PRE62]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![](img/00011.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: An auto updating message displayed using tput
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 tput 显示的自动更新消息
- en: 'This simple script uses `tput` with a series of numbers to change the color
    of the output.`tput setaf x` sets the foreground color to the value corresponding
    to the `x` integer:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本使用 `tput` 和一系列数字来改变输出的颜色。`tput setaf x` 设置前景色为与 `x` 整数对应的值：
- en: '[PRE63]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For the background, we use `tput setbg x` with the same list of codes. We used
    the command substitution to get the output of the command and use it with `printf`
    to modify the output accordingly. The values for the rest of the `tput` commands
    are quite obvious:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于背景，我们使用 `tput setbg x` 和相同的代码列表。我们使用命令替换获取命令的输出，并使用 `printf` 来相应地修改输出。其他 `tput`
    命令的值是显而易见的：
- en: '`tput smso` enters the standout mode'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tput smso` 进入突出显示模式'
- en: '`tput rmso` exits the standout mode'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tput rmso` 退出突出显示模式'
- en: '`tput dim` makes the output less bright'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tput dim` 使输出变得不那么亮'
- en: '`tput sgro` reverts back to the standard terminal output'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tput sgro` 恢复到标准终端输出'
- en: '`tput cvis` hides the cursor'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tput cvis` 隐藏光标'
- en: 'Then, we created a function named `box`, which hides the cursor, and then sets
    the background to blue. The interesting parts are here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个名为 `box` 的函数，它隐藏光标，并将背景设置为蓝色。这里的有趣部分是：
- en: '`tput cols` gets the number of columns of the terminal'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tput cols` 获取终端的列数'
- en: '`tput lines` gets the number of lines of the terminal'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tput lines` 获取终端的行数'
- en: We stored the output of the two commands in the width and height variables and
    used the message variable to compose a string, which outputs the dimensions of
    our terminal, using the `tput` colors to format the output, which has a nice flag
    as a background. We used the various attributes in an unconventional way, but
    you can play with them and see what kind of output you can get.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个命令的输出存储在宽度和高度变量中，并使用消息变量来组成一个字符串，输出我们终端的尺寸，使用 `tput` 的颜色来格式化输出，背景有一个漂亮的旗帜。我们以非常规的方式使用了各种属性，但你可以自己尝试，看看能得到什么样的输出。
- en: Look into `man terminfo`, `man termcap`, and `man tput` to have an idea of all
    that you can do with `tput`. Continuing with the script, we get the length of
    the message and clear the script, clear the screen, and finally with `tput cup
    x y`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `man terminfo`、`man termcap` 和 `man tput`，了解你可以使用 `tput` 做的所有事情。继续编写脚本，我们获取消息的长度并清除脚本，清除屏幕，最后使用
    `tput cup x y`。
- en: 'We move the cursor to the right position to center the message on the terminal.
    We had to compensate the characters used for the `tput` attributes. Outside the
    function, we then use a trap that intercepts the window change signal sent to
    the process when the terminal, which controls it, changes its size. This way the
    trap will invoke the function box each time the user changes the size of the window,
    so the new height and width will be calculated and printed to the terminal. We
    left an infinite loop at the end, which kicks in play once the first box iteration
    has been completed: the infinite loop keeps the script running idle waiting for
    the winch signal to be trap. And as soon as it is trapped, the box function is
    called, a new height and width values calculated, and an up-to-date message is
    displayed.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将光标移动到正确的位置，以便将消息居中显示在终端上。我们需要补偿用于` tput` 属性的字符。在函数外部，我们使用一个陷阱，拦截发送到进程的窗口变化信号，当控制该进程的终端改变其大小时。这样，每次用户改变窗口大小时，陷阱就会调用`box`函数，从而计算并打印新的高度和宽度到终端。我们在最后留下了一个无限循环，一旦第一个框架迭代完成，它便开始执行：这个无限循环保持脚本处于空闲状态，等待窗口变化信号的捕获。一旦捕获到信号，就会调用`box`函数，计算新的高度和宽度，并显示最新的消息。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our scripts are starting to get more complex and ever interesting; we are moving
    from dealing with the shell to programming, to making something handy out of it.
    The next part of the book will dive into a bit of real-world programming, creating
    some applications that will show us how to create some sound and reliable tools
    for our everyday life as sysadmins or curious users.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本开始变得更加复杂且有趣；我们正在从处理Shell脚本转向编程，并利用它创造一些实用的东西。本书的下一部分将深入到一些实际编程，创建一些应用程序，展示如何为我们的日常生活作为系统管理员或好奇的用户，打造一些可靠且有用的工具。
