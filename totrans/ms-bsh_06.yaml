- en: Iterations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we have seen so far enables us to interact with the user, process the input,
    and provide some output based on conditions we imposed. All of this is fine; and
    if the user calls our scripts with some arguments, we can store them in an array
    and process given that we know how many options they are passing to the command
    line. We must know in advance how many items the user will provide us with, otherwise
    we will lose those in excess. This is where an iterative construct comes in play.
    Since we already saw some examples, it can enumerate the content of an array and
    let us process its content without knowing in advance the number of items stored.
    In this chapter, we will have a look at how to use the `for` loop and *while/until*
    loop to get a strong grip on the data the user provides us with.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop is one of the most used structures when it comes to a Bash script
    and enables us to repeat one of more actions on each single item in a list. Its
    basic structure can be outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we use a placeholder, which will take at each round of the loop one of
    the values in the list of items, which will then be processed in the `do` section.
    Once all the list is scanned through, the loop is done, and we exit it. Let''s
    start with a simple and nice example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, quite straightforward, but notice that the list can be the result
    of any kind of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we used a brace expansion to get a countdown with a step of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have a `for` loop on one line as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, isn''t it? Now let''s do something a bit more complex. Let''s say we
    want to write the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we do this? Let''s try with a simple loop and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Not exactly what we wanted. Well, not at all because the script does not know
    how to tell what is a city, what is a nation, and what goes with what. We have
    to find a way to qualify our items; and we can do it using their position. Here
    we have the set built-in, which enables us to assign the content of a variable
    to a positional parameter. We will just use it in a fancy way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much better, and it is exactly what we were looking for; but how did
    we reach our goal? The first step was grouping the related items into double quotes,
    so for instance, `Belfast` goes with `UK`. The tricky part was using the set built-in
    with `--`, which forces the values following it to be assigned to positional parameters
    even though they start with a dash and if no arguments are given the positional
    parameters get unset. So, since we have groups of two: city and nation, we have
    `$1` and `$2`; one holding the city and the other having the nation. From there
    on, it was just a matter of printing the positional parameters. We can go even
    further without specifying a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can provide the arguments on the command line; the script will take
    its input from `$@)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed before, the list can be anything: a variable, a brace expression,
    fixed values, the result of a command substitution, anything that creates a list
    of value through which we iterate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the list is provided by the counter function, which prints
    out the result of a brace expansion. We then take the value returned by the function
    through the `echo` command and use it as a list to iterate on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget the C-style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have a decreasing counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What we saw so far allows us to cycle through structures of data and work on
    them as long as we have some items to process, but we do not know yet how to work
    on something until a condition is met or not, so this is the topic for the next
    paragraph where we will see how to keep our script alive until something happens.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do something while, until…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop is a great option to enumerate the contents provided by the
    user, but it is not so handy when it comes to handling a number of options whose
    number is not known beforehand. In this case, we would find more interesting kinds
    of loops, which would allow us to cycle until a certain condition is met or while
    a certain situation persists, for instance, while the user inputs something or
    until a threshold is met. So, let''s see which constructs can help us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At a first glance, the difference between the `while` and `for` loops is evident:
    the latter is based on a placeholder that each time takes a value from a list
    and we work on that value, the former is triggered while conditions last. Let''s
    make an example starting with a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a simple counter, from 1 to 5, and we already saw it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s rewrite it using a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see if the output is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the output is exactly the same. Now, we will speak about another loop
    constructor, the `until` loop, which cycles on a list until a condition is met.
    Its structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure is similar to the `while` loop, just the conditions change: `while`
    lasts as long as a condition is met, `until` lasts until a condition is met. To
    better understand the difference, let''s rewrite the example in the `until` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the code, until we do not reach a value of `i` higher than
    `5`, we print its value and increase it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks familiar, doesn''t it? So we can recap the three kinds of loop under
    the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for` iterates on the values taken from a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while` executes the loop until the condition is `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`until` executes the loop while the condition is `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting the loop with break and continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This gives us some nice opportunities, such as infinite loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `true` always evaluates as true, the condition is always verified so
    we have an infinite execution of the `do/done` clause; press *Ctrl+ C* to exit
    from the loop. An infinite loop looks like something nasty, but it opens a new
    scenario for our scripts, since we can make them run or wait for something for
    as long as we want. Actually, if we do not use a couple of loop control commands:
    `break` will exit the loop and `continue` will restart it, jumping over the remaining
    commands. Let''s see an example of creating a hypothetical backup program menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what we did. We opened a `while true` loop, so whatever is inside
    it will be executed over and over. We then used a *here* document to have a nice
    menu to display to the user and a `read` option to ask the user for a choice to
    evaluate the input. Any choice except for `quit` will do nothing but display a
    message and wait for 3 seconds, after which the cycle restarts, clearing the screen
    and showing the menu once again (this is the reason for the `sleep` command).
    The only exception is if the customer hits `0`,`Q`, or `q`: in this case a message
    is displayed and the loop is exited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we exit a loop, not necessarily the entire script. This is a nice
    old style menu, which has its advantages over graphical ones: easier to code,
    easier to maintain, and less resources consumed, but most of all, it does not
    require a graphical monitor to be displayed: it works well on character monitors
    and over serial connections. For the `continue` instruction, the action flow is
    quite different, since it resumes iteration for the main `for`, `while`, `until`,
    or `select` loop. When used in a `for` loop the variable takes the value of the
    next element in the list of conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code will enumerate from 0 to 10 and print the values met, except when
    it hits the number 4: in this case, the `continue` will force the `for` loop to
    skip the value and proceed from 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Time to give our client a menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are looking at different ways to play with loops in order
    to work on the pieces of information the user provides us with. From a simple
    menu, we moved onto something fancier and better looking; and now, it is time
    to take a step further and have a look at the `select` construct whose task is
    to let us create menu in an effortless way. Its syntax is similar to the for construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as we can see, this construct is very similar to `for` and sports a list,
    which gets expanded on the standard error in a series of elements preceded by
    a number. If we omit the `in list` part, the list gets constructed from the positional
    parameters given on the command line, such as if we used `[in $@]`. Once the elements
    in the list are printed, a `PS3` prompt is shown and a line from the `stdin` is
    read and stored into the REPLY variable. If something is read on the line, each
    word is displayed along with a number; if the line is empty the prompt is displayed
    again, but `if` and `EOF` characters are given as an input (*Ctrl+D*) the loop
    is exited. As a shortcut, you can use `break` to exit. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This easy script will show you a menu of choices taken from the `in list` and
    wait for a selection. Once the user inputs a selection, it is echoed and the loop
    starts again showing the available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, there is no control on what the user provided us with, so this
    is something we have to implement by ourselves. Also, the prompt is the least
    sexy thing we have ever seen, but we can alter it giving a value to the `PS3`
    variable, so just add `PS3="Your choice is: "` right below the sha-bang. Save
    and rerun the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Way better now. Great, now another small issue: the script never exits, so
    how can we force it to exit? Let''s see some interesting modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We nested a case construct inside the `select` so that we can evaluate the
    choice given by the user and react accordingly. In any case, we just print out
    the choice made by the user, but if he selects `4`, we print the choice and exit
    with `break`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can do something more interesting than this, especially if we want to
    interact with the system. Let''s again aim to make a backup script and take advantage
    of what we just did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `while true` to make the main loop so that the script will be always
    running unless we explicitly exit from it, then with a *here* document, we show
    a neat menu to the user and then a case construct to provide a way to evaluate
    the answers given by the user in the next step. The first option in the `case`
    statement clears the screen and embeds a select structure, also it provides a
    list of files to work on using a filename expansion. Since we do not know in advance
    how many files we will have in the current directory, and we cannot modify the
    list, we can rely on a trick, creating a file called `EXIT` at the beginning of
    the script and deleting at the end of it. The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And select option 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The files are automatically numbered along without the EXIT placeholder. The
    files in the directory are all numbered, and our EXIT strategy shows up even though
    it is not the last option; but renaming it would allow us to place it wherever
    we want. Inside `select`, we find another case, since we want to evaluate the
    answer given by the user and work on the right file. So, if the user does not
    select the option corresponding to EXIT, we do not break out from the loop clearing
    out the file, but proceed by compressing it and exiting to the main loop, which
    will show up the main menu. All of this is nice, but did you realize that there
    is a big issue at play here? What happens if you select one option that is not
    really available in the select menu?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, it is to be expected since we did not provide a real check on the input,
    or better, we are checking only what we expected to receive, not the unexpected.
    So let''s modify the default option for the inner case statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply added a check to the content passed through `$file variable`: if
    the variable does not hold anything and does not point to any filename, we display
    a message, wait for three seconds, and then restart the loop. We could also use
    read instead of just waiting to force the user to press a key to continue; and
    this would leave the warning message displayed until the user reacts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the various examples, there is more than one way to create
    a user menu in Bash; and in the coming chapters, we will use them and make them
    even more fancier. But talking about user interaction, we have one topic left
    to face and it is quite interesting: dealing with how to manage the command line
    argument passed to our scripts. So, if we do not want to show a menu, but want
    to receive arguments on the command line, how do we do it? We already saw something,
    but there is a nice built-in that can ease our job, so it is time to have a look
    at `getops`.'
  prefs: []
  type: TYPE_NORMAL
- en: CLI, passing the arguments to the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Geopts is a Bash built-in widely used to efficiently parse switches and arguments
    passed on the command line of a script. We already saw other ways to accomplish
    this task, but getops makes it quite easy to handle it, since it can automatically
    recognize the switches and argument passed to the script. Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we pass to `getops` is a string of options, the classical `-a
    -x -f` of whatever you want, without any leading dash, such as `getops axf` or
    also `getops ax:f`. If you see an option followed by a colon, this means that
    the option is meant to have an argument such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, `-x` has an argument while `-a` is a simple switch, or we can
    also call it **flag** that can just be there or not, but it does not require any
    arguments. The options can be specified as lower or upper characters or digits.
    The `getops` built-in has some predefined variables for its internal use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OPTARG` holds the argument for an option or the flag for an unknown option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTBIND` holds the index for the next option to parse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTERR` holds 0 or 1 and sets the display of error messages from `getops`.
    The default value is 1, so messages are displayed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As it is quite clear, `getops` is useful for parsing short options, but it
    cannot process the long style options, so `-a` is okay, but `--all `will not be
    parsed. It''s a limit, but it is just a matter of style. Let''s see a simple example
    and by commenting on it, we will have a look at how `getops` works on the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our script starts with a while loop, and this is due to the fact that `getops`
    exits with a status called `fail` when there is nothing to parse, and this condition
    is met when it reaches the first non option argument or when it hits a `--`. Next,
    we see the `getops` built-in followed by `ax:f`, which means it expects this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`getops` will read all the options up to the first non-option argument and
    store them in a variable that in our case is named option. Now, the last part
    is a bit tricky. Have a look at `getopts ":ax:f"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice`:` before the first option? It disables the standard error messages
    for getops and alters the way the standard variables are used.
  prefs: []
  type: TYPE_NORMAL
- en: In case of an invalid option, the variable (`option` in our example) is used
    to store the `?` character, which highlights the error; and `OPTARG` is instanced
    with the invalid character provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of an argument, the variable is instanced with a colon `:` and `OPTARG`
    holds the option character. Let''s run this script with the different options
    to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, but do not get fooled, we have two main issues here, do you see them?
    Let''s have a look at the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, no switches were given, no output at all, and this is not good at all:
    remember not to leave your user without a feedback, never. Always have your script
    to show something to the user, so he knows he did something and will not try to
    invoke it repeatedly. We can manage this situation adding just before the while
    loop a small fragment of code, which counts the arguments on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special, we just checked if the number of arguments passed to the command
    line is equal to `0` and whether this is the case we echo a message and exit with
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`Hello` is an argument passed to the command line, but `-a` does not accept
    the `options` argument, so how do we retrieve `Hello`? Notice that there is a
    difference between these two invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `Hello` is the argument of an option and the second is a simple argument
    on the command line, which is not related to an option, since `-a` does not accept
    any arguments. And so, we were able to reach `Hello` the first time, but not on
    the second scenario. How can we overcome this limitation? Let''s rewrite the previous
    example adding the following lines at the end of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we are. Notice the use of shift that helped us in retrieving the argument;
    this trick is based upon the value hold by `OPTIND`, which corresponds to the
    number of options parsed by the last call of `getops`. If we recall how `getops`
    works: each time it is invoked, it puts the next option in the variable used to
    hold them, initializing it if does not exist and the index of the next argument
    to parse into the `OPTIND` variable. So, `OPTIND` at the first run has `1` as
    its argument. Bear in mind that `OPTIND` is never reset by the shell, so if you
    have to make multiple calls to `getops`, it is up to you to reinitialize the variable
    to `1`. Then, we use shift to deal with the positional parameter, since this built-in
    is able to shift the positional parameters on the left by the number specified
    as its argument. So `shift "$((OPTIND-1))"` shifts the positional parameter of
    the next argument of `getops` back to one position. Let''s rewrite a part of the
    previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'But at the end of the script, we have this left on the command line: `Hello`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens? When you run the script, `OPTIND` starts with a value of
    `1` and gets incremented by `1` each time `getops` gets called. So, since we have
    two options to process on the command line, at the end of the `getops` loop, the
    value of `OPTIND` will be 2+1, so we have 3\. Now, if we shift the command line
    of `"$((OPTIND-1))"`, it means that we move the command-line arguments of 2 slots
    (3-1) to the left. Bear in mind that when you shift the positional arguments to
    the left, they get essentially lost and so what you are left with is the rest
    of the arguments. In our case, if we move the positional arguments of 2 on the
    left, we get rid of `-f` and `-a`; and we are left with the first non-option argument,
    `"Hello"`. Here we are! If we now print the content of the command line `$@` after
    the loop, we are left exactly with `Hello`. Now, it''s time to build up the tools
    we will use in the next chapters and pull together all the bits and parts you
    learned so far. First things first: the script will become more complex, and it
    will tend to clutter a bit, so if we recall what we saw in the first chapters
    about sourcing a file, what we will do now is create a library to hold all the
    common functions and settings that we are going to use frequently. Adopting this
    style will help to keep our scripts neat and simple and to master their content
    with less effort. So, first things first, let''s create a library file that we
    will call `library.lib` and start writing some functions in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s rewrite the first part of the previous script in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And time to run the script without any options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the check on the zero length input has been moved to the library,
    then sourced back to the main script. So, now, we have two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Less rows in our primary script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `non_zero_function` is now available to all the scripts that will source
    the library we just created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But now, it is time for something fancy. Ever wanted to give some spice to
    your output? Just modify this library in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We added some ANSI color code to our library assigning them to a meaningful
    variable name and also created a small `color_print` function. ANSI escape code
    or sequences are methods to manage colors and attributes on text terminals and
    are represented by a string starting with the ESC character (033 in octal), followed
    by a character between 64 to 95 in the ASCII range. W just added a few foreground
    colors, but by googling, you will find a lengthy list of escaped characters that
    you can assign to background colors, bold characters, reverse, and so forth. The
    `color_print` function is just a tiny example of what can be done with these control
    codes and it makes use of `printf`, which is a bit more flexible than `echo` even
    though `echo -e` will deal with escaped characters and will be good enough to
    print colors and attributes. Notice that the `color_print` functions ends `printf`
    with  `''33[0m''`, which is a reset control character that will revert to default
    all the changes you made to the output: once you modify a color or an attribute,
    everything will be printed with that alteration until you explicitly reset to
    default using the reset escape sequence. Now, it is time to take advantage of
    what we just saw and modify the script we just created so that it ends this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two different examples on how to use the escape codes to manage the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The word `But` is preceded by the value of the variable `Green` that we sourced
    from the library and it is closed by the `CReset` variable value, so echo will
    turn the output to green foreground right before writing `But` and revert to the
    standard color, usually white, right after thanks to the reset escape sequence.
    Then, right before printing the command-line arguments, it switches to `Red` to
    revert back once finished. The last line is printed using the `color_print` function
    sourced from the library file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the function definition, it accepts two arguments, the escape
    code and the string to print trailing them with a reset code; in our case we selected
    `Yellow`, so let''s see what is the outcome in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inline escape codes or ad hoc functions kicks up our output
  prefs: []
  type: TYPE_NORMAL
- en: 'Nice, isn''t it? There are actually many ways to color your output using Bash,
    from interacting with the dialog program, which will give you curses such as interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a simple message box, which reminds me of the old Linux installers to
    zenity that will give you a GTK+ interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Zenity allows you to create beautiful interfaces using GTK+ decorations
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can use depends on the level of interaction we want to have with the
    customer; for instance, scripts dealing with services probably will not need any
    fancy stuff. And on our concerns about portability: to use dialog and zenity you
    have to install them; they are not shipped by default with a Linux system. For zenity,
    keep in mind that it only show its goodness on a graphical interface; if you go
    over serial or text-based terminals, it will show you curses such as interface
    at best. If you want to use something more advanced than ANSII escape code, you
    can resort to the `tput` command, which is shipped with Linux; and by using the
    `terminfo` or `termcap` databases, it enables you to interact with the terminal
    in a more interesting way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An auto updating message displayed using tput
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple script uses `tput` with a series of numbers to change the color
    of the output.`tput setaf x` sets the foreground color to the value corresponding
    to the `x` integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'For the background, we use `tput setbg x` with the same list of codes. We used
    the command substitution to get the output of the command and use it with `printf`
    to modify the output accordingly. The values for the rest of the `tput` commands
    are quite obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tput smso` enters the standout mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tput rmso` exits the standout mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tput dim` makes the output less bright'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tput sgro` reverts back to the standard terminal output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tput cvis` hides the cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we created a function named `box`, which hides the cursor, and then sets
    the background to blue. The interesting parts are here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tput cols` gets the number of columns of the terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tput lines` gets the number of lines of the terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We stored the output of the two commands in the width and height variables and
    used the message variable to compose a string, which outputs the dimensions of
    our terminal, using the `tput` colors to format the output, which has a nice flag
    as a background. We used the various attributes in an unconventional way, but
    you can play with them and see what kind of output you can get.
  prefs: []
  type: TYPE_NORMAL
- en: Look into `man terminfo`, `man termcap`, and `man tput` to have an idea of all
    that you can do with `tput`. Continuing with the script, we get the length of
    the message and clear the script, clear the screen, and finally with `tput cup
    x y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We move the cursor to the right position to center the message on the terminal.
    We had to compensate the characters used for the `tput` attributes. Outside the
    function, we then use a trap that intercepts the window change signal sent to
    the process when the terminal, which controls it, changes its size. This way the
    trap will invoke the function box each time the user changes the size of the window,
    so the new height and width will be calculated and printed to the terminal. We
    left an infinite loop at the end, which kicks in play once the first box iteration
    has been completed: the infinite loop keeps the script running idle waiting for
    the winch signal to be trap. And as soon as it is trapped, the box function is
    called, a new height and width values calculated, and an up-to-date message is
    displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our scripts are starting to get more complex and ever interesting; we are moving
    from dealing with the shell to programming, to making something handy out of it.
    The next part of the book will dive into a bit of real-world programming, creating
    some applications that will show us how to create some sound and reliable tools
    for our everyday life as sysadmins or curious users.
  prefs: []
  type: TYPE_NORMAL
