<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating Interactive Scripts</h1>
                </header>
            
            <article>
                
<p>In <a href="f439f212-0f5f-4c9d-abdb-9f9b8c199a78.xhtml" target="_blank">Chapter 1</a>, <em>The What and Why of Scripting with Bash</em>, we learned how to create a script and use some of its basic elements. These included optional parameters that we can pass through to the script when it is executed. In this chapter, we will extend this by using the shell's built-in <kbd>read</kbd> command to allow for interactive scripts. Interactive scripts are scripts that prompt for information during the script's execution.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Using <kbd>echo</kbd> with options</li>
<li>Basic script using <kbd>read</kbd></li>
<li>Script comments</li>
<li>Enhancing read scripts with <kbd>read</kbd> prompts</li>
<li>Limiting the number of entered characters</li>
<li>Controlling the visibility of the entered text</li>
<li>Passing options</li>
<li>Read options values</li>
<li>Try to be standard</li>
<li>Enhancing learning with simple scripts</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The source code for this chapter can be downloaded from here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter02">https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter02</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using echo with options</h1>
                </header>
            
            <article>
                
<p>So far, in this book we have been able to see that the <kbd>echo</kbd> command is very useful and is going to be used in many of our scripts, if not all of them. When running the <kbd>echo</kbd> command, the built-in command will be used unless we state the full path to the file. We can test this with the following command:</p>
<pre><strong>$ which echo</strong></pre>
<p>To gain help on the built-in command, we can use man bash and search for <kbd>echo</kbd>; however, the <kbd>echo</kbd> command is identical to the internal command, so we recommend that you use man echo in most cases in order to display the command options.</p>
<p>The basic use of <kbd>echo</kbd> that we have seen so far will produce a text output and a new line. This is often the desired response, so we don't need to be concerned that the next prompt will append to the end of the echoed text. The new line separates the script output from the next shell prompt. If we do not supply any text string to print, <kbd>echo</kbd> will print only the new line to <kbd>STDOUT</kbd>. We can test this with the following command, directly from the command line. We do not need to run <kbd>echo</kbd> or, in fact, any other command from a script. To run <kbd>echo</kbd> from the command line, we simply enter the command as shown:</p>
<pre><strong>$ echo</strong></pre>
<p>The output will show a clear new line between the command we issued and the subsequent prompt. We can see this in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-215 image-border" src="assets/efb1c784-4e60-46cd-81ad-bbd50cace4c3.png" style="width:11.83em;height:4.25em;"/></div>
<p>If we want to suppress the new line, which is especially useful if we are to prompt users, we can do this in the following two ways, with the help of <kbd>echo</kbd>:</p>
<pre><strong>$ echo -n "Which directory do you want to use? "</strong><br/><strong>$ echo -e "Which directory do you want to use? \c"</strong></pre>
<p>The result will be to suppress the line feed. In the initial example, the <kbd>-n</kbd> option is used to suppress the line feed. The second example uses the more generic <kbd>-e</kbd> option, which allows escape sequences to be added to the text string. To continue on the same line, we use <kbd>\c</kbd> as the escape sequence.</p>
<p class="NormalPACKT" style="margin: 3.0pt 0cm .0001pt 0cm"><span>This does not look great as the final part of the script or when it is run from the command line, as the command prompt will follow. This is illustrated in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-216 image-border" src="assets/da374c15-d11a-42ff-bc0c-f4c957d812a6.png" style="width:37.42em;height:3.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic script using read</h1>
                </header>
            
            <article>
                
<p>When used as part of a script that prompts for user input, the suppression of the line feed is exactly what we want. We will begin by copying the existing <kbd>hello2.sh</kbd> script to <kbd>hello3.sh</kbd> and build an interactive script. Initially, we will use <kbd>echo</kbd> as the prompt mechanism, but, as we gradually enhance the script, we will generate the prompt directly from the shell built-in <kbd>read</kbd> command:</p>
<pre><strong>$ cp $HOME/bin/hello2.sh $HOME/bin/hello3.sh</strong><br/><strong>$ chmod +x $HOME/bin/hello3.sh</strong></pre>
<p>Edit the <kbd>$HOME/bin/hello3.sh</kbd> script so that it reads as follows:</p>
<pre>#!/bin/bash<br/>echo -n "Hello $(basename $0)! May I ask your name: "<br/>read<br/>echo "Hello $REPLY"<br/>exit 0</pre>
<p>As we execute the script, we will be greeted and prompted with whatever is typed. This is echoed using the <kbd>$REPLY</kbd> variable in the echo statement. As we have not yet supplied a variable name to the read built-in command, the default <kbd>$REPLY</kbd> variable is used. The script execution and output are shown in the following screenshot. Take some time to practice the script on your own system.</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-218 image-border" src="assets/1f745d37-3805-4fc8-ba30-a6672c7a4e87.png" style="width:26.92em;height:7.25em;"/></div>
<p>This little step has taken us a long way and there are many uses for a script like this; we have all used installation scripts that prompt for options and directories as we run through the install. We accept that it is still quite trivial, but, as we delve into the chapter, we will get closer to some more useful scripts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Script comments</h1>
                </header>
            
            <article>
                
<p>We should always introduce commenting scripts early in the piece. A script comment is prefaced with a <kbd>#</kbd> symbol. Anything after the # symbol is a comment and is not evaluated by the script. The shebang, <kbd>#!/bin/bash</kbd>, is primarily a comment and, as such, is not evaluated by the shell. The shell running the script reads the whole shebang, so it knows which command interpreter to hand the script over to. A comment may be at the start of a line or partway into the line. Shell scripting does not have the notion of multi-line comments.</p>
<p>If you are not already familiar with comments, then please note that they are added to the script to describe who wrote the script, when it was written and last updated, and what the script does. They are the metadata of the script.</p>
<p>The following is an example of comments in scripts:</p>
<pre>#!/bin/bash<br/># Welcome to bash scripting<br/># Author: Mokhtar<br/># Date: 1/5/2018</pre>
<p>It is good practice to comment, and add comments that explain what the code is doing and why. This will help you and your colleagues who need to edit the script at a later date.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhancing scripts with read prompts</h1>
                </header>
            
            <article>
                
<p>We have seen how we can use the built-in read to populate a variable. So far, we have used echo to produce the prompt, but this can be passed to read itself using the <kbd>-p</kbd> option. The <kbd>read</kbd> command will surpass the additional linefeed, so we reduce both the line count and the complexity to some degree.</p>
<p>We can test this at the command line itself. Try typing the following command to see <kbd>read</kbd> in action:</p>
<pre><strong>$ read -p "Enter your name: " name</strong></pre>
<p>We use the <kbd>read</kbd> command with the <kbd>-p</kbd> option. The argument that follows the option is the text that appears in the prompt. Normally, we would make sure that there is a trailing space at the end of the text to ensure that we can clearly see what we type. The last argument supplied here is the variable we want to populate; we simply call it name. Variables are case-sensitive too. Even if we do not supply the last argument, we can still store the user's response, but this time in the <kbd>REPLY</kbd> variable.</p>
<div class="packt_infobox">When we return the value of a variable, we use <kbd>$</kbd>, but not when we write it. In simple terms, when reading a variable we refer to <kbd>$VAR</kbd> and when setting a variable we refer to <kbd>VAR=value</kbd>.</div>
<p>The <kbd>read</kbd> command with syntax using the <kbd>-p</kbd> option is shown as follows:</p>
<pre>read -p &lt;prompt&gt; &lt;variable name&gt;</pre>
<p>We can edit the script so that it appears similar to the following extract from <kbd>hello3.sh</kbd>:</p>
<pre>#!/bin/bash<br/>read -p "May I ask your name: " name<br/>echo "Hello $name"<br/>exit 0</pre>
<p>The <kbd>read</kbd> prompt cannot evaluate commands within the message string, such as those we used before.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limiting the number of entered characters</h1>
                </header>
            
            <article>
                
<p>We have not needed this functionality in the scripts we have used so far, but we may need to ask users to hit any key to continue. At the moment, we have set it up in such a way that the variable is not populated until we hit the <em>Enter</em> key. Users have to hit <em>Enter</em> to continue. If we use the <kbd>-n</kbd> option followed by an integer, we can specify the number of characters to accept before continuing; we will set <kbd>1</kbd> in this case. Take a look at the following code extract:</p>
<pre>#!/bin/bash<br/>read -p "May I ask your name: " name<br/>echo "Hello $name"<br/>read -n1 -p "Press any key to exit"<br/>echo<br/>exit 0</pre>
<p>Now the script will pause after displaying the name until we press any key; we can literally press any key before continuing, as we accept just 1 key stroke, whereas earlier we were required to leave the default behavior in place, as we could not know how long an entered name would be. We have to wait for the user to hit <em>Enter</em>.</p>
<div class="packt_infobox">We add an additional echo here to ensure that a new line is issued before the script ends. This ensures that the shell prompt starts on a new line.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling the visibility of the entered text</h1>
                </header>
            
            <article>
                
<p>Even though we have limited the input to a single character, we do get to see the text on the screen. In the same way, if we type the name, we get to see the entered text before we hit <em>Enter</em>. In this case, it is just untidy, but if we are entering sensitive data, such as a PIN or a password, we should hide the text. We can use the silent option, or <kbd>-s</kbd>, to achieve this. A simple edit in the script will set this in place:</p>
<pre>#!/bin/bash<br/>read -p "May I ask your name: " name<br/>echo "Hello $name"<br/>read -sn1 -p "Press any key to exit"<br/>echo<br/>exit 0</pre>
<p>Now, when we use a key to continue, it will not be displayed on the screen. We can see the behavior of the script in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-219 image-border" src="assets/8a3a1c4d-d287-4f35-9209-34a0d28f59fc.png" style="width:33.58em;height:6.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing options</h1>
                </header>
            
            <article>
                
<p><span>So far, we have seen in the first chapter how to read parameters from the user. Also, you can pass options. So, what are options? And how are they different from parameters?</span></p>
<div>
<p>Options are characters with a single dash before them.</p>
<p>Check out this example:</p>
<pre><strong>$ ./script1.sh -a</strong></pre>
<p>The <kbd>-a</kbd> is an option. You can check from your script if the user entered this option; if so, then your script can behave in some manner.</p>
<p>You can pass multiple options:</p>
<pre><strong>$ ./script1.sh -a -b -c</strong></pre>
<p>To print these options, you can use the <kbd>$1</kbd>, <kbd>$2</kbd>, and <kbd>$3</kbd> variables:</p>
<pre>#!/bin/bash<br/>echo $1<br/>echo $2<br/>echo $3</pre></div>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-222 image-border" src="assets/00112873-5c8f-48e9-bbe6-da929c24c9ec.png" style="width:33.17em;height:9.33em;"/></div>
<div>
<p>We should check these options, but, since we haven't discussed conditional statements yet, we will keep it simple for now.</p>
<p>Options can be passed with a value, like this:</p>
<pre><strong>$ ./script1.sh -a -b 20 -c</strong></pre>
<p>Here the <kbd>-b</kbd> option is passed with a value of <kbd>20</kbd>.</p>
</div>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-223 image-border" src="assets/f49ffb2c-345c-4111-a6bf-7299bae26f75.png" style="width:32.92em;height:10.00em;"/></div>
<p>As you can see, the variable <kbd>$3=20</kbd>, which is the passed value.</p>
<p>This might not be acceptable to you. You need <kbd>$2=-b</kbd> and <kbd>$3=-c</kbd>.</p>
<p>We will use some conditional statements to get these options correct.</p>
<pre>#!/bin/bash<br/>while [ -n "$1" ]<br/>do<br/>case "$1" in<br/>-a) echo "-a option used" ;;<br/><span>-b) echo "-b option used" ;;<br/></span><span>-c) echo "-c option used" ;;<br/></span><span>*) echo "Option $1 not an option" ;;<br/></span><span>esac<br/></span><span>shift<br/></span><span>done</span></pre>
<p>If you don't know about the while loop, it's not a problem; we will discuss conditional statements in detail in the coming chapters.</p>
<p>The <kbd>shift</kbd> command shifts the options one step to the left.</p>
<p>So, if we have three options or parameters and we use the <kbd>shift</kbd> command:</p>
<ul>
<li><kbd>$3</kbd> becomes <kbd>$2</kbd></li>
<li><kbd>$2</kbd> becomes <kbd>$1</kbd></li>
<li><kbd>$1</kbd> is dropped</li>
</ul>
<p>It's like an action to move forward while iterating over the options using the while loop.</p>
<p>So, in the first loop cycle, <kbd>$1</kbd> will be the first option. After shifting the options, <kbd>$1</kbd> will be the second option and so on.</p>
<p>If you try the previous code, you will notice that it still doesn't identify the values of options correctly. Don't worry, the solution is coming; just wait a little longer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing parameters with options</h1>
                </header>
            
            <article>
                
<p>To pass parameters along with options simultaneously, you must separate them with a double dash, like this:</p>
<pre><strong>$ ./script1.sh -a -b -c -- p1 p2 p3</strong></pre>
<p>Using the previous technique, we can iterate over the options till we reach the double dash, then we will iterate over the parameters:</p>
<pre>#!/bin/bash<br/>while [ -n "$1" ]<br/>do<br/>case "$1" in<br/>-a) echo "-a option found" ;;<br/>-b) echo "-b option found";;<br/>-c) echo "-c option found" ;;<br/>--) shift<br/>break ;;<br/>*) echo "Option $1 not an option";;<br/>esac<br/><span>shift<br/></span><span>done<br/></span><span>#iteration over options is finished here.<br/></span><span>#iteration over parameters started.<br/></span><span>num=1<br/></span><span>for param in $@<br/></span><span>do<br/></span><span>echo "#$num: $param"<br/></span><span>num=$(( $num + 1 ))<br/></span><span>done</span></pre>
<p>Now if we run it with parameters and options combined, we should see a list of options and another list of parameters:</p>
<pre><strong>$ ./script1.sh -a -b -c -- p1 p2 p3</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-224 image-border" src="assets/bc37cb87-8604-4816-8a01-d35bbfcbe25f.png" style="width:41.83em;height:11.83em;"/></div>
<p class="NormalPACKT" style="margin: 3.0pt 0cm .0001pt 0cm"><span>As you can see, anything passed after the double dash is treated as a parameter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Read options values</h1>
                </header>
            
            <article>
                
<p>We have seen how to identify options and parameters, but we still need a way to read the options values correctly.</p>
<p>You may need to pass a value for a specific option. How can this value be read?</p>
<p>We will check for the <kbd>$2</kbd> variable while the iteration goes through the options that we expect a value for.</p>
<p>Check the following code:</p>
<pre>#!/bin/bash<br/>while [ -n "$1" ]<br/>do<br/>case "$1" in<br/>-a) echo "-a option passed";;<br/>-b) param="$2"<br/>echo "-b option passed, with value $param"<br/>shift ;;<br/>-c) echo "-c option passed";;<br/>--) shift<br/>break ;;<br/>*) echo "Option $1 not an option";;<br/>esac<br/>shift<br/>done<br/>num=1<br/>for param in "$@"<br/>do<br/>echo "#$num: $param"<br/>num=$(( $num + 1 ))<br/>done</pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-225 image-border" src="assets/f03655e1-78fb-4bc8-99f1-ee6f69db10f8.png" style="width:36.33em;height:9.58em;"/></div>
<p>This looks good now; your script identifies the options and the passed value for the second option.</p>
<p>There is a built-in option for getting options from the users, which is using the <kbd>getopt</kbd> function.</p>
<p>Unfortunately, <kbd>getopt</kbd> doesn't support options with more than one character.</p>
<p>There is a non-built-in program called <kbd>getopt</kbd>, which supports options larger than one character, but, again, the macOS X version doesn't support long options.</p>
<p>Anyway, if you would like to read more about <kbd>getopt</kbd> usage, refer to the further reading resources given after this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Try to be standard</h1>
                </header>
            
            <article>
                
<p>You may use bash scripts from GitHub, and you may notice that there is a standard option scheme that is followed. It's not required, but it is preferable.</p>
<p>These are some of the commonly used options:</p>
<ul>
<li><kbd>-a</kbd>: List all items</li>
<li><kbd>-c</kbd>: Get a count of all items</li>
<li><kbd>-d</kbd>: Output directory</li>
<li><kbd>-e</kbd>: Expand items</li>
<li><kbd>-f</kbd>: Specify a file</li>
<li><kbd>-h</kbd>: Show the help page</li>
<li><kbd>-i</kbd>: Ignore the character case</li>
<li><kbd>-l</kbd>: List a text</li>
<li><kbd>-o</kbd>: Send output to a file</li>
<li><kbd>-q</kbd>: Keep silent; don't ask the user</li>
<li><kbd>-r</kbd>: Process something recursively</li>
<li><kbd>-s</kbd>: Use stealth mode</li>
<li><kbd>-v</kbd>: Use verbose mode</li>
<li><kbd>-x</kbd>: Specify an executable</li>
<li><kbd>-y</kbd>: Accept without prompting me</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhancing learning with simple scripts</h1>
                </header>
            
            <article>
                
<p>Our scripts are still a little trivial, and we have not looked at conditional statements so we can test for correct input, but let's take a look at some simple scripts that we can build with some functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backing-up with scripts</h1>
                </header>
            
            <article>
                
<p>Now that we have created some scripts, we may want to back these up to a different location. If we create a script to prompt us, we can choose the location and the type of files that we want to backup.</p>
<p>Consider the following script for your first practice. Create the script and name it <kbd>$HOME/backup.sh</kbd>:</p>
<pre>#!/bin/bash<br/># Author: @theurbanpenguin<br/># Web: www.theurbapenguin.com<br/># Script to prompt to back up files and location<br/># The files will be search on from the user's home<br/># directory and can only be backed up to a directory<br/># within $HOME<br/># Last Edited: July 4 2015<br/>read -p "Which file types do you want to backup " file_suffix<br/>read -p "Which directory do you want to backup to " dir_name<br/># The next lines creates the directory if it does not exist<br/>test -d $HOME/$dir_name || mkdir -m 700 $HOME/$dir_name<br/># The find command will copy files the match the<br/># search criteria ie .sh . The -path, -prune and -o<br/># options are to exclude the backdirectory from the<br/># backup.<br/>find $HOME -path $HOME/$dir_name -prune -o \<br/>-name "*$file_suffix" -exec cp {} $HOME/$dir_name/ \;<br/>exit 0</pre>
<p>You will see that the file is commented; though, in black and white, the readability is a little difficult. If you have an electronic copy of this book, you should see the colors in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-226 image-border" src="assets/eae4e9df-999d-4a0a-b469-d3de9048748d.png" style="width:31.42em;height:19.08em;"/></div>
<p>As the script runs, you may choose <kbd>.sh</kbd> for the files to backup and backup as the directory. The script execution is shown in the following screenshot, along with a listing of the directory:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-227 image-border" src="assets/3c16ef07-c383-425a-8264-3c39feca6afe.png" style="width:31.58em;height:16.42em;"/></div>
<p>Now you can see that we can start to create meaningful scripts with trivial scripting; although we strongly urge adding error checking of the user input if this script is for something other than personal use. As we progress into the book, we will cover this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to a server</h1>
                </header>
            
            <article>
                
<p>Let's look at some practical scripts that we can use to connect to servers. Firstly, we will look at ping, and in the second script we will look at prompting for SSH credentials.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Version 1 – ping</h1>
                </header>
            
            <article>
                
<p>This is something we can all do, as no special services are required. This will simplify the <kbd>ping</kbd> command for console users who may not know the details of the command. This will ping the server for just three counts rather than the normal infinite amount. There is no output if the server is alive, but a failed server reports <kbd>sever dead</kbd>. Create the following script as <kbd>$HOME/bin/ping_server.sh</kbd>:</p>
<pre>#!/bin/bash<br/># Author: @theurbanpenguin<br/># Web: www.theurbapenguin.com<br/># Script to ping a server<br/># Last Edited: July 4 2015<br/>read -p "Which server should be pinged " server_addr<br/>ping -c3 $server_addr 2&gt;1 &gt; /dev/null || echo "Server Dead"</pre>
<p>The following screenshot shows successful and failed outputs:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-228 image-border" src="assets/6c3d2840-0f52-4c10-8c79-d168635d5c25.png" style="width:23.00em;height:8.92em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Version 2 – SSH</h1>
                </header>
            
            <article>
                
<p>Often SSH is installed and running on servers, so you may be able to run this script if your system is running SSH or you have access to an SSH server. In this script, we prompt for the server address and username, and pass them through to the SSH client. Create the following script as <kbd>$HOME/bin/connect_server.sh</kbd>:</p>
<pre>#!/bin/bash<br/># Author: @theurbanpenguin<br/># Web: www.theurbapenguin.com<br/># Script to prompt fossh connection<br/># Last Edited: July 4 2015<br/>read -p "Which server do you want to connect to: " server_name<br/>read -p "Which username do you want to use: " user_name<br/>ssh ${user_name}@$server_name</pre>
<div class="packt_infobox">Use of the brace bracket is to delimit the variable from the <kbd>@</kbd> symbol in the last line of the script.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Version 3 – MySQL/MariaDB</h1>
                </header>
            
            <article>
                
<p>In the next script, we will provide the detail for a database connection along with the SQL query to execute. You will be able to run this if you have a MariaDB or MySQL database server on your system, or one that you can connect to. For this demonstration, we will use Linux Mint 18.3 and MariaDB version 10; however, this should work for any MySQL server or MariaDB, from version 5 onwards. The script collects user and password information as well as the SQL command to execute. Create the following script as <kbd>$HOME/bin/run_mysql.sh</kbd>:</p>
<pre>#!/bin/bash<br/># Author: @theurbanpenguin<br/># Web: www.theurbapenguin.com<br/># Script to prompt for MYSQL user password and command<br/># Last Edited: July 4 2015<br/>read -p "MySQL User: " user_name<br/>read -sp "MySQL Password: " mysql_pwd<br/>echo<br/>read -p "MySQL Command: " mysql_cmd<br/>read -p "MySQL Database: " mysql_db<br/>mysql -u"$user_name" -p$mysql_pwd $mysql_db -Be"$mysql_cmd"</pre>
<p>In this script, we can see that we suppress the display of the MySQL password when we input it into the <kbd>read</kbd> command using the <kbd>-s</kbd> option. Again, we use <kbd>echo</kbd> directly to ensure that the next prompt starts on a new line.</p>
<p>The script input is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-229 image-border" src="assets/356f2b3d-3ee9-43f8-a629-81b7c1c4e83a.png" style="width:23.83em;height:15.67em;"/></div>
<p class="NormalPACKT" style="margin: 3.0pt 0cm .0001pt 0cm"><span>Now we can easily see the password suppression working and the ease of adding to the MySQL commands.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading files</h1>
                </header>
            
            <article>
                
<p>The <kbd>read</kbd> command is not only used to read inputs from the user; you can use the <kbd>read</kbd> command to read files for further processing.</p>
<pre>#!/bin/bash<br/>while read line<br/>do<br/>echo $line<br/>done &lt; yourfile.txt</pre>
<p>We redirect the file content to the <kbd>while</kbd> command to read the content using the <kbd>read</kbd> command, line by line.</p>
<p>Finally, we print the line using the <kbd>echo</kbd> command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Feel proud that you now have your <em>I can read</em> badge for shell scripting. We have developed our scripts to be interactive and to prompt users for input during the script execution. These prompts can be used to simplify user operations on the command line. In this way, they do not need to remember the command-line options or have passwords that end up stored in the command-line history. When using passwords, we can simply store the value using the read <kbd>-sp</kbd> options.</p>
<p>Also, we saw how to pass options with and without values, and how to identify values correctly. We saw how to pass options and parameters at the same time, thanks to the double dash.</p>
<p>In the next chapter, we will take our time to look at the conditional statements in bash.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How many comments are in the following code?</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash<br/># Welcome to shell scripting<br/># Author: Mokhtar</pre>
<ol start="2">
<li>If we have the following code:</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash<br/>echo $1<br/>echo $2<br/>echo $3</pre>
<p style="padding-left: 60px">And we run the script with these options:</p>
<pre style="padding-left: 60px"><strong>$ ./script1.sh -a -b50 -c</strong></pre>
<p style="padding-left: 60px">What is the result of running this code?</p>
<ol start="3">
<li>Check the following code:</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash<br/>shift<br/>echo $#</pre>
<p style="padding-left: 60px">If we run it with these options:</p>
<pre style="padding-left: 60px"><strong>$ ./script1.sh Mokhtar -n -a 35 -p</strong></pre>
<ol>
<li style="list-style-type: none">
<ol>
<li>What is the result?</li>
<li>What is the dropped parameter?</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Please see the following for further reading relating to this chapter:</p>
<ul>
<li><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_08_02.html">http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_08_02.html</a></li>
<li><a href="https://ss64.com/bash/read.html">https://ss64.com/bash/read.html</a></li>
<li><a href="http://www.manpagez.com/man/1/getopt/">http://www.manpagez.com/man/1/getopt/</a></li>
<li><a href="https://ss64.com/bash/getopts.html">https://ss64.com/bash/getopts.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>