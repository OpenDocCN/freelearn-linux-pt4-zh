- en: Chapter 9. Twitter Access Control System with Smart Card and RFID
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：使用智能卡和RFID的Twitter访问控制系统
- en: Identifying people or objects with a computer may seem like an easy task, but,
    in reality, there is a lot of technology behind the devices used to accomplish
    this task.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用计算机识别人员或物体可能看起来像是一项简单的任务，但实际上，完成这一任务的设备背后有着大量的技术。
- en: In this chapter, we are going to use a smart card reader and two kinds of RFID
    readers (a **Low Frequency** or **LF** reader suitable for short ranges and an
    **Ultra High Frequency** or **UHF** reader suitable for long ranges) in order
    to show different possibilities to implement a minimal identifying system for
    access control.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用智能卡读卡器和两种类型的RFID读卡器（适用于短距离的**低频**或**LF**读卡器，以及适用于长距离的**超高频**或**UHF**读卡器），以展示实现最小化识别系统用于访问控制的不同可能性。
- en: Once the detection has been done, the system will send a message to our Twitter
    account informing our followers about what is happening (in a normal case, we
    may lock or unlock something, but I decided to do something different).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成检测，系统将向我们的Twitter账户发送一条信息，通知我们的关注者发生了什么（在正常情况下，我们可能会锁定或解锁某些东西，但我决定做点不一样的事情）。
- en: The basics of functioning
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理基础
- en: The smart cards and the smart card readers, for example, are complex devices
    that are used everywhere nowadays, from our credit cards to our smartphones. The
    term smart card implies a set of technologies, including integrated circuits,
    microprocessors, memories, antennas, and so on, in the same integrated circuit,
    to form a microchip that is the heart of a smart card. On the other hand, the
    smart card readers are complex devices that can communicate with the cards and
    save data on it or return data to a computer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，智能卡和智能卡读卡器是复杂的设备，如今无处不在，从我们的信用卡到智能手机。智能卡一词意味着一套技术，包括集成电路、微处理器、存储器、天线等，这些都集成在同一个电路中，形成微芯片，成为智能卡的核心。另一方面，智能卡读卡器是复杂的设备，能够与卡片进行通信并在其上保存数据或将数据返回计算机。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reader can get more information regarding the smart card world by taking
    a look at [https://en.wikipedia.org/wiki/Smart_card.](https://en.wikipedia.org/wiki/Smart_card.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以通过查看[https://en.wikipedia.org/wiki/Smart_card](https://en.wikipedia.org/wiki/Smart_card)获取更多有关智能卡世界的信息。
- en: The evolution of smart cards are the **Radio-Frequency Identification** (**RFID**)
    devices that can be used to identify people or objects in a contactless form,
    starting from a few centimeters to several meters. The RFID readers and the corresponding
    tags (or transponders) are high technology radio devices that can exchange data
    to each other in order to accomplish identification tasks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 智能卡的发展是**射频识别**（**RFID**）设备的演变，这些设备可以用于以非接触的方式识别人员或物体，识别距离从几厘米到几米不等。RFID读卡器和相应的标签（或应答器）是高技术的无线设备，能够相互交换数据，从而完成识别任务。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reader can get more information regarding the **RFID** world by taking a
    look at [https://en.wikipedia.org/wiki/Radio-frequency_identification](https://en.wikipedia.org/wiki/Radio-frequency_identification).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以通过查看[https://en.wikipedia.org/wiki/Radio-frequency_identification](https://en.wikipedia.org/wiki/Radio-frequency_identification)来获取更多有关**RFID**世界的信息。
- en: This time, all the complexity of this project is inside the hardware devices
    (the smart card reader and the RFID readers) and their corresponding software
    managers, so we only have to write the code to get access to them and retrieve
    the data held in the smart cards or the RFID tags only.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，所有项目的复杂性都集中在硬件设备（智能卡读卡器和RFID读卡器）及其相应的软件管理器中，因此我们只需要编写代码以访问这些设备并获取智能卡或RFID标签中的数据。
- en: 'In order to show different techniques to manage an identification device, we''re
    going to write three programs (one per device) in three different programming
    languages. However, the result of all programs will be the same: when a well-defined
    person (or object) has been recognized, a message will be sent to our Twitter
    account.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示管理识别设备的不同技术，我们将编写三个程序（每个设备一个）使用三种不同的编程语言。然而，所有程序的结果都是相同的：当一个明确定义的人员（或物体）被识别时，系统将向我们的Twitter账户发送一条信息。
- en: To accomplish this last task, we're going to use a dedicated (and interesting)
    tool that allows the user to manage a Twitter account from the command line.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成最后的任务，我们将使用一个专用（且有趣的）工具，它允许用户通过命令行管理Twitter账户。
- en: 'Every identification system has its own characteristics; however:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个识别系统都有其独特的特点；然而：
- en: The solution with the smart card reader can be used, where the identification
    can be done by inserting a credit card (or something similar) somewhere for identification.
    This is not suitable for wireless applications. The smart card reader I'm going
    to use in my prototype is a USB device with a slot where the smart card must be
    inserted.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能卡读卡器的解决方案可以用于需要通过插入信用卡（或类似物品）进行身份识别的场合。这不适用于无线应用。我要在我的原型中使用的智能卡读卡器是一个USB设备，带有一个插槽，必须插入智能卡才能识别。
- en: The second solution, that is, the one with the RFID LF reader, can be used where
    the identification tasks need wireless, but where the distance between the object
    to identify and the reader is no more than a few centimeters. These kinds of devices
    are usually very simple, such as the one I'm going to use in my prototype. The
    RFID reader is connected with the host by a serial port, and it simply returns
    a string each time a tag is detected.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种解决方案，也就是使用RFID LF读卡器的方案，适用于需要无线识别任务，但对象与读卡器之间的距离不超过几厘米的场合。这类设备通常非常简单，比如我将在我的原型中使用的设备。RFID读卡器通过串口与主机连接，每当检测到标签时，它会简单地返回一个字符串。
- en: The last solution is implemented with a RFID UHF reader, that is, with a device
    that can detect tags in a wireless mode, as the preceding RFID LF reader does,
    but at a distance of several meters long. These UHF devices can be more complex
    than the LF ones, such as the one I'm going to use for my prototype. The RFID
    reader still uses a serial connection to talk with the host, but it implements
    a more elaborate protocol to exchange data.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的解决方案是通过RFID UHF读卡器实现的，也就是说，使用一种能够以无线模式检测标签的设备，类似于之前的RFID LF读卡器，但距离可达到几米远。这些UHF设备比LF设备更为复杂，例如我将在我的原型中使用的设备。RFID读卡器仍然使用串口连接与主机通信，但它实现了一种更复杂的协议来交换数据。
- en: Setting up the hardware
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件设置
- en: As just said in the previous section, this time we have to connect a USB device
    and two serial devices. Regarding the USB device, the main problem is that it
    has a nonstandard USB connector, so we have to find a trick to solve the problem
    (see the following part); while for the serial devices, we have to find two free
    serial ports on the BeagleBone Black's expansion connectors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面章节所述，这次我们需要连接一个USB设备和两个串口设备。关于USB设备，主要问题是它有一个非标准的USB连接器，因此我们必须找到一个解决方法（见下一部分）；而对于串口设备，我们需要在BeagleBone
    Black的扩展连接器上找到两个空闲的串口。
- en: 'Regarding this last issue, we should remember that the BeagleBone Black has
    six on-board serial ports that are disabled by default, except the `/dev/ttyO0`
    device, which is coupled to the serial console. If we do log in into the system,
    we can easily verify it by using the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于最后这个问题，我们应该记住BeagleBone Black默认禁用六个板载串口，只有`/dev/ttyO0`设备是与串口控制台配对的。如果我们登录到系统中，可以通过以下命令轻松验证：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To enable the other serial ports, we need to modify the kernel settings in
    order to enable the serial port that we wish to use. The choice of which ports
    to enable depends on the pins we''d like to use to connect our devices, and the
    following table may help us in choosing them:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用其他串口，我们需要修改内核设置，以便启用我们希望使用的串口。选择启用哪个端口取决于我们希望使用的引脚来连接设备，以下表格可能有助于我们做出选择：
- en: '| Device | TxD | RxD | RTS | CTS | Name |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | TxD | RxD | RTS | CTS | 名称 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `/dev/ttyO1` | P9.24 | P9.26 |   |   | `UART1` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `/dev/ttyO1` | P9.24 | P9.26 |   |   | `UART1` |'
- en: '| `/dev/ttyO2` | P9.21 | P9.22 | P8.38 | P8.37 | `UART2` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `/dev/ttyO2` | P9.21 | P9.22 | P8.38 | P8.37 | `UART2` |'
- en: '| `/dev/ttyO4` | P9.13 | P9.11 | P8.33 | P8.35 | `UART4` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `/dev/ttyO4` | P9.13 | P9.11 | P8.33 | P8.35 | `UART4` |'
- en: '| `/dev/ttyO5` | P8.37 | P8.38 |   |   | `UART5` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `/dev/ttyO5` | P8.37 | P8.38 |   |   | `UART5` |'
- en: 'All the devices are suitable for our scope, so I choose to use the two `/dev/ttyO1`
    and `/dev/ttyO2` devices, and, to activate them, we can use the following commands:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有设备都适用于我们的范围，因此我选择使用两个`/dev/ttyO1`和`/dev/ttyO2`设备，并且为了激活它们，我们可以使用以下命令：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, two new serial ports are ready to be used, as shown by the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个新的串口已准备好使用，如下所示的命令所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reader can also take a look at the book *BeagleBone Essentials*, *Packt
    Publishing*, written by the author of this book, in order to have more information
    regarding how to manage the BeagleBone Black's serial ports needed to communicate
    with the sensors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 读卡器还可以查看这本书《*BeagleBone Essentials*》，由本书的作者编写，出版商为*Packt Publishing*，以便获得更多有关如何管理BeagleBone
    Black的串口，进而与传感器进行通信的信息。
- en: Setting up the smart card reader
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置智能卡读卡器
- en: 'The smart card reader I used in this prototype is shown in the following image:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个原型中使用的智能卡读卡器如下图所示：
- en: '![Setting up the smart card reader](img/B00255_09_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![设置智能卡读卡器](img/B00255_09_01.jpg)'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The device can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/http://www.cosino.io/product/smartcard-reader-isoiec-7816](http://www.cosino.io/product/http://www.cosino.io/product/smartcard-reader-isoiec-7816).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备可以通过以下链接购买（或通过上网搜索）：[http://www.cosino.io/product/http://www.cosino.io/product/smartcard-reader-isoiec-7816](http://www.cosino.io/product/http://www.cosino.io/product/smartcard-reader-isoiec-7816)。
- en: The device is based on the chip **Maxim 73S1215F**, and its datasheet is available
    at [http://datasheets.maximintegrated.com/en/ds/73S1215F.pdf](http://datasheets.maximintegrated.com/en/ds/73S1215F.pdf).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备基于**Maxim 73S1215F**芯片，其数据表可在[http://datasheets.maximintegrated.com/en/ds/73S1215F.pdf](http://datasheets.maximintegrated.com/en/ds/73S1215F.pdf)上找到。
- en: As stated before, this device has a nonstandard USB connector, so we have to
    find a trick to connect it to our BeagleBone Black.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个设备具有非标准的USB连接器，因此我们必须找到一种方法将其连接到我们的BeagleBone Black上。
- en: 'The *quick and dirty* solution can be in using a USB plug type A adapter from
    an old USB device, which then must be soldered with the board, as shown in the
    following image:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速且简便*的解决方案是使用来自旧USB设备的USB插头类型A适配器，然后必须将其焊接到板上，如下图所示：'
- en: '![Setting up the smart card reader](img/B00255_09_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![设置智能卡读卡器](img/B00255_09_02.jpg)'
- en: 'The connections must be done according to the following table:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 连接必须按照以下表格进行：
- en: '| Smart Card reader pin | USB plug type A cable |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 智能卡读卡器引脚 | USB插头类型A电缆 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| VBus | Red |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| VBus | 红色 |'
- en: '| D- | White |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| D- | 白色 |'
- en: '| D+ | Yellow |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| D+ | 黄色 |'
- en: '| GND | Green |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| GND | 绿色 |'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The connector pin out can be retrieved at [https://en.wikipedia.org/wiki/USB](https://en.wikipedia.org/wiki/USB)
    in the **pin out** box on the left.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器引脚输出可以在[https://en.wikipedia.org/wiki/USB](https://en.wikipedia.org/wiki/USB)的**引脚输出**框中查看。
- en: 'If the connections are correct, once you connect the device to the BeagleBone
    Black, you should get an output as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接正确，一旦你将设备连接到BeagleBone Black，应该会得到如下输出：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Okay, everything works correctly, but now we need some packages to manage our
    smart card reader. So, let''s install them by using the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一切正常工作，但现在我们需要一些包来管理我们的智能卡读卡器。那么，让我们通过以下命令安装它们：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once finished, the `pcsc` tool is ready to work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`pcsc`工具就可以开始工作了。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The curious reader may take a look at the following URL for further information
    on this tool: [http://ludovic.rousseau.free.fr/softwares/pcsc-tools/](http://ludovic.rousseau.free.fr/softwares/pcsc-tools/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的读者可以查看以下网址，了解更多关于此工具的信息：[http://ludovic.rousseau.free.fr/softwares/pcsc-tools/](http://ludovic.rousseau.free.fr/softwares/pcsc-tools/)。
- en: 'Once installed, we can execute it with the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以通过以下命令执行它：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In case you get the following error instead of the preceding output, you can
    try to restart the daemon with the `/etc/init.d/pcscd restart` command and then
    execute the `pcsc_scan` tool again:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到以下错误而不是前述输出，可以尝试使用`/etc/init.d/pcscd restart`命令重启守护进程，然后再次执行`pcsc_scan`工具：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Okay, the daemon started correctly, but it still didn''t recognize our device.
    In this case, we have to patch the `/etc/libccid_Info.plist` configuration file,
    as shown in the following patch:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，守护进程已正确启动，但它仍然没有识别我们的设备。在这种情况下，我们需要修补`/etc/libccid_Info.plist`配置文件，如下所示的补丁所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After all the modifications are in place, we have to restart the daemon. Now
    the output should change as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有修改完成后，我们必须重启守护进程。现在，输出应该会发生如下变化：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Great! Now we can verify that the reader is really working by inserting a card
    into the socket and by verifying that the tool should print something, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在我们可以通过将卡片插入插槽并验证工具是否应该打印出以下内容，来验证读卡器是否正常工作：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The device is functioning; however, we need a dedicated program to manage the
    cards. So, let''s install the `python-pyscard` package with the usual `aptitude`
    command and then consider the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备正在正常工作；然而，我们需要一个专门的程序来管理卡片。因此，我们先通过常用的`aptitude`命令安装`python-pyscard`包，然后考虑以下代码片段：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code is stored in the `chapter_09/smart_card/smart_card.py` script
    in the book's example code repository.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码存储在书籍示例代码仓库中的`chapter_09/smart_card/smart_card.py`脚本中。
- en: The program defines a `cardmonitor` object and then adds its observer with the
    `addObserver()` method in order to be called when a card is inserted or removed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 程序定义了一个`cardmonitor`对象，并通过`addObserver()`方法添加其观察者，以便在插入或移除卡片时调用。
- en: 'If executed, the program gives an output as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行成功，程序将输出如下内容：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you get the following error while executing the command, you need the `python-daemon`
    package:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行命令时出现以下错误，则需要安装`python-daemon`包：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You an resolve the issue by using the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用以下命令解决此问题：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Setting up the RFID LF reader
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置RFID LF读取器
- en: 'As an RFID LF reader, we can use the device shown in the following image that
    sends its data through a serial port at the TTL 3.3V level:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个RFID LF读取器，我们可以使用下图所示的设备，它通过TTL 3.3V电平的串口发送数据：
- en: '![Setting up the RFID LF reader](img/B00255_09_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![设置RFID LF读取器](img/B00255_09_03.jpg)'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The device can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/lf-rfid-low-voltage-reader](http://www.cosino.io/product/lf-rfid-low-voltage-reader).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备可以通过以下链接购买（或通过搜索互联网）：[http://www.cosino.io/product/lf-rfid-low-voltage-reader](http://www.cosino.io/product/lf-rfid-low-voltage-reader)。
- en: The datasheet of this device is available at [http://cdn.sparkfun.com/datasheets/Sensors/ID/ID-2LA,%20ID-12LA,%20ID-20LA2013-4-10.pdf](http://cdn.sparkfun.com/datasheets/Sensors/ID/ID-2LA,%20ID-12LA,%20ID-20LA2013-4-10.pdf).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备的datasheet可以在[http://cdn.sparkfun.com/datasheets/Sensors/ID/ID-2LA,%20ID-12LA,%20ID-20LA2013-4-10.pdf](http://cdn.sparkfun.com/datasheets/Sensors/ID/ID-2LA,%20ID-12LA,%20ID-20LA2013-4-10.pdf)找到。
- en: 'It can be directly connected to our BeagleBone Black to the following pins
    of the expansion connector *P9*, corresponding to the already-enabled serial device
    `/dev/ttyO1`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以直接连接到我们的BeagleBone Black，并连接到扩展连接器*P9*的以下引脚，对应已启用的串口设备`/dev/ttyO1`：
- en: '| Pins | RFID LF reader pins - label |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | RFID LF读取器引脚 - 标签 |'
- en: '| --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| P9.4 - Vcc | 8 - Vcc |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| P9.4 - Vcc | 8 - Vcc |'
- en: '| P9.26 - RxD | 6 - TX |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| P9.26 - RxD | 6 - TX |'
- en: '| P9.2 - GND | 7 - GND |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| P9.2 - GND | 7 - GND |'
- en: 'After all the pins have been connected, the tag''s data will be available on
    the `/dev/ttyO1` device. To quickly verify it, we can use the following commands:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有引脚连接完毕后，标签的数据将在`/dev/ttyO1`设备上可用。为了快速验证，我们可以使用以下命令：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, when approaching a tag to the reader, we should hear a *beep*, and the
    corresponding tag''s ID should appear to the command line as follows. (The following
    `cat` command is repeated from before for better readability, so you don''t need
    to retype it):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当将标签靠近读取器时，我们应该能听到*哔哔声*，并且相应的标签ID应显示在命令行中，如下所示。（下面的`cat`命令为提高可读性而重复，您不需要重新输入它）：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, using the `cat` command is not the best thing to do for our purposes
    since its output is not a completely clean ASCII text (see the device''s datasheet
    for further information about this issue); in fact, some *dirty* bytes are received
    before the tag ID. For example, the dot ''`.`'' before the tag ID is one of these
    bytes. So, we can imagine writing a dedicated tool to clean the received messages
    from the device in order to have a clean ASCII ID string. A code snippet of such
    a tool is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`cat`命令并不是最适合我们需求的操作，因为它的输出并不是完全干净的ASCII文本（有关此问题的更多信息，请参阅设备的datasheet）；事实上，在标签ID之前接收了一些*脏*字节。例如，标签ID前的点符号“`.`”就是这些字节之一。因此，我们可以设想编写一个专用工具来清理从设备接收到的消息，以便获得一个干净的ASCII
    ID字符串。这样的工具的代码片段如下：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code is stored in the `chapter_09/rfid_lf/rfid_lf.sh` script in
    the book's example code repository.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码存储在书籍示例代码仓库中的`chapter_09/rfid_lf/rfid_lf.sh`脚本中。
- en: 'The `cat` command reads the data from the device addressed by the `dev` variable,
    as in the preceding example; then, the output is passed through the `tr` command
    in order to remove nonprintable characters. The result is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令从由`dev`变量指定的设备读取数据，如前面的示例所示；然后，输出通过`tr`命令传递，以去除不可打印字符。结果如下：'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The curious reader can take a look at the `tr`'s man pages for further information
    about its usage.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的读者可以查看`tr`的man页面，以获取有关其用法的更多信息。
- en: Setting up the RFID UHF reader
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置RFID UHF阅读器
- en: 'As an RFID UHF reader, we can use the following device that sends its data
    through a serial port at the TTL 3.3V level:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为RFID UHF阅读器，我们可以使用以下设备，它通过TTL 3.3V级别的串口发送数据：
- en: '![Setting up the RFID UHF reader](img/B00255_09_04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![设置RFID UHF阅读器](img/B00255_09_04.jpg)'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The device can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/uhf-rfid-long-range-reader](http://www.cosino.io/product/uhf-rfid-long-range-reader).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备可以通过以下链接购买（或通过网络搜索）：[http://www.cosino.io/product/uhf-rfid-long-range-reader](http://www.cosino.io/product/uhf-rfid-long-range-reader)。
- en: The product's information from the manufacturer is available at [http://www.caenrfid.it/en/CaenProd.jsp?mypage=3&parent=59&idmod=818](http://www.caenrfid.it/en/CaenProd.jsp?mypage=3&parent=59&idmod=818).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 产品的制造商信息可以在[http://www.caenrfid.it/en/CaenProd.jsp?mypage=3&parent=59&idmod=818](http://www.caenrfid.it/en/CaenProd.jsp?mypage=3&parent=59&idmod=818)查看。
- en: 'It can be directly connected to our BeagleBone Black to the following pins
    of the expansion connector *P9*, which are connected with the already-enabled
    serial device `/dev/ttyO2`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以直接连接到我们的BeagleBone Black，通过扩展连接器*P9*的以下引脚，这些引脚与已启用的串口设备`/dev/ttyO2`连接：
- en: '| Pins | RFID UHF reader pins - label |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | RFID UHF阅读器引脚 - 标签 |'
- en: '| --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| P9.6 - Vcc | 1 - +5V |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| P9.6 - Vcc | 1 - +5V |'
- en: '| P9.21 - TxD | 9 - RXD |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| P9.21 - TxD | 9 - RXD |'
- en: '| P9.22 - RxD | 10 - TXD |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| P9.22 - RxD | 10 - TXD |'
- en: '| P9.1 - GND | 12 - GND |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| P9.1 - GND | 12 - GND |'
- en: After all the pins have been connected, the tag's data will be available at
    the `/dev/ttyO2` device, but to get them, we need extra software. In fact, this
    device requires a special protocol to communicate with the host, so we need to
    install a dedicated **C** library to do the trick, as explained in the following
    part.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有引脚连接完成后，标签的数据将可通过`/dev/ttyO2`设备获取，但为了获取这些数据，我们需要额外的软件。事实上，这个设备需要一种特殊的协议与主机进行通信，因此我们需要安装一个专用的**C**库来完成这一任务，具体方法将在下面部分进行说明。
- en: 'We need to download, compile, and then install three libraries: `libmsgbuff`,
    `libavp`, and `libcaenrfid`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要下载、编译并安装三个库：`libmsgbuff`、`libavp`和`libcaenrfid`。
- en: 'First of all, we need some prerequisite packages. So, let''s install them:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些先决软件包。所以，让我们安装它们：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can start downloading the first library with the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令开始下载第一个库：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we have to enter in the new directory `libmsgbuff` and execute the `autogen.sh`
    command, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要进入新目录`libmsgbuff`并执行`autogen.sh`命令，如下所示：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'It may happen that you get the following errors:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现以下错误：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this case, the lines with the macros `AM_SILENT_RULES` and `AM_PROG_AR`
    should be deleted, as shown in the following patch:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，带有宏`AM_SILENT_RULES`和`AM_PROG_AR`的行应该被删除，如下所示的补丁所示：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, we can safely restart the `autogen.sh` command.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以安全地重新启动`autogen.sh`命令。
- en: 'Then, to recompile the library, we can use the following command line:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要重新编译库，我们可以使用以下命令行：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Okay, now that the packages are ready we can install them by using the `dpkg`
    command, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，既然软件包已经准备好，我们可以使用`dpkg`命令安装它们，如下所示：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now it''s the turn of the second library. The steps are the same as in the
    preceding example. Once done, move to the parent directory and then download the
    new sources with the following `git` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到第二个库了。步骤与前面的示例相同。完成后，进入上级目录，然后使用以下`git`命令下载新源代码：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, execute the `autogen.sh` script in the library''s directory:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在库的目录中执行`autogen.sh`脚本：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Again, as in the preceding example, if an `undefined macro` error occurs, just
    apply the same patch as in the preceding example at the current `autogen.sh` script.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 同前面的例子一样，如果发生`undefined macro`错误，只需按照前面示例中的补丁修复当前`autogen.sh`脚本。
- en: 'Then, start the following compilation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，开始以下编译：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And, finally, execute the `dpkg` command to install the packages:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行`dpkg`命令来安装软件包：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Okay, for the last library the procedure is similar, but with a little note.
    Move to the parent directory. Then, download the code and execute the `autogen.sh`
    script (patch it as before if needed):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，最后一个库的过程类似，但有一个小提示。首先，进入上级目录。然后，下载代码并执行`autogen.sh`脚本（如有需要，可以像之前一样修补）：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we need to create two new files for the BeagleBone Black''s architecture
    (which is named `armhf` in Debian). The commands are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要为BeagleBone Black的架构（在Debian中名为`armhf`）创建两个新文件。命令如下：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can execute the usual package generation command followed by the installation
    one, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行常规的包生成命令，紧接着是安装命令，如下所示：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At this point, the needed libraries are in place, so we can compile our program
    to get access to the RFID UHF reader. A snippet of a possible implementation is
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所需的库已经就绪，我们可以编译我们的程序来访问RFID UHF读卡器。以下是可能实现的一个代码片段：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code is stored in the `chapter_09/rfid_uhf/rfid_uhf.c` script in
    the book's example code repository.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码存储在书籍示例代码库中的`chapter_09/rfid_uhf/rfid_uhf.c`脚本中。
- en: The program simply uses the `caenrfid_open()` method to establish a connection
    with the reader and the `caenrfid_inventory()` method to detect the tags. The
    `caenrfid_set_srcconf()` method is used to set an internal special feature in
    order to avoid multiple readings of the same tag.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序简单地使用`caenrfid_open()`方法与读卡器建立连接，并使用`caenrfid_inventory()`方法来检测标签。`caenrfid_set_srcconf()`方法用于设置一个内部特殊功能，以避免多次读取相同的标签。
- en: 'The program can be compiled with the `make` command, executed in the `rfid_uhf`
    directory, and the tool can be used as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序可以通过在`rfid_uhf`目录中执行`make`命令进行编译，工具可以如下使用：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The program answers with no output in case there are no tags near the reader''s
    antenna, but if we approach some tags we get something as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读卡器天线附近没有标签，程序将不会有输出，但如果我们靠近一些标签，则会得到如下所示的内容：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that, in this case, and contrary to what happens in the RFID LF case, the
    reader can detect a tag even a few meters away (the distance depends on the antenna
    you're using!)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，与RFID LF的情况相反，读卡器可以在几米外检测到标签（具体距离取决于你使用的天线！）
- en: The final picture
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终图像
- en: 'The following image shows the prototype I realized to implement this project
    and to test the software:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了我实现该项目并测试软件时制作的原型：
- en: '![The final picture](img/B00255_09_05.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![最终图像](img/B00255_09_05.jpg)'
- en: Note that to use the RFID UHF reader, you must use an external power supply,
    while for the other two readers it is not needed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要使用RFID UHF读卡器，必须使用外部电源，而其他两种读卡器则不需要。
- en: Setting up the software
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置软件
- en: After the hardware has been set up, most of the job is done; to finish our job,
    we need to first install a tool to get access to our Twitter account, and then
    we have to add a mechanism to call it each time a successful identification process
    is accomplished. So, in the following sections I'm going to show how to install
    and correctly set up a command line tool to communicate with Twitter and then
    how to call it in three different programming languages for three different identification
    systems.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件设置完成后，大部分工作已经完成；为了完成我们的任务，我们首先需要安装一个工具来访问我们的Twitter帐户，然后我们必须添加一个机制，每次成功完成识别过程时调用它。所以，在接下来的章节中，我将展示如何安装并正确设置一个命令行工具与Twitter进行通信，然后如何在三种不同的编程语言中调用它，以支持三种不同的识别系统。
- en: To simplify the project a bit, we can use a static list of known IDs stored
    in each program, but you can understand that this list can be easily managed by
    an external database. So, I leave this implementation as an exercise for you.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化项目，我们可以在每个程序中使用一个已知ID的静态列表，但你可以理解，这个列表可以通过外部数据库轻松管理。所以，我将这个实现留给你作为练习。
- en: Setting up the Twitter utility
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Twitter工具
- en: 'The utility I''m going to use to get access to a Twitter account is named with
    the single character `t`. The `t` program, as reported on its home page, derives
    from the Twitter SMS commands:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我将用于访问Twitter帐户的工具命名为单字符`t`。根据其主页的描述，`t`程序源自Twitter的短信命令：
- en: '*The CLI takes syntactic cues from the Twitter SMS commands, but it offers
    vastly more commands and capabilities than are available via SMS.*'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*该CLI从Twitter的短信命令中获取语法提示，但它提供了比SMS命令更多的命令和功能。*'
- en: In fact, once installed, it uses simple commands to update our Twitter status,
    follow/unfollow users, retrieve detailed information about a Twitter user, create
    a list for everyone you're following, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一旦安装完成，它使用简单的命令来更新我们的Twitter状态、关注/取消关注用户、获取Twitter用户的详细信息、为你关注的所有人创建列表等等。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete reference of the `t` tool, the [https://github.com/sferik/t](https://github.com/sferik/t)
    URL is a good starting point.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `t` 工具的完整参考，[https://github.com/sferik/t](https://github.com/sferik/t)网址是一个很好的起点。
- en: 'To install this tool into our BeagleBone Black, we first need the `ruby-dev`
    package with the `aptitude` program:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此工具安装到我们的 BeagleBone Black 上，我们首先需要安装 `ruby-dev` 包，并使用 `aptitude` 程序：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, `t` is installed with the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令安装 `t`：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The execution of this command can be very slow! So, be patient and wait.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令可能非常缓慢！所以，请耐心等待。
- en: 'Once the installation has ended, we can execute the program, and if everything
    works well, a long list of available commands should be displayed as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 安装结束后，我们可以执行程序，如果一切正常，应该会显示一个长长的可用命令列表，如下所示：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At this point, as done for other social networks, we have to create a special
    application for our Twitter account to get access to our data. To do so, let''s
    point our browser to the [https://apps.twitter.com/app/new](https://apps.twitter.com/app/new)
    URL. We''ll see a form where we can fill out information about our new application.
    Simply fill in three fields: **Name**, **Description**, and **Website**. Note
    that the name of the application needs to be unique across all Twitter users and
    cannot contain the word `twitter`, while the website can be arbitrary (for instance,
    `http://www.mydomain.com`), as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，与其他社交网络一样，我们需要为我们的 Twitter 账户创建一个特殊的应用程序，以获取对我们的数据的访问权限。为此，让我们将浏览器指向[https://apps.twitter.com/app/new](https://apps.twitter.com/app/new)网址。我们将看到一个表单，在其中填写有关新应用程序的信息。只需填写三个字段：**名称**、**描述**和**网站**。请注意，应用程序的名称必须在所有
    Twitter 用户中唯一，且不能包含 `twitter` 一词，而网站可以是任意的（例如，`http://www.mydomain.com`），如下图所示：
- en: '![Setting up the Twitter utility](img/B00255_09_06.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Twitter 工具](img/B00255_09_06.jpg)'
- en: Regarding the **Callback URL** field, you can leave it blank. Then, click on
    the checkbox for developer terms agreement at the bottom of the page and then
    click on the **Create your Twitter application** button.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**回调 URL**字段，您可以将其留空。然后，点击页面底部的开发者条款同意框，再点击**创建您的 Twitter 应用程序**按钮。
- en: 'Once your application has been successfully created, you will see a page where
    you can manage your application settings, as shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用程序成功创建，您将看到一个页面，可以在此管理您的应用程序设置，如下图所示：
- en: '![Setting up the Twitter utility](img/B00255_09_07.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Twitter 工具](img/B00255_09_07.jpg)'
- en: Now, go to the **Permissions** tab and change **Access** type to **Read, Write
    and Access direct messages** and save.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到**权限**选项卡，并将**访问**类型更改为**读取、写入和访问直接消息**，然后保存。
- en: 'The next step is to authorize your application to access your Twitter account.
    For that, run the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是授权您的应用程序访问您的 Twitter 账户。为此，运行以下命令：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, once the *Enter* key has been pressed, the following output is shown:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按下*回车*键后，会显示以下输出：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Apart from the error messages due to the fact that `t` cannot execute any browser
    at all, we have to go to the **Keys and Access Token** tab and enter the key in
    the **Consumer Key (API Key)** field located under **Application Settings**. Then,
    the tool will ask for the API secret, so you have to enter the **Consumer Secret
    (API Secret)** in the same page as before.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由于 `t` 无法执行任何浏览器而导致的错误信息外，我们还需要转到**密钥和访问令牌**选项卡，并在**应用程序设置**下的**消费者密钥（API
    密钥）**字段中输入密钥。然后，工具会要求输入 API 密钥，因此您需要在之前的页面中输入**消费者密钥（API 密钥）**。
- en: '![Setting up the Twitter utility](img/B00255_09_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Twitter 工具](img/B00255_09_08.jpg)'
- en: 'When finished, if both the keys are valid, the tool will display the following
    output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，如果两个密钥有效，工具将显示以下输出：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As before, the tool will try to open the browser again in order to show the
    Twitter application authorization page, but of course, it cannot, so the following
    error message is shown:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，工具会再次尝试打开浏览器，以显示 Twitter 应用程序授权页面，但当然它无法打开，因此会显示以下错误信息：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Okay, we just need to *copy and paste* the preceding URL into our browser on
    the host PC to finish the job. To be clear, the URL is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们只需要*复制并粘贴*上面的 URL 到主机 PC 的浏览器中以完成此操作。明确来说，URL 如下：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, a new page where your Twitter credentials are to be put should appear,
    as shown in the following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应出现一个新页面，要求输入您的 Twitter 凭据，如下图所示：
- en: '![Setting up the Twitter utility](img/B00255_09_09.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Twitter 工具](img/B00255_09_09.jpg)'
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Sorry for the Italian, but this is what my Twitter account's default language
    is set to.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起，虽然是意大利语，但这是我 Twitter 账户默认语言设置的语言。
- en: 'Put your Twitter credentials and, if they are correct, the system should give
    you a PIN to be used to finish the authorization process (see the following screenshot):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你的 Twitter 凭证，如果它们正确，系统应该会提供一个 PIN，用于完成授权过程（见下图）：
- en: '![Setting up the Twitter utility](img/B00255_09_10.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Twitter 工具](img/B00255_09_10.jpg)'
- en: 'Just *copy and paste* the PIN into the terminal where the tool is running and
    press *Enter* (again, you should not care about the error when launching the browser).
    However, if all steps are correct, the last message from `t` should be the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 只需*复制并粘贴* PIN 到工具运行的终端中，然后按 *Enter*（再次提醒，启动浏览器时不必担心错误）。不过，如果所有步骤正确，`t`工具的最后一条消息应该是：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Great! Now, we are ready to do our first tweet from the BeagleBone Black''s
    command line! The command is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们准备从 BeagleBone Black 的命令行发布第一条推文了！命令如下：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following screenshot shows a snippet of my Twitter account where the recently
    sent message is published:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我的 Twitter 账户的一部分，最近发送的消息已发布：
- en: '![Setting up the Twitter utility](img/B00255_09_11.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Twitter 工具](img/B00255_09_11.jpg)'
- en: The smart card implementation
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能卡实现
- en: Let's now start with the first implementation of our identifying system by getting
    access to the smart card. The code is written in Python, and it shows a possible
    implementation of our access control system by using a smart card reader.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从获取智能卡的访问权限开始，实施我们的识别系统。代码是用 Python 编写的，展示了通过使用智能卡读卡器实现访问控制系统的一种可能实现方式。
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that implementation is very minimal since we limit our attention to the
    ATR parameter, which cannot be used to uniquely identify a smart card in all circumstances.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种实现非常简约，因为我们只关注 ATR 参数，而 ATR 参数在所有情况下不能唯一地识别智能卡。
- en: 'The program is very similar to the one stored in the `chapter_09/smart_card/smart_card.py`
    file, so I''m going to show only the relevant differences here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序与存储在`chapter_09/smart_card/smart_card.py`文件中的程序非常相似，所以我这里只展示相关的差异：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code is stored in the `chapter_09/smart_card/smart_card2twitter.py`
    script in the book's example code repository.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码存储在本书示例代码库中的`chapter_09/smart_card/smart_card2twitter.py`脚本中。
- en: The `ID2NAME` array holds a list of known IDs, that is, our *database* of valid
    IDs that are associated with well-known people. It's easy here to imagine that
    using a real database would be a better implementation, but this solution is fine
    for our teaching purposes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`ID2NAME`数组保存了已知 ID 的列表，也就是我们与知名人物关联的有效 ID 的 *数据库*。在这里，容易想象如果使用真实数据库会是更好的实现，但这种解决方案对于我们的教学目的已经足够。'
- en: The `update()` method extracts the smart card's ATR field, and then, instead
    of simply printing it, it compares the current ID with our internal database,
    and in case of positive match, it calls the `t` tool in order to update the Twitter
    account.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法提取智能卡的 ATR 字段，然后，它并非简单地打印出来，而是将当前 ID 与我们的内部数据库进行比较，在匹配成功的情况下，调用`t`工具更新
    Twitter 帐户。'
- en: The RFID LF implementation
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RFID LF 实现
- en: 'As in the preceding example, we have to modify the `chapter_09/rfid_lf/rfid_lf.sh`
    **Bash** script a bit in order to call the `t` tool if the current tag ID is found
    in the list of the known IDs held by the `ID2NAME` array. A snippet of the modified
    code is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如同前面的示例，我们需要稍微修改`chapter_09/rfid_lf/rfid_lf.sh` **Bash** 脚本，以便在当前标签 ID 出现在`ID2NAME`数组中的已知
    ID 列表时，调用`t`工具。修改后的代码片段如下：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code is stored in the `chapter_09/rfid_lf/rfid_lf2twitter.sh` script
    in the book's example code repository.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码存储在本书示例代码库中的`chapter_09/rfid_lf/rfid_lf2twitter.sh`脚本中。
- en: The RFID UHF implementation
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RFID UHF 实现
- en: 'The last implementation is in C**,** and it uses the RFID UHF reader in order
    to take the identification string. The trick is now well-known; we simply need
    to modify the `chapter_09/rfid_uhf/rfid_uhf.c` program in order to check the current
    tag ID with the known ones held again in the well-known `ID2NAME` array. The code
    snippet is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的实现是用 C 编写的，并且使用 RFID UHF 读卡器获取识别字符串。这个方法现在已经非常流行；我们只需修改`chapter_09/rfid_uhf/rfid_uhf.c`程序，以便检查当前标签
    ID 是否与`ID2NAME`数组中已知的 ID 匹配。代码片段如下：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code is stored in the `chapter_09/rfid_uhf/rfid_uhf2twitter.c`
    file in the book's example code repository.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码存储在书中示例代码库中的`chapter_09/rfid_uhf/rfid_uhf2twitter.c`文件中。
- en: Before executing it, don't forget to compile it!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 执行之前，别忘了先编译它！
- en: Final test
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终测试
- en: 'To test our prototype, we have to run the three different programs presented
    in the preceding section. As in the previous chapters, I first executed the `chapter_09/SYSINIT.sh`
    file in the book''s example code repository as usual to set up all peripherals:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的原型，我们必须运行前一节中介绍的三种不同的程序。和前几章一样，我首先执行了书中示例代码库中的`chapter_09/SYSINIT.sh`文件，以设置所有外设：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, let''s start the smart card program and insert the smartcard as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们启动智能卡程序并插入智能卡，如下所示：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, press the *CTRL* + *C* keys to stop the program, and let''s try the RFID
    LF program as follows by approaching the relative tag:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按下*CTRL* + *C*键停止程序，然后按照如下方式尝试RFID LF程序，通过接近相应标签来进行测试：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Again, stop the program with the *CTRL* + *C* keys, and let''s test the last
    program as follows by approaching the relative tag again:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用*CTRL* + *C*键停止程序，然后按照如下方式重新接近相应标签来测试最后一个程序：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered how to publish a message to a Twitter account
    and three different ways to identify people or objects by using different identification
    technologies and programming languages.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们探索了如何向Twitter账户发布消息，以及使用不同的识别技术和编程语言识别人员或物体的三种不同方法。
- en: In the next chapter, we'll discover how to manage some lights by using a common
    remote controller (or any infrared capable device). We'll see how our BeagleBone
    Black board can receive some commands by using our TV remote.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探索如何使用普通遥控器（或任何红外设备）管理一些灯光。我们将看到如何通过我们的电视遥控器让BeagleBone Black板接收一些命令。
