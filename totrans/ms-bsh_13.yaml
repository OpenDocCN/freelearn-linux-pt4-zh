- en: Its Time for a Timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having had a peek into daemons and SSH tunnels, dealing with `cronjob` could
    look like a humble task, but let''s think for a while about our daily routine:
    how many times do we need to schedule a job to be executed in a specific time
    frame, maybe late at night or while we are on vacation? How many times do we need
    a certain task to be executed every day at a precise hour, every single day? Do
    we really want to stay up late at night or give up our vacations, or more importantly,
    can we be sure we will always be available to run a task every day at the same
    hour? Simply, we can''t be. So, a method to schedule jobs and have them executed
    when needed, everytime it is needed, can be humble, but it is what makes a system
    easier to manage and saves us a lot of headaches.'
  prefs: []
  type: TYPE_NORMAL
- en: We have many tools and forked projects available, but we will focus on a couple
    of them. The most famous old tools around are **at** and **cron**. They do quite
    the same thing, but with a different spin and definitely with a different goal.
  prefs: []
  type: TYPE_NORMAL
- en: One shot at it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we need to fire a job at a specific hour without any need to repeat
    the action, so just a one off. What we can use in this case is a simple utility
    called `at` with its companion batch. What does it do? It simply reads from the
    input or a file on what to execute and when, and it will use `/bin/sh` to invoke
    whatever we want. There is a little twist though: batch will do it but not at
    a specific time. It will be done when the system load drops below 1.5 or any level
    specified at the `atd` runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we introduced `atd`; what is this? This is the daemon that executes the
    one shot jobs defined and put in its queue by the `at` utility, and so, it is
    a daemon that usually runs under a dedicated daemon user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this is a daemon that is fired up as a system service, but we have some
    other options; we can pass it to modify how it deals with the scheduled jobs.
    Let''s see what we can make use of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-l`: Defines the load factor over which the scheduled jobs will not be run.
    If no limit is imposed, it defaults to 1.5; but, in systems with x CPUs, a good
    limit value could be higher than x-1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b`: This sets the minimum interval in seconds between two consecutive jobs
    being fired. This defaults to `60`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d`: Having issues here? This will enable a debug feature that will divert
    the error messages from `syslog` to `stderr`, usually the terminal. This option
    goes along with the `-f` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: Good for debugging, this options forces `atd` to run in the foreground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: Forces the processing of the `at` and `batch` queue to only a single
    run. This is used for backward compatibility with older versions of `at`; and
    it is run as we ran the old `atrun` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Few files are involved in the `atd` running process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/var/spool/cron/atjobs`: This is the directory where the jobs created by `at` are
    stored and `atd` will read the queue from. It must be owned by the same owner
    of the process (in our case, daemon) and have strict access rights of 700.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var/spool/cron/atspool`: This is the directory that temporarily holds the
    output of the jobs. It is owned by a daemon user with an access mode of 700.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/at.allow`, `/etc/at.deny`: In this file, we can set which account can
    submit jobs to `atd` and which are forbidden.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one limit in using `atd`; if it's spool directory is mounted with NFS,
    then whichever option you use for mounting, it will simply not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw a couple of interesting files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This administrator who can submit jobs to the `atd` daemon can have a really
    simple syntax: it is a simple list of account names, one per line, with no whitespaces.
    There is a precedence order in which the files are parsed:`/etc/at.allow` is the
    first one to be read. If any account names are found in it, these will be the
    only accounts to be allowed to submit the jobs.'
  prefs: []
  type: TYPE_NORMAL
- en: If `/etc/at.allow` does not exist, then `/etc/at.deny` is parsed and every account
    name found in it will be forbidden to send jobs to `atd`. If the file exists but
    it is empty, it is interpreted as that every account can submit jobs to `atd`.
  prefs: []
  type: TYPE_NORMAL
- en: If neither `/etc/at.allow` or `/etc/at.deny` exists, this means that only the
    superuser can submit jobs to `atd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the systems, we use a sandbox. We have `/etc/at.deny` and its contents here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So for the rules we just saw, if  `/etc/at`. `allow` is absent, all the accounts
    listed in `/etc/at.deny` are forbidden to submit jobs to `atd`. This makes sense
    as we can see that these are accounts related to services or a nobody user, and
    these are not supposed to have any need to submit a job.
  prefs: []
  type: TYPE_NORMAL
- en: This is all we need to know about the service part of the `at` facility; let's
    see what we can rely on to schedule a job. On the client side, we have the following
    utilities that we can use to submit jobs to `atd`.
  prefs: []
  type: TYPE_NORMAL
- en: The `at` and `batch read` commands from a standard input or a specified file,
    which are to be executed at a later time, using `/bin/sh`.
  prefs: []
  type: TYPE_NORMAL
- en: '`at`: This is the main utility we deal with, and its function is to submit
    jobs that are to be executed at a specific time. Time specification can be really
    smart and flexible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HH:MM`: This specifies the time of the current day to run a command called
    by `at`. If the time has already passed, the command is intended to be run on
    the next day at the same hour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`midnight`: The job is meant to be run at midnight:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To submit a job, simply press *Ctrl*+*D *on a newline:'
  prefs: []
  type: TYPE_NORMAL
- en: '`noon`: This job is meant to be run at noon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`teatime`: This job will be run at 4 PM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AM-PM`: We can add a trailing AM or PM to have the job be executed at a certain
    hour in the morning or in the afternoon:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`date month_name [year]`: We can also have a job running at a specific time
    on a precise day, month, and optionally, a year too; but, we have to keep in mind
    that whatever format we choose, the date must follow the time specification and
    not precede it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`MMDD[CC]YY`: Date specification as month, day, optional century, and year
    without spaces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`MM/DD/[CC]YY`: Date specification as month/day/optional century/year separated
    by a slash:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`DD.MM.[CC]YY`: Date specification as day.month.optional century.year separated
    by a dot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`[CC]YY-MM-DD`: Date specification as optional century year-month-day, separated
    by a dash:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`now + minutes | hours | days | weeks`: We can also set the time in minutes,
    hours, days, or weeks from the time/date on the system at the moment of creating
    the job:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`today`: We can set a job to be run at a specific hour relative to today; if
    we do not define an hour, it will be simply executed immediately:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`tomorrow`:  We can set a job to be run at a specific hour the next day; if
    we do not define an hour, it will be simply executed at the same hour that the
    job has been created, but the next day:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete reference for time specification is available at `/usr/share/doc/at/timespec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the examples, the commands are read from `stdin` or from
    a file, if using the option `-f` filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the job is put in the queue, it retains some bits from the moment it was
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: The environment variables except for `BASH_VERSINFO`, `DISPLAY`, `EUID`, `GROUPS`,
    `SHELLOPTS`, `TERM`, `UID`, `_` , and `umask` are retained from the time of invocation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What kind of environment libraries are exported to the job depends on the future
    developments; but, for instance, if we want to schedule a compile job for some
    program sources, we will have to set such libraries as `LD_LIBRARY_PATH` or `LD_PRELOAD`
    from inside the job itself since they are not inherited.
  prefs: []
  type: TYPE_NORMAL
- en: Once the job is executed, its results will be displayed to `stdout` and `stderr`
    and mailed to the user using `/usr/sbin/sendmail`, but, if it is executed from
    `su` and `at` and retains its original user id, the results will be mailed to
    the user who originally logged in to `su`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a simple command that will generate some output, and then let''s
    make sure an email is sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s check the mailbox for the default alias user for root (check
    `/etc/aliases` to know whom the emails to root will be delivered to):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we saw how to schedule a job, let''s see what options it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-q`: Force `at` to use the specified queue to place a job. Queues are designated
    with a single character, from a to z and from A to Z; the default queue is named
    after *a for at* and *b for batch*. Queues with higher letters have an increased
    niceness while there is a special queue named `=` , which is reserved for jobs
    that are actually running. If a job is submitted to a queue with a capital letter,
    it is treated as if it was submitted to batch; so, once the time specification
    is hit, the job is executed only if the load average of the system is below the
    threshold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-V`: Just prints the version number of the utility to `stderr` and `exit`
    successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-m`: Sends an email to the user once the job has been completed, even if the
    job itself has no output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-M`: Never sends any emails to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f` filename: We already saw this option; it forces `at` to read from the
    specified file the commands to run within the job, rather than from the `stdin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t [[CC]YY]MMDDhhmm[.ss]`: Defines the time to run the job named `at/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l`: This is actually an alias for `atq`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This is actually an alias for `atrm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d`: This is actually an alias for `atrm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b`: This is actually an alias for `batch`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v`: Shows when a job will be executed before reading it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`-c`: Shows on the `stdout` the specified job:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`batch`: Runs a job when the average system load is under a specific threshold,
    the default threshold defaulting to 1.5\. There is a major caveat though: in order
    to work correctly, batch depends on Linux on a proc filesystem mounted on `/proc`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If a user is not logged on at the time `at` is invoked or when the file named `/var/run/utmp`
    is not readable, the email at the end of the job is sent to the account found
    as the value of the environment variable LOGNAME. If this variable is unavailable,
    the current user id will receive the email.
  prefs: []
  type: TYPE_NORMAL
- en: '`atq`: Shows a list of pending job, for the user. If run by superuser, it shows
    the list of all the scheduled jobs for all the accounts. The format of the list
    is here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, what the unprivileged users see is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what `root` sees at the same time on the same system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the list, the queue with the name of `a`, and `indeed` queues,
    are designated with a single character, from a to z and from A to Z, the default
    queue being named after *a for at* and *b for batch*. Queues with higher letters
    have an increased niceness, while there is a special queue named `=` , which is
    reserved for jobs actually running. If `atq` is given a specific queue as an argument,
    it will show only the jobs in that queue. Let''s see what `atq` can show without
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s restrict the list to just the batch queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `atq` supports the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-q`: It is the only option, along with `V`, accepted by `atq` and restricts
    its output to the specified queue content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-V`: Just prints the version number of the utility to the `stderr` and `exit`
    successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atrm`: Deletes jobs identified by the job id:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have four jobs whose ids are `3`, `9`, `13`, and `29`; let''s remove
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Nothing left, we are done. On a final note, `atrm` accepts only one option,
    that is `-V`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we saw so far is good for a one shot job, since `at` will not allow us
    to set some recurring task; so, if we want to execute some recurring jobs over
    time, we need to resort to a different kind of facility: the well-known cron service.'
  prefs: []
  type: TYPE_NORMAL
- en: The cron scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most used facilities on a server is actually the scheduler, even
    if we do not realize how much we rely on it. Some of the services that run unattended
    on our systems are dealt with by a scheduler, which is in charge to run them at
    specific times over a span of days, weeks, and months. All those humble, repetitive
    tasks, which are so essential for the correct functioning of our environment,
    are hidden behind the curtains and do what we would not like to do, for instance,
    rotate all the system logs when it is needed. Would we do these jobs every day,
    at crazy hours, for all the services that require maintenance? No, we have better
    things to do. The cron scheduler does not have any better things to do; its purpose
    is to wake up every minute and check if something has to be done, and this makes
    it the best candidate to perform tedious repetitive tasks, at the same hour, maybe
    every day or every week. So, since one of the purposes of this book is to get
    the best we can from our system, we will have a look at this humble servant and
    learn how to configure and administer it so that it will side us in the necessary
    but not-so-funny task of administering our systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `at`, crontab relies on three different components: a utility, called
    `cron`**;** a set of configuration files, the most renowned being `/etc/crontab`;
    and a client/editor called crontab. Does it look a bit confusing? Let''s go in
    an orderly manner and have a look at the cron service first.'
  prefs: []
  type: TYPE_NORMAL
- en: cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This service runs every minute, looks for jobs stored in its crontab files,
    and checks if it must be run in the current minute. If anything is found, it is
    executed; otherwise, cron will be rerun the next minute and so forth. Once the
    job has been executed, the output of the commands issued is mailed to the owner
    of the crontab or to the user specified in the MAILTO environment variable in
    the crontab, if any. Notably, every minute, cron not only reads the crontab files
    but also checks the modification file of its spool directory or if `/etc/crontab`
    has changed and, if so, it will analyze the modification time of all the crontab
    files and reload them to get any changes made to the job''s specification. So,
    we do not worry about restarting cron if we changed anything. It will manage the
    changes by itself, but cron is also able to cope with clock changes: if the time
    has been changed by less than 3 hours backward, the already run jobs will not
    be rerun. Then, if the time shifts forward to less than 3 hours, the *skipped* jobs
    will be run as soon as the clock will hit the new time. This affects only those
    jobs that have been set with a specific execution time. So, those tasks, using
    keywords such as `@hourly`, and those who have the wildcard `*` in the hour or
    minute specification for the runtime will not be affected. If the clock is shifted
    by more than 3 hours, all the jobs will be run following the new time set.'
  prefs: []
  type: TYPE_NORMAL
- en: Each distribution can implement a different kind of cron facility and have the
    configuration files in a slightly different location. If unsure, `man cron` and
    `man crontab` will show what is supported by the service and which locations the
    relevant files are kept at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is one more surprise: there is no cron. Well, we can chuckle because
    actually we call cron the daemon part of the service, but what is actually used
    to provide that service can change according to the distribution that we are using.
    There are different schedulers available for our purposes. Here are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vixie-cron`: This is the father of all the modern crons: the venerable cron
    from Paul Vixie, coded in 1987.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bcron`: It is a cron replacement focused to provide a secure service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cronie`: It is a Fedora-based form of vixie-cron.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dcron`: Dillon''s cron is a stripped-down version of a cron; it is secure
    and simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fcron`: It could be a nice replacement to the classic vixie cron and it is
    designed for a system that is not continuously running. So, it has some interesting
    features like the ability to schedule jobs at startup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some cron implementations, and we are confident that somewhere
    there are some more, a fork or something original that addresses some precise
    requirement. For the purpose of this book, we will refer to vixie-cron as installed
    on a Debian system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have many options to interact with cron, but let''s see what it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f`: It does not daemonize and will stay in the foreground. It is useful to
    debug what is going on with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l`: It enables the Linux Standard Base compliant script names for files inside
    `/etc/cron.d` ([http://lanana.org/lsbreg/cron/index.html](http://lanana.org/lsbreg/cron/index.html)).
    Only the files inside this directory will be affected; those under `/etc/cron.hourly`,
    `/etc/cron.daily`, `/etc/cron/weekly` , and `/etc/cron/monthly` will not be affected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n`: Includes the Fully Qualified Domain Name in the subject of the email
    sent after a job has been run; otherwise, only the hostname will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l`: Sets the log level. Errors are always logged; but, different levels unlock
    additional information that is recorded using the system log facility, usually
    syslog under the *cron* facility. The single level values can be summed and the
    resulting value will enable the collection of more than one kind of information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: It logs the start of all cron jobs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: It logs the end of all cron jobs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`: It logs the end of all failed jobs, so all jobs with exit status are different
    from `0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`8`: It logs the process identification number of all cron jobs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`15`: It will collect all the information (8+4+2+1) grabbed in the preceding
    levels'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The default log level is 1, but we can specify 0 if we want to disable logging
    at all
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a couple of things to keep in mind when using cron:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cron daemons set up a number of environment variables when dealing with
    jobs, such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SHELL`: Set to `/bin/sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOGNAME`: Set from the content of `/etc/passwd` line related to the crontab
    owner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HOME`: Set from the content of `/etc/passwd` line related to the crontab owner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATH`: Set to `/usr/bin:/bin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If any other environment variables must be set by the user, the easiest way
    to accomplish this is to set them into crontab definitions for vixie-cron; other
    implementations such as cronie do not allow this, so you can resort to prepend
    them on the crontab line entry before calling the script or program belonging
    to the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at the syslog file, we can see the crontab being installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we did not make any mistakes, we should see the `/var/log/proxy` file
    being created and updated with the content of the environment the command named
    `env` has been invoked from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `HTTP_PROXY` environment variable is set for the job, and we will see more
    and more of these lines growing into the file, so we will see in a while how to
    remove this crontab or the single job.
  prefs: []
  type: TYPE_NORMAL
- en: One environment is read instead of being set and this is called **MAILTO**.
    If it is defined, the output of the job will be sent to the name specified; if
    it is empty, no mail will be sent. MAILTO can also be set to send emails to a
    list of users separated by commas. If not, MAILTO is set so the outcome of a job
    will be sent to the owner of the crontab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the cron implementations support PAM, so if they happen to set up a
    new cron job for a user, and we face some authorization issues we have three files
    to look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/cron.allow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/cron.deny`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/pam.d/cron`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/at.allow` is the first file to be read if it exists. If any account names
    are found in it, these will be the only accounts to be allowed to submit jobs
    using the crontab utility. If `/etc/cron.allow` does not exist, then `/etc/cron.deny`
    is parsed and every account name found in it will be forbidden to send jobs to
    cron. If the file exists, but it is empty, only the superuser or those listed
    in `/etc/cron.allow` will be able to submit jobs. If neither `/etc/cron.allow` nor
    `/etc/cron.deny` are available, any user will be allowed to submit jobs to cron.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We talked about the `crontab` utility. What is this? It is actually the program
    that lets us write the crontab files, which instruct cron on which jobs to execute,
    when, and on behalf of whom. Indeed, each user can have his/her own `crontab`,
    which is stored in `/var/spool/cron/crontabs`; but we should not edit them manually.
    We must resort to the `crontab` utility, which will let us edit and install the
    `crontab` file in the correct way. So, how do we use `crontab`? Let''s say we
    already have a file with our job specifications, and we will see later on how
    to write it; the only command we have to issue is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will install a new crontab for the current user from the file specified,
    but we can also manually enter our job details by typing them on the command line
    with `crontab`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can imply from the preceding command lines, if `crontab` is called without
    passing a username, it will work on the cron jobs of the user who invoked it.
    So, if we want to list or modify a user `crontab`, given that we have sufficient
    privileges, this is being superuser, we can issue the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to edit and install a new cron job, we can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Being the first time the `crontab` utility is invoked by the user, it could
    ask for the default editor to be used; if not, the visual or editor environment
    variable are instanced. If nothing is set, `/usr/bin/editor` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the example shown, the Debian distribution triggered the configuration of
    `/etc/alternatives`, which provides the link to the default editor.
  prefs: []
  type: TYPE_NORMAL
- en: Once into the editor, each cron job must be specified on a line on its own,
    such as `* * * * * ps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see later what this sequence means; as of now, we just exit the editor
    and save the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, `crontab` informs us that the crontab has been installed, and it
    could be interesting to have it displayed on the `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to get rid of the crontab, there is a handy option that will remove
    it completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: But be careful-if you want to get rid of some jobs but retain the others, the
    best solution is to edit the `crontab` again, delete the lines related to the
    jobs we do not want, and then save it. The new `crontab` with the remaining jobs
    will be installed and will completely replace the old one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are not confident in deleting a crontab, we could set an alias that points
    to `crontab -i -r` , which works with `-r` and prompts the user for a confirmation
    before deleting the crontab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We will not touch some distribution specific configurations, such as the support
    for `/etc/cron.hourly`, `/etc/cron.daily`, `/etc/cron.weekly`, and `/etc/cron.monthly` provided
    through the `/etc/crontab` file, since otherwise, we would end up drilling down
    all the bits and configurations of all possible cron implementations in all the
    main distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'What interests us here is to understand the underlying basic notions on how
    to deal with cron so that whatever different implementation we find, we will be
    able to deal with it and look into its idiosyncrasies. There are a couple of interesting
    things left to see now: one is the syntax we will use to define a job and the
    other is a quick glance to anacron: a utility we have often heard of.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if a `crontab` file can look a bit cryptic at first glance, it is not
    so difficult to understand what the sequence of the characters mean: the first
    field is for the minute when the job must be executed; the second for the hour;
    the third for the day of the month; the fourth for the month; the fifth for the
    day of the week; and the sixth for the command to execute. So, the `crontab` we
    just created a few lines ago can be read as laid out in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fields** | ***** | ***** | ***** | ***** | ***** | **ps** |'
  prefs: []
  type: TYPE_TB
- en: '| Minutes | X |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Hours |  | X |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Day of the month |  |  | X |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Month |  |  |  | X |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Day of the week |  |  |  |  | X |  |'
  prefs: []
  type: TYPE_TB
- en: '| Command |  |  |  |  |  | X |'
  prefs: []
  type: TYPE_TB
- en: What the fields mean
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now we know what these fields mean, but what are those asterisks and
    what can we write into each field? Another table will make all this easier to
    understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Allowed values** | **Metacharacters** |'
  prefs: []
  type: TYPE_TB
- en: '| Minutes | 0-59 | * , - / |'
  prefs: []
  type: TYPE_TB
- en: '| Hours | 0-23 | * , - / |'
  prefs: []
  type: TYPE_TB
- en: '| Day of the month | 1-31 | * , - / |'
  prefs: []
  type: TYPE_TB
- en: '| Month | 1-12 or Jan-Dec | * , - / |'
  prefs: []
  type: TYPE_TB
- en: '| Day of the week | 0-7 or Sun-Sat | * , - / |'
  prefs: []
  type: TYPE_TB
- en: Which values can be used inside each field
  prefs: []
  type: TYPE_NORMAL
- en: We are almost there. Just a few things more to learn and we will be able to
    fully understand a crontab line; but first, what are those metacharacters and
    what do they mean?
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Sunday can be specified both as `0` and `7` in the day of
    the week field.
  prefs: []
  type: TYPE_NORMAL
- en: '`*`: This stands for *every* and can be used in all the fields. So, inside
    a minute field it will tell cron to run the job every minute, inside the hour
    every hour, and so forth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`,`: The comma defines a list. For instance, `1`, `5`, and `15` in the day
    of the month will instruct cron to run the job on the first, the fifth, and on
    the fifteenth day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: The hyphen defines an inclusive range. For instance, 4-7 in the day of
    the week field will force cron to execute the job from Thursday to Sunday.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`: The forward slash is used to define steps, and it can be used with ranges
    so that it will skip the value of the number through the range. So, 1-59/2 in
    the minute field will give us all the odd minutes in one hour, since it will start
    from one and wait 2 minutes before the next execution; this can be specified as
    a list as well: `1`, `3`, `5`, `7`, `9`, `11`, `13`, `15`, `17`, `19`, `21`, `23`,
    `25`, `27`, `29`, `31`, `33`, `35`, `37`, `39`, `41`, `43`, `45`, `47`, `49`,
    `51`, `53`, `55`, `57`, and `59`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see, steps can be quite handy. The forward slash can also be combined
    with the asterisk: `*/2` in the hours field means *every 2 hours*, in the month
    field would be *every two months,* and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: Some implementations of cron support an extra field for the *year,* with values
    from `1970` to `2099` supporting the `*`  and  `-` metacharacters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one set of special markers we have to see before analyzing a crontab
    line. We can define some recurrences using special keywords prefixed by an `@`,
    as shown in the next table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Keyword** | **Execution** | **The same as** |'
  prefs: []
  type: TYPE_TB
- en: '| `@yearly` | Once a year, at midnight of Jan 1st | `0 0 1 1 *` |'
  prefs: []
  type: TYPE_TB
- en: '| `@annually` | Equivalent to `@yearly` | `0 0 1 1 *` |'
  prefs: []
  type: TYPE_TB
- en: '| `@montly` | Once a month, at midnight of the first day of the month | `0
    0 1 * *` |'
  prefs: []
  type: TYPE_TB
- en: '| `@weekly` | Once a week, at midnight between Sat and Sun | `0 0 * * 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `@daily` | Once a day, at midnight | `0 0 * * *` |'
  prefs: []
  type: TYPE_TB
- en: '| `@midnight` | Equivalent to `@daily` | `0 0 * * *` |'
  prefs: []
  type: TYPE_TB
- en: '| `@hourly` | Once an hour, at the tick of the hour | `0 * * * *` |'
  prefs: []
  type: TYPE_TB
- en: '| `@reboot` | At cron daemon startup | `nothing` |'
  prefs: []
  type: TYPE_TB
- en: Keywords with special meanings
  prefs: []
  type: TYPE_NORMAL
- en: '`This` replaces all the first five fields altogether and can become handy if
    you do not have special constraints about hours or days, but you want something
    being executed in a generic time frame.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding there are a few things to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Each line specifying a cron job must be ended by a newline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The percent sign `%` used in the command field is turned into a newline character,
    and all the data after the first `%` is sent to the `stdin` of the command to
    be executed. The percentage can be escaped by doubling it `%%` so that it will
    not be interpreted as a newline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the crontab file, blank lines, leading spaces, and tabs are not parsed.
    If a line starts with `#` , it will be treated as a comment and not parsed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the crontab file, we can either set some variables or define a cron job;
    nothing else is allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable can be assigned as `VARIABLE_NAME = value`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spaces surrounding the equals sign are optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No expansions or substitutions are performed on variables. So, `VARIABLE_NAME=$LOGNAME` will
    not instance `VARIABLE_NAME` since the value string is not even parsed for expansion
    or substitution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty value must be surrounded by quotes, and if the values contain blanks,
    quotes are required to preserve them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No per user time zones are available. The default system time zone is used instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, with this in mind, let''s have a look at a cron job specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 35 | 1-24/4 | * | * | Mon,Thu | /opt/scripts/script.sh |'
  prefs: []
  type: TYPE_TB
- en: '| minutes | hours | Day of the month | month | Day of the week | command |'
  prefs: []
  type: TYPE_TB
- en: '| Execute at minute 35 past every 4th hour, from 1 through 24 on Monday and
    Thursday |'
  prefs: []
  type: TYPE_TB
- en: A useful grid to make sense of a job specification line
  prefs: []
  type: TYPE_NORMAL
- en: 'Caged in a table, the job specification is easier to understand and becomes
    much easier if we use some keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all, the definition was shortened to two simple fields. But fiddling
    with the fields can lead us to something tricky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What does this do? Simply executes the script every odd minute, not even, odd.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if the system is rebooted or is a desktop, which can stay off for
    days or weeks? Using cron would lead to some jobs not being executed at all or
    just skipped, and this is not a desirable behavior. This is where anacron comes
    in handy: it will run a job even if we switch on the desktop after the scheduled
    time. How can it be? Simply, this utility keeps a log of all the jobs and when
    they were executed using a series of timestamped files held in `/var/spool/anacron`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed in an orderly manner and have a look at the file which drives
    anacron, whose name is `/etc/anacron`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand it, we must have a peek into its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can notice, we can have variables with crontab, but the format of a job
    definition is slightly different and can have one of the following syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`period`: Expressed in days specifying the frequency the job is run at. For
    instance, 10 is every 10 days.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@period`: Allows to use some keywords to specify the frequency: `@daily`,
    `@weekly`, and `@monthly` for once per day, week, and month.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay`: Expressed in minutes, defines the delay after which anacron executes
    a scheduled job when the threshold is hit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`job-name`: We can give a job whatever identifier we want, but no slashes are
    allowed. It will be used by anacron as the name for the timestamp file of the
    job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command`: Can be whatever command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see, the standard anacron file in the example will run the run-parts
    utility along with the directory argument. And, the exact job of run-parts is
    to run the scripts it finds in the directory it is being given as arguments. So,
    interpreting the anacron lines should be easy now, should''t it? Editing it is
    easy as well: we can do it by hand, no special utilities are required or available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way anacron works is amazingly straightforward and effective: it checks
    each job specified in the `anacrontab` file and sees whether it has been executed
    in the last x specified in the period field. If it has not been run and the threshold
    is hit, it will execute the job after waiting for the delay set in the second
    field of the job definition. Once the task has been executed, anacron records
    the date in a timestamp file related to the job; so next time, it will just have
    to read it to know what to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all the jobs scheduled have been executed, anacron exits; but, we also
    send anacron a SIGUSR1 signal to kill it: it will wait for any running jobs to
    finish and then will cleanly exit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is also another task performed by anacron once a job has been executed:
    if any output is created by the job, it is mailed to the user running anacron,
    usually root, or the one whose email is specified in the MAILTO environment variable
    from anacrontab. If a `LOGNAME` variable is instanced, it will be used as the
    sender of the email.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s see which options are supported by anacron:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f`: Forces anacron to execute all the defined jobs, regardless of the timestamps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u`: Just updates the timestamps of the jobs to the current date without executing
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: Serializes the execution of the jobs; meaning that, before starting the
    next job, anacron will wait for the current one to be completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n`: Ignores the delay specification for each job and runs them as they hit
    the threshold. Implies the -s option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d`: Usually anacron goes in background, but this option will force it to
    the foreground. It is useful for debugging, since anacron will sendn the runtime
    messages to the stderr and to syslog. The output emails will be sent to the recipient
    anyway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-q`: Does not print messages to the stderr and implies the `-d` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t` file: Reads the jobs, definitions from the specified file instead of the
    default anacrontab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-T`: Tests the validity of anacrontab. If there are any errors, they will
    be shown and anacron will return the value of `1`; otherwise, it will return `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-S` directory: Uses the specified directory to store the timestamp files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-V`: Prints anacron version and exits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h`: Prints the usage help and exits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have two methods available to execute jobs: one is a daemon, which forks
    in the background and stays there working on some, hopefully, important tasks;
    the other is the schedulers, great for those jobs that must be executed with a
    recurring pattern. These tools can really help us to keep everything in order,
    and execute complex and boring tasks by easing the maintenance of a server or
    even a desktop. But Bash is not only made of commands, scripts, tasks, and services:
    it is the home we are working in on a daily basis. It is our playground, our workbench,
    something to get familiar with. So, the next chapter will deal with some utilities,
    configurations, and advice to make our Bash a cozy place to live our digital life.'
  prefs: []
  type: TYPE_NORMAL
