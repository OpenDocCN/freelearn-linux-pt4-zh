- en: Menus, Arrays, and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a script often means having to deal with user interaction. You want
    to know what the user expects from your script, and you want to let the user know
    what options they have to decide from. So, we give the user some choices, they
    give us their answers, we evaluate them against some preset values, and decide
    what to do next. This implies a method to expose some data to the user, gather
    their answer, cycle between options, and react accordingly. There are different
    ways to do this, and we will see how to accomplish the task using some standard
    constructs. At the end of this chapter, we will be able to offer, gather, store,
    and process data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: The case statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are given more alternatives, you can process them with a sequence
    of if else statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` clauses can be nested if needed, but in the long run, having more
    than a few choices messes up the code, making it less readable. One of the basic
    mantras of coding is exactly keeping the code readable, making it *elegant* since
    elegance here does not simply mean beautiful, but also consistent over time. Always
    keep a meaningful indentation so that the clauses will outstand. Try to use as
    little code as you can, adopt the same notation all through your script, and make
    it all compact and lean. So, having a cascade of *if/then/else/fi* with a lot
    of indentation cannot show up as the optimal decision for your script, but there
    is an alternative available and it is widely adopted to create user menus and
    process the data provided and it is the `case` statement in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression is actually a condition that must match the pattern given in
    `condition x)`. Once the match is true, the corresponding block of commands are
    executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each of these block of commands is called a **clause** and is terminated by
    the `;;` double semicolon. All the case statements are enclosed in `case` and `esac `and
    each condition can be expressed either as `condition_1)` or `condition_1 | condition_2
    | condition_n)`.
  prefs: []
  type: TYPE_NORMAL
- en: Each condition can be an alternative match for triggering the execution of the
    commands inside the clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see two examples of how to deal with the same options using the *if/then/else/fi*
    and *case/esac* constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not complex code. We are asking for some input, and then we will check
    for a couple of conditions whether the text entered is all made of digits or characters;
    otherwise we have `dunno` as the default answer. We used a slightly more complicated
    version of *if/then/else/fi.* We adopted `elif` to check an alternative option
    to match for our condition. We could have gone further with a series of `elif`
    to check if the user input some alphanumerics or other kinds of characters, but
    as you can see from this tiny example, the code is still becoming a bit difficult
    to read; it is not so clear. Now, let''s try something slightly different using
    the case statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'What we do here is create a condition, so that we can strip all the alphabetic
    characters from the input variable value . What''s left is checked against `""`.
    What does it mean? It simply means that if after stripping the string of all alpha
    characters what''s left is an empty string. If the condition is not met we check
    against a second condition: if in what is left of the original strings there are
    some alphanumeric characters, it means that in the original string there were
    numeric characters. If even this second condition is met it means that in the
    stripped string there are chars other than numbers or alphabetic characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you ever see or use a `case` statement before ? Yes, probably more often
    than you think. Let''s do something interesting now; we will see later why it
    is so interesting. Go to the `/et/init.d/` directory for Linux distribution, still
    **SystemV** compatible, and take a look at any of the scripts you find there.
    These are the scripts that deal with the startup/shutdown of system services such
    as cron or dbus along with all the additional services that can be offered such
    as ssh, Apache, and so forth. Looking at these scripts something pops out immediately,
    they have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used as a base for our interactive scripts, since it provides a
    bare bones structure to deal with user interaction. As you can see, each clause
    has `:`, as being a base script, nothing gets executed; and for each clause, we
    graciously exit with a success code except for the conditional restart and the
    default options. The conditional restart is really optional, but it lets you restart
    your service based on a condition you will impose, so it is up to you to leave
    or delete this section. As we saw earlier in this book, the `case` construct is
    somewhat similar to the *if/then/else/fi* construct with a condition to match
    against different strings given as options. The construct is enclosed between
    the `case` and `esac `markers; notice that `esac` is `case` read backwards. Consider
    the following clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It starts with one or more strings to be matched; each possible match is separated
    by a `|` and ends with  `;;`. If more than one match is true, only the first is
    taken into account. The last option is usually an asterisk, and this can be considered
    as a catchall default since `*` matches whatever strings the user inputs. So,
    if no previous matches trigger a clause, this last one will be matched anyway
    and is a good place to write help or some command-line utilization messages, since
    it will always be displayed if the user did not enter the right options.
  prefs: []
  type: TYPE_NORMAL
- en: The string of patterns to match can be optionally preceded by `(`, for example, `(string1
    | string2 | stringn)`. Remember that the last `;;` before `esac` can be omitted
    without causing any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Each string starting the clause is an optional match for case condition in. This is
    usually a string of text that must be checked for a match against each option
    string starting a clause. If the condition is a variable, it is expanded using
    the parameter expansion, variable expansion (tilde), command substitution, process
    substitution, and quote removal, but no pathname expansion, brace expansion, or
    word splitting is performed. Given that, you do not need to quote the variable
    for safe processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Bash 4 a couple of clause terminators were introduced, and we already
    saw them in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`;&` makes the execution continue with the commands associated with the next
    condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`;;&` makes the shell check the option and execute the associated commands
    if the condition is matched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no matches are found, the exit status is 0, otherwise the exit status is
    the one from the last command executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how they word and proceed to modify the base script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Without any arguments, there cannot be any matches on a given option, so the
    catchall asterisk comes into play and executes the echo printing the usage message
    on `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All the other options are straightforward; we deleted the `condrestart` option
    just to make the script more compact and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the `;&` terminator on the last clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the script with status as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Ahem, embarrassing, nothing changed. Why? Have a closer look at the clause:
    the `;&` terminator is preceded by `exit 0`, so the execution of the script stops
    before hitting the terminator. Well, let''s delete `exit 0` and invoke the script
    again with the status argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Interesting, isn''t it? We cascaded from one block to the other, so we had
    the status block commands executed right after the restart block commands got
    executed. And this is exactly what we expected from the `;&` operator, since the
    execution had to proceed to the next block where once the first condition was
    met. But now, let''s do something else and modify the restart clause as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened? Simply put, once the `status` string was matched, the first
    `echo` command got executed and the `;&` operator caused the command associated
    to the restart clause to be invoked  without any other string check. In the restart
    clause, the `;;&` operator caused a string check on the following clause, but
    this being a string match against a wildcard, it matched anyway so the `echo` command
    of the `usage` string was executed. But what happens if we invert the operators
    between the status and restart clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We entered the `status` clause, executed the code, and then proceeded to the
    `restart` code. Here, the command was not executed since `;;&` triggers the command
    execution only if the string matches, but our `status` argument does not match
    the `restart` option. In the next line, we have  `;&`, which cascades us to the
    next clause, whose code is executed regardless of any matches. If you want to
    cause the commands in the `restart` clause to be executed anyway, just modify
    the matching options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we gave two possible matches for the restart clause, `restart`
     or `status`. The first failed, but the second matched, and the command got executed,
    and then the next clause command got executed as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw the `case` construct used in a startup script with minimal interaction
    with the user, but now, let''s start working on this construct to make something
    more interesting out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This simple script can be used to archive the content of a directory. It asks
    the user for the content and checks the answer against the lower and upper case
    `y` , `yes`, `n` , and `no`. Nothing too difficult here; we are just putting together
    things we already saw in the previous chapters. We start off with a clear instruction
    to clean the screen from any previous content, and then we ask the user for `yes`
    or `no` using an `echo -n`. So, we do not output any new lines, and the user answer
    will be on the same line after the double colon. The next step is to check against
    a list of characters.
  prefs: []
  type: TYPE_NORMAL
- en: '`[yY] | [yY][Ee][Ss] )` will match both the lower and capital `y` but also
    against `yes` and `YES` and all the mix between lower and capital characters in
    this string. If this matches, we inform the user that we are proceeding to archive
    the file. Notice `echo -e` that we used; this enables the interpretation of backslash
    escapes, so we can use `\n` to enter a new line and go to the next line on the
    terminal. The next instruction is a command substitution, so we get the output
    of the `date` command assigned to the now variable. What we are doing is creating
    the bits that will later concatenate to obtain a unique filename for our archive.
    In this case, we get a date composed by `year.month.day.hour.minute.second`. We
    will use this string to prefix our archive, so we will be able to obtain a unique
    filename every second. But this is also a limit, because if we create two archives
    at the same moment, the latter will overwrite the former, having both the names
    the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind your goals and limits and stick to them. When creating some variables
    or conditions, you have to think at the scope of your effort and not overthink
    about what you are doing. An example here is the prefix for the archive name.
    Giving us a name that is unique in the time range of a second allows us to have
    a new filename every single second, but it exposes us to the risk of having the
    archive overwritten if the same script is invoked twice at the same time, for
    instance, from two different terminals. To avoid this, we could create a function
    to forge random strings as prefix and avoid this issue or, at least, highly reduce
    the probability of a name collision. We will see later in this book how to create
    a random string, but is it worthy now? We are creating an example to show the
    use of case to process the user input and create an archive, so it is not likely
    that this script will be run twice at the same time. It could be great to catch
    this condition, but since it is not in the scope of this project, we will not
    do so, since the time spent will not be justified by the result and the likeliness
    of the event that it would prevent. On the opposite side, when writing a script,
    take your time to clarify to yourself what this script should do, what could be
    the pitfalls, which errors could occur, and the possible remedies you could code
    into the script itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Professional programming is not just coding, it is planning, trying to understand
    what could happen, what you want, and how to reach the goal. First, ask yourself
    what goal you want to accomplish, how to reach it, if you can realistically get
    to it with your knowledge, means, time, resources, and so on. Then, plan and develop
    accordingly. This applies to you as well as your clients since most of the time
    the hardest part is to understand what your customer really wants, being aware
    or not of it, how much time and resources it takes to code, and if the customer
    is willing to give you the time required and the resources needed. Finally, ask
    yourself if you can work on it given all these requisites. Let''s say that if
    you were asked to code a simple calculator in assembly, you probably could do
    so after learning it, practicing a bit, and then trying a few times. But could
    you do it if you were given three days, starting from scratch? So, define the
    goal, its limits and resources, plan the execution, think of the pitfalls your
    code could face and then, well, take into account a fair contingency: your computer
    could stop working, you can get a cold, anything can happen so keep a fair amount
    of time as a contingency because your client has a delivery date in mind, and
    you have to deliver your code on time, cold, flu, computer gone crazy given. Finally,
    stick to a routine. Let''s say you have four hours a day for coding and you know
    that in this amount of time, you can code 50 lines; but with exceptional effort,
    you could code 65 file lines. Do not take 65 lines into account and stick to an
    average amount. You are confident with this since you are going to code on a daily
    basis for quite a few days, and you cannot allow yourself to sprint every single
    day. Create your routine on an effort you know you can carry for a large amount
    of time so that you and your client do not incur an unpleasant situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after this digression, let''s go on and check the last couple of interesting
    commands in the `yes` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line helps us to find the name of the current directory using parameter
    expansions: we get the content of the `$PWD` environment variable and delete the
    longest matching for the pattern, in our case all the path up until the last forward
    slash, and assign the result to the variable called filename. The second instruction
    creates an archive from all the files contained in the local directory called `*`
    and create the archive name out of the different bits that we prepared beforehand.
    Note`${}`, which allows us to preserve the variable during the concatenation.
    So, now is the time to execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We were able to list the files held into the archive and a simple `ls` will
    double-check the outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All the files are in place and we can also see the newly created archive. But
    are we sure that everything is fine? Let''s create a `test` directory and copy
    all our files in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We copied the files in the `test` directory and set the directory permissions
    so that no one will be able to write into it. Now, let''s enter the directory
    and run our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Interesting, we see some error messages, but the script still says we have
    an archive file, let''s check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'No, we do not have any new archive, and this is exactly what we''d expect since
    our user cannot write anything in the test directory. So, it can happen; sometimes,
    our script faces an issue, such as it cannot write or read from a directory or
    some files, and this is what we have to plan now: a contingency method to deal
    with this possible issue. What we can do is test to check the exit code of the
    `tar` command: if it is different from `0`, it means that the archive creation
    failed somehow, otherwise everything went fine. So, let''s rewrite the `yes` clause
    adding a test after the `tar` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful not to write any command between `tar` and the `test`, since the
    `$?` traps the exit code of the last command executed. Now, let''s check the outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Not bad! Now, our script is telling us that something has gone wild, and it
    stopped telling us that the archive was successfully created even though the `tar`
    command was failing. Anyway, the output is a bit messy. We already know from our
    error message that there was an error, so let's clean the output by modifying `tar
    cvzf $now.${filename}.tgz * 2>/dev/null`.
  prefs: []
  type: TYPE_NORMAL
- en: We just redirected the standard error to `/dev/null`, so no errors will be displayed
    to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, it is preferable to mask the system or application errors
    and provide the customer with a more meaningful error message crafted by you.
    Bear in mind that not all users are system administrators or programmers and familiar
    with the operating system, application error messages, or codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is actually cleaner, and we could even go further and rip out the list of
    files. Do you know how to do it? A tip, the `stdout`…
  prefs: []
  type: TYPE_NORMAL
- en: 'But then, look at the following clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are the same, but we used `if` in a more idiomatic way, since its
    purpose is to test if a condition is true or not, so in this case if the command
    succeeded or failed. But then, you have many ways to accomplish the same result;
    take a look here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `remove` command, given inside the test directory, fails due to the lack
    of permissions, but let''s go up one directory and create a test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'I used the logical AND/OR operators to take advantage of what I usually called
    short circuit. Read the previous examples with the following grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '*If [command1] is true than we evaluate also command2 [but if the first clause
    is not true execute command3]*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the logical AND, both the commands called `rm test1` and `echo "file deleted"`
    must be true for the overall expression on the left of the OR (||). If the first
    command does not evaluate to true, the second is not even taken into account (short
    circuiting).
  prefs: []
  type: TYPE_NORMAL
- en: If the first part called `left_command && right_command` evaluates to be false,
    the OR comes into play and triggers the execution of the last command. But just
    in case that the first part, before `||` is true, then the second part will not
    be triggered. This is because, for the overall expression `left_command || right_command` to
    be true, it is enough for one of the two to be true and the first being true,
    the second command is not even evaluated (short circuiting).
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of error handling does not cause a script to exit in case of issues,
    and this can be desirable behavior most of the time, but sometimes, we could resort
    to a trick that would throw us out in case of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the exit from the script if any command, in subshell or braces,
    exits with a non-zero code. This does not apply if the failing command is part
    of a command list right after a while or until command, a part of the  *fi/elif*
    test in a *if/then/else/fi* statement, or is part of a set of commands executed
    following `&&` or `||`.
  prefs: []
  type: TYPE_NORMAL
- en: We will see more examples on how to use the case construct later on, as of now
    we are going to see something interesting that will affect the way you will collect,
    store, and process data. So, get ready for the arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Think of an array as a structure that can hold more than a single object, something
    like a variable with one or many values. Imagine you have a few friends and you
    want to write down their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the variables instanced, you can then deference them, deferencing
    being the act of retrieving a value. This is OK, but it somehow cages you into
    some limitations, such as you must call the exact variable name to access its
    value, you cannot easily cycle between them, you cannot tell the number of values
    so quickly, and more. For such operations, there is an appropriate structure,
    which comes at hand and allows us to work on the values as a single entity--this
    is the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements inside an array are indexed, and its position is assigned during
    the assignment, so `Anthony` will be at the first position and `Dionysios` at
    the fifth. But once declared and instanced, we can add elements to the array in
    a specific position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'How do you check if what is said so far is correct? A good way to do this would
    be accessing the different elements printing the values at the different positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'From the previous example, we can see a couple of interesting things:'
  prefs: []
  type: TYPE_NORMAL
- en: The first position of an array has an index of 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value is accessed in the form of `${array_name[index]}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not assigned, a position does not hold any value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can assign a value to any position using an index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add another person to the list now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it would be fine to have a way to print the whole content of the array
    at once, since the number of elements is growing, and it is taking a bit of time
    to echo all the indexed values. So, we can either use `array_name[@]` or `array_name[*]` to
    access the whole content of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What is interesting here is the position of `Ilaria` into the array. We inserted
    this name at position -2, so using a negative index provides a new feature introduced
    in Bash 4.2 that allows us to locate a position in the array starting from the
    end of it. So, -2 means two slots starting from the end of the array. But now,
    let''s go back to the array declaration. We just saw one way to create an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other ways to create an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the index must be a positive integer, since we do not have any
    slots to count backward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'No index needed here, even if given, it will be ignored. This way of declaring
    an array can be useful in cases when you do not yet know which values will be
    stored into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Even if you instance an array using another form, placing `declare -a array_name`
    before the instantiation can speed up subsequent operations on the array itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just declared an array named `friends` and used the read built-in, but this
    time, we gave the `-a` option ,which force read to get any words from the user
    and assigned to the named array indexes in a sequential order. Bear in mind that`-a`
    forces the unsetting of the array before the first assignment. Now, let''s try
    this wee script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'From Bash 4 on, there is a new type of array called an **associative array**.
    These are a bit different from the indexed arrays that we have seen so far: think
    of it as a set of two linked arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We just declared an associative array called `friends` and asked the user for
    two values, one a name and the other an email, but we stored them in two different
    variables instead of inserting them directly in an array. Inserting in the array
    was the next action. Use the name value as index and the address value as the
    linked content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For our demonstration purposes, we did not check the input, but have a look
    at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'An associative array index cannot be made entirely blank, so we can modify
    the previous script to add a check on the name value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We just checked for the `name` variable not to be unset or empty, and this saved
    us a lot of trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard argument separator on the command line is the space, but you can
    alter the way your script will read the single word that you give as an argument
    using the IFS environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute it and give arguments as `Anthony Mike`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the names are at the same index, so they are not treated as two different
    friends. So, let''s now use a comma to separate the names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Noel` is at index 0 and `Tarek` is at index 1, so they are actually
    distinct names stored in different positions of the array. But what if the user
    does not answer to it in a timely manner? Well, another environment variable can
    help us with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We just assigned a value of three seconds to the `TMOUT` environment variable,
    which defines the standard timeout period for both the shell and the read built-in.
    Used in the interactive shell, it causes the shell itself to exit if no input
    comes to the terminal before the timeout expires. Used with the read built-in,
    it defines the timeout period after which the commands terminates if no input
    is given. In our case, when the timeout is hit, we check the number of elements
    stored into the array: if it is equal to 0, we print a warning message and exit
    with 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In case we find something in the array, we cycle it and print all the values
    and associated indexes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Bash 4 introduced a new built-in mapfile, which is used to read lines from
    the standard input (the file descriptor if a `-u` option is provided) and load
    them into an indexed array. What can this be used for? Well, have a look at this--we
    start off creating a `file.txt` file with a list of our friends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a script that takes advantage of the mapfile built-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to see why `mapfile` is handy: we loaded all the lines from the
    file without using any loop or having to deal with each single line. In fact,
    using the built-in `read -a` would have loaded only the first line into the array,
    and we had to deal with the rest of the text file using some sort of loop. With
    `mapfile`, you just load everything and that is all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s recap the different ways we have to store values in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'It is quite straightforward. Select the position in the array using an index
    and assign the value. I can be any integer out of an arithmetic expression. If
    it is negative then the `i` positions from the last value are available in the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also omit the index, in this case, the value will be assigned to the
    index 0 slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This is true for the associative array as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `0` is actually a string used as a string, as it should be for
    an associative array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method to store data in an array is the compound assignment of values,
    as we saw before, but it works for indexed arrays only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'With this method, we have to be careful since the array is unset before the
    assignment, so all the previous values get lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can preserve the old content of the array using the `+=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have a compound assignment using keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This holds true for associative arrays as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Notice that an associative array does not imply a specific order in keys; as
    you can see from the previous example, they are unsorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we see the mapfile method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We used a slightly more compact form of the `mapfile` command, since we did
    not specify the name of the array to read the file content into. In this case,
    when no array is provided, `mapfile` stores the data into the default `MAPFILE`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the different methods for storing values, it''s time
    to retrieve them in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'I can be any integer out of an arithmetic expression. If it is negative, then
    the `i` positions from the last value are available in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We can notice a couple of interesting things here.
  prefs: []
  type: TYPE_NORMAL
- en: The `-2` index points to the last position in the array, which is filled in
    by `"fifth value"` minus the two slots, so we count backwards until we reach the
    5-2 slot. The third position in the array index 2 (the index count starts from
    0) and holds the string `"third value"`.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we used strings with spaces, thanks to the double quotes that preserved
    them. As a precaution while echoing, we quoted the retrieved value as well.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, we can retrieve the value of an element into an associative
    array using the form called  `$my_associative[string]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where the string is one of the keys stored into the array related to the values,
    we want to retrieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also retrieve all the stored values at once using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you do not want all the values, we can get them in *slices* using the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'With `S` being the index value we are starting from and `O` the offset for
    reading the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In both the examples, we started reading from the index position 3 and actually
    read the two following values. If we omit one of the values, the remaining will
    be taken in account as an offset from position 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also play with the substring removal operators that we saw earlier in
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: And so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `${array_name[@]}` and `${array_name[*]}` follow the same rules
    as `$@` and `$*` when it comes to the parameters expansion with the first notation
    seeing the parameters all as a single string and the latter as single words quoted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to store and retrieve data from an array, we have to see
    how to delete them. We can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unset array_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unset array_name[@]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unset array_name[*]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can unset a single value at a defined index position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This holds true for the associative arrays as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also assign nothing both to the array and the single values, either
    for the indexed or associative arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'For the associative array, just change this line in the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise again, change these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Some final notes are due for some interesting notations that we can use to
    deal with arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code explains the length of the array value pointed out at the
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting expansion that we can have on arrays is represented by:'
  prefs: []
  type: TYPE_NORMAL
- en: '#{#array_name[*]} or #{#array_name[@]}'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can expand to the number of elements in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We have all the elements now to see how we can loop through the content of
    an array. We can start with something easy that we have already seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple method with some restrictions: the index starts from 0 and
    the progression is expected to be sequential. But we can do something to overcome
    these limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We modified the `for` statement and now `i` will be instanced with each of
    the elements that we got from the `$(my_array[*]}` expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. We have access to the values, but what about the indexes?
    Just bear in mind that `${!array_name[@]}` and `${!array_name[*]}` expand to the
    list of indexes of the array. Just notice that using `@` in quotes expands each
    key into a single word. So, knowing this, we can retrieve both the values and
    the indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, something a bit more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We stored all the indexes of the friends array in another array called `indexes`,
    and then we used this latter to retrieve the content from the former one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see more on iterations shortly, but what we will focus on next is how
    to make our code clean, tidy, and reusable by taking advantage of another construct
    that Bash provides us with: the functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point of the book, we know enough to write our own code, process variables,
    interact with the user, and the environment, many things altogether, and so we
    are ready to make a mess. We know how to write a bunch of lines, but we still
    do not know how to keep things clean and tidy and, moreover, how to make our code
    reusable. As we can easily guess from the examples seen so far, a script or a
    command line is a one way processed flow of code; the characters making up our
    commands are read from left to right, from top to bottom. So, when you pass a
    construct or an assignment, it is done and if you want to process something the
    same way you did before; you have to rewrite the code that carried on the procedure
    again. So, if you are coding more than a small script you risk to end up with
    a huge amount of repetitive code, sloppy layout; and inefficiency; but Bash, like
    any other programming language, provides us with a method to overcome these issues.
    We are talking of functions. What are functions? An example will clarify what
    a function is better than many words. Let''s create a small fragment of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes two positional arguments as input to check if the first argument is
    less than the second assuming that the input is an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to try our brand new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'But it can also have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'It can even have a declared notation using the `function` keyword as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also have a one-line definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `;` after the last command. We also saw in [Chapter 4](part0075.html#27GQ60-8ae483f626fa439a8b6ee1bf9fb955ec)*, **Quoting
    and Escaping*, the use of anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever kind of declaration you want to use, a function is triggered simply
    by calling its name and accepting positional parameters such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in the previous chapter, a function can return a value, because bear
    in mind that the values processed inside a function are available only after the
    function itself has been triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we assigned the value of the first positional variable to
    the variable named `var`, and then printed this value from inside and outside
    the function, before it gets triggered and finally after it is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: We notice a couple of interesting things.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to print the value of `var` before the function is triggered, we
    do not get anything. This is because even though the code for the function is
    read before the command, the echo itself `echo "The value of var outside the function
    before it is triggered is: $var"` is executed before the function is triggered
    and has the chance to work on variables and assign a value to `var`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, just because `echo "The value of var outside the function before it
    is triggered is: $var"` is executed before the function itself, it actually is
    the first message printed on the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content assigned or created inside a function is available outside of it,
    because the function runs in the same shell context of the script, so they share
    the same environment and variables. But what if I wish to create variables that
    are available only inside the function itself? Let''s alter the assignment instruction
    by adding the local built-in before the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the script once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'We can hide variables from the main body of the script, but we can also get
    the function to return us something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we had a bit of fun creating a new function to print the actual
    messages shown to the user, and we can see on initial benefit of using functions:
    the code evaluating, if an integer is minor then another is now clean, holds less
    rows, and it is more readable. On the other hand, the print return takes as input
    the first two positional variables and takes the third as the return code (`$?`)
    of the minor function. Another benefit of introducing a function focused on printing
    messages to the user is that we introduced something else with it, a separation
    between the presentation layer, the `print_return` function, the elaboration layer,
    and the `minor` function. So, each time we want to modify how the information
    is shown to the user, we do not have to tinker with the core function, so we do
    not risk introducing any error in its code. On the other hand, if we want to work
    on the core function, we can make any modifications, and we do not have to modify
    the presentation layer as long as the output from the core remains the same.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have some functions that you think you can use in many of your scripts,
    it would be a good idea to write all of them in file, and then source the file
    from within your script and use them from there. This way you will have your own
    library of functions that you will reuse over time when needed without the burden
    of having to write them every single time.
  prefs: []
  type: TYPE_NORMAL
- en: 'But can we pass to a function variable that references other variables? Let''s
    try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `FIRST_VALUE` references `SECOND_VALUE`, which has a value of `20`, so
    we would expect to see `20` when we try to print `$FIRST_VALUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not what we were expecting, was it? This happens because Bash treats
    the variable name `SECOND_VALUE` as a bunch of characters. A mere is a string
    taken in its literal value and not as a pointer to a value called `(20)`. We can
    overcome this issue anyway; let''s just add `print_value "${!FIRST_VALUE}"` to
    the previous script before `exit 0` , and now we run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'We used what is called indirect referencing to actually reference the value
    of a value. This kind of notation called `$``{!variable_name}` introduced in Bash
    2 makes indirect referencing not so difficult to write down, but sometimes, you
    will find the old version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: What we see as `$$a` is actually the value of the value, and then we escape
    it and with `eval` , we force its evaluation and assignment it to `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about dereferencing a variable after it has been passed to a function?
    Here are some lines of code to play with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'So we started with a variable called `a10` holding the value of `10`. Then,
    we printed its value before triggering the function, and right afterwards, we
    called the function passing the name of the variable. The first step in the `print_value`
    function prints the value of the first positional argument passed to the function
    itself. Now, you have all the knowledge to read the code and get what has been
    done. We played a bit with indirect reference, deference, and a parameter substitution,
    so the simple output of the script should make it all clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we are: the value of `a10` changed from the original `20` to the new
    `30`, and now we know why and how. Before leaving the functions chapter, just
    a couple of notes: we already talked about anonymous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Just remember the last semicolon before the ending brace and also see the returned
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Once invoked, the script outputs a meaningful error message overcoming the
    limitations of the return built-in, which can only return integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code returns the value of `OK`, and being a block of code, a function
    `stdin` and `stdout` can be redirected easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: And that's all for now, it's time to move on and add some spice to our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You learned how to interact with users, read their input, and store it in appropriate
    structures, cycle though values, and take advantage of the functions to make our
    code tidy and reusable. So now it is time to explore some structures that we have
    already used a bit: we are talking about iterations.'
  prefs: []
  type: TYPE_NORMAL
