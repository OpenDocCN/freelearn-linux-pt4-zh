- en: Menus, Arrays, and Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单、数组和函数
- en: Writing a script often means having to deal with user interaction. You want
    to know what the user expects from your script, and you want to let the user know
    what options they have to decide from. So, we give the user some choices, they
    give us their answers, we evaluate them against some preset values, and decide
    what to do next. This implies a method to expose some data to the user, gather
    their answer, cycle between options, and react accordingly. There are different
    ways to do this, and we will see how to accomplish the task using some standard
    constructs. At the end of this chapter, we will be able to offer, gather, store,
    and process data efficiently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本通常意味着需要处理用户交互。你需要知道用户对脚本的期望，并让用户知道他们可以选择的选项。因此，我们提供一些选择给用户，他们提供答案，我们根据一些预设值来评估它们，并决定下一步要做什么。这就意味着要有一种方法，能够将一些数据展示给用户，收集他们的答案，循环选择项，并相应地做出反应。有多种方法可以实现这一点，我们将看到如何使用一些标准结构来完成这个任务。在本章结束时，我们将能够高效地提供、收集、存储和处理数据。
- en: The case statement
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: case语句
- en: 'When you are given more alternatives, you can process them with a sequence
    of if else statements:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有更多的选择时，可以通过一系列的if else语句来处理它们：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `if` clauses can be nested if needed, but in the long run, having more
    than a few choices messes up the code, making it less readable. One of the basic
    mantras of coding is exactly keeping the code readable, making it *elegant* since
    elegance here does not simply mean beautiful, but also consistent over time. Always
    keep a meaningful indentation so that the clauses will outstand. Try to use as
    little code as you can, adopt the same notation all through your script, and make
    it all compact and lean. So, having a cascade of *if/then/else/fi* with a lot
    of indentation cannot show up as the optimal decision for your script, but there
    is an alternative available and it is widely adopted to create user menus and
    process the data provided and it is the `case` statement in the following form:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`子句可以根据需要进行嵌套，但从长远来看，选择过多会使代码混乱，降低可读性。编程的基本原则之一就是保持代码可读性，使其*优雅*，因为优雅在这里不仅仅意味着美丽，还意味着在时间上保持一致性。始终保持有意义的缩进，使子句突出。尽量用尽可能少的代码，始终采用相同的符号表示法，使代码紧凑高效。因此，拥有一连串的*if/then/else/fi*，并且有大量缩进，可能并不是你的脚本的最佳选择，但有一种替代方法已经被广泛采用，那就是使用`case`语句，形式如下：'
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The expression is actually a condition that must match the pattern given in
    `condition x)`. Once the match is true, the corresponding block of commands are
    executed:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式实际上是一个条件，必须匹配`condition x)`中给定的模式。一旦匹配为真，对应的命令块就会被执行：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each of these block of commands is called a **clause** and is terminated by
    the `;;` double semicolon. All the case statements are enclosed in `case` and `esac `and
    each condition can be expressed either as `condition_1)` or `condition_1 | condition_2
    | condition_n)`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每一块命令被称为**子句**，并以`;;`双分号结束。所有的案例语句都包含在`case`和`esac`中，每个条件可以表示为`condition_1)`或`condition_1
    | condition_2 | condition_n)`。
- en: Each condition can be an alternative match for triggering the execution of the
    commands inside the clause.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条件都可以作为触发子句内部命令执行的替代匹配项。
- en: 'Let''s see two examples of how to deal with the same options using the *if/then/else/fi*
    and *case/esac* constructs:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看两个例子，展示如何使用*if/then/else/fi*和*case/esac*结构处理相同的选项：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s look at some tests:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些测试：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is not complex code. We are asking for some input, and then we will check
    for a couple of conditions whether the text entered is all made of digits or characters;
    otherwise we have `dunno` as the default answer. We used a slightly more complicated
    version of *if/then/else/fi.* We adopted `elif` to check an alternative option
    to match for our condition. We could have gone further with a series of `elif`
    to check if the user input some alphanumerics or other kinds of characters, but
    as you can see from this tiny example, the code is still becoming a bit difficult
    to read; it is not so clear. Now, let''s try something slightly different using
    the case statement:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是复杂的代码。我们请求一些输入，然后检查几个条件，看输入的文本是否完全由数字或字符组成；如果不是，则使用`dunno`作为默认答案。我们使用了稍微复杂一点的*if/then/else/fi*版本。我们采用了`elif`来检查另一个条件是否符合要求。我们本可以继续使用一系列`elif`来检查用户是否输入了字母数字或其他类型的字符，但从这个小示例中可以看出，代码开始变得有些难以阅读；它不那么清晰了。现在，让我们试试使用`case`语句，稍微做点不同的尝试：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What we do here is create a condition, so that we can strip all the alphabetic
    characters from the input variable value . What''s left is checked against `""`.
    What does it mean? It simply means that if after stripping the string of all alpha
    characters what''s left is an empty string. If the condition is not met we check
    against a second condition: if in what is left of the original strings there are
    some alphanumeric characters, it means that in the original string there were
    numeric characters. If even this second condition is met it means that in the
    stripped string there are chars other than numbers or alphabetic characters.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是创建一个条件，以便从输入变量值中去除所有字母字符。剩下的部分会与`""`进行比较。这意味着什么？它简单地表示，如果在去除字符串中的所有字母字符后，剩下的是一个空字符串。如果条件不满足，我们将检查第二个条件：如果剩下的原始字符串中还有一些字母数字字符，意味着原始字符串中包含了数字字符。如果第二个条件也满足，则意味着在去除字母和数字字符后，剩下的字符串中包含其他字符。
- en: 'Did you ever see or use a `case` statement before ? Yes, probably more often
    than you think. Let''s do something interesting now; we will see later why it
    is so interesting. Go to the `/et/init.d/` directory for Linux distribution, still
    **SystemV** compatible, and take a look at any of the scripts you find there.
    These are the scripts that deal with the startup/shutdown of system services such
    as cron or dbus along with all the additional services that can be offered such
    as ssh, Apache, and so forth. Looking at these scripts something pops out immediately,
    they have the following structure:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前见过或使用过`case`语句吗？是的，可能比你想象的更常见。现在让我们做点有趣的事情；稍后我们会看到为什么它如此有趣。前往Linux发行版的`/et/init.d/`目录，仍然是**SystemV**兼容的，并查看你在那里找到的任何脚本。这些是处理系统服务启动/关闭的脚本，例如cron或dbus，以及可以提供的其他服务，如ssh、Apache等。查看这些脚本时，有一件事立刻引起了注意，它们具有以下结构：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This can be used as a base for our interactive scripts, since it provides a
    bare bones structure to deal with user interaction. As you can see, each clause
    has `:`, as being a base script, nothing gets executed; and for each clause, we
    graciously exit with a success code except for the conditional restart and the
    default options. The conditional restart is really optional, but it lets you restart
    your service based on a condition you will impose, so it is up to you to leave
    or delete this section. As we saw earlier in this book, the `case` construct is
    somewhat similar to the *if/then/else/fi* construct with a condition to match
    against different strings given as options. The construct is enclosed between
    the `case` and `esac `markers; notice that `esac` is `case` read backwards. Consider
    the following clause:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以作为我们交互式脚本的基础，因为它提供了一个基本框架来处理用户交互。如你所见，每个条件后面都跟着一个`:`，作为基础脚本，没有任何操作会被执行；对于每个条件，我们都会优雅地退出并返回成功代码，除了条件重启和默认选项。条件重启实际上是可选的，但它允许你基于你设置的条件重新启动服务，所以是否保留或删除这个部分由你决定。正如我们在本书前面看到的，`case`结构有点类似于*if/then/else/fi*结构，后者用来匹配给定的不同字符串选项。该结构被`case`和`esac`标记包围；注意到`esac`是`case`的倒写。考虑以下条件：
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It starts with one or more strings to be matched; each possible match is separated
    by a `|` and ends with  `;;`. If more than one match is true, only the first is
    taken into account. The last option is usually an asterisk, and this can be considered
    as a catchall default since `*` matches whatever strings the user inputs. So,
    if no previous matches trigger a clause, this last one will be matched anyway
    and is a good place to write help or some command-line utilization messages, since
    it will always be displayed if the user did not enter the right options.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它以一个或多个需要匹配的字符串开始；每个可能的匹配项由`|`分隔，并以`;;`结束。如果有多个匹配项为真，只有第一个会被考虑。最后一个选项通常是一个星号，通常可以视为一个“通配符”，因为`*`会匹配用户输入的任何字符串。所以，如果前面的匹配项没有触发任何条件，这最后一个选项仍然会被匹配，通常用于编写帮助信息或一些命令行使用说明，因为如果用户没有输入正确的选项，它将始终显示。
- en: The string of patterns to match can be optionally preceded by `(`, for example, `(string1
    | string2 | stringn)`. Remember that the last `;;` before `esac` can be omitted
    without causing any issues.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配的模式字符串可以选择性地以`(`开头，例如，`(string1 | string2 | stringn)`。记住，在`esac`之前的最后一个`;;`可以省略，不会导致任何问题。
- en: Each string starting the clause is an optional match for case condition in. This is
    usually a string of text that must be checked for a match against each option
    string starting a clause. If the condition is a variable, it is expanded using
    the parameter expansion, variable expansion (tilde), command substitution, process
    substitution, and quote removal, but no pathname expansion, brace expansion, or
    word splitting is performed. Given that, you do not need to quote the variable
    for safe processing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开始子句的字符串是一个可选的匹配项，用于`case condition`中的匹配。通常，这是一个必须检查是否与每个开始子句的选项字符串匹配的文本字符串。如果条件是一个变量，它将通过参数扩展、变量扩展（波浪符）、命令替换、进程替换和去除引号来展开，但不会执行路径名扩展、大括号扩展或单词分割。鉴于此，你不需要对变量进行引号处理以确保安全处理。
- en: 'From Bash 4 a couple of clause terminators were introduced, and we already
    saw them in the previous chapter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从Bash 4开始，出现了一些子句终止符，我们已经在上一章中见过它们：
- en: '`;&` makes the execution continue with the commands associated with the next
    condition'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`;&`使得执行继续进行，并与下一个条件关联的命令被执行'
- en: '`;;&` makes the shell check the option and execute the associated commands
    if the condition is matched'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`;;&`使得Shell检查该选项，并在条件匹配时执行关联的命令'
- en: If no matches are found, the exit status is 0, otherwise the exit status is
    the one from the last command executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到匹配项，则退出状态为0，否则退出状态为最后执行的命令的状态。
- en: 'Let''s see how they word and proceed to modify the base script:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们是如何表述的，并继续修改基础脚本：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s try it out:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试试：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Without any arguments, there cannot be any matches on a given option, so the
    catchall asterisk comes into play and executes the echo printing the usage message
    on `stdout`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何参数，给定选项上无法找到匹配项，因此会触发全匹配星号，并执行`echo`打印使用信息到`stdout`：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All the other options are straightforward; we deleted the `condrestart` option
    just to make the script more compact and easy to read.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他选项都很简单；我们删除了`condrestart`选项只是为了使脚本更简洁、更易读。
- en: 'Now, let''s use the `;&` terminator on the last clause:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在最后一个子句上使用`;&`终止符：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, execute the script with status as the argument:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用状态作为参数执行脚本：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Ahem, embarrassing, nothing changed. Why? Have a closer look at the clause:
    the `;&` terminator is preceded by `exit 0`, so the execution of the script stops
    before hitting the terminator. Well, let''s delete `exit 0` and invoke the script
    again with the status argument:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，尴尬，什么都没变。为什么？仔细看看子句：`;&`终止符前面是`exit 0`，所以在达到终止符之前，脚本的执行就停止了。好吧，让我们删除`exit
    0`并再次使用状态参数调用脚本：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Interesting, isn''t it? We cascaded from one block to the other, so we had
    the status block commands executed right after the restart block commands got
    executed. And this is exactly what we expected from the `;&` operator, since the
    execution had to proceed to the next block where once the first condition was
    met. But now, let''s do something else and modify the restart clause as well:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣，不是吗？我们从一个块级跳转到另一个块，因此我们在执行重启块命令后，立即执行了状态块命令。这正是我们期望`;&`运算符的行为，因为执行需要继续到下一个块，一旦满足第一个条件。但是现在，让我们做点别的，修改重启子句：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s execute the script:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行脚本：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What happened? Simply put, once the `status` string was matched, the first
    `echo` command got executed and the `;&` operator caused the command associated
    to the restart clause to be invoked  without any other string check. In the restart
    clause, the `;;&` operator caused a string check on the following clause, but
    this being a string match against a wildcard, it matched anyway so the `echo` command
    of the `usage` string was executed. But what happens if we invert the operators
    between the status and restart clauses:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？简单来说，一旦匹配了`status`字符串，第一个`echo`命令被执行，并且`;&`运算符使得与重启子句关联的命令被调用，而没有进行其他字符串检查。在重启子句中，`;;&`运算符导致对下一个子句进行字符串检查，但由于这是与通配符的字符串匹配，它无论如何都匹配，因此执行了`usage`字符串的`echo`命令。但如果我们将状态子句和重启子句之间的运算符颠倒，会发生什么呢？
- en: '[PRE16]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We entered the `status` clause, executed the code, and then proceeded to the
    `restart` code. Here, the command was not executed since `;;&` triggers the command
    execution only if the string matches, but our `status` argument does not match
    the `restart` option. In the next line, we have  `;&`, which cascades us to the
    next clause, whose code is executed regardless of any matches. If you want to
    cause the commands in the `restart` clause to be executed anyway, just modify
    the matching options:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入了`status`条件，执行了代码，然后继续执行`restart`代码。这里命令并没有执行，因为`;;&`只有在字符串匹配时才会触发命令执行，但我们的`status`参数并不匹配`restart`选项。在下一行，我们使用了`;&`，这会将我们级联到下一个条件，且无论是否匹配，那个条件的代码都会被执行。如果你想强制执行`restart`条件下的命令，可以修改匹配选项：
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And now, let''s try this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试试看：
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, we gave two possible matches for the restart clause, `restart`
     or `status`. The first failed, but the second matched, and the command got executed,
    and then the next clause command got executed as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们提供了两个可能的重启条件匹配项，`restart`或`status`。第一个失败了，但第二个匹配上了，于是命令执行了，然后下一个条件命令也被执行了。
- en: 'We saw the `case` construct used in a startup script with minimal interaction
    with the user, but now, let''s start working on this construct to make something
    more interesting out of it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个启动脚本中看到过`case`结构，该结构与用户的交互较少，但现在，让我们开始使用这个结构，做出一些更有趣的事情：
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This simple script can be used to archive the content of a directory. It asks
    the user for the content and checks the answer against the lower and upper case
    `y` , `yes`, `n` , and `no`. Nothing too difficult here; we are just putting together
    things we already saw in the previous chapters. We start off with a clear instruction
    to clean the screen from any previous content, and then we ask the user for `yes`
    or `no` using an `echo -n`. So, we do not output any new lines, and the user answer
    will be on the same line after the double colon. The next step is to check against
    a list of characters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本可以用来归档一个目录的内容。它会询问用户内容，并将用户的回答与小写和大写的`y`、`yes`、`n`和`no`进行比对。这里没有什么难的，我们只是在将之前章节中学到的内容组合起来。我们首先清除屏幕上的所有旧内容，然后通过`echo
    -n`询问用户输入`yes`或`no`。这样我们就不会输出新的一行，用户的回答将出现在双冒号后面的同一行。接下来的步骤是与字符列表进行比对。
- en: '`[yY] | [yY][Ee][Ss] )` will match both the lower and capital `y` but also
    against `yes` and `YES` and all the mix between lower and capital characters in
    this string. If this matches, we inform the user that we are proceeding to archive
    the file. Notice `echo -e` that we used; this enables the interpretation of backslash
    escapes, so we can use `\n` to enter a new line and go to the next line on the
    terminal. The next instruction is a command substitution, so we get the output
    of the `date` command assigned to the now variable. What we are doing is creating
    the bits that will later concatenate to obtain a unique filename for our archive.
    In this case, we get a date composed by `year.month.day.hour.minute.second`. We
    will use this string to prefix our archive, so we will be able to obtain a unique
    filename every second. But this is also a limit, because if we create two archives
    at the same moment, the latter will overwrite the former, having both the names
    the same.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`[yY] | [yY][Ee][Ss] )`将匹配小写和大写的`y`，还会匹配`yes`、`YES`以及这些字符大小写混合的所有情况。如果匹配成功，我们会告知用户我们将继续归档文件。注意我们使用了`echo
    -e`，它允许解析反斜杠转义序列，因此我们可以使用`\n`来插入新的一行并跳到终端的下一行。接下来的指令是命令替换，我们将`date`命令的输出赋值给变量`now`。我们正在创建将来拼接成唯一归档文件名的部分。在这个例子中，我们得到了一个由`year.month.day.hour.minute.second`组成的日期。我们将使用这个字符串作为归档文件的前缀，这样每秒都会生成一个唯一的文件名。但这也是一个限制，因为如果我们在同一时刻创建两个归档，后者将覆盖前者，两个文件的名字是一样的。'
- en: Keep in mind your goals and limits and stick to them. When creating some variables
    or conditions, you have to think at the scope of your effort and not overthink
    about what you are doing. An example here is the prefix for the archive name.
    Giving us a name that is unique in the time range of a second allows us to have
    a new filename every single second, but it exposes us to the risk of having the
    archive overwritten if the same script is invoked twice at the same time, for
    instance, from two different terminals. To avoid this, we could create a function
    to forge random strings as prefix and avoid this issue or, at least, highly reduce
    the probability of a name collision. We will see later in this book how to create
    a random string, but is it worthy now? We are creating an example to show the
    use of case to process the user input and create an archive, so it is not likely
    that this script will be run twice at the same time. It could be great to catch
    this condition, but since it is not in the scope of this project, we will not
    do so, since the time spent will not be justified by the result and the likeliness
    of the event that it would prevent. On the opposite side, when writing a script,
    take your time to clarify to yourself what this script should do, what could be
    the pitfalls, which errors could occur, and the possible remedies you could code
    into the script itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 时刻牢记你的目标和限制，并坚持它们。在创建某些变量或条件时，你必须从你工作的范围出发，而不是过度思考你正在做的事情。这里的一个例子是归档名称的前缀。给我们一个在秒级时间范围内唯一的名称，允许我们每秒都有一个新的文件名，但如果相同的脚本在相同的时间被两次调用，例如从两个不同的终端调用，就有可能发生归档被覆盖的风险。为了避免这种情况，我们可以创建一个函数来伪造随机字符串作为前缀，从而避免这个问题，或者至少大大减少名称冲突的可能性。本书稍后会介绍如何创建一个随机字符串，但现在有必要吗？我们创建一个示例来展示如何使用`case`语句处理用户输入并创建归档，因此这个脚本不太可能在同一时间被执行两次。捕捉这种情况可能很好，但由于它不在这个项目的范围内，我们不会这样做，因为所花费的时间并不足以通过结果来证明其价值，也不太可能防止这种事件的发生。相反，在编写脚本时，要花时间明确自己脚本的功能，可能的陷阱，可能发生的错误，以及可以在脚本中编写的解决方案。
- en: 'Professional programming is not just coding, it is planning, trying to understand
    what could happen, what you want, and how to reach the goal. First, ask yourself
    what goal you want to accomplish, how to reach it, if you can realistically get
    to it with your knowledge, means, time, resources, and so on. Then, plan and develop
    accordingly. This applies to you as well as your clients since most of the time
    the hardest part is to understand what your customer really wants, being aware
    or not of it, how much time and resources it takes to code, and if the customer
    is willing to give you the time required and the resources needed. Finally, ask
    yourself if you can work on it given all these requisites. Let''s say that if
    you were asked to code a simple calculator in assembly, you probably could do
    so after learning it, practicing a bit, and then trying a few times. But could
    you do it if you were given three days, starting from scratch? So, define the
    goal, its limits and resources, plan the execution, think of the pitfalls your
    code could face and then, well, take into account a fair contingency: your computer
    could stop working, you can get a cold, anything can happen so keep a fair amount
    of time as a contingency because your client has a delivery date in mind, and
    you have to deliver your code on time, cold, flu, computer gone crazy given. Finally,
    stick to a routine. Let''s say you have four hours a day for coding and you know
    that in this amount of time, you can code 50 lines; but with exceptional effort,
    you could code 65 file lines. Do not take 65 lines into account and stick to an
    average amount. You are confident with this since you are going to code on a daily
    basis for quite a few days, and you cannot allow yourself to sprint every single
    day. Create your routine on an effort you know you can carry for a large amount
    of time so that you and your client do not incur an unpleasant situation.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 专业编程不仅仅是编码，它还包括规划，尝试理解可能发生的事情、你想要什么，以及如何达成目标。首先，问问自己你想要实现什么目标，如何实现，自己是否有足够的知识、资源、时间等来实现它。然后，做出相应的规划和开发。这不仅适用于你，也适用于你的客户，因为大多数时候最难的部分是理解客户真正想要的是什么，不管他是否意识到这一点，编码需要多少时间和资源，客户是否愿意给你足够的时间和资源。最后，问问自己，给定这些前提条件，你是否能够完成任务。假设你被要求用汇编语言编写一个简单的计算器，经过一些学习、练习和多次尝试，你可能可以完成。但如果你只有三天时间，从零开始，你能完成吗？所以，定义目标、目标的限制和资源，计划执行过程，考虑到你的代码可能遇到的陷阱，然后，考虑一个合理的应急预案：你的电脑可能会坏，或者你可能感冒了，任何事情都有可能发生，因此需要留出一定的应急时间，因为客户有一个交付日期，你必须按时交付代码，尽管可能有感冒、流感、电脑故障等情况。最后，保持规律。假设你每天有四小时的编码时间，你知道在这个时间内，你可以编写
    50 行代码；但如果付出额外的努力，你最多可以写 65 行代码。不要把 65 行作为目标，要坚持一个平均值。你应该对这个进度有信心，因为你会每天进行编码，而且不能每天都冲刺。根据你知道自己能持续一段时间的努力来制定规律，以避免自己和客户面临不愉快的局面。
- en: 'So, after this digression, let''s go on and check the last couple of interesting
    commands in the `yes` clause:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这段插曲之后，让我们继续检查 `yes` 条件中的最后几个有趣的命令：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first line helps us to find the name of the current directory using parameter
    expansions: we get the content of the `$PWD` environment variable and delete the
    longest matching for the pattern, in our case all the path up until the last forward
    slash, and assign the result to the variable called filename. The second instruction
    creates an archive from all the files contained in the local directory called `*`
    and create the archive name out of the different bits that we prepared beforehand.
    Note`${}`, which allows us to preserve the variable during the concatenation.
    So, now is the time to execute the script:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行帮助我们使用参数扩展找到当前目录的名称：我们获取 `$PWD` 环境变量的内容，并删除与模式匹配的最长部分，在我们的例子中是路径直到最后一个斜杠，并将结果赋值给名为
    filename 的变量。第二条指令从本地目录中所有文件创建一个归档文件，文件名为 `*`，并将之前准备好的不同部分合并成归档名。注意 `${}`，它允许我们在拼接时保留变量的值。那么，现在是执行脚本的时候了：
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We were able to list the files held into the archive and a simple `ls` will
    double-check the outcome:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够列出归档中的文件，简单的 `ls` 命令将再次确认结果：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All the files are in place and we can also see the newly created archive. But
    are we sure that everything is fine? Let''s create a `test` directory and copy
    all our files in it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文件都在正确的位置，我们也可以看到新创建的归档文件。但是我们能确保一切都正常吗？让我们创建一个 `test` 目录并将所有文件复制进去：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We copied the files in the `test` directory and set the directory permissions
    so that no one will be able to write into it. Now, let''s enter the directory
    and run our script:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件复制到 `test` 目录，并设置目录权限，以使任何人都无法写入。现在，让我们进入该目录并运行脚本：
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Interesting, we see some error messages, but the script still says we have
    an archive file, let''s check it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣，我们看到了一些错误消息，但脚本仍然说我们有一个归档文件，来检查一下：
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'No, we do not have any new archive, and this is exactly what we''d expect since
    our user cannot write anything in the test directory. So, it can happen; sometimes,
    our script faces an issue, such as it cannot write or read from a directory or
    some files, and this is what we have to plan now: a contingency method to deal
    with this possible issue. What we can do is test to check the exit code of the
    `tar` command: if it is different from `0`, it means that the archive creation
    failed somehow, otherwise everything went fine. So, let''s rewrite the `yes` clause
    adding a test after the `tar` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们没有新的归档文件，这正是我们预期的，因为我们的用户无法在测试目录中写入任何内容。因此，这种情况是有可能发生的；有时候，我们的脚本会遇到问题，比如它无法从目录或某些文件中读取或写入，这就是我们现在必须规划的事情：一个应急方法来应对这个潜在问题。我们可以做的是检查
    `tar` 命令的退出代码：如果它与 `0` 不同，表示归档创建失败，否则一切正常。所以，让我们重写 `yes` 条件，并在 `tar` 命令后添加一个测试：
- en: '[PRE26]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Be careful not to write any command between `tar` and the `test`, since the
    `$?` traps the exit code of the last command executed. Now, let''s check the outcome:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 小心不要在 `tar` 和 `test` 之间写任何命令，因为 `$?` 捕获的是最后执行命令的退出代码。现在，让我们检查一下结果：
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Not bad! Now, our script is telling us that something has gone wild, and it
    stopped telling us that the archive was successfully created even though the `tar`
    command was failing. Anyway, the output is a bit messy. We already know from our
    error message that there was an error, so let's clean the output by modifying `tar
    cvzf $now.${filename}.tgz * 2>/dev/null`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！现在，我们的脚本告诉我们发生了问题，并且它停止显示归档成功创建的消息，尽管 `tar` 命令失败了。无论如何，输出有点混乱。我们已经从错误消息中得知存在错误，所以让我们通过修改
    `tar cvzf $now.${filename}.tgz * 2>/dev/null` 来清理输出。
- en: We just redirected the standard error to `/dev/null`, so no errors will be displayed
    to `stdout`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将标准错误重定向到 `/dev/null`，所以错误信息不会显示到 `stdout`。
- en: Most of the time, it is preferable to mask the system or application errors
    and provide the customer with a more meaningful error message crafted by you.
    Bear in mind that not all users are system administrators or programmers and familiar
    with the operating system, application error messages, or codes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，最好是屏蔽系统或应用程序的错误，给客户提供由你设计的、更有意义的错误消息。请记住，并不是所有用户都是系统管理员或程序员，也不熟悉操作系统、应用程序错误消息或代码。
- en: 'Let''s have a look at the output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下输出：
- en: '[PRE28]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is actually cleaner, and we could even go further and rip out the list of
    files. Do you know how to do it? A tip, the `stdout`…
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这样其实更简洁，甚至可以进一步优化，去掉文件列表。你知道怎么做吗？提示：`stdout`…
- en: 'But then, look at the following clause:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，再看看以下语句：
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The results are the same, but we used `if` in a more idiomatic way, since its
    purpose is to test if a condition is true or not, so in this case if the command
    succeeded or failed. But then, you have many ways to accomplish the same result;
    take a look here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一样的，但我们使用 `if` 语句的方式更符合习惯，因为它的目的是测试条件是否为真，或者在本例中，命令是否成功或失败。不过，你有很多方法可以实现同样的结果；看看这里：
- en: '[PRE30]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `remove` command, given inside the test directory, fails due to the lack
    of permissions, but let''s go up one directory and create a test file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试目录中，`remove` 命令因权限不足而失败，但我们可以向上进入一个目录并创建一个测试文件：
- en: '[PRE31]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'I used the logical AND/OR operators to take advantage of what I usually called
    short circuit. Read the previous examples with the following grammar:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了逻辑与/或运算符来利用我通常称之为短路的特性。请阅读以下语法的前述示例：
- en: '*If [command1] is true than we evaluate also command2 [but if the first clause
    is not true execute command3]*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果 [command1] 为真，则我们也会评估命令2 [但如果第一个条件不为真，则执行命令3]*'
- en: Using the logical AND, both the commands called `rm test1` and `echo "file deleted"`
    must be true for the overall expression on the left of the OR (||). If the first
    command does not evaluate to true, the second is not even taken into account (short
    circuiting).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑与（AND），`rm test1` 和 `echo "file deleted"` 两个命令都必须为真，整体表达式才会成立（在 OR（||）的左侧）。如果第一个命令未能返回真，第二个命令将不会被考虑（短路）。
- en: If the first part called `left_command && right_command` evaluates to be false,
    the OR comes into play and triggers the execution of the last command. But just
    in case that the first part, before `||` is true, then the second part will not
    be triggered. This is because, for the overall expression `left_command || right_command` to
    be true, it is enough for one of the two to be true and the first being true,
    the second command is not even evaluated (short circuiting).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个部分`left_command && right_command`的结果为假，OR操作会触发最后一个命令的执行。但如果在`||`之前的第一个部分为真，则第二部分不会被触发。因为对于整体表达式`left_command
    || right_command`来说，只要其中一个为真即可，若第一个为真，则第二个命令甚至不会被评估（短路）。
- en: 'This kind of error handling does not cause a script to exit in case of issues,
    and this can be desirable behavior most of the time, but sometimes, we could resort
    to a trick that would throw us out in case of errors:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误处理方式在出现问题时不会导致脚本退出，这在大多数情况下是可取的行为，但有时我们也可以使用一个技巧，在出错时让我们退出：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will cause the exit from the script if any command, in subshell or braces,
    exits with a non-zero code. This does not apply if the failing command is part
    of a command list right after a while or until command, a part of the  *fi/elif*
    test in a *if/then/else/fi* statement, or is part of a set of commands executed
    following `&&` or `||`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何命令在子shell或大括号中退出时返回非零代码，这将导致脚本退出。如果失败的命令是紧跟在`while`或`until`命令后的命令列表的一部分，或者是*fi/elif*测试的一部分，或是在`&&`或`||`后执行的命令的一部分，则不适用此规则。
- en: We will see more examples on how to use the case construct later on, as of now
    we are going to see something interesting that will affect the way you will collect,
    store, and process data. So, get ready for the arrays.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到更多关于如何使用case构造的例子，目前我们要看一些有趣的内容，它将影响你收集、存储和处理数据的方式。所以，准备好学习数组吧。
- en: Arrays
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Think of an array as a structure that can hold more than a single object, something
    like a variable with one or many values. Imagine you have a few friends and you
    want to write down their names:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组看作一种可以容纳多个对象的结构，类似于一个具有一个或多个值的变量。想象一下你有几个朋友，你想把他们的名字写下来：
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once you have the variables instanced, you can then deference them, deferencing
    being the act of retrieving a value. This is OK, but it somehow cages you into
    some limitations, such as you must call the exact variable name to access its
    value, you cannot easily cycle between them, you cannot tell the number of values
    so quickly, and more. For such operations, there is an appropriate structure,
    which comes at hand and allows us to work on the values as a single entity--this
    is the array:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你实例化了变量，你就可以进行解引用，解引用是指检索一个值的操作。这是可以的，但它在某种程度上将你限制在一些局限性中，例如你必须调用准确的变量名才能访问它的值，不能轻松地在它们之间循环，不能快速判断值的数量，等等。针对这些操作，有一种合适的结构，它为我们提供了方便，使我们可以将这些值作为一个整体进行处理——这就是数组：
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The elements inside an array are indexed, and its position is assigned during
    the assignment, so `Anthony` will be at the first position and `Dionysios` at
    the fifth. But once declared and instanced, we can add elements to the array in
    a specific position:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的元素是有索引的，位置是在赋值时确定的，所以`Anthony`将位于第一个位置，`Dionysios`位于第五个位置。但一旦声明并实例化，我们可以在特定位置向数组添加元素：
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'How do you check if what is said so far is correct? A good way to do this would
    be accessing the different elements printing the values at the different positions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么检查目前为止所说的是否正确？一个好方法是访问不同的元素，并打印出不同位置的值：
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'From the previous example, we can see a couple of interesting things:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的例子中，我们可以看到一些有趣的事情：
- en: The first position of an array has an index of 0
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的第一个位置的索引是0。
- en: A value is accessed in the form of `${array_name[index]}`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`${array_name[index]}`的形式访问一个值。
- en: If not assigned, a position does not hold any value
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有赋值，一个位置不会持有任何值。
- en: We can assign a value to any position using an index
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用索引给任何位置赋值。
- en: 'Let''s add another person to the list now:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来给列表添加另一个人：
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, it would be fine to have a way to print the whole content of the array
    at once, since the number of elements is growing, and it is taking a bit of time
    to echo all the indexed values. So, we can either use `array_name[@]` or `array_name[*]` to
    access the whole content of the array:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果能有一种方法一次性打印出整个数组的内容就好了，因为元素数量在增长，回显所有索引值需要一些时间。所以，我们可以使用`array_name[@]`或者`array_name[*]`来访问数组的全部内容：
- en: '[PRE38]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What is interesting here is the position of `Ilaria` into the array. We inserted
    this name at position -2, so using a negative index provides a new feature introduced
    in Bash 4.2 that allows us to locate a position in the array starting from the
    end of it. So, -2 means two slots starting from the end of the array. But now,
    let''s go back to the array declaration. We just saw one way to create an array:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是`Ilaria`在数组中的位置。我们将这个名字插入到位置-2，因此使用负索引提供了Bash 4.2中引入的新功能，允许我们从数组的末尾开始定位位置。所以，-2意味着从数组末尾开始两个插槽。但现在，让我们回到数组声明。我们刚刚看到了一种创建数组的方式：
- en: '[PRE39]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are other ways to create an array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方式可以创建数组：
- en: '[PRE40]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case, the index must be a positive integer, since we do not have any
    slots to count backward:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，索引必须是正整数，因为我们没有任何插槽可以向后计数：
- en: '[PRE41]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'No index needed here, even if given, it will be ignored. This way of declaring
    an array can be useful in cases when you do not yet know which values will be
    stored into it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要索引，即使给出，也会被忽略。这种声明数组的方式在你还不知道将存储哪些值时非常有用：
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Even if you instance an array using another form, placing `declare -a array_name`
    before the instantiation can speed up subsequent operations on the array itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用另一种形式实例化数组，在实例化之前放置`declare -a array_name`也能加速后续对数组本身的操作。
- en: 'We just declared an array named `friends` and used the read built-in, but this
    time, we gave the `-a` option ,which force read to get any words from the user
    and assigned to the named array indexes in a sequential order. Bear in mind that`-a`
    forces the unsetting of the array before the first assignment. Now, let''s try
    this wee script:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚声明了一个名为`friends`的数组，并使用了内置的read命令，但这次我们给了`-a`选项，强制read从用户那里获取任何单词，并按顺序分配给命名数组的索引。请注意，`-a`会在第一次赋值前强制取消数组的设置。现在，让我们试试这个小脚本：
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'From Bash 4 on, there is a new type of array called an **associative array**.
    These are a bit different from the indexed arrays that we have seen so far: think
    of it as a set of two linked arrays:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从Bash 4开始，有一种新的数组类型，称为**关联数组**。它们与我们之前看到的索引数组稍有不同：可以把它想象成一组两个关联的数组：
- en: '[PRE44]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We just declared an associative array called `friends` and asked the user for
    two values, one a name and the other an email, but we stored them in two different
    variables instead of inserting them directly in an array. Inserting in the array
    was the next action. Use the name value as index and the address value as the
    linked content:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚声明了一个名为`friends`的关联数组，并请求用户提供两个值，一个是名称，另一个是电子邮件，但我们将它们存储在两个不同的变量中，而不是直接插入数组。插入数组是接下来的操作。使用名称值作为索引，地址值作为关联内容：
- en: '[PRE45]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For our demonstration purposes, we did not check the input, but have a look
    at this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们没有检查输入，但请看这个：
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'An associative array index cannot be made entirely blank, so we can modify
    the previous script to add a check on the name value:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组的索引不能完全为空，因此我们可以修改之前的脚本，添加对名称值的检查：
- en: '[PRE47]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We just checked for the `name` variable not to be unset or empty, and this saved
    us a lot of trouble.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚检查了`name`变量是否未设置或为空，这为我们省去了很多麻烦。
- en: 'The standard argument separator on the command line is the space, but you can
    alter the way your script will read the single word that you give as an argument
    using the IFS environment variable:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行上的标准参数分隔符是空格，但你可以使用IFS环境变量改变脚本读取单个参数的方式：
- en: '[PRE48]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let''s execute it and give arguments as `Anthony Mike`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行它并提供参数`Anthony Mike`：
- en: '[PRE49]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Both the names are at the same index, so they are not treated as two different
    friends. So, let''s now use a comma to separate the names:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 两个名称位于相同的索引位置，因此它们不会被视为两个不同的朋友。那么，让我们现在用逗号来分隔这些名称：
- en: '[PRE50]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, `Noel` is at index 0 and `Tarek` is at index 1, so they are actually
    distinct names stored in different positions of the array. But what if the user
    does not answer to it in a timely manner? Well, another environment variable can
    help us with this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Noel`位于索引0，而`Tarek`位于索引1，因此它们实际上是不同的名称，存储在数组的不同位置。但是，如果用户没有及时回答呢？嗯，另一个环境变量可以帮助我们：
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We just assigned a value of three seconds to the `TMOUT` environment variable,
    which defines the standard timeout period for both the shell and the read built-in.
    Used in the interactive shell, it causes the shell itself to exit if no input
    comes to the terminal before the timeout expires. Used with the read built-in,
    it defines the timeout period after which the commands terminates if no input
    is given. In our case, when the timeout is hit, we check the number of elements
    stored into the array: if it is equal to 0, we print a warning message and exit
    with 1:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将三秒的值赋给了`TMOUT`环境变量，该变量定义了shell和`read`内建命令的标准超时周期。用于交互式shell时，如果在超时到期之前终端没有输入，shell本身会退出。与`read`内建命令一起使用时，它定义了超时周期，如果没有输入，命令将在超时后终止。在我们的案例中，当超时发生时，我们会检查存入数组中的元素数量：如果为0，我们会打印警告信息并以1退出：
- en: '[PRE52]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In case we find something in the array, we cycle it and print all the values
    and associated indexes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在数组中找到某个元素，我们将循环并打印所有值和相关索引。
- en: '[PRE53]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Bash 4 introduced a new built-in mapfile, which is used to read lines from
    the standard input (the file descriptor if a `-u` option is provided) and load
    them into an indexed array. What can this be used for? Well, have a look at this--we
    start off creating a `file.txt` file with a list of our friends:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 4引入了一个新的内建命令`mapfile`，用于从标准输入（如果提供了`-u`选项，则是文件描述符）读取行，并将其加载到索引数组中。这个可以用来做什么呢？来看一下这个示例——我们首先创建一个名为`file.txt`的文件，里面列出了我们的朋友：
- en: '[PRE54]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s create a script that takes advantage of the mapfile built-in:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个脚本，利用`mapfile`内建命令：
- en: '[PRE55]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, let''s run the script:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们运行脚本：
- en: '[PRE56]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It''s easy to see why `mapfile` is handy: we loaded all the lines from the
    file without using any loop or having to deal with each single line. In fact,
    using the built-in `read -a` would have loaded only the first line into the array,
    and we had to deal with the rest of the text file using some sort of loop. With
    `mapfile`, you just load everything and that is all.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出为什么`mapfile`很有用：我们加载了文件中的所有行，而不需要使用任何循环或处理每一行。事实上，如果使用内建的`read -a`，它只会将文件的第一行加载到数组中，之后我们还得用某种循环处理文件的其余部分。使用`mapfile`时，你只需要加载所有内容，就这么简单。
- en: 'So, let''s recap the different ways we have to store values in an array:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们回顾一下存储值到数组中的不同方法：
- en: '[PRE57]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It is quite straightforward. Select the position in the array using an index
    and assign the value. I can be any integer out of an arithmetic expression. If
    it is negative then the `i` positions from the last value are available in the
    array:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接。通过索引选择数组中的位置并赋值。它可以是任何算术表达式中的整数。如果是负数，那么数组中可以访问从最后一个值开始的`i`个位置：
- en: '[PRE58]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can also omit the index, in this case, the value will be assigned to the
    index 0 slot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以省略索引，在这种情况下，值将被分配到索引0位置：
- en: '[PRE59]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is true for the associative array as well:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关联数组来说也是如此：
- en: '[PRE60]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this case, `0` is actually a string used as a string, as it should be for
    an associative array.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`0`实际上是作为字符串使用的，正如它在关联数组中应该是的。
- en: 'Another method to store data in an array is the compound assignment of values,
    as we saw before, but it works for indexed arrays only:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据到数组中的另一种方法是之前看到的复合赋值，但它只适用于索引数组：
- en: '[PRE61]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With this method, we have to be careful since the array is unset before the
    assignment, so all the previous values get lost:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法时，我们需要小心，因为数组在赋值之前会被取消设置，因此所有之前的值都会丢失：
- en: '[PRE62]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can preserve the old content of the array using the `+=` operator:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`+=`操作符保留数组中的旧内容：
- en: '[PRE63]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, we have a compound assignment using keys:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用键进行复合赋值：
- en: '[PRE64]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This holds true for associative arrays as well:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组也是如此：
- en: '[PRE65]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that an associative array does not imply a specific order in keys; as
    you can see from the previous example, they are unsorted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关联数组并不意味着键的顺序；正如从前面的示例中看到的，它们是无序的。
- en: 'Finally, we see the mapfile method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到`mapfile`方法：
- en: '[PRE66]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We used a slightly more compact form of the `mapfile` command, since we did
    not specify the name of the array to read the file content into. In this case,
    when no array is provided, `mapfile` stores the data into the default `MAPFILE`
    array.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了稍微更紧凑的`mapfile`命令形式，因为我们没有指定数组的名称来读取文件内容。在这种情况下，当没有提供数组时，`mapfile`会将数据存储到默认的`MAPFILE`数组中。
- en: 'Now that we have seen the different methods for storing values, it''s time
    to retrieve them in various ways:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了不同的存储值的方法，是时候以各种方式检索它们了：
- en: '[PRE67]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'I can be any integer out of an arithmetic expression. If it is negative, then
    the `i` positions from the last value are available in the array:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`i` 可以是算术表达式中的任何整数。如果它是负数，那么数组中距离最后一个值 `i` 个位置的值将可用：'
- en: '[PRE68]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We can notice a couple of interesting things here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到这里有几个有趣的点。
- en: The `-2` index points to the last position in the array, which is filled in
    by `"fifth value"` minus the two slots, so we count backwards until we reach the
    5-2 slot. The third position in the array index 2 (the index count starts from
    0) and holds the string `"third value"`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`-2` 索引指向数组中的最后一个位置，该位置被 `"fifth value"` 填充，并减去两个槽，因此我们从后往前数，直到到达 5-2 的槽。数组索引中的第三个位置（索引从
    0 开始）包含字符串 `"third value"`。'
- en: Second, we used strings with spaces, thanks to the double quotes that preserved
    them. As a precaution while echoing, we quoted the retrieved value as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们使用了带有空格的字符串，得益于双引号将它们保留了下来。为了确保输出正确，我们在回显时也引用了检索到的值。
- en: In a similar way, we can retrieve the value of an element into an associative
    array using the form called  `$my_associative[string]`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过使用名为`$my_associative[string]`的形式，将元素的值检索到关联数组中。
- en: 'Where the string is one of the keys stored into the array related to the values,
    we want to retrieve this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 其中字符串是存储在数组中的与我们想要检索的值相关的键之一：
- en: '[PRE69]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can also retrieve all the stored values at once using this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以一次性检索所有存储的值，使用以下方式：
- en: '[PRE70]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we can see from the following examples:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从以下示例中看到的：
- en: '[PRE71]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'But if you do not want all the values, we can get them in *slices* using the
    following syntax:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不想要所有的值，我们可以通过以下语法以 *切片* 的方式获取它们：
- en: '[PRE72]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With `S` being the index value we are starting from and `O` the offset for
    reading the values:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `S` 为我们开始的索引值，`O` 为读取值的偏移量：
- en: '[PRE73]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In both the examples, we started reading from the index position 3 and actually
    read the two following values. If we omit one of the values, the remaining will
    be taken in account as an offset from position 0:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，我们从索引位置 3 开始读取，实际上读取了接下来的两个值。如果我们省略其中一个值，剩余的值将作为从位置 0 开始的偏移量来考虑：
- en: '[PRE74]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can also play with the substring removal operators that we saw earlier in
    this book:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用本书中前面提到的子字符串删除操作符：
- en: '[PRE75]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Or:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE76]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Or:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE77]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: And so forth.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推。
- en: Notice that `${array_name[@]}` and `${array_name[*]}` follow the same rules
    as `$@` and `$*` when it comes to the parameters expansion with the first notation
    seeing the parameters all as a single string and the latter as single words quoted.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`${array_name[@]}`和`${array_name[*]}`在参数扩展时遵循与`$@`和`$*`相同的规则，第一个表示将所有参数视为一个单一字符串，后者则将参数视为单独的单词并加以引用。
- en: 'Now that we know how to store and retrieve data from an array, we have to see
    how to delete them. We can use the following commands:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何从数组中存储和检索数据，接下来要看看如何删除它们。我们可以使用以下命令：
- en: '`unset array_name`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unset array_name`'
- en: '`unset array_name[@]`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unset array_name[@]`'
- en: '`unset array_name[*]`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unset array_name[*]`'
- en: 'Have a look at the following examples:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE78]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can unset a single value at a defined index position:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在定义的索引位置取消设置单个值：
- en: '[PRE79]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This holds true for the associative arrays as well:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关联数组也是如此：
- en: '[PRE80]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As you can see from the following output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下输出中所看到的：
- en: '[PRE81]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can also assign nothing both to the array and the single values, either
    for the indexed or associative arrays:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将空值分配给数组和单个值，无论是对于索引数组还是关联数组：
- en: '[PRE82]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Or:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE83]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'For the associative array, just change this line in the previous script:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关联数组，只需在前面的脚本中修改这一行：
- en: '[PRE84]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, run it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行它：
- en: '[PRE85]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Otherwise again, change these lines:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，再次修改这些行：
- en: '[PRE86]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, run the script:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行脚本：
- en: '[PRE87]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Some final notes are due for some interesting notations that we can use to
    deal with arrays:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些最终说明，涉及一些我们可以用来处理数组的有趣符号：
- en: '[PRE88]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The following code explains the length of the array value pointed out at the
    index:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码解释了在索引位置指向的数组值的长度：
- en: '[PRE89]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Or:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE90]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Another interesting expansion that we can have on arrays is represented by:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的另一个有趣扩展是：
- en: '#{#array_name[*]} or #{#array_name[@]}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '#{#array_name[*]} 或 #{#array_name[@]}'
- en: 'This can expand to the number of elements in the array:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以扩展为数组中的元素数量：
- en: '[PRE91]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Or:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE92]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This gives us the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了以下结果：
- en: '[PRE93]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We have all the elements now to see how we can loop through the content of
    an array. We can start with something easy that we have already seen:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了所有元素，可以看看如何遍历数组的内容。我们可以从已经看到的简单例子开始：
- en: '[PRE94]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, let''s execute it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行它：
- en: '[PRE95]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This is a simple method with some restrictions: the index starts from 0 and
    the progression is expected to be sequential. But we can do something to overcome
    these limitations:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的方法，但有一些限制：索引从0开始，并且预期进展是顺序的。但我们可以做一些事情来克服这些限制：
- en: '[PRE96]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We modified the `for` statement and now `i` will be instanced with each of
    the elements that we got from the `$(my_array[*]}` expansion:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了`for`语句，现在`i`将实例化为从`$(my_array[*]}`扩展中获得的每个元素：
- en: '[PRE97]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'So far, so good. We have access to the values, but what about the indexes?
    Just bear in mind that `${!array_name[@]}` and `${!array_name[*]}` expand to the
    list of indexes of the array. Just notice that using `@` in quotes expands each
    key into a single word. So, knowing this, we can retrieve both the values and
    the indexes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们可以访问值，但索引呢？请记住，`${!array_name[@]}` 和 `${!array_name[*]}` 展开为数组的索引列表。只需注意，在引号中使用`@`会将每个键展开为一个单独的单词。因此，了解这一点后，我们可以同时检索值和索引：
- en: '[PRE98]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This will give us the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下结果：
- en: '[PRE99]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Finally, something a bit more complex:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，稍微复杂一点的内容：
- en: '[PRE100]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We stored all the indexes of the friends array in another array called `indexes`,
    and then we used this latter to retrieve the content from the former one:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将朋友数组的所有索引存储在另一个名为`indexes`的数组中，然后使用它来从前一个数组中获取内容：
- en: '[PRE101]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We will see more on iterations shortly, but what we will focus on next is how
    to make our code clean, tidy, and reusable by taking advantage of another construct
    that Bash provides us with: the functions.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会看到更多关于迭代的内容，但接下来我们要关注的是如何通过利用 Bash 提供的另一个构造——函数——来使我们的代码简洁、整洁并且可重用。
- en: Functions
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'At this point of the book, we know enough to write our own code, process variables,
    interact with the user, and the environment, many things altogether, and so we
    are ready to make a mess. We know how to write a bunch of lines, but we still
    do not know how to keep things clean and tidy and, moreover, how to make our code
    reusable. As we can easily guess from the examples seen so far, a script or a
    command line is a one way processed flow of code; the characters making up our
    commands are read from left to right, from top to bottom. So, when you pass a
    construct or an assignment, it is done and if you want to process something the
    same way you did before; you have to rewrite the code that carried on the procedure
    again. So, if you are coding more than a small script you risk to end up with
    a huge amount of repetitive code, sloppy layout; and inefficiency; but Bash, like
    any other programming language, provides us with a method to overcome these issues.
    We are talking of functions. What are functions? An example will clarify what
    a function is better than many words. Let''s create a small fragment of code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们已经足够了解如何编写自己的代码，处理变量，与用户和环境交互，做很多事情，因此我们已经准备好制造混乱了。我们知道如何写一堆代码行，但我们仍然不知道如何保持代码整洁、简洁，更重要的是，如何使代码可重用。正如我们从到目前为止的示例中轻松猜到的那样，脚本或命令行是单向处理的代码流；构成我们命令的字符是从左到右、从上到下读取的。因此，当你传递一个构造或赋值时，它就完成了，如果你想按照之前的方式处理某些内容，你必须再次编写执行该过程的代码。所以，如果你编写的不仅仅是一个小脚本，你很可能会陷入大量重复代码、凌乱布局和低效的困境；但
    Bash 和其他任何编程语言一样，为我们提供了一种方法来克服这些问题。我们说的就是函数。什么是函数？一个例子比千言万语更能说明函数的作用。让我们创建一个小的代码片段：
- en: '[PRE102]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'It takes two positional arguments as input to check if the first argument is
    less than the second assuming that the input is an integer:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受两个位置参数作为输入，以检查第一个参数是否小于第二个参数，假设输入的是整数：
- en: '[PRE103]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Time to try our brand new function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候尝试我们全新的函数了：
- en: '[PRE104]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'But it can also have the following structure:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但它也可以有如下结构：
- en: '[PRE105]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'It can even have a declared notation using the `function` keyword as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至可以使用`function`关键字来声明，如下所示：
- en: '[PRE106]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can also have a one-line definition:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以有一个单行定义：
- en: '[PRE107]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Notice the `;` after the last command. We also saw in [Chapter 4](part0075.html#27GQ60-8ae483f626fa439a8b6ee1bf9fb955ec)*, **Quoting
    and Escaping*, the use of anonymous functions.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一个命令后的`;`。我们在[第4章](part0075.html#27GQ60-8ae483f626fa439a8b6ee1bf9fb955ec)*,
    **引用和转义**中也看到了匿名函数的使用。
- en: 'Whatever kind of declaration you want to use, a function is triggered simply
    by calling its name and accepting positional parameters such as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想使用什么样的声明，函数只需通过调用它的名称并接受位置参数来触发，如下所示：
- en: '[PRE108]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'As we saw in the previous chapter, a function can return a value, because bear
    in mind that the values processed inside a function are available only after the
    function itself has been triggered:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章所看到的，函数可以返回一个值，因为请记住，函数内部处理的值只有在函数被触发后才可用：
- en: '[PRE109]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In this example, we assigned the value of the first positional variable to
    the variable named `var`, and then printed this value from inside and outside
    the function, before it gets triggered and finally after it is triggered:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将第一个位置变量的值赋给了名为`var`的变量，然后在函数内外打印这个值，直到它被触发之前以及触发之后：
- en: '[PRE110]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We notice a couple of interesting things.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到了一些有趣的事情。
- en: 'If we try to print the value of `var` before the function is triggered, we
    do not get anything. This is because even though the code for the function is
    read before the command, the echo itself `echo "The value of var outside the function
    before it is triggered is: $var"` is executed before the function is triggered
    and has the chance to work on variables and assign a value to `var`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们尝试在函数触发之前打印 `var` 的值，我们什么也得不到。这是因为尽管函数的代码在命令之前被读取，但 `echo "The value of
    var outside the function before it is triggered is: $var"` 这条语句在函数触发之前执行，因而没有机会操作变量并给
    `var` 赋值。'
- en: 'Second, just because `echo "The value of var outside the function before it
    is triggered is: $var"` is executed before the function itself, it actually is
    the first message printed on the terminal.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '其次，`echo "The value of var outside the function before it is triggered is:
    $var"` 这条语句虽然在函数之前执行，但它实际上是第一个在终端上打印的消息。'
- en: 'The content assigned or created inside a function is available outside of it,
    because the function runs in the same shell context of the script, so they share
    the same environment and variables. But what if I wish to create variables that
    are available only inside the function itself? Let''s alter the assignment instruction
    by adding the local built-in before the variable:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部赋值或创建的内容在函数外部是可用的，因为函数在与脚本相同的 Shell 上下文中运行，因此它们共享相同的环境和变量。但如果我希望创建只在函数内部可用的变量呢？我们可以通过在变量前添加
    `local` 内建命令来修改赋值指令：
- en: '[PRE111]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We run the script once again:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行脚本：
- en: '[PRE112]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We can hide variables from the main body of the script, but we can also get
    the function to return us something:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将变量从脚本的主体中隐藏，但我们也可以让函数返回一些值：
- en: '[PRE113]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In this example, we had a bit of fun creating a new function to print the actual
    messages shown to the user, and we can see on initial benefit of using functions:
    the code evaluating, if an integer is minor then another is now clean, holds less
    rows, and it is more readable. On the other hand, the print return takes as input
    the first two positional variables and takes the third as the return code (`$?`)
    of the minor function. Another benefit of introducing a function focused on printing
    messages to the user is that we introduced something else with it, a separation
    between the presentation layer, the `print_return` function, the elaboration layer,
    and the `minor` function. So, each time we want to modify how the information
    is shown to the user, we do not have to tinker with the core function, so we do
    not risk introducing any error in its code. On the other hand, if we want to work
    on the core function, we can make any modifications, and we do not have to modify
    the presentation layer as long as the output from the core remains the same.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们玩了一下创建一个新函数来打印实际的消息，并且我们看到使用函数的一个初步好处：代码中的整数比较现在变得更简洁，行数更少，可读性更强。另一方面，打印返回值时，输入的是前两个位置参数，第三个参数是
    `minor` 函数的返回代码（`$?`）。引入一个专注于打印消息的函数的另一个好处是，它帮助我们实现了分层：`print_return` 函数负责呈现层，`minor`
    函数负责处理层。因此，每次我们想修改显示信息的方式时，就不需要修改核心函数，从而避免了引入任何错误。另一方面，如果我们想修改核心函数，我们可以随意更改，而不需要修改呈现层，只要核心输出保持不变。
- en: If you have some functions that you think you can use in many of your scripts,
    it would be a good idea to write all of them in file, and then source the file
    from within your script and use them from there. This way you will have your own
    library of functions that you will reuse over time when needed without the burden
    of having to write them every single time.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些认为可以在多个脚本中使用的函数，将它们写在一个文件里，然后在脚本中引用该文件并从中使用这些函数是个不错的主意。这样，你就拥有了一个自己的函数库，在需要时可以重复使用，避免每次都要编写相同的代码。
- en: 'But can we pass to a function variable that references other variables? Let''s
    try this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们能否将引用其他变量的变量传递给函数呢？让我们试试这个：
- en: '[PRE114]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'So, `FIRST_VALUE` references `SECOND_VALUE`, which has a value of `20`, so
    we would expect to see `20` when we try to print `$FIRST_VALUE`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`FIRST_VALUE` 引用了 `SECOND_VALUE`，而 `SECOND_VALUE` 的值是 `20`，因此我们期待在尝试打印 `$FIRST_VALUE`
    时，看到 `20`：
- en: '[PRE115]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'It is not what we were expecting, was it? This happens because Bash treats
    the variable name `SECOND_VALUE` as a bunch of characters. A mere is a string
    taken in its literal value and not as a pointer to a value called `(20)`. We can
    overcome this issue anyway; let''s just add `print_value "${!FIRST_VALUE}"` to
    the previous script before `exit 0` , and now we run it again:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们预期的结果，对吧？之所以会这样，是因为 Bash 将变量名 `SECOND_VALUE` 视为一串字符。它只是一个按字面值取用的字符串，而不是指向值为`(20)`的指针。不过我们依然可以解决这个问题；只需在之前的脚本中添加
    `print_value "${!FIRST_VALUE}"`，并放在 `exit 0` 之前，然后再运行它：
- en: '[PRE116]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We used what is called indirect referencing to actually reference the value
    of a value. This kind of notation called `$``{!variable_name}` introduced in Bash
    2 makes indirect referencing not so difficult to write down, but sometimes, you
    will find the old version:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了所谓的间接引用来实际引用一个值的值。这种语法 `$``{!variable_name}` 是在 Bash 2 中引入的，它使得间接引用不再那么难以书写，但有时你可能会遇到旧版本：
- en: '[PRE117]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: What we see as `$$a` is actually the value of the value, and then we escape
    it and with `eval` , we force its evaluation and assignment it to `a`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的 `$$a` 实际上是值的值，然后我们通过 `eval` 对其进行转义，强制评估并将其赋值给 `a`。
- en: 'How about dereferencing a variable after it has been passed to a function?
    Here are some lines of code to play with:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在将变量传递给函数后，如何进行解引用呢？以下是一些可以尝试的代码行：
- en: '[PRE118]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'So we started with a variable called `a10` holding the value of `10`. Then,
    we printed its value before triggering the function, and right afterwards, we
    called the function passing the name of the variable. The first step in the `print_value`
    function prints the value of the first positional argument passed to the function
    itself. Now, you have all the knowledge to read the code and get what has been
    done. We played a bit with indirect reference, deference, and a parameter substitution,
    so the simple output of the script should make it all clear:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们从一个叫做 `a10` 的变量开始，它的值是 `10`。然后，我们在触发函数之前打印了它的值，接着调用函数并传递了该变量的名称。在 `print_value`
    函数的第一步中，打印了传递给该函数的第一个位置参数的值。现在，你拥有了足够的知识来理解这段代码及其操作。我们稍微玩了一下间接引用、解引用和参数替换，所以脚本的简单输出应该能让一切变得清晰：
- en: '[PRE119]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'And here we are: the value of `a10` changed from the original `20` to the new
    `30`, and now we know why and how. Before leaving the functions chapter, just
    a couple of notes: we already talked about anonymous functions:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们明白了：`a10` 的值从原来的 `20` 变成了新的 `30`，而且现在我们知道了原因和过程。在离开函数章节之前，再提几点：我们已经讨论过匿名函数：
- en: '[PRE120]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Just remember the last semicolon before the ending brace and also see the returned
    values:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 只要记住在结束大括号之前的最后一个分号，并查看返回的值：
- en: '[PRE121]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Once invoked, the script outputs a meaningful error message overcoming the
    limitations of the return built-in, which can only return integers:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用，脚本会输出一个有意义的错误信息，克服了内置 `return` 的限制，它只能返回整数：
- en: '[PRE122]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The previous code returns the value of `OK`, and being a block of code, a function
    `stdin` and `stdout` can be redirected easily:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码返回了 `OK` 的值，并且作为代码块，函数 `stdin` 和 `stdout` 可以很容易地重定向：
- en: '[PRE123]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This gives us the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下输出：
- en: '[PRE124]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: And that's all for now, it's time to move on and add some spice to our scripts.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就这些，接下来是时候为我们的脚本加入一些趣味了。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'You learned how to interact with users, read their input, and store it in appropriate
    structures, cycle though values, and take advantage of the functions to make our
    code tidy and reusable. So now it is time to explore some structures that we have
    already used a bit: we are talking about iterations.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何与用户交互、读取他们的输入并将其存储在合适的结构中，循环遍历值，并利用函数让我们的代码更加整洁和可重用。现在是时候探索一些我们已经使用过的结构了：我们在谈论的是迭代。
