- en: Let's Start Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Bash is the art of taking advantage of your environment to make the
    best out of it. It is not just a matter of dealing with boring routine tasks that
    can be automated. It is crafting your working space so that it becomes more efficient
    for your goals. Thus, even though Bash scripting is not as expressive as other
    more complex languages, such as Python or JavaScript, it is simple enough to be
    grabbed in a short time, and so flexible that it will suffice for most of your
    everyday tasks, even the trickiest ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'But is Bash so plain and easy? Let''s have a look at our first lines in Bash.
    Let''s begin with something easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us do it again in a slightly different way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What is interesting here is that the value of `real` is slightly different
    between the two commands. OK, but why? Let''s dig a bit further with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly enough, the first seems to be a `shell builtin`, the second simply
    a system program, an external utility, and it is here that lies the difference.
    `builtin` is a command that is built into the shell, the opposite of a system
    program, which is invoked by the shell. An internal command, the opposite to an
    external command.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the difference between internal and external shell commands that
    lead to such different timing, we have to understand how an external program is
    invoked by the shell. When an external program is to be executed, Bash creates
    a copy of itself with the same environment of the parent shell, giving birth to
    a new process with a different process ID number. So to speak, we just saw how
    forking is carried out. Inside the new address space, a system exec is called
    to load the new process data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `builtin` commands, it is a different story, Bash executes them without
    any forks, and this leads to a couple of the following interesting outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `builtin` execution is faster because there are no copies and no executables
    invoked. One side note is that this advantage is more evident with short-running
    programs because the overhead is before any executable is called: once the external
    program is invoked, the difference in the pure execution time between the `builtin`
    command and the program is negligible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Being internal to Bash, the `builtin` commands can affect its internal state,
    and this is not possible with the external program. Let''s take into account a
    classic example using `builtincd`. If `cd` were an external program, once invoked
    from shell as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first operation would be our shell forking a process for `cd`, and this
    latter would change the current directory for its own process, not for the one
    we are inside and that was forked to give birth to the `cd` process. The parent
    shell would remain unaffected. So, we would not go anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Curious about which `bulitins` are available? You have some options, to either
    execute the following `builtin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or this other `builtin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To better understand why there is a difference between the execution of a `builtin`
    and an external program, we must see what happens when we invoke a command.
  prefs: []
  type: TYPE_NORMAL
- en: First, remember that the shell works from left to right and takes all the variable
    assignments and redirections and saves them in order to process later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If nothing else is left, the shell takes the first word from the command line
    as the name of the command itself, while all the rest is considered as its arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is dealing with the required input and output redirection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, before being assigned to a variable, all the text following the sign
    `=` is subject to tilde expansion, parameter expansion, command substitution,
    arithmetic expansion, and quote removal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no command name comes out as a result of the last operation, the variable
    can then affect the environment. If an assignment fails, an error is raised and
    the command invoked exits with a non-zero status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no command name is the outcome of the operation seen before, all the redirections
    are applied, but differently from variables, they do not affect the current environment.
    Again, if any error occurs, there is a non-zero status exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the preceding operations are performed, the command is then executed and
    exited with a status, depending on whether one or more expansions contain command
    substitutions. The overall exit status will be the one from the last command substitution,
    and if no command substitution were performed, the exit status will be zero.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are finally left with a command name and some optional arguments.
    It is at this point the roads of `builtins` and external programs divert.
  prefs: []
  type: TYPE_NORMAL
- en: At first, the shell looks at the command name, and if there are no slashes,
    it searches for its location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no slashes, the shell tries to see if there is a function with
    that name and executes it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no functions are found, the shell tries to hit `builtin`, and if there is
    anyone with that name, it is executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK, now if there is any `builtin`, it already got invoked. What about an external
    program?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Bash goes on, and if it finds no `builtins` by that name on the command
    line, there are three chances:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full path of the command to execute is already contained into its internal
    hash table, which is a structure used to speed up the search
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: If the full path is not in the hash, the shell looks for it into the content
    of the environmental `PATH` variable, and if it finds it, it is added to the hash
    table
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The full path is not available in the `PATH` variable, so the shell returns
    with an exit status of 127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hash can even be invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The second column will then tell you not only which commands have been hashed,
    but also how many times each of them has been executed during the current session
    (hits).
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that the search found the full path to the command we want to execute;
    now we have a full path, and we are in the same situation as if the Bash found
    one or more slashes into the command name. In either case, the shell thinks that
    it has a good path to invoke a command and executes the latter in a forked environment.
  prefs: []
  type: TYPE_NORMAL
- en: This is when we are lucky, but it can happen that the file invoked is not an
    executable, and in this case, given that our path does not point to a directory
    instead of a file, the Bash makes an educated guess and thinks to run a shell
    script. In this case, the script is executed in a subshell that is at all a new
    environment, which inherits the content of the hash table of the parent shell.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing anything else, the shell looks at the first line of the script
    for an optional `sha-bang` (we will see later what this is) - after the `sha-bang`,
    there is the path to the interpreter used to manage the script and some optional
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, and only at this point, your external command, if it is a script,
    is executed. If it is an executable, it is invoked a bit before, but way after
    any `builtin`.
  prefs: []
  type: TYPE_NORMAL
- en: During these first paragraphs, we saw some commands and concepts that should
    sound familiar to you. The next paragraphs of this chapter will quickly deal with
    some basic elements of Bash, such as variables, expansions, and redirections.
    If you already know them, you will be able to use the next pages as a reference
    while working on your scripts. If, on the contrary, you are not so familiar with
    them, have a look at what comes next because all you will read will be fundamental
    in understanding what you can do in and with the shell.
  prefs: []
  type: TYPE_NORMAL
- en: I/O redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the previous pages, redirection is one of the last operations
    undertaken by Bash to parse and prepare the command line that will lead to the
    execution of a command. But what is a redirection? You can easily guess from your
    everyday experience. It means taking a stream that goes from one point to another
    and making it go somewhere else, like changing the flow of a river and making
    it go somewhere else. In Linux and Unix, it is quite the same, just keep in mind
    the following two principles:'
  prefs: []
  type: TYPE_NORMAL
- en: In Unix, each process, except for daemons, is supposed to be connected to a
    standard input, standard output, and standard error device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every device in Unix is represented by a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also think of these devices as streams:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard input, named `stdin`, is the intaking stream from which the process
    receives input data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard output, named `stdout`, is the outbound stream where the process writes
    its output data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard error, named `stderr`, is the stream where the process writes its error
    messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These streams are also identified by a standard POSIX file descriptor, which
    is an integer used by the kernel as a handler to refer to them, as you can see
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device** | **Mode** | **File descriptor** |'
  prefs: []
  type: TYPE_TB
- en: '| `stdin` | read | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `stdout` | write | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `stderr` | write | 2 |'
  prefs: []
  type: TYPE_TB
- en: So, tinkering with the file descriptors for the three main streams means that
    we can redirect the flows between `stdin` and `stdout`, but also `stderr`, from
    one process to the other. So, we can make different processes communicate with
    each other, and this is actually a form of IPC, inter-process communication, which
    we will look at it in more detail later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we redirect the **Input/Output** (**I/O**), from one process to another?
    We can get to this goal making use of some special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's start stating that the default output of a process, usually, is the `stdout`.
    Whatever it returns is returned on the `stdout` which, again usually, is the monitor
    or the terminal. Using the `>` character, we can divert this flow and make it
    go to a file. If the file does not exist, it is created, and if it exists, it
    is flattened and its content is overwritten with the output stream of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example will clarify how the redirection to a file works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the command `echo` to print a message on the `stdout`, and so we see
    the message written, in our case, to the text terminal that is usually connected
    to the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing on the filesystem, so the output went straight to the terminal,
    but the underlying directory was not affected. Now, time for a redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, nothing to the screen; no output at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, as you can see, the output did not vanish; it was simply redirected
    to a file on the current directory which got created and filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we have something interesting. The `cat` command takes the content of the
    `output_file.txt` and sends it on the `stdout.` What we can see is that the output
    from the former command was redirected from the terminal and written to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This double mark answers a requirement we often face: *How can we add more
    content coming from a process to a file without overwriting anything?* Using this
    double character, which means no file is already in place, create a new one; if
    it already exists, just append the new data. Let''s take the previous file and
    add some content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Bingo, the file was not overwritten and the new content from the `echo` command
    was added to the old. Now, we know how to write to a file, but what about reading
    from somewhere else other than the `stdin`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the text terminal is the `stdin`, the keyboard is the standard input for
    a process, where it expects some data from. Again, we can divert the flow or data
    reading and get the process read from a file. For our example, we start creating
    a file containing a set of unordered numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And let us verify its content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can have the `sort` command read this file into its `stdin`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, our numbers are now in sequence, but we can do something more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What did we do? We simply gave the file `to_sort` to the command `sort` into
    its standard input, and at the same time, we concatenated a second redirection
    so that the output of `sort` is written into the file `sorted`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, we can concatenate multiple redirections and have some interesting results,
    but we can do something even trickier, that is, chaining together inputs and outputs,
    not on files but on processes, as we will see now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The pipe character does exactly what its name suggests, *pipes* the stream;
    could be the `stdout` or `stderr`, from one process to another, creating a simple
    interprocess communication facility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we had a bit of fun, first getting a list of processes, then
    piping the output to the `awk` utility, which printed only the first, eleventh,
    and twelfth fields of the output of the first command, giving us the process ID,
    CPU percentage, and memory percentage columns. Then, we got rid of the heading
    `PID %CPU %MEM`, piping the `awk` output to the input of `grep`, which performed
    a reverse pattern matching on any strings containing a character, not a number.
    In the next stage, we piped the output to the `sort` command, which reverse-ordered
    the data based on the values in the second column. Finally, we wanted only the
    three lines, and so we got the `PID` of the first three heaviest processes relying
    on CPU occupation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redirection can also be used for some kind of fun or useful stuff, as you can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are two users on the same machine on different terminals,
    and remember that each user has to be connected to a terminal. To be able to write
    to any user's terminal, you must be root or, as in this example, the same user
    on two different terminals. With the `who` command we can identify which terminal
    (`ttys`) the user is connected to, also known as *reads from*, and we simply redirect
    the output from an `echo` command to his terminal. Because its session is connected
    to the terminal, he will read what we send to the `stdin` of his terminal device
    (hence, `/dev/ttysxxx`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything in Unix is represented by a file, be it a device, a terminal, or
    anything we need access to. We also have some special files, such as `/dev/null`,
    which is a sinkhole - whatever you send to it gets lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And have a look at the following example too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Great, there is enough to have fun, but it is just the beginning. There is a
    whole lot more to do with the file descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Messing around with stdin, stdout, and stderr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, if we tinker a little bit with the file descriptors and special characters
    we can have some nice, really nice, outcomes; let's see what we can do.
  prefs: []
  type: TYPE_NORMAL
- en: '`x < filename`: This opens a file in read mode and assigns the descriptor named
    `a`, whose value falls between `3` and `9`. We can choose any name by the means
    of which we can easily access the file content through the `stdin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1 > filename`: This redirects the standard output to filename. If it does
    not exist, it gets created; if it exists, the pre-existing data is overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1 >> filename`: This redirects the standard output to filename. If it does
    not exist, it is created; otherwise, the contents get appended to the pre-existing
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2 > filename`: This redirects the standard error to filename. If it does not
    exist, it gets created; if it exists, the pre-existing data is overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2 >> filename`: This redirects the standard error to filename. If it does
    not exist, it is created; otherwise, the contents get appended to the pre-existing
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&> filename`: This redirects both the `stdout` and the `stderr` to filename.
    This redirects the standard error to filename. If it does not exist, it gets created;
    if it exists, the pre-existing data is overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2>&1`: This redirects the `stderr` to the `stdout`. If you use this with a
    program, its error messages will be redirected to the `stdout`, that is, usually,
    the monitor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y>&x`: This redirects the file descriptor for `y` to `x` so that the output
    from the file pointed by descriptor `y` will be redirected to the file pointed
    by descriptor `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>&x`: This redirects the file descriptor `1` that is associated with the `stdout`
    to the file pointed by the descriptor `x`, so whatever hits the standard output
    will be written in the file pointed by `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x<> filename`: This opens a file in read/write mode and assigns the descriptor
    `x` to it. If the file does not exist, it is created, and if the descriptor is
    omitted, it defaults to `0`, the `stdin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x<&-`: This closes the file opened in read mode and associated with the descriptor
    `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0<&- or <&-`: This closes the file opened in read mode and associated with
    the descriptor `0`, the `stdin` , which is then closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x>&-`: This closes the file opened in write mode and associated with the descriptor
    `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1>&- or >&-`: This closes the file opened in write mode and associated with
    the descriptor `1`, the `stdout`, which is then closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to see which file descriptors are associated with a process, you
    can explore the `/proc` directory and point to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Under that path, change `PID` with the ID of the process you want to explore;
    you will find all the file descriptors associated with it, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, isn''t it? So, let us do something that is absolute fun:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s open a socket in read/write mode to the web server of a virtual
    machine created for this book and assign the descriptor `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let us write something to it; nothing complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We just requested a simple HTML file created for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now let us read the file descriptor `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We connected the file descriptor to a remote server through a socket,
    we could write to it and read the response, redirecting the streams over the network.
  prefs: []
  type: TYPE_NORMAL
- en: For dealing just with the command line, we have done a lot so far, but if we
    want to go further, we have to see how to script all these commands and make the
    most out of them. It is time for our first script!
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for the interpreter: the sha-bang'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the game gets tougher, a few concatenations on the command line cannot
    be enough to perform the tasks we are meant to accomplish. Too many bits on single
    lines are too messy, and we lack clarity, so better to store our commands or `builtins`
    in a file and have it executed.
  prefs: []
  type: TYPE_NORMAL
- en: When a script is executed, the system loader parses the first line looking for
    what is named the `sha-bang` or shebang, a sequence of characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will force the loader to treat the following characters as a path to the
    interpreter and its optional arguments to be used to further parse the script,
    which will then be passed as another argument to the interpreter itself. So, at
    the end, the interpreter will parse the script and, this time, we will ignore
    the `sha-bang`, since its first character is a hash, usually indicating a comment
    inside a script and comments do not get executed. To go a little further, the
    `sha-bang` is what we call a 2-bit magic number, a constant sequence of numbers
    or text values used in Unix to identify file or protocol types. So, `0x23 0x21`
    is actually the ASCII representation of `#!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s make a little experiment and create a tiny one line script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Just one line. Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, everything is as we expected. Has Linux something to say about our script?
    Let''s ask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the file utility says that it is a plain file, and this is a simple text
    file indeed. Time for a nice trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special; we just added a `sha-bang` pointing to `/bin/sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the `sha-bang` is there at the beginning of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'No way, now it is a script! The file utility makes three different tests to
    identify the type of file it is dealing with. In order: file system tests, magic
    number tests, and language tests. In our case, it identified the magic numbers
    that represent the `sha-bang`, and thus a script, and this is what it told us:
    it is a script.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, a couple of final notes before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: You can omit the `sha-bang` if your script is not using a shell `builtins` or
    shell internals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pay attention to `/bin/sh`, not everything that looks like an innocent executable
    is what it seems:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In some systems, `/bin/sh` is a symbolic link to a different kind of interpreter,
    and if you are using some internals or `builtins` of Bash, your script could have
    unwanted or unexpected outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Calling your script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, we have our two-line script; time to see if it really does what we want
    it to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'No way! It is not executing, and from the error message, it seems related to
    the file permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Interesting. Let us recap what the file permissions are. As you can see, the
    line describing the properties of a file starts with a series of letters and lines.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **User** | **Group** | **Others** |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | `rw-` | `r--` | `r--` |'
  prefs: []
  type: TYPE_TB
- en: For type, we can have two main values, d - this is actually a directory, or
    `-` and means this is a regular file. Then, we can see what permissions are set
    for the user owning the file, for the group owning the file, and for all other
    users. As you may guess, `r` stands for permission to read; `w` stands for being
    able to write; `x` stands for permission to execute; and `-` means no right. These
    are all in the same order, first `r`, then `w`, then `x`. So  wherever you see
    a `-` instead of an `r`, `w`, or `x` , it means that particular right is not granted.
  prefs: []
  type: TYPE_NORMAL
- en: The same works for directory permission, except that `x` means you can traverse
    the directory; `r` means that you can enumerate the content of it; `w` means that
    you can modify the attributes of the directory and removes the entries that are
    eventually in it.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Indicator** | **File type** |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Regular file |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | Block file (disk or partition) |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | Character file, like the terminal under /dev |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Directory |'
  prefs: []
  type: TYPE_TB
- en: '| `l` | Symbolic link |'
  prefs: []
  type: TYPE_TB
- en: '| `p` | Named pipe (FIFO) |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | Socket |'
  prefs: []
  type: TYPE_TB
- en: 'So, going back to our file, we do not see any execution bit set. Why? Here,
    a shell `builtin` can help us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Does it make any sense to you? Well, it should, once we see how the permissions
    on files can be represented in numeric form. Think of permissions as bits of metadata
    pertaining to a file, one bit for each grant; no grant is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s convert from binary to decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Permission** | **Binary** | **Decimal** |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | `100` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `w` | `010` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | `001` | 1 |'
  prefs: []
  type: TYPE_TB
- en: Now, just combine the decimal values to obtain the final permission, but remember
    that you have to calculate read, write, and execution grants in triplets - one
    set for the user owning the file, one for the group, and one for the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back again to our file, we can change its permissions in a couple of ways.
    Let''s say we want it to be readable, writable, and executable by the user; readable
    and writable by the group; and only readable by the others. We can use the command
    `chmod` to accomplish this goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, `+` or  `-` add or subtract the permissions to the file or directory pointed
    and `u`, `g`, `w` to define which of the three sets of attributes we are referring
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can speed things up using the numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the following command should do the trick in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to verify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are. So we just need to see whether our user can execute the file,
    as the permissions granted suggest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This should go under the `sha-bang`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, it works. Well, the script is not that complex, but served our purposes.
    But we left one question behind*: Why was the file created with that set of permissions? *As
    a preliminary explanation, I ran the command `umask`, and the result was `0022`
     but did not go further.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Count the digits in `umask`, and those in the numeric modes for `chmod`. Four
    against three. What does that leading digit means? We have to introduce some special
    permission modes that enable some interesting features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sticky bit. Think of it as a user right assertion on a file or directory. If
    a sticky bit is set on a directory, the files inside it can be deleted or renamed
    only by the file owner, the owner of the directory the file is in, or by root.
    Really useful in a shared directory to prevent one user from deleting or renaming
    some other user''s file. The sticky bit is represented by the t letter at the
    end of the of the list of permissions or by the octal digit 1 at the beginning.
    Let''s see how it works:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, the t is capital, not lower, as we were talking about. Maybe
    this sequence of commands will make everything clearer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You probably got it: the t attribute is a capital when, on the file or directory,
    the execution bix (x) is not set for the others (o).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And now, back to the origins:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We used the four-digit notations, and the leading `0` cleared out the `1` which
    referred to the sticky bit. Obviously, we could also use `chmod -t` to accomplish
    the same goal. One final note, if sticky bit and GUID are in conflicts, the sticky
    bit prevails in granting permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set UID**: The **Set User ID** (**SUID** upon execution) marks an executable,
    so that when it runs, it will do so as the file owner, with his privileges, and
    not as the user invoking it. Another tricky use is that, if assigned to a directory,
    all the files created or moved to that directory will have the ownership changed
    to the owner of the directory and not to the user actually performing the operation.
    Visually, it is represented by an s in the position of the user execution rights.
    The octal number referring to it is 4:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '**Set GID**: The **SGID** (**Set Group ID** upon execution) marks an executable,
    so that when it is run, it does as the user invoking it was in the group that
    owns the file. If applied to a directory, every file created or moved to the directory
    will have the group set to the group owning the directory rather than the one
    the user performing the operation belongs to. Visually, it is represented by an
    `s` in the position of the group execution rights. The octal number referring
    to it is 2.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s reset the permissions on our `test` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we apply SGID using the octal digit referring to it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the s is capital because we do not have the execution permission
    granted on the group; the same applies for SUID.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we can go back again to our umask, and at this point you probably already
    know what is the meaning of the four-digit notation is. It is a command that modifies
    the permissions on a file creation, denying the permission bits. Taking our default
    creation mask for directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can think of  `umask` of `0022` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not pay attention to the first `0`; it is the sticky bit and simply subtracts
    from the default grant mask for a directory, `rwx` for user, group, and others,
    the value of the `umask`. The remaining value is the current permission mask for
    file creation. If you are not comfortable with the numeric notation, you can see
    the `umask` values in the familiar `rwx` notation using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For the files, the default mask is `666`, so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It is actually a tad more complicated than this, but this rule of thumb will
    let you calculate the masks quickly. Let us try to create a new `umask`. First,
    let''s reset the `umask` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, nothing gets subtracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test` file has `666` access rights and the directory `777`. This is really
    way too much:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the permissions are 750 for directories and 640 for files.
    A bit of math will help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You would get the same result from the `umask` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: All these settings last as long as you are logged in to the session, so if you
    want to make them permanent, just add the `umask` call with the appropriate argument
    to`/etc/bash.bashrc`,  or `/etc/profile` for a system-wide effect or, for a single
    user mask, add it to the `.bashrc` file inside the user home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Something went wrong, let's trace it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we have a new tiny script named `disk.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special, a shebang, a couple of echoes on a new line just to have some
    vertical spacing, the output of `df -h` and the same command but parsed by `awk`
    to give us a meaningful message. Let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The total disk allocation for this system is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too complicated, a bunch of easy commands, which in case of failure
    print an error message on the standard output. However, let''s think for a moment
    that we have a more flexible script, more lines, some variable assignments, loops,
    and other constructs, and something goes wrong, but the output does not tell us
    anything. In this case, be handy to see a method that is actually running inside
    our script so that we can see the output of the commands, the variable assignments,
    and so forth. In Bash, this is possible; thanks to the `set` command associated
    with the `-x` argument, which shows all the commands and arguments in the script
    printed to the `stdout`, after the commands have been expanded and before they
    are actually invoked. The same behavior can be obtained running a subshell with
    the `-x` argument. Let''s see what would happen if it was used with our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is quite easy to understand how the stream of data flows inside the
    script: all the lines beginning with a `+` sign are commands, and the following
    lines are outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think for a moment that we have longer scripts; for most parts, we are
    sure that things work fine. For some lines, we are not completely sure of the
    outcome. Debugging everything would be *noisy*. In this case, we can use `set-x`
    to enable the logging only for those lines we need to inspect, turning it off
    with `set+x` when it is no longer needed. Time to modify the script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, time to run it again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we see the instructions given in the block marked by `set-x`,
    and we also see the `set+x` instruction given, but then, after this, the line
    with `awk` disappears and we see only its output, filtering out what was not so
    interesting for us and leaving only the part we want to focus on.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a powerful debugging system typical of more complex programming
    languages, but it can be really helpful in scripts of hundreds of lines where
    we can lose track of sophisticated structures, such as evaluations, cycles, or
    variable assignments, which make the scripts more expressive but even more difficult
    to get hold of and master. So, now that we are clear on how to debug a file, which
    permissions are needed to make it safely executable, and how to shell parse the
    command line, we are ready to spice things up looking at how we can use variables
    to add more flexibility to our hand-crafted tools.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is a variable? We could answer that it is something not constant; nice
    joke, but it would not help us so much. Better to think of it as a bucket where
    we can store some information for later processing: at a certain point of your
    script you get a value, a piece of info that you do not want to process at that
    very moment, so you fit it into a variable that you will recall later in the script.
    This is, in an intuitive way, the use of a variable, a way to allocate a part
    of the system memory to hold your data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen that our scripts could retrieve some pieces of information
    from the system and had to process them straight away, since, without the use
    of a variable, we had no way to further process the information except for concatenating
    or redirecting the output to another program. This forced us to have a linear
    execution, no flexibility, no complexity: once you get some data, you process
    it straight away redirecting the file descriptors, one link in the chain after
    the other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable is nothing really new; a lot of programming languages use them to
    store different types of data, integers, floating, strings, and you can see many
    different kinds of variables related to different kinds of data they hold. So,
    you have probably heard about casting a variable, which means, roughly, changing
    its type: you get a value as a string of numbers and you want to use it as an
    integer, so you cast it as an `int` and proceed processing it using some math
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our shell is not so sophisticated, and it has only one type of variable or,
    better, it has none: whatever you store in it can be later processed without any
    casting. This can be nice because you do not have to pay attention to what type
    of data you are holding; you get a number as a string and can process it straight
    away as an integer. Nice and easy, but we must remember that restrictions are
    in place not just to prevent us from doing something, but also to help us not
    do something that would be unhealthy for our code, and this is exactly the risk
    in having flat variables, to write some piece of code that simply does not work,
    cannot work.'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we just saw, a variable is a way to store a value: we get a value, assign
    it to a variable and refer to the latter to access the former. The operation of
    retrieving the content of a variable is named **variable substitution**. A bit
    like, if you think about descriptors, the way that  you use them to access files.
    The way you assign a variable is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`LABEL` can be any string, can have upper and lowercase, start with or contain
    numbers and underscores, and it is case sensitive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The assignment is performed by the `=` character, which, be wary, is not the
    same as the *equal to *`==` sign; they are two different things and are used in
    different contexts. Finally, whatever you put at the right of the assignment operator
    becomes the value of the variable. So, let''s assign some value to our first variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can try to access the value trying to perform an action on the variable
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Not exactly what we expected. We want the content, not the name of the variable.
    Have a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This is better. Using the `$` character at the beginning of the variable name
    identified this as a variable and not a plain string, so we had access to the
    content. This means that, from now on, we can just use the variable with any commands
    instead of referring to the whole content of it. So, let us try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The output is null, and not 0; we will see later on that zero is not the same
    as null, since null is no value but zero is indeed a value, an integer. What does
    the previous output mean? Simply that our labels are case sensitive, change one
    character from upper to lower or vice versa, and you will have a new variable
    which, since you did not assign any value to it, does not hold any value, hence
    the null you receive once you try to access it.
  prefs: []
  type: TYPE_NORMAL
- en: Keep the variable name safe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just saw that `$label` is the way we reference the content of a variable,
    but if you have a look at some scripts, you can find another way of retrieving
    variable content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The two ways of referencing the content of a variable are both valid, and you
    can use the first, more compact, in any case except when concatenating the variable
    name to any characters, which could change the variable name itself. In this case,
    it becomes mandatory to use the extended version of the variable substitution,
    as the following example will make clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start printing our variable again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s do it again using the extended version of substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Exactly the same output since, as we said, these two methods are equivalent.
    Now, let us add a string to our variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing, and we can understand why the name of the variable changed; so we
    have no content to access to. But now, let us try the extended way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Bingo! The name of the variable has been preserved so that the shell was able
    to reference its value and then concatenated it to the `ly` string we added to
    the name.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this difference in mind, because the graphs will be a handy way to concatenate
    strings to a variable to spice your scripts up and, as a good rule of thumb, refer
    to variables using the graphs. This will help you avoid unwanted hindrances.
  prefs: []
  type: TYPE_NORMAL
- en: Variables with limited scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said before, variables have no type in shell, and this makes them somehow
    easy to use, but we must pay attention to some sorts of limits to their use.
  prefs: []
  type: TYPE_NORMAL
- en: First, the content of a variable is accessible only after the value has been
    assigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example will make everything clearer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the variable disk space to store the result of the `df` command and
    try to reference its value on the preceding and following lines. Let us run it
    in debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the flow of execution is sequential: you access the value of
    the variable only after it is instanced, not before. And bear in mind that the
    first line actually printed something: a null value. Well, now let us print the
    variable on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The variable is instanced inside the script, and it is confined there, inside
    the shell spawned to invoke the command and nothing passed to our main shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can ourselves impose some restrictions to a variable, as we will see with
    the next example. In this new case, we will introduce the use of a function, something
    that we are going to look at in more detail further in this book and the keyword
    local:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: What can we see here?
  prefs: []
  type: TYPE_NORMAL
- en: The content of variable `disk_space` is not available before the variable itself
    is instanced. We already knew this.
  prefs: []
  type: TYPE_NORMAL
- en: The content of a variable instanced inside a function is not available when
    it is defined in the function, but when the function itself is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: A variable marked by the keyword local and defined inside a function is available
    only inside the function and only when the function is invoked. Outside the block
    of code defined by the function itself; the local variable is not visible to the
    rest of the script. So, using local variables can be handy to write recursive
    code, even though not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: So, we just saw a few ways to make a variable really limited in its scope, and
    we also noted that its content is not available outside the script it was instanced
    in. Wouldn't it be nice to have some variables with a broader scope, capable of
    influencing the execution of each and every script, something at environment level?
    It would, and from now on we are going to explore the environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, the shell comes with an environment, which dictates
    what it can do and what not, so let''s just have a look at what these variables
    are using the `env` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Some of the variables have been omitted for the sake of clarity; otherwise,
    the output would have been too long, but still we can see something interesting.
    We can have a look at the `PATH` variable content, which influences where the
    shell will look for a program or script to execute. We can see which shell is
    being currently used, by which user, what the current directory is and the previous
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'But environment variables can not only be read; they can be instanced using
    the export command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us read it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'That is it, but since this was just a test, it is better to unset the variable
    so that we do not leave unwanted values around the shell environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let us try to get the content of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'No way! The variable content is no more, and as you will see now, the environment
    variables disappear once their shell is no more. Let''s have a look at the following
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We simply instance a new variable, `grep` for it in the environment and then
    print its content to the `stdout`. What happens once invoked?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We can easily see that the variable was grepped on the `env` output, so this
    means that the variable is actually instanced at the environment level and we
    could access its content and print it. But then we executed the echo of the content
    of `MYTEST` outside the script again, and we could just print a blank line. If
    you remember, when we execute a script, the shell forks a new shell and passes
    to it its full environment, thus the command inside the program shell can manipulate
    the environment. But then, once the program is terminated, the related shell is
    terminated, and its environment variables are lost; the child shell inherits the
    environment from the parent, the parent does not inherit the environment from
    the child.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us go back to our shell, and let us see how we can manipulate the
    environment to our advantage. If you remember, when the shell has to invoke a
    program or a script, it looks inside the content of the `PATH` environment variable
    to see if it can find it in one of the paths listed. If it is not there, the executable
    or the script cannot be invoked just with their names, they have to be called
    passing the full path to it. But have a look at what this script is capable of
    doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We print our current user directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we print the content of the environment `PATH` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a little tricky. Using the graphs, we preserve the content of the variable
    and add `a`, which is the delimiter for each path inside the list held by `PATH`,
    plus the `~/tmp`, which literally means the `tmp` directory inside the `home`
    directory of the current user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'And we actually found it. Well, you could also add some evaluation to make
    the `echo` conditional, but we will see such a thing later on. Time for something
    funny:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the line starting with `env`; this command is able to overrun
    the `PATH` environment variable and to pass its own variable and related value.
    The same behavior can be obtained using export instead of `env`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This last try is even worse. We modified the content of the `$PATH` variable
    which now points to a directory where we cannot find the script. So, not being
    in the `$PATH`, the script cannot be invoked by just its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We are in the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: What is our `PATH`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Now we expand the path for all the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now our `PATH` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: We are looking for the `setting.sh` script!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Found it!
  prefs: []
  type: TYPE_NORMAL
- en: Time for magic!
  prefs: []
  type: TYPE_NORMAL
- en: We are looking for the `setting.sh` script!
  prefs: []
  type: TYPE_NORMAL
- en: BOOOO, nothing!
  prefs: []
  type: TYPE_NORMAL
- en: Second try...
  prefs: []
  type: TYPE_NORMAL
- en: '`env`: ''which'': No such file or directory'
  prefs: []
  type: TYPE_NORMAL
- en: No way...
  prefs: []
  type: TYPE_NORMAL
- en: '| **Environment variable** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `BASH_VERSION` | The version of the current Bash session |'
  prefs: []
  type: TYPE_TB
- en: '| `HOME` | The home directory of the current user |'
  prefs: []
  type: TYPE_TB
- en: '| `HOSTNAME` | The name of the host |'
  prefs: []
  type: TYPE_TB
- en: '| `LANG` | The locale used to manage the data |'
  prefs: []
  type: TYPE_TB
- en: '| `PATH` | The search path for the shell |'
  prefs: []
  type: TYPE_TB
- en: '| `PS1` | The prompt configuration |'
  prefs: []
  type: TYPE_TB
- en: '| `PWD` | The path to the current directory |'
  prefs: []
  type: TYPE_TB
- en: '| `USER` | The name of the currently logged in user |'
  prefs: []
  type: TYPE_TB
- en: '| `LOGNAME` | Same as user |'
  prefs: []
  type: TYPE_TB
- en: 'We can also use `env` with the `-i` argument to strip down all the environment
    variables and just pass to the process what we want, as we can see in the following
    examples. Let''s start with something easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too difficult, we modified the `PATH` variable passing a useless value
    because `HELLO` is not a searchable path, then we had to invoke `env` using the
    full path because `PATH` became useless. Finally, we piped everything to the input
    of `grep`, which will select all the rows (`^)` starting with the string `PATH`,
    printing that line and one line before and after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s modify the script, adding `-i` to the first `env`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let us run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you guess what happened? Another change will make everything clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'No `grep`; we are able to see the complete output of the second `env` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Just `PATH=HELLO env` with the argument `-i` passed to the second `env` process,
    a stripped down environment with only the variables specified on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we are engaged in stripping down, let us see how we can make a function
    disappear with the well-known `unset -f` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to verify what happens with the `unset` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The space left is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Unset done, now let us invoke the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print` function works well, as expected before we unset it, and also the
    variable content becomes no longer available. Speaking about variables, we can
    actually unset some of them on the same row using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: We saw how to modify an environment variable, but what if we want to make it
    read-only so to protect its content from an unwanted modification?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the line `readonlyPATH`, and now let''s see what the execution of this
    script leads us to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened is that our script tried to modify the `PATH` variable that was
    just made `readonly` a few lines before and failed. This failure then led us out
    of the screen with a failure, and this is confirmed by printing the value of the
    `$?` variable, which holds the exit state of the last command invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the use of such a kind of variable later, but now what interests
    us is to know what that `0` and `1` mean: the first time we issued the `echo`
    command, right after invoking the script, it gave us the exit code `1`, which
    means failure, and this makes sense because the script exited abruptly with an
    error. The second time we ran `echo`, it showed `0`, which means that the last
    command executed, the previous `echo` went well, without any errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable expansion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The variable expansion is the method we have to access and actually change
    the content of a variable or parameter. The simplest way to access or reference
    the variable value is as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we assigned a value to the variable `x` and then referenced the value preceding
    the variable name with the dollar sign `$.` So, `echo$x` prints the content of
    `x`, `1`, to the standard output. But we can do something even more subtle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we gave a value to the variable `x`, then we instanced the variable `y`
    referencing the content of the variable `x`. So, `y` got its assignment referencing
    the value of `x` through the `$` character, not directly using a number after
    the `=` char. So far, we saw two different ways to reference a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The first one is terser, but it would be better to stick to the second way because
    it preserves the name of the variable and, as we saw a few pages before, it allows
    us to concatenate a string to the variable without losing the possibility of referencing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just saw the simplest among different ways to manipulate the value held
    by a variable. What we are going to see now is how to thinker with a variable
    to have default values and messages, so we make the interaction with the variable
    more flexible. Before proceeding, just bear in mind that we can use two notations
    for our next example and they are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you could see either of the two in a script, and both are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply, if a variable is not set, return a default value, as we can see in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned before, the two notations, with or without the colon, are quite
    the same. Let us see what happens if in the previous script we substitute `${x:-somenumber}`
    with `${x-somenumber}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the modified script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is fine, but the last line. So what is the difference at play here?
    Simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*${x-30}`: The notation with a colon forces a check on the existence of a
    value for the variable and this value may well be null. In case you have a value,
    it does print the value of the variable, ignoring the fallback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unset -f x`: It unsets the variable, so it has no value and we have a fallback
    value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x=`: It gives a null to `x`; so the fallback does not come in to play, and
    we get back the variable value, for example, null'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${x:-30}`: This forces a fallback value in case the value of a variable is
    null or nonexistent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unset -f x`: It unsets the variable, so it has no value and we have a fallback
    value'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x=`: It gives a null to `x`, but the fallback comes in to play and we get
    a default value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default values can be handy if you are writing a script which expects an input
    or the customer: if the customer does not provide a value, we can use a fallback
    default value and have our variable instanced with something meaningful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We ask the user for an input. If he gives us a value, we print it; otherwise,
    we fallback the value of the variable to `99` and print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'If the variable has a value, it is returned; otherwise, the variable has a
    default value assigned. In the previous case, we got back a value if the variable
    had no value; or null, here the variable is actually assigned a value. Better
    to see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We set a variable and then print its value. Then, we unset it and print its
    value, but because it is unset, we get back a default value. So we try to print
    the value of `x`, but since the number we got in the preceding operation was not
    obtained by an assignment, `x` is still unset. Finally, we use `echo "${x:=30}"`
    and get the value `30` assigned to the variable `x`, and indeed, when we print
    the value of the variable, we get something. Let us see the script in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the blank line in the middle of the output: we just got a value from
    the preceding operation, not a real variable assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Force a check on the existence of a non null value for a variable. If it exists,
    it returns the default value; otherwise it returns null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us run it and check, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, when the variable is correctly instanced, instead of returning
    its value, it returns a default `100` and this is double-checked in the following
    rows where we print the value of `x` and it is still `10`: the `100` we saw was
    not a value assignment but just a default returned instead of the real value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'As we tried to access a `void` variable, but for the unset would have been
    the same, the script exited with an error and the message we got from the variable
    expansion. All good with the first line, `x` has a value and we printed it but,
    as you can see, we cannot arrive to the third line, which remains unparsed: the
    script exited abruptly with a default message printed.'
  prefs: []
  type: TYPE_NORMAL
- en: Nice stuff, isn't it? Well, there is a lot more, we have to look at the pattern
    matching against variables.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching against variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a few ways to fiddle with variables, and some of these have a really
    interesting use in scripts, as we will see later on in this book. Let''s briefly
    recap what we can do with variables and how to do it, but remember we are dealing
    with values that are returned, not assigned back to the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives us the length of the variable, or if it is an array, the length of
    the first element of an array. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'And indeed `thisisaverylongvalue` is made up of  `20` characters. Now, let
    us see an example with arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we instantiated an array with three elements `apple`, `pear`, and `banana`.
    We will see later in this book how to work with arrays in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'We printed the third element of the array. Arrays start with an index of 0,
    so the third element is at index `2`, and it is banana, a 6 characters long word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'We print the second element of the array: pear,a 4 characters long word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: And now, the first element, that is, apple is 5 characters long. Now, if the
    example we saw is true, the following command should return `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'And indeed, the length of the word apple is `5` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to tear out your variable, for a part of it you can use a pattern
    and remove the shortest occurrence of the pattern from the beginning of the variable
    and return the resulting value. It is not a variable assignment, not so easy to
    grasp, but an example will make it clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'This form is like the preceding one but with a slight difference, the pattern
    is used to remove its largest occurrence in the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'We instanced the variable with a series of recurring digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we tried to match a pattern, which means any digit between a leading
    and ending 1, the shortest occurrence. So it took out 10102010103:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we cut away the widest occurrence of the pattern, and so 10102010103,
    resulting in a meager `03` as the value returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we cut away the shortest occurrence of the pattern but now from the end
    of the variable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the shortest occurrence of the `1*3` pattern counted from the end of the
    file is `10102010103` so we get `10102010` back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous example, with `##`, in this case, we cut away the longest
    occurrence of the pattern from the end of the variable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Quite clear, isn''t it? The longest occurrence is `1*3` is `10102010103`, so
    we tear away everything and we return nothing, as this example which makes use
    of the evaluation of `-z` (is empty) will show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The reader familiar with regular expressions probably already understood what
    the outcome is: replace the first occurrence of the pattern in the variable by
    substitution. If substitution does not exist, then delete the first occurrence
    of a pattern in variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Not so nasty, and we were able to instance a variable with the output of our
    find and replace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the preceding, in this case, we are going to replace the occurrences
    of a pattern in the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the preceding example, if substitution is omitted, a pattern is deleted
    from the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'If the prefix of the variable matches, then replace the pattern with substitution
    in variable, so this is similar to the preceding but matches only at the beginning
    of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: As usual, omitting means deleting the occurrence of the pattern from the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, a positional replacement, this time at the end of the variable
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of nonsense, but it makes sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Match the name of the variable names starting with the highlighted prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'We can decide from which position we want to start the variable expansion,
    so determining what part of its value we want to get back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we just took a part of the variable, and we decided the starting point,
    but we can also define for how long cherry-picking is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: So we do not go further, start at a position and stop at the offset; this way,
    we can extract whatever consecutive characters/digits we want from the value of
    a variable.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen many different ways to access and modify the content of
    a variable or, at least, of what we get from a variable. There is a class of very
    special variables left to look at, and these will be really handy when writing
    a script.
  prefs: []
  type: TYPE_NORMAL
- en: Special variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see now some variables which have some spacial uses that we can benefit
    from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The first interesting variables we want to explore have a special role in our
    scripts because they will let us capture more than an argument on our first command-line
    execution. Have a look at this bunch of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to `$1`, `$2`, `$3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'First try, no arguments on the command line, we see nothing printed for the
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Second try, we invoke the script and add three digits separated by spaces and,
    actually, we can see them printed. The first on the command line corresponds to
    `$1`, the second to `$2`, and the third to `$3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The value of the first variable is `Green`; the second is `Yellow`; and the
    third is `Red`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third try, we use words with the same results. But notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a double quote to prevent the space between one sentence and another
    being interpreted as a divider for the command-line bits, and in fact, the first
    and second sentences were added as a complete string to the variables, but the
    third came up just with an A because the subsequent spaces, not quoted, were considered
    to be separators and the following bits taken as `$4`, `$5`, and `$n`. Note that
    we could also mix the order of assignment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The result would be the same. What is important is not the position of the variable
    we declare, but what positional we associate with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw, we used two different methods to represent a positional variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Are they the same? Almost. Look here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Interesting, the `eleventhvariable` has been interpreted as it were the positional
    `$1` and added a `1`. Odd, let''s rewrite the echo in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'And run the script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are correct. We did not pass an eleventh positional value on the command
    line, so the `eleventhvariable` has not been instantiated and we do not see anything
    printed to the video. Be cautious, always use `${}`; it will preserve the value
    of the variable in your complex scripts when having a grasp of every single detail
    would be really difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'This expands to the full path to the script; it gives you a way to handle it
    in your script. So, let''s add the following line at the end of the script and
    execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, the path is local, since we called the script from inside the
    directory that is holding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Expands into the number of the arguments passed to the script, showing us the
    number of arguments that have been passed on the command line to the script. So,
    let''s add the following line to our script and let''s see what comes out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Gives us the list of arguments passed on the command line to the script, with
    one difference: `${@}` preserves the spaces, the second doesn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'We changed the characters used by the shell as a delimiter to identify single
    words. Now, let us execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the difference at play:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*`: This expands to the positional parameters, starting from the first and
    when the expansion is within double quotes, it expands to a single word and separates each
    positional parameter using the first character of IFS. If the latter is null,
    a space is used, if it is null the words are concatenated without separators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@`: This expands to the positional parameter, starting from the first, and
    if the expansion occurs within a double quote, each positional parameter is expanded
    to a word on its own:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'This special variable expands to the exit value of the last command executed,
    as we have already seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: The first command was successful, so the exit code is `0` ; the second gave
    an error `127command not found`, since such a command as `tt` does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '`${$}` expands to the process number of the current shell and for a script
    is the shell in which it is running. Let us add the following line to our `positional.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Step by step, our script is telling us more and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'This is tricky; it expands to the process number of the last command executed
    in the background. Time to add some other lines to our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'And now execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: We used `nohup ps &` to send the `ps` in the background (`&`) and detach it
    from the current terminal (`nohup`). We will see later, in more details the use
    of background commands; it suffices now to see how, before sending the process
    in to the background, we had no value to print for `${!}` ; it was instanced only
    after we sent `ps` in to the background.
  prefs: []
  type: TYPE_NORMAL
- en: Do you see that?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Well, for our purposes, it has no value, so how can we redirect this useless
    output and get rid of it during the execution of our script? You know what? It
    is a tiny exercise for you to do before you start reading the next chapter, which
    will deal with the operators and much more fun.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched on some of the very basics of the shell, such as
    things that you should know how to deal with in the correct way. Failing to preserve
    variable names can, for instance, lead us to unwanted results and, on a different
    side, knowing how to access environment variables will help us create a better
    environment for our day-to-day tasks. As we said, basic but important things that
    a Bash master should know by heart, because unmasks, file descriptors, and fiddling
    with variables are what let you play awesome tricks and are the building blocks
    to becoming more advanced. So, do not just overlook them; they will help you.
  prefs: []
  type: TYPE_NORMAL
