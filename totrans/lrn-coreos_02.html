<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;Setting Up Your CoreOS Environment" id="I3QM1-31555e2039a14139a7f00b384a5a2dd8"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Setting Up Your CoreOS Environment</h1></div></div></div><p class="calibre9">CoreOS can <a id="id55" class="calibre1"/>be installed on a variety of platforms such as bare metal servers, cloud provider's virtual machines, physical servers, and so on. This chapter describes in detail how to bring up your first CoreOS environment focusing on deploying CoreOS on a Virtual Machine. When deploying in a virtualization environment, tools such as Vagrant come in very handy in managing CoreOS virtual machines. <span class="strong"><strong class="calibre2">Vagrant</strong></span> <a id="id56" class="calibre1"/>enables setting up CoreOS with multiple nodes even on single laptops or workstations easily with minimum configuration. Vagrant supports VirtualBox, a commonly used virtualization application. Both Vagrant and VirtualBox are available for multiple architecture, such as Intel or AMD, and operating systems such as Windows, Linux, Solaris, and Mac.</p><p class="calibre9">This chapter covers setting up CoreOS on VirtualBox, VMware VSphere, and the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">VirtualBox installation</li><li class="listitem">Introduction to Vagrant</li><li class="listitem">CoreOS on VMware VSphere setup </li><li class="listitem">Introduction to Docker</li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre9">GIT is used for downloading all the required software mentioned in this chapter. </p></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Setting Up Your CoreOS Environment" id="I3QM1-31555e2039a14139a7f00b384a5a2dd8">
<div class="book" title="Installing GIT"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec13" class="calibre1"/>Installing GIT</h1></div></div></div><p class="calibre9">Download the latest <a id="id57" class="calibre1"/>version of GIT installation as per the host operating system from <a class="calibre1" href="http://www.vagrantup.com/downloads.html">http://www.vagrantup.com/downloads.html</a>. After the download is complete, start the installation. The installation of GIT using this procedure is useful for Mac and Windows. For all Linux distributions, the GIT client is available through its package manager. For example, if the operation system is CentOS, the package manager <code class="email">yum</code> can be used to install GIT.</p></div></div>
<div class="book" title="Installing VirtualBox" id="J2B81-31555e2039a14139a7f00b384a5a2dd8"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Installing VirtualBox</h1></div></div></div><p class="calibre9">Download <a id="id58" class="calibre1"/>the latest version of VirtualBox as per the host operating system and architecture from <a class="calibre1" href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>. After the download is complete, start the installation.</p><p class="calibre9">During installation, continue with the default options. VirtualBox installation resets the host machine's network adapters during installation. This will result in the network connection toggle. After the installation is successful, Installer will print the status of the operation.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Introduction to Vagrant"><div class="book" id="K0RQ2-31555e2039a14139a7f00b384a5a2dd8"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Introduction to Vagrant</h1></div></div></div><p class="calibre9">Vagrant <a id="id59" class="calibre1"/>provides a mechanism to install and configure a development, test, or production environment. Vagrant works with various virtualization applications such as VirtualBox, VMware, AWS and so on. All installation, setup information, configuration, and dependencies are maintained in a file and virtual machine can be configured and brought up using a simple Vagrant command. This also helps to automate the process of installation and configuration of machines using commonly available scripting languages. Vagrant helps in creating an environment that is exactly the same across users and deployments. Vagrant also provides simple commands to manage the virtual machines. In the context of CoreOS, Vagrant will help to create multiple machines of the CoreOS cluster with ease and with the same environment.</p></div>

<div class="book" title="Introduction to Vagrant">
<div class="book" title="Installing Vagrant"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec09" class="calibre1"/>Installing Vagrant</h2></div></div></div><p class="calibre9">Download <a id="id60" class="calibre1"/>and install <a id="id61" class="calibre1"/>the latest version of Vagrant from <a class="calibre1" href="http://www.vagrantup.com/downloads">http://www.vagrantup.com/downloads</a>. Choose default settings during installation. </p></div></div>

<div class="book" title="Introduction to Vagrant">
<div class="book" title="Vagrant configuration files"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec10" class="calibre1"/>Vagrant configuration files</h2></div></div></div><p class="calibre9">The <a id="id62" class="calibre1"/>Vagrant configuration file contains the configuration and provisioning information of the virtual machines. The configuration filename is <code class="email">Vagrantfile</code> and the file syntax is <code class="email">Ruby</code>. The configuration file can be present in any of the directory levels starting from the current working directory. The file in the current working directory is read first, then the file (if present) in one directory level back, and so on until <code class="email">/</code>. Files are merged as they are read. For most of the configuration parameters, newer settings overwrite the older settings except for a few parameters where they are appended.</p><p class="calibre9">A <code class="email">Vagrantfile</code> template <a id="id63" class="calibre1"/>and other associated files can be <span class="strong"><em class="calibre10">cloned</em></span> from the GIT repository (<a class="calibre1" href="https://github.com/coreos/coreos-vagrant.git">https://github.com/coreos/coreos-vagrant.git</a>). Run the following command from the terminal to clone the repository. Note that the procedure to start a terminal may vary from OS to OS. For example, in Windows, the terminal for running GIT commands is by running <code class="email">Git</code> <code class="email">Bash</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ git clone https://github.com/coreos/coreos-vagrant/</strong></span>
</pre></div><p class="calibre9">A directory, <code class="email">coreos-vagrant</code>, is created after <code class="email">git clone</code>. Along with other files associated to the <code class="email">Git</code> repository, the directory contains <code class="email">Vagrantfile</code>, <code class="email">user-data.sample</code>, and <code class="email">config.rb.sample</code>. Rename <code class="email">user-data.sample</code> to <code class="email">user-data</code> and <code class="email">config.rb.sample</code> to <code class="email">config.rb</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">git clone https://github.com/coreos/coreos-vagrant/</strong></span>
<span class="strong"><strong class="calibre2">Cloning into 'coreos-vagrant'...</strong></span>
<span class="strong"><strong class="calibre2">remote: Counting objects: 402, done.</strong></span>
<span class="strong"><strong class="calibre2">remote: Total 402 (delta 0), reused 0 (delta 0), pack-reused 402</strong></span>
<span class="strong"><strong class="calibre2">Receiving objects: 100% (402/402), 96.63 KiB | 31.00 KiB/s, done.</strong></span>
<span class="strong"><strong class="calibre2">Resolving deltas: 100% (175/175), done.</strong></span>

<span class="strong"><strong class="calibre2">cd coreos-vagrant/</strong></span>
<span class="strong"><strong class="calibre2">ls</strong></span>
<span class="strong"><strong class="calibre2">config.rb.sample*  CONTRIBUTING.md*  DCO*  LICENSE*  MAINTAINERS*  NOTICE*  README.md*  user-data.sample*  Vagrantfile*</strong></span>
</pre></div><p class="calibre9">
<code class="email">Vagrantfile</code> contains template configuration to create and configure the CoreOS virtual machine using VirtualBox. <code class="email">Vagrantfile</code> includes the <code class="email">config.rb</code> file using the <code class="email">require</code> directive:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">…</strong></span>
<span class="strong"><strong class="calibre2">CONFIG = File.join(File.dirname(__FILE__), "config.rb")</strong></span>
<span class="strong"><strong class="calibre2">….</strong></span>
<span class="strong"><strong class="calibre2">if File.exist?(CONFIG)</strong></span>
<span class="strong"><strong class="calibre2">  require CONFIG</strong></span>
<span class="strong"><strong class="calibre2">end</strong></span>
<span class="strong"><strong class="calibre2">…</strong></span>

<span class="strong"><strong class="calibre2">…</strong></span>
<span class="strong"><strong class="calibre2">CLOUD_CONFIG_PATH = File.join(File.dirname(__FILE__), "user-data")</strong></span>
<span class="strong"><strong class="calibre2">…</strong></span>
<span class="strong"><strong class="calibre2">      if File.exist?(CLOUD_CONFIG_PATH)</strong></span>
<span class="strong"><strong class="calibre2">        config.vm.provision :file, :source =&gt; "#{CLOUD_CONFIG_PATH}", :destination =&gt; "/tmp/vagrantfile-user-data"</strong></span>
<span class="strong"><strong class="calibre2">        config.vm.provision :shell, :inline =&gt; "mv /tmp/vagrantfile-user-data /var/lib/coreos-vagrant/", :privileged =&gt; true</strong></span>
<span class="strong"><strong class="calibre2">      end</strong></span>
<span class="strong"><strong class="calibre2">…</strong></span>
</pre></div></div></div>

<div class="book" title="Introduction to Vagrant">
<div class="book" title="Cloud-config"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec11" class="calibre1"/>Cloud-config</h2></div></div></div><p class="calibre9">
<span class="strong"><strong class="calibre2">cloud config</strong></span> files <a id="id64" class="calibre1"/>are <a id="id65" class="calibre1"/>special files that get executed by the <code class="email">cloud-init</code> process when the CoreOS system starts or when the configuration is dynamically updated. Typically, the cloud config file contains the various OS level configuration of the docker container such as networking, user administration, systemd units and so on. For CoreOS, <code class="email">user-data</code> is the name of the <code class="email">cloud-config</code> file and is present inside the base directory of the <code class="email">vagrant</code> folder. The <code class="email">systemd units</code> files are configuration files containing information about a process.</p><p class="calibre9">The <code class="email">cloud-config</code> file uses the YAML file format. A <code class="email">cloud-config</code> file must contain <code class="email">#cloud-config</code> as the first line, followed by an associative array that has zero or more of the following keys:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">coreos</code>: This <a id="id66" class="calibre1"/>key provides configuration of<a id="id67" class="calibre1"/> the services provided by CoreOS. Configuration for some of the important services are described next:<div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">etc2</code>: This<a id="id68" class="calibre1"/> key replaces the previously used <code class="email">etc</code> service. The parameters for <code class="email">etc2</code> are used to generate the systemd unit drop-in file for <code class="email">etcd2</code> services. Some of the important parameters of the <code class="email">etc2</code> configuration are:<p class="calibre9">
<code class="email">discovery</code>: This <a id="id69" class="calibre1"/>specifies the unique token used to identify all the etcd members forming a cluster. The unique token can be generated by accessing the free discovery service (<a class="calibre1" href="https://discovery.etcd.io/new?sizhttp://e=&lt;clustersize&gt;">https://discovery.etcd.io/new?sizhttp://e=&lt;clustersize&gt;</a>). This is used when the discovery mechanism is used to identify cluster etcd members in cases where IP addresses of all the nodes are not known beforehand. The token generated is also called the discovery URL. The discovery service helps clusters to connect to each other using <code class="email">initial-advertise-peer-urls</code> provided by each member by storing the connected etcd members, the size of the cluster, and other metadata against the discovery URL. For more information regarding forming the CoreOS cluster, refer to <a class="calibre1" title="Chapter 3. Creating Your CoreOS Cluster and Managing the Cluster" href="part0026_split_000.html#OPEK1-31555e2039a14139a7f00b384a5a2dd8">Chapter 3</a>, <span class="strong"><em class="calibre10">Creating Your CoreOS Cluster and Managing the Cluster</em></span>.</p><p class="calibre9">
<code class="email">initial-advertise-peer-urls</code>: This <a id="id70" class="calibre1"/>specifies the member's own peer URLs that are advertised to the cluster. The IP should be accessible to all etcd members. Depending on accessibility, a public and/or private IP can be used. </p><p class="calibre9">
<code class="email">advertise-client-urls</code>: This <a id="id71" class="calibre1"/>specifies the member's own client URLs <a id="id72" class="calibre1"/>that are advertised to the cluster. The IP should be accessible to all etcd members. Depending on accessibility, a public and/or private IP can be used.</p><p class="calibre9">
<code class="email">listen-client-urls</code>: This <a id="id73" class="calibre1"/>specifies the list of self URLs on which the member is listening for client traffic. All advertised client URLs should be part of this configuration.</p><p class="calibre9">
<code class="email">listen-peer-urls</code>: This <a id="id74" class="calibre1"/>specifies the list of self URLs on which the member is listening for peer traffic. All advertised peer URLs should be part of this configuration.</p><p class="calibre9">On some platforms, the providing IP can be automated by using <span class="strong"><em class="calibre10">templating feature</em></span>. Instead of providing actual IP addresses, the fields <code class="email">$public_ipv4 </code>or <code class="email">$private_ipv4</code> can be provided.</p><p class="calibre9">
<code class="email">$public_ipv4</code> is a substitution variable for the public IPV4 address of the machine.</p><p class="calibre9">
<code class="email">$private_ipv4</code> is a substitution variable for the private IPV4 address of the machine.</p><p class="calibre9">The following is sample <code class="email">coreos</code> configuration in the <code class="email">cloud-config</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">#cloud-config</strong></span>
<span class="strong"><strong class="calibre2">coreos:</strong></span>
<span class="strong"><strong class="calibre2">  etcd2:</strong></span>
<span class="strong"><strong class="calibre2">    discovery: https://discovery.etcd.io/d54166dee3e709cf35b0d78913621df6</strong></span>
<span class="strong"><strong class="calibre2">    # multi-region and multi-cloud deployments need to use $public_ipv4</strong></span>
<span class="strong"><strong class="calibre2">    advertise-client-urls: http://$public_ipv4:2379</strong></span>
<span class="strong"><strong class="calibre2">    initial-advertise-peer-urls: http://$private_ipv4:2380</strong></span>
<span class="strong"><strong class="calibre2">    # listen on both the official ports and the legacy ports</strong></span>
<span class="strong"><strong class="calibre2">    # legacy ports can be omitted if your application doesn't depend on them</strong></span>
<span class="strong"><strong class="calibre2">    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001</strong></span>
<span class="strong"><strong class="calibre2">    listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001</strong></span>
</pre></div></li><li class="listitem"><code class="email">fleet</code>: The <a id="id75" class="calibre1"/>parameters for fleet are used to generate environment variables for the fleet service. The fleet service manages the running of containers on clusters. Some of the important parameters of the fleet configuration are:<p class="calibre9">
<code class="email">etcd_servers</code>: This <a id="id76" class="calibre1"/>provides the list of URLs through which etcd services can be reached. The URLs configured should be one of the <code class="email">listen-client-urls</code> for etcd services.</p><p class="calibre9">
<code class="email">public_ip</code>: The<a id="id77" class="calibre1"/> IP address that should be published with the local machine's state.</p><p class="calibre9">The following is a sample fleet configuration in the <code class="email">cloud-config</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">#cloud-config</strong></span>
<span class="strong"><strong class="calibre2">  fleet:</strong></span>
<span class="strong"><strong class="calibre2">    etcd_servers: http:// $public_ipv4:2379,http:// $public_ipv4:4001</strong></span>
<span class="strong"><strong class="calibre2">    public-ip: $public_ipv4</strong></span>
</pre></div></li><li class="listitem"><code class="email">flannel</code>: The <a id="id78" class="calibre1"/>parameters for flannel are used to generate environment variables for the flannel service. The flannel service provides communication between containers.</li><li class="listitem"><code class="email">locksmith</code>: The <a id="id79" class="calibre1"/>parameters for locksmith are used to generate environment variables for the locksmith service. The locksmith service provides reboot management of clusters.</li><li class="listitem"><code class="email">update</code>: These <a id="id80" class="calibre1"/>parameters manipulate settings related to how CoreOS instances are updated.</li><li class="listitem"><code class="email">Units</code>: These <a id="id81" class="calibre1"/>parameters specify the set of systemd units that need to be started after boot-up. Some of the important parameters of unit configuration are:<p class="calibre9">
<span class="strong"><strong class="calibre2">name</strong></span>: This <a id="id82" class="calibre1"/>specifies the name of the service.</p><p class="calibre9">
<span class="strong"><strong class="calibre2">command</strong></span>: This <a id="id83" class="calibre1"/>parameter specifies the command to execute on the unit: start, stop, reload, restart, try-restart, reload-or-restart, reload-or-try-restart.</p><p class="calibre9">
<span class="strong"><strong class="calibre2">enable</strong></span>: This<a id="id84" class="calibre1"/> flag (true/false) specifies if the Install section of the unit file has to be ignored or not.</p><p class="calibre9">
<span class="strong"><strong class="calibre2">drop-ins</strong></span>: This <a id="id85" class="calibre1"/>contains a list of the unit's drop-in files. Each unit information set contains <span class="strong"><em class="calibre10">name</em></span>, which specifies the unit's drop-in files, and <span class="strong"><em class="calibre10">content</em></span>, which is plain text representing the unit's drop-in file.</p><p class="calibre9">The following is a sample unit configuration in the <code class="email">cloud-config</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">#cloud-config</strong></span>
<span class="strong"><strong class="calibre2">  units:</strong></span>
<span class="strong"><strong class="calibre2">    - name: etcd2.service</strong></span>
<span class="strong"><strong class="calibre2">      command: start</strong></span>
<span class="strong"><strong class="calibre2">    - name: fleet.service</strong></span>
<span class="strong"><strong class="calibre2">      command: start</strong></span>
<span class="strong"><strong class="calibre2">    - name: docker-tcp.socket</strong></span>
<span class="strong"><strong class="calibre2">      command: start</strong></span>
<span class="strong"><strong class="calibre2">      enable: true</strong></span>
<span class="strong"><strong class="calibre2">      content: |</strong></span>
<span class="strong"><strong class="calibre2">        [Unit]</strong></span>
<span class="strong"><strong class="calibre2">        Description=Docker Socket for the API</strong></span>

<span class="strong"><strong class="calibre2">        [Socket]</strong></span>
<span class="strong"><strong class="calibre2">        ListenStream=2375</strong></span>
<span class="strong"><strong class="calibre2">        Service=docker.service</strong></span>
<span class="strong"><strong class="calibre2">        BindIPv6Only=both</strong></span>

<span class="strong"><strong class="calibre2">        [Install]</strong></span>
<span class="strong"><strong class="calibre2">        WantedBy=sockets.target</strong></span>
</pre></div></li></ul></div></li><li class="listitem"><code class="email">ssh_authorized_keys</code>: This <a id="id86" class="calibre1"/>parameter specifies the public SSH keys that will be authorized for the core user.</li><li class="listitem"><code class="email">hostname</code>: This <a id="id87" class="calibre1"/>specifies the hostname of the member.</li><li class="listitem"><code class="email">users</code>: This <a id="id88" class="calibre1"/>specifies the list of users to be created or updated on the member. Each user information contains name, password, homedir, shell, and so on.</li><li class="listitem"><code class="email">write_files</code>: This <a id="id89" class="calibre1"/>specifies the list of files that are to be created on the member. Each file information contains path, permission, owner, content, and so on.</li><li class="listitem"><code class="email">manage_etc_hosts</code>: This <a id="id90" class="calibre1"/>specifies the content of the <code class="email">/etc/hosts</code> file for local name resolution. Currently, only localhost is supported.</li></ul></div></div></div>

<div class="book" title="Introduction to Vagrant">
<div class="book" title="The config.rb configuration file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec12" class="calibre1"/>The config.rb configuration file</h2></div></div></div><p class="calibre9">This <a id="id91" class="calibre1"/>file contains information to configure the CoreOS cluster. This file provides the configuration value for the parameters used by <code class="email">Vagrantfile</code>. <code class="email">Vagrantfile</code> accesses<a id="id92" class="calibre1"/> the configuration by including the <code class="email">config.rb</code> file. The following are the parameters:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">$num_instances</code>: This <a id="id93" class="calibre1"/>parameter specifies the number of nodes in the cluster</li><li class="listitem"><code class="email">$shared_folders</code>: This <a id="id94" class="calibre1"/>parameter specifies the list of shared folder paths on the host machine along with the respective path on the member</li><li class="listitem"><code class="email">$forwarded_ports</code>: This <a id="id95" class="calibre1"/>specifies the port forwarding from the member to the host machine</li><li class="listitem"><code class="email">$vm_gui</code>: This <a id="id96" class="calibre1"/>flag specifies if GUI is to be set up for the member</li><li class="listitem"><code class="email">$vm_memory</code>: This <a id="id97" class="calibre1"/>parameter specifies the memory for the member in MBs</li><li class="listitem"><code class="email">$vm_cpus</code>: This <a id="id98" class="calibre1"/>specifies the number of CPUs to be allocated for the member</li><li class="listitem"><code class="email">$instance_name_prefix</code>: This <a id="id99" class="calibre1"/>parameter specifies the prefix to be used for the member name</li><li class="listitem"><code class="email">$update_channel</code>: This <a id="id100" class="calibre1"/>parameter specifies the update channel (alpha, beta, and so on) for CoreOS</li></ul></div><p class="calibre9">The following is a sample <code class="email">config.rb</code> file:</p><div class="informalexample"><pre class="programlisting">$num_instances=1
$new_discovery_url="https://discovery.etcd.io/new?size=#{$num_instances}"

# To automatically replace the discovery token on 'vagrant up', uncomment
# the lines below:
#
#if File.exists?('user-data') &amp;&amp; ARGV[0].eql?('up')
#  require 'open-uri'
#  require 'yaml'
#
#  token = open($new_discovery_url).read
#
#  data = YAML.load(IO.readlines('user-data')[1..-1].join)
#  if data['coreos'].key? 'etcd'
#    data['coreos']['etcd']['discovery'] = token
#  end
#  if data['coreos'].key? 'etcd2'
#    data['coreos']['etcd2']['discovery'] = token
#  end
#
#  # Fix for YAML.load() converting reboot-strategy from 'off' to false`
#  if data['coreos']['update'].key? 'reboot-strategy'
#     if data['coreos']['update']['reboot-strategy'] == false
#          data['coreos']['update']['reboot-strategy'] = 'off'
#       end
#  end
#
#  yaml = YAML.dump(data)
#  File.open('user-data', 'w') { |file| file.write("#cloud-config\n\n#{yaml}") }
#end

$instance_name_prefix="coreOS-learn"
$image_version = "current"
$update_channel='alpha'
$vm_gui = false
$vm_memory = 1024
$vm_cpus = 1
$shared_folders = {}
$forwarded_ports = {}</pre></div></div></div>

<div class="book" title="Introduction to Vagrant">
<div class="book" title="Starting a CoreOS VM using Vagrant"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec13" class="calibre1"/>Starting a CoreOS VM using Vagrant</h2></div></div></div><p class="calibre9">Once <a id="id101" class="calibre1"/>the <code class="email">config.rb</code> and <code class="email">user-config</code> files are updated with the actual configuration parameter, execute the command <code class="email">vagrant up</code> in the directory where configuration files are present to start the CoreOS VM image. Once the <code class="email">vagrant up</code> command is successfully executed, the CoreOS in the VM environment is ready:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">vagrant up</strong></span>
<span class="strong"><strong class="calibre2">Bringing machine 'core-01' up with 'virtualbox' provider...</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Checking if box 'coreos-alpha' is up to date...</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Clearing any previously set forwarded ports...</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Clearing any previously set network interfaces...</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Preparing network interfaces based on configuration...</strong></span>
<span class="strong"><strong class="calibre2">    core-01: Adapter 1: nat</strong></span>
<span class="strong"><strong class="calibre2">    core-01: Adapter 2: hostonly</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Forwarding ports...</strong></span>
<span class="strong"><strong class="calibre2">    core-01: 22 =&gt; 2222 (adapter 1)</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Running 'pre-boot' VM customizations...</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Booting VM...</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Waiting for machine to boot. This may take a few minutes...</strong></span>
<span class="strong"><strong class="calibre2">    core-01: SSH address: 127.0.0.1:2222</strong></span>
<span class="strong"><strong class="calibre2">    core-01: SSH username: core</strong></span>
<span class="strong"><strong class="calibre2">    core-01: SSH auth method: private key</strong></span>
<span class="strong"><strong class="calibre2">    core-01: Warning: Connection timeout. Retrying...</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Machine booted and ready!</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Setting hostname...</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Configuring and enabling network interfaces...</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: Machine already provisioned. Run `vagrant provision` or use the `--provision`</strong></span>
<span class="strong"><strong class="calibre2">==&gt; core-01: flag to force provisioning. Provisioners marked to run always will still run.</strong></span>

<span class="strong"><strong class="calibre2">vagrant status</strong></span>
<span class="strong"><strong class="calibre2">Current machine states:</strong></span>

<span class="strong"><strong class="calibre2">core-01                   running (virtualbox)</strong></span>
</pre></div><p class="calibre9">The VM is <a id="id102" class="calibre1"/>running. To stop this VM, you can run <code class="email">vagrant halt</code> to shut it down forcefully, or you can run <code class="email">vagrant suspend</code> to simply suspend the virtual machine. In either case, to restart it again, simply run <code class="email">vagrant up</code>.</p></div></div>
<div class="book" title="Setting up CoreOS on VMware vSphere" id="KVCC1-31555e2039a14139a7f00b384a5a2dd8"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Setting up CoreOS on VMware vSphere</h1></div></div></div><p class="calibre9">VMware vSphere<a id="id103" class="calibre1"/> is a server virtualization platform that uses VMware's ESX/ESXi hypervisor. VMware VSphere provides complete platform, toolsets and virtualization infrastructure to provide and manage virtual machines in bare metal. VMware vSphere consists of VMware vCenter Server and VMware vSphere Client. VMware vCenter Server manages the virtual as well as the physical resources. VMware vSphere Client provides a GUI to install and manage virtual machines in bare metal.</p></div>
<div class="book" title="Installing VMware vSphere Client"><div class="book" id="LTSU2-31555e2039a14139a7f00b384a5a2dd8"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Installing VMware vSphere Client</h1></div></div></div><p class="calibre9">Download the<a id="id104" class="calibre1"/> latest version of VMware vSphere Client installation as per the host operating system and architecture from <a class="calibre1" href="http://vsphereclient.vmware.com/vsphereclient/1/9/9/3/0/7/2/VMware-viclient-all-5.5.0-1993072.exe">http://vsphereclient.vmware.com/vsphereclient/1/9/9/3/0/7/2/VMware-viclient-all-5.5.0-1993072.exe</a>. After the download is complete, start the installation. During installation, continue with the default options.</p><p class="calibre9">Once the installation is complete, open the VMware vSphere Client application. This opens a new GUI. In the <span class="strong"><strong class="calibre2">IP address</strong></span> / <span class="strong"><strong class="calibre2">Name</strong></span> field, enter the IP address/hostname to directly manage a single host. Enter the IP address/hostname of vCenter Server to manage multiple hosts. In the <span class="strong"><strong class="calibre2">User name</strong></span> and <span class="strong"><strong class="calibre2">Password</strong></span> field, enter the username and password.</p><p class="calibre9">Download the latest version <a id="id105" class="calibre1"/>of the CoreOS image from <a class="calibre1" href="http://stable.release.core-os.net/amd64-usr/current/coreos_production_vmware_ova.ova">http://stable.release.core-os.net/amd64-usr/current/coreos_production_vmware_ova.ova</a>. Once the download is complete, the next step is to create the VM image using the downloaded <code class="email">ova</code> file. The steps to create the VM image are as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the VMware vSphere Client application.</li><li class="listitem" value="2">Enter IP address, username and password as mentioned earlier.</li><li class="listitem" value="3">Click on the <span class="strong"><strong class="calibre2">File</strong></span> menu.</li><li class="listitem" value="4">Click on <span class="strong"><strong class="calibre2">Deploy OVF Template</strong></span>.</li><li class="listitem" value="5">This opens a new Wizard. Specify the location of the <code class="email">ova</code> file that was downloaded earlier. Click on <span class="strong"><strong class="calibre2">Next.</strong></span></li><li class="listitem" value="6">Specify the name of the VM and inventory location in the <span class="strong"><strong class="calibre2">Name and Location</strong></span> tab.</li><li class="listitem" value="7">Specify <a id="id106" class="calibre1"/>the host/server where this VM is to be deployed in the <span class="strong"><strong class="calibre2">Host/Cluster</strong></span> tab.</li><li class="listitem" value="8">Specify the location where the VM image should be stored in the <span class="strong"><strong class="calibre2">Storage</strong></span> tab.</li><li class="listitem" value="9">Specify the disk format in the <span class="strong"><strong class="calibre2">Disk Format</strong></span> tab.</li><li class="listitem" value="10">Click on <span class="strong"><strong class="calibre2">Next</strong></span>. It takes a while to deploy the VM image.<div class="mediaobject"><img src="../images/00011.jpeg" alt="Installing VMware vSphere Client" class="calibre11"/></div><p class="calibre15"> </p></li></ol><div class="calibre16"/></div><p class="calibre9">Once the VM image is deployed in the VMware server, we need to start the CoreOS VM with the appropriate <code class="email">cloud-config</code> file having required configuration property. The <code class="email">cloud-config</code> file in VMware vSphere should be specified by attaching a config-drive which is an <code class="email">iso</code> file with filesystem labeled <code class="email">config-2</code> by attaching CD-ROMs or new drives. The following are the commands to <a id="id107" class="calibre1"/>create the <code class="email">iso</code> file in a Linux-based operating system:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a folder, say <code class="email">/tmp/new-drive/openstack/latest</code>, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">mkdir -p /tmp/new-drive/openstack/latest</strong></span>
</pre></div></li><li class="listitem" value="2">Copy the <code class="email">user_data</code> file, which is the <code class="email">cloud-config</code> file, into the folder:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">cp user_data /tmp/new-drive/openstack/latest/user_data</strong></span>
</pre></div></li><li class="listitem" value="3">Create the <code class="email">iso</code> file using the command <code class="email">mkisofs</code> as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">mkisofs -R -V config-2 -o configdrive.iso /tmp/new-drive</strong></span>
</pre></div></li></ol><div class="calibre16"/></div><p class="calibre9">Once the <code class="email">config-drive</code> file is created, perform the following steps to attach the <code class="email">config</code> file to the VM:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Transfer the <code class="email">iso</code> image to the machine wherein the VMware vSphere Client program is running.</li><li class="listitem" value="2">Open VMware vSphere Client.</li><li class="listitem" value="3">Click on the CoreOS VM and go to the <span class="strong"><strong class="calibre2">Summary</strong></span> tab of the VM as shown in the following screenshot:<div class="mediaobject"><img src="../images/00012.jpeg" alt="Installing VMware vSphere Client" class="calibre11"/></div><p class="calibre15"> </p></li><li class="listitem" value="4">Right-click over the <span class="strong"><strong class="calibre2">Datastore</strong></span> section and click on <span class="strong"><strong class="calibre2">Browse Datastore</strong></span>. This will open a new window called <span class="strong"><strong class="calibre2">Datastore Browser</strong></span>.</li><li class="listitem" value="5">Select<a id="id108" class="calibre1"/> the folder named <code class="email">iso</code>.</li><li class="listitem" value="6">Click on the <span class="strong"><strong class="calibre2">Upload file to Datastore</strong></span> icon.</li><li class="listitem" value="7">Select the <code class="email">iso</code> file in the local machine and upload the <code class="email">iso</code> file to the <span class="strong"><strong class="calibre2">Datastore</strong></span>.<div class="mediaobject"><img src="../images/00013.jpeg" alt="Installing VMware vSphere Client" class="calibre11"/></div><p class="calibre15"> </p></li></ol><div class="calibre16"/></div><p class="calibre9">The next step is to attach the <code class="email">iso</code> file as a <code class="email">cloud-config</code> file for the VM. Perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Go to <span class="strong"><strong class="calibre2">CoreOS VM</strong></span> and right-click.</li><li class="listitem" value="2">Click on <span class="strong"><strong class="calibre2">Properties</strong></span>.</li><li class="listitem" value="3">Select <span class="strong"><strong class="calibre2">CD/DVD drive 1</strong></span>.</li><li class="listitem" value="4">On the right-hand side, select <span class="strong"><strong class="calibre2">Device Status</strong></span> as <span class="strong"><strong class="calibre2">Connected</strong></span> as well as <span class="strong"><strong class="calibre2">Connect at power on</strong></span>.</li><li class="listitem" value="5">Click on <span class="strong"><strong class="calibre2">Datastore ISO File</strong></span> and select the uploaded <code class="email">iso</code> file from the data store.<div class="mediaobject"><img src="../images/00014.jpeg" alt="Installing VMware vSphere Client" class="calibre11"/></div><p class="calibre15"> </p></li></ol><div class="calibre16"/></div><p class="calibre9">Once the <code class="email">iso</code> file is <a id="id109" class="calibre1"/>uploaded and attached to the VM, start the VM. The CoreOS VM  the VMware environment is ready.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Introduction to Docker"><div class="book" id="MSDG2-31555e2039a14139a7f00b384a5a2dd8"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Introduction to Docker</h1></div></div></div><p class="calibre9">Linux Containers, as <a id="id110" class="calibre1"/>described before, provide a lightweight or stripped-down version of OS within the host OS. Applications can be installed on Linux Containers and can be ported to any host OS supporting Linux Containers. A user doesn't have to care about releasing different software for different target machines. Multiple Linux Containers can be created on a host OS, thus providing the capability to run multiple instances of software on the same machine independent of each other. Imagine software using a large number of ports and a tedious configuration file. In a traditional approach, the user has to carefully create the configuration file for each instance so that they don't conflict with another instance. In Linux Containers, the same configuration file would work on all Container instances. This helps with faster deployment and simpler operation.</p><p class="calibre9">Docker<a id="id111" class="calibre1"/> containers are primarily Linux Containers that are capable of running a single application by design. They have the capability to run on any machine with Docker installed. Docker can be installed over a variety of machines running different operating systems such as Linux or Mac and thus making the application portable. Let's understand some Docker concepts.</p></div>

<div class="book" title="Introduction to Docker">
<div class="book" title="Image"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl4sec04" class="calibre1"/>Image</h2></div></div></div><p class="calibre9">Docker image is <a id="id112" class="calibre1"/>a read-only template. Usually, images contain an OS snapshot, but Docker images can contain anything, such as a database and OS or application. They are read only and are shared across multiple Docker containers.</p><p class="calibre9">Images can be created from scratch, or from an existing image listed on docker hub. <span class="strong"><strong class="calibre2">Docker hub</strong></span> is a <a id="id113" class="calibre1"/>public <code class="email">Docker Registry</code> that hosts docker images that can be downloaded and used. We can also set up a private docker registry.</p><p class="calibre9">Images have a unique ID and a unique human-readable name and tag pair. Images can be called, for example, <code class="email">ubuntu:latest</code>, <code class="email">ubuntu:precise</code>, <code class="email">django:1.6</code>, <code class="email">django:1.7</code>, and so on.</p><p class="calibre9">Docker uses <span class="strong"><strong class="calibre2">Union File System</strong></span><a id="id114" class="calibre1"/> to combine layers of images to form a single Docker image. Union File System allows files and directories in different filesystems to be overlaid over a single filesystem. A docker image starts with the base image, usually a standard OS image over which other layers of images are appended. Each layer provides additional functionalities over the previous layers. Upon image changes, only impact layers need to be provided instead of the complete image.</p></div></div>

<div class="book" title="Introduction to Docker">
<div class="book" title="Container"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec15" class="calibre1"/>Container</h2></div></div></div><p class="calibre9">
<span class="strong"><strong class="calibre2">Containers</strong></span> are <a id="id115" class="calibre1"/>created from <a id="id116" class="calibre1"/>the Docker Image. Container holds everything required for an application to run, such as user files, metadata, user applications, and so on. To expose the service provided by the containers, Docker allows exposing specific ports of a container.</p><div class="book" title="Volumes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl4sec05" class="calibre1"/>Volumes</h3></div></div></div><p class="calibre9">As<a id="id117" class="calibre1"/> described before, Docker images are layers of read-only Union filesystems. When we start a container, additionally a read-write layer is created over the top of the read-only layer as there may be a requirement to modify a file (for instance). When some modification is made, data is present in both the read-write and read-only layers. This is required so that the image used in the container remains unchanged. The scope of this read-write layer is only until the container exists. Once the container is deleted, the read-write layer is destroyed and the read-only (unchanged) image is available for reuse. <span class="strong"><strong class="calibre2">Volumes</strong></span> provide a mechanism to manage data within and across containers. They also provide a mechanism to share data from the host machine to the container, thus enabling data to be outside the container. Data can be directly shared from the host<a id="id118" class="calibre1"/> folder or from another container. It's recommended to create a data-only container and share data from that container.</p></div></div></div>

<div class="book" title="Introduction to Docker">
<div class="book" title="Links"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec16" class="calibre1"/>Links</h2></div></div></div><p class="calibre9">Docker containers <a id="id119" class="calibre1"/>can connect to each other using the network port mappings created while containers are created. This brings some element of hardcoding as the ports are preconfigured. Container links can also be used by linking the source container to the recipient container using container names. Docker exposes connectivity information for the source container to the recipient container through environment variables and by modifying the <code class="email">/etc/hosts</code> file. The environment variables are prefixed with the link name and follow naming convention to help the recipient identify the interface details (such as protocol used, IP address, port, and so on). The <code class="email">/etc/hosts</code> file is updated with the source container IP address and the hostname as the container name.</p></div></div>

<div class="book" title="Introduction to Docker">
<div class="book" title="Installing Docker"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec17" class="calibre1"/>Installing Docker</h2></div></div></div><p class="calibre9">Docker can <a id="id120" class="calibre1"/>also be installed on a variety of platforms, virtual machines and cloud providers. Docker contains two components:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Docker Client: The user invokes Docker Client to start, stop, and manage the Docker container.</li><li class="listitem">Docker Daemon: Docker Client interfaces with Docker Daemon to actually start, stop, and manage the Docker container. Docker Daemon can only run on Linux machines. So if Docker is installed on Windows or Mac, Docker Daemon runs inside Linux Virtual Machine (for instance, in VirtualBox).</li></ul></div><p class="calibre9">There are two ways to create a Docker image:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Using Docker File and the Docker <code class="email">build</code> command</li><li class="listitem">Using the pre-built docker images from dockerhub</li></ul></div></div></div>

<div class="book" title="Introduction to Docker">
<div class="book" title="Creating a sample Docker image using Docker File"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec18" class="calibre1"/>Creating a sample Docker image using Docker File</h2></div></div></div><p class="calibre9">In this<a id="id121" class="calibre1"/> section, we will learn how to create Docker containers through Docker File. Docker File has obvious benefits. Docker File helps automate the build process, it can be version controlled for the project, and inline comments serve as help for beginners and many others.</p><p class="calibre9">The following is the simple Docker File that creates a docker image using the CentOS base image:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$cat Dockerfile</strong></span>
<span class="strong"><strong class="calibre2">FROM centos</strong></span>
<span class="strong"><strong class="calibre2">CMD ["uname", "-a"]</strong></span>

<span class="strong"><strong class="calibre2">$ docker build -t docker_uname .</strong></span>
<span class="strong"><strong class="calibre2">Sending build context to Docker daemon 2.048 kB</strong></span>
<span class="strong"><strong class="calibre2">Step 0 : FROM centos</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; 7322fbe74aa5</strong></span>
<span class="strong"><strong class="calibre2">Step 1 : CMD uname -a</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; Using cache</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; 36d993cf27b9</strong></span>
<span class="strong"><strong class="calibre2">Successfully built 36d993cf27b9</strong></span>
</pre></div><div class="book" title="Docker File"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec10" class="calibre1"/>Docker File</h3></div></div></div><p class="calibre9">Docker File <a id="id122" class="calibre1"/>contains the instructions used by Docker to build the images. The Docker File takes the following format:</p><div class="informalexample"><pre class="programlisting"># Comment
INSTRUCTION arguments</pre></div><p class="calibre9">The instructions are run in order. The lines beginning with <code class="email">#</code> are treated as comments and are not executed. Environment variables can also be used as variables in instruction arguments. Some of the important instructions are:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">FROM</code>: This sets the base image for the Docker image. This is the first instruction. Arguments can be in any one of the following format:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">FROM &lt;image&gt; </strong></span>
<span class="strong"><strong class="calibre2">FROM &lt;image&gt;:&lt;tag&gt;</strong></span>
<span class="strong"><strong class="calibre2">FROM &lt;image&gt;@&lt;digest&gt;</strong></span>
</pre></div><p class="calibre17">If <code class="email">tag</code> or <code class="email">digest</code> is not provided, the latest image is selected.</p></li><li class="listitem"><code class="email">RUN</code>: This instruction specifies the commands to be executed for building the container. Typical usages of <code class="email">RUN</code> instructions are updating the base image with OS patches, installing specific packages, updating system configuration, and so on. Each command runs in a separate layer on top of the current image and committed. The committed image is then used for the next step. Arguments can be in any one of the following format:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">RUN &lt;command&gt; </strong></span>
</pre></div><p class="calibre17">In this form, <code class="email">command</code> is executed within shell /<code class="email">bin/sh -c</code>. Shell <code class="email">/bin/sh –c</code> is the default <code class="email">ENTRYPOINT</code> for docker:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">RUN ["executable", "param1", "param2"]</strong></span>
</pre></div><p class="calibre17">In this form, <code class="email">command</code> is executed directly without invoking a shell.</p></li><li class="listitem"><code class="email">ENTRYPOINT</code>: This specifies the executable and its corresponding parameters when docker is started. Any parameters that are passed during the starting of docker are appended to <code class="email">ENTRYPOINT</code> and executed.<p class="calibre17">Arguments can be in any one of the following formats:</p><div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">ENTRYPOINT ["executable", "param1", "param2"]</code>: In this format, command is executed directly without invoking a shell.</li><li class="listitem"><code class="email">ENTRYPOINT &lt;command&gt; &lt;paramters&gt;</code>: In this format, command is executed within shell <code class="email">/bin/sh -c</code>.</li></ul></div></li><li class="listitem"><code class="email">CMD</code>: This <a id="id123" class="calibre1"/>specifies the defaults (that is, executable, shell, and command-line parameters) for the containers to be executed when docker is started. This is different from <code class="email">RUN</code> as <code class="email">RUN</code> instructions are only executed during building an image.<p class="calibre17">Arguments can be in any one of the following format:</p><div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">CMD ["executable","param1","param2"]</code>: This format is used when <code class="email">ENTRYPOINT</code> is not provided. Command is executed here without a shell.</li><li class="listitem"><code class="email">CMD ["param1","param2"]</code>: This format is used when <code class="email">ENTRYPOINT</code> is provided with a default command. The parameters provided here are appended to <code class="email">ENTRYPOINT</code> and executed.</li><li class="listitem"><code class="email">CMD command param1 param2</code> (shell form): In this format, command is executed within shell <code class="email">/bin/sh -c</code>.</li></ul></div><p class="calibre17">Only one <code class="email">CMD</code> instruction is executed. If multiple <code class="email">CMD</code> instructions are provided, the last instruction is used.</p></li><li class="listitem"><code class="email">EXPOSE</code>: This specifies the list of listening ports on which Docker is listening. The format of this field is: <code class="email">EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></li><li class="listitem"><code class="email">VOLUME</code>: This specifies the mount path in the container and the external directories from the host machine or volumes from another container. The format of this field is: <code class="email">VOLUME &lt;directory&gt; [&lt;directory&gt;…]</code></li></ul></div></div></div></div>

<div class="book" title="Introduction to Docker">
<div class="book" title="Pulling the Docker image from Docker Hub"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch02lvl2sec19" class="calibre1"/>Pulling the Docker image from Docker Hub</h2></div></div></div><p class="calibre9">
<span class="strong"><strong class="calibre2">Docker Hub</strong></span> is <a id="id124" class="calibre1"/>a community-driven docker image hosting service provided by Docker that has capabilities for public and private content. Already there are more than 100,000 images available in the Docker Hub registry. Instead of building docker images using Docker File, docker images can be directly downloaded from Docker Hub. The docker <code class="email">pull</code> command is used to pull the images directly <a id="id125" class="calibre1"/>from Docker Hub and the format is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">docker pull centos</strong></span>
</pre></div></div></div>

<div class="book" title="Introduction to Docker">
<div class="book" title="Running Docker Image"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch02lvl2sec20" class="calibre1"/>Running Docker Image</h2></div></div></div><p class="calibre9">Let's start <a id="id126" class="calibre1"/>by running an already existing system command from the Docker container. The Docker container in this example prints the system information and exits:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ docker run centos uname -a</strong></span>
<span class="strong"><strong class="calibre2">Linux 3c954433a1e2 4.0.9-boot2docker #1 SMP Thu Aug 13 03:05:44 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux</strong></span>
</pre></div><p class="calibre9">The <code class="email">run</code> parameter runs Docker containers. The image name is provided as <code class="email">centos</code>. During the first run, if the image is not available in the local machine, the latest-version <code class="email">centos</code> image is downloaded from the public image registry Docker Hub. Since no version of the image was specified, the latest version was chosen. If a specific version is required to be installed, it can also be provided, for example, <code class="email">centos:6.6</code>. The <code class="email">uname –a</code> command is then executed inside the container using the default <code class="email">ENTRYPOINT</code> <code class="email">/bin/sh -c</code>. After the command execution is completed, the container exits.</p><p class="calibre9">We will create a more sophisticated Docker File container that executes the <code class="email">RUN</code> instruction to install a package over the base image and listens for a TCP connection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$cat Dockerfile</strong></span>
<span class="strong"><strong class="calibre2">FROM centos</strong></span>

<span class="strong"><strong class="calibre2"># install ncat commad to be used for this demo during build. Ncat </strong></span>
<span class="strong"><strong class="calibre2"># is not part of standard package.</strong></span>
<span class="strong"><strong class="calibre2">RUN ["yum", "-y", "install", "nc"]</strong></span>

<span class="strong"><strong class="calibre2"># print machine ips</strong></span>
<span class="strong"><strong class="calibre2">RUN ["cat", "/etc/hosts"]</strong></span>

<span class="strong"><strong class="calibre2"># run the command ncat to listen on all IP address on port 12345</strong></span>
<span class="strong"><strong class="calibre2">CMD ["ncat", "-vv", "-l", "0.0.0.0", "12345"]</strong></span>

<span class="strong"><strong class="calibre2">$ docker build -t dock_ncat .</strong></span>
<span class="strong"><strong class="calibre2">Sending build context to Docker daemon 3.072 kB</strong></span>
<span class="strong"><strong class="calibre2">Step 0 : FROM centos</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; 7322fbe74aa5</strong></span>
<span class="strong"><strong class="calibre2">Step 1 : RUN yum -y install nc</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; Using cache</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; 886063e43760</strong></span>
<span class="strong"><strong class="calibre2">Step 2 : RUN cat /etc/hosts</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; Using cache</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; df623793d532</strong></span>
<span class="strong"><strong class="calibre2">Step 3 : CMD ncat -vv -l 0.0.0.0 12345</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; Running in a0a5daa581b4</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; f8ad341c047e</strong></span>
<span class="strong"><strong class="calibre2">Removing intermediate container a0a5daa581b4</strong></span>
<span class="strong"><strong class="calibre2">Successfully built f8ad341c047e Removing intermediate container 6f8284dad1f8</strong></span>
<span class="strong"><strong class="calibre2">Successfully built 3c60a690a2d7</strong></span>


<span class="strong"><strong class="calibre2">$ docker run -p :12344:12345 dock_ncat</strong></span>
<span class="strong"><strong class="calibre2">Ncat: Version 6.40 ( http://nmap.org/ncat )</strong></span>
<span class="strong"><strong class="calibre2">Ncat: Listening on 0.0.0.0:12345</strong></span>
<span class="strong"><strong class="calibre2">Ncat: Connection from 172.18.42.1.</strong></span>
<span class="strong"><strong class="calibre2">Ncat: Connection from 172.18.42.1:58939.</strong></span>
</pre></div><p class="calibre9">Port <code class="email">12345</code> from <a id="id127" class="calibre1"/>the container is mapped to port <code class="email">12344</code> on the host. If the host tries to connect on <code class="email">12344</code>, a connection gets established on the container.</p></div></div>
<div class="book" title="Summary" id="NQU21-31555e2039a14139a7f00b384a5a2dd8"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, we were able to set up and run CoreOS with a single machine using Vagrant and VirtualBox. We were also able to create and run Docker images. In due process, we familiarized ourselves with the important configuration files and their contents. </p><p class="calibre9">In the next chapter, we will learn how to set up a CoreOS cluster with multiple machines. We will also learn how machines are discovered and services are scheduled on those machines.</p></div></body></html>