<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;The Build System"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. The Build System</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the host system</li><li class="listitem" style="list-style-type: disc">Installing Poky</li><li class="listitem" style="list-style-type: disc">Creating a build directory</li><li class="listitem" style="list-style-type: disc">Building your first image</li><li class="listitem" style="list-style-type: disc">Explaining the Freescale Yocto ecosystem</li><li class="listitem" style="list-style-type: disc">Installing support for Freescale hardware</li><li class="listitem" style="list-style-type: disc">Building Wandboard images</li><li class="listitem" style="list-style-type: disc">Troubleshooting your Wandboard's first boot</li><li class="listitem" style="list-style-type: disc">Configuring network booting for a development setup</li><li class="listitem" style="list-style-type: disc">Sharing downloads</li><li class="listitem" style="list-style-type: disc">Sharing the shared state cache</li><li class="listitem" style="list-style-type: disc">Setting up a package feed</li><li class="listitem" style="list-style-type: disc">Using build history</li><li class="listitem" style="list-style-type: disc">Working with build statistics</li><li class="listitem" style="list-style-type: disc">Debugging the build system</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p>The <a id="id0" class="indexterm"/>Yocto project (<a class="ulink" href="http://www.yoctoproject.org/">http://www.yoctoproject.org/</a>) is an embedded Linux distribution builder that makes use of several other open source projects.</p><p>The Yocto project <a id="id1" class="indexterm"/>provides a reference build system for embedded Linux, called <a id="id2" class="indexterm"/>
<span class="strong"><strong>Poky</strong></span>, which has the <span class="strong"><strong>BitBake</strong></span><a id="id3" class="indexterm"/> and <span class="strong"><strong>OpenEmbedded-Core</strong></span> (<span class="strong"><strong>OE-Core</strong></span>)<a id="id4" class="indexterm"/> projects at its base. The purpose of Poky<a id="id5" class="indexterm"/> is to build the components needed for an embedded Linux product, namely:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A bootloader image</li><li class="listitem" style="list-style-type: disc">A Linux kernel image</li><li class="listitem" style="list-style-type: disc">A root filesystem image</li><li class="listitem" style="list-style-type: disc">Toolchains and <span class="strong"><strong>software development kits</strong></span> (<span class="strong"><strong>SDKs</strong></span>)<a id="id6" class="indexterm"/> for application development</li></ul></div><p>With these, the<a id="id7" class="indexterm"/> Yocto project covers the needs of both system and application developers. When the Yocto project is used as an integration environment for bootloaders, the Linux kernel, and user space applications, we refer to it as system development.</p><p>For application development, the Yocto project builds SDKs that enable the development of applications independently of the Yocto build system.</p><p>The Yocto project makes a new release every six months. The latest release at the time of this writing is <a id="id8" class="indexterm"/>Yocto 1.7.1 Dizzy, and all the examples in this book refer to the 1.7.1 release.</p><p>A Yocto release<a id="id9" class="indexterm"/> comprises the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Poky, the reference build system</li><li class="listitem" style="list-style-type: disc">A build appliance; that is, a VMware image of a host system ready to use Yocto</li><li class="listitem" style="list-style-type: disc">An <span class="strong"><strong>Application Development Toolkit</strong></span> (<span class="strong"><strong>ADT</strong></span>)<a id="id10" class="indexterm"/> installer for your host system</li><li class="listitem" style="list-style-type: disc">And for the different supported platforms:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Prebuilt toolchains</li><li class="listitem" style="list-style-type: disc">Prebuilt packaged binaries</li><li class="listitem" style="list-style-type: disc">Prebuilt images</li></ul></div></li></ul></div><p>The Yocto 1.7.1 release<a id="id11" class="indexterm"/> is available to download from <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/">http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/</a>.</p></div></div>
<div class="section" title="Setting up the host system"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Setting up the host system</h1></div></div></div><p>This recipe will explain <a id="id12" class="indexterm"/>how to set up a host Linux system to use the Yocto project.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Getting ready</h2></div></div></div><p>The recommended way to develop an embedded Linux system is using a native Linux workstation. Development work using virtual machines is discouraged, although they may be used for demo and test purposes.</p><p>Yocto builds all the components mentioned before from scratch, including the cross-compilation toolchain and the native tools it needs, so the Yocto build process is demanding in terms of processing power and both hard drive space and I/O.</p><p>Although Yocto will work fine on machines with lower specifications, for professional developer's workstations, it is recommended to use <span class="strong"><strong>symmetric multiprocessing</strong></span> (<span class="strong"><strong>SMP</strong></span>)<a id="id13" class="indexterm"/> systems with 8 GB or more system memory and a high capacity, fast hard drive. Build servers can employ distributed compilation, but this is out of the scope of this book. Due to different bottlenecks in the build process, there does not seem to be much improvement above 8 CPUs or around 16 GB RAM.</p><p>The first build will also download all the sources from the Internet, so a fast Internet connection is also recommended.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How to do it...</h2></div></div></div><p>Yocto supports several<a id="id14" class="indexterm"/> distributions, and each Yocto release will document a list of the supported ones. Although the use of a supported Linux distribution is strongly advised, Yocto is able to run on any Linux system if it has the following dependencies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Git 1.7.8 or greater</li><li class="listitem" style="list-style-type: disc">Tar 1.24 or greater</li><li class="listitem" style="list-style-type: disc">Python 2.7.3 or greater (but not Python 3)</li></ul></div><p>Yocto also provides a way to install the correct version of these tools by either downloading a <span class="emphasis"><em>buildtools-tarball</em></span> or building one on a supported machine. This allows virtually any Linux distribution to be able to run Yocto, and also makes sure that it will be possible to replicate your Yocto build system in the future. This is important for embedded products with long-term availability requirements.</p><p>This book will use the Ubuntu 14.04<span class="strong"><strong> Long-Term Stable</strong></span> (<span class="strong"><strong>LTS</strong></span>)<a id="id15" class="indexterm"/> Linux distribution for all examples. Instructions to install on other Linux distributions can be found on the <span class="emphasis"><em>Supported Linux Distributions</em></span> section of the <span class="emphasis"><em>Yocto Project Development Manual</em></span>, but the examples will only be tested with Ubuntu 14.04 LTS.</p><p>To make sure you have the required package dependencies installed for Yocto and to follow the examples in the book, run the following command from your shell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc- multilib build-essential chrpath socat libsdl1.2-dev xterm make xsltproc docbook-utils fop dblatex xmlto autoconf automake libtool libglib2.0-dev python-gtk2 bsdmainutils screen</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>The example code in the book can be accessed through several GitHub repositories at <a class="ulink" href="https://github.com/yoctocookbook">https://github.com/yoctocookbook</a>. Follow the instructions on GitHub to obtain a copy of the source in your computer.</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How it works...</h2></div></div></div><p>The preceding <a id="id16" class="indexterm"/>command will use <code class="literal">apt-get</code>, the <a id="id17" class="indexterm"/>
<span class="strong"><strong>Advanced Packaging Tool</strong></span> (<span class="strong"><strong>APT</strong></span>), command-line tool. It is a frontend of the <span class="strong"><strong>dpkg</strong></span> package manager<a id="id18" class="indexterm"/> that is included in the Ubuntu distribution. It will install all the required packages and their dependencies to support all the features of the Yocto project.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>There's more...</h2></div></div></div><p>If build times are an important factor for you, there are certain steps you can take when preparing your disks to optimize them even further:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Place the <code class="literal">build</code> directories on their own disk partition or a fast external drive.</li><li class="listitem" style="list-style-type: disc">Use the ext4 filesystem but configure it not to use journalism on your Yocto-dedicated partitions. Be aware that power losses may corrupt your build data.</li><li class="listitem" style="list-style-type: disc">Mount the filesystem in such a way that read times are not written/recorded on file reads, disable write barriers, and delay committing filesystem changes with the following mount options:<div class="informalexample"><pre class="programlisting">noatime,barrier=0,commit=6000.</pre></div></li><li class="listitem" style="list-style-type: disc">Do not build on network-mounted drives.</li></ul></div><p>These changes reduce the data integrity safeguards, but with the separation of the <code class="literal">build</code> directories to their own disk, failures would only affect temporary build data, which can be erased and regenerated.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The complete Yocto project installation instructions for Ubuntu and other supported distributions can be found on the <span class="emphasis"><em>Yocto Project Reference Manual</em></span> at<a id="id19" class="indexterm"/> <a class="ulink" href="http://www.yoctoproject.org/docs/1.7.1/ref-manual/ref-manual.html">http://www.yoctoproject.org/docs/1.7.1/ref-manual/ref-manual.html</a></li></ul></div></div></div>
<div class="section" title="Installing Poky"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Installing Poky</h1></div></div></div><p>This recipe will explain how to set up your host Linux system with Poky, the Yocto project reference system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Getting ready</h2></div></div></div><p>Poky uses the <a id="id20" class="indexterm"/>OpenEmbedded build system, and as such, uses the BitBake tool, a task scheduler written in Python which forked from Gentoo's Portage tool. You can think of BitBake as the make utility in Yocto. It will parse the configuration and recipe metadata, schedule a task list, and run through it.</p><p>BitBake<a id="id21" class="indexterm"/> is also the command-line interface to Yocto.</p><p>Poky and BitBake are two of the open source projects used by Yocto. The Poky project is maintained by the Yocto community. You can download Poky from its Git repository<a id="id22" class="indexterm"/> at <a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi/poky/">http://git.yoctoproject.org/cgit/cgit.cgi/poky/</a>.</p><p>Development discussions can be followed and contributed to by visiting the development mailing list <a id="id23" class="indexterm"/>at <a class="ulink" href="https://lists.yoctoproject.org/listinfo/poky">https://lists.yoctoproject.org/listinfo/poky</a>.</p><p>BitBake, on the other hand, is maintained by both the Yocto and OpenEmbedded communities, as the tool is used by both. BitBake<a id="id24" class="indexterm"/> can be downloaded from its Git repository at <a class="ulink" href="http://git.openembedded.org/bitbake/">http://git.openembedded.org/bitbake/</a>.</p><p>Development discussions can be followed and contributed to by visiting the development mailing list <a id="id25" class="indexterm"/>at <a class="ulink" href="http://lists.openembedded.org/mailman/listinfo/bitbake-devel">http://lists.openembedded.org/mailman/listinfo/bitbake-devel</a>.</p><p>The Poky build system only supports virtualized QEMU machines for the following architectures:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ARM (qemuarm)</li><li class="listitem" style="list-style-type: disc">x86 (qemux86)</li><li class="listitem" style="list-style-type: disc">x86-64 (qemux86-64)</li><li class="listitem" style="list-style-type: disc">PowerPC (qemuppc)</li><li class="listitem" style="list-style-type: disc">MIPS (qemumips, qemumips64)</li></ul></div><p>Apart from these, it also supports some reference hardware <a id="id26" class="indexterm"/>
<span class="strong"><strong>Board Support Packages</strong></span> (<span class="strong"><strong>BSPs</strong></span>), representative of the architectures just listed. These are those BSPs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Texas Instruments Beaglebone (beaglebone)</li><li class="listitem" style="list-style-type: disc">Freescale MPC8315E-RDB (mpc8315e-rdb)</li><li class="listitem" style="list-style-type: disc">Intel x86 based PCs and devices (genericx86 and genericx86-64)</li><li class="listitem" style="list-style-type: disc">Ubiquiti Networks EdgeRouter Lite (edgerouter)</li></ul></div><p>To develop on different hardware, you will need to complement Poky with hardware-specific Yocto layers. This will be covered later on.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How to do it...</h2></div></div></div><p>The Poky<a id="id27" class="indexterm"/> project incorporates a stable BitBake release, so to get started with Yocto, we only need to install Poky in our Linux host system.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Note that you can also install BitBake independently through your distribution's package management system. This is not recommended and can be a source of problems, as BitBake needs to be compatible with the metadata used in Yocto. If you have installed BitBake from your distribution, please remove it.</p></div></div><p>The current Yocto release is 1.7.1, or Dizzy, so we will install that into our host system. We will use the <code class="literal">/opt/yocto</code> folder as the installation path:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo install -o $(id -u) -g $(id -g) -d /opt/yocto</strong></span>
<span class="strong"><strong>$ cd /opt/yocto</strong></span>
<span class="strong"><strong>$ git clone --branch dizzy git://git.yoctoproject.org/poky</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How it works...</h2></div></div></div><p>The previous instructions will use Git (the source code management system command-line tool) to clone the Poky repository, which includes BitBake, into a new <code class="literal">poky</code> directory on our current path, and point it to the Dizzy stable branch.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>There's more...</h2></div></div></div><p>Poky contains three metadata directories, <code class="literal">meta</code>, <code class="literal">meta-yocto</code>, and <code class="literal">meta-yocto-bsp</code>, as well as a template metadata layer, <code class="literal">meta-skeleton</code>, that can be used as a base for new layers. Poky's three metadata directories<a id="id28" class="indexterm"/> are explained here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">meta</code>: This directory<a id="id29" class="indexterm"/> contains the OpenEmbedded-Core metadata, which supports the ARM, x86, x86-64, PowerPC, MIPS, and MIPS64 architectures and the QEMU emulated hardware. You can download it from its Git repository at <a class="ulink" href="http://git.openembedded.org/openembedded-core/">http://git.openembedded.org/openembedded-core/</a>.<p>Development discussions can be followed and contributed to by visiting the <a id="id30" class="indexterm"/>development mailing list at <a class="ulink" href="http://lists.openembedded.org/mailman/listinfo/openembedded-core">http://lists.openembedded.org/mailman/listinfo/openembedded-core</a>.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">meta-yocto</code>: This<a id="id31" class="indexterm"/> contains Poky's distribution-specific metadata.</li><li class="listitem" style="list-style-type: disc"><code class="literal">meta-yocto-bsp</code>: This <a id="id32" class="indexterm"/>contains metadata for the<a id="id33" class="indexterm"/> reference hardware boards.</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is documentation about Git, the<a id="id34" class="indexterm"/> distributed version control system, at <a class="ulink" href="http://git-scm.com/doc">http://git-scm.com/doc</a></li></ul></div></div></div>
<div class="section" title="Creating a build directory"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Creating a build directory</h1></div></div></div><p>Before building your first <a id="id35" class="indexterm"/>Yocto image, we need to create a <code class="literal">build</code> directory for it.</p><p>The build process, on a host system as outlined before, can take up to one hour and need around 20 GB of hard drive space for a console-only image. A graphical image, like <code class="literal">core-image-sato</code>, can take up to 4 hours for the build process and occupy around 50 GB of space.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>How to do it...</h2></div></div></div><p>The first thing we need to do is create a <code class="literal">build</code> directory for our project, where the build output will be generated. Sometimes, the <code class="literal">build</code> directory may be referred to as the project directory, but <code class="literal">build</code> directory is the appropriate Yocto term.</p><p>There is no right way to structure the <code class="literal">build</code> directories when you have multiple projects, but a good practice is to have one <code class="literal">build</code> directory per architecture or machine type. They can all share a common <code class="literal">downloads</code> folders, and even a shared state cache (this will be covered later on), so keeping them separate won't affect the build performance, but it will allow you to develop on multiple projects simultaneously.</p><p>To create a <code class="literal">build</code> directory, we use the <code class="literal">oe-init-build-env</code> script provided by Poky. The script needs to be sourced into your current shell, and it will set up your environment to use the OpenEmbedded/Yocto build system, including adding the BitBake utility to your path. You can specify a <code class="literal">build</code> directory to use or it will use <code class="literal">build</code> by default. We will use <code class="literal">qemuarm</code> for this example.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/poky</strong></span>
<span class="strong"><strong>$ source oe-init-build-env qemuarm</strong></span>
</pre></div><p>The script will change to the specified directory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>As <code class="literal">oe-init-build-env</code> <a id="id36" class="indexterm"/>only<a id="id37" class="indexterm"/> configures the current shell, you will need to source it on every new shell. But, if you point the script to an existing <code class="literal">build</code> directory, it will set up your environment but won't change any of your existing configurations.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>BitBake<a id="id38" class="indexterm"/> is designed with a client/server abstraction, so we can also start a memory resident server and connect a client to it. With this setup, loading cache and configuration information each time is avoided, which saves some overhead. To run a memory resident BitBake that will always be available, you can use the <code class="literal">oe-init-build-env-memres</code> script as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source oe-init-build-env-memres 12345 qemuarm</strong></span>
</pre></div><p>Here <code class="literal">12345</code> is the local port to be used.</p><p>Do not use both BitBake flavors simultaneously, as this can be a source of problems.</p><p>You can then kill the memory resident BitBake by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -m</strong></span>
</pre></div></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How it works...</h2></div></div></div><p>Both scripts<a id="id39" class="indexterm"/> call the <code class="literal">scripts/oe-setup-builddir</code> script inside the <code class="literal">poky</code> directory to create the <code class="literal">build</code> directory.</p><p>On creation, the <code class="literal">build</code> directory contains a <code class="literal">conf</code> directory with the following three files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">bblayers.conf</code>: This file <a id="id40" class="indexterm"/>lists the metadata layers to be considered for this project.</li><li class="listitem" style="list-style-type: disc"><code class="literal">local.conf</code>: This file <a id="id41" class="indexterm"/>contains the project-specific configuration variables. You can set common configuration variables to different projects with a <code class="literal">site.conf</code> file, but this is not created by default.</li><li class="listitem" style="list-style-type: disc"><code class="literal">templateconf.cfg</code>: This file <a id="id42" class="indexterm"/>contains the directory that includes the template configuration files used to create the project. By default it uses the one pointed to by the <code class="literal">templateconf</code> file in your <a id="id43" class="indexterm"/>Poky installation directory, which is <code class="literal">meta-yocto/conf</code> by default.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>To start a build from scratch, that's all the <code class="literal">build</code> directory needs.</p><p>Erasing everything apart from these files will recreate your build from scratch.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/poky/qemuarm</strong></span>
<span class="strong"><strong>$ rm -Rf tmp sstate-cache</strong></span>
</pre></div></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>There's more...</h2></div></div></div><p>You can specify a different template configuration file to use when you create your <code class="literal">build</code> directory using the <code class="literal">TEMPLATECONF</code> variable; for example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ TEMPLATECONF=meta-custom/config source oe-init-build-env &lt;build- dir&gt;</strong></span>
</pre></div><p>The <code class="literal">TEMPLATECONF</code> variable needs to refer to a directory containing templates for both <code class="literal">local.conf</code> and <code class="literal">bblayer.conf</code>, but named <code class="literal">local.conf.sample</code> and <code class="literal">bblayers.conf.sample</code>.</p><p>For our purposes, we can use the unmodified default project configuration files.</p></div></div>
<div class="section" title="Building your first image"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Building your first image</h1></div></div></div><p>Before building our first image, we<a id="id44" class="indexterm"/> need to decide what type of image we want to build. This recipe will introduce some of the available Yocto images and provide instructions to build a simple image.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Getting ready</h2></div></div></div><p>Poky contains a set of default target images. You can list them by executing the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/poky</strong></span>
<span class="strong"><strong>$ ls meta*/recipes*/images/*.bb</strong></span>
</pre></div><p>A full description of the different images can be found on the <span class="emphasis"><em>Yocto Project Reference Manual</em></span>. Typically, these default images are used as a base and customized for your own project needs. The most frequently used base default images are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">core-image-minimal</code>: This is the <a id="id45" class="indexterm"/>smallest BusyBox-, sysvinit-, and udev-based console-only image</li><li class="listitem" style="list-style-type: disc"><code class="literal">core-image-full-cmdline</code>: This is the <a id="id46" class="indexterm"/>BusyBox-based console-only image with full hardware support and a more complete Linux system, including bash</li><li class="listitem" style="list-style-type: disc"><code class="literal">core-image-lsb</code>: This is a<a id="id47" class="indexterm"/> console-only image that is based on Linux Standard Base compliance</li><li class="listitem" style="list-style-type: disc"><code class="literal">core-image-x11</code>: This is the basic<a id="id48" class="indexterm"/> X11 Windows-system-based image with a graphical terminal</li><li class="listitem" style="list-style-type: disc"><code class="literal">core-image-sato</code>: This is the <a id="id49" class="indexterm"/>X11 Window-system-based image with a SATO theme and a GNOME Mobile desktop environment</li><li class="listitem" style="list-style-type: disc"><code class="literal">core-image-weston</code>: This is a <a id="id50" class="indexterm"/>Wayland protocol and Weston reference compositor-based image</li></ul></div><p>You will also find images with the following suffixes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dev</code>: These <a id="id51" class="indexterm"/>images are suitable for development work, as they contain headers and libraries.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sdk</code>: These <a id="id52" class="indexterm"/>images include a complete SDK that can be used for development on the target.</li><li class="listitem" style="list-style-type: disc"><code class="literal">initramfs</code>: This is <a id="id53" class="indexterm"/>an image that can be used for a RAM-based root filesystem, which can optionally be embedded with the Linux kernel.</li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How to do it...</h2></div></div></div><p>To build an image, we<a id="id54" class="indexterm"/> need to configure the <code class="literal">MACHINE</code> we are building it for and pass its name to BitBake. For example, for the <code class="literal">qemuarm</code> machine, we would run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/poky/qemuarm</strong></span>
<span class="strong"><strong>$ MACHINE=qemuarm bitbake core-image-minimal</strong></span>
</pre></div><p>Or we could export the <code class="literal">MACHINE</code> variable to the current shell environment with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ export MACHINE=qemuarm</strong></span>
</pre></div><p>But the preferred and persistent way to do it is to edit the <code class="literal">conf/local.conf</code> configuration file to change the default machine to <code class="literal">qemuarm</code>:</p><div class="informalexample"><pre class="programlisting">- #MACHINE ?= "qemuarm"
+ MACHINE ?= "qemuarm"</pre></div><p>Then you can just execute the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake core-image-minimal</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How it works...</h2></div></div></div><p>When you pass a target recipe to BitBake, it first parses the following configuration files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">conf/bblayers.conf</code>: This file is used to find all the configured layers</li><li class="listitem" style="list-style-type: disc"><code class="literal">conf/layer.conf</code>: This file is used on each configured layer</li><li class="listitem" style="list-style-type: disc"><code class="literal">meta/conf/bitbake.conf</code>: This file is used for its own configuration</li><li class="listitem" style="list-style-type: disc"><code class="literal">conf/local.conf</code>: This file is used for any other configuration the user may have for the current build</li><li class="listitem" style="list-style-type: disc"><code class="literal">conf/machine/&lt;machine&gt;.conf</code>: This file is the machine configuration; in our case, this is <code class="literal">qemuarm.conf</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">conf/distro/&lt;distro&gt;.conf</code>: This file is the distribution policy; by default, this is the <code class="literal">poky.conf</code> file</li></ul></div><p>And then BitBake parses<a id="id55" class="indexterm"/> the target recipe that has been provided and its dependencies. The outcome is a set of interdependent tasks that BitBake will then execute in order.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>There's more...</h2></div></div></div><p>Most developers won't be interested in keeping the whole build output for every package, so it is recommended to configure your project to remove it with the following configuration in your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">INHERIT += "rm_work"</pre></div><p>But at the same time, configuring it for all packages means that you won't be able to develop or debug them.</p><p>You can add a list of packages to exclude from cleaning by adding them to the <code class="literal">RM_WORK_EXCLUDE</code> variable. For example, if you are going to do BSP work, a good setting might be:</p><div class="informalexample"><pre class="programlisting">RM_WORK_EXCLUDE += "linux-yocto u-boot"</pre></div><p>Remember that you can use a custom template <code class="literal">local.conf.sample</code> configuration file in your own layer to keep these configurations and apply them for all projects so that they can be shared across all developers.</p><p>Once the build finishes, you can find the output images on the <code class="literal">tmp/deploy/images/qemuarm</code> directory inside your <code class="literal">build</code> directory.</p><p>By default, images are not erased from the <code class="literal">deploy</code> directory, but you can configure your project to remove the previously built version of the same image by adding the following to your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">RM_OLD_IMAGE = "1"</pre></div><p>You can test run your<a id="id56" class="indexterm"/> images on the QEMU emulator by executing this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runqemu qemuarm core-image-minimal</strong></span>
</pre></div><p>The <code class="literal">runqemu</code> script included in Poky's <code class="literal">scripts</code> directory is a launch wrapper around the QEMU machine emulator to simplify its usage.</p></div></div>
<div class="section" title="Explaining the Freescale Yocto ecosystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Explaining the Freescale Yocto ecosystem</h1></div></div></div><p>As we saw, Poky <a id="id57" class="indexterm"/>metadata starts with the <code class="literal">meta</code>, <code class="literal">meta-yocto</code>, and <code class="literal">meta-yocto-bsp</code> layers, and it can be expanded by using more layers.</p><p>An index of the available OpenEmbedded layer<a id="id58" class="indexterm"/>s that are compatible with the Yocto project is maintained at <a class="ulink" href="http://layers.openembedded.org/">http://layers.openembedded.org/</a>.</p><p>An embedded product's development usually starts with hardware evaluation using a manufacturer's reference board design. Unless you are working with one of the reference boards already supported by Poky, you will need to extend Poky to support your hardware.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>Getting ready</h2></div></div></div><p>The first thing to do is to select which base hardware your design is going to be based on. We will use a board that is based on a Freescale i.MX6 <span class="strong"><strong>System on Chip</strong></span> (<span class="strong"><strong>SoC</strong></span>)<a id="id59" class="indexterm"/> as a starting point for our embedded product design.</p><p>This recipe gives an overview of the support for Freescale hardware in the Yocto project.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How to do it...</h2></div></div></div><p>The SoC manufacturer (in this case, Freescale) has a range of reference design boards for purchase, as well as official Yocto-based software releases. Similarly, other manufacturers that use Freescale's SoCs offer reference design boards and their own Yocto-based software releases.</p><p>Selecting the appropriate hardware to base your design on is one of the most important design decisions for an embedded product. Depending on your product needs, you will decide to either:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use a production-ready board, like a <a id="id60" class="indexterm"/><span class="strong"><strong>single-board computer</strong></span> (<span class="strong"><strong>SBC</strong></span>)</li><li class="listitem" style="list-style-type: disc">Use a module and build your custom carrier board around it</li><li class="listitem" style="list-style-type: disc">Use Freescale's SoC directly and design your own board</li></ul></div><p>Most of the times, a production-ready board will not match the specific requirements of an professional embedded system, and the process of designing a complete carrier board using Freescale's SoC would be too time consuming. So, using an appropriate module that already solves the most technically challenging design aspects is a common choice.</p><p>Some of the characteristics that are important to consider are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Industrial temperature ranges</li><li class="listitem" style="list-style-type: disc">Power management</li><li class="listitem" style="list-style-type: disc">Long-term availability</li><li class="listitem" style="list-style-type: disc">Precertified wireless and Bluetooth (if applicable)</li></ul></div><p>The Yocto <a id="id61" class="indexterm"/>community layers that support Freescale-based boards are called <code class="literal">meta-fsl-arm</code> and <code class="literal">meta-fsl-arm-extras</code>. The selection of boards that are supported on <code class="literal">meta-fsl-arm</code> is limited to Freescale reference designs, which would be the starting point if you are considering designing your own carrier board around Freescale's SoC. Boards from other vendors are maintained on the <code class="literal">meta-fsl-arm-extras</code> layer.</p><p>There are other embedded manufacturers that use <code class="literal">meta-fsl-arm</code>, but they have not integrated their boards in the <code class="literal">meta-fsl-arm-extras</code> community layer. These manufacturers will keep their own BSP layers, which depend on <code class="literal">meta-fsl-arm</code>, with specific support for their hardware. An example of this is Digi International and its ConnectCore 6 module, which is based on the i.MX6 SoC.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>How it works...</h2></div></div></div><p>To understand Freescale Yocto ecosystem, we need to start with the Freescale community BSP, comprising the <code class="literal">meta-fsl-arm</code> layer with support for Freescale reference boards, and its companion, <code class="literal">meta-fsl-arm-extra</code>, with support for boards from other vendors, and its differences with the official Freescale Yocto releases that Freescale offers for their reference designs.</p><p>There are some key differences<a id="id62" class="indexterm"/> between the community and Freescale Yocto releases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Freescale releases are developed internally by Freescale without community involvement and are used for BSP validation on Freescale reference boards.</li><li class="listitem" style="list-style-type: disc">Freescale releases go through an internal QA and validation test process, and they are maintained by Freescale support.</li><li class="listitem" style="list-style-type: disc">Freescale releases for a specific platform reach a maturity point, after which they are no longer worked on. At this point, all the development work has been integrated into the community layer and the platforms are further maintained by the Freescale BSP community.</li><li class="listitem" style="list-style-type: disc">Freescale Yocto releases are not Yocto compatible, while the community release is.</li></ul></div><p>Freescale's<a id="id63" class="indexterm"/> engineering works very closely with the Freescale BSP community to make sure that all development in their official releases is integrated in the community layer in a reliable and quick manner.</p><p>Usually, the best option is to use the Freescale BSP community release but stay with the U-Boot and Linux kernel versions that were released as part of the manufacturer's stable BSP release.</p><p>This effectively means that you get the latest updates to the Linux kernel and U-Boot from the manufacturer while simultaneously getting the latest updates to the root filesystem from the community, extending the lifetime of your product, and making sure you are up to date with applications, bug fixes, and security updates.</p><p>This takes advantage of the manufacturer's QA process for the system components that are closer to the hardware, and makes it possible to use the manufacturer's support while simultaneously getting user space updates from the community. The Freescale BSP community is also very responsive and active, so problems can usually be worked on with them to benefit all parts.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>There's more...</h2></div></div></div><p>The Freescale BSP community extends Poky with the following layers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">meta-fsl-arm</code>: This is the <a id="id64" class="indexterm"/>community layer that supports Freescale reference designs. It has a dependency on OpenEmbedded-Core. Machines in this layer will be maintained even after Freescale stops active development on them. You can download <code class="literal">meta-fsl-arm</code> from its Git repository at <a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi/meta-fsl-arm/">http://git.yoctoproject.org/cgit/cgit.cgi/meta-fsl-arm/</a>.<p>Development discussions can be followed and contributed to by visiting the development mailing list at <a class="ulink" href="https://lists.yoctoproject.org/listinfo/meta-freescale">https://lists.yoctoproject.org/listinfo/meta-freescale</a>.</p><p>The <code class="literal">meta-fsl-arm</code> layer<a id="id65" class="indexterm"/> pulls both the Linux kernel and the U-Boot source from Freescale's repositories using the following links:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Freescale Linux kernel Git </strong></span><a id="id66" class="indexterm"/><span class="strong"><strong>repository</strong></span>: <a class="ulink" href="http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/">http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Freescale </strong></span><a id="id67" class="indexterm"/><span class="strong"><strong>U-Boot Git repository</strong></span>: <a class="ulink" href="http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/">http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/</a></li></ul></div><p>Other Linux kernel and U-Boot versions are available, but keeping the manufacturer's supported version is recommended.</p><p>The <code class="literal">meta-fsl-arm</code> layer includes Freescale's proprietary binaries to enable some hardware features – most notably its hardware graphics, multimedia, and encryption capabilities. To make use of these capabilities, the end user needs to accept Freescale's<a id="id68" class="indexterm"/> <span class="strong"><strong>End-User License Agreement</strong></span> (<span class="strong"><strong>EULA</strong></span>), which is included in the <code class="literal">meta-fsl-arm</code> layer. To accept the license, the following line needs to be added to the project's <code class="literal">conf/local.conf</code> configuration file:</p><div class="informalexample"><pre class="programlisting">ACCEPT_FSL_EULA = "1"</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">meta-fsl-arm-extra</code>: This layer <a id="id69" class="indexterm"/>adds support for other community-maintained boards; for example, the Wandboard. To <a id="id70" class="indexterm"/>download the layer's content, you may visit <a class="ulink" href="https://github.com/Freescale/meta-fsl-arm-extra/">https://github.com/Freescale/meta-fsl-arm-extra/</a>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">meta-fsl-demos</code>: This layer <a id="id71" class="indexterm"/>adds a metadata layer for demonstration target images. To download the layer's <a id="id72" class="indexterm"/>content, you may visit <a class="ulink" href="https://github.com/Freescale/meta-fsl-demos">https://github.com/Freescale/meta-fsl-demos</a>.</li></ul></div><p>Freescale uses another layer on top of the layers above for their official software releases: <code class="literal">meta-fsl-bsp-release</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">meta-fsl-bsp-release</code>: This is a Freescale-maintained layer that is used in the official Freescale software releases. It contains modifications to both <code class="literal">meta-fsl-arm</code> and <code class="literal">meta-fsl-demos</code>. It is not part of the community release.</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information, refer to the <a id="id73" class="indexterm"/>FSL community BSP release notes available at <a class="ulink" href="http://freescale.github.io/doc/release-notes/1.7/">http://freescale.github.io/doc/release-notes/1.7/</a></li></ul></div></div></div>
<div class="section" title="Installing support for Freescale hardware"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Installing support for Freescale hardware</h1></div></div></div><p>In this recipe, we will install <a id="id74" class="indexterm"/>the community Freescale BSP Yocto<a id="id75" class="indexterm"/> release that adds support for Freescale hardware to our Yocto installation.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>Getting ready</h2></div></div></div><p>With so many layers, manually cloning each of them and adding them to your project's <code class="literal">conf/bblayers.conf</code> file is cumbersome. The community is using the <code class="literal">repo</code> tool developed by Google for their community Android to ease the installation of Yocto.</p><p>To install <code class="literal">repo</code> in your host system, type in the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo curl http://commondatastorage.googleapis.com/git-repo- downloads/repo &gt; /usr/local/sbin/repo</strong></span>
<span class="strong"><strong>$ sudo chmod a+x /usr/local/sbin/repo</strong></span>
</pre></div><p>The <code class="literal">repo</code> tool is a Python utility that parses an XML file, called <code class="literal">manifest</code>, with a list of Git repositories. The <code class="literal">repo</code> tool is then used to manage those repositories as a whole.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>How to do it...</h2></div></div></div><p>For example, we will use <code class="literal">repo</code> to download all the repositories listed in the previous recipe to our host system. For that, we will point it to the Freescale community BSP <code class="literal">manifest</code> for the Dizzy release:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;manifest&gt;
  &lt;default sync-j="4" revision="master"/&gt;
  &lt;remote fetch="git://git.yoctoproject.org" name="yocto"/&gt;
  &lt;remote fetch="git://github.com/Freescale" name="freescale"/&gt;
  &lt;remote fetch="git://git.openembedded.org" name="oe"/&gt;
  &lt;project remote="yocto" revision="dizzy" name="poky" path="sources/poky"/&gt;
  &lt;project remote="yocto" revision="dizzy" name="meta-fsl-arm" path="sources/meta-fsl-arm"/&gt;
  &lt;project remote="oe" revision="dizzy" name="meta-openembedded" path="sources/meta-openembedded"/&gt;
  &lt;project remote="freescale" revision="dizzy" name="fsl- community-bsp-base" path="sources/base"&gt;
        &lt;copyfile dest="README" src="README"/&gt;
        &lt;copyfile dest="setup-environment" src="setup- environment"/&gt;
  &lt;/project&gt;
  &lt;project remote="freescale" revision="dizzy" name="meta-fsl-arm- extra" path="sources/meta-fsl-arm-extra"/&gt;
  &lt;project remote="freescale" revision="dizzy" name="meta-fsl- demos" path="sources/meta-fsl-demos"/&gt;
  &lt;project remote="freescale" revision="dizzy" name="Documentation" path="sources/Documentation"/&gt;
&lt;/manifest&gt;</pre></div><p>The <code class="literal">manifest</code> file <a id="id76" class="indexterm"/>shows all the installation paths and <a id="id77" class="indexterm"/>repository sources for the different components that are going to be installed.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec36"/>How it works...</h2></div></div></div><p>The <code class="literal">manifest</code> file is a list of the different layers that are needed for the Freescale community BSP release. We can now use <code class="literal">repo</code> to install it. Run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir /opt/yocto/fsl-community-bsp</strong></span>
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp</strong></span>
<span class="strong"><strong>$ repo init -u https://github.com/Freescale/fsl-community-bsp- platform -b dizzy</strong></span>
<span class="strong"><strong>$ repo sync</strong></span>
</pre></div><p>You can optionally pass a <code class="literal">-jN</code> argument to sync if you have a multicore machine for multithreaded operations; for example, you could pass <code class="literal">repo sync -j8</code> in an 8-core host system.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec37"/>There's more...</h2></div></div></div><p>To list the hardware boards supported by the different layers, we may run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls sources/meta-fsl*/conf/machine/*.conf</strong></span>
</pre></div><p>And to list the newly introduced target images, use the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls sources/meta-fsl*/recipes*/images/*.bb</strong></span>
</pre></div><p>The community Freescale BSP release<a id="id78" class="indexterm"/> introduces the following new target images:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fsl-image-mfgtool-initramfs</code>: This is a <a id="id79" class="indexterm"/>small, RAM-based <code class="literal">initramfs</code> image used with the Freescale manufacturing tool</li><li class="listitem" style="list-style-type: disc"><code class="literal">fsl-image-multimedia</code>: This is a<a id="id80" class="indexterm"/> console-only image that includes the <code class="literal">gstreamer</code> multimedia framework over the framebuffer, if applicable</li><li class="listitem" style="list-style-type: disc"><code class="literal">fsl-image-multimedia-full</code>: This is an <a id="id81" class="indexterm"/>extension of <code class="literal">fsl-image-multimedia</code>, but extends the <code class="literal">gstreamer</code> multimedia framework to include all available plugins</li><li class="listitem" style="list-style-type: disc"><code class="literal">fsl-image-machine-test</code>: This is an extension on <code class="literal">fsl-image-multimedia-full</code> for testing and <a id="id82" class="indexterm"/>benchmarking</li><li class="listitem" style="list-style-type: disc"><code class="literal">qte-in-use-image</code>: This is <a id="id83" class="indexterm"/>a graphical image that includes support for Qt4 over the framebuffer</li><li class="listitem" style="list-style-type: disc"><code class="literal">qt-in-use-image</code>: This is a<a id="id84" class="indexterm"/> graphical image that includes support for Qt4 over the X11 Windows system</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec38"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Instructions to use the <code class="literal">repo</code> tool, including using <code class="literal">repo</code> with proxy servers, can be found in the Android documentation<a id="id85" class="indexterm"/> at <a class="ulink" href="https://source.android.com/source/downloading.html">https://source.android.com/source/downloading.html</a></li></ul></div></div></div>
<div class="section" title="Building Wandboard images"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Building Wandboard images</h1></div></div></div><p>Building images for one of <a id="id86" class="indexterm"/>the supported boards (for example, <code class="literal">Wandboard Quad</code>) follows the same process we described earlier for the QEMU machines, with the exception of using the <code class="literal">setup-environment</code> script, which is a wrapper around <code class="literal">oe-init-build-env</code>.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec39"/>How to do it...</h2></div></div></div><p>To build an image for the <code class="literal">wandboard-quad</code> machine, use the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp</strong></span>
<span class="strong"><strong>$ mkdir -p wandboard-quad</strong></span>
<span class="strong"><strong>$ MACHINE=wandboard-quad source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake core-image-minimal</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>The current version of the <code class="literal">setup-environment</code> script only works if the <code class="literal">build</code> directory is under the installation folder; in our case, <code class="literal">/opt/yocto/fsl-community-bsp</code>.</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec40"/>How it works...</h2></div></div></div><p>The <code class="literal">setup-environment</code> script <a id="id87" class="indexterm"/>will create a <code class="literal">build</code> directory, set up the <code class="literal">MACHINE</code> variable, and prompt you to accept the Freescale EULA as described earlier. Your <code class="literal">conf/local.conf</code> configuration file will be updated both with the specified machine and the EULA acceptance variable.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Remember that if you close your terminal session, you will need to set up the environment again before being able to use BitBake. You can safely rerun the <code class="literal">setup-environment</code> script as seen previously, as it will not touch an existing <code class="literal">conf/local.conf</code> file. Run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
</pre></div></div></div><p>The resulting image, <code class="literal">core-image-minimal.sdcard</code>, which is created inside the <code class="literal">build</code> directory, can be programmed into a microSD card, inserted into the primary slot in the Wandboard CPU board, and booted using the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/wandboard- quad/tmp/deploy/images/wandboard-quad/</strong></span>
<span class="strong"><strong>$ sudo dd if=core-image-minimal.sdcard of=/dev/sdN bs=1M &amp;&amp; sync</strong></span>
</pre></div><p>Here, <code class="literal">/dev/sdN</code> corresponds to the device node assigned to the microSD card in your host system.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>Be careful when running the <code class="literal">dd</code> command, as it could harm your machine. You need to be absolutely sure that the <span class="emphasis"><em>sdN</em></span> device corresponds to your microSD card and not a drive on your development machine.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec41"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can find more information regarding the <code class="literal">repo</code> tool<a id="id88" class="indexterm"/> on Android's documentation at <a class="ulink" href="https://source.android.com/source/using-repo.html">https://source.android.com/source/using-repo.html</a></li></ul></div></div></div>
<div class="section" title="Troubleshooting your Wandboard's first boot"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Troubleshooting your Wandboard's first boot</h1></div></div></div><p>If you have problems booting your<a id="id89" class="indexterm"/> image, follow this recipe to troubleshoot.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec42"/>Getting ready</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Without the microSD card inserted, plug in a microUSB-to-USB cable to the USB OTG interface of your Wandboard. Check the <code class="literal">lsusb</code> utility on your Linux host to see whether the Wandboard appears as follows:<div class="informalexample"><pre class="programlisting">Bus 002 Device 006: ID 15a2:0054 Freescale Semiconductor, Inc. i.MX6Q SystemOnChip in RecoveryMode</pre></div><p>If you don't see this, try a different power supply. It should be 5V, 10W.</p></li><li class="listitem">Make sure you connect a NULL modem serial cable between the RS232 connector in your Wandboard target and a serial port on your Linux host. Then open a terminal program like minicom with the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ minicom -D /dev/ttyS0 -b 115200</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>You will need to add your user to the dialout group, or try to run the command as sudo. This should open a 115200 8N1 serial connection. The serial device may vary in your Linux host. For example, a USB-to-serial adapter may be detected as <code class="literal">/dev/ttyUSB0</code>. Also, make sure both hardware and software flow control are disabled.</p></div></div></li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec43"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Insert the microSD card image to the module slot, not the base board, as the latter is only used for storage and not for booting, and power it. You should see the U-Boot banner in the minicom session output.</li><li class="listitem">If not, you may have a problem with the serial communication. By default, the Ethernet interface in the FSL community BSP image is configured to request an address by DHCP, so you can use that to connect to the target.<p>Make sure you have a DHCP server running on the test network where the target is.</p><p>You can use a packet sniffer like <span class="strong"><strong>Wireshark</strong></span><a id="id90" class="indexterm"/> to capture a network trace on your Linux host and filter packages like the <code class="literal">bootp</code> protocol. At the least, you should see some broadcasts from your target, and if you use an Ethernet hub, you should also see the DHCP replies.</p><p>Optionally, you can log in to your DHCP server and check the logs to see if a new IP address has been assigned. If you see an IP address being assigned, you might want to consider adding an SSH server, like <a id="id91" class="indexterm"/>
<span class="strong"><strong>Dropbear</strong></span>, to your core-image-minimal image so that you can establish a network connection with the target. You can do this by adding the following line to the <code class="literal">conf/local.conf</code> configuration file:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " dropbear"</pre></div><p>Note the space after the initial quote.</p><p>After building and reprogramming, you can then start an SSH session to the Wandboard from your Linux host with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ssh root@&lt;ip_address&gt;</strong></span>
</pre></div><p>The connection should automatically log in without a password prompt.</p></li><li class="listitem">Try to program the <a id="id92" class="indexterm"/>default microSD card images from <a class="ulink" href="http://www.wandboard.org/index.php/downloads">http://www.wandboard.org/index.php/downloads</a> to <a id="id93" class="indexterm"/>make sure the hardware and your setup is valid.</li><li class="listitem">Try to reprogram your microSD card. Make sure you are using the correct images for your board (for example, do not mix dual and quad images). Also, try different cards and card readers.</li></ol></div><p>These steps will have your Wandboard start booting, and you should have some output in your serial connection.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec44"/>There's more...</h2></div></div></div><p>If everything else fails, you can verify the position of the bootloader on your microSD card. You can dump the contents of the first blocks of your microSD card with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo dd if=/dev/sdN of=/tmp/sdcard.img count=10</strong></span>
</pre></div><p>You should see a U-Boot header at offset 0x400. That's the offset where the i.MX6 boot ROM will be looking for the bootloader when bootstrapped to boot from the microSD interface. Use the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ head /tmp/sdcard.img | hexdump</strong></span>
<span class="strong"><strong>0000400 00d1 4020 0000 1780 0000 0000 f42c 177f</strong></span>
</pre></div><p>You can recognize the <a id="id94" class="indexterm"/>U-Boot header by dumping the U-Boot image from your build. Run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ head u-boot-wandboard-quad.imx | hexdump</strong></span>
<span class="strong"><strong>0000000 00d1 4020 0000 1780 0000 0000 f42c 177f</strong></span>
</pre></div></div></div>
<div class="section" title="Configuring network booting for a development setup"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Configuring network booting for a development setup</h1></div></div></div><p>Most professional i.MX6 boards will have an internal <span class="strong"><strong>embedded MMC</strong></span> (<span class="strong"><strong>eMMC</strong></span>)<a id="id95" class="indexterm"/> flash memory, and that would be the recommended way to boot firmware. The Wandboard is not really a product meant for professional use, so it does not have one. But neither the eMMC nor the microSD card are ideal for development work, as any system change would involve a reprogramming of the firmware image.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec45"/>Getting ready</h2></div></div></div><p>The ideal setup for <a id="id96" class="indexterm"/>development work is to use<a id="id97" class="indexterm"/> both TFTP and NFS servers in your host system and to only store the U-Boot bootloader in either the eMMC or a microSD card. With this setup, the bootloader will fetch the Linux kernel from the TFTP server and the kernel will mount the root filesystem from the NFS server. Changes to either the kernel or the root filesystem are available without the need to reprogram. Only bootloader development work would need you to reprogram the physical media.</p><div class="section" title="Installing a TFTP server"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Installing a TFTP server</h3></div></div></div><p>If you are not already running a <a id="id98" class="indexterm"/>TFTP server, follow the next steps to install and configure a TFTP server on your Ubuntu 14.04 host:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install tftpd-hpa</strong></span>
</pre></div><p>The <code class="literal">tftpd-hpa</code> configuration file is installed in <code class="literal">/etc/default/tftpd-hpa</code>. By default, it uses <code class="literal">/var/lib/tftpboot</code> as the root <code class="literal">TFTP</code> folder. Change the folder permissions to make it accessible to all users <a id="id99" class="indexterm"/>using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo chmod 1777 /var/lib/tftpboot</strong></span>
</pre></div><p>Now copy the Linux kernel and device tree from your <code class="literal">build</code> directory as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/wandboard- quad/tmp/deploy/images/wandboard-quad/</strong></span>
<span class="strong"><strong>$ cp zImage-wandboard-quad.bin zImage-imx6q-wandboard.dtb /var/lib/tftpboot</strong></span>
</pre></div></div><div class="section" title="Installing an NFS server"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Installing an NFS server</h3></div></div></div><p>If you are not already running an <a id="id100" class="indexterm"/>NFS server, follow the next steps to install and configure one on your Ubuntu 14.04 host:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install nfs-kernel-server</strong></span>
</pre></div><p>We will use the <code class="literal">/nfsroot</code> directory as the root for the NFS server, so we will "untar" the target's root filesystem from our Yocto <code class="literal">build</code> directory in there:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo mkdir /nfsroot</strong></span>
<span class="strong"><strong>$ cd /nfsroot</strong></span>
<span class="strong"><strong>$ sudo tar xvf /opt/yocto/fsl-community-bsp/wandboard- quad/tmp/deploy/images/wandboard-quad/core-image-minimal-wandboard- quad.tar.bz2</strong></span>
</pre></div><p>Next, we will configure the NFS server to export the <code class="literal">/nfsroot</code> folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/etc/exports:</strong></span>
<span class="strong"><strong>/nfsroot/ *(rw,no_root_squash,async,no_subtree_check)</strong></span>
</pre></div><p>We will then restart the NFS server for the configuration changes to take effect:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo service nfs-kernel-server restart</strong></span>
</pre></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec46"/>How to do it...</h2></div></div></div><p>Boot the Wandboard and <a id="id101" class="indexterm"/>stop at the U-Boot prompt <a id="id102" class="indexterm"/>by pressing any key on the serial console. Then run through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Get an IP address by DHCP:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; dhcp</strong></span>
</pre></div><p>Alternatively, you can configure a static IP address with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; setenv ipaddr &lt;static_ip&gt;</strong></span>
</pre></div></li><li class="listitem">Configure the IP address of your host system, where the TFTP and NFS servers have been set up:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; setenv serverip &lt;host_ip&gt;</strong></span>
</pre></div></li><li class="listitem">Configure the root filesystem mount:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; setenv nfsroot /nfsroot</strong></span>
</pre></div></li><li class="listitem">Configure the Linux kernel and device tree filenames:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; setenv image zImage-wandboard-quad.bin</strong></span>
<span class="strong"><strong>&gt; setenv fdt_file zImage-imx6q-wandboard.dtb</strong></span>
</pre></div></li><li class="listitem">If you have configured a static IP address, you need to disable DHCP on boot by running:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; setenv ip_dyn no</strong></span>
</pre></div></li><li class="listitem">Save the U-Boot environment to the microSD card:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; saveenv</strong></span>
</pre></div></li><li class="listitem">Perform a network boot:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; run netboot</strong></span>
</pre></div></li></ol></div><p>The Linux kernel <a id="id103" class="indexterm"/>and device tree will be <a id="id104" class="indexterm"/>fetched from the TFTP server, and the root filesystem will be mounted by the kernel from the NFS share after getting a DHCP address from your network (unless using static IP addresses).</p><p>You should be able to log in with the root user without a password prompt.</p></div></div>
<div class="section" title="Sharing downloads"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Sharing downloads</h1></div></div></div><p>You will usually work on several projects<a id="id105" class="indexterm"/> simultaneously, probably for different hardware platforms or different target images. In such cases, it is important to optimize the build times by sharing <code class="literal">downloads</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec47"/>Getting ready</h2></div></div></div><p>The build system runs a search for downloaded sources in a number of places:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It tries the local <code class="literal">downloads</code> folder.</li><li class="listitem" style="list-style-type: disc">It looks into the configured premirrors, which are usually local to your organization.</li><li class="listitem" style="list-style-type: disc">It then tries to fetch from the upstream source as configured in the package recipe.</li><li class="listitem" style="list-style-type: disc">Finally, it checks the configured mirrors. Mirrors are public alternate locations for the source.</li></ul></div><p>If a package source is not found in any of the these four, the package build will fail with an error. Build warnings are also issued when upstream fetching fails and mirrors are tried, so that the upstream problem can be looked at.</p><p>The Yocto project maintains a set of mirrors to isolate the build system from problems with the upstream servers. However, when adding external layers, you could be adding support for packages that are not in the Yocto project's mirror servers, or other configured mirrors, so it is recommended that you keep a local premirror to avoid problems with source availability.</p><p>The default Poky setting for a new project is to store the downloaded package sources on the current <code class="literal">build</code> directory. This is the first place the build system will run a search for source <code class="literal">downloads</code>. This setting can be configured in your project's <code class="literal">conf/local.conf</code> file with the <code class="literal">DL_DIR</code> configuration variable.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec48"/>How to do it...</h2></div></div></div><p>To optimize the<a id="id106" class="indexterm"/> build time, it is recommended to keep a shared <code class="literal">downloads</code> directory between all your projects. The <code class="literal">setup-environment</code> script of the <code class="literal">meta-fsl-arm</code> layer changes the default <code class="literal">DL_DIR</code> to the <code class="literal">fsl-community-bsp</code> directory created by the <code class="literal">repo</code> tool. With this setup, the <code class="literal">downloads</code> folder will already be shared between all the projects in your host system. It is configured as:</p><div class="informalexample"><pre class="programlisting">DL_DIR ?= "${BSPDIR}/downloads/"</pre></div><p>A more scalable setup (for instance, for teams that are remotely distributed) is to configure a premirror. For example, adding the following to your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">INHERIT += "own-mirrors"
SOURCE_MIRROR_URL = "http://example.com/my-source-mirror"</pre></div><p>A usual setup is to have a build server serve its <code class="literal">downloads</code> directory. The build server can be configured to prepare tarballs of the Git directories to avoid having to perform Git operations from upstream servers. This setting in your <code class="literal">conf/local.conf</code> file will affect the build performance, but this is usually acceptable in a build server. Add the following:</p><div class="informalexample"><pre class="programlisting">BB_GENERATE_MIRROR_TARBALLS = "1"</pre></div><p>An advantage of this setup is that the build server's <code class="literal">downloads</code> folder can also be backed up to guarantee source availability for your products in the future. This is especially important in embedded products with long-term availability requirements.</p><p>In order to test this setup, you may check to see whether a build is possible just by using the premirrors with the following:</p><div class="informalexample"><pre class="programlisting">BB_FETCH_PREMIRRORONLY = "1"</pre></div><p>This setting in your <code class="literal">conf/local.conf</code> file can also be distributed across the team with the <code class="literal">TEMPLATECONF</code> variable during the project's creation.</p></div></div>
<div class="section" title="Sharing the shared state cache"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Sharing the shared state cache</h1></div></div></div><p>The Yocto project builds <a id="id107" class="indexterm"/>everything from source. When you create a new project, only the configuration files are created. The build process then compiles everything from scratch, including the cross-compilation toolchain and some native tools important for the build.</p><p>This process can take a long time, and the Yocto project implements a shared state cache mechanism that is used for incremental builds with the aim to build only the strictly necessary components for a given change.</p><p>For this to work, the build system calculates a checksum of the given input data to a task. If the input data changes, the task needs to be rebuilt. In simplistic terms, the build process generates a run script for each task that can be checksummed and compared. It also keeps track of a task's output, so that it can be reused.</p><p>A package recipe can modify the shared state caching to a task; for example, to always force a rebuild by marking it as <code class="literal">nostamp</code>. A more in-depth explanation of the shared state cache mechanism can be found in <a id="id108" class="indexterm"/>the <span class="emphasis"><em>Yocto Project Reference Manual</em></span> at <a class="ulink" href="http://www.yoctoproject.org/docs/1.7.1/ref-manual/ref-manual.html">http://www.yoctoproject.org/docs/1.7.1/ref-manual/ref-manual.html</a>.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec49"/>How to do it...</h2></div></div></div><p>By default, the build system will use a shared state cache directory called <code class="literal">sstate-cache</code> on your <code class="literal">build</code> directory to store the cached data. This can be changed with the <code class="literal">SSTATE_DIR</code> configuration variable in your <code class="literal">conf/local.conf</code> file. The cached data is stored in directories named with the first two characters of the hash. Inside, the filenames contain the whole task checksum, so the cache validity can be ascertained just by looking at the filename. The build process set scene tasks will evaluate the cached data and use it to accelerate the build if valid.</p><p>When you want to start a build from a clean state, you need to remove both the <code class="literal">sstate-cache</code> directory and the <code class="literal">tmp</code> directory.</p><p>You can also instruct BitBake to ignore the shared state cache by using the <code class="literal">--no-setscene</code> argument when running it.</p><p>It's a good practice to keep backups of clean shared state caches (for example, from a build server), which can be used in case of shared state cache corruption.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec50"/>There's more...</h2></div></div></div><p>Sharing a shared state cache is possible; however, it needs to be approached with care. Not all changes are detected by the shared state cache implementation, and when this happens, some or all of the cache needs to be invalidated. This can cause problems when the state cache is being shared.</p><p>The recommendation in this case depends on the use case. Developers working on Yocto metadata should keep the shared state cache as default, separated per project.</p><p>However, validation and testing engineers, kernel and bootloader developers, and application developers would probably benefit from a well-maintained shared state cache.</p><p>To configure an NFS share drive to be shared among the development team to speed up the builds, you can add the following to your <code class="literal">conf/local.conf</code> configuration file:</p><div class="informalexample"><pre class="programlisting">SSTATE_MIRRORS ?= "\
     file://.* file:///nfs/local/mount/sstate/PATH"</pre></div><p>The expression <code class="literal">PATH</code> in this<a id="id109" class="indexterm"/> example will get substituted by the build system with a directory named with the hash's first two characters.</p></div></div>
<div class="section" title="Setting up a package feed"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Setting up a package feed</h1></div></div></div><p>An embedded system project seldom<a id="id110" class="indexterm"/> has the need to introduce changes to the Yocto build system. Most of the time and effort is spent in application development, followed by a lesser amount in maybe kernel and bootloader development.</p><p>As such, a whole system rebuild is probably done very few times. A new project is usually built from a prebuilt shared state cache, and application development work only needs to be done to perform full or incremental builds of a handful of packages.</p><p>Once the packages are built, they need to be installed on the target system for testing. Emulated machines are fine for application development, but most hardware-related work needs to be done on embedded hardware.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec51"/>Getting ready</h2></div></div></div><p>An option is to manually copy the build binaries to the target's root filesystem, either copying it to the NFS share on the host system the target is mounting its root filesystem from (as explained in the <span class="emphasis"><em>Configuring network booting for a development setup</em></span> recipe earlier) or using any other method like SCP, FTP, or even a microSD card.</p><p>This method is also used by IDEs<a id="id111" class="indexterm"/> like Eclipse when debugging an application you are working on. However, this method does not scale well when you need to install several packages and dependencies.</p><p>The next option would be to copy the packaged binaries (that is, the RPM, deb, or ipk packages) to the target's filesystem and then use the target's package management system to install them. For this to work, your target's filesystem needs to be built with package management tools. Doing this is as easy as adding the <code class="literal">package-management</code> feature to your root filesystem; for example, you may add the following line to your project's <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">EXTRA_IMAGE_FEATURES += "package-management"</pre></div><p>So for an RPM package, you will copy it to the target and use the <span class="strong"><strong>rpm</strong></span> or <span class="strong"><strong>smart</strong></span> utilities<a id="id112" class="indexterm"/> to install it. The smart package management tool is GPL licensed and can work with a variety of package formats.</p><p>However, the most optimized way to do this is to convert your host system package's output directory into a package feed. For example, if you are using the default RPM package format, you may convert <code class="literal">tmp/deploy/rpm</code> in your <code class="literal">build</code> directory into a package feed that your target can use to update.</p><p>For this to work, you <a id="id113" class="indexterm"/>need to configure an HTTP server on your computer that serves the packages.</p><div class="section" title="Versioning packages"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Versioning packages</h3></div></div></div><p>You also need to make sure that the<a id="id114" class="indexterm"/> generated packages are correctly versioned, and that means updating the recipe <a id="id115" class="indexterm"/>revision, <span class="strong"><strong>PR</strong></span>, with every change. It is possible to do this manually, but the recommended—and compulsory way if you want to use package feeds—is to use a PR server.</p><p>However, the PR server is not enabled by default. The packages generated without a PR server are consistent with each other but offer no update guarantees for a system that is already running.</p><p>The simplest PR server configuration is to run it locally on your host system. To do this, you add the following to your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">PRSERV_HOST = "localhost:0"</pre></div><p>With this setup, update coherency is guaranteed for your feed.</p><p>If you want to share your feed with other developers, or you are configuring a build server or package server, you would run a single instance of the PR server by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake-prserv --host &lt;server_ip&gt; --port &lt;port&gt; --start</strong></span>
</pre></div><p>And you will update the project's build configuration to use the centralized PR server, editing <code class="literal">conf/local.conf</code> as follows:</p><div class="informalexample"><pre class="programlisting">PRSERV_HOST = "&lt;server_ip&gt;:&lt;port&gt;"</pre></div><p>Also, if you are using a shared state cache as described before, all of the contributors to the shared state cache need to use the same PR server.</p><p>Once the feed's integrity is <a id="id116" class="indexterm"/>guaranteed, we need to configure an HTTP server to serve the feed.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec52"/>How to do it...</h2></div></div></div><p>We will use <code class="literal">lighttpd</code><a id="id117" class="indexterm"/> for this <a id="id118" class="indexterm"/>example, as it is lightweight and easy to configure. Follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the web server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install lighttpd</strong></span>
</pre></div></li><li class="listitem">By default, the document root specified in the <code class="literal">/etc/lighttpd/lighttpd.conf</code> configuration file is <code class="literal">/var/www/</code>, so we only need a symlink to our package feed:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo mkdir /var/www/wandboard-quad</strong></span>
<span class="strong"><strong>$ sudo ln -s /opt/yocto/fsl-community-bsp/wandboard- quad/tmp/deploy/rpm /var/www/wandboard-quad/rpm</strong></span>
</pre></div><p>Next, reload the configuration as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo service lighttpd reload</strong></span>
</pre></div></li><li class="listitem">Refresh the package index. This needs to be done manually to update the package feed after every build:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake package-index</strong></span>
</pre></div></li><li class="listitem">Then we need to configure our target filesystem with the new package feeds:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># smart channel --add all type=rpm-md \ baseurl=http://&lt;server_ip&gt;/wandboard-quad/rpm/all</strong></span>

<span class="strong"><strong># smart channel --add wandboard_quad type=rpm-md \ baseurl=http://&lt;server_ip&gt;/wandboard-quad/rpm/wandboard_quad</strong></span>

<span class="strong"><strong># smart channel --add cortexa9hf_vfp_neon type=rpm-md \ baseurl=http://&lt;server_ip&gt;/wandboard- quad/rpm/cortexa9hf_vfp_neon</strong></span>
</pre></div></li><li class="listitem">Once the setup is ready, we will be able to query and update packages from the target's root filesystem with the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># smart update</strong></span>
<span class="strong"><strong># smart query &lt;package_name&gt;</strong></span>
<span class="strong"><strong># smart install &lt;package_name&gt;</strong></span>
</pre></div></li></ol></div><p>To make this change persistent in the target's root filesystem, we can configure the package feeds at compilation time by using the <code class="literal">PACKAGE_FEED_URIS</code> variable in <code class="literal">conf/local.conf</code> as<a id="id119" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">PACKAGE_FEED_URIS = "http://&lt;server_ip&gt;/wandboard-quad"</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec53"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More information and a <a id="id120" class="indexterm"/>user manual for the smart utility can be found at <a class="ulink" href="https://labix.org/smart/">https://labix.org/smart/</a></li></ul></div></div></div>
<div class="section" title="Using build history"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec22"/>Using build history</h1></div></div></div><p>When maintaining software for an <a id="id121" class="indexterm"/>embedded product, you need a way to know what has changed and how it is going to affect your product.</p><p>On a Yocto system, you may need to update a package revision (for instance, to fix a security vulnerability), and you need to make sure what the implications of this change are; for example, in terms of package dependencies and changes to the root filesystem.</p><p>Build history enables you to do just that, and we will explore it in this recipe.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec54"/>How to do it...</h2></div></div></div><p>To enable build history, add the following to your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">INHERIT += "buildhistory"</pre></div><p>The following enables information gathering, including dependency graphs:</p><div class="informalexample"><pre class="programlisting">BUILDHISTORY_COMMIT = "1"</pre></div><p>The preceding line of code enables the storage of build history in a local Git repository.</p><p>The Git repository location can be set by the <code class="literal">BUILDHISTORY_DIR</code> variable, which by default is set to a <code class="literal">buildhistory</code> directory on your <code class="literal">build</code> directory.</p><p>By default, <code class="literal">buildhistory</code> tracks changes to packages, images, and SDKs. This is configurable using the <code class="literal">BUILDHISTORY_FEATURES</code> variable. For example, to track only image changes, add the following to your <code class="literal">conf/local.conf</code>:</p><div class="informalexample"><pre class="programlisting">BUILDHISTORY_FEATURES = "image"</pre></div><p>It can also track specific files and copy them to the <code class="literal">buildhistory</code> directory. By default, this includes only <code class="literal">/etc/passwd</code> and <code class="literal">/etc/groups</code>, but it can be used to track any important files like security certificates. The files need to be added with the <code class="literal">BUILDHISTORY_IMAGE_FILES</code> variable in your <code class="literal">conf/local.conf</code> file as follows:</p><div class="informalexample"><pre class="programlisting">BUILDHISTORY_IMAGE_FILES += "/path/to/file"</pre></div><p>Build history will slow down the build, increase the build size, and may also grow the Git directory to an unmanageable size. The recommendation is to enable it on a build server for software releases, or in specific cases, such as when updating production software.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec55"/>How it works...</h2></div></div></div><p>When enabled, it will keep a record of the changes to each package and image in the form of a Git repository in a way that can be explored and analyzed.</p><p>For a package, it records the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Package and recipe revision</li><li class="listitem" style="list-style-type: disc">Dependencies</li><li class="listitem" style="list-style-type: disc">Package size</li><li class="listitem" style="list-style-type: disc">Files</li></ul></div><p>For an image, it records the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build configuration</li><li class="listitem" style="list-style-type: disc">Dependency graphs</li><li class="listitem" style="list-style-type: disc">A list of files that includes ownership and permissions</li><li class="listitem" style="list-style-type: disc">List of installed packages</li></ul></div><p>And for an SDK, it <a id="id122" class="indexterm"/>records the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SDK configuration</li><li class="listitem" style="list-style-type: disc">List of both host and target files, including ownership and permissions</li><li class="listitem" style="list-style-type: disc">Dependency graphs</li><li class="listitem" style="list-style-type: disc">A list of installed packages</li></ul></div><div class="section" title="Looking at the build history"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Looking at the build history</h3></div></div></div><p>Inspecting the <a id="id123" class="indexterm"/>Git directory <a id="id124" class="indexterm"/>with the build history can be done in several ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using Git tools like gitk or git log.</li><li class="listitem" style="list-style-type: disc">Using the <a id="id125" class="indexterm"/><span class="strong"><strong>buildhistory-diff</strong></span> command-line tool, which displays the differences in a human-readable format.</li><li class="listitem" style="list-style-type: disc">Using a Django-1.4-based web interface. You will need to import the build history data to the application's database after every build. The details are available at <a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi/buildhistory-web/tree/README">http://git.yoctoproject.org/cgit/cgit.cgi/buildhistory-web/tree/README</a>.</li></ul></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec56"/>There's more...</h2></div></div></div><p>To maintain the <a id="id126" class="indexterm"/>build history, it's important to optimize it and avoid it from growing over time. Periodic backups of the build history and clean-ups of older data are important to keep the build history repository at a manageable size.</p><p>Once the <code class="literal">buildhistory</code> directory has been backed up, the following process will trim it and keep only the most recent history:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy your repository to a temporary RAM filesystem (<code class="literal">tmpfs</code>) to speed things up. Check the output of the <code class="literal">df -h</code> command to see which directories are <code class="literal">tmpfs</code> filesystems and how much space they have available, and use one. For example, in Ubuntu, the <code class="literal">/run/shm</code> directory is available.</li><li class="listitem">Add a graft point for a commit one month ago with no parents:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git rev-parse "HEAD@{1 month ago}" &gt; .git/info/grafts</strong></span>
</pre></div></li><li class="listitem">Make the graft point permanent:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git filter-branch</strong></span>
</pre></div></li><li class="listitem">Clone a new repository to clean up the remaining Git objects:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git clone file://${tmpfs}/buildhistory buildhistory.new</strong></span>
</pre></div></li><li class="listitem">Replace the old <code class="literal">buildhistory</code> directory with the new cleaned one:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ rm -rf buildhistory</strong></span>
<span class="strong"><strong>$ mv buildhistory.new buildhistory</strong></span>
</pre></div></li></ol></div></div></div>
<div class="section" title="Working with build statistics"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec23"/>Working with build statistics</h1></div></div></div><p>The build system can collect build <a id="id127" class="indexterm"/>information per task and image. The data may be used to identify areas of optimization of build times and bottlenecks, especially when new recipes are added to the system. This recipe will explain how the build statistics work.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec57"/>How to do it...</h2></div></div></div><p>To enable the collection of statistics, your project needs to inherit the <code class="literal">buildstats</code> class by adding it to <code class="literal">USER_CLASSES</code> in your <code class="literal">conf/local.conf</code> file. By default, the <code class="literal">fsl-community-bsp</code> build project is configured to enable them.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>USER_CLASSES ?= "buildstats"</strong></span>
</pre></div><p>You can configure the location of these statistics with the <code class="literal">BUILDSTATS_BASE</code> variable, and by default it is set to the <code class="literal">buildstats</code> folder in the <code class="literal">tmp</code> directory under the <code class="literal">build</code> directory (<code class="literal">tmp/buildstats</code>).</p><p>The <code class="literal">buildstats</code> folder contains a folder per image with the build stats under a <code class="literal">timestamp</code> folder. Under it will be a subdirectory per package in your built image, and a <code class="literal">build_stats</code> file that contains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Host system information</li><li class="listitem" style="list-style-type: disc">Root filesystem location and size</li><li class="listitem" style="list-style-type: disc">Build time</li><li class="listitem" style="list-style-type: disc">Average CPU usage</li><li class="listitem" style="list-style-type: disc">Disk statistics</li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec58"/>How it works...</h2></div></div></div><p>The accuracy of the data <a id="id128" class="indexterm"/>depends on the download directory, <code class="literal">DL_DIR</code>, and the shared state cache directory, <code class="literal">SSTATE_DIR</code>, existing on the same partition or volume, so you may need to configure them accordingly if you are planning to use the build data.</p><p>An example <code class="literal">build-stats</code> file looks like the following:</p><div class="informalexample"><pre class="programlisting">Host Info: Linux agonzal 3.13.0-35-generic #62-Ubuntu SMP Fri Aug 15 01:58:42 UTC 2014 x86_64 x86_64
Build Started: 1411486841.52
Uncompressed Rootfs size: 6.2M  /opt/yocto/fsl-community- bsp/wandboard-quad/tmp/work/wandboard_quad-poky-linux- gnueabi/core-image-minimal/1.0-r0/rootfs
Elapsed time: 2878.26 seconds
CPU usage: 51.5%
EndIOinProgress: 0
EndReadsComp: 0
EndReadsMerged: 55289561
EndSectRead: 65147300
EndSectWrite: 250044353
EndTimeIO: 14415452
EndTimeReads: 10338443
EndTimeWrite: 750935284
EndWTimeIO: 816314180
EndWritesComp: 0
StartIOinProgress: 0
StartReadsComp: 0
StartReadsMerged: 52319544
StartSectRead: 59228240
StartSectWrite: 207536552
StartTimeIO: 13116200
StartTimeReads: 8831854
StartTimeWrite: 3861639688
StartWTimeIO: 3921064032
StartWritesComp: 0</pre></div><p>These disk statistics come from the <a id="id129" class="indexterm"/>Linux kernel disk I/O stats (<a class="ulink" href="https://www.kernel.org/doc/Documentation/iostats.txt">https://www.kernel.org/doc/Documentation/iostats.txt</a>). The different elements are explained here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ReadsComp</code>: This is the <a id="id130" class="indexterm"/>total number of reads completed</li><li class="listitem" style="list-style-type: disc"><code class="literal">ReadsMerged</code>: This is the total number of adjacent reads merged</li><li class="listitem" style="list-style-type: disc"><code class="literal">SectRead</code>: This is the total number of sectors read</li><li class="listitem" style="list-style-type: disc"><code class="literal">TimeReads</code>: This is the total number of milliseconds spent reading</li><li class="listitem" style="list-style-type: disc"><code class="literal">WritesComp</code>: This is the total number of writes completed</li><li class="listitem" style="list-style-type: disc"><code class="literal">SectWrite</code>: This is the total number of sectors written</li><li class="listitem" style="list-style-type: disc"><code class="literal">TimeWrite</code>: This is the total number of milliseconds spent writing</li></ul></div><p><code class="literal">IOinProgress</code>: This is the total number of I/Os in progress when reading <code class="literal">/proc/diskstats</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TimeIO</code>: This is the total number of milliseconds spent performing I/O</li><li class="listitem" style="list-style-type: disc"><code class="literal">WTimeIO</code>: This is the total number of weighted time while performing I/O</li></ul></div><p>And inside each package, we have a list of tasks; for example, for <code class="literal">ncurses-5.9-r15.1</code>, we have the following tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">do_compile</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_fetch</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_package</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_package_write_rpm</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_populate_lic</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_rm_work</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_configure</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_install</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_packagedata</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_patch</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_populate_sysroot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">do_unpack</code></li></ul></div><p>Each one of them contain, in the same format as earlier, the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build time</li><li class="listitem" style="list-style-type: disc">CPU usage</li><li class="listitem" style="list-style-type: disc">Disk stats</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec59"/>There's more...</h2></div></div></div><p>You can also obtain a<a id="id131" class="indexterm"/> graphical representation of the data using the <code class="literal">pybootchartgui.py</code> tool included in the Poky source. From your project's <code class="literal">build</code> folder, you can execute the following command to obtain a <code class="literal">bootchart.png</code> graphic in <code class="literal">/tmp</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ../sources/poky/scripts/pybootchartgui/pybootchartgui.py tmp/buildstats/core-image-minimal-wandboard-quad/ -o /tmp</strong></span>
</pre></div></div></div>
<div class="section" title="Debugging the build system"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec24"/>Debugging the build system</h1></div></div></div><p>In the last recipe of this chapter, we <a id="id132" class="indexterm"/>will explore the different methods available to debug problems with the build system and its metadata.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec60"/>Getting ready</h2></div></div></div><p>Let's first introduce some of the usual <a id="id133" class="indexterm"/>use cases on a debugging session.</p><div class="section" title="Finding recipes"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Finding recipes</h3></div></div></div><p>A good way to check whether a <a id="id134" class="indexterm"/>specific package is supported in your current layers is to search for it as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ find -name "*busybox*"</strong></span>
</pre></div><p>This will recursively search all layers for the BusyBox pattern. You can limit the search to recipes and append files by executing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ find -name "*busybox*.bb*"</strong></span>
</pre></div></div><div class="section" title="Dumping BitBake's environment"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Dumping BitBake's environment</h3></div></div></div><p>When developing or <a id="id135" class="indexterm"/>debugging package or image recipes, it is very common to ask BitBake to list its environment both globally and for a specific target, be it a package or image.</p><p>To dump the global environment and <code class="literal">grep</code> for a variable of interest (for example, <code class="literal">DISTRO_FEATURES</code>), use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -e | grep -w DISTRO_FEATURES</strong></span>
</pre></div><p>Optionally, to locate the source directory for a specific package recipe like BusyBox, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -e busybox | grep ^S=</strong></span>
</pre></div><p>You could also execute the <a id="id136" class="indexterm"/>following command to locate the working directory for a package or image recipe:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -e &lt;target&gt; | grep ^WORKDIR=</strong></span>
</pre></div></div><div class="section" title="Using the development shell"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Using the development shell</h3></div></div></div><p>BitBake offers the <code class="literal">devshell</code> task to <a id="id137" class="indexterm"/>help developers. It is executed with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c devshell &lt;target&gt;</strong></span>
</pre></div><p>It will unpack and patch the source, and open a new terminal (it will autodetect your terminal type or it can be set with <code class="literal">OE_TERMINAL</code>) in the target source directory, which has the environment correctly setup.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>While in a graphical environment, devshell opens a new terminal or console window, but if we are working on a non-graphical environment, like telnet or SSH, you may need to specify <code class="literal">screen</code> as your terminal in your <code class="literal">conf/local.conf</code> configuration file as follows:</p><div class="informalexample"><pre class="programlisting">OE_TERMINAL = "screen"</pre></div></div></div><p>Inside the devshell, you can run development commands like <code class="literal">configure</code> and <code class="literal">make</code> or invoke the cross-compiler directly (use the <code class="literal">$CC</code> environment variable, which has been set up already).</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec61"/>How to do it...</h2></div></div></div><p>The starting point for debugging a package build error is the BitBake error message printed on the build process. This will usually point us to the task that failed to build.</p><p>To list all the tasks available for a given recipe, with descriptions, we execute the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c listtasks &lt;target&gt;</strong></span>
</pre></div><p>If you need to recreate the error, you can force a build with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -f &lt;target&gt;</strong></span>
</pre></div><p>Or you can ask BitBake to force-run only a specific task using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c compile -f &lt;target&gt;</strong></span>
</pre></div><div class="section" title="Task log and run files"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Task log and run files</h3></div></div></div><p>To debug the build errors, BitBake creates<a id="id138" class="indexterm"/> two types of useful files per shell task and stores them in a <code class="literal">temp</code> folder in the working directory. Taking BusyBox as an example, we would look into:</p><div class="informalexample"><pre class="programlisting"> /opt/yocto/fsl-community-bsp/wandboard-quad/tmp/work/cortexa9hf- vfp-neon-poky-linux-gnueabi/busybox/1.22.1-r32/temp</pre></div><p>And find a list of log and run files. The filename format is</p><p><code class="literal">log.do_&lt;task&gt;.&lt;pid&gt;</code></p><p>and <code class="literal">run.do_&lt;task&gt;.&lt;pid&gt;</code>.</p><p>But luckily, we also have symbolic links, without the <code class="literal">pid</code> part, that link to the latest version.</p><p>The log files will contain the output of the task, and that is usually the only information we need to debug the problem. The run file contains the actual code executed by BitBake to generate the log mentioned before. This is only needed when debugging complex build issues.</p><p>Python tasks, on the other hand, do not currently write files as described previously, although it is planned to do so in the future. Python tasks execute internally and log information to the terminal.</p></div><div class="section" title="Adding logging to recipes"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Adding logging to recipes</h3></div></div></div><p>BitBake recipes accept either bash or<a id="id139" class="indexterm"/> Python code. Python logging is done through the <code class="literal">bb</code> class and uses the standard logging Python library module. It has the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">bb.plain</code>: This uses <code class="literal">logger.plain</code>. It can be used for debugging, but should not be committed to the source.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bb.note</code>: This uses <code class="literal">logger.info</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bb.warn</code>: This uses <code class="literal">logger.warn</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bb.error</code>: This uses <code class="literal">logger.error</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bb.fatal</code>: This uses <code class="literal">logger.critical</code> and exits BitBake.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bb.debug</code>: This should be passed log level as the first argument and uses <code class="literal">logger.debug</code>.</li></ul></div><p>To print debug output from bash in our recipes, we need to use the <code class="literal">logging</code> class by executing:</p><div class="informalexample"><pre class="programlisting">inherit logging</pre></div><p>The <code class="literal">logging</code> class is inherited by default by all recipes containing <code class="literal">base.bbclass</code>, so we don't usually have to inherit it explicitly. We will then have access to the following bash functions, which will output to the log files (not to the console) in the <code class="literal">temp</code> directory inside the working directory as <a id="id140" class="indexterm"/>described previously:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">bbplain</code>: This function outputs literally what's passed in. It can be used in debugging but should not be committed to a recipe source.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bbnote</code>: This function prints with the <code class="literal">NOTE</code> prefix.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bbwarn</code>: This prints a non-fatal warning with the <code class="literal">WARNING</code> prefix.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bberror</code>: This prints a non-fatal error with the <code class="literal">ERROR</code> prefix.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bbfatal</code>: This function halts the build and prints an error message as with <code class="literal">bberror</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bbdebug</code>: This function prints debug messages with log level passed as the first argument. It is used with the following format:<div class="informalexample"><pre class="programlisting">bbdebug [123] "message"</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>The bash functions mentioned here do not log to the console but only to the log files.</p></div></div></li></ul></div></div><div class="section" title="Looking at dependencies"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Looking at dependencies</h3></div></div></div><p>You can ask <a id="id141" class="indexterm"/>BitBake to print the current and provided versions of packages with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake --show-versions</strong></span>
</pre></div><p>Another common debugging task is the removal of unwanted dependencies.</p><p>To see an overview of pulled-in dependencies, you can use BitBake's verbose output by running this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -v &lt;target&gt;</strong></span>
</pre></div><p>To analyze what dependencies are pulled in by a package, we can ask BitBake to create DOT files that describe these dependencies by running the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -g &lt;target&gt;</strong></span>
</pre></div><p>The DOT format is a text description language for graphics that is understood by the <span class="strong"><strong>GraphViz</strong></span><a id="id142" class="indexterm"/> open source package and all the utilities that use it. DOT files can be visualized or further processed.</p><p>You can omit dependencies from the graph to produce more readable output. For example, to omit dependencies from <code class="literal">glibc</code>, you would run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -g &lt;target&gt; -I glibc</strong></span>
</pre></div><p>Once the preceding commands have been run, we get three files in the current directory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">package-depends.dot</code>: This file shows the dependencies between runtime targets</li><li class="listitem" style="list-style-type: disc"><code class="literal">pn-depends.dot</code>: This file shows the dependencies between recipes</li><li class="listitem" style="list-style-type: disc"><code class="literal">task-depends.dot</code>: This file shows the dependencies between tasks</li></ul></div><p>There is<a id="id143" class="indexterm"/> also a <code class="literal">pn-buildlist</code> file with a list of packages that would be built by the given target.</p><p>To convert the <code class="literal">.dot</code> files to postscript files (<code class="literal">.ps</code>), you may execute:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ dot -Tps filename.dot -o outfile.ps</strong></span>
</pre></div><p>However, the most useful way to display dependency data is to ask BitBake to display it graphically with the dependency explorer, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -g -u depexp &lt;target&gt;</strong></span>
</pre></div><p>The result may be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/5186OS_01_01.jpg" alt="Looking at dependencies"/></div></div><div class="section" title="Debugging BitBake"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Debugging BitBake</h3></div></div></div><p>It is not common to have to debug <a id="id144" class="indexterm"/>BitBake itself, but you may find a bug in BitBake and want to explore it by yourself before reporting it to the BitBake community. For such cases, you can ask BitBake to output the debug information at three different levels with the <code class="literal">-D</code> flag. To display all the debug information, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -DDD &lt;target&gt;</strong></span>
</pre></div></div><div class="section" title="Error reporting tool"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec12"/>Error reporting tool</h3></div></div></div><p>Sometimes, you will find a build error on a<a id="id145" class="indexterm"/> Yocto recipe that you have not modified. The first place to check for errors is the community itself, but before launching your mail client, head to <a class="ulink" href="http://errors.yoctoproject.org">http://errors.yoctoproject.org</a>.</p><p>This is a central database of user-reported errors. Here, you may check whether someone else is experiencing the same problem.</p><p>You can submit your own build failure to the database to help the community debug the problem. To do so, you may use the <code class="literal">report-error</code> class. Add the following to your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">INHERIT += "report-error"</pre></div><p>By default, the error information is stored under <code class="literal">tmp/log/error-report</code> under the <code class="literal">build</code> directory, but you can set a specific location with the <code class="literal">ERR_REPORT_DIR</code> variable.</p><p>When the error reporting tool is activated, a build error will be captured in a file in the <code class="literal">error-report</code> folder. The build output will also print a command to send the error log to the server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ send-error-report ${LOG_DIR}/error-report/error-report_${TSTAMP}</strong></span>
</pre></div><p>When this command is executed, it will report back with a link to the upstream error.</p><p>You can set up a local error server, and use that instead by passing a server argument. The error server code and setting up details can be found at <a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi/error-report-web/tree/README">http://git.yoctoproject.org/cgit/cgit.cgi/error-report-web/tree/README</a>.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec62"/>There's more...</h2></div></div></div><p>Although you can use Linux utilities to parse Yocto's metadata and build output, BitBake lacks a command base UI for common tasks. One project that aims to provide it is <code class="literal">bb</code>, which is available at <a class="ulink" href="https://github.com/kergoth/bb">https://github.com/kergoth/bb</a>.</p><p>To use it, you need to clone the repository locally by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/sources</strong></span>
<span class="strong"><strong>$ git clone https://github.com/kergoth/bb.git</strong></span>
</pre></div><p>Then run the <code class="literal">bb/bin/bb init</code> command, which prompts you to add a bash command to your <code class="literal">~/.bash_profile</code> file.</p><p>You can either do that or execute it in your current shell as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ eval "$(/opt/yocto/fsl-community-bsp/sources/bb/bin/bb init -)"</strong></span>
</pre></div><p>You will first need to set up your environment as usual:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Some of the commands only work with a populated work directory, so you may need to remove the <code class="literal">rm_work</code> class if you want to use <code class="literal">bb</code>.</p></div></div><p>Some of the tasks that are made easier by the <code class="literal">bb</code> utility are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Exploring the contents of a package:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bb contents &lt;target&gt;</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Searching for a pattern in the recipes:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bb search &lt;pattern&gt;</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Displaying either the global BitBake environment or the environment for a specific package and grepping for a specific variable:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bb show -r &lt;recipe&gt; &lt;variable&gt;</strong></span>
</pre></div></li></ul></div></div></div></body></html>