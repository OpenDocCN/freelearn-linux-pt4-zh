<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Remote Connections over SSH</h1>
                
            
            <article>
                
<p class="calibre1"> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is SSH?</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>The common answer to such questions is to use a secure shell and use SSH. The only drawback is that SSH is not a shell; it is actually a protocol often referred to SSH1 and SSH2: two different versions of the same protocol, incompatible with each other. Actually, nowadays, we are mostly dealing with SSH version 2 and OpenSSH server; it is the server program from the OpenBSD Project, which is available for a number of platforms.</span></span></p>
<p class="calibre1"><span><span>What are the benefits of SSH and why should we use it? Short story long, SSH grants three main facilities:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre2">Authentication</strong>: This means it can make us sure of the identity of the other party. So, when someone tries to connect to our SSH server, the server will be able to obtain a digital proof of identity of the remote party prior to giving it access to the system.</li>
<li class="calibre13"><strong class="calibre2">Encryption</strong>: Older protocols such as Telnet and FTP are nice and easy to use, but they have a huge drawback since they send data in clear, so if someone could not breach a server, they could always try to eavesdrop on the data to and from it. SSH addresses this issue by encrypting the data, so it cannot be read so easily.</li>
<li class="calibre13"><strong class="calibre2">Integrity</strong>: It prevents tampering. If anyone intercepts the data and modifies it in transit, SSH will notice it. </li>
</ul>
<p class="calibre27"><span>A typical SSH connection goes through a series of steps involving establishing a session and authenticating:</span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">Session</strong>: The server listens to a port, usually port <kbd class="calibre9">22</kbd>. </span></span><span><span>The client contacts the server, which replies with the supported protocol versions. </span></span><span><span>If any version is supported both by the client and the server, the connection continues. </span></span><span><span>The server provides a host key, which is a proof of identity; and if it has been already recorded by the client on a previous session, it gets compared with the saved copy. </span></span><span><span>The client and the server negotiate a session key, which will be used to encrypt the session (a symmetric key).</span></span></li>
</ul>
<p class="calibre27"><span><span>Once a secure channel has been established, the client authenticates to the server with a number of options such as Kerberos; it is host-based but usually uses one of the following methods:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">Password</strong>: The user must have a password-protected account on the remote server. This is probably the easiest way for the setup, but it holds some drawbacks such as we have to remember the username and password used on the remote host, and it makes it more difficult to automate logins into a script.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Public key</strong>: Not to be confused with the encryption key, the public key method actually relies on a pair of SSH keys, one public and one private. One interesting thing is that the public key can be used to encrypt the data, which will be decrypted only by the private key. So, this is an asymmetric encryption since the two keys serve different purposes, and we cannot use the public key to decrypt data encrypted with the same public key. And there is no way to create a private key from a public one, so it becomes safe and easy to distribute the public key: whoever gets the public key can encrypt the data, but only those ones with the corresponding private key can decrypt it. So, it becomes safe to share the public key while the private one must be kept secret and unaccessible.</span></span></li>
</ul>
<p class="calibre27"><span><span>It is interesting to have a look at how the two different kinds of encryptions are used during an SSH session:</span></span></p>
<ul class="calibre12">
<li class="calibre13">
<p class="calibre1"><span><span><strong class="calibre2">Symmetric encryption</strong>: Used to encrypt all the data flowing through an SSH session, it relies on the Diffie-Hellman (or related) algorithm and relies on a large prime number, which works as follows:</span></span></p>
<ol class="calibre17">
<li value="1" class="calibre13">At the beginning of the session, both clients and servers chose a large prime number, which is used as a seed value. Then, the client and server chose one encryption generator such as AES and another prime number, which is not communicated to the other party.</li>
<li value="2" class="calibre13">Now, we have a shared prime number, two private prime numbers, and an encryption generator, so each party derives a public key from its private prime number that it can share with the other side.</li>
<li value="3" class="calibre13">Once shared, each party decrypts the other's public key, the algorithm, its private prime number, and the shared prime number to create a new master secret key that is the same for both, so it can be used to encrypt from both parts the subsequent traffic.<br class="title-page-name"/>
In between, the process of establishing a master key involves the server using his host key to sign the data used in the transaction, and so it authenticates with the client, which now can trust the server.</li>
</ol>
</li>
<li class="calibre13">
<p class="calibre1"><span><span><strong class="calibre2">Asymmetric encryption</strong>: It is used in the authentication stage to authenticate the client onto the server. As we see, one of the the authentication methods is carried through a pair of keys, one public and one private: </span></span></p>
<ol class="calibre17">
<li value="1" class="calibre13">The client starts sending the ID of the pair of keys it wants to use for the authentication and a username.</li>
<li value="2" class="calibre13"><span>The server then checks whether the user account is available on the system and if inside there is a</span> <kbd class="calibre9">.ssh</kbd> <span>directory containing an</span> <kbd class="calibre9">authorized_keys</kbd> <span>file. If the file is available, it should contain the public keys stored by the server, so the ID sent by the client is matched against the IDs of the keys stored in this file.</span></li>
<li value="3" class="calibre13"><span><span>If the public key of the client is found, it is used to encrypt a random number that is then sent back to the client.</span></span></li>
<li value="4" class="calibre13"><span><span>The client, which generated the public key, holds its secret key, and so it can decrypt the packet sent by the server and obtain the secret random number.</span></span></li>
</ol>
</li>
</ul>
<p class="calibre1"> </p>
<div class="calibre22">
<ol start="5" class="calibre15">
<li value="5" class="calibre13">On the client side, a random number is combined with the session key, and then hashed to obtain its MD5 hash value.</li>
<li value="6" class="calibre13">The MD5 hash value is then sent back to the server, which then uses the session key and the original random number to calculate the MD5 hash value on its own. If the two hash values match, it means that the client has the private key corresponding to the public key used to encrypt the random number and so the client is authenticated.</li>
</ol>
</div>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">MD5 hashing</strong>: We just hinted about MD5 hashing, so let's briefly explain what it is all about without drilling too much, since there are entire books on cryptographic and hashing algorithms. A hashing function is used to map a bunch of data with an arbitrary size to a fixed size. It is like creating a fingerprint of something but with a peculiar property: you can map the original data to a fixed size value using a hashing function, but you cannot map back from the fixed size value to the original data. Long story short, a hashing function is a one-way function. MD5 is an algorithm used by the hash function to produce a 128-bit hash value: whatever is the size of the hashed data, the MD5 hashed value produced will be 128 bits long--no more, no less. Although created as a cryptographic means, MD5 has proved itself vulnerable to different attacks, and so, it is used nowadays to check the integrity of the data, downloaded from a safe site and that has not been intentionally tampered.</span></span></li>
</ul>
<p class="calibre1"><span><span>SSH can give us a secure channel to work over the network, avoiding having the data being captured by third parties and having us securely authenticated. Most of the time, we are dealing with an OpenSSH server, but when it comes to clients, there are plenty of them for any operating systems: from command-line programs to graphical ones such as putty. It's just on us to choose whatever we find more ergonomic. Once we have chosen our preferred client, we can connect to the server; and since the most secure method is using public keys, we will see in the next chapter how to set up a passwordless connection to an SSH server.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuration files</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Before playing with ssh and having a look at what it can do for us, let's take some time to see what are the most relevant files that are used to manage the ssh service and client. The configuration files for the SSHD daemon are usually stored in </span></span><span><span><kbd class="calibre9">/etc/ssh</kbd> </span></span><span><span>where we can find some interesting files:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre9">moduli</kbd><span><span>: This file contains the prime numbers and generators used by sshd in the Diffie-Hellman group exchange key exchange method, which is needed to create the shared session master encryption key.</span></span></li>
<li class="calibre13"><kbd class="calibre9">sshd_config</kbd><span><span>: This is the configuration file for the ssh daemon. We will have a closer look at it later to see some interesting and useful directives, which alter the way we connect to a remote server.</span></span></li>
<li class="calibre13"><kbd class="calibre9">ssh_config</kbd><span><span>: This is the system-wide SSH client configuration file that is used when no user-specific configuration file is found in the user home directory <kbd class="calibre9">~/.ssh/config</kbd>. We will see later on what we can do with it.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_dsa_key</kbd>: This is the DSA private key used by the sshd daemon.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_dsa_key_pub</kbd>: This is the DSA public key used by the sshd daemon.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_rsa_key</kbd>: This is the RSA private key used by the sshd daemon.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_rsa_key_pub</kbd>: This is the RSA public key used by the sshd daemon.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_key</kbd>: This the RSA private key used by sshd for the SSH version 1 protocol.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_key.pub</kbd>: This is the RSA public key used by sshd for the SSH version 1 protocol.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_ecdsa_key</kbd>: This is the ECDSA private key used by the sshd daemon.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_ecdsa_key.pub</kbd>: This is the ECDSA public key used by the sshd daemon.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_ed25519_key</kbd>: This is the ED25519 private key used by the sshd daemon.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh_host_ed25519_key.pub</kbd>: This is the ED25519 public key used by the sshd daemon.</span></span></li>
</ul>
<p class="calibre1"><span><span>What are all these RSA, DSA, ECDSA, and ED25519 acronyms associated to the host keys? These acronyms refer to public key cryptosystems used for the authentication keys and open a world of holy wars: some say that <strong class="calibre2">Digital Signature Algorithm (DSA)</strong> is slower when encrypting but faster when decrypting compared to RSA (acronym from the name of the researchers behind this algorithm, Ron Rivest, Adi Shamir, and Leonard Adleman from MIT ), which is deemed to be much more secure than DSA, while <strong class="calibre2">Elliptic Curve Digital Signature Algorithm</strong> (<strong class="calibre2">ECDSA</strong>) and <strong class="calibre2">Edwards-curve Digital Signature Algorithm</strong> (<strong class="calibre2">ed25519</strong>) are newcomers on the scene. All these are digital signature schemes that use different properties such as prime numbers or elliptic curves to ensure that the encryption itself is unbreakable, or more realistically, computationally unfeasible or not so likely. So, before proceeding, let's make a point: we cannot be sure that some encryption is really unbreakable, and we cannot be sure for how long some of them that nowadays look safe will be so in the future.</span></span></p>
<p class="calibre1"><span><span>So, we can make an educated guess and chose an algorithm that is computationally expensive and allegedly without any backdoor from anyone. So, keeping in mind that we are never 100% safe, we can make our choice with some OpenSSH Project recommendations in mind:</span></span></p>
<ul class="calibre12">
<li class="calibre13">OpenSSH 7.0 deprecated DSA due to its weakness. So, we can safely discard this algorithm.</li>
<li class="calibre13">Do not use keys smaller than 1024. This makes sense, since longer keys can be computationally heavier, but for everyday use, they do not give a relevant added hindrance.</li>
<li class="calibre13">Do not use cyphers, such as Blowfish, CBC, RC4, MD5 based HMAC algorithms and RIPE-MD160 HMAC.</li>
<li class="calibre13">Do not use SSH version 1, as it is deprecated and not supported.</li>
<li class="calibre13"><span>Use ECDA or ED25519, and if it not possible, we can create an RSA key of at least 2048 or 4096.</span></li>
</ul>
<p class="calibre1"><span><span>Quite complex, isn't it? Well, a rule of thumb to understand what NOT to use is to read the Release Notes page of the OpenSSH project we can find at  </span></span><span><span><a href="http://www.openssh.com/releasenotes.html" class="calibre4">http://www.openssh.com/releasenotes.html</a> </span></span><span><span>and have a look at the </span></span><span><span>Future deprecation notice </span></span><span><span>section.</span></span></p>
<p class="calibre1"><span><span>Whatever we find here will be deprecated and eventually abandoned in the next releases, so even if we do not drill down into the details of the mathematics behind the encryption algorithms, we can trust the OpenSSH project and not use whatever is deprecated in any releases. When it comes to ciphers, these are algorithms that take chunks of plain data and create bits of obfuscated data. It suffices to say that even in this case, some holy wars are in play, with some major algorithms being considered weaker and some stronger:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">Digital Encryption Standard (DES)</strong>: Well regarded in the past, this is not really considered safe anymore due to the small keys used.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Triple DES</strong>: This is based on DES and considered safer but not really efficient nowadays.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Advanced Encryption Standard (AES) or Rijndael</strong>: This is a quite recent algorithm and well regarded. AES-256, for instance, is used in TLS/SSL, and it is considered safe.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">IDEA</strong>: This is a viable algorithm but due to patent use it is not so widespread.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Twofish</strong>: Using blocks of 128 bits and a variable length key, it is one of the choices for our encryption needs.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Serpent</strong>: If you do not have any ideas on what to choose, and cannot use AES, go with this, it has a block size of 128 bits and keys of 128, 192, and 256 bits. Slower than other options but safe: a block cipher with a block size of 128 bits.</span></span></li>
</ul>
<p class="calibre1"><span><span>After this short digression, we can proceed to having a look at another set of SSH config files that are optionally located on the user <kbd class="calibre9">.ssh</kbd> config directory:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre9">authorized_keys</kbd><span><span>: In this file, we can find the list of the public keys that give access to the server. As we saw earlier, when a client tries to connect to the server, it looks for the account and if it exists, looks in the <kbd class="calibre9">.ssh/authorized_keys</kbd> file in the user home directory for the ID of the key pair provided by the client. If the ID is found, the client is authenticated with the user and key provided.</span></span></li>
<li class="calibre13"><kbd class="calibre9">authorized_keys</kbd><span><span><span><span>: </span></span><span><span>This file holds a list of authorized public keys for servers. When the client connects to a server, the server authenticates the client by checking its signed public key stored within this file.</span></span></span></span></li>
<li class="calibre13"><kbd class="calibre9">known_hosts</kbd><span><span><span><span>:</span></span><span><span> This file contains the host public keys of the server that the client had already accessed. When the server sends to the client their host public key, it has looked inside this file to see if it corresponds to the previously stored public key for the remote host.</span></span></span></span></li>
<li class="calibre13"><kbd class="calibre9">config</kbd><span><span><span><span>:</span></span><span><span> It holds the ssh client configuration for the user. It is really important in the passwordless connections since it helps to automate the connections. We will see more about it later.</span></span></span></span></li>
<li class="calibre13"><kbd class="calibre9">id_dsa</kbd><span><span><span><span>:</span></span><span><span> This holds the DSA private key for the user.</span></span></span></span></li>
<li class="calibre13"><kbd class="calibre9">id_dsa.pub</kbd><span><span><span><span>:</span></span><span><span> This holds the DSA public key for the user.</span></span></span></span></li>
<li class="calibre13"><kbd class="calibre9">id_rsa</kbd><span><span><span><span>:</span></span><span><span> This holds the RSA private key for the user.</span></span></span></span></li>
<li class="calibre13"><kbd class="calibre9">id_rsa.pub</kbd><span><span>:<span><span> This holds the RSA public key for the user.</span></span></span></span></li>
<li class="calibre13"><kbd class="calibre9">Identity</kbd><span><span><span><span>:</span></span><span><span> This contains the RSA private key of the user for SSH version 1.</span></span></span></span></li>
<li class="calibre13"><kbd class="calibre9">Identity.pub</kbd><span><span><span><span>:</span></span><span><span> This contains the RSA public key of the user for SSH version 1.</span></span></span></span></li>
</ul>
<p class="calibre1"><span><span><span><span>These are files we could find on a host, but probably we will not find all of them, for instance, not all the keys will be there; and we will have to create them taking the chance to give them some more meaningful names. Something we are sure to find on a remote host and interest us is the <kbd class="calibre9">sshd_config</kbd> file. Since this will help us to modify the way the daemon will offer the SSH server, let's have a look at it more in detail, covering some of the most interesting directives.</span></span></span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The sshd_config file</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We will have a look at the directives that can be the most useful for our everyday service usage, but if we need to know all the details about all the configuration options, we can just invoke <kbd class="calibre9">man</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">man sshd_config</strong>
</pre>
<p class="calibre1"><span><span>The main SSH daemon configuration file is located at the </span></span><span><span><kbd class="calibre9">/etc/ssh/sshd_config</kbd> </span></span><span><span>event, though we can specify any file at the daemon startup using the <kbd class="calibre9">-f</kbd> option on the command line. That said, let's go through and have a look at the most interesting configuration bits:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">AcceptEnv</kbd>: This allows the client to copy the environment variable into the session environment sent by the client. It can be useful, but it can also be dangerous, and the default is not to accept any client environment variable.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">AllowGroups</kbd>: By default, the log in is only allowed for members from all groups available on the system, but with this directive, you can restrict it to only to the users whose primary or secondary groups matches the groups listed, even using a pattern, as we will see later. We can use group names only; no ID and the access directives are processed in this order: <kbd class="calibre9">DenyUsers</kbd>, <kbd class="calibre9">AllowUsers</kbd>, <kbd class="calibre9">DenyGroups</kbd>, <kbd class="calibre9">AllowGroups</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">AllowUsers</kbd>: <span>By default, all users with a valid account are allowed to log in, but with this directive, we can restrict the access to only those members who match an account name or a patter. We can specify user names only and not IDs. We can also specify a member as <kbd class="calibre9">user@host</kbd> so</span> that the restrictions will be applied not only to the account name but also to the origin host. This can be written in the CDIR/mask format. The access directives are processed in this order: <kbd class="calibre9">DenyUsers</kbd>, <kbd class="calibre9">AllowUsers</kbd>, <kbd class="calibre9">DenyGroups</kbd>, <kbd class="calibre9">AllowGroups</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">AuthenticationMethods</kbd>: We can specify the authentication methods that a user must successfully go through to be given access to the system. It defaults to <em class="calibre20">any</em> meaning that the user must successfully authenticate once to any of the available methods. If any authentication methods combination is listed, for instance, <kbd class="calibre9">password</kbd>, </span></span><kbd class="calibre9">publickey</kbd><span><span>, <kbd class="calibre9">keyboard-interactive</kbd>, <kbd class="calibre9">publickey</kbd></span></span>, <span><span>the user will be forced to authenticate through all the authentication methods at least once and in the order they are listed. So, in the example show, the user has to successfully authenticate with the <kbd class="calibre9">publickey</kbd> method and then at least with a password. The <kbd class="calibre9">keyboad-interactive</kbd> method is a generic authentication, which relies on facilities such as PAM, RADIUS, and RSA Secure ID and can be limited by appending a column followed by the <kbd class="calibre9">bsdauth</kbd>, <kbd class="calibre9">pam</kbd>, or <kbd class="calibre9">skey</kbd> keywords. If the <kbd class="calibre9">publickey</kbd> method is used more than once, such as </span></span><kbd class="calibre9">publickey</kbd> <span><span>and <kbd class="calibre9">publickey</kbd>, two different public keys will be required to successfully authenticate. Whatever method is listed, it then must be enabled in the configuration.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">AuthorizedKeysFile</kbd>: Sometimes, we just put our client public authentication key in the <kbd class="calibre9">authorized_keys</kbd> file inside the <kbd class="calibre9">user ~./ssh</kbd> directory and nothing happens. Well, one of the issues could be originated by this directive, since it is here where the name of the file is defined. The default value is <kbd class="calibre9">.ssh/authorized_keys .ssh/authorized_keys2</kbd>, but we can also find some tokens such as </span></span><kbd class="calibre9">%h/.ssh/authorized_keys</kbd><span><span>, with <kbd class="calibre9">%h</kbd> standing for the home directory of the account autenticating; or we can also see <kbd class="calibre9">%%</kbd> , which stands for a simple <kbd class="calibre9">%</kbd> while a <kbd class="calibre9">%u</kbd> is replaced by the username. Once the tokens are expanded, the result is taken either as the full path to the file or the path relative to the user home directory.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">Banner</kbd>: This is a nice option to show a message to the user before he authenticates. If <kbd class="calibre9">none</kbd> is supplied, no banner is shown. It is only available for SSH-2 and defaults to none.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ChallengeResponseAuthentication</kbd>: This allows the challenge-response authentication. It defaults to <kbd class="calibre9">yes</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ChrootDirectory</kbd>: By specifying the full path to a directory, we can <kbd class="calibre9">chroot</kbd> a user into it after he successfully authenticates. It is not an easy task though since the directory must be owned by root and not writable by anyone else. In addition, we must provide some files required for a session, such as the shell, <kbd class="calibre9">/dev/null</kbd>, <kbd class="calibre9">/dev/zero</kbd>, <kbd class="calibre9">/dev/arandom</kbd>, <kbd class="calibre9">/dev/stdin</kbd>, <kbd class="calibre9">/dev/stdout</kbd>, <kbd class="calibre9">/dev/stderr</kbd>, and <kbd class="calibre9">/dev/ttyx</kbd>. We can also find some tokens such as <kbd class="calibre9">%h</kbd> standing for the home directory of the account authenticating; or we can also see <kbd class="calibre9">%%</kbd> , which stands for a simple <kbd class="calibre9">%</kbd> while a <kbd class="calibre9">%u</kbd> is replaced by the username.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">Ciphers</kbd>: This allows us to specify the ciphers allowed for SSH-2. This is a good point to restrict the number and kind of ciphers we want to deal with. The default cipher list, comma separated, is <kbd class="calibre9">aes128-ctr,aes192-ctr</kbd>, </span></span><kbd class="calibre9">aes256-ctr</kbd><span><span>, </span></span><kbd class="calibre9">aes128cm@openssh.com</kbd><span><span>, </span></span><kbd class="calibre9">aes256-gcm@openssh.com</kbd><span><span>, and <kbd class="calibre9">chacha20-poly1305@openssh.com</kbd></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ClientAliveCountMax</kbd>: This is the number of the client alive messages that can be sent without the daemon receiving any reply from the client. When the max is hit, the daemon will disconnect the client. The default value is <kbd class="calibre9">3</kbd>; and this option is available only for SSH-2.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ClientAliveInterval</kbd>: This is the time interval, in seconds, after which if the client does not send any messages, the server will send itself a message through the encrypted channel to the client to push for a reply. The default is <kbd class="calibre9">0</kbd>. So, let's say that we set this option to <kbd class="calibre9">5</kbd> and the previous <kbd class="calibre9">ClientAliveCountMax</kbd> to <kbd class="calibre9">12</kbd>; the client will be disconnected after <kbd class="calibre9">60</kbd> seconds.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">DenyGroups</kbd>: By default, members from all the groups are allowed to authenticate but with this directive, we can restrict them to a list of space-separated groups. So, the authentication is unavailable for those users whose primary or supplementary groups is listed in this directive or matched through a pattern.</span></span></li>
</ul>
<p class="calibre1">We already mentioned <span><span>the pattern available in </span></span><kbd class="calibre9">sshd config</kbd><span><span>, and this breaks down essentially to two characters:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">* matches 0 or more characters</strong>: Something like <kbd class="calibre9">192.168.*</kbd> will match all the IP addresses starting with <kbd class="calibre9">192.168</kbd> ; or <kbd class="calibre9">*.foo.com</kbd> will match all the third-level domains for <kbd class="calibre9">foo.com</kbd> as well as the second-level domain called foo.com.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">? matches exactly one character</strong>: So, for instance, <kbd class="calibre9">192.16?.1</kbd> will match all the IPS from <kbd class="calibre9">192.160.1</kbd> to <kbd class="calibre9">192.168.9.1</kbd>.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Pattern list</strong>: As the name states, this is a list of patterns delimited by commands. The single patterns can be negated by a leading exclamation mark; for example, </span></span><span><span><kbd class="calibre9">!*.noway.foo.com,*.foo.com</kbd> </span></span><span><span>would allow the all the third-level domains for <kbd class="calibre9">foo.com</kbd> except those containing a noway right before <kbd class="calibre9">.foo.com</kbd>.</span></span></li>
</ul>
<p class="calibre1"><span><span>Groups must be specified by their name, not by their numeric ID; and the order in which this directive is processed is: <kbd class="calibre9">DenyUsers</kbd>, <kbd class="calibre9">AllowUsers</kbd>, <kbd class="calibre9">DenyGroups</kbd>, and  <kbd class="calibre9">AllowGroups</kbd>.</span></span></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre9">DenyUsers</kbd>: <span><span>Followed by a list of user name patterns separated by a space, this directive disallows the log in for those user accounts which match the listed patterns. As usual, only the names of the users and not their ID can be specified and by default all users are allowed to log in. <span>We can also specify a member as <kbd class="calibre9">ser@host</kbd> so</span> that the restrictions will be applied not only to the account name but also to the origin host; this can be written also in the CDIR/mask format. The access directives are processed in this order: <kbd class="calibre9">DenyUsers</kbd>, <kbd class="calibre9">AllowUsers</kbd>, <kbd class="calibre9">DenyGroups</kbd>, and <kbd class="calibre9">AllowGroups</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">DisableForwarding</kbd>: This directive disables all kinds of forwardings such as X11, TCP, ssh-agent, and <kbd class="calibre9">StreamLocal</kbd>. This is a nice directive to use if we want to trim down the service and make it safer.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ForceCommand</kbd>:<span> This overrides any command sent by the client or listed in the <kbd class="calibre9">~/.ssh/rc</kbd> of the authenticating account; and it forces the execution of the command listed in this directive. The command is executed through the account shell with the <kbd class="calibre9">-c</kbd> option. This defaults to <kbd class="calibre9">no</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">HostbasedAuthentication</kbd>: This allows/denies the authentication based on <kbd class="calibre9">rhosts</kbd> or <kbd class="calibre9">hostS_equive</kbd> along with a successful public <kbd class="calibre9">jkey</kbd> client host authentication. The default is <kbd class="calibre9">no/</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">HostKey</kbd>: This directive specifies the file the private host key is kept in. By default, the locations are <kbd class="calibre9">/etc/ssh/ssh_host_rsa_key</kbd>, <kbd class="calibre9">/etc/ssh/ssh_host_ecdsa_key</kbd>, and <kbd class="calibre9">/etc/ssh/ssh_host_ed25519_key</kbd>. We can have multiple host keys defined for a single host. but it is important that the files holding them are not world or group accessible.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">KbdInteractiveAuthentication</kbd>:<span> This allows/denies the keyboard-interactive authentication. The default value is drawn from <kbd class="calibre9">ChallengeResponseAuthentication</kbd> , which is usually set to <kbd class="calibre9">yes</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">KerberosAuthentication</kbd>: This allows/denies the validation through a Kerberos server of the password provided by the client. The default value is <kbd class="calibre9">no</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ListenAddress</kbd>: This lists the addresses SSH daemon will be listening on. We can use an IPv4/IPv6 address, a hostname, or a list of them and follow them with an optional port, such as following:</span></span></li>
</ul>
<pre class="calibre21">
<strong class="calibre2">Listen 192.168.0.10:6592</strong>
</pre>
<p class="calibre27"><span><span>If no ports are specified, sshd will listen on those listed in the ports directive. The default configuration is to listen to all local addresses:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">LoginGraceTime</kbd>: This is a timeout in seconds for the user to complete the log in process. It defaults to 120 seconds; with 0, we can disable the timeout.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">LogLevel</kbd>: In case of any issues, we can modify the verbosity of the logs generated by sshd. The default level is <kbd class="calibre9">INFO</kbd> , but we can set it to any of <kbd class="calibre9">QUIET</kbd>, <kbd class="calibre9">FATAL</kbd>, <kbd class="calibre9">ERROR</kbd>, <kbd class="calibre9">INFO</kbd>, <kbd class="calibre9">VERBOSE</kbd>, <kbd class="calibre9">DEBUG</kbd>, <kbd class="calibre9">DEBUG1</kbd>, <kbd class="calibre9">DEBUG2</kbd>, <kbd class="calibre9">DEBUG3</kbd>. <kbd class="calibre9">DEBUG</kbd> and <kbd class="calibre9">DEBUG1</kbd> are equivalent while each <kbd class="calibre9">DEBUGx</kbd> enables a higher level of verbosity. <kbd class="calibre9">DEBUG</kbd> is not advised since it can disclose too many private informations related to the users.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">Match</kbd>: With this directive, we can use conditional statements so that if they are satisfied, the following configuration lines will override the one in the main configuration block. If a keyword/configuration block appears in more than one match clause, only the first instance is taken in account. As a matching criteria, we can use the following directives: user, group, host, local address, local port, address, or all for all of them. We can match against a single value, a comma separated list and we can also use wildcards and negation operators.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">MaxAuthTries</kbd>: This limits the maximum number or authentication attempts per single connection. Once half of the threshold is hit, the subsequent failed attempts are logged. It defaults to <kbd class="calibre9">6</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">PasswordAuthentication</kbd>: This allows/denies password authentication. This defaults to yes.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">PermitEmptyPasswords</kbd>: This allows/denies the use of empty passwords when password authentication is enabled. This is not safe to set to <kbd class="calibre9">yes</kbd> and defaults to <kbd class="calibre9">no</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">PermitRootLogin</kbd>: This lets a user log in as root. It can have the following values: <kbd class="calibre9">yes</kbd>, <kbd class="calibre9">prohibit-password</kbd>, <kbd class="calibre9">without-password</kbd>, <kbd class="calibre9">forced-commands-only</kbd>, and <kbd class="calibre9">no</kbd>. If set to <kbd class="calibre9">prohibit-password</kbd> or <kbd class="calibre9">without-password</kbd>, the <kbd class="calibre9">password</kbd> and <kbd class="calibre9">keyboard-interactive</kbd> authentications are not available for user root; if set to <kbd class="calibre9">forced-commands-only</kbd>, a log in with public key authentication is allowed but only if a command is specified.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">PermitTTY</kbd>: This allows/denies the use of a <kbd class="calibre9">pty</kbd> (pseudo terminal) for the session. This defaults to <kbd class="calibre9">yes</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">PermitTunnel</kbd>: This allows/denies the <em class="calibre20">tun</em> device forwarding. It takes <kbd class="calibre9">yes</kbd>, <kbd class="calibre9">point-to-point</kbd>, <kbd class="calibre9">ethernet</kbd> or <kbd class="calibre9">no</kbd> as arguments. <kbd class="calibre9">Yes</kbd> enables both <kbd class="calibre9">point-to-point</kbd> and <kbd class="calibre9">ethernet</kbd> forwarding. This defaults to <kbd class="calibre9">no</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">PermitUserRC</kbd>: If set to <kbd class="calibre9">yes</kbd>, the commands inside <kbd class="calibre9">~/.ssh/rc</kbd> are executed. This defaults to <kbd class="calibre9">yes</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">Port</kbd>: This specifies the port number the SSH daemon will listen on. This defaults to <kbd class="calibre9">22</kbd>, but we should move this port to some higher number to avoid most of the script kiddies around trying to automatically deface the service.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">PubkeyAuthentication</kbd>: This allows/denies public key authentication. This defaults to <kbd class="calibre9">yes</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">StrictModes</kbd>: This enables/disables file mode and ownership checks on the account's files and home directory before letting the log in process go through. If it is set to <kbd class="calibre9">yes</kbd>, it checks for a world-writable user <kbd class="calibre9">.ssh</kbd> directory or a world writable <kbd class="calibre9">home</kbd> directory, and if we leave our files or directories world-writable, the log in is denied. This does not apply to <kbd class="calibre9">ChrootDirectory</kbd> , whose permissions and ownership are always checked.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">Subsystem</kbd>: This enables the execution of an external subsystem, usually an <kbd class="calibre9">sftp-server</kbd>. The syntax is a subsystem name followed by a command with an optional argument to be executed on a subsystem invocation. This defaults to the <kbd class="calibre9">no</kbd> subsystem configured.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">SyslogFacility</kbd>: We can use any of these <kbd class="calibre9">syslog</kbd> facilities to log the messages from the SSH daemon: <kbd class="calibre9">DAEMON</kbd>, <kbd class="calibre9">USER</kbd>, <kbd class="calibre9">AUTH</kbd>, <kbd class="calibre9">LOCAL0</kbd>, <kbd class="calibre9">LOCAL1</kbd>, <kbd class="calibre9">LOCAL2</kbd>, <kbd class="calibre9">LOCAL3</kbd>, <kbd class="calibre9">LOCAL4</kbd>, <kbd class="calibre9">LOCAL5</kbd>, <kbd class="calibre9">LOCAL6</kbd>, and <kbd class="calibre9">LOCAL7</kbd>. This defaults to <kbd class="calibre9">AUTH</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">TCPKeepAlive</kbd>: This enables the server to send <kbd class="calibre9">TCP keepalive</kbd> to the client so that it will be able to detect any disconnection. This is not an easy choice: a temporary routing issue could lead to a forced disconnection from the server; but without a <kbd class="calibre9">keepalive</kbd>, a connection could hang indefinitely if the client disconnects or dies. This defaults to <kbd class="calibre9">yes</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">UseDNS</kbd>: This forces the SSH daemon to resolve, the host name through a DNS facility and check whether it resolves to the IP address of the client connecting. If this option is set to <kbd class="calibre9">no</kbd>, the usage of <kbd class="calibre9">from= in ~/.ssh/authorized_keys</kbd> still does not support host names but IP addresses only; and the same is applicable for the Match Host directive. Setting this option to <kbd class="calibre9">yes</kbd> can cause delays in authentication due to the DNS resolution task. Defaults to <kbd class="calibre9">yes</kbd>.</span></span></li>
<li class="calibre13"><span><span><span><span><kbd class="calibre9">UsePAM</kbd>:</span></span><span><span> This enables/disables the Pluggable Authentication Module interface. Defaults to <kbd class="calibre9">no</kbd>. If set to <kbd class="calibre9">yes</kbd>, it will enable the authentication through PAM using <kbd class="calibre9">ChallengeResponseAuthentication</kbd> and <kbd class="calibre9">PasswordAuthentication</kbd>, along with the PAM account and session modules, so one of these must be disabled. Interestingly, enabling PAM will allow the SSH daemon to run as an unprivileged user. This defaults to <kbd class="calibre9">no</kbd>.</span></span></span></span></li>
<li class="calibre13"><span><span><span><span><kbd class="calibre9">UsePrivilegeSeparation</kbd>:</span></span><span><span> If this is enabled, after the user's log in, the SSH daemon will create a child process with the privileges of the authenticated user. It can take <kbd class="calibre9">yes</kbd>, <kbd class="calibre9">no</kbd> ,  or <kbd class="calibre9">sandbox</kbd> as arguments. If <kbd class="calibre9">sandbox</kbd> is selected, further mandatory restrictions are performed on the syscalls the child can perform so that it will be more difficult to use a compromised child to attack hosts or the local kernel. This defaults to sanbox.</span></span></span></span></li>
<li class="calibre13"><span><span><span><span><kbd class="calibre9">X11Forwarding</kbd>:</span></span><span><span> This allows/denies X11 forwarding. If set to <kbd class="calibre9">yes</kbd>, it can expost X11 to attacks, so this option must be taken with care. Defaults to <kbd class="calibre9">no</kbd>.</span></span></span></span></li>
</ul>
<p class="calibre1"><span><span><span><span>We just saw some of the configurations on the server side, but we can alter how we interact with the SSH daemon configuring the client too, so let's have a look at the most interesting options from the client side.</span></span></span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ssh_config</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>On the client side, we have a few ways to configure how a connection will be held:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span>From the command line, passing options to the client while invoking it</span></span></li>
<li class="calibre13"><span><span>From the configuration file inside the user's home directory <kbd class="calibre9">~/.ssh/config</kbd></span></span></li>
<li class="calibre13"><span><span>From the system-wide configuration file in <kbd class="calibre9">/etc/ssh/ssh_config</kbd></span></span></li>
</ul>
<p class="calibre1"><span><span>For the configuration files, we must bear in mind that only the first value obtained for each directive will be used; so if we give the same directive multiple times, only the first one will be evaluated. So, we must keep the more specific options at the beginning of the configuration file while the broader one will be pushed toward the end.</span></span></p>
<p class="calibre1"><span>As we will see in the next paragraph, where we will examine a practical use of the client configuration, the file is segmented <span>into </span>sections whose boundaries are delimited by the <kbd class="calibre9">Host</kbd> directive: whatever configuration directive is listed below the keyword will belong to the host specified, until the next Host declaration. Each line in the file contains a configuration directive and value, optionally enclosed in double quotes when containing spaces; lines starting with <kbd class="calibre9">#</kbd> or blank are considered comments. Multiple values can be separated by a whitespace or <kbd class="calibre9">=</kbd>. With these caveats in mind, let's have a look at the most interesting keywords in the client configuration file:</span></p>
<ul class="calibre12">
<li class="calibre13">
<p class="calibre1"><span><span><kbd class="calibre9">Host</kbd>:<span> This directive can take a host name as an argument or a pattern, which can be negated with <kbd class="calibre9">!</kbd>.</span></span></span> If <kbd class="calibre9">*</kbd> the following directives apply to all hosts<span><span><span>. Whatever pattern or name is given here, it should match the host name we would give on the command line to connect to the remote host. All the directives following the <kbd class="calibre9">Host</kbd> keyword will be applied only to the host defined, up to the next <kbd class="calibre9">Host</kbd> or <kbd class="calibre9">Match</kbd> directive. If a host/pattern value is negated, all the directives for that host(s) are negated.</span></span></span></p>
</li>
<li class="calibre13"><span><span><kbd class="calibre9">Match</kbd>:<span> This limits the scope of the following directives, up to the next <kbd class="calibre9">Match</kbd> or <kbd class="calibre9">Host</kbd> declaration, to be applied only when the values specified are satisfied. The values can be <kbd class="calibre9">all</kbd> , which always matches or one or more among <kbd class="calibre9">canonical</kbd>, <kbd class="calibre9">exec</kbd>, <kbd class="calibre9">host</kbd>, <kbd class="calibre9">originalhost</kbd>, <kbd class="calibre9">user</kbd>, and <kbd class="calibre9">localuser</kbd>. The <kbd class="calibre9">all</kbd> value must appear alone or right after canonical, which are the only two options not requiring an argument. Values can be negated using</span></span></span> <kbd class="calibre9">!</kbd>.</li>
<li class="calibre13"><span><span><kbd class="calibre9">canonical</kbd><span>: This is matched when the configuration file is reparsed after the hostname canonicalization has taken place (we will see in a while what it means).</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">exec</kbd><span>: Executes a command using the account's shell; and if its <kbd class="calibre9">exit</kbd> status is zero then the condition is evaluated as <kbd class="calibre9">true</kbd>. If the command contains a whitespace then it must be quoted; it can accept tokens as arguments (we will see in a while what it means).</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">host</kbd><span>: This matches against the destination hostname, after any substitution operated by the <kbd class="calibre9">Hostname</kbd> or <kbd class="calibre9">CanonicalizeHostname</kbd> options. It can accept a comma-separated list, wildcards, and negation (<kbd class="calibre9">!</kbd>). For instance, take a look here:</span></span></span></li>
</ul>
<pre class="calibre21">
<strong class="calibre2">match host foo.com exec "test %p = 9999"<br class="title-page-name"/></strong><strong class="calibre2">IdentityFile foo.identity</strong>
</pre>
<p class="calibre27"><span><span><span>We will use the identity file called  <kbd class="calibre9">foo.identity</kbd> only if the target host has the <kbd class="calibre9">foo.com</kbd> hostname and the the port equals to <kbd class="calibre9">9999</kbd>.</span></span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">originalhost</kbd><span>: This is matched against the hostname specified on the client command line.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">user</kbd><span>: This matches against the username used to log in on the remote host.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">localuser</kbd>: This i<span>s matched against the local (client side) user running an SSH client.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">BatchMode</kbd>:<span> Useful for unattended log in from a script. If it is set to <kbd class="calibre9">yes</kbd>, no passphrases or passwords will be asked for and the <kbd class="calibre9">ServerAliveIntervall</kbd> will be set to <kbd class="calibre9">300</kbd> seconds in Debian. This defaults to <kbd class="calibre9">no</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">BindAddress</kbd>:<span> Useful in client machines which have more than one IP address assigned; it specifies the source address for the connection. Does not work if <kbd class="calibre9">UsePrivilegedPort</kbd> is set to <kbd class="calibre9">yes</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">CanonicalDomains</kbd>:<span> Used with <kbd class="calibre9">CanonicalizeHostname</kbd>; it sets a list of domain suffixes to search for the remote host to connect to.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">CanonicalizeFallbackLocal</kbd>:<span> If set to <kbd class="calibre9">yes</kbd>, the client will attemp to look up an unqualified hostname using the search rule of the client system. If set to <kbd class="calibre9">no</kbd> and <kbd class="calibre9">CanonicalizeHostname</kbd> is set to <kbd class="calibre9">yes</kbd> , it will fail immediately if the remote hostname cannot be found in any of the domains listed by <kbd class="calibre9">CanonicalDomains</kbd>. Defaults to <kbd class="calibre9">yes</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">CanonicalizeHostname</kbd>:<span> Enables the canonicalization rewriting the hostname. If set to <kbd class="calibre9">no</kbd>, the local resolver will manage the hostname lookup; if set to <kbd class="calibre9">always</kbd>, it will rewrite the unqualified hostnames using the domains listed in <kbd class="calibre9">CanonicalDomains</kbd>. The <kbd class="calibre9">CanonicalizePermittedCNAMEs</kbd> rules will be applied. If set to <kbd class="calibre9">yes</kbd>, the canonicalization will be performed for those connections which do not use a <kbd class="calibre9">ProxyCommand</kbd> directive.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">CanonicalizePermittedCNAMEs</kbd>:<span> Lists the rules that must be followed during hostname canonicalization. The rules can have one of more of the following arguments:</span></span></span>
<ul class="calibre23">
<li class="calibre13"><span><span><kbd class="calibre9">source_domains:target_domains</kbd>:<span> The first being a list of patterns for domains that may follow the hostname in canonicalization; <kbd class="calibre9">target_domains</kbd> is a list of patterns of domains that the former domains may resolve to.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">CertificateFile</kbd>:<span> Lists the file where to load the certificate file for the corresponding private key pointed to by the <kbd class="calibre9">IntentityFile</kbd> directive.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">CheckHostIP</kbd>:<span> Defines whether the client will check for the host IP in the <kbd class="calibre9">known_hosts</kbd> file for DNS spoofing prevention, adding the IP of the remote host to the <kbd class="calibre9">~/.ssh/known_hosts</kbd> file. Defaults to <kbd class="calibre9">yes</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ConnectionAttempts</kbd>:<span> The number of connection tries per second before exiting. Defaults to <kbd class="calibre9">1</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ConnectTimeout</kbd>:<span> Timeout in seconds for a connection try.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ForwardX11</kbd>:<span> Enables X11 redirection over the connection and sets the DISPLAY value. Defaults to <kbd class="calibre9">no</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">GatewayPorts</kbd>:<span> Allows/denies the connection of remote hosts to local forwarded ports. Defaults to <kbd class="calibre9">no</kbd>, meaning that the local forwarded ports bind to the loopback device address. If set to <kbd class="calibre9">yes</kbd>, they are bound to the <kbd class="calibre9">*</kbd> address.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">GlobalKnownHostsFile</kbd>:<span> Sets one or more file (separated by whitespaces) where the host keys are kept. Defaults to the default <kbd class="calibre9">/etc/ssh/ssh_known_hosts</kbd> and <kbd class="calibre9">/etc/ssh/ssh_known_hosts2</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">HostKeyAlias</kbd>:<span> Sets an alias to be used instead of the hostname when searching or saving the host key in the <kbd class="calibre9">hostkey</kbd> file.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">HostName</kbd>:<span> Points to the real hostname of the remote host that we are going to log in. We can use this field to create a meaningful alias for the remote host, either using numeric IPS, tokens (we will see them later), or short names.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">IdentityFile</kbd>:<span> Defines the file the authentication identity is read from. Defaults to <kbd class="calibre9">~/.ssh/identity</kbd> for SSH-1, and <kbd class="calibre9">~/.ssh/id_dsa</kbd>, <kbd class="calibre9">~/.ssh/id_ecdsa</kbd>, <kbd class="calibre9">~/.ssh/id_ed25519</kbd> and <kbd class="calibre9">~/.ssh/id_rsa</kbd> for SSH-2. If no certificates have been associated using the <kbd class="calibre9">CertificateFile</kbd> directive, SSH will try to read a file whose name is crafted by adding <kbd class="calibre9">-cert.pub</kbd> to the name listed under <kbd class="calibre9">IdentityFile</kbd>. Tokens can be used as argument; and it is possible to repeatedly use this directive to add more identity files to the list of the ones tried.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">Include</kbd>:<span> Includes the configuration files listed. If a file is not pointed to by an absolute path, it is meant to be located under <kbd class="calibre9">~/.ssh</kbd> if included in a user configuration or under <kbd class="calibre9">/etc/ssh</kbd> if included in the system-wide configuration file. Wildcards can be used, and this directive can be listed as an argument for the <kbd class="calibre9">match</kbd> and <kbd class="calibre9">host</kbd> keywords for conditional includes.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">LocalCommand</kbd>:<span> We can write a command to be executed with the user shell once the local client has successfully connected to the remote host. It accepts the tokens, but it is ignored unless <kbd class="calibre9">PermitLocalCommand</kbd> is enabled.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">LocalForward</kbd>:<span> Enables the forwarding of a TCP local port over a secure connection to the remote host and port. It accepts two arguments: </span></span></span><span><span><kbd class="calibre9">[local_address:]port</kbd> and <kbd class="calibre9">remote_host:port</kbd>.</span></span></li>
</ul>
</li>
</ul>
<p class="calibre27"><span><span><span>We can specify more than one forwarding but only a superuser can bind a local privileged port. The local port is bound to the address drawn from the <kbd class="calibre9">GatewayPorts</kbd> directive if not specified as an argument. If the localhost is given, the listening port will be accessible only from the local client machine; and an empty address means</span></span></span> <kbd class="calibre9">*</kbd>, <span><span><span>so the port will be accessible on all the interfaces.</span></span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">NumberOfPasswordPrompts</kbd>: <span>Defines how many times a password is asked for before declaring the login process as failed, the argument can be an integer which defaults to <kbd class="calibre9">3</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">Port</kbd>:<span> This is the port on the remote server that the client will try to connect to. Defaults to <kbd class="calibre9">22</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">PreferredAuthentications</kbd>:<span> Defines the order in which the client will try different authentication methods. Defaults to </span></span></span><span><span><kbd class="calibre9">gssapi-with-mic</kbd>,<kbd class="calibre9">hostbased</kbd>,<kbd class="calibre9">publickey</kbd>, <kbd class="calibre9">keyboard-interactive</kbd>, and </span></span><kbd class="calibre9">password</kbd>.</li>
<li class="calibre13"><span><span><kbd class="calibre9">Protocol</kbd>:<span> Defines the protocol supported by the client in order of preference. If more than one is listed, they must be separated by a command. If a preferred protocol fails, the next in the list will be tried. Defaults to <kbd class="calibre9">2</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ProxyCommand</kbd>:<span> Defines the command used to connect to the remote server; and it is executed with the exec directive of the user's shell. Really useful used with <kbd class="calibre9">netcat</kbd> to proxy connections. Accepts tokens.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">RemoteForward</kbd>:<span> Enables the forwarding of a TCP port on the remote host on a secure connection to a port on the local machine. It accepts two arguments: </span></span></span><span><span><kbd class="calibre9">[local_address:]port</kbd> and <kbd class="calibre9">remote_host:port</kbd></span></span>.</li>
</ul>
<p class="calibre27"><span><span><span>We can specify more than one forwarding by only logging as a superuser on the remote host lets us bind a remote privileged port. If this is not specified, <kbd class="calibre9">local_address</kbd> is bound to the loop-back device. And if no remote host is specified, or <kbd class="calibre9">*</kbd> is used, then the forwarded port will be accessible on all interfaces on the remote host. To specify a remote address, we must enable the directive <kbd class="calibre9">GatewayPorts</kbd> in <kbd class="calibre9">sshd_config</kbd>.</span></span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">ServerAliveCountMax</kbd>:<span> Defines the maximum number of server alive messages without receiving a reply from the remote host. Once the threshold is hit, the session is disconnected. These kinds of messages are way different from the <kbd class="calibre9">TCPKeepAlive</kbd> messages: the first one is sent over the encrypted channel, and so is not spoofable, while the second is in clear and can be spoofed. Defaults to <kbd class="calibre9">3</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ServerAliveInterval</kbd>:<span> Defines a timeout in seconds, after which the client will send a message through the secure channel. Defines a timeout in seconds after which if no data have been received the client will send a message to the server  through the secure channel requesting a response. Defaults to <kbd class="calibre9">0</kbd>, meaning that no messages will ever be sent.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">StrictHostKeyChecking</kbd>:<span> If this is set to <kbd class="calibre9">yes</kbd>, two things will happen:</span></span></span>
<ul class="calibre23">
<li class="calibre13"><span><span><span>The client will never automatically add a host key to the <kbd class="calibre9">~/.ssh/known_hosts</kbd> file.</span></span></span></li>
<li class="calibre13"><span><span><span>The client will refuse to connect to a remote host whose key has changed from the one stored in the <kbd class="calibre9">known_hosts</kbd> file.</span></span></span></li>
</ul>
</li>
</ul>
<p class="calibre32"><span><span><span>If this is set to <kbd class="calibre9">yes</kbd>, the client will automatically add the new keys while if set to ask, which is the default value the client will ask the user to confirm the addition of the key to the <kbd class="calibre9">known_hosts</kbd> file.</span></span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">TCPKeepAlive</kbd>:<span> Enables/disables the keepalive messages sent by the client to the remote host. Defaults to <kbd class="calibre9">yes</kbd> ; and this will allow the client to detect network disconnections or remote host crashing. It is largely used in scripts for unattended disconnection detection.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">Tunnel</kbd>: <span>Enables forwarding between the client and the remote host for the tun device. Arguments can be <kbd class="calibre9">yes</kbd>, <kbd class="calibre9">point-to-point</kbd>, <kbd class="calibre9">ethernet</kbd> , or <kbd class="calibre9">no</kbd>. Defaults to <kbd class="calibre9">yes</kbd> , which enables the default point-to-point mode.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">TunnelDevice</kbd>:<span> Defines which tun devices to open both for the client and the remote host. The argument is specified as </span></span></span><kbd class="calibre9"><span><span><span>client_tun:[host_tun]</span></span></span></kbd>.</li>
</ul>
<p class="calibre32"><span><span><span>Devices can be addressed by their numerical ID or using <kbd class="calibre9">any</kbd> , which will force the usage of the next available tun device. If no <kbd class="calibre9">host_tun</kbd> is defined, it defaults to <kbd class="calibre9">any</kbd>. The default is <kbd class="calibre9">any:any</kbd>.</span></span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">UsePrivilegedPort</kbd>:<span> Enables/disables the usage of a privileged port of the outgoing connection. If it is set to <kbd class="calibre9">yes</kbd>, ssh must be <kbd class="calibre9">setuid root</kbd> since this is the only user who is able to use privileged ports. Defaults to <kbd class="calibre9">no</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">User</kbd>:<span> Specifies the username of the remote account to log in.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">UserKnownHostsFile</kbd>:<span> Defines one or more files for the user's <kbd class="calibre9">host_key</kbd> database. If more than one file is specified, it must be separated by a whitespace. Defaults to <kbd class="calibre9">~/.ssh/known_hosts</kbd>, <kbd class="calibre9">~/.ssh/known_hosts2</kbd>.</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">TOKENS</kbd>:<span> We referred to them in some of the configuration directives, and these are special character combinations that can be expanded during the SSH session:</span></span></span>
<ul class="calibre23">
<li class="calibre13"><span><span><kbd class="calibre9">%%</kbd>: This <span>is expanded to a literal <kbd class="calibre9">%</kbd></span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%C</kbd>: <span>Short for <kbd class="calibre9">%l%h%p%r</kbd></span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%d</kbd>: <span>Expands to the home directory of the user on the client side</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%h</kbd>: <span>This is the hostname of the remote host</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%i</kbd>: <span>Expands to the local user ID</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%L</kbd>: <span>Hostname of the client</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%l</kbd>: <span>Hostname of the client, domain included, including the domain name</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%n</kbd>: <span>Original hostname of the remote host as given on the command line</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%p</kbd>: <span>Port on the remote host</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%r</kbd>: <span>Username on the remote host</span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">%u</kbd>: <span>Username on the client side</span></span></span></li>
</ul>
</li>
</ul>
<p class="calibre1"><span><span><span>These tokens are accepted in a different extent as arguments to different configuration directives:</span></span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">Match exec</kbd> <span>makes use of <kbd class="calibre9">%%</kbd>, <kbd class="calibre9">%h</kbd>, <kbd class="calibre9">%L</kbd>, <kbd class="calibre9">%l</kbd>, <kbd class="calibre9">%n</kbd>, <kbd class="calibre9">%p</kbd>, <kbd class="calibre9">%r</kbd>, <kbd class="calibre9">%u</kbd></span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">CertificateFile</kbd> <span>makes use of <kbd class="calibre9">%%</kbd>, <kbd class="calibre9">%d</kbd>, <kbd class="calibre9">%h</kbd>, <kbd class="calibre9">%l</kbd>, <kbd class="calibre9">%r</kbd>, and <kbd class="calibre9">%u</kbd></span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ControlPath</kbd> <span>makes use of <kbd class="calibre9">%%</kbd>, <kbd class="calibre9">%C</kbd>, <kbd class="calibre9">%h</kbd>, <kbd class="calibre9">%i</kbd>, <kbd class="calibre9">%L</kbd>, <kbd class="calibre9">%l</kbd>, <kbd class="calibre9">%n</kbd>, <kbd class="calibre9">%p</kbd>, <kbd class="calibre9">%r</kbd>, <kbd class="calibre9">%u</kbd></span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">HostName</kbd> <span>makes use of <kbd class="calibre9">%%</kbd> and <kbd class="calibre9">%h</kbd></span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">IdentityAgent</kbd> <span>and</span> <kbd class="calibre9">IdentityFile</kbd> <span>make use of <kbd class="calibre9">%%</kbd>, <kbd class="calibre9">%d</kbd>, <kbd class="calibre9">%h</kbd>, <kbd class="calibre9">%l</kbd>, <kbd class="calibre9">%r</kbd>, <kbd class="calibre9">%u</kbd></span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">LocalCommand</kbd> <span>makes use of <kbd class="calibre9">%%</kbd>, <kbd class="calibre9">%C</kbd>, <kbd class="calibre9">%d</kbd>, <kbd class="calibre9">%h</kbd>, <kbd class="calibre9">%l</kbd>, <kbd class="calibre9">%n</kbd>, <kbd class="calibre9">%p</kbd>, <kbd class="calibre9">%r</kbd>, <kbd class="calibre9">%u</kbd></span></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ProxyCommand</kbd> <span>makes use of <kbd class="calibre9">%%</kbd>, <kbd class="calibre9">%h</kbd>, <kbd class="calibre9">%p</kbd>, and <kbd class="calibre9">%r</kbd></span></span></span></li>
</ul>
<p class="calibre1"><span><span><span>Some of the directives that we listed for <kbd class="calibre9">sshd_config</kbd> , which were also available on the <kbd class="calibre9">ssh_config</kbd> file, were omitted for brevity's sake. We tried to be as tidy as possible before going to the next paragraph, where you will learn how to create passwordless connections using some of the directives that we just examined so far.</span></span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Passwordless connections</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>One of the most useful features in the everyday life of a Linux user is the ability to connect to remote servers without the burden of remembering all the addresses, ports, users, and passwords. Well, if one resorts to using some kind of client such as Putty, it can store all these details in a connection snippet. We can recall when we need to log in to a remote host, but Linux offers a more <em class="calibre20">native</em> and practical way to reach this goal. We are talking about passwordless connections, which means we just ssh to a host alias and we are in, no questions asked, and nothing other than an alias to remember.</span></span></p>
<p class="calibre1"><span><span>What do we need to set up such a nice connection method? We have  a few actors in place: we have to check the server setup, generate some keys, and configure the client.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the server</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Let's start from the server opening the </span></span><span><span><kbd class="calibre9">/etc/ssh/ssd_config</kbd>  </span></span><span><span>file and checking the following configuration directives:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Port 22</strong>
</pre>
<p class="calibre1"><span><span>Let's start with the port. The standard port for the SSH service is <kbd class="calibre9">22</kbd> , and it is at this value that most of the script kiddies around will probe your SSH daemon with some automated tools; so if you have a server publicly available, change the value to an unprivileged port such as <kbd class="calibre9">9527</kbd> . Thus, a lot of these attacks will simply be ineffective:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#ListenAddress ::<br class="title-page-name"/></strong><strong class="calibre2">#ListenAddress 0.0.0.0</strong>
</pre>
<p class="calibre1"><span><span>If we need to bind the service to a specific address on our server, this is the directive we need to work on; we simply uncomment and fill in the appropriate value:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Protocol 2</strong>
</pre>
<p class="calibre1"><span><span>We do not think to use version 1 of the protocol, not even as a second choice. We stay safe and go along protocol version 2:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># HostKeys for protocol version 2<br class="title-page-name"/></strong><strong class="calibre2">HostKey /etc/ssh/ssh_host_rsa_key<br class="title-page-name"/></strong><strong class="calibre2">HostKey /etc/ssh/ssh_host_dsa_key<br class="title-page-name"/></strong><strong class="calibre2">HostKey /etc/ssh/ssh_host_ecdsa_key<br class="title-page-name"/></strong><strong class="calibre2">HostKey /etc/ssh/ssh_host_ed25519_key</strong>
</pre>
<p class="calibre1"><span><span>Ever wondered where the system-wide host keys are? Here, they are, and we can also decide to change names and path if we need to.</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#Privilege Separation is turned on for security<br class="title-page-name"/></strong><strong class="calibre2">UsePrivilegeSeparation yes</strong>
</pre>
<p class="calibre1"><span><span>Definitely! We want to work with unprivileged processes so that no super user privileges can be exploited.</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Authentication:</strong><br class="title-page-name"/><strong class="calibre2">LoginGraceTime 120</strong>
</pre>
<p class="calibre1"><span><span>Just give us some time to log in.</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#PermitRootLogin without-password<br class="title-page-name"/></strong><strong class="calibre2">PermitRootLogin yes</strong>
</pre>
<p class="calibre1"><span><span>One safe practice is to limit the log in to the root account on a remote host to key-based authentication. This way, an intruder will not able to break in by just guessing a password; he will need the client's secret key to enter, and the key is safely stored on our client, not on the server. Anyway, if we want to remotely set up a passwordless authentication for the root account, we must allow root logins with passwords. Once we are sure everything works, we will restrict</span></span> without-password.</p>
<pre class="codepackt">
<strong class="calibre2">StrictModes yes</strong>
</pre>
<p class="calibre1"><span><span>It is so easy to forget some world-writable permission on the home directory or on our ssh configuration files and keys, so better to enable this directive; and it will prevent us to log in if the home directory of the remote user we log in has some unsafe permissions set.</span></span></p>
<pre class="codepackt">
<strong class="calibre2">PubkeyAuthentication yes</strong>
</pre>
<p class="calibre1"><span><span>Well, we are working on that so better to be sure this is set to <kbd class="calibre9">yes</kbd>.</span></span></p>
<pre class="codepackt">
<strong class="calibre2">AuthorizedKeysFile %h/.ssh/authorized_keys</strong>
</pre>
<p class="calibre1"><span><span>Let's note down where our public key must be stored. The token tells us they are in the <kbd class="calibre9">.ssh</kbd> directory inside the home of the accounts the file <kbd class="calibre9">authorized_keys</kbd> is in the home directory of the account we used to login into the system.</span></span></p>
<pre class="codepackt">
<strong class="calibre2">HostbasedAuthentication no</strong>
</pre>
<p class="calibre1"><span><span>Just for safety, let's ditch the host authentication:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">PermitEmptyPasswords no </strong>
</pre>
<p class="calibre1"><span><span>Let's check this. We must never switch this to yes unless we want logins without passwords. But who would want this?</span></span></p>
<pre class="codepackt">
<strong class="calibre2">UsePAM yes</strong>
</pre>
<p class="calibre1"><span><span>There are a few reasons why we would like to set this to <kbd class="calibre9">yes</kbd>. One is that, with this on, the SSH daemon cannot be run as root; and this is a safe option.</span></span></p>
<p class="calibre1"><span><span>Once we have the config bits in place, let's check that we also have the host keys that we need to proof the server identity to the client. As we can read from the configuration file, on the remote host, we should have a key for each algorithm supported in </span></span><span><kbd class="calibre9">/etc/ssh</kbd></span><span><span>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ls -lah /etc/ssh/<br class="title-page-name"/></strong><strong class="calibre2">total 296K<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 root root 4.0K Apr 16 07:32 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 129 root root 12K Apr 17 04:00 ..<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 237K Jul 22 2016 moduli<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 1.7K Jul 22 2016 ssh_config<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 2.6K Apr 16 07:32 sshd_config<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 668 Apr 16 07:20 ssh_host_dsa_key<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 601 Apr 16 07:20 ssh_host_dsa_key.pub<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 227 Apr 16 07:20 ssh_host_ecdsa_key<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 173 Apr 16 07:20 ssh_host_ecdsa_key.pub<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 399 Apr 16 07:20 ssh_host_ed25519_key<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 93 Apr 16 07:20 ssh_host_ed25519_key.pub<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 1.7K Apr 16 07:20 ssh_host_rsa_key<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 393 Apr 16 07:20 ssh_host_rsa_key.pub</strong>
</pre>
<p class="calibre1"><span><span>There they are! So, we are fine. They usually get created when we install the OpenSSH server from our distribution packages, but we can also decide to create our very own host key. Let's see how. First, let's have a look at the fingerprint of one of the keys:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ssh-keygen -f /etc/ssh/ssh_host_ecdsa_key.pub -l<br class="title-page-name"/></strong><strong class="calibre2">256 fe:23:d3:9b:8a:80:30:ad:0d:ac:81:fa:ba:3f:6f:56 /etc/ssh/ssh_host_ecdsa_key.pub (ECDSA)</strong>
</pre>
<p class="calibre1"><span><span>We used ssh-keygen, a utility which does a lot of things, from creating a key to modifying it or, as in this case, having a look at it. The first field of the resulting sting tells us the bit length of the key, the second sports the actual key, the third points to the file holding this key, and finally comes the encryption method.</span></span></p>
<div class="packt_figure"><img class="image-border2" src="../images/00045.jpeg"/></div>
<div class="packt_figref"><span><span>Using the -lv options will give you a nice ASCII fingerprint of the key</span></span></div>
<p class="calibre1"><span><span>But let's say we do not trust the existing keys, and we want to create a new pair set of them:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# cd /etc/ssh<br class="title-page-name"/></strong><strong class="calibre2">root:# ssh-keygen -A<br class="title-page-name"/></strong><strong class="calibre2">ssh-keygen: generating new host keys: RSA1 RSA DSA ECDSA ED25519</strong>
</pre>
<p class="calibre1"><span><span>Is this easy? Yes, it is:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ls -lh ssh_h*<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 668 Apr 24 06:13 ssh_host_dsa_key<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 601 Apr 24 06:13 ssh_host_dsa_key.pub<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 227 Apr 24 06:13 ssh_host_ecdsa_key<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 173 Apr 24 06:13 ssh_host_ecdsa_key.pub<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 399 Apr 24 06:13 ssh_host_ed25519_key<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 93 Apr 24 06:13 ssh_host_ed25519_key.pub<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 976 Apr 24 06:13 ssh_host_key<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 641 Apr 24 06:13 ssh_host_key.pub<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 1.7K Apr 24 06:13 ssh_host_rsa_key<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 root root 393 Apr 24 06:13 ssh_host_rsa_key.pub</strong>
</pre>
<p class="calibre1"><span><span>Here are the new key files; let's check the same key again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ssh-keygen -f /etc/ssh/ssh_host_ecdsa_key.pub -l<br class="title-page-name"/></strong><strong class="calibre2">256 24:4d:3e:6b:f4:0f:4b:bf:56:b9:b5:c4:b6:ab:c6:7b /etc/ssh/ssh_host_ecdsa_key.pub (ECDSA)</strong>
</pre>
<p class="calibre1"><span><span>The two keys are different:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">24:4d:3e:6b:f4:0f:4b:bf:56:b9:b5:c4:b6:ab:c6:7b<br class="title-page-name"/></strong><strong class="calibre2">fe:23:d3:9b:8a:80:30:ad:0d:ac:81:fa:ba:3f:6f:56</strong>
</pre>
<p class="calibre1"><span><span>We took advantage of the <kbd class="calibre9">-A</kbd> option of ssh-keygen, which automatically creates a missing key for each type (<kbd class="calibre9">rsa1</kbd>, <kbd class="calibre9">rsa</kbd>, <kbd class="calibre9">dsa</kbd>, <kbd class="calibre9">ecdsa</kbd>, and <kbd class="calibre9">ed25519</kbd>). The keys are created with the default bit size, with no password, and with the default comments. Now, let's say again that we want to create our very own <kbd class="calibre9">ecdsa</kbd> host key pair:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ssh-keygen -t ecdsa -a 1000 -b 521 -C "My hand crafted key" -f /etc/ssh/ssh_host_crafted_ecdsa -o<br class="title-page-name"/></strong><strong class="calibre2">Generating public/private ecdsa key pair.<br class="title-page-name"/></strong><strong class="calibre2">Enter passphrase (empty for no passphrase): <br class="title-page-name"/></strong><strong class="calibre2">Enter same passphrase again: <br class="title-page-name"/></strong><strong class="calibre2">Your identification has been saved in /etc/ssh/ssh_host_crafted_ecdsa.<br class="title-page-name"/></strong><strong class="calibre2">Your public key has been saved in /etc/ssh/ssh_host_crafted_ecdsa.pub.<br class="title-page-name"/></strong><strong class="calibre2">The key fingerprint is:<br class="title-page-name"/></strong><strong class="calibre2">28:74:b2:e6:a1:e5:6d:cd:ca:e7:f2:47:86:6d:39:d6 My hand crafted key<br class="title-page-name"/></strong><strong class="calibre2">The key's randomart image is:<br class="title-page-name"/></strong><strong class="calibre2">+---[ECDSA 521]---+<br class="title-page-name"/></strong><strong class="calibre2">|                 |<br class="title-page-name"/></strong><strong class="calibre2">|                 |<br class="title-page-name"/></strong><strong class="calibre2">|    o .          |<br class="title-page-name"/></strong><strong class="calibre2">|   . + .         |<br class="title-page-name"/></strong><strong class="calibre2">|     * . So o    |<br class="title-page-name"/></strong><strong class="calibre2">|    * + o. O E   |<br class="title-page-name"/></strong><strong class="calibre2">|   . o o o= .    |<br class="title-page-name"/></strong><strong class="calibre2">|     o... .      |<br class="title-page-name"/></strong><strong class="calibre2">|      o=o.       |<br class="title-page-name"/></strong><strong class="calibre2">+-----------------+</strong>
</pre>
<div class="packt_figure"><img class="image-border2" src="../images/00046.jpeg"/></div>
<div class="packt_figref"><span><span>Our new ecdsa host key has been created</span></span></div>
<p class="calibre1"><span><span>We created our new host key using some simple options:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">-t</kbd>: This selects the type of the <kbd class="calibre9">keyboard-interactive</kbd></span></span>.</li>
<li class="calibre13"><span><span><kbd class="calibre9">-a</kbd>: This option can be selected when saving a key in the ed25519 format or with any SSH-2 key when the <kbd class="calibre9">-o</kbd> option is selected. It specifies the number of <strong class="calibre2">Key Derivation Function</strong> (<strong class="calibre2">KDF</strong>) rounds to use to encrypt the private password. It makes the passphrase check slower and more resistant to a brute force attack. The higher the integer, the slower the check. It defaults to <kbd class="calibre9">64</kbd> , which is really good; we just got insane with <kbd class="calibre9">1000</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">-b</kbd>: Bit length of the key. Ecdsa can have a size of 256, 384, or 521 bit.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">-C</kbd>: Is a comment you can associate to the key.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">-f</kbd>: Is the path to the file that will hold the new key.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">-o</kbd>: Saves the SSH-2 private key in the new OpenSSH format rather than the usual PEM format. The new format is more resistant to brute force attack, but it is not supported by OpenSSH versions lower than 6.5. The ed25519 keys are always saved in the new format, so they do not require this option on the command line.</span></span></li>
</ul>
<p class="calibre1"><span><span>Now, it is time to make the new key available to the server by adding it to the main sshd configuration file:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">HostKey /etc/ssh/ssh_host_crafted_ecdsa</strong>
</pre>
<p class="calibre1"><span><span>Let's restrict the permissions on the keys:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# chmod 600 *</strong>
</pre>
<p class="calibre1"><span><span>So, no one other than root will be able to access the keys and configuration files:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ls -lah | grep cra<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 751 Apr 24 11:41 ssh_host_crafted_ecdsa<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 root root 225 Apr 24 11:39 ssh_host_crafted_ecdsa.pub</strong>
</pre>
<p class="calibre1"><span><span>We notice two things:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span>We created a private key whose name does not end with <kbd class="calibre9">_key</kbd>. We did this on purpose to differentiate it from the prebuilt keys. The <kbd class="calibre9">key</kbd> filename can be whatever we want, but better give it a meaningful value.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">ssh-keygen</kbd> automatically added a trailing <kbd class="calibre9">.pub</kbd> to the private key file name and used the resulting name for the public key filename.</span></span></li>
</ul>
<div class="packt_infobox"><span class="calibre30">Safe permissions for ssh keys are:<br class="calibre29"/></span><span class="calibre30"><kbd class="calibre28">700</kbd> for the <kbd class="calibre28">.ssh</kbd> directory, and<br class="calibre29"/></span><span class="calibre30"><kbd class="calibre28">600</kbd> for the key files inside the <kbd class="calibre28">.ssh</kbd> directory.</span></div>
<p class="calibre1"><span><span>Now, let's reload or restart the service to get the new key available for the SSH daemon:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# systemctl restart sshd ; systemctl status sshd<br class="title-page-name"/></strong><strong class="calibre2">● ssh.service - OpenBSD Secure Shell server<br class="title-page-name"/></strong><strong class="calibre2">Loaded: loaded (/lib/systemd/system/ssh.service; enabled)<br class="title-page-name"/></strong><strong class="calibre2">Active: active (running) since Mon 2017-04-24 11:40:51 EDT; 5ms ago<br class="title-page-name"/></strong><strong class="calibre2">Process: 30993 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)<br class="title-page-name"/></strong><strong class="calibre2">Main PID: 31265 (sshd)<br class="title-page-name"/></strong><strong class="calibre2">CGroup: /system.slice/ssh.service<br class="title-page-name"/></strong><strong class="calibre2">└─31265 /usr/sbin/sshd -D</strong>
</pre>
<p class="calibre1"><span><span>Wow, it is working, let's see the logs:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# tail -f /var/log/syslog<br class="title-page-name"/></strong><strong class="calibre2">Apr 24 11:40:51 spoton systemd[1]: Stopping OpenBSD Secure Shell server...<br class="title-page-name"/></strong><strong class="calibre2">Apr 24 11:40:51 spoton systemd[1]: Starting OpenBSD Secure Shell server...<br class="title-page-name"/></strong><strong class="calibre2">Apr 24 11:40:51 spoton systemd[1]: Started OpenBSD Secure Shell server.<br class="title-page-name"/></strong><strong class="calibre2">Apr 24 11:40:51 spoton sshd[31265]: Could not load host key: /etc/ssh/ssh_host_crafted_ecdsa</strong>
</pre>
<p class="calibre1"><span><span>We are almost there. The daemon successfully started but refused to load the host key. What happened? Simply, we gave a passphrase during the key creation; and  to load the key, a passphrase must be given but the daemon cannot interact and fill it in. We must remove the passphrase:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ssh-keygen -p -f /etc/ssh/ssh_host_crafted_ecdsa</strong>
</pre>
<p class="calibre1"><span><span>The program will ask for the old password, and when it comes to fill in a new one, let's just hit the <em class="calibre20">Enter</em> key twice so that no password will be added to the private key. Now, let's restart and check:</span></span></p>
<p class="calibre1"><kbd class="calibre9"><span><span>root:# systemctl restart ssh ; systemctl status ssh ; tail -n3 /var/log/syslog</span></span></kbd></p>
<pre class="codepackt">
<strong class="calibre2">● ssh.service - OpenBSD Secure Shell server<br class="title-page-name"/></strong><strong class="calibre2">Loaded: loaded (/lib/systemd/system/ssh.service; enabled)<br class="title-page-name"/></strong><strong class="calibre2">Active: active (running) since Mon 2017-04-24 11:59:32 EDT; 8ms ago<br class="title-page-name"/></strong><strong class="calibre2">Process: 30993 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)<br class="title-page-name"/></strong><strong class="calibre2">Main PID: 31517 (sshd)<br class="title-page-name"/></strong><strong class="calibre2">CGroup: /system.slice/ssh.service<br class="title-page-name"/></strong><strong class="calibre2">└─31517 /usr/sbin/sshd -D<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">Apr 24 11:59:32 spoton systemd[1]: Started OpenBSD Secure Shell server.<br class="title-page-name"/></strong><strong class="calibre2">Apr 24 11:59:32 spoton systemd[1]: Stopping OpenBSD Secure Shell server...<br class="title-page-name"/></strong><strong class="calibre2">Apr 24 11:59:32 spoton systemd[1]: Starting OpenBSD Secure Shell server...<br class="title-page-name"/></strong><strong class="calibre2">Apr 24 11:59:32 spoton systemd[1]: Started OpenBSD Secure Shell server.</strong>
</pre>
<p class="calibre1"><span><span>Now, it is really fine, the key has been loaded.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Preparing the remote account</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Let's use a scenario where we will create a completely new user; whatever we will do here will be applicable to a preexisting user. First, let's create our new user test user on the remote host, and let's configure it so that it will be available through key authentication only:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# useradd -m test_user</strong>
</pre>
<p class="calibre1"><span><span>So, we just created the <kbd class="calibre9">test_user</kbd> account and provided it with a <kbd class="calibre9">home</kbd> directory:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ls -lah /home/test_user/<br class="title-page-name"/></strong><strong class="calibre2">total 20K<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 test_user test_user 4.0K Apr 24 12:50 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 4 root root 4.0K Apr 24 12:50 ..<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 test_user test_user 220 Nov 5 17:22 .bash_logout<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 test_user test_user 3.5K Nov 5 17:22 .bashrc<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 test_user test_user 675 Nov 5 17:22 .profile</strong>
</pre>
<p class="calibre1"><span><span>Notice that there is no <kbd class="calibre9">.ssh</kbd> at the moment. Now, since we do want this account to be accessible only using a key, let's lock it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# passwd -l test_user</strong>
</pre>
<p class="calibre1"><span><span>The <kbd class="calibre9">-l</kbd> option in <kbd class="calibre9">passwd</kbd> locks the account using a nice trick. When we create an account, <kbd class="calibre9">passwd</kbd> asks for it; and then it encrypts the password and writes it into the </span></span><span><kbd class="calibre9">/etc/shadow</kbd> </span><span><span>file, as we can see in a <kbd class="calibre9">shadow</kbd> file before locking:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# root@spoton:~# grep test_user /etc/shadow<br class="title-page-name"/></strong><strong class="calibre2">test_user:$6$yTDup7NC$5eAg6QabTnMvwtqUfbmAcCy74zjHNj6RXafdIEBEmiVyz2DIVkdFgzuuIFuscdAmIBp4B6lqh5tUNfDnK.8Q/1:17280:0:99999:7:::</strong>
</pre>
<p class="calibre1"><span><span>The fields of the <kbd class="calibre9">shadow</kbd> file can be interpreted as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">1ogin name<br class="title-page-name"/></strong><strong class="calibre2">encrypted password<br class="title-page-name"/></strong><strong class="calibre2">date of last password change<br class="title-page-name"/></strong><strong class="calibre2">minimum password age<br class="title-page-name"/></strong><strong class="calibre2">maximum password age<br class="title-page-name"/></strong><strong class="calibre2">password warning period<br class="title-page-name"/></strong><strong class="calibre2">password inactivity period<br class="title-page-name"/></strong><strong class="calibre2">account expiration date<br class="title-page-name"/></strong><strong class="calibre2">reserved field for future use</strong>
</pre>
<p class="calibre1"><span><span>We will not go into the details of each field, a simple <em class="calibre20">man shadow</em> will give us all the information we need. What really matters is the second field holding the encrypted password. When a user tries to log in, the password they provide is encrypted and checked against the second field of the <kbd class="calibre9">/etc/shadow</kbd> file: if they match, the password is correct; if not, then the password is not correct and the user log in is refused. Have a look at the same string after the account has been locked:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# passwd -l test_user<br class="title-page-name"/></strong><strong class="calibre2">test_user:!$6$yTDup7NC$5eAg6QabTnMvwtqUfbmAcCy74zjHNj6RXafdIEBEmiVyz2DIVkdFgzuuIFuscdAmIBp4B6lqh5tUNfDnK.8Q/1:17280:0:99999:7:::</strong>
</pre>
<p class="calibre1"><span><span>There is something new: the password field has <kbd class="calibre9">!</kbd> at the beginning, actually changing its value. And here is the trick: a character such as <kbd class="calibre9">!</kbd> or <kbd class="calibre9">*</kbd> can never be a result of the <kbd class="calibre9">crypt(3)</kbd> function used by <kbd class="calibre9">passwd</kbd> to encrypt the user password, so adding an exclamation mark makes the value unmatchable. Whatever value the user fills in, <kbd class="calibre9">passwd</kbd> will never be able to generate an exclamation mark; so, practically, the account is locked.</span></span></p>
<p class="calibre1"><span><span>Just for the setup, let's enable the account again with a temporary password:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# passwd test_user<br class="title-page-name"/></strong><strong class="calibre2">Enter new UNIX password: <br class="title-page-name"/></strong><strong class="calibre2">Retype new UNIX password: <br class="title-page-name"/></strong><strong class="calibre2">passwd: password updated successfully</strong>
</pre>
<p class="calibre1"><span><span>We need to log in with a password to copy over our client public identity key. Once done, we will lock the account again.</span></span></p>
<p class="calibre1"><span><span>So, now we have a username we can use and a port: <kbd class="calibre9">9999</kbd>. We can jump back to the client and create our configuration.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the client</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Back to our client; let's enter the <kbd class="calibre9">home</kbd> directory of the user we want to set up the connection for. Let's say that </span></span><kbd class="calibre9">local_user</kbd> <span><span>wants to connect as <kbd class="calibre9">test_user</kbd> on the remote host called <strong class="calibre2">spoton</strong>.</span></span></p>
<p class="calibre1"><span><span>Let's go to the <kbd class="calibre9">local_user</kbd> home directory, </span></span><span><span><kbd class="calibre9">local_user:~$ cd /home/local_user</kbd>, </span></span><span><span>and have a look at what is inside it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ls -lah<br class="title-page-name"/></strong><strong class="calibre2">total 20K<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 local_user local_user 4.0K Apr 24 18:34 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 4 root root 4.0K Apr 24 18:34 ..<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 local_user local_user 220 Nov 15 18:49 .bash_logout<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 local_user local_user 3.5K Nov 15 18:49 .bashrc<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 local_user local_user 675 Nov 15 18:49 .profile</strong>
</pre>
<p class="calibre1"><span><span>Well, the usual file for a new account, but there is a problem:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# egrep IdentityFile /etc/ssh/ssh_config <br class="title-page-name"/></strong><strong class="calibre2"># IdentityFile ~/.ssh/identity<br class="title-page-name"/></strong><strong class="calibre2"># IdentityFile ~/.ssh/id_rsa<br class="title-page-name"/></strong><strong class="calibre2"># IdentityFile ~/.ssh/id_dsa<br class="title-page-name"/></strong><strong class="calibre2"># IdentityFile ~/.ssh/id_ecdsa<br class="title-page-name"/></strong><strong class="calibre2"># IdentityFile ~/.ssh/id_ed25519</strong>
</pre>
<p class="calibre1"><span><span>We have no identity file set, so we need to uncomment one of those lines; and if we want, we can also change the file name. For now, we will just add this line to the <kbd class="calibre9">ssh_config</kbd> file:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">IdentityFile ~/.ssh/id_ecdsa_to_spoton</strong>
</pre>
<p class="calibre1"><span><span>We just modified the file name to make it clear that it will be used for the remote host named spoton. We could have different identity files for connecting to more than one remote server or as different users to the same server. So, it is better to find a meaningful name for the key file, one that will remind us what it is used for. Now that we have a reference in the client config file, we must create the <kbd class="calibre9">.ssh</kbd> directory:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ mkdir .ssh</strong>
</pre>
<p class="calibre1"><span><span>Set the right access permissions:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ chmod 700 .ssh</strong>
</pre>
<p class="calibre1"><span><span>Now, let's enter the <kbd class="calibre9">.ssh</kbd> directory and create our key; to keep things easy, we will not force a password on the private key:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ssh-keygen -t ecdsa -a 64 -b 384 -C "Key for test_user on spoton" -f id_ecdsa_to_spoton -o<br class="title-page-name"/></strong><strong class="calibre2">Generating public/private ecdsa key pair.<br class="title-page-name"/></strong><strong class="calibre2">Enter passphrase (empty for no passphrase): <br class="title-page-name"/></strong><strong class="calibre2">Enter same passphrase again: <br class="title-page-name"/></strong><strong class="calibre2">Your identification has been saved in id_to_spoton.<br class="title-page-name"/></strong><strong class="calibre2">Your public key has been saved in id_to_spoton.pub.<br class="title-page-name"/></strong><strong class="calibre2">The key fingerprint is:<br class="title-page-name"/></strong><strong class="calibre2">SHA256:ZhJMqQ19CpCIB3d9KEaVUhH5ngyOP8LDqGxxkvj967M Key for test_user on spoton<br class="title-page-name"/></strong><strong class="calibre2">The key's randomart image is:<br class="title-page-name"/></strong><strong class="calibre2">+---[ECDSA 384]---+<br class="title-page-name"/></strong><strong class="calibre2">|ooo+o=*B         |<br class="title-page-name"/></strong><strong class="calibre2">|o.o.*oB o        |<br class="title-page-name"/></strong><strong class="calibre2">| . . Bo=         |<br class="title-page-name"/></strong><strong class="calibre2">| . +..           |<br class="title-page-name"/></strong><strong class="calibre2">|. . o.+S.        |<br class="title-page-name"/></strong><strong class="calibre2">|.+ .. .++        |<br class="title-page-name"/></strong><strong class="calibre2">| .+= .           |<br class="title-page-name"/></strong><strong class="calibre2">|..o * +          |<br class="title-page-name"/></strong><strong class="calibre2">|oo =E=           |<br class="title-page-name"/></strong><strong class="calibre2">+----[SHA256]-----+</strong>
</pre>
<p class="calibre1"><span><span>We used a smaller key size of 384, since at 512, we can face some issues and the key can be refused with a message like this from the client when invoking it with the <kbd class="calibre9">-vvv</kbd> option:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">debug2: input_userauth_pk_ok: fp SHA256:Y7KP6aAFrbzNYYMZLTAiFf71yiE8mzgfzZ6FnrDC964<br class="title-page-name"/></strong><strong class="calibre2">debug3: sign_and_send_pubkey: ECDSA SHA256:Y7KP6aAFrbzNYYMZLTAiFf71yiE8mzgfzZ6FnrDC964<br class="title-page-name"/></strong><strong class="calibre2">Load key "/home/local_user/.ssh/id_ecdsa_to_spoton": invalid format</strong>
</pre>
<p class="calibre1"><span><span>Now, we have a key pair, one public, and one private:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ls -lah<br class="title-page-name"/></strong><strong class="calibre2">total 16K<br class="title-page-name"/></strong><strong class="calibre2">drw------- 2 root root 4.0K Apr 24 19:50 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 3 local_user local_user 4.0K Apr 24 18:52 ..<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 local_user local_user 634 Apr 24 19:44 id_ecdsa_to_spoton<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 local_user local_user 233 Apr 24 19:44 id_ecdsa_to_spoton.pub</strong>
</pre>
<p class="calibre1"><span><span>The access rights are not good for the pub key, so better fix it to a safer <kbd class="calibre9">600</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ chmod 600 *</strong>
</pre>
<p class="calibre1"><span><span>Now, as we already know, the private key must be kept safe on the client; but we must copy the public key over the remote host, and add it to </span></span><kbd class="calibre9">~/.ssh/authorized_keys</kbd><span> </span><span><span>of</span></span> <kbd class="calibre9">test_user</kbd><span><span>.</span></span></p>
<p class="calibre1"><span><span>We have actually two ways to do it.</span></span></p>
<p class="calibre1"><span><span>Manually, copy the public key over to the remote server; copy it into the authorized_keys file and fix the access rights. Or, you can use the </span></span><span><kbd class="calibre9">ssh-copy-id</kbd> </span><span><span>utility.</span></span></p>
<p class="calibre1"><span><span>Let's use this second method:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ssh-copy-id -iid_ecdsa_to_spoton.pub -p 9999 test_user@192.168.0.5<br class="title-page-name"/></strong><strong class="calibre2">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "id_ecdsa_to_spoton.pub"<br class="title-page-name"/></strong><strong class="calibre2">The authenticity of host '[192.168.0.5]:9999 ([192.168.0.5]:9999)' can't be established.<br class="title-page-name"/></strong><strong class="calibre2">ECDSA key fingerprint is SHA256:LPSZkMIYkaMJXXnD6GvUGFMAjL6yM6pZwVRUojqmhGw.<br class="title-page-name"/></strong><strong class="calibre2">Are you sure you want to continue connecting (yes/no)? yes<br class="title-page-name"/></strong><strong class="calibre2">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed<br class="title-page-name"/></strong><strong class="calibre2">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys<br class="title-page-name"/></strong><strong class="calibre2">test_user@192.168.0.5's password: <br class="title-page-name"/></strong><strong class="calibre2">Number of key(s) added: 1</strong>
</pre>
<p class="calibre1"><span><span>Now try logging in to the machine:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">"ssh -p '9999' 'test_user@192.168.0.5'"</strong>
</pre>
<p class="calibre1"><span><span>Check to make sure that only the key(s) you wanted were added.</span></span></p>
<p class="calibre1"><span><span>Everything seems fine, so let's connect to the remote system as <kbd class="calibre9">test_user</kbd> using the password we set. Check that in the home directory inside the <kbd class="calibre9">.ssh</kbd> subdirectory, there is an <kbd class="calibre9">authorized_keys</kbd> file with our public key inside:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">test_user@spoton:~/.ssh$ cd .ssh/<br class="title-page-name"/></strong><strong class="calibre2">test_user@spoton:~/.ssh$ ls -lah<br class="title-page-name"/></strong><strong class="calibre2">total 12K<br class="title-page-name"/></strong><strong class="calibre2">drwx------ 2 test_user test_user 4.0K Apr 24 14:05 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 3 test_user test_user 4.0K Apr 24 14:05 ..<br class="title-page-name"/></strong><strong class="calibre2">-rw------- 1 test_user test_user 281 Apr 24 14:05 authorized_keys</strong>
</pre>
<p class="calibre1"><span><span>The file is actually there with the correct access settings. Let's have a look inside it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">test_user@spoton:~/.ssh$ cat authorized_keys <br class="title-page-name"/></strong><strong class="calibre2">ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQAAAAIbmlzdHAzODQAAABhBPlnKFqWXsCj47zKtrZzqj8PUuAvFlpTPzTJ4faHF1Fb2YJkI4Ywc4gmRig/hz+0kAXtanla4pMQtE6NqwyNheqo5rru8czRM9jRigqN8UwF7yZNf0LMxYV2aFCzrGcz6g== Key for test_user on spoton</strong>
</pre>
<p class="calibre1"><span><span>It looks like the right key; let's log out and have a look at the <kbd class="calibre9">local_user</kbd> public identity key:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ cat id_ecdsa_to_spoton.pub <br class="title-page-name"/></strong><strong class="calibre2">ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQAAAAIbmlzdHAzODQAAABhBPlnKFqWXsCj47zKtrZzqj8PUuAvFlpTPzTJ4faHF1Fb2YJkI4Ywc4gmRig/hz+0kAXtanla4pMQtE6NqwyNheqo5rru8czRM9jRigqN8UwF7yZNf0LMxYV2aFCzrGcz6g== Key for test_user on spoton</strong>
</pre>
<p class="calibre1"><span><span>So, we just have to try the connection to the remote host using the identity file we created; but first, we have to make sure we allowed the port called <kbd class="calibre9">9999</kbd> on the remote host. Once we are sure that nothing is in between, we can just issue on the client side:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ssh -i /home/local_user/.ssh/id_ecdsa_to_spoton -p 9999 test_user@192.168.0.5<br class="title-page-name"/></strong><strong class="calibre2">The programs included with the Debian GNU/Linux system are free software;<br class="title-page-name"/></strong><strong class="calibre2">the exact distribution terms for each program are described in the </strong><strong class="calibre2">individual files in /usr/share/doc/*/copyright.<br class="title-page-name"/></strong><strong class="calibre2">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent </strong><strong class="calibre2">permitted by applicable law.<br class="title-page-name"/></strong><strong class="calibre2">Last login: Mon Apr 24 14:54:43 2017 from moveaway.hereiam<br class="title-page-name"/></strong><strong class="calibre2">test_user@spoton:~$ </strong>
</pre>
<p class="calibre1"><span><span>That's it! We just logged in without any passwords, but this is still cumbersome. You have to point to the identity file and remember the port and the address. Not really handy, but we can improve our experience by taking advantage of the local configuration file that the client expects inside the <kbd class="calibre9">.ssh</kbd> directory of the local account. So, inside </span></span><span><kbd class="calibre9">/home/local_user/.ssh</kbd>, l</span><span><span>et's create a file called </span></span><kbd class="calibre9"><span><span>config</span></span></kbd> <span><span>and write the following directives:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Host *<br class="title-page-name"/></strong><strong class="calibre2">UserKnownHostsFile /dev/null<br class="title-page-name"/></strong><strong class="calibre2">StrictHostKeyChecking no<br class="title-page-name"/></strong><strong class="calibre2">IdentitiesOnly yes <br class="title-page-name"/></strong><strong class="calibre2">Host spoton<br class="title-page-name"/></strong><strong class="calibre2">AddressFamily inet<br class="title-page-name"/></strong><strong class="calibre2">ConnectionAttempts 10<br class="title-page-name"/></strong><strong class="calibre2">ForwardAgent no<br class="title-page-name"/></strong><strong class="calibre2">ForwardX11 no<br class="title-page-name"/></strong><strong class="calibre2">ForwardX11Trusted no<br class="title-page-name"/></strong><strong class="calibre2">GatewayPorts yes<br class="title-page-name"/></strong><strong class="calibre2">HostBasedAuthentication no<br class="title-page-name"/></strong><strong class="calibre2">HostKeyAlias spotalias<br class="title-page-name"/></strong><strong class="calibre2">HostName 192.168.0.5<br class="title-page-name"/></strong><strong class="calibre2">IdentityFile ~/.ssh/id_ecdsa_to_spoton<br class="title-page-name"/></strong><strong class="calibre2">PasswordAuthentication no<br class="title-page-name"/></strong><strong class="calibre2">Port 9999<br class="title-page-name"/></strong><strong class="calibre2">Protocol 2<br class="title-page-name"/></strong><strong class="calibre2">Compression yes<br class="title-page-name"/></strong><strong class="calibre2">CompressionLevel 9<br class="title-page-name"/></strong><strong class="calibre2">ServerAliveCountMax 3<br class="title-page-name"/></strong><strong class="calibre2">ServerAliveInterval 15<br class="title-page-name"/></strong><strong class="calibre2">TCPKeepAlive no<br class="title-page-name"/></strong><strong class="calibre2">User test_user</strong>
</pre>
<p class="calibre1"><span><span>We have two sections, one of which applies to any host and one more specific for the host -spoton. Any time we want to add another host, we just have to copy and paste the host specific section, change the <kbd class="calibre9">Host</kbd>, <kbd class="calibre9">HostKeyAlias</kbd>, <kbd class="calibre9">Hostname</kbd>, <kbd class="calibre9">IdentityFile</kbd>, <kbd class="calibre9">User</kbd></span></span>,<span><span> and, if needed, <kbd class="calibre9">Port</kbd> and that is all. The config file will grow with specific sections and our connections will be simply as follows:</span></span></p>
<pre class="codepackt">
<span><span>l<strong class="calibre2">ocal_user:~$ ssh spoton<br class="title-page-name"/></strong></span></span><strong class="calibre2">Warning: Permanently added 'spotalias,[192.168.0.5]:9999' (ECDSA) to the list of known hosts.<br class="title-page-name"/></strong><strong class="calibre2">The programs included with the Debian GNU/Linux system are free software;<br class="title-page-name"/></strong><strong class="calibre2">the exact distribution terms for each program are described in the<br class="title-page-name"/></strong><strong class="calibre2">individual files in /usr/share/doc/*/copyright.<br class="title-page-name"/></strong><strong class="calibre2">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent </strong><strong class="calibre2">permitted by applicable law.<br class="title-page-name"/></strong><strong class="calibre2">Last login: Mon Apr 24 15:25:41 2017 from moveaway.hereiam</strong>
</pre>
<p class="calibre1"><span><span>That's all, it is just matter to invoke SSH with the alias specified in <kbd class="calibre9">Host</kbd> and we connect, no passwords, ports, addresses, or identity files were requested. Last bit, let's lock the remote user:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# passwd -l test_user<br class="title-page-name"/></strong><strong class="calibre2">passwd: password expiry information changed.</strong>
</pre>
<p class="calibre1"><span><span>Now, let's check the account status:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# passwd -S test_user<br class="title-page-name"/></strong><strong class="calibre2">test_user L 04/24/2017 0 99999 7 -1</strong>
</pre>
<p class="calibre1"><span><span>The <kbd class="calibre9">L</kbd> shows us that the account is locked. So, we can go back to the client and try to connect again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ssh spoton<br class="title-page-name"/></strong><strong class="calibre2">Warning: Permanently added 'spotalias,[192.168.0.5]:9999' (ECDSA) to the list of known hosts.<br class="title-page-name"/></strong><strong class="calibre2">The programs included with the Debian GNU/Linux system are free software;<br class="title-page-name"/></strong><strong class="calibre2">the exact distribution terms for each program are described in the </strong><strong class="calibre2">individual files in /usr/share/doc/*/copyright.<br class="title-page-name"/></strong><strong class="calibre2">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent </strong><strong class="calibre2">permitted by applicable law.<br class="title-page-name"/></strong><strong class="calibre2">Last login: Mon Apr 24 15:31:16 2017 from moveaway.hereiam</strong>
</pre>
<p class="calibre1"><span><span>Here we are. The remote <kbd class="calibre9">test_user</kbd> account is locked, no one can use it locally or from a remote connection using a password. No one except the one who has the right private key; in this case, on our client called <kbd class="calibre9">local_user</kbd> .</span></span></p>
<p class="calibre1"><span><span>We can play so many tricks with ssh that you could write an entire book on it, but we will limit our fun to a couple of nice functions offered by this tool. Proxying and tunneling we will see in the next paragraph.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Proxies and tunnels</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Let's say we need a quick way to exit our network bypassing the firewall settings. Our machine cannot make any HTTP/HTTPS connection, but we can reach another remote host, which has a free access to the Internet. So, let's see a practical example. First, let's use <kbd class="calibre9">curl</kbd> to grab a remote page:</span></span></p>
<pre class="codepackt">
<span><span>local_user:~$ curl www.packtpublishing.com<br class="title-page-name"/></span></span><span><span>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;<br class="title-page-name"/></span></span><span><span>&lt;html  xml:lang="en"&gt;<br class="title-page-name"/></span></span><span><span>&lt;head&gt;<br class="title-page-name"/></span></span><span><span>&lt;title&gt;Best packtpublishing online&lt;/title&gt;<br class="title-page-name"/></span></span><span><span>&lt;meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /&gt;<br class="title-page-name"/></span></span><span><span>&lt;meta name="description" content="Free best online packtpublishing website" /&gt;<br class="title-page-name"/></span></span><span><span>&lt;meta name="keywords" content="online,packtpublishing,website" /&gt;<br class="title-page-name"/></span></span><span><span>&lt;link rel="stylesheet" type="text/css" href="online.css" media="screen" /&gt;<br class="title-page-name"/></span></span><span><span>&lt;/head&gt;<br class="title-page-name"/></span></span><span><span>&lt;body&gt;<br class="title-page-name"/></span></span><span><span>&lt;div class="wrapper"&gt;<br class="title-page-name"/></span></span><span><span>&lt;div class="top"&gt;&lt;p&gt;packtpublishing info at packtpublishing.com&lt;/p&gt;&lt;/div&gt;<br class="title-page-name"/></span></span><span><span>&lt;div class="header"&gt;&lt;img src="header.png" alt="header"&gt;&lt;/div&gt;<br class="title-page-name"/></span></span><span><span>&lt;div class="column" id="a"&gt;<br class="title-page-name"/><br class="title-page-name"/></span></span><span><span>&lt;h1&gt;Online packtpublishing top website&lt;/h1&gt;<br class="title-page-name"/></span></span><span><span>&lt;br /&gt;<br class="title-page-name"/></span></span><span><span>&lt;a href="inc/online/packtpublishing.php"&gt;&lt;img src="click2.png" alt="login"&gt;&lt;/a&gt;<br class="title-page-name"/></span></span><span><span>&lt;br /&gt;<br class="title-page-name"/></span></span><span><span>&lt;h1&gt;deluxemanager+packtpublishing&lt;img src="ctc.png" alt="@gmail.com" style="float:right;"&gt;&lt;/h1&gt;<br class="title-page-name"/></span></span><span><span>&lt;br /&gt;<br class="title-page-name"/></span></span><span><span>www.packtpublishing.com 2014</span></span><span><span>&lt;br /&gt;<br class="title-page-name"/></span></span><span><span>&lt;/div&gt;<br class="title-page-name"/></span></span><span><span>&lt;/body&gt;<br class="title-page-name"/></span></span><span><span>&lt;/html&gt;</span></span>
</pre>
<p class="calibre1"><span><span>We just grabbed the <a href="https://www.packtpub.com/" class="calibre4">www.packtpub.com</a> home page; nice, isn't it? Now, just for fun, root let's use a simple firewall such as <kbd class="calibre9">ufw</kbd> to block any outgoing connection to port <kbd class="calibre9">80</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ufw deny out 80/tcp<br class="title-page-name"/></strong><strong class="calibre2">Rule added<br class="title-page-name"/></strong><strong class="calibre2">Rule added (v6)</strong>
</pre>
<p class="calibre1"><span><span>Now, let's try to run the <kbd class="calibre9">curl</kbd> command once again; it will hang, since we denied any outgoing connections to any IP on port <kbd class="calibre9">80</kbd>. But now let's give the following command:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ssh -f -N -D 8080 spoton</strong>
</pre>
<p class="calibre1"><span><span><strong class="calibre2">Warning:</strong> Permanently added <kbd class="calibre9">spoton,[192.168.0.5]:9999 (ECDSA)</kbd> to the list of known hosts.</span></span></p>
<p class="calibre1"><span><span>And then:</span></span></p>
<pre class="codepackt">
<span><span>local_user:~$ curl --proxy socks5h://localhost:8080 www.packtpublishing.com<br class="title-page-name"/></span></span><span><span>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;<br class="title-page-name"/></span></span><span><span>&lt;html  xml:lang="en"&gt;<br class="title-page-name"/></span></span><span><span>&lt;head&gt;<br class="title-page-name"/></span></span>…
</pre>
<p class="calibre1"><span><span>We omitted the rest of the HTML code, but it is the same as for the previous <kbd class="calibre9">curl</kbd> command, since we grabbed the same page. What happened? We invoked ssh with some options:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">-f</kbd>: This forces ssh to the background just before the command execution.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">-N</kbd>: This prevents ssh from executing any command on the remote host, since we are just proxying.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">-D</kbd>: Followed by <kbd class="calibre9">[local_address]:port</kbd>, defines a local dynamic port forwarding and allocates a socket to listen for requests. When a connection is made to this port, this is forwarded over the secure connection to the remote host, while the application protocol is used to understand where to connect to from the remote machine. So, SSH will perform as a SOCKS server supporting the SOCKS4 and SOCKS5 protocols. If used frequently, port forwarding can be set into the account <kbd class="calibre9">ssh config</kbd> file. Just notice that only a superuser can forward a privileged port.</span></span></li>
</ul>
<p class="calibre1"><span><span>We then used <kbd class="calibre9">spoton</kbd> as the destination, since we have a config snippet saved for it so we do not need to specify addresses or password. But if we had no config, we would have written this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ssh -f -N -D 8080 test_user@192.168.0.5:9999</strong>
</pre>
<p class="calibre1"><span><span>Fill in the user password when asked for. Once we have our SOCKS proxy on, we can then configure any applications such as curl, Chrome, and Firefox to make use of it.</span></span></p>
<p class="calibre1"><span><span>We do not like a SOCKS proxy? So, why not simply tunnel everything into a secure connection?</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ssh -N -L 8888:www.anomali.com:443 spoton</strong>
</pre>
<p class="calibre1"><span><span>Now let's make a call:</span></span></p>
<pre class="codepackt">
local_user:~$ curl -k https://localhost:8888<br class="title-page-name"/>&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;<br class="title-page-name"/>&lt;html&gt;&lt;head&gt;<br class="title-page-name"/>&lt;title&gt;301 Moved Permanently&lt;/title&gt;<br class="title-page-name"/>&lt;/head&gt;&lt;body&gt;<br class="title-page-name"/>&lt;h1&gt;Moved Permanently&lt;/h1&gt;<br class="title-page-name"/>&lt;p&gt;The document has moved &lt;a href="https://www.anomali.com/blog/"&gt;here&lt;/a&gt;.&lt;/p&gt;<br class="title-page-name"/>&lt;/body&gt;&lt;/html&gt;
</pre>
<p class="calibre1"><span><span>What is interesting here is the <kbd class="calibre9">-L</kbd> option, which forces the connections to the given TCP port (<kbd class="calibre9">8888</kbd>) to be forwarded over the encrypted channel to the remote host (<kbd class="calibre9">spoton</kbd>); and port (<kbd class="calibre9">9999</kbd>) or Unix socket, which then connects to the final host (<kbd class="calibre9">www.anomali.com</kbd>) on the port designated (<kbd class="calibre9">443</kbd>). As for the proxy, if we use this feature frequently, we can set it up into the account ssh config file, while we can optionally specify a local address to bind the local port (in brackets if IPv6). The spoton can be replaced by the remote account name at the remote address and port, as shown in the previous example. Notice that we used a redirection on HTTP, but this is a tunnel, so we can use whatever protocol we want, not just HTTP.</span></span></p>
<p class="calibre1"><span><span>But we can do even something fancier: we can let someone access a remote host through us. So, on the local machine, we just give the following command:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ssh -f -N -R 8181:www.anomali.com:443 spoton</strong>
</pre>
<p class="calibre1"><span><span>Then, on <kbd class="calibre9">spoton</kbd>, we will use, <kbd class="calibre9">curl</kbd> command:</span></span></p>
<pre class="codepackt">
test_user:~$ curl -k https://localhost:8181<br class="title-page-name"/>&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;<br class="title-page-name"/>&lt;html&gt;&lt;head&gt;<br class="title-page-name"/>&lt;title&gt;301 Moved Permanently&lt;/title&gt;<br class="title-page-name"/>&lt;/head&gt;&lt;body&gt;<br class="title-page-name"/>&lt;h1&gt;Moved Permanently&lt;/h1&gt;<br class="title-page-name"/>&lt;p&gt;The document has moved &lt;a href="https://www.anomali.com/blog/"&gt;here&lt;/a&gt;.&lt;/p&gt;<br class="title-page-name"/>&lt;/body&gt;&lt;/html&gt;
</pre>
<p class="calibre1"><span><span>That is, we access <kbd class="calibre9">www.anomali.com</kbd> from <kbd class="calibre9">spoton</kbd> through our local machine; and that is what <kbd class="calibre9">-R</kbd> allows us to do: forward the connections on the remote host (<kbd class="calibre9">spoton</kbd>) on the remote port (<kbd class="calibre9">8181</kbd>) to the local machine, and from there to the external site (<kbd class="calibre9">www.anomali.com</kbd>). We then had to use the <kbd class="calibre9">-k</kbd> option with curl to prevent it complaining about an insecure connection, since the mismatch from the apparent URL and the external site SSL certificate. As a last word, we must remember to re-enable the ports we closed with the firewall before moving on.</span></span></p>
<p class="calibre1"><span><span>Nice, isn't it? Before leaving this chapter, let's indulge in some other tricks just to have fun. Let's go back to our public key stored in the <kbd class="calibre9">test_user authorized_keys</kbd> on <kbd class="calibre9">spoton</kbd> , and let's add something at the beginning of the key:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">command="sudo ifconfig eth0",no-port-forwarding,no-X11-forwarding ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQAAAAIbmlzdHAzODQAAABhBPlnKFqWXsCj47zKtrZzqj8PUuAvFlpTPzTJ4faHF1Fb2YJkI4Ywc4gmRig/hz+0kAXtanla4pMQtE6NqwyNheqo5rru8czRM9jRigqN8UwF7yZNf0LMxYV2aFCzrGcz6g== Key for test_user on spoton</strong>
</pre>
<p class="calibre1"><span><span>We simply added a command to the key: each time we use this key to log in, the command will be executed. Since the user is unprivileged and the command requires to be run by root, we are using <kbd class="calibre9">sudo</kbd>, so let's add the following file to <kbd class="calibre9">/etc/sudoers.d/</kbd></span></span>:</p>
<pre class="codepackt">
<strong class="calibre2">root:# cat /etc/sudoers.d/test_user <br class="title-page-name"/></strong><strong class="calibre2">test_user ALL = (root) NOPASSWD: /sbin/ifconfig eth0</strong>
</pre>
<p class="calibre1"><span><span>The name of the file does not matter; it is the content that makes the difference, enabling <kbd class="calibre9">test_user</kbd> to run <kbd class="calibre9">/sbin/ifconfig eth0</kbd> as root. This way, we will concede a small and restricted privilege. Now, from our local machine as <kbd class="calibre9">local_user</kbd>, let's connect to <kbd class="calibre9">spoton</kbd> using the public key that we created:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local_user:~$ ssh spoton<br class="title-page-name"/></strong><strong class="calibre2">Warning: Permanently added 'spotalias,[192.168.0.5]:9999' (ECDSA) to the list of known hosts.<br class="title-page-name"/></strong><strong class="calibre2">eth0 Link encap:Ethernet HWaddr 00:1d:ba:88:2a:e6 <br class="title-page-name"/></strong><strong class="calibre2">inet addr:192.168.0.5 Bcast:192.168.0.255 Mask:255.255.255.0<br class="title-page-name"/></strong><strong class="calibre2">inet6 addr: redacted/64 Scope:Global<br class="title-page-name"/></strong><strong class="calibre2">inet6 addr: redacted/64 Scope:Link<br class="title-page-name"/></strong><strong class="calibre2">UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1<br class="title-page-name"/></strong><strong class="calibre2">RX packets:614498 errors:0 dropped:0 overruns:0 frame:0<br class="title-page-name"/></strong><strong class="calibre2">TX packets:29212 errors:0 dropped:0 overruns:0 carrier:0<br class="title-page-name"/></strong><strong class="calibre2">collisions:0 txqueuelen:1000 <br class="title-page-name"/></strong><strong class="calibre2">RX bytes:119612772 (114.0 MiB) TX bytes:4249467 (4.0 MiB)<br class="title-page-name"/></strong><strong class="calibre2">Interrupt:16 <br class="title-page-name"/></strong><strong class="calibre2">Connection to 192.168.0 5 closed.</strong>
</pre>
<p class="calibre1"><span><span>We can create dedicated users/keys to restart services, check logs, execute whatever maintenance task, and we will just have to fire up the connection without bothering about permissions and commands.</span></span></p>
<p class="calibre1"><span><span>Do we need to run a graphical application that we do not have installed and cannot install, but we know it is available on a remote host? We must be sure that the X11 forwarding is enabled in our user <kbd class="calibre9">ssh config</kbd> file:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">ForwardX11 yes<br class="title-page-name"/></strong><strong class="calibre2">ForwardX11Trusted yes</strong>
</pre>
<p class="calibre1"><span><span>The forwarding is enabled on the remote server:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">X11Forwarding yes</strong>
</pre>
<p class="calibre1"><span><span>Obviously, on the remote server, there must be <kbd class="calibre9">Xorg</kbd> installed along with the <kbd class="calibre9">xauth</kbd> utility; and if we are using the same key, we have to clean it from the command snipped and revert to the original value. Once we are sure, we just type this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">test_user:~$ ssh -n -f -X spoton firefox<br class="title-page-name"/></strong><strong class="calibre2">Warning: Permanently added 'spoton,[192.168.0.5]:9999' (ECDSA) to the list of known hosts.<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ /usr/bin/xauth: file /root/.Xauthority does not exist<br class="title-page-name"/></strong><strong class="calibre2">Xlib: extension "RANDR" missing on display "localhost:10.0".</strong>
</pre>
<p class="calibre1"><span><span>In a few seconds, Firefox will be up and running on the remote host, but its window will be displayed on our local system.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We just scratched the surface of what we can actually do with SSH. There are so many things such as <kbd class="calibre9">ssh-agent</kbd>, <kbd class="calibre9">ssh-add</kbd>, and <kbd class="calibre9">ssh-keyring</kbd>, and so many complex and tricky things to do that a chapter cannot hold everything. Anyway, this is a starting point; and once we get familiar on the usage of both the server and the client, we can start a journey in the esoteric world of encrypted connections, jumphosts, proxies, and whatever we need or we want to know. As of now, we need to step further to another topic that will show us how to set up scheduled jobs to execute our script in a timely manner and how to properly log their execution so that we will be always able to understand what is going on with our creations. It's time for timed jobs, time to explore the at, cron and logging facilities.</span></span></p>


            </article>

            
        </section>
    </body></html>