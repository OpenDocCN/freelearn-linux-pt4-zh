- en: Introducing the Core and its Capabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Core及其功能
- en: 'In this chapter, we cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: Dissecting a .NET Core object
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解构.NET Core对象
- en: Breaking down an output into different objects
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出分解为不同的对象
- en: Parsing input from text to object
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析输入从文本到对象
- en: Comparing the outputs of Bash and PowerShell
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较Bash和PowerShell的输出
- en: Comparing Windows PowerShell and PowerShell
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较Windows PowerShell和PowerShell
- en: Listing out the aliases and using them in place of cmdlets
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出别名并使用它们替代cmdlet
- en: Creating a custom alias
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建自定义别名
- en: Importing/Exporting custom aliases for future use
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入/导出自定义别名以供未来使用
- en: Listing out the execution policies and setting a suitable one
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出执行策略并设置合适的策略
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Microsoft's announcement of "open sourcing" .NET in 2014 almost stirred a storm.
    Many rushed to the stands (so to speak) to read about the unbelievable—how could
    Microsoft possibly open-source the core of their operating system? Some were cynical,
    others rejoiced. Then came the announcement a little louder and clearer that .NET
    Core was open source, not the .NET Framework. Many said .NET Core was a subset
    of .NET Framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在2014年宣布“开源” .NET几乎引发了一场风暴。许多人赶忙涌上台（打个比方）去了解这令人难以置信的消息——微软怎么可能将操作系统的核心开源？一些人持怀疑态度，另一些人则感到高兴。然后宣布更加明确——.NET
    Core是开源的，而不是.NET Framework。许多人认为.NET Core是.NET Framework的一个子集。
- en: .NET was first announced in 2000, as a new platform based on Internet standards.
    Along with it, by the end of the year, Microsoft published the **Common Language
    Infrastructure** as a standard, so that anyone who wanted, could write their own
    .NET framework based on those standards. .NET Framework has been the basis of
    Windows since the noughties.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: .NET首次在2000年宣布，作为一个基于互联网标准的新平台。年底时，微软发布了**公共语言基础设施**作为标准，使得任何人都可以基于这些标准编写自己的.NET框架。.NET
    Framework自2000年代初以来一直是Windows的基础。
- en: Windows PowerShell was released to the general market in 2006, as an implementation
    of .NET Framework, focussed on system administrators (or sysadmins, to enable
    them to better manage their Windows workloads and automate tasks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Windows PowerShell于2006年发布，作为.NET Framework的一个实现，专注于系统管理员（或称为sysadmins），以帮助他们更好地管理Windows工作负载并自动化任务。
- en: In June of 2016, Microsoft released a collaboratively refactored, more modern
    and efficient .NET. The .NET Core was officially born. While .NET Framework continues
    to rule the Windows arena, .NET Core, which is open source and cross-platform,
    has picked up great momentum and continues to grow. And .NET Core seems to be
    the way forward.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年6月，微软发布了经过协作重构、更现代、更高效的.NET。.NET Core正式诞生。虽然.NET Framework继续主宰Windows领域，但.NET
    Core作为开源且跨平台的框架，获得了巨大的推动力，并持续增长。而.NET Core似乎是未来的发展方向。
- en: PowerShell (not *Windows* PowerShell) is based on .NET Core, and therefore,
    is open source, with the same vision as .NET Core to be cross-platform.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell（不是*Windows* PowerShell）基于.NET Core，因此它是开源的，并且具有与.NET Core相同的愿景，即跨平台。
- en: In this chapter, we will look at a very simple implementation of .NET Core and
    compare it to the output of PowerShell to prove that PowerShell is nothing but
    encapsulated .NET Core code. Along with it, we shall look at the general behaviour
    of PowerShell as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一个非常简单的.NET Core实现，并与PowerShell的输出进行比较，以证明PowerShell不过是封装了的.NET Core代码。同时，我们也将观察PowerShell的一般行为。
- en: Dissecting a .NET Core Object
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构.NET Core对象
- en: .NET Core works on a cross-platform standard Common Language Infrastructure.
    Therefore, it has been possible to encapsulate the internal workings of Linux
    using .NET Core. As we would see in the future chapters, PowerShell is object-oriented,
    just like .NET Core. For this demonstration, we would pick a simple system class,
    called `System.IO.DirectoryInfo` to show information about a certain directory.
    We will also compare the output .NET Core object to the output of a PowerShell
    cmdlet which also shows information about a certain directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core在跨平台的标准公共语言基础设施（Common Language Infrastructure）上运行。因此，使用.NET Core封装Linux的内部工作变得可能。正如我们在未来的章节中会看到的，PowerShell是面向对象的，就像.NET
    Core一样。为了演示，我们将选择一个简单的系统类，`System.IO.DirectoryInfo`，来展示某个目录的信息。我们还将比较.NET Core对象的输出与PowerShell
    cmdlet的输出，这两者都展示了某个目录的信息。
- en: You do not have to remember the names of the .NET Core classes, methods or their
    syntaxes to work with PowerShell; that's the whole point of the existence of PowerShell.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要记住.NET Core类、方法或它们的语法来与PowerShell一起工作；这正是PowerShell存在的意义所在。
- en: Getting Ready
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好了吗
- en: If you followed along the last chapter, you should already have PowerShell installed
    on your Linux computer; open a terminal window and type in `pwsh` to invoke PowerShell.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照上一章的步骤操作，应该已经在你的 Linux 计算机上安装了 PowerShell；打开终端窗口并键入 `pwsh` 来启动 PowerShell。
- en: 'Every **object** has members—**properties** and **methods**. In case you''re
    new to the concepts of Object Oriented Programming, properties are qualities of
    an object (what the object has), and methods are the capabilities of an object
    (what the object can do). Therefore, to quote (arguably) the most overused example
    of properties and methods: If a horse is an object, its height, its colour, etc.
    would be its properties; galloping, eating, etc. would be the methods that the
    object supports.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 **对象** 都有成员——**属性** 和 **方法**。如果你是面向对象编程的新手，属性是对象的特性（对象有什么），而方法是对象的能力（对象能做什么）。因此，引用（可以说是）最常被使用的属性和方法的例子：如果马是一个对象，它的高度、颜色等就是它的属性；奔跑、吃饭等就是该对象支持的方法。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: With PowerShell, .NET Core is also installed as a dependency. Let us create
    an object in PowerShell, which would call a .NET class and its default constructor.
    This constructor requires an argument.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 PowerShell 时，.NET Core 也作为一个依赖项被安装。让我们在 PowerShell 中创建一个对象，它将调用 .NET 类及其默认构造函数。这个构造函数需要一个参数。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gives us information on the directory specified, like so:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将为我们提供关于指定目录的信息，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is a cmdlet in PowerShell,  called, `Get-Item`, which gives us details
    about a directory. Let us call this cmdlet with the same argument as before, and
    see what we get.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，有一个名为 `Get-Item` 的 cmdlet，它可以提供关于目录的详细信息。让我们使用与之前相同的参数来调用这个 cmdlet，看看我们能得到什么。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Close! Let us now look at the *details* of the output object we just received,
    using the `Get-Member` cmdlet on the output of `Get-Item`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很接近了！现在让我们使用 `Get-Member` cmdlet 查看刚才收到的输出对象的 *详细信息*。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Get-Member` shows all the members available in the output object (most PowerShell
    cmdlets return objects as output, not plain text). For more information, run `Get-Help
    Get-Member`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Member` 显示输出对象中所有可用的成员（大多数 PowerShell cmdlet 返回的是对象输出，而非纯文本）。欲了解更多信息，请运行
    `Get-Help Get-Member`。'
- en: This would list a series of members that are part of the output. We're primarily
    concerned about the very first line for now.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出作为输出的一系列成员。我们目前主要关注第一行。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Notice the very first line of the output, `TypeName: System.IO.DirectoryInfo`.
    That is the exact type name we used when creating the .NET object.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '注意输出的第一行，`TypeName: System.IO.DirectoryInfo`。这就是我们在创建 .NET 对象时使用的精确类型名称。'
- en: '![](img/c1e7e64f-6963-4c88-9e96-ee87651fba00.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1e7e64f-6963-4c88-9e96-ee87651fba00.png)'
- en: This proves that the same task of showing information on the current working
    directory can be achieved by calling a .NET constructor, or by running a PowerShell
    cmdlet. Therefore, we infer that PowerShell cmdlets are simply encapsulated .NET
    code, simplified to enable administrators to work with computers, without having
    to worry about the underlying .NET code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了显示当前工作目录信息的相同任务可以通过调用 .NET 构造函数，或者运行 PowerShell cmdlet 来实现。因此，我们推测 PowerShell
    cmdlet 仅仅是封装的 .NET 代码，简化后使管理员能够与计算机进行交互，而不必担心底层的 .NET 代码。
- en: In essence, `Get-Item` calls the `System.IO.DirectoryInfo` class under the hood,
    with the arguments passed along with the cmdlet.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，`Get-Item` 在幕后调用了 `System.IO.DirectoryInfo` 类，并传递了与 cmdlet 一起传入的参数。
- en: '`Get-Item` can be used with any location in your file system. As long as you
    are authorised to access the location, PowerShell would return information about
    the location you pass as the argument.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Item` 可以与文件系统中的任何位置一起使用。只要你有权访问该位置，PowerShell 就会返回你作为参数传递的位置信息。'
- en: 'Like they say:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如他们所说：
- en: If the C# guys can do it, so can you.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 C# 大家都能做到，你也可以。
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Read the output of the `Get-Item | Get-Member` command to understand what more
    information you can get about the directory you specify. Also, after we are comfortable
    using the `Select-Object` cmdlet, we should be able to call specific fields from
    the returned objects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读 `Get-Item | Get-Member` 命令的输出，以了解你可以获得关于指定目录的更多信息。此外，当我们熟悉使用 `Select-Object`
    cmdlet 后，应该能够从返回的对象中调用特定的字段。
- en: See also
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: The .NET class, [System.IO.DirectoryInfo](https://msdn.microsoft.com/en-us/library/system.io.directoryinfo(v=vs.110).aspx)
    (Microsoft Developer Network)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET 类，[System.IO.DirectoryInfo](https://msdn.microsoft.com/en-us/library/system.io.directoryinfo(v=vs.110).aspx)（Microsoft
    开发者网络）
- en: Breaking down an output into different objects
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将输出分解为不同的对象
- en: In the previous section, we saw that an object can have properties as well as
    methods. These properties and methods are known as members. In the object oriented
    approach to programming (and by extension, administration using PowerShell), it
    is possible to reference these properties as well as methods of an object using
    the **member access operator**, which is a single dot (`.`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到一个对象可以有属性和方法。这些属性和方法被称为成员。在面向对象的编程方法中（以及通过 PowerShell 管理扩展），可以使用**成员访问操作符**，即单个点（`.`），来引用对象的属性和方法。
- en: Getting Ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ideally, this recipe should be an extension to the previous. If you did not
    run the previous commands, it is suggested that you do, and then proceed with
    the steps below.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，这个食谱应该是对前面的扩展。如果你没有运行前面的命令，建议先运行它们，然后再继续以下步骤。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Look at the output of the following command from the previous recipe:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下之前食谱中命令的输出：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output table contains the name of the member, the type and the definition.
    Take a look at the `MemberType` column; you have `Method`, and different kinds
    of properties such as `CodeProperty` and `Property`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表包含成员的名称、类型和定义。看看 `MemberType` 列；你会看到 `Method` 和不同种类的属性，如 `CodeProperty` 和
    `Property`。
- en: Assume that we would like to see when my home directory was last written to.
    We would refer to this property using the member access operator. To do this,
    simply enclose in parenthesis the `Get-Item` command along with its argument and
    refer to the property using the dot operator.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想查看我的主目录最后一次写入的时间。我们可以使用成员访问操作符来引用这个属性。为此，只需将 `Get-Item` 命令及其参数括在括号中，并使用点操作符引用属性。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, let us pick the property, `Parent`, of the object. This should give us
    the details of the directory which my home directory resides in.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们选择这个对象的属性 `Parent`。这将为我们提供我的主目录所在目录的详细信息。
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This output in itself is an object, which means that we can fetch last write
    time and other details of this returned object, just like how we did for `/home/ram`.
    How do we see when the parent folder (`/home`) was created?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出本身是一个对象，这意味着我们可以像处理 `/home/ram` 一样获取这个返回对象的最后写入时间和其他详细信息。我们如何查看父文件夹（`/home`）的创建时间？
- en: First, let us use the `Get-Member` cmdlet on this object and see the `TypeName`
    of the returned object.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在这个对象上使用 `Get-Member` cmdlet，并查看返回对象的 `TypeName`。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is the same as `Get-Item` itself. Therefore, any of the members of `Get-Item
    /home/ram` apply to `(Get-Item /home/ram).Parent` as well.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 `Get-Item` 本身相同。因此，`Get-Item /home/ram` 的任何成员也适用于 `(Get-Item /home/ram).Parent`。
- en: Now call the `CreationTime` property on the parent object. Simply add a dot
    next to `Parent`, and call the `CreationTime` property.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在父对象上调用 `CreationTime` 属性。只需在 `Parent` 后添加一个点，然后调用 `CreationTime` 属性。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `CreationTime` property is an object in itself, of the type, `DateTime`.
    Therefore, you can perform date and time operations on this object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreationTime` 属性本身就是一个对象，类型为 `DateTime`。因此，你可以在这个对象上执行日期和时间操作。'
- en: PowerShell is not case-sensitive most of the time. However, it is recommended
    we stick to the conventions in order to minimise errors. Especially since case
    sensitivity is a convention in Linux. Properties could be of different data types.
    The data type can be seen in the `Definition` column.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 在大多数情况下不区分大小写。然而，建议我们遵循约定，以减少错误。特别是因为大小写敏感性在 Linux 中是一个约定。属性可能有不同的数据类型。数据类型可以在`Definition`列中看到。
- en: Let us look at the members of the `CreationTime` object to see if we can further
    filter the output.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看 `CreationTime` 对象的成员，看看是否可以进一步过滤输出。
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let us pick only the year property from this object.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们仅选择这个对象的年份属性。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This concludes picking properties from within the returned objects. Next, let
    us use a method from within the returned object and create a sub-directory under
    `/home/ram`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是从返回的对象中选择属性的全部内容。接下来，让我们使用返回对象中的方法，在 `/home/ram` 下创建一个子目录。
- en: First, list out the existing directories under the directory. This is done using
    the cmdlet, `Get-ChildItem`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，列出该目录下的现有目录。可以使用 cmdlet `Get-ChildItem` 完成这项操作。
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Get-Item` gives you details about the directory itself. In essence, this cmdlet
    deals with the current item at hand. Therefore, you have properties and methods
    that align with that intention. Child items, on the other hand, mean the files
    and directories that are *within* the said item.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Item` 会提供关于目录本身的详细信息。本质上，这个 cmdlet 处理当前的项目。因此，你可以访问与该意图相关的属性和方法。而子项则意味着在该项*内*的文件和目录。'
- en: That is a list of standard directories in a user profile. Let us now create
    a sub-directory within this profile folder, using a method in `Get-Item`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是用户配置文件中标准目录的列表。现在让我们在该配置文件文件夹内创建一个子目录，使用 `Get-Item` 中的方法。
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To know what argument a certain method accepts, look in the `Definition` column
    of the output of `Get-Member`. In case of `CreateSubdirectory`, the definition
    is `System.IO.DirectoryInfo CreateSubdirectory(string path)`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道某个方法接受什么参数，请查看 `Get-Member` 输出中的 `Definition` 列。对于 `CreateSubdirectory`，定义是
    `System.IO.DirectoryInfo CreateSubdirectory(string path)`。
- en: You should now get a confirmation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该会看到一个确认信息。
- en: '![](img/d5608bd8-b8e8-471a-8413-8002dc6cf776.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5608bd8-b8e8-471a-8413-8002dc6cf776.png)'
- en: Excellent. Now, list out the directories under the home directory.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很好。现在，列出主目录下的所有目录。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can now see the new directory that we created using the `CreateSubdirectory`
    method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们使用 `CreateSubdirectory` 方法创建的新目录。
- en: Running `Get-ChildItem`, as you may notice, is similar to running the `GetDirectories`
    and `GetFiles` methods of the object returned by `Get-Item`. This is another example
    of encapsulation in .NET Core.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `Get-ChildItem` 时，正如你可能注意到的，它类似于运行 `Get-Directories` 和 `GetFiles` 方法，这些方法来自
    `Get-Item` 返回的对象。这是 .NET Core 中封装的另一个例子。
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Using the properties and methods within a returned object is simple. Objects
    from within the output returned by a cmdlet can be called using the member access
    operator directly on the command (cmdlet including the parameter).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用返回对象中的属性和方法非常简单。可以直接在命令（包括参数的 cmdlet）上使用成员访问运算符来调用 cmdlet 返回输出中的对象。
- en: Calling properties after the member access operator fetches the data that's
    held within the property. In our case, it was the `LastWriteTime`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在成员访问运算符后调用属性会获取该属性中保存的数据。在我们的例子中，它是 `LastWriteTime`。
- en: Methods are functions. They may or may not require an argument. The `CreateSubdirectory`
    method requires a string argument, which is the name (or path) of the sub-directory
    we wish to create—whatever we enter in the parenthesis essentially forms the path
    we wish to create. In case of methods that can run without an argument, they need
    to be called with empty parenthesis following the name of the method, like `ToString()`,
    for example.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是函数。它们可能需要，也可能不需要参数。`CreateSubdirectory` 方法需要一个字符串参数，它是我们希望创建的子目录的名称（或路径）——我们在括号中输入的内容基本上构成了我们希望创建的路径。对于那些不需要参数的可以运行的方法，它们需要在方法名后跟一个空括号进行调用，例如
    `ToString()`。
- en: When we pass the string argument into `CreateSubdirectory`, the method runs
    a .NET Core routine and creates a sub-directory within the directory we specify
    with `Get-Item`. The internal workings of the .NET Core is beyond the scope of
    this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将字符串参数传递给 `CreateSubdirectory` 时，该方法会运行一个 .NET Core 例程，并在我们通过 `Get-Item`
    指定的目录内创建一个子目录。 .NET Core 的内部工作超出了本书的范围。
- en: See also
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Recipe: Selecting objects via the pipeline'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 食谱：通过管道选择对象
- en: Parsing input from text to object
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文本到对象的解析
- en: Moving to the object model from text could seem a little daunting at first.
    However, with PowerShell, it is not very hard to switch to the new model, especially
    given that PowerShell can convert text into objects given the right tools. In
    this recipe, we would look at two of the ways that PowerShell converts textual
    data into objects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本转换到对象模型最初可能看起来有些令人生畏。然而，在 PowerShell 中，切换到新模型并不难，尤其是考虑到 PowerShell 可以根据合适的工具将文本转换为对象。在本食谱中，我们将查看
    PowerShell 将文本数据转换为对象的两种方法。
- en: Getting Ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before we dive into the recipe, let us give ourselves a little introduction
    on how text-to-object parsing is handled. One way is to use .NET's built-in functionality,
    and the second one that we discuss involves using a cmdlet to perform the conversion
    based on a delimiter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入食谱之前，先给自己做一个简短的介绍，讲解文本到对象解析是如何处理的。一种方法是使用 .NET 内置的功能，另一种方法则是使用 cmdlet，根据分隔符来执行转换，这是我们将要讨论的内容。
- en: 'The basic requirement for this recipe is simple: you simply need PowerShell
    installed on your computer. We will edit the file within PowerShell. If you would
    be comfortable using a text editor instead, that works as well. Most Linux distributions
    pack a text editor. If not, use your package manager to install Vim, Nano, Gedit,
    Visual Studio Code, Atom or any other text/code editor.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的基本要求很简单：你只需要在计算机上安装PowerShell。我们将在PowerShell中编辑文件。如果你更喜欢使用文本编辑器，也可以。这大多数Linux发行版都自带文本编辑器。如果没有，你可以通过包管理器安装Vim、Nano、Gedit、Visual
    Studio Code、Atom或其他任何文本/代码编辑器。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We shall first look at converting text into an object from plain text input
    at the terminal. This involves using what is known as a **PowerShell Type Accelerator**.
    A PowerShell Type Accelerator is a an alias for .NET classes. Using these, we
    can call .NET classes and use many of their functionalities within PowerShell.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看如何从终端的纯文本输入将文本转换为对象。这涉及到使用所谓的**PowerShell 类型加速器**。PowerShell 类型加速器是.NET类的别名。通过使用这些加速器，我们可以调用.NET类并在PowerShell中使用它们的许多功能。
- en: Let us take plain text as input and convert the text into a date object. To
    check what sort of object your input is, use the `Get-Member` cmdlet.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们以纯文本为输入，并将其转换为日期对象。要检查输入的对象类型，可以使用`Get-Member` cmdlet。
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Enclosing any text within single quotes defines the text as a **non-expanding
    literal string**. No explicit definition is required in this case, in PowerShell.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何文本用单引号括起来，可以将该文本定义为**非扩展的文字字符串**。在PowerShell中，这种情况下不需要显式定义。
- en: The `TypeName` says, `System.String`. This confirms that what we entered was
    plain text. Let us now use a Type Accelerator and convert this text into a `DateTime`
    object. The accelerator for this purpose is `[DateTime]`; place this accelerator
    before the literal string.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TypeName`显示为`System.String`。这确认了我们输入的确实是纯文本。现在让我们使用类型加速器，将该文本转换为`DateTime`对象。这个加速器是`[DateTime]`；将这个加速器放在文字字符串前面。'
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, find the `TypeName` of the object that was returned.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，找到返回的对象的`TypeName`。
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Voila, the string has been successfully parsed into date and time!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà，字符串已经成功解析为日期和时间！
- en: It is also possible to achieve the same result with the cmdlet, `Get-Date`,
    when it is called with the text argument.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`Get-Date` cmdlet，并传入文本参数，同样也可以实现相同的结果。
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, the `TypeName` would be:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，`TypeName`将是：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Just like we did in the previous recipe, we can now manipulate the object to
    show information in a more meaningful way. For instance, if you care only about
    the year, you would write:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在前面所做的那样，我们现在可以操作对象，以更有意义的方式展示信息。例如，如果你只关心年份，你可以写：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The other way of converting text into an object is to use cmdlets that perform
    such tasks. PowerShell packs a few converter cmdlets, one of which is `Import-Csv`.
    You may have noticed that PowerShell usually sends out output in a tabular format.
    This is a simple representation of objects. And `Import-Csv` converts data in
    delimited row-and-column structure into objects, where each row is an instance
    of the object itself, and each column is a property of the object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将文本转换为对象的方法是使用执行此类任务的cmdlet。PowerShell提供了一些转换cmdlet，其中之一就是`Import-Csv`。你可能注意到，PowerShell通常以表格格式输出结果。这是对象的简单表示形式。而`Import-Csv`将以分隔符行列结构的数据转换为对象，每一行是对象的一个实例，每一列是对象的一个属性。
- en: 'To demonstrate this, let us create a CSV file with the following content in
    it. At the PowerShell prompt, type:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们创建一个CSV文件，并在其中输入以下内容。在PowerShell提示符下，输入：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This would take you to the next line; PowerShell is expecting input. Paste the
    following sample content at the prompt.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会让你进入下一行；PowerShell正在等待输入。请在提示符处粘贴以下示例内容。
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Go to the next line and enter the following at the `>>` prompt:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到下一行，在`>>`提示符下输入以下内容：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You could perform the same operation using the `touch` command and the text
    editor of your choice. The goal is to get the content into the sample file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`touch`命令和你选择的文本编辑器执行相同的操作。目标是将内容写入示例文件中。
- en: Next, read the contents of the file using PowerShell.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用PowerShell读取文件的内容。
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That looks like simple text. Let us look at the type name of the object to
    confirm that this is indeed plain text. Type in:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来像是简单的文本。让我们查看对象的类型名称，以确认这确实是纯文本。输入：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That is plain and simple string. Let us now convert the content into a simple
    object. This is done using `Import-Csv`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那只是一个简单的字符串。现在让我们将内容转换为一个简单的对象。这可以通过`Import-Csv`来完成。
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That should give you a list-like output.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你一个类似列表的输出。
- en: '![](img/421790f7-a304-47d2-8a53-8d8b24057760.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/421790f7-a304-47d2-8a53-8d8b24057760.png)'
- en: To confirm the output is objects, list out its members.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确认输出为对象，请列出其成员。
- en: '![](img/2ce2642a-5e63-4f99-85ca-3dcba5ee4bcb.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ce2642a-5e63-4f99-85ca-3dcba5ee4bcb.png)'
- en: In general, the content is a custom object, as denoted by `PSCustomObject`.
    The columns we had in the CSV are of type `NoteProperty`, as shown by `MemberType`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，内容是一个自定义对象，如`PSCustomObject`所示。我们在CSV中拥有的列是`NoteProperty`类型，如`MemberType`所示。
- en: A `NoteProperty` is a generic property, whose characteristics are similar to
    string. While most properties are inherited from .NET, `NoteProperty` is custom-created
    within PowerShell, as a name-value pair.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoteProperty`是一种通用属性，其特性类似于字符串。虽然大多数属性都是从.NET继承而来，但`NoteProperty`是在PowerShell中自定义创建的，作为名称-值对。'
- en: If you would rather look at the content as a table, format the content as a
    table.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你更愿意将内容视为表格，请将内容格式化为表格。
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](img/653c86b0-0db0-4230-9e4d-86c4a23a5109.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/653c86b0-0db0-4230-9e4d-86c4a23a5109.png)'
- en: That brings us to the end of this recipe. We have successfully converted text
    into an object. However, note that this is just a simple conversion, and that
    the output of `Import-Csv` is still string-like. Although, all of the content
    is now objects, which are easier to handle in PowerShell.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本配方的结尾。我们已成功将文本转换为对象。但请注意，这只是一个简单的转换，而`Import-Csv`的输出仍然类似于字符串。尽管如此，所有内容现在都是对象，这在PowerShell中更易于处理。
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Type Accelerators are another form of encapsulation of .NET code in PowerShell.
    Remember the first recipe in this chapter wherein we created a .NET object within
    PowerShell. We used the PowerShell command, `New-Object -TypeName System.IO.DirectoryInfo
    -ArgumentList ''/home/ram''` to get information on a home directory: we created
    a new instance of `System.IO.DirectoryInfo`, and passed an argument to it. That
    was a lot of code to write. To accelerate the process, we could use, `[IO.DirectoryInfo]''/home/ram''`,
    (`System` is the default namespace; PowerShell would understand it without us
    explicitly mentioning it when calling accelerators) which outputs the same object
    as the former command.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类型加速器是在PowerShell中封装.NET代码的另一种形式。请记住本章的第一个配方，在其中我们在PowerShell中创建了一个.NET对象。我们使用了PowerShell命令`New-Object
    -TypeName System.IO.DirectoryInfo -ArgumentList '/home/ram'`来获取主目录的信息：我们创建了`System.IO.DirectoryInfo`的一个新实例，并向其传递了一个参数。那是一大堆要写的代码。为了加快这个过程，我们可以使用`[IO.DirectoryInfo]'/home/ram'`（`System`是默认命名空间；PowerShell在调用加速器时不需要我们显式提及它，也能理解它），它输出与前一个命令相同的对象。
- en: 'With `Import-Csv` on the other hand, the process was a simple conversion of
    data from text into name-value pairs. This is similar to using `ConvertFrom-Text`
    with a `Delimiter` parameter. This way, we instruct PowerShell to convert each
    row of text into instances of the object: The first row in the row-column structure
    is taken as the property name, and the rest of the rows are data. The cells are
    separated using  delimiter, which was a comma, in case of the CSV file.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用`Import-Csv`的过程是将文本数据简单转换为名称-值对。这类似于使用带有`Delimiter`参数的`ConvertFrom-Text`。通过这种方式，我们指示PowerShell将每行文本转换为对象的实例：行列结构中的第一行被视为属性名称，其余行是数据。单元格使用逗号分隔符分隔，这在CSV文件中是一样的。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Look for more conversion cmdlets built into PowerShell. This can be done using
    the command, `Get-Command -Verb ConvertFrom`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找更多内置于PowerShell的转换命令。可以使用命令`Get-Command -Verb ConvertFrom`来实现。
- en: See also
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More about Type Accelerators in the [Hey, Scripting Guy! Blog](https://blogs.technet.microsoft.com/heyscriptingguy/2013/07/08/use-powershell-to-find-powershell-type-accelerators/).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于类型加速器的更多信息，请参阅[Hey, Scripting Guy! Blog](https://blogs.technet.microsoft.com/heyscriptingguy/2013/07/08/use-powershell-to-find-powershell-type-accelerators/)。
- en: 'Recipe: Using Here strings.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方：使用Here字符串。
- en: The [different kinds of members](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.psmembertypes?view=pscore-6.0.0)
    in PowerShell.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell中的[不同类型的成员](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.psmembertypes?view=pscore-6.0.0)。
- en: 'Best Practices Roundup: Formatting only in the end.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最佳实践汇总：仅在最后进行格式化。
- en: Comparing the outputs of Bash and PowerShell
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较Bash和PowerShell的输出
- en: PowerShell and Bash are both shells, and are capable of interacting with the
    kernel. Just like how Bash can run on Windows, PowerShell can now run on Linux.
    While almost all of the aspects of which shell is better than the other is debatable,
    and the choice of shell is simply a matter of personal preference today, it is
    true that PowerShell is as powerful as .NET Core can get.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell和Bash都是Shell，都能够与内核进行交互。就像Bash可以在Windows上运行一样，PowerShell现在也可以在Linux上运行。虽然关于哪个Shell更好的几乎所有方面都存在争议，今天选择哪种Shell纯粹是个人偏好的问题，但毫无疑问，PowerShell与.NET
    Core的强大能力是相匹配的。
- en: The primary difference between the two shells is, like we have seen before,
    that PowerShell outputs objects, while Bash returns text. Manipulation of the
    output in Bash involves manipulating text first, and then running further commands
    on the manipulated text to fetch the desirable output. PowerShell, on the other
    hand, handles content as objects and by design, requires comparatively less manipulation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 两个Shell的主要区别是，正如我们之前所看到的，PowerShell输出的是对象，而Bash返回的是文本。在Bash中，操作输出涉及首先处理文本，然后在处理后的文本上运行进一步的命令以获取所需的输出。而PowerShell则将内容处理为对象，按设计需要的文本操作较少。
- en: Structured data, as noted by Jeffrey Snover (the inventor of Windows PowerShell),
    is getting popular as days pass, and structured data is where PowerShell shines
    the most.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化数据，正如Windows PowerShell的发明者Jeffrey Snover所指出的，随着时间的推移越来越受欢迎，而结构化数据正是PowerShell最为出色的地方。
- en: Getting Ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we are going to pick one example to show how simple and efficient
    it is to handle file metadata using PowerShell, primarily since the output is
    an object. We will list the files and folders within our home directory, along
    with the date and time of modification using both, `ls` in Bash and `Get-ChildItem`
    in PowerShell.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将选择一个例子，展示如何使用PowerShell处理文件元数据既简单又高效，主要是因为输出是对象。我们将列出我们的主目录中的文件和文件夹，并使用`ls`（在Bash中）和`Get-ChildItem`（在PowerShell中）显示修改的日期和时间。
- en: 'Open up two instances of the terminal if you would so like: launch `pwsh` on
    one.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，也可以打开两个终端实例：在其中一个上启动`pwsh`。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: At the Bash prompt, enter `ls -l` to list out all the files along with the metadata
    that the command shows by default.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Bash提示符下，输入`ls -l`来列出所有文件及该命令默认显示的元数据。
- en: '![](img/eaf2fd5f-b91c-43ce-8e94-a7f1d764df1e.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eaf2fd5f-b91c-43ce-8e94-a7f1d764df1e.png)'
- en: Go to the terminal that has PowerShell running, and type in `Get-ChildItem`
    at the prompt.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开运行PowerShell的终端，在提示符下输入`Get-ChildItem`。
- en: '![](img/b2226dc9-7aae-4763-a1ec-249384383e49.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2226dc9-7aae-4763-a1ec-249384383e49.png)'
- en: Now, let us pick only the name of the folders and the last-modified date and
    time. This is done in Bash by passing the output of `ls -l` to `awk`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们只选择文件夹的名称以及最后修改的日期和时间。这可以通过在Bash中将`ls -l`的输出传递给`awk`来完成。
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/f56c057d-072d-4881-a844-5885d5270466.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f56c057d-072d-4881-a844-5885d5270466.png)'
- en: Next, let us pick the same information on PowerShell as well.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在PowerShell中也获取相同的信息。
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/94508b98-e2da-4f79-b637-8753329401cf.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94508b98-e2da-4f79-b637-8753329401cf.png)'
- en: If you notice, the output is very similar in both the cases, however, with PowerShell,
    you see the names of the columns as well, which means that you don't have to look
    for further documentation. Also, the selection of columns is simpler in PowerShell;
    no text manipulation is required. On the other hand, in Bash, we use the `awk`
    command to manipulate the text output.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到的话，在这两种情况下，输出是非常相似的，然而在PowerShell中，你还可以看到列的名称，这意味着你不需要再查找额外的文档。而且，在PowerShell中选择列的操作更简单，无需文本操作。另一方面，在Bash中，我们使用`awk`命令来操作文本输出。
- en: Let's go one step further and create a sub-directory with a space in the name.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步操作，创建一个名字中带空格的子目录。
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/60488ba8-6c4c-45d1-b5bf-145f2fc1134f.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60488ba8-6c4c-45d1-b5bf-145f2fc1134f.png)'
- en: Notice that what should have been `test subdirectory`, appears as `test`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原本应该是`test subdirectory`的部分，显示为`test`。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运作...
- en: PowerShell reads content from the file system as objects, not as text. Therefore,
    you perform a selection of the desired columns (or as we shall later see, properties)
    directly. Bash, on the other hand, outputs text, columns from which are manipulated
    using a delimiter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell从文件系统中读取内容时是作为对象处理，而不是作为文本。因此，你可以直接选择所需的列（或者稍后我们将看到的属性）。而Bash则输出文本，其中的列通过分隔符进行操作。
- en: To demonstrate that this is the case, we created a new subdirectory with a space
    in its name, and we performed the column selection same as before, only in this
    case, we did not get the complete name of the new subdirectory, because the name
    contained a white space, which is a delimiter in `awk`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，我们创建了一个新子目录，目录名中带有空格，我们进行了与之前相同的列选择操作，只不过这次我们没有得到新子目录的完整名称，因为目录名中包含了空格，而空格在`awk`中是一个分隔符。
- en: Comparing Bash and PowerShell is like comparing apples and oranges—in more ways
    than one. However, understanding the differences helps us leverage each of the
    tools to our benefit.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 比较 Bash 和 PowerShell 就像比较苹果和橘子——不仅仅是在一个方面。然而，理解它们的差异有助于我们充分利用每个工具。
- en: See also
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'Recipe: Selecting objects via the pipeline.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方：通过管道选择对象。
- en: Comparing Windows PowerShell and PowerShell
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较 Windows PowerShell 和 PowerShell
- en: PowerShell and Windows PowerShell are two different implementations. The former
    is based on a larger framework, the .NET Framework. The latter, on the other hand
    is a more modern framework, the .NET Core. PowerShell is cross-platform since
    its parent is. Windows PowerShell, on the other hand, is Windows-only, but has
    more capabilities than PowerShell, as of writing this chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 和 Windows PowerShell 是两个不同的实现。前者基于更大的框架——.NET Framework；后者则是基于更现代的框架——.NET
    Core。由于 PowerShell 的父框架是跨平台的，因此 PowerShell 也是跨平台的；而 Windows PowerShell 仅限于 Windows，但截至本章节撰写时，它的功能比
    PowerShell 更强大。
- en: The PowerShell that this book talks about is the cross-platform PowerShell Core.
    This is referred to as *PowerShell*. The PowerShell that is Windows-specific is
    referred to as *Windows PowerShell*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所讨论的 PowerShell 是跨平台的 PowerShell Core，简称*PowerShell*。而特定于 Windows 的 PowerShell
    称为*Windows PowerShell*。
- en: Windows PowerShell leverages the internal components and the architectural model
    of Windows with its capabilities enhanced by WinRM as well as Windows Management
    Instrumentation. In fact, most of the differences exist because of the inherent
    differences between Windows and Unix-like operating systems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Windows PowerShell 利用 Windows 的内部组件和架构模型，其能力通过 WinRM 和 Windows 管理工具增强。事实上，大多数差异的存在是因为
    Windows 和类 Unix 操作系统之间的固有差异。
- en: Support for snap-ins
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 snap-ins 的支持
- en: PowerShell will not support the legacy version of modules, called **Snap-ins**.
    Many of the snap-ins of old have been repackaged to be binary modules, and therefore,
    this should not be much of a concern, because future development of these should
    in theory work on either PowerShell, provided the system calls in the binaries
    can work on the system the binary is running on. For example, even if the Windows
    Active Directory module were repackaged into a binary PowerShell module, it would
    run on Windows PowerShell as well as PowerShell on Windows, but not on PowerShell
    on Linux because Windows Active Directory does not run on Linux.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 不支持传统的模块版本，称为**Snap-ins**。许多旧版的 snap-ins 已被重新打包为二进制模块，因此这不应成为大问题，因为这些模块的未来开发理论上应该可以在
    PowerShell 上运行，只要二进制文件中的系统调用能够在其运行的系统上工作。例如，即使 Windows Active Directory 模块被重新打包为二进制
    PowerShell 模块，它也能在 Windows PowerShell 和 Windows 上的 PowerShell 中运行，但无法在 Linux 上的
    PowerShell 中运行，因为 Windows Active Directory 无法在 Linux 上运行。
- en: Convenience aliases
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 便捷的别名
- en: One important point to note is that commands like `ls` and `mkdir` are aliases
    in Windows PowerShell, which means, running `ls` on Windows PowerShell would run
    `Get-ChildItem` in the background (this is also true for PowerShell on Windows).
    In Linux, however, running `ls` from within PowerShell would run the actual `ls`
    command; `ls` is not an alias in PowerShell on Linux, it is the command itself,
    whose output would be plain text. You can validate this by running `ls | Get-Member`
    on PowerShell on Linux, and compare it with PowerShell on Windows as well as Windows
    PowerShell. (It is, therefore, good to stick to the best practice of not using
    aliases in scripts.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的重要点是，像 `ls` 和 `mkdir` 这样的命令在 Windows PowerShell 中是别名，这意味着在 Windows PowerShell
    中运行 `ls` 会在后台执行 `Get-ChildItem`（Windows 上的 PowerShell 也是如此）。然而，在 Linux 中，在 PowerShell
    中运行 `ls` 会运行实际的 `ls` 命令；在 Linux 上的 PowerShell 中，`ls` 不是别名，而是命令本身，其输出将是纯文本。你可以通过在
    Linux 上的 PowerShell 中运行 `ls | Get-Member` 来验证这一点，并与 Windows 上的 PowerShell 以及 Windows
    PowerShell 进行对比。（因此，最好遵循不在脚本中使用别名的最佳实践。）
- en: '![](img/f38b4dcd-f484-4673-9559-92e752c14a42.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f38b4dcd-f484-4673-9559-92e752c14a42.png)'
- en: PowerShell knows whether it is running on Linux, Windows or Mac OS by means
    of the values of the automatic variables, `IsLinux`, `IsWindows` and `IsMacOS`.
    On any system, only one of these variables has the value, `True`. When PowerShell
    sees that `IsLinux` is `True`, it would run Linux commands instead of the convenience
    aliases that were initially created to facilitate Linux administrators. For more
    information on these automatic variables, read the recipe, *Configure built-in
    variables*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 通过自动变量 `IsLinux`、`IsWindows` 和 `IsMacOS` 的值来判断自己运行在哪个操作系统上。在任何系统中，这些变量只有一个是
    `True`。当 PowerShell 发现 `IsLinux` 为 `True` 时，它会运行 Linux 命令，而不是最初为了方便 Linux 管理员创建的别名。有关这些自动变量的更多信息，请阅读配方
    *配置内建变量*。
- en: PowerShell Workflows
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 工作流
- en: Windows administrators who are used to PowerShell Workflows in Windows PowerShell
    need to note that they are absent in PowerShell. PowerShell Workflows were a little
    advanced, (to put it nicely), and were used in specific scenarios, where multiple
    cmdlets were to be run in parallel, or activities had to, say, survive a reboot.
    Workflows work on the Windows Workflow Foundation, which isn't cross-platform.
    Therefore, PowerShell Workflows will not run on PowerShell. Understand, though,
    that this is no loss at all.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯于 Windows PowerShell 工作流的 Windows 管理员需要注意，PowerShell 中没有这些功能。PowerShell 工作流稍微复杂（可以这么说），用于特定场景，如需要并行运行多个
    cmdlet 或活动需要在重启后继续执行。工作流是基于 Windows 工作流基础（Windows Workflow Foundation）的，而这并不跨平台。因此，PowerShell
    工作流无法在 PowerShell 中运行。但请理解，这根本不是什么损失。
- en: PowerShell Desired State Configuration
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 期望状态配置
- en: 'Desired State Configuration is work-in-progress as of writing this chapter.
    As of now, there are two codebases of DSC resources: LCM for Linux, which is managed
    by Microsoft''s Unix team, and the other, DSC Resources for Windows PowerShell
    written by the PowerShell team. It would be some time before the DSC codebase
    becomes cross-platform.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的期望状态配置（Desired State Configuration，DSC）目前仍在开发中。到目前为止，DSC 资源有两个代码库：一个是由 Microsoft
    的 Unix 团队管理的 Linux 版 LCM，另一个是由 PowerShell 团队编写的 Windows PowerShell 版 DSC 资源。DSC
    代码库跨平台化还需要一段时间。
- en: Listing out the aliases and using them in place of cmdlets
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有别名并用它们替代 cmdlet
- en: 'Aliases, as the meaning goes, are alternative names to cmdlets. They serve
    two purposes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 别名，顾名思义，是 cmdlet 的替代名称。它们有两个目的：
- en: Reduce the number of keystrokes
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少击键次数
- en: Make the transition to PowerShell smoother
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使过渡到 PowerShell 更加顺畅
- en: Traditionally, aliases were created in PowerShell so that Windows and Linux
    administrators did not find the new framework intimidating to work with. Regardless,
    aliases are best used only on the command line, and not in scripts, because some
    aliases are not aliases in Linux, and in general, aliases affect readability.
    (For instance, it would take conscious effort to realise that `gbp` stands for
    `Get-PSBreakPoint`.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，别名是在 PowerShell 中创建的，以便让 Windows 和 Linux 管理员不觉得新的框架难以使用。然而，别名最好只在命令行中使用，而不是脚本中，因为有些别名在
    Linux 中并不存在，并且一般来说，别名会影响可读性。（例如，要意识到 `gbp` 代表的是 `Get-PSBreakPoint`，需要有意识的努力。）
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Now that the best practice has been looked at, let us now look at listing out
    all the aliases in the system. Like already mentioned, it is simple to think in
    PowerShell. When we know that the verb to fetch any information is `Get`, and
    the noun in this case would be `Alias`, the cmdlet could be `Get-Alias`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过最佳实践，接下来让我们看看如何列出系统中的所有别名。正如之前所提到的，在 PowerShell 中思考非常简单。当我们知道获取任何信息的动词是
    `Get`，而名词在这个例子中是 `Alias`，那么相应的 cmdlet 就是 `Get-Alias`。
- en: Running a quick `Get-Command` on `Get-Alias` would tell us whether there indeed
    is such a cmdlet.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个简单的 `Get-Command` 来查询 `Get-Alias`，我们就能知道是否确实有这个 cmdlet。
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let us now run `Get-Help` to understand how to use the cmdlet.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行 `Get-Help` 来了解如何使用该 cmdlet。
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you're unsure about any command, or would like to reduce keystrokes without
    involving aliases, use tab-completion. Write a part of the cmdlet or parameter,
    and press the Tab key. PowerShell will complete the command for you, or show you
    suggestions, based on which platform you're doing this on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定任何命令，或者想在不使用别名的情况下减少击键次数，可以使用 tab 补全。输入部分 cmdlet 或参数，然后按 Tab 键。PowerShell
    会根据你所在的平台，为你完成命令或提供建议。
- en: According to the help documentation, all the parameters for `Get-Alias` are
    optional (they are all enclosed in `[]`). Therefore, simply running `Get-Alias`
    would give us a list of all the aliases available in the current instance of PowerShell.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据帮助文档，`Get-Alias` 的所有参数都是可选的（它们都被 `[]` 括起来）。因此，仅运行 `Get-Alias` 将列出当前 PowerShell
    实例中所有可用的别名。
- en: '![](img/1365c009-4f5b-4083-9ee8-257073c8a995.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1365c009-4f5b-4083-9ee8-257073c8a995.png)'
- en: Let us now try to resolve the alias, `gbp` to the PowerShell cmdlet that it
    actually runs.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试解析别名`gbp`，找到它实际运行的 PowerShell cmdlet。
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let us now look at how to do the opposite: get the alias for a certain cmdlet.
    If you read the help documentation for this cmdlet, you''d see a parameter called
    `Definition` in the second parameter set. This is the actual PowerShell cmdlet
    that runs when an alias is called.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看如何做相反的操作：获取某个 cmdlet 的别名。如果你阅读此 cmdlet 的帮助文档，你会看到第二个参数集中有一个名为 `Definition`
    的参数。这就是调用别名时运行的实际 PowerShell cmdlet。
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can see two aliases as output, both of which run `Get-ChildItem` under the
    hood. Let us now run `dir` as well as `Get-ChildItem` and compare their outputs.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到两个别名作为输出，它们都在幕后运行 `Get-ChildItem`。现在我们运行 `dir` 和 `Get-ChildItem`，并比较它们的输出。
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The two outputs are identical. Let us now look at what type of object the commands
    return.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个输出是相同的。现在让我们看看这些命令返回的是哪种类型的对象。
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: They returned the same object as well.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也返回了相同的对象。
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Aliases are nothing but mappings done within PowerShell. The short words are
    mapped to PowerShell cmdlets, identified by the `Definition` property in each
    of the aliases. Therefore, you can use the aliases to in place of full cmdlets.
    Aliases also support the same parameters as the cmdlet as well, since aliases
    are merely pointers to the right cmdlet.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 别名只是在 PowerShell 中的映射。短单词被映射到 PowerShell cmdlet，在每个别名的 `Definition` 属性中识别。因此，你可以使用别名代替完整的
    cmdlet。别名还支持与 cmdlet 相同的参数，因为别名只是指向正确 cmdlet 的指针。
- en: See also
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Best Practices Roundup
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最佳实践总结
- en: Creating a Custom Alias
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义别名
- en: Aliases, as we saw in the previous recipe, are simply pointers to actual PowerShell
    cmdlets, and therefore, creating custom alias simply involves identifying a word
    for the alias you'd like to create, and map it to the PowerShell cmdlet that you'd
    like to call.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所见，别名只是指向实际 PowerShell cmdlet 的指针，因此，创建自定义别名只是涉及确定你希望使用的别名的单词，并将其映射到你想要调用的
    PowerShell cmdlet。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First, identify a word that you'd like to use as the alias. For example, let
    us consider `listdir`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确定你想用作别名的单词。例如，让我们考虑 `listdir`。
- en: Run listdir on PowerShell to ensure such a cmdlet (or a Linux command) does
    not already exist.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 上运行 `listdir`，确保不存在此类 cmdlet（或 Linux 命令）。
- en: 'List out the cmdlets that deal with aliases, by running:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令列出处理别名的 cmdlet：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember that the nouns in PowerShell are singular. Therefore, there would be
    no first-party cmdlet that contains `Aliases`. If third party modules give you
    `Aliases` as a noun in them, they are not following the PowerShell best practice
    of using only singular nouns.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，PowerShell 中的名词是单数形式。因此，不会有包含 `Aliases` 的第一方 cmdlet。如果第三方模块将 `Aliases` 作为名词使用，那么它们没有遵循
    PowerShell 的最佳实践，即仅使用单数名词。
- en: '`New-Alias` is the cmdlet we are looking for, since it creates a new alias.
    (`Set-Alias` is used to modify an alias that already exists.)'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`New-Alias` 是我们要找的 cmdlet，因为它用于创建一个新的别名。(`Set-Alias` 用于修改已存在的别名。)'
- en: 'Read the help documentation for `New-Alias` by running:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令，查看 `New-Alias` 的帮助文档：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The help document indicates that only the Name and the Value parameters are
    mandatory. We shall use only the two to create this simple alias.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助文档指出，只有 `Name` 和 `Value` 参数是必需的。我们将仅使用这两个来创建这个简单的别名。
- en: 'Run the following to create the custom alias:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建自定义别名：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See whether the alias was created as desired or not.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看别名是否按预期创建。
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Also, run the alias to see what output it gives.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，运行别名以查看它输出的内容。
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That is the output that we are familiar with–the output of `Get-ChildItem`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们熟悉的输出——`Get-ChildItem` 的输出。
- en: Aliases are ephemeral by default. They exist only as long as your PowerShell
    session exists. To use custom aliases without having to recreate them each time,
    export these aliases (the instructions for which are in the next recipe) and import
    them using your PowerShell profile. We will understand profiles in a later chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，别名是临时的。它们只在 PowerShell 会话存在时有效。为了避免每次都需要重新创建它们，你可以将这些别名导出（下一节将介绍操作步骤），并通过
    PowerShell 配置文件导入它们。我们将在后面的章节中了解配置文件。
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Aliases, as already mentioned, are pointers to cmdlets. Using `New-Alias`, you
    create a pointer with a custom name, that points to the desired PowerShell cmdlet.
    This is simply a Name–Value pair.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，别名是指向 cmdlet 的指针。使用 `New-Alias`，你可以创建一个带有自定义名称的指针，指向你想要的 PowerShell cmdlet。这实际上是一个名称-值对。
- en: When you run anything on PowerShell, PowerShell checks its list of cmdlets and
    aliases (among other definitions) to understand what you are asking for. When
    PowerShell encounters an alias, it looks for which cmdlet it points to, and runs
    the cmdlet.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 PowerShell 中运行任何命令时，PowerShell 会检查它的 cmdlet 和别名列表（以及其他定义），以理解你在请求什么。当 PowerShell
    遇到一个别名时，它会查找该别名指向的 cmdlet 并执行该 cmdlet。
- en: There's more...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: You can add more content to your aliases, such as descriptions. Refer the help
    documentation for `Get-Alias` to see what more you can do with aliases.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为别名添加更多内容，比如描述。请参考`Get-Alias`的帮助文档，看看你可以对别名做些什么。
- en: See also
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'Recipe 3.8: Understanding cmdlets and parameters'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方 3.8：理解 cmdlet 和参数
- en: 'Recipe 2.8: Importing/Exporting custom aliases for future use'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方 2.8：导入/导出自定义别名以便未来使用
- en: 'Recipe 3.4: Enabling automated execution of commands for each load'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方 3.4：启用每次加载时自动执行命令
- en: Export/Import Custom Aliases for Future Use
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出/导入自定义别名以便未来使用
- en: Aliases being ephemeral, in spite of its advantages and the intended use of
    aliases, could be seen as an inconvenience. In order that aliases can be reused,
    they need to be exported to a file and later, imported when needed. This recipe
    will show you how to export and import the aliases you may have created.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管别名具有优势且被设计用来临时使用，但它们的临时性可能会带来不便。为了使别名可以重复使用，需要将其导出到文件，并在需要时再导入。这个配方将展示如何导出和导入你可能已经创建的别名。
- en: Getting Ready
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need custom aliases already created for this process to be effective. If
    you don't have custom aliases created, the export action would only export the
    default aliases, which would be loaded with PowerShell anyway.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要先创建自定义别名，才能使此过程生效。如果你没有创建自定义别名，导出操作将仅导出默认别名，这些别名本来就在 PowerShell 中加载。
- en: Go to the previous recipe to create at least one custom alias.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请返回上一节，创建至少一个自定义别名。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: Ensure that your custom alias exists and runs properly. One way of doing this
    is to get details about the alias you created.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的自定义别名存在并正常运行。实现这一点的一种方法是获取你创建的别名的详细信息。
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Export all of the aliases loaded on your session to a file.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有加载到当前会话中的别名导出到文件。
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: CSV is the default file type. The import that we would see in the coming steps
    understands CSV and make the necessary associations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 是默认的文件类型。我们在接下来的步骤中看到的导入操作理解 CSV 并做出必要的关联。
- en: It is also possible to export the aliases as a script. This way, PowerShell
    will create a script that would contain the New-Alias cmdlet for each of the aliases
    in the export.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也可以将别名导出为脚本。这样，PowerShell 将创建一个脚本，其中包含每个导出别名的 `New-Alias` cmdlet。
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Look at the contents of each of the files created; the CSV file first, and then
    the script.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看每个文件的内容；首先是 CSV 文件，然后是脚本。
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![](img/56717d30-2937-4bac-89c4-634503efc8e8.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56717d30-2937-4bac-89c4-634503efc8e8.png)'
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](img/bdf72b32-a228-470f-ac21-ad35d4e8013a.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdf72b32-a228-470f-ac21-ad35d4e8013a.png)'
- en: Optionally, edit the file to remove all the aliases except the ones you created.
    The custom aliases can be found at the bottom of the list.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，编辑文件以删除除你创建的别名之外的所有别名。自定义别名可以在列表的底部找到。
- en: This concludes exporting aliases.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此为止，已完成别名导出部分。
- en: Let us now import aliases into our PowerShell session.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将别名导入到 PowerShell 会话中。
- en: Restart PowerShell.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启 PowerShell。
- en: See if the alias, `listdir`, that you created exists.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看你创建的别名`listdir`是否存在。
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, import the aliases.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导入别名。
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You may receive several errors, each saying that the new alias could not be
    created since the alias already existed. There are two ways to handle this: the
    first is to remove the default aliases from the export file (which is recommended),
    and the second is to use the `-Force` parameter (this may still result in errors,
    but they would be significantly fewer).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会收到多个错误，提示新别名无法创建，因为该别名已存在。处理方法有两种：第一种是从导出文件中移除默认别名（推荐），第二种是使用`-Force`参数（这可能仍会导致错误，但错误会显著减少）。
- en: If you exported the aliases as a script, simply call the script.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将别名导出为脚本，只需调用该脚本即可。
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The script way is straight-forward: the cmdlets are run one after the other
    and the aliases are created in the system just like how you created them manually.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本方式很简单：命令按顺序运行，别名像你手动创建它们一样在系统中创建。
- en: With the CSV import, PowerShell parses the input into the Name–Value pairs (and
    add other parameters based on what you exported) and add them to its alias reference
    for the current process.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSV导入时，PowerShell会将输入解析为名称-值对（并根据导出的内容添加其他参数），并将其添加到当前进程的别名引用中。
- en: See also
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'Recipe 3.4: Enabling automated execution of commands for each load'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方 3.4：为每次加载启用自动执行命令
- en: Listing out the execution policies and setting a suitable one
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出执行策略并设置合适的策略
- en: There was a time when running scripts on Windows computers was a piece of cake.
    Windows computers were highly prone to remote script executions. With PowerShell,
    Microsoft added a safety belt that allowed the user some control over how PowerShell
    scripts were loaded. Some specific models of script executions got restricted,
    which plugged some holes in the system.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，在Windows计算机上运行脚本是一件轻松的事。Windows计算机极易受到远程脚本执行的攻击。随着PowerShell的出现，微软为用户提供了一种安全带，使用户能够控制PowerShell脚本的加载方式。某些特定的脚本执行模型被限制，弥补了系统中的一些漏洞。
- en: It is important to remember that execution policies are **not** a security feature.
    There are ways to circumvent this fence and still run scripts. Execution policies
    are in place to ensure users don't accidentally run scripts without awareness.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，执行策略**不是**一种安全功能。存在绕过此限制并运行脚本的方法。执行策略的目的是确保用户不会在不知情的情况下意外运行脚本。
- en: PowerShell on Windows and Windows PowerShell contain the configuration. Running
    PowerShell scripts on Windows is still restricted by default. On PowerShell on
    Linux, this doesn't work at the moment, and based on the interactions in the community,
    it is uncertain whether this feature would make it to PowerShell on Linux.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Windows上的PowerShell和Windows PowerShell包含此配置。默认情况下，Windows上的PowerShell脚本仍然是受限制的。而在Linux上的PowerShell，目前不支持此功能，并且根据社区中的互动，尚不确定该功能是否会引入到Linux版PowerShell中。
- en: 'An execution policy determines what type of execution of scripts is allowed.
    Here are the six execution policies (excluding Default):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略决定了允许执行脚本的类型。以下是六种执行策略（不包括默认策略）：
- en: AllSigned
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AllSigned
- en: RemoteSigned
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RemoteSigned
- en: Restricted
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Restricted
- en: Unrestricted
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unrestricted
- en: Bypass
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bypass
- en: Undefined
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Undefined
- en: 'There are three scopes as well:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个作用域：
- en: Process
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程
- en: CurrentUser
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CurrentUser
- en: LocalMachine
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LocalMachine
- en: A combination of an execution policy and a scope are what determine the condition
    which scripts can be loaded under. Microsoft has documented in detail what each
    of the policies is. In general, AllSigned requires that all the scripts that run
    on the computer are signed using a code signing certificate by a trusted certification
    authority. If this policy is set, PowerShell will not run unsigned scripts even
    if you were the one to create them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略和作用域的组合决定了脚本可以在哪些条件下加载。微软已经详细记录了每种策略的含义。一般来说，AllSigned要求所有在计算机上运行的脚本都必须由受信任的证书颁发机构使用代码签名证书进行签名。如果设置了此策略，即使是你自己创建的脚本，PowerShell也不会运行未签名的脚本。
- en: '**Restricted** is the default policy: Commands can be run, but not scripts. **RemoteSigned**
    allows scripts created on your own computer to run. Scripts that are downloaded
    from the Internet cannot be run.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**Restricted**是默认策略：可以运行命令，但不能运行脚本。**RemoteSigned**允许在本地计算机上创建的脚本运行。来自互联网的下载脚本无法运行。'
- en: '**Bypass** is similar to unrestricted, however, is used in specific scenarios
    such as when PowerShell forms the basis of a certain application, and the application
    has its own security implementation.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bypass**类似于Unrestricted，但用于特定场景，例如当PowerShell构成某个应用程序的基础时，该应用程序有其自己的安全实现。'
- en: '**Unrestricted** means that all scripts and commands can run after a simple
    confirmation. **Undefined** means that no policy has been defined for a particular
    scope. Let us try to understand the concepts using the following recipe.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe needs Windows to work. If you're running a pure Linux environment,
    you cannot work with this recipe. You may run the commands, but you would see
    the Unrestricted policy set at all levels.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: If you can get your hands on a Windows computer, you can proceed with this recipe
    regardless of whether it has PowerShell or Windows PowerShell.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a PowerShell window  by running `pwsh` or `powershell`. The `pwsh` command
    calls PowerShell, and `powershell` calls Windows PowerShell.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Windows PowerShell comes preinstalled on all modern Windows products; PowerShell,
    on the other hand, has to be installed. Note that all of the current PowerShell
    cmdlets will run as well on Windows PowerShell.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: First, run the Get-Command cmdlet to know how to work with execution policies.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![](img/ad67d754-eabc-404d-bf92-3014549f8ff6.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: Let us now get help on running the cmdlet.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We want to know the execution policy set on the machine, therefore, we would
    run:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![](img/69fa2f0d-8c11-4129-9c73-e4967f4357b5.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: This shows the execution policy currently effective on the current PowerShell
    session.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'To list out the policies set at various scopes, run the following command:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![](img/5db273a2-fe7e-4915-b9ad-c590063310a7.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
- en: We see that the policy is only set at the LocalMachine level, and it is set
    at RemoteSigned, which is the same as that reflected in the previous step. The
    policy at the LocalUser and the Process scopes is Undefined, which made the session
    pick the execution policy from LocalMachine.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Let us now set the execution policy for the local machine to be Undefined and
    see what our session picks up.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, close the current PowerShell session and open a new session
    as the administrator.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, run the command:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![](img/e039790c-5185-4b1d-96be-38b1391f12e3.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: The help document shows that the value of the ExecutionPolicy parameter is mandatory,
    and that Undefined is one of the valid values it would accept. We want to set
    the policy at the LocalMachine scope, therefore,
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, list out the execution policies at the various scopes:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![](img/7a2cad04-6a65-480e-9d9f-14d60b2a8e9b.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'Now, let us check the currently-effective execution policy:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![](img/91d88fe3-665a-4ea8-b9c7-1e3ab057e777.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: Let us now set the execution policy back to how it was before we began the recipe.
    You may want to change the policy to suit your needs, based on what authority
    you have on the computer.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Execution policies are nothing but conditions set on the system to avoid accidental
    script runs. They work at different scopes.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: There are three scopes in PowerShell, as noted already. The **LocalSystem**
    scope is at the end of the chain. Right above it is the **CurrentUser** scope.
    At the top, is the **Process** scope. The level of precedence is Process > CurrentUser
    > LocalMachine. Therefore, if any policy other than Undefined is set at the Process
    scope, the session would use the policy set on the process. In case it's Undefined,
    it would look for the policy set on the CurrrentUser scope. If CurrentUser has
    the policy marked as Undefined as well, the session would apply the policy applied
    at the LocalMachine level. If LocalMachine has Undefined set, the session would
    pick the Default policy, which is based on what PowerShell has defined as the
    policy, which may vary based on the version of operating system. On Windows 2016,
    for instance, the default policy is RemoteSigned.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所提到的，PowerShell 中有三种作用域。**LocalSystem** 作用域位于链条的末端。它上面是 **CurrentUser**
    作用域。最上面的是 **Process** 作用域。优先级的顺序是：Process > CurrentUser > LocalMachine。因此，如果在
    Process 作用域设置了除 Undefined 以外的策略，当前会话将使用在进程上设置的策略。如果是 Undefined，则会查找在 CurrentUser
    作用域上设置的策略。如果 CurrentUser 也标记为 Undefined，那么会话将应用在 LocalMachine 级别上设置的策略。如果 LocalMachine
    设置为 Undefined，则会话将选择默认策略，这个默认策略是基于 PowerShell 所定义的策略，具体内容可能会根据操作系统版本而有所不同。例如，在
    Windows 2016 中，默认策略是 RemoteSigned。
- en: The policies set at the CurrentUser and LocalMachine levels are stored in the
    Windows Registry. The policy set on the Process scope is stored in the ephemeral
    environment variable, `$env:PSExecutionPolicyPreference`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CurrentUser 和 LocalMachine 级别上设置的策略会存储在 Windows 注册表中。Process 作用域上设置的策略则存储在临时环境变量
    `$env:PSExecutionPolicyPreference` 中。
- en: See also
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: '[About_Execution_Policies](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6)
    (Microsoft)'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[执行策略简介](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6)
    (Microsoft)'
