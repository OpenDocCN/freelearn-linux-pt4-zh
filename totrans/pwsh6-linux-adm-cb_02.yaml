- en: Introducing the Core and its Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting a .NET Core object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Breaking down an output into different objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parsing input from text to object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comparing the outputs of Bash and PowerShell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comparing Windows PowerShell and PowerShell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listing out the aliases and using them in place of cmdlets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom alias
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing/Exporting custom aliases for future use
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listing out the execution policies and setting a suitable one
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft's announcement of "open sourcing" .NET in 2014 almost stirred a storm.
    Many rushed to the stands (so to speak) to read about the unbelievable—how could
    Microsoft possibly open-source the core of their operating system? Some were cynical,
    others rejoiced. Then came the announcement a little louder and clearer that .NET
    Core was open source, not the .NET Framework. Many said .NET Core was a subset
    of .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: .NET was first announced in 2000, as a new platform based on Internet standards.
    Along with it, by the end of the year, Microsoft published the **Common Language
    Infrastructure** as a standard, so that anyone who wanted, could write their own
    .NET framework based on those standards. .NET Framework has been the basis of
    Windows since the noughties.
  prefs: []
  type: TYPE_NORMAL
- en: Windows PowerShell was released to the general market in 2006, as an implementation
    of .NET Framework, focussed on system administrators (or sysadmins, to enable
    them to better manage their Windows workloads and automate tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In June of 2016, Microsoft released a collaboratively refactored, more modern
    and efficient .NET. The .NET Core was officially born. While .NET Framework continues
    to rule the Windows arena, .NET Core, which is open source and cross-platform,
    has picked up great momentum and continues to grow. And .NET Core seems to be
    the way forward.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell (not *Windows* PowerShell) is based on .NET Core, and therefore,
    is open source, with the same vision as .NET Core to be cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at a very simple implementation of .NET Core and
    compare it to the output of PowerShell to prove that PowerShell is nothing but
    encapsulated .NET Core code. Along with it, we shall look at the general behaviour
    of PowerShell as well.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting a .NET Core Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core works on a cross-platform standard Common Language Infrastructure.
    Therefore, it has been possible to encapsulate the internal workings of Linux
    using .NET Core. As we would see in the future chapters, PowerShell is object-oriented,
    just like .NET Core. For this demonstration, we would pick a simple system class,
    called `System.IO.DirectoryInfo` to show information about a certain directory.
    We will also compare the output .NET Core object to the output of a PowerShell
    cmdlet which also shows information about a certain directory.
  prefs: []
  type: TYPE_NORMAL
- en: You do not have to remember the names of the .NET Core classes, methods or their
    syntaxes to work with PowerShell; that's the whole point of the existence of PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you followed along the last chapter, you should already have PowerShell installed
    on your Linux computer; open a terminal window and type in `pwsh` to invoke PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every **object** has members—**properties** and **methods**. In case you''re
    new to the concepts of Object Oriented Programming, properties are qualities of
    an object (what the object has), and methods are the capabilities of an object
    (what the object can do). Therefore, to quote (arguably) the most overused example
    of properties and methods: If a horse is an object, its height, its colour, etc.
    would be its properties; galloping, eating, etc. would be the methods that the
    object supports.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With PowerShell, .NET Core is also installed as a dependency. Let us create
    an object in PowerShell, which would call a .NET class and its default constructor.
    This constructor requires an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us information on the directory specified, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is a cmdlet in PowerShell,  called, `Get-Item`, which gives us details
    about a directory. Let us call this cmdlet with the same argument as before, and
    see what we get.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Close! Let us now look at the *details* of the output object we just received,
    using the `Get-Member` cmdlet on the output of `Get-Item`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`Get-Member` shows all the members available in the output object (most PowerShell
    cmdlets return objects as output, not plain text). For more information, run `Get-Help
    Get-Member`.'
  prefs: []
  type: TYPE_NORMAL
- en: This would list a series of members that are part of the output. We're primarily
    concerned about the very first line for now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Notice the very first line of the output, `TypeName: System.IO.DirectoryInfo`.
    That is the exact type name we used when creating the .NET object.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1e7e64f-6963-4c88-9e96-ee87651fba00.png)'
  prefs: []
  type: TYPE_IMG
- en: This proves that the same task of showing information on the current working
    directory can be achieved by calling a .NET constructor, or by running a PowerShell
    cmdlet. Therefore, we infer that PowerShell cmdlets are simply encapsulated .NET
    code, simplified to enable administrators to work with computers, without having
    to worry about the underlying .NET code.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, `Get-Item` calls the `System.IO.DirectoryInfo` class under the hood,
    with the arguments passed along with the cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-Item` can be used with any location in your file system. As long as you
    are authorised to access the location, PowerShell would return information about
    the location you pass as the argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like they say:'
  prefs: []
  type: TYPE_NORMAL
- en: If the C# guys can do it, so can you.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the output of the `Get-Item | Get-Member` command to understand what more
    information you can get about the directory you specify. Also, after we are comfortable
    using the `Select-Object` cmdlet, we should be able to call specific fields from
    the returned objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET class, [System.IO.DirectoryInfo](https://msdn.microsoft.com/en-us/library/system.io.directoryinfo(v=vs.110).aspx)
    (Microsoft Developer Network)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Breaking down an output into different objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw that an object can have properties as well as
    methods. These properties and methods are known as members. In the object oriented
    approach to programming (and by extension, administration using PowerShell), it
    is possible to reference these properties as well as methods of an object using
    the **member access operator**, which is a single dot (`.`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, this recipe should be an extension to the previous. If you did not
    run the previous commands, it is suggested that you do, and then proceed with
    the steps below.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look at the output of the following command from the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output table contains the name of the member, the type and the definition.
    Take a look at the `MemberType` column; you have `Method`, and different kinds
    of properties such as `CodeProperty` and `Property`.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we would like to see when my home directory was last written to.
    We would refer to this property using the member access operator. To do this,
    simply enclose in parenthesis the `Get-Item` command along with its argument and
    refer to the property using the dot operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, let us pick the property, `Parent`, of the object. This should give us
    the details of the directory which my home directory resides in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This output in itself is an object, which means that we can fetch last write
    time and other details of this returned object, just like how we did for `/home/ram`.
    How do we see when the parent folder (`/home`) was created?
  prefs: []
  type: TYPE_NORMAL
- en: First, let us use the `Get-Member` cmdlet on this object and see the `TypeName`
    of the returned object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is the same as `Get-Item` itself. Therefore, any of the members of `Get-Item
    /home/ram` apply to `(Get-Item /home/ram).Parent` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now call the `CreationTime` property on the parent object. Simply add a dot
    next to `Parent`, and call the `CreationTime` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `CreationTime` property is an object in itself, of the type, `DateTime`.
    Therefore, you can perform date and time operations on this object.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell is not case-sensitive most of the time. However, it is recommended
    we stick to the conventions in order to minimise errors. Especially since case
    sensitivity is a convention in Linux. Properties could be of different data types.
    The data type can be seen in the `Definition` column.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at the members of the `CreationTime` object to see if we can further
    filter the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let us pick only the year property from this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This concludes picking properties from within the returned objects. Next, let
    us use a method from within the returned object and create a sub-directory under
    `/home/ram`.
  prefs: []
  type: TYPE_NORMAL
- en: First, list out the existing directories under the directory. This is done using
    the cmdlet, `Get-ChildItem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Get-Item` gives you details about the directory itself. In essence, this cmdlet
    deals with the current item at hand. Therefore, you have properties and methods
    that align with that intention. Child items, on the other hand, mean the files
    and directories that are *within* the said item.'
  prefs: []
  type: TYPE_NORMAL
- en: That is a list of standard directories in a user profile. Let us now create
    a sub-directory within this profile folder, using a method in `Get-Item`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To know what argument a certain method accepts, look in the `Definition` column
    of the output of `Get-Member`. In case of `CreateSubdirectory`, the definition
    is `System.IO.DirectoryInfo CreateSubdirectory(string path)`.
  prefs: []
  type: TYPE_NORMAL
- en: You should now get a confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5608bd8-b8e8-471a-8413-8002dc6cf776.png)'
  prefs: []
  type: TYPE_IMG
- en: Excellent. Now, list out the directories under the home directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can now see the new directory that we created using the `CreateSubdirectory`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Running `Get-ChildItem`, as you may notice, is similar to running the `GetDirectories`
    and `GetFiles` methods of the object returned by `Get-Item`. This is another example
    of encapsulation in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the properties and methods within a returned object is simple. Objects
    from within the output returned by a cmdlet can be called using the member access
    operator directly on the command (cmdlet including the parameter).
  prefs: []
  type: TYPE_NORMAL
- en: Calling properties after the member access operator fetches the data that's
    held within the property. In our case, it was the `LastWriteTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Methods are functions. They may or may not require an argument. The `CreateSubdirectory`
    method requires a string argument, which is the name (or path) of the sub-directory
    we wish to create—whatever we enter in the parenthesis essentially forms the path
    we wish to create. In case of methods that can run without an argument, they need
    to be called with empty parenthesis following the name of the method, like `ToString()`,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: When we pass the string argument into `CreateSubdirectory`, the method runs
    a .NET Core routine and creates a sub-directory within the directory we specify
    with `Get-Item`. The internal workings of the .NET Core is beyond the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe: Selecting objects via the pipeline'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parsing input from text to object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving to the object model from text could seem a little daunting at first.
    However, with PowerShell, it is not very hard to switch to the new model, especially
    given that PowerShell can convert text into objects given the right tools. In
    this recipe, we would look at two of the ways that PowerShell converts textual
    data into objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the recipe, let us give ourselves a little introduction
    on how text-to-object parsing is handled. One way is to use .NET's built-in functionality,
    and the second one that we discuss involves using a cmdlet to perform the conversion
    based on a delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic requirement for this recipe is simple: you simply need PowerShell
    installed on your computer. We will edit the file within PowerShell. If you would
    be comfortable using a text editor instead, that works as well. Most Linux distributions
    pack a text editor. If not, use your package manager to install Vim, Nano, Gedit,
    Visual Studio Code, Atom or any other text/code editor.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We shall first look at converting text into an object from plain text input
    at the terminal. This involves using what is known as a **PowerShell Type Accelerator**.
    A PowerShell Type Accelerator is a an alias for .NET classes. Using these, we
    can call .NET classes and use many of their functionalities within PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Let us take plain text as input and convert the text into a date object. To
    check what sort of object your input is, use the `Get-Member` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Enclosing any text within single quotes defines the text as a **non-expanding
    literal string**. No explicit definition is required in this case, in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: The `TypeName` says, `System.String`. This confirms that what we entered was
    plain text. Let us now use a Type Accelerator and convert this text into a `DateTime`
    object. The accelerator for this purpose is `[DateTime]`; place this accelerator
    before the literal string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, find the `TypeName` of the object that was returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Voila, the string has been successfully parsed into date and time!
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to achieve the same result with the cmdlet, `Get-Date`,
    when it is called with the text argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `TypeName` would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we did in the previous recipe, we can now manipulate the object to
    show information in a more meaningful way. For instance, if you care only about
    the year, you would write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The other way of converting text into an object is to use cmdlets that perform
    such tasks. PowerShell packs a few converter cmdlets, one of which is `Import-Csv`.
    You may have noticed that PowerShell usually sends out output in a tabular format.
    This is a simple representation of objects. And `Import-Csv` converts data in
    delimited row-and-column structure into objects, where each row is an instance
    of the object itself, and each column is a property of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let us create a CSV file with the following content in
    it. At the PowerShell prompt, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This would take you to the next line; PowerShell is expecting input. Paste the
    following sample content at the prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the next line and enter the following at the `>>` prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You could perform the same operation using the `touch` command and the text
    editor of your choice. The goal is to get the content into the sample file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, read the contents of the file using PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That looks like simple text. Let us look at the type name of the object to
    confirm that this is indeed plain text. Type in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That is plain and simple string. Let us now convert the content into a simple
    object. This is done using `Import-Csv`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That should give you a list-like output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/421790f7-a304-47d2-8a53-8d8b24057760.png)'
  prefs: []
  type: TYPE_IMG
- en: To confirm the output is objects, list out its members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ce2642a-5e63-4f99-85ca-3dcba5ee4bcb.png)'
  prefs: []
  type: TYPE_IMG
- en: In general, the content is a custom object, as denoted by `PSCustomObject`.
    The columns we had in the CSV are of type `NoteProperty`, as shown by `MemberType`.
  prefs: []
  type: TYPE_NORMAL
- en: A `NoteProperty` is a generic property, whose characteristics are similar to
    string. While most properties are inherited from .NET, `NoteProperty` is custom-created
    within PowerShell, as a name-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: If you would rather look at the content as a table, format the content as a
    table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/653c86b0-0db0-4230-9e4d-86c4a23a5109.png)'
  prefs: []
  type: TYPE_IMG
- en: That brings us to the end of this recipe. We have successfully converted text
    into an object. However, note that this is just a simple conversion, and that
    the output of `Import-Csv` is still string-like. Although, all of the content
    is now objects, which are easier to handle in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type Accelerators are another form of encapsulation of .NET code in PowerShell.
    Remember the first recipe in this chapter wherein we created a .NET object within
    PowerShell. We used the PowerShell command, `New-Object -TypeName System.IO.DirectoryInfo
    -ArgumentList ''/home/ram''` to get information on a home directory: we created
    a new instance of `System.IO.DirectoryInfo`, and passed an argument to it. That
    was a lot of code to write. To accelerate the process, we could use, `[IO.DirectoryInfo]''/home/ram''`,
    (`System` is the default namespace; PowerShell would understand it without us
    explicitly mentioning it when calling accelerators) which outputs the same object
    as the former command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `Import-Csv` on the other hand, the process was a simple conversion of
    data from text into name-value pairs. This is similar to using `ConvertFrom-Text`
    with a `Delimiter` parameter. This way, we instruct PowerShell to convert each
    row of text into instances of the object: The first row in the row-column structure
    is taken as the property name, and the rest of the rows are data. The cells are
    separated using  delimiter, which was a comma, in case of the CSV file.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look for more conversion cmdlets built into PowerShell. This can be done using
    the command, `Get-Command -Verb ConvertFrom`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More about Type Accelerators in the [Hey, Scripting Guy! Blog](https://blogs.technet.microsoft.com/heyscriptingguy/2013/07/08/use-powershell-to-find-powershell-type-accelerators/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recipe: Using Here strings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [different kinds of members](https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.psmembertypes?view=pscore-6.0.0)
    in PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Best Practices Roundup: Formatting only in the end.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comparing the outputs of Bash and PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell and Bash are both shells, and are capable of interacting with the
    kernel. Just like how Bash can run on Windows, PowerShell can now run on Linux.
    While almost all of the aspects of which shell is better than the other is debatable,
    and the choice of shell is simply a matter of personal preference today, it is
    true that PowerShell is as powerful as .NET Core can get.
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference between the two shells is, like we have seen before,
    that PowerShell outputs objects, while Bash returns text. Manipulation of the
    output in Bash involves manipulating text first, and then running further commands
    on the manipulated text to fetch the desirable output. PowerShell, on the other
    hand, handles content as objects and by design, requires comparatively less manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Structured data, as noted by Jeffrey Snover (the inventor of Windows PowerShell),
    is getting popular as days pass, and structured data is where PowerShell shines
    the most.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to pick one example to show how simple and efficient
    it is to handle file metadata using PowerShell, primarily since the output is
    an object. We will list the files and folders within our home directory, along
    with the date and time of modification using both, `ls` in Bash and `Get-ChildItem`
    in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up two instances of the terminal if you would so like: launch `pwsh` on
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the Bash prompt, enter `ls -l` to list out all the files along with the metadata
    that the command shows by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eaf2fd5f-b91c-43ce-8e94-a7f1d764df1e.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to the terminal that has PowerShell running, and type in `Get-ChildItem`
    at the prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b2226dc9-7aae-4763-a1ec-249384383e49.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let us pick only the name of the folders and the last-modified date and
    time. This is done in Bash by passing the output of `ls -l` to `awk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f56c057d-072d-4881-a844-5885d5270466.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let us pick the same information on PowerShell as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/94508b98-e2da-4f79-b637-8753329401cf.png)'
  prefs: []
  type: TYPE_IMG
- en: If you notice, the output is very similar in both the cases, however, with PowerShell,
    you see the names of the columns as well, which means that you don't have to look
    for further documentation. Also, the selection of columns is simpler in PowerShell;
    no text manipulation is required. On the other hand, in Bash, we use the `awk`
    command to manipulate the text output.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go one step further and create a sub-directory with a space in the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/60488ba8-6c4c-45d1-b5bf-145f2fc1134f.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that what should have been `test subdirectory`, appears as `test`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell reads content from the file system as objects, not as text. Therefore,
    you perform a selection of the desired columns (or as we shall later see, properties)
    directly. Bash, on the other hand, outputs text, columns from which are manipulated
    using a delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate that this is the case, we created a new subdirectory with a space
    in its name, and we performed the column selection same as before, only in this
    case, we did not get the complete name of the new subdirectory, because the name
    contained a white space, which is a delimiter in `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Bash and PowerShell is like comparing apples and oranges—in more ways
    than one. However, understanding the differences helps us leverage each of the
    tools to our benefit.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe: Selecting objects via the pipeline.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comparing Windows PowerShell and PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell and Windows PowerShell are two different implementations. The former
    is based on a larger framework, the .NET Framework. The latter, on the other hand
    is a more modern framework, the .NET Core. PowerShell is cross-platform since
    its parent is. Windows PowerShell, on the other hand, is Windows-only, but has
    more capabilities than PowerShell, as of writing this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell that this book talks about is the cross-platform PowerShell Core.
    This is referred to as *PowerShell*. The PowerShell that is Windows-specific is
    referred to as *Windows PowerShell*.
  prefs: []
  type: TYPE_NORMAL
- en: Windows PowerShell leverages the internal components and the architectural model
    of Windows with its capabilities enhanced by WinRM as well as Windows Management
    Instrumentation. In fact, most of the differences exist because of the inherent
    differences between Windows and Unix-like operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Support for snap-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell will not support the legacy version of modules, called **Snap-ins**.
    Many of the snap-ins of old have been repackaged to be binary modules, and therefore,
    this should not be much of a concern, because future development of these should
    in theory work on either PowerShell, provided the system calls in the binaries
    can work on the system the binary is running on. For example, even if the Windows
    Active Directory module were repackaged into a binary PowerShell module, it would
    run on Windows PowerShell as well as PowerShell on Windows, but not on PowerShell
    on Linux because Windows Active Directory does not run on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Convenience aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important point to note is that commands like `ls` and `mkdir` are aliases
    in Windows PowerShell, which means, running `ls` on Windows PowerShell would run
    `Get-ChildItem` in the background (this is also true for PowerShell on Windows).
    In Linux, however, running `ls` from within PowerShell would run the actual `ls`
    command; `ls` is not an alias in PowerShell on Linux, it is the command itself,
    whose output would be plain text. You can validate this by running `ls | Get-Member`
    on PowerShell on Linux, and compare it with PowerShell on Windows as well as Windows
    PowerShell. (It is, therefore, good to stick to the best practice of not using
    aliases in scripts.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f38b4dcd-f484-4673-9559-92e752c14a42.png)'
  prefs: []
  type: TYPE_IMG
- en: PowerShell knows whether it is running on Linux, Windows or Mac OS by means
    of the values of the automatic variables, `IsLinux`, `IsWindows` and `IsMacOS`.
    On any system, only one of these variables has the value, `True`. When PowerShell
    sees that `IsLinux` is `True`, it would run Linux commands instead of the convenience
    aliases that were initially created to facilitate Linux administrators. For more
    information on these automatic variables, read the recipe, *Configure built-in
    variables*.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows administrators who are used to PowerShell Workflows in Windows PowerShell
    need to note that they are absent in PowerShell. PowerShell Workflows were a little
    advanced, (to put it nicely), and were used in specific scenarios, where multiple
    cmdlets were to be run in parallel, or activities had to, say, survive a reboot.
    Workflows work on the Windows Workflow Foundation, which isn't cross-platform.
    Therefore, PowerShell Workflows will not run on PowerShell. Understand, though,
    that this is no loss at all.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Desired State Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Desired State Configuration is work-in-progress as of writing this chapter.
    As of now, there are two codebases of DSC resources: LCM for Linux, which is managed
    by Microsoft''s Unix team, and the other, DSC Resources for Windows PowerShell
    written by the PowerShell team. It would be some time before the DSC codebase
    becomes cross-platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing out the aliases and using them in place of cmdlets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Aliases, as the meaning goes, are alternative names to cmdlets. They serve
    two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduce the number of keystrokes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the transition to PowerShell smoother
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traditionally, aliases were created in PowerShell so that Windows and Linux
    administrators did not find the new framework intimidating to work with. Regardless,
    aliases are best used only on the command line, and not in scripts, because some
    aliases are not aliases in Linux, and in general, aliases affect readability.
    (For instance, it would take conscious effort to realise that `gbp` stands for
    `Get-PSBreakPoint`.)
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the best practice has been looked at, let us now look at listing out
    all the aliases in the system. Like already mentioned, it is simple to think in
    PowerShell. When we know that the verb to fetch any information is `Get`, and
    the noun in this case would be `Alias`, the cmdlet could be `Get-Alias`.
  prefs: []
  type: TYPE_NORMAL
- en: Running a quick `Get-Command` on `Get-Alias` would tell us whether there indeed
    is such a cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let us now run `Get-Help` to understand how to use the cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you're unsure about any command, or would like to reduce keystrokes without
    involving aliases, use tab-completion. Write a part of the cmdlet or parameter,
    and press the Tab key. PowerShell will complete the command for you, or show you
    suggestions, based on which platform you're doing this on.
  prefs: []
  type: TYPE_NORMAL
- en: According to the help documentation, all the parameters for `Get-Alias` are
    optional (they are all enclosed in `[]`). Therefore, simply running `Get-Alias`
    would give us a list of all the aliases available in the current instance of PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1365c009-4f5b-4083-9ee8-257073c8a995.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us now try to resolve the alias, `gbp` to the PowerShell cmdlet that it
    actually runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now look at how to do the opposite: get the alias for a certain cmdlet.
    If you read the help documentation for this cmdlet, you''d see a parameter called
    `Definition` in the second parameter set. This is the actual PowerShell cmdlet
    that runs when an alias is called.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can see two aliases as output, both of which run `Get-ChildItem` under the
    hood. Let us now run `dir` as well as `Get-ChildItem` and compare their outputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The two outputs are identical. Let us now look at what type of object the commands
    return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: They returned the same object as well.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aliases are nothing but mappings done within PowerShell. The short words are
    mapped to PowerShell cmdlets, identified by the `Definition` property in each
    of the aliases. Therefore, you can use the aliases to in place of full cmdlets.
    Aliases also support the same parameters as the cmdlet as well, since aliases
    are merely pointers to the right cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best Practices Roundup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a Custom Alias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aliases, as we saw in the previous recipe, are simply pointers to actual PowerShell
    cmdlets, and therefore, creating custom alias simply involves identifying a word
    for the alias you'd like to create, and map it to the PowerShell cmdlet that you'd
    like to call.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, identify a word that you'd like to use as the alias. For example, let
    us consider `listdir`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run listdir on PowerShell to ensure such a cmdlet (or a Linux command) does
    not already exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'List out the cmdlets that deal with aliases, by running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the nouns in PowerShell are singular. Therefore, there would be
    no first-party cmdlet that contains `Aliases`. If third party modules give you
    `Aliases` as a noun in them, they are not following the PowerShell best practice
    of using only singular nouns.
  prefs: []
  type: TYPE_NORMAL
- en: '`New-Alias` is the cmdlet we are looking for, since it creates a new alias.
    (`Set-Alias` is used to modify an alias that already exists.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read the help documentation for `New-Alias` by running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The help document indicates that only the Name and the Value parameters are
    mandatory. We shall use only the two to create this simple alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following to create the custom alias:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See whether the alias was created as desired or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Also, run the alias to see what output it gives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That is the output that we are familiar with–the output of `Get-ChildItem`.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases are ephemeral by default. They exist only as long as your PowerShell
    session exists. To use custom aliases without having to recreate them each time,
    export these aliases (the instructions for which are in the next recipe) and import
    them using your PowerShell profile. We will understand profiles in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aliases, as already mentioned, are pointers to cmdlets. Using `New-Alias`, you
    create a pointer with a custom name, that points to the desired PowerShell cmdlet.
    This is simply a Name–Value pair.
  prefs: []
  type: TYPE_NORMAL
- en: When you run anything on PowerShell, PowerShell checks its list of cmdlets and
    aliases (among other definitions) to understand what you are asking for. When
    PowerShell encounters an alias, it looks for which cmdlet it points to, and runs
    the cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can add more content to your aliases, such as descriptions. Refer the help
    documentation for `Get-Alias` to see what more you can do with aliases.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe 3.8: Understanding cmdlets and parameters'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recipe 2.8: Importing/Exporting custom aliases for future use'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recipe 3.4: Enabling automated execution of commands for each load'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export/Import Custom Aliases for Future Use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aliases being ephemeral, in spite of its advantages and the intended use of
    aliases, could be seen as an inconvenience. In order that aliases can be reused,
    they need to be exported to a file and later, imported when needed. This recipe
    will show you how to export and import the aliases you may have created.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need custom aliases already created for this process to be effective. If
    you don't have custom aliases created, the export action would only export the
    default aliases, which would be loaded with PowerShell anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the previous recipe to create at least one custom alias.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that your custom alias exists and runs properly. One way of doing this
    is to get details about the alias you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Export all of the aliases loaded on your session to a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: CSV is the default file type. The import that we would see in the coming steps
    understands CSV and make the necessary associations.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to export the aliases as a script. This way, PowerShell
    will create a script that would contain the New-Alias cmdlet for each of the aliases
    in the export.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Look at the contents of each of the files created; the CSV file first, and then
    the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/56717d30-2937-4bac-89c4-634503efc8e8.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/bdf72b32-a228-470f-ac21-ad35d4e8013a.png)'
  prefs: []
  type: TYPE_IMG
- en: Optionally, edit the file to remove all the aliases except the ones you created.
    The custom aliases can be found at the bottom of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This concludes exporting aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now import aliases into our PowerShell session.
  prefs: []
  type: TYPE_NORMAL
- en: Restart PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See if the alias, `listdir`, that you created exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, import the aliases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You may receive several errors, each saying that the new alias could not be
    created since the alias already existed. There are two ways to handle this: the
    first is to remove the default aliases from the export file (which is recommended),
    and the second is to use the `-Force` parameter (this may still result in errors,
    but they would be significantly fewer).'
  prefs: []
  type: TYPE_NORMAL
- en: If you exported the aliases as a script, simply call the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The script way is straight-forward: the cmdlets are run one after the other
    and the aliases are created in the system just like how you created them manually.'
  prefs: []
  type: TYPE_NORMAL
- en: With the CSV import, PowerShell parses the input into the Name–Value pairs (and
    add other parameters based on what you exported) and add them to its alias reference
    for the current process.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe 3.4: Enabling automated execution of commands for each load'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listing out the execution policies and setting a suitable one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a time when running scripts on Windows computers was a piece of cake.
    Windows computers were highly prone to remote script executions. With PowerShell,
    Microsoft added a safety belt that allowed the user some control over how PowerShell
    scripts were loaded. Some specific models of script executions got restricted,
    which plugged some holes in the system.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that execution policies are **not** a security feature.
    There are ways to circumvent this fence and still run scripts. Execution policies
    are in place to ensure users don't accidentally run scripts without awareness.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell on Windows and Windows PowerShell contain the configuration. Running
    PowerShell scripts on Windows is still restricted by default. On PowerShell on
    Linux, this doesn't work at the moment, and based on the interactions in the community,
    it is uncertain whether this feature would make it to PowerShell on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'An execution policy determines what type of execution of scripts is allowed.
    Here are the six execution policies (excluding Default):'
  prefs: []
  type: TYPE_NORMAL
- en: AllSigned
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RemoteSigned
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restricted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unrestricted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bypass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Undefined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three scopes as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CurrentUser
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LocalMachine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A combination of an execution policy and a scope are what determine the condition
    which scripts can be loaded under. Microsoft has documented in detail what each
    of the policies is. In general, AllSigned requires that all the scripts that run
    on the computer are signed using a code signing certificate by a trusted certification
    authority. If this policy is set, PowerShell will not run unsigned scripts even
    if you were the one to create them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Restricted** is the default policy: Commands can be run, but not scripts. **RemoteSigned**
    allows scripts created on your own computer to run. Scripts that are downloaded
    from the Internet cannot be run.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bypass** is similar to unrestricted, however, is used in specific scenarios
    such as when PowerShell forms the basis of a certain application, and the application
    has its own security implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unrestricted** means that all scripts and commands can run after a simple
    confirmation. **Undefined** means that no policy has been defined for a particular
    scope. Let us try to understand the concepts using the following recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe needs Windows to work. If you're running a pure Linux environment,
    you cannot work with this recipe. You may run the commands, but you would see
    the Unrestricted policy set at all levels.
  prefs: []
  type: TYPE_NORMAL
- en: If you can get your hands on a Windows computer, you can proceed with this recipe
    regardless of whether it has PowerShell or Windows PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a PowerShell window  by running `pwsh` or `powershell`. The `pwsh` command
    calls PowerShell, and `powershell` calls Windows PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Windows PowerShell comes preinstalled on all modern Windows products; PowerShell,
    on the other hand, has to be installed. Note that all of the current PowerShell
    cmdlets will run as well on Windows PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: First, run the Get-Command cmdlet to know how to work with execution policies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ad67d754-eabc-404d-bf92-3014549f8ff6.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us now get help on running the cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to know the execution policy set on the machine, therefore, we would
    run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/69fa2f0d-8c11-4129-9c73-e4967f4357b5.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows the execution policy currently effective on the current PowerShell
    session.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list out the policies set at various scopes, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5db273a2-fe7e-4915-b9ad-c590063310a7.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the policy is only set at the LocalMachine level, and it is set
    at RemoteSigned, which is the same as that reflected in the previous step. The
    policy at the LocalUser and the Process scopes is Undefined, which made the session
    pick the execution policy from LocalMachine.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now set the execution policy for the local machine to be Undefined and
    see what our session picks up.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, close the current PowerShell session and open a new session
    as the administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, run the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e039790c-5185-4b1d-96be-38b1391f12e3.png)'
  prefs: []
  type: TYPE_IMG
- en: The help document shows that the value of the ExecutionPolicy parameter is mandatory,
    and that Undefined is one of the valid values it would accept. We want to set
    the policy at the LocalMachine scope, therefore,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, list out the execution policies at the various scopes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7a2cad04-6a65-480e-9d9f-14d60b2a8e9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let us check the currently-effective execution policy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/91d88fe3-665a-4ea8-b9c7-1e3ab057e777.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us now set the execution policy back to how it was before we began the recipe.
    You may want to change the policy to suit your needs, based on what authority
    you have on the computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Execution policies are nothing but conditions set on the system to avoid accidental
    script runs. They work at different scopes.
  prefs: []
  type: TYPE_NORMAL
- en: There are three scopes in PowerShell, as noted already. The **LocalSystem**
    scope is at the end of the chain. Right above it is the **CurrentUser** scope.
    At the top, is the **Process** scope. The level of precedence is Process > CurrentUser
    > LocalMachine. Therefore, if any policy other than Undefined is set at the Process
    scope, the session would use the policy set on the process. In case it's Undefined,
    it would look for the policy set on the CurrrentUser scope. If CurrentUser has
    the policy marked as Undefined as well, the session would apply the policy applied
    at the LocalMachine level. If LocalMachine has Undefined set, the session would
    pick the Default policy, which is based on what PowerShell has defined as the
    policy, which may vary based on the version of operating system. On Windows 2016,
    for instance, the default policy is RemoteSigned.
  prefs: []
  type: TYPE_NORMAL
- en: The policies set at the CurrentUser and LocalMachine levels are stored in the
    Windows Registry. The policy set on the Process scope is stored in the ephemeral
    environment variable, `$env:PSExecutionPolicyPreference`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[About_Execution_Policies](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6)
    (Microsoft)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
