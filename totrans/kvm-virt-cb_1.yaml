- en: Getting Started with QEMU and KVM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 QEMU 和 KVM
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing and configuring QEMU
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置 QEMU
- en: Managing disk images with qemu-img
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 qemu-img 管理磁盘镜像
- en: Preparing images for OS installation with qemu-nbd
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 qemu-nbd 准备 OS 安装的镜像
- en: Installing a custom OS on the image with debootstrap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 debootstrap 在镜像上安装自定义操作系统
- en: Resizing an image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整镜像大小
- en: Using pre-existing images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预先存在的镜像
- en: Running virtual machines with qemu-system-*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 qemu-system-* 运行虚拟机
- en: Starting the QEMU VM with KVM support
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动具有 KVM 支持的 QEMU VM
- en: Connecting to a running instance with VNC
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 VNC 连接到运行中的实例
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '**Quick Emulator** (**QEMU**) is the main component of the QEMU/KVM virtualization
    technology suit. It provides hardware virtualization and processor emulation.
    QEMU runs in userspace and, without the need for kernel, drivers can still provide
    fast system emulation. QEMU supports two operating modes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速模拟器**（**QEMU**）是 QEMU/KVM 虚拟化技术套件的主要组成部分。它提供硬件虚拟化和处理器仿真。QEMU 在用户空间运行，在无需内核驱动的情况下仍能提供快速系统仿真。QEMU
    支持两种操作模式：'
- en: Full system emulation, where QEMU emulates an entire computer system, including
    the CPU type and peripherals
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全系统仿真，其中 QEMU 仿真整个计算机系统，包括 CPU 类型和外设
- en: User mode emulation, where QEMU can run a process that has been compiled on a
    different CPU architecture natively
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户模式仿真，其中 QEMU 可以在不同 CPU 架构上本地运行已编译的进程
- en: In this book, we are going to focus on full system emulation with the hardware
    acceleration support provided by the **Kernel-based Virtual Machine** (**KVM**)
    hypervisor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将专注于使用由 **基于内核的虚拟机**（**KVM**）虚拟化程序提供的硬件加速支持进行完整系统仿真。
- en: In this chapter, we will start by installing QEMU on Linux, then explore various
    examples of building, managing, and using disk images for the virtual instances.
    We will then have an in-depth look at running QEMU in full system emulation mode,
    using the provided binaries. We will see examples of using the KVM kernel module
    to accelerate the QEMU processes. Finally, we are going to end the chapter with
    details on how to connect to the virtual machines we started earlier, using VNC
    clients.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从在 Linux 上安装 QEMU 开始，然后探讨构建、管理和使用虚拟实例的磁盘镜像的各种示例。接着，我们将深入了解如何在完整系统仿真模式下运行
    QEMU，使用提供的二进制文件。我们将看到使用 KVM 内核模块加速 QEMU 进程的示例。最后，我们将详细介绍如何使用 VNC 客户端连接我们之前启动的虚拟机。
- en: Installing and configuring QEMU
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 QEMU
- en: In this recipe, we will look at installing QEMU on a single server with the
    provided distribution packages. For production environments, we recommend using
    precompiled, packaged versions of QEMU for easier and more consistent deployments.
    However, we are going to see an example of how to compile QEMU from source, in
    case you need a certain version that you might want to package later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将介绍如何使用提供的发行版软件包在单个服务器上安装 QEMU。对于生产环境，我们建议使用预编译的、打包的 QEMU 版本，以便更轻松和一致地部署。但是，我们将看到一个示例，展示如何从源代码编译
    QEMU，以备后续可能需要打包的特定版本。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Depending on your Linux distribution, the package name and installation commands
    will differ. You can use your system's package manager, such as `apt`, `dnf`,
    or `yum` to search for any packages containing the QEMU string and get familiar
    with what is available for your particular Linux variant. The source code can
    be downloaded from the official QEMU project website at [http://www.qemu-project.org/download/#source](http://www.qemu-project.org/download/#source).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的 Linux 发行版，软件包名称和安装命令会有所不同。你可以使用系统的软件包管理器，如 `apt`、`dnf` 或 `yum`，搜索包含 QEMU
    字符串的软件包，并了解适用于你特定 Linux 变种的可用选项。可以从官方 QEMU 项目网站下载源代码：[http://www.qemu-project.org/download/#source](http://www.qemu-project.org/download/#source)。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps to install QEMU from packages on Ubuntu/Debian
    and RHEL/CentOS distributions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，在 Ubuntu/Debian 和 RHEL/CentOS 发行版上从软件包安装 QEMU：
- en: 'On Ubuntu/Debian distributions, update your packages index:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Ubuntu/Debian 发行版中，更新你的软件包索引：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install the package:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装软件包：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On CentOS/RHEL distributions execute:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 CentOS/RHEL 发行版上执行：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To install from source, execute the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要从源代码安装，请执行以下操作：
- en: 'Download the archive first:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先下载存档：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Extract the files from the archive:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存档中提取文件：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Configure and compile the source code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置和编译源代码：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Installing QEMU is quite trivial, as we just saw. Let''s have a look at what
    the QEMU metapackage installed on Ubuntu looks like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 QEMU 非常简单，正如我们刚才看到的。让我们看一下 Ubuntu 上安装的 QEMU 元包是什么样的：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the preceding output, we can see that there are few packages involved.
    If you are interested, you can read the individual description to get more familiar
    with what each package provides.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到涉及的包并不多。如果你感兴趣，可以阅读每个包的描述，了解每个包提供的功能。
- en: 'It''s worth mentioning that all binaries provided from the earlier-mentioned packages
    start with the prefix QEMU. You can use tab completion to see the list of available
    executables:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，所有之前提到的包提供的二进制文件都以 QEMU 为前缀。你可以使用 Tab 补全来查看可用的可执行文件列表：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that there's a single executable for each CPU architecture type that
    can be emulated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每种 CPU 架构类型都有一个可以仿真的单独可执行文件。
- en: Managing disk images with qemu-img
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 qemu-img 管理磁盘镜像
- en: To run virtual machines, QEMU needs images to store the filesystem of the guest
    OS. The image itself is a type of file, and it represents the guest filesystem residing
    on a virtual disk. QEMU supports various images and provides tools to create and
    manage them. In this recipe, we are going to build a blank disk image with the
    `qemu-img` utility.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行虚拟机，QEMU 需要镜像来存储客机操作系统的文件系统。镜像本身是一种文件类型，表示虚拟磁盘上的客机文件系统。QEMU 支持多种镜像，并提供了创建和管理这些镜像的工具。在本节中，我们将使用
    `qemu-img` 工具创建一个空白的磁盘镜像。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use this recipe, we need to have the `qemu-img` utility installed. If you
    followed the steps in the first recipe, you should have that covered. To check
    what image types are supported on your Linux distribution, run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此方法，我们需要安装 `qemu-img` 工具。如果你按照第一步的指示操作，应该已经安装好了。要检查你的 Linux 发行版支持哪些镜像类型，可以运行以下命令：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the preceding output, we can see that there are many supported images on
    the test system that we are using. Make sure that your QEMU version supports the
    raw image type, as it's the default and that is what we are going to use in this
    recipe. One of the most commonly used image type is `qcow2`, which supports copy
    on write, compression, encryption, and snapshotting. We are going to leverage that
    in later recipes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到，在我们使用的测试系统中，有许多受支持的镜像。确保你的 QEMU 版本支持 raw 镜像格式，因为它是默认格式，我们将在本节中使用它。最常用的镜像格式之一是
    `qcow2`，它支持写时复制、压缩、加密和快照功能。我们将在后续的教程中使用这个格式。
- en: Please note that even though QEMU supports multiple formats, that does not necessarily
    mean that you can run virtual machines on them. However, `qemu-img` can be used
    to convert different images to raw and `qcow2` formats. For best performance,
    use raw or `qcow2` image formats.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管 QEMU 支持多种格式，但这并不意味着你可以在它们上运行虚拟机。然而，`qemu-img` 可以用于将不同的镜像转换为 raw 和 `qcow2`
    格式。为了获得最佳性能，建议使用 raw 或 `qcow2` 镜像格式。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to create a blank raw image of a specified size
    and to verify that the file was created on the host:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建一个指定大小的空白 raw 镜像，并验证该文件是否已在主机上创建：
- en: 'Create a raw image named `debian.img` with size of 10 GB:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `debian.img`、大小为 10 GB 的 raw 镜像：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Check that the file was created:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件是否已创建：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Examine the file type:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件类型：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Obtain more information about the image:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取有关镜像的更多信息：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `qemu-img` utility allows us to create, convert, and modify guest images.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`qemu-img` 工具允许我们创建、转换和修改客机镜像。'
- en: In step 1, we used the `-f` flag specifying the image format; in this case,
    `raw`, the name of the image to be created and the size in gigabytes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们使用了 `-f` 标志来指定镜像格式；在本例中是 `raw`，以及要创建的镜像名称和大小（以 GB 为单位）。
- en: In step 4, we used the `info` subcommand to gather additional information about
    the existing image. Note how the disk size is showing as currently being zero.
    This is due to the fact that this is a blank image, not containing a filesystem.
    We are going to create one in the next recipe.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 步中，我们使用了 `info` 子命令来获取有关现有镜像的更多信息。注意磁盘大小目前显示为零，这是因为这是一个空白镜像，没有包含文件系统。我们将在下一节中创建文件系统。
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'In this recipe, we listed the supported disk image formats by QEMU. The following
    is a brief description of the most common types that you might encounter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们列出了 QEMU 支持的磁盘镜像格式。以下是你可能会遇到的几种常见格式的简要描述：
- en: '`raw`: Raw disk image format. This is the default format and can be one of
    the fastest file-based formats. If you format this image with a filesystem that
    supports holes, for example, EXT3, then only sectors that have data will use space.
    The main drawback of the raw images is the lack of features, making them ideal
    for testing and quick prototyping.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raw`：原始磁盘映像格式。这是默认格式，且通常是最快的基于文件的格式。如果你为此映像格式创建一个支持“孔”的文件系统，例如EXT3，那么只有包含数据的扇区才会占用空间。raw映像的主要缺点是缺乏特性，使其非常适合用于测试和快速原型开发。'
- en: '`qcow2`: As we mentioned in the previous section, this is one of the most feature-rich
    formats. It supports VM snapshots, compression, and encryption for the price of
    slightly reduced performance.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qcow2`：正如我们在上一节提到的，这是功能最丰富的格式之一。它支持虚拟机快照、压缩和加密，但性能略有降低。'
- en: '`qcow`: This is an older QEMU image format that supports backing files, compact
    image files, encryption, and compression.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qcow`：这是一个较老的QEMU映像格式，支持备份文件、紧凑型映像文件、加密和压缩。'
- en: '`dmg`: This is the Mac disk image format. The Mac disk image provides secure
    password protection and compression, and it is most commonly used to distribute
    software, rather than running virtual machines.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dmg`：这是Mac磁盘映像格式。Mac磁盘映像提供了安全的密码保护和压缩，通常用于分发软件，而不是运行虚拟机。'
- en: '`nbd`: The network block device, typically used for accessing remote storage
    devices.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nbd`：网络块设备，通常用于访问远程存储设备。'
- en: '`vdi`: This disk format is used by the Oracle VirtualBox software and can be
    used to run virtual machines on various CPU platforms.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vdi`：这种磁盘格式由Oracle VirtualBox软件使用，可以在各种CPU平台上运行虚拟机。'
- en: '`vmdk`: This is the VMware disk image type, where a single virtual hard disk
    can span multiple files.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmdk`：这是VMware的磁盘映像格式，其中一个虚拟硬盘可以跨多个文件。'
- en: '`vhdx`: Microsoft Hyper-V uses this image format. It provides large storage
    capacity, data corruption protection during power failures and read/write optimization
    for larger disk images.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vhdx`：Microsoft Hyper-V使用这种映像格式。它提供了大容量存储、在断电时的数据损坏保护以及对大磁盘映像的读写优化。'
- en: In this book, we are going to use the `raw` and `qcow2` disk formats, as they
    provide the best performance and toolset for running and manipulating them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用`raw`和`qcow2`磁盘格式，因为它们提供了最佳的性能和工具集来运行和操作它们。
- en: Preparing images for OS installation with qemu-nbd
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用qemu-nbd准备操作系统安装映像
- en: In the previous recipe, we created a blank raw image. In this recipe, we are
    going to make a partition and a filesystem on it, getting the image ready for
    full guest OS installation. When creating the partition and file system, you should
    consider the type of load that the virtual instance will create. If your applications
    running inside VM are IO bound, you might consider XFS for the image filesystem.
    For this recipe, we are going to use EXT4, as most Linux distributions support
    it out of the box.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个配方中，我们创建了一个空白的raw映像。在这个配方中，我们将对其进行分区并创建文件系统，为完整的客户操作系统安装做准备。在创建分区和文件系统时，你应考虑虚拟实例可能产生的负载类型。如果虚拟机中运行的应用程序是IO密集型的，可能考虑为映像文件系统使用XFS。对于本配方，我们将使用EXT4，因为大多数Linux发行版默认支持它。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we are going to use the following tools:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本配方，我们将使用以下工具：
- en: '`qemu-nbd`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qemu-nbd`'
- en: '`sfdisk`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sfdisk`'
- en: The `nbd` kernel module
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nbd`内核模块'
- en: '`mkfs`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkfs`'
- en: Most Linux distributions should already have the tools installed. If that's
    not the case, consult your distribution's documentation on how to install them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux发行版应该已经安装了相关工具。如果没有，请参考你所使用的发行版文档了解如何安装这些工具。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps outlined to partition and create a filesystem on
    the blank image:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行下述步骤，分区并在空白映像上创建文件系统：
- en: 'Load the `nbd` kernel module:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`nbd`内核模块：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using the `qemu-nbd` tool, associate the blank image file to the `/dev/nbd0`
    block device:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`qemu-nbd`工具，将空白映像文件与`/dev/nbd0`块设备关联：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create two partitions on the block device. One will be used for swap, and the
    other as the root partition for the guest OS:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在块设备上创建两个分区，一个用于交换分区，另一个作为客户操作系统的根分区：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'List the available block devices after the partitioning:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分区后列出可用的块设备：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the swap partition:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建交换分区：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Make the EXT4 filesystem on the root partition:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根分区上创建EXT4文件系统：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We take advantage of the functionality that the `nbd` kernel module provides
    by allowing us to associate a raw image file to a block device using the `qemu-nbd`
    utility. To get more information about the kernel module run the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用`nbd`内核模块提供的功能，允许我们使用`qemu-nbd`工具将原始镜像文件关联到块设备。要获取更多关于内核模块的信息，运行以下代码：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can examine the block device metadata created in step 2 by running the following
    command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令检查在步骤2中创建的块设备元数据：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After creating the two new partitions in step 3, the type of the image file
    has changed. Let''s examine it again:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤3中创建两个新分区后，镜像文件的类型发生了变化。让我们再次检查它：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We chose to use the `sfdisk` utility to create the partitions, but you can use
    the `fdisk` utility interactively instead if you prefer. The end result will be
    the same.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用`sfdisk`工具来创建分区，但如果你更喜欢，也可以使用`fdisk`工具进行交互式操作，最终结果是一样的。
- en: Now that we have an image file that contains two partitions and a filesystem,
    we can proceed with installing the guest OS in the next recipe.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含两个分区和文件系统的镜像文件，我们可以继续按照下一个配方安装客户操作系统。
- en: Installing a custom OS on the image with debootstrap
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用debootstrap在镜像上安装自定义操作系统
- en: In this recipe, we are going to use the `debootstrap` utility to install a Debian
    distribution on the raw image we prepared in the previous two recipes. The `debootstrap`
    command is used to bootstrap a basic Debian system using a specific public mirror.
    By the end of this recipe, we should have an image containing an entire Linux
    distribution, ready for QEMU execution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用`debootstrap`工具，在之前准备好的原始镜像上安装Debian发行版。`debootstrap`命令用于使用特定的公共镜像引导基本的Debian系统。通过本配方操作完成后，我们应该得到一个包含完整Linux发行版的镜像，准备好在QEMU中运行。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to need the following in order to complete this recipe:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，我们需要以下工具：
- en: The block devices created in the previous recipe
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一配方中创建的块设备
- en: The `debootstrap` utility
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debootstrap`工具'
- en: The `chroot` utility
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chroot`工具'
- en: 'To ensure that the swap and root block devices are still present on the system,
    run the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保交换区和根块设备仍然存在于系统中，运行以下命令：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If that's not the case, please refer to the *Preparing images for OS installation
    with qemu-nbd* recipe on how to associate the raw image with the `/deb/nbd0` block
    device.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况不是这样，请参考*使用qemu-nbd为操作系统安装准备镜像*配方，了解如何将原始镜像与`/deb/nbd0`块设备关联。
- en: 'To install the `debootstrap` utility, if not already present on your system,
    execute the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统中没有安装`debootstrap`工具，可以执行以下代码来安装：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'Follow these steps outlined to install a new Debian Linux distribution on the
    raw image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装一个新的Debian Linux发行版到原始镜像上：
- en: 'Mount the root partition from the **Network Block Device** (**NBD**) device
    and ensure that it was mounted successfully:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载**网络块设备**（**NBD**）上的根分区，并确保它已经成功挂载：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Install the latest stable Debian distribution on the root partition mounted
    on `/mnt` from the specified public repository:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从指定的公共仓库在挂载在`/mnt`的根分区上安装最新的稳定Debian发行版：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Ensure the root filesystem was created, by listing all the files at the mounted
    location:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过列出挂载位置的所有文件，确保根文件系统已创建：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Bind and mount the devices directory from the host to the image filesystem:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主机的设备目录绑定并挂载到镜像文件系统中：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Ensure that the `nbd` devices are now present inside the mount location:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保现在`nbd`设备已经出现在挂载位置：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Change the directory namespace to be the root filesystem of the image and ensure
    the operation succeeded:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改目录命名空间为镜像的根文件系统，并确保操作成功：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Check the distribution version inside the chroot environment:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在chroot环境中检查发行版版本：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Mount the `proc` and `sysfs` virtual filesystems inside the chrooted environment:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在chroot环境中挂载`proc`和`sysfs`虚拟文件系统：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'While still inside the chrooted location, install the Debian kernel metapackage
    and the `grub2` utilities:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然处于chroot位置时，安装Debian内核元包和`grub2`工具：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If asked to select target device for GRUB to install on, do not select any and
    just continue.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被要求选择目标设备以供GRUB安装，请不要选择任何设备，直接继续。
- en: 'Install GRUB on the root device:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根设备上安装GRUB：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Update the GRUB configs and the `initrd` image:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新GRUB配置和`initrd`镜像：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Change the root password of the guest:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改客户操作系统的根密码：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Allow access to the pseudo Terminal inside the new guest OS:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许访问新客户操作系统中的伪终端：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Change the `systemd` run level to the `multi-user` level:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `systemd` 的运行级别更改为 `multi-user` 级别：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the root mountpoint to the `fstab` file, so it can persist reboots:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根挂载点添加到 `fstab` 文件中，以便在重启时能够持久化：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Unmount the following filesystems as we are done using them for now:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成对以下文件系统的使用，请卸载它们：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Exit the chrooted environment:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 chroot 环境：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Install GRUB on the root partition of the block device associated with the
    raw image:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与原始镜像关联的块设备的根分区上安装 GRUB：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Update the GRUB configuration file to reflect the correct block device for
    the guest image:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 GRUB 配置文件，以反映客户机镜像的正确块设备：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Unmount the `nbd0` device:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卸载 `nbd0` 设备：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Disassociate the `nbd0` device from the raw image:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解除 `nbd0` 设备与原始镜像的关联：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: A lot has happened in the previous section, so let's step through the commands
    and talk a little bit more about what exactly was performed and why.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前一部分进行了很多操作，现在让我们一步步回顾命令并详细说明到底做了什么以及为什么这样做。
- en: In step 1, we mounted the root partition we created earlier on the `/dev/nbd0p2`
    device to `/mnt`, so we can use it. Once mounted, in step 2, we installed an entire
    Debian distribution on that device using the mount-point as the target.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们将之前创建的根分区挂载到 `/dev/nbd0p2` 设备的 `/mnt` 目录，以便使用它。挂载后，在第 2 步中，我们使用挂载点作为目标，在该设备上安装了整个
    Debian 发行版。
- en: In order to install the GRUB boot loader on the root partition of the image,
    we bind and mounted the `/dev` directory from the host filesystem to the image
    filesystem in `/mnt` in step 4.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在镜像的根分区上安装 GRUB 启动加载器，在第 4 步中我们将主机文件系统的 `/dev` 目录绑定并挂载到镜像文件系统的 `/mnt` 目录下。
- en: Then in step 6, we used the chroot tool to change our directory namespace to
    be `/mnt`, so we can perform operations, as we are directly on the new OS.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第 6 步中，我们使用 chroot 工具将我们的目录命名空间更改为 `/mnt`，以便执行操作，因为我们已经直接进入新操作系统。
- en: In step 8, we mounted the `proc` and `sysfs` virtual filesystems inside the
    image because the GRUB bootloader tool expect them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 步中，我们在镜像内挂载了 `proc` 和 `sysfs` 虚拟文件系统，因为 GRUB 启动加载器工具需要它们。
- en: In step 9, we proceeded to install the kernel source and GRUB tools in preparation
    of installing the bootloader on the boot partition and in step 10 we installed
    the bootloader.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9 步中，我们安装了内核源代码和 GRUB 工具，为在启动分区上安装启动加载器做准备，并在第 10 步中安装了启动加载器。
- en: In step 11, the GRUB configuration files were generated and the boot ramdisk
    image was updated.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 11 步中，生成了 GRUB 配置文件，并更新了启动 RAM 磁盘镜像。
- en: In steps 12, 13, and 14, we changed the root password and ensured we get access
    to the pseudo Terminal, so we can log into the VM later and change the run-level
    from the default graphical interface to the multiuser.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 12、13 和 14 步中，我们更改了根密码，并确保可以访问伪终端，以便稍后登录虚拟机并将运行级别从默认的图形界面更改为多用户模式。
- en: Since the fstab file is empty right after installing the Debian OS on the image,
    we have to add the root mount point, or the VM will not be able to start. This
    was accomplished in step 15.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在安装 Debian 操作系统后，`fstab` 文件为空，我们必须添加根挂载点，否则虚拟机将无法启动。这项工作在第 15 步完成。
- en: In steps 16 and 17, we performed some cleaning up by unmounting the filesystems
    we mounted earlier and exited the chroot environment.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 16 和 17 步中，我们进行了清理，卸载了之前挂载的文件系统，并退出了 chroot 环境。
- en: Back on the host filesystem in step 18, we installed GRUB on the `nbd0` device
    by specifying the mounted location of the image.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 18 步回到主机文件系统时，我们通过指定镜像的挂载位置，在 `nbd0` 设备上安装了 GRUB。
- en: In step 19, we updated the GRUB config device name to be `sda2` because this
    is the name that will appear inside the virtual machine once we start it. The
    `nbd0p2` name is only present while we have the association between the raw image
    and the network block device on the host OS. From the VM perspective, the second
    partition inside the image we created by is named `sda2` by default.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 19 步中，我们将 GRUB 配置设备名称更新为 `sda2`，因为一旦启动虚拟机，这个名称将出现在虚拟机内。`nbd0p2` 名称仅在主机操作系统上原始镜像与网络块设备关联时存在。从虚拟机的角度来看，我们创建的镜像中的第二个分区默认命名为
    `sda2`。
- en: And finally, in steps 20 and 21, we performed some cleaning by removing the
    mount point and disassociating the raw image from the network block device `nbd0`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第 20 和第 21 步中，我们通过删除挂载点并解除原始镜像与网络块设备 `nbd0` 的关联来进行了一些清理。
- en: Resizing an image
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整镜像大小
- en: In this recipe, we are going to examine how to resize an existing raw image,
    the partitions hosted on it and the filesystem on top of the partitions. We are
    going to be using the raw image that we build in the previous recipes, which contains
    a swap and a root partition with an EXT4 filesystem formatted on it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将展示如何调整现有原始镜像、其上的分区以及分区上方的文件系统的大小。我们将使用在之前教程中创建的原始镜像，其中包含一个交换分区和一个使用EXT4文件系统格式化的根分区。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we are going to use the following tools:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们将使用以下工具：
- en: '`qemu-img`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qemu-img`'
- en: '`losetup`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`losetup`'
- en: '`tune2fs`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tune2fs`'
- en: '`e2fsck`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e2fsck`'
- en: '`kpartx`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kpartx`'
- en: '`fdisk`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fdisk`'
- en: '`resize2fs`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize2fs`'
- en: 'Most of the utilities should already be installed on Ubuntu with the exception
    of `kpartx`. To install it, run the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`kpartx`外，大多数工具应该已经在Ubuntu上安装。若要安装它，请运行以下命令：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: The next steps demonstrate how to add additional space to the raw image we created
    earlier, extend the root partition, and resize the filesystem. By the end of this
    recipe, the original raw image filesystem size should have changed from `10G`
    to `20G`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤演示了如何为我们之前创建的原始镜像添加额外的空间，扩展根分区并调整文件系统大小。通过本教程，原始镜像的文件系统大小应该从`10G`变更为`20G`。
- en: 'Obtain the current size of the image:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取镜像的当前大小：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add additional 10 GB to the image:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向镜像中添加额外的10 GB：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Please note that not all image types support resizing. In order to resize such
    an image, you will need to convert it to raw image first using  the `qemu-img`
    convert command.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有的镜像类型都支持调整大小。为了调整此类镜像的大小，您需要先使用`qemu-img`转换命令将其转换为原始镜像。
- en: 'Check the new size of the image:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查镜像的新大小：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Print the name of the first unused loop device:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印第一个未使用的循环设备的名称：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Associate the first unused loop device with the raw image file:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个未使用的循环设备与原始镜像文件关联：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Read the partition information from the associated loop device and create the
    device mappings:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从关联的循环设备读取分区信息，并创建设备映射：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Examine the new device maps, representing the partitions on the raw image:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新的设备映射，表示原始镜像中的分区：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Obtain some information from the root partition mapping:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取根分区映射的一些信息：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Check the filesystem on the root partition of the mapped device:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查映射设备上根分区的文件系统：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Remove the journal from the root partition device:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从根分区设备中移除日志：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Ensure that the journaling has been removed:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保日志功能已被移除：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Remove the partition mappings:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除分区映射：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Detach the loop device from the image:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从镜像中分离循环设备：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Associate the raw image with the network block device:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始镜像与网络块设备关联：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Using `fdisk`, list the available partitions, then delete the root partition,
    recreate it, and write the changes:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fdisk`列出可用的分区，然后删除根分区，重新创建它并写入更改：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Associate the first unused loop device with the raw image file, like we did
    in step 5:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个未使用的循环设备与原始镜像文件关联，如步骤5中所做：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Read the partition information from the associated loop device and create the
    device mappings:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从关联的循环设备读取分区信息，并创建设备映射：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After the partitioning is complete, perform a filesystem check:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分区完成后，执行文件系统检查：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Resize the filesystem on the root partition of the mapped device:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整映射设备上根分区的文件系统大小：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create the filesystem journal because we removed it earlier:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件系统日志，因为我们之前已经移除了它：
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Remove the device mappings:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除设备映射：
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理……
- en: Resizing an image for VM can be somewhat involving, as we saw from all the steps
    in the previous section. Things can get complicated when there are multiple Linux
    partitions inside the same image, even more so if we are not using **Logical Volume
    Management** (**LVM**). Let's step through all the commands we ran earlier and
    explain in more details why we ran them and what they do.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为虚拟机调整镜像大小可能会稍微复杂一些，正如我们在上一部分的所有步骤中看到的那样。当同一个镜像中有多个Linux分区时，事情可能会变得更复杂，尤其是当我们不使用**逻辑卷管理**（**LVM**）时。让我们逐步解释我们之前运行的所有命令，并详细说明为什么要运行这些命令，以及它们的作用。
- en: In step 1, we confirmed the current size of the image being 10 GB.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们确认了镜像的当前大小为10 GB。
- en: In step 2, we added 10 GB at the end of the image and confirm the new image
    size in step 3.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们在镜像的末尾添加了10 GB，并在步骤3中确认了新镜像的大小。
- en: Recall that the image we built from earlier recipes contains two partitions,
    swap and root. We need a way to manipulate them individually. Particularly, we
    would like to allocate the extra space we added in step 2 to the root partition.
    To do that we need to expose it as a block device that we can easily manipulate
    with standard disk and filesystem utilities. We accomplished that using the `losetup`
    command in step 5, resulting in a mapping between the image and a new block device
    named `/dev/loop1`. In step 6, we exposed the individual partitions as two new
    device mappings. The `/dev/mapper/loop1p2` is the root partition that we would
    like to append the unused disk space to.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们之前创建的镜像包含两个分区，交换分区和根分区。我们需要一种方法来单独操作它们。特别是，我们希望将第 2 步中增加的额外空间分配给根分区。为此，我们需要将其暴露为一个块设备，以便我们可以通过标准的磁盘和文件系统工具轻松操作它。我们在第
    5 步中使用 `losetup` 命令完成了这一操作，结果是在镜像与名为 `/dev/loop1` 的新块设备之间建立了映射。在第 6 步中，我们将各个分区暴露为两个新的设备映射。`/dev/mapper/loop1p2`
    是根分区，我们希望将未使用的磁盘空间附加到该分区。
- en: Before we can resize the partitioned on the loop device, we need to check the
    integrity of the filesystem on it, and this is what we did in step 9\. Because
    we are using a journaling filesystem, we need to remove the journal prior to resizing.
    We do that in step 10 and made sure that the `has_journal` attribute is not showing
    after running the `tune2fs` command in step 11.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够调整 loop 设备上的分区大小之前，我们需要检查其文件系统的完整性，这就是我们在第 9 步中所做的。由于我们使用的是日志文件系统，在调整大小之前，我们需要先移除日志。我们在第
    10 步中执行了这一步，并确保在第 11 步中运行 `tune2fs` 命令后，`has_journal` 属性没有显示。
- en: Now, we need to work directly on the main block device and not the individual
    partitions. We remove the mappings in steps 12 and 13 and associated a new block
    device with the image file using the `qemu-nbd` command in step 14\. The new `/dev/nbd0`
    block device now represents the entire disk of the guest VM and it's a direct
    mapping to what's inside the raw image. We can use this block device just like
    any other regular disk, most importantly we can use tools such as `fdisk` to examine
    and manipulate the partitions residing on it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要直接操作主块设备，而不是单独的分区。在第 12 和 13 步中，我们移除了映射，并在第 14 步中使用 `qemu-nbd` 命令将镜像文件与一个新的块设备关联起来。新的
    `/dev/nbd0` 块设备现在代表了整个虚拟机的磁盘，并且是原始镜像内部的直接映射。我们可以像操作任何其他常规磁盘一样使用这个块设备，最重要的是，我们可以使用
    `fdisk` 等工具来检查和操作其上的分区。
- en: In step 15, we use the `fdisk` utility to delete the root partition and recreate
    it. This does not destroy any filesystem data, but changes the metadata, allocating
    the extra space we added earlier as part of the root partition.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 15 步中，我们使用 `fdisk` 工具删除并重新创建根分区。这不会销毁任何文件系统数据，但会更改元数据，将之前增加的额外空间分配为根分区的一部分。
- en: Now that the block device has all the disk space allocated to the root partition,
    we need to extend the filesystem that is on top of it. We do that by first recreating
    the individual partition mappings like we did earlier, to expose the root partition
    directly so that we can yet again manipulate it. We do that in steps 16 and 17.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 既然块设备的所有磁盘空间都分配给了根分区，我们需要扩展其上的文件系统。我们通过首先像之前一样重新创建各个分区映射来做到这一点，从而直接暴露根分区，以便我们再次对其进行操作。我们在步骤
    16 和 17 中完成了这一步骤。
- en: In steps 18 and 19, we check the integrity of the root file system, then we
    resize it to the maximum available disk space on the root partition that it resides.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 18 和 19 步中，我们检查了根文件系统的完整性，然后将其调整为根分区上最大可用的磁盘空间。
- en: Finally, in step 20, we remove the mappings again. Now the image, the root partition
    inside the image, and the EXT4 filesystem on top of the Linux partition have been
    resized to 20 GB.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在步骤 20 中，我们再次移除映射。现在，镜像、镜像内的根分区以及 Linux 分区上方的 EXT4 文件系统都已调整为 20 GB。
- en: You can check the new root partition size by starting a new QEMU instance using
    the image. We are going to do just that in a separate recipe in this chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过启动一个新的 QEMU 实例并使用该镜像来检查新的根分区大小。我们将在本章的另一个配方中详细操作。
- en: Using pre-existing images
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现有镜像
- en: In the *Installing a custom OS on the image with debootstrap* recipe, we saw
    how to use the `debootstrap` command to install Debian on an image we built. Most
    Linux vendors provide already built images of their distributions for various
    architectures. Installable images are also available for manually installing the
    guest OS. In this recipe, we are going to demonstrate how to obtain and examine
    CentOS and Debian images that have already been built. In a later recipe, we are
    going to show how to start QEMU/KVM instances using those same images.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用 debootstrap 安装自定义操作系统到镜像* 食谱中，我们演示了如何使用 `debootstrap` 命令将 Debian 安装到我们构建的镜像中。大多数
    Linux 供应商提供了针对各种架构的其发行版的预构建镜像。也有可安装的镜像，供手动安装客操作系统使用。在这个食谱中，我们将演示如何获取和检查已经构建的 CentOS
    和 Debian 镜像。在后续的食谱中，我们将展示如何使用这些镜像启动 QEMU/KVM 实例。
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we are going to need QEMU installed on the host OS. For instructions
    on how to install QEMU, please refer to the *Installing and configuring QEMU*
    recipe from this chapter. We are also going to need the `wget` utility to download
    the images from the upstream public repositories.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们需要在主操作系统上安装 QEMU。有关如何安装 QEMU 的说明，请参阅本章中的 *安装和配置 QEMU* 食谱。我们还需要 `wget`
    工具从上游公共仓库下载镜像。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'To obtain Debian Wheezy images for use with QEMU and KVM, perform the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取用于 QEMU 和 KVM 的 Debian Wheezy 镜像，请执行以下操作：
- en: 'Download the image using `wget`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `wget` 下载镜像：
- en: '[PRE67]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inspect the type of the image:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查镜像的类型：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To download CentOS images run the following commands:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载 CentOS 镜像，请运行以下命令：
- en: 'Download the image using wget:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 wget 下载镜像：
- en: '[PRE69]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Inspect the type of the image:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查镜像的类型：
- en: '[PRE70]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: There are many public repositories on the Internet that provide images of various
    types, most commonly `qcow2` for use with QEMU/KVM. In the previous section, we
    used the official CentOS repository to obtain the image and an another one containing
    prebuilt images for Debian.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多公共仓库提供各种类型的镜像，最常见的是 `qcow2` 格式，供 QEMU/KVM 使用。在前面的章节中，我们使用了官方的 CentOS
    仓库来获取镜像，并且还有一个包含已构建 Debian 镜像的仓库。
- en: Both images are in the `qcow2` format, as we confirmed in step 2.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 两个镜像都采用 `qcow2` 格式，正如我们在步骤 2 中确认的那样。
- en: There's more...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: So far, we've only seen how to build, examine, manipulate, and download images.
    In the next recipe, we are going to focus on how to actually use the images to
    start QEMU/KVM instances.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只了解了如何构建、检查、操作和下载镜像。在接下来的食谱中，我们将重点介绍如何实际使用这些镜像来启动 QEMU/KVM 实例。
- en: See also
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Examine the following links to get more information about what prebuilt images
    are available for the listed distributions:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以获取有关可用的预构建镜像的更多信息：
- en: Official Ubuntu images: [https://uec-images.ubuntu.com/releases/](https://uec-images.ubuntu.com/releases/)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Ubuntu 镜像：[https://uec-images.ubuntu.com/releases/](https://uec-images.ubuntu.com/releases/)
- en: Official CentOS images: [https://cloud.centos.org/centos/](https://cloud.centos.org/centos/)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 CentOS 镜像：[https://cloud.centos.org/centos/](https://cloud.centos.org/centos/)
- en: Official Debian images: [http://cdimage.debian.org/cdimage/openstack/](http://cdimage.debian.org/cdimage/openstack/)
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Debian 镜像：[http://cdimage.debian.org/cdimage/openstack/](http://cdimage.debian.org/cdimage/openstack/)
- en: Official Fedora images: [https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/)
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Fedora 镜像：[https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/)
- en: Official openSUSE images: [http://download.opensuse.org/repositories/Cloud:/Images:/](http://download.opensuse.org/repositories/Cloud:/Images:/)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 openSUSE 镜像：[http://download.opensuse.org/repositories/Cloud:/Images:/](http://download.opensuse.org/repositories/Cloud:/Images:/)
- en: Running virtual machines with qemu-system-*
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 qemu-system-* 运行虚拟机
- en: In this recipe, we are going to demonstrate how to start virtual machines with
    QEMU. QEMU provides binaries that can emulate different CPU architectures using
    either custom or prebuilt images for the guest OS.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将演示如何使用 QEMU 启动虚拟机。QEMU 提供的二进制文件可以通过使用定制的或预构建的客操作系统镜像来模拟不同的 CPU 架构。
- en: 'If you completed the *Installing and configuring QEMU* recipe, you should have
    a host that contains the following binaries:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完成了 *安装和配置 QEMU* 食谱，您应该已经拥有包含以下二进制文件的主机：
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Each command can start a QEMU-emulated instance for the specific CPU architecture.
    For this recipe, we are going to be using the `qemu-system-x86_64` utility.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令可以启动一个特定 CPU 架构的 QEMU 仿真实例。在本食谱中，我们将使用 `qemu-system-x86_64` 工具。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To complete this recipe, you will need the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此食谱，您将需要以下内容：
- en: The QEMU binaries, provided after following the *Installing and configuring
    QEMU* recipe
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QEMU 二进制文件，根据*安装和配置 QEMU*的步骤提供。
- en: The custom raw Debian image we built in the *Installing a custom OS on the image
    with debootstrap* recipe
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在*使用 debootstrap 在镜像上安装自定义操作系统*的步骤中构建的自定义原始 Debian 镜像。
- en: The CentOS `qcow2` image we downloaded in the *Using pre-existing images* recipe
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在*使用现有镜像*的步骤中下载的 CentOS `qcow2` 镜像。
- en: 'Let''s have a look at what CPU architectures QEMU  supports on the host system:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 QEMU 在主机系统上支持的 CPU 架构：
- en: '[PRE72]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: From the preceding output, we can see the list of CPUs that we can pass as parameters to
    the `-cpu` flag in order to emulate that CPU type inside our virtual machine.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到可以作为参数传递给 `-cpu` 标志以在我们的虚拟机内模拟该 CPU 类型的 CPU 列表。
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To start a new virtual machine using the `qemu-system` utility, perform the
    following steps:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `qemu-system` 实用程序启动新的虚拟机，请执行以下步骤：
- en: 'Start a new QEMU virtual machine using the `x86_64` CPU architecture:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `x86_64` CPU 架构启动新的 QEMU 虚拟机：
- en: '[PRE73]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Ensure that the instance is running:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保实例正在运行：
- en: '[PRE74]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Terminate the Debian QEMU instance:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止 Debian QEMU 实例：
- en: '[PRE75]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Start a new QEMU instance using the prebuilt CentOS image:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用预构建的 CentOS 镜像启动新的 QEMU 实例：
- en: '[PRE76]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Ensure that the instance is running:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保实例正在运行：
- en: '[PRE77]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Terminate the CentOS QEMU instance:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止 CentOS QEMU 实例：
- en: '[PRE78]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Make sure to replace the IP address of the `-vnc` parameter with the one from
    your host machine.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `-vnc` 参数中的 IP 地址替换为主机机器的 IP 地址。
- en: How it works...
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: How to start a virtual machine with QEMU/KVM depends greatly on the type of
    image and how the partitions are structured inside that image.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如何启动带有 QEMU/KVM 的虚拟机取决于镜像类型以及镜像内部分区的结构。
- en: We used two different image types with different partitioning schemes to demonstrate
    this concept.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两种不同的镜像类型和不同的分区方案来演示这个概念。
- en: In step 1, we used the `qemu-system-x86_64` command to emulate a `x86_64` CPU
    architecture, specifically we passed the `-cpu Nehalem` flag, emulating the Nehalem
    CPU model. We passed the IP address of our host as a parameter to the `-vnc` flag.
    This starts a VNC server in the VM so that we can later use a VNC client to connect
    to the QEMU instance. We specified the amount of memory to be allocated to the instance,
    in this case, 1GB with the `-m` flag. We instructed QEMU that we are going to
    use a raw image with the `format=raw` option and the name and location of the
    actual image with the `file=debian.img` parameter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们使用 `qemu-system-x86_64` 命令模拟了 `x86_64` CPU 架构，具体地，我们传递了 `-cpu Nehalem`
    标志，模拟 Nehalem CPU 模型。我们将主机的 IP 地址作为参数传递给 `-vnc` 标志。这启动了 VM 中的 VNC 服务器，以便稍后使用 VNC
    客户端连接到 QEMU 实例。我们使用 `-m` 标志指定要分配给实例的内存量，此处为 1GB。我们告知 QEMU 我们将使用带有 `format=raw`
    选项的原始镜像，并使用 `file=debian.img` 参数指定实际镜像的名称和位置。
- en: Recall that this raw image contains two partitions with the second partition
    containing the root filesystem where the bootloader is located. This is very important
    to remember because we need to specify from what partition index the guest OS
    should load. We do that with the `index=2` flag. Finally, we pass the `-daemonize`
    parameter to background the QEMU process.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个原始镜像包含两个分区，第二个分区包含引导加载程序所在的根文件系统。这点非常重要，因为我们需要指定客户操作系统应从哪个分区索引加载。我们使用
    `index=2` 标志来实现这一点。最后，我们使用 `-daemonize` 参数将 QEMU 进程放到后台。
- en: In step 4, we started another QEMU instance, this time using the `qcow2` CentOS
    image we downloaded earlier. We did not have to specify from what partition we
    need to boot from this this time because most prebuilt images use the first partition,
    or only have one partition. We also used the `-hda` flag instead of the `-drive`
    parameter, just to demonstrate that both options can be used with the same result.
    The `-hda` flag tells QEMU the first disk for the instance should be loaded from
    the filename that follows it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 步中，我们启动了另一个 QEMU 实例，这次使用了之前下载的 `qcow2` CentOS 镜像。这次我们不需要指定从哪个分区引导，因为大多数预构建的镜像使用第一个分区，或者只有一个分区。我们还使用了
    `-hda` 标志而不是 `-drive` 参数，只是为了演示这两个选项可以产生相同的结果。`-hda` 标志告诉 QEMU 实例的第一个磁盘应该从其后跟的文件名加载。
- en: Starting the QEMU VM with KVM support
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 KVM 支持启动 QEMU VM
- en: In this recipe, we are going to start a QEMU virtual machine with KVM acceleration.
    **Kernel-based Virtual Machine** (**KVM**) is a full virtualization technology
    for CPU architectures that support virtualization extensions. For Intel-based
    processors, this is the Intel VT, and for AMD CPUS, it is the AMD-V hardware extension.
    The main parts of KVM are two loadable kernel modules, named `kvm.ko`, which provides
    the main virtualization functionality, and a second kernel module that is processor
    specific, `kvm-intel.ko` and `kvm-amd.ko` for both main CPU vendors.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将启动一个带有KVM加速的QEMU虚拟机。**基于内核的虚拟化技术**（**KVM**）是针对支持虚拟化扩展的CPU架构的完全虚拟化技术。对于英特尔处理器，这是Intel
    VT，对于AMD CPU，这是AMD-V硬件扩展。KVM的主要部分包括两个可加载的内核模块，一个是`kvm.ko`，提供主要的虚拟化功能，另一个是处理器特定的内核模块，分别是`kvm-intel.ko`和`kvm-amd.ko`，针对主要的CPU供应商。
- en: QEMU is the userspace component to create virtual machines, where KVM resides
    in kernel space. If you completed the *Running virtual machines with qemu-system*-*
    recipe, you might note that the difference between running a KVM virtual machine
    and running a nonaccelerated QEMU instance is just a single command-line option.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU是用于创建虚拟机的用户空间组件，而KVM则位于内核空间。如果您完成了*使用qemu-system运行虚拟机*食谱，您可能会注意到，运行KVM虚拟机与运行非加速的QEMU实例之间的区别，仅仅是一个命令行选项。
- en: Getting ready
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to start a KVM instance, you will need the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动KVM实例，您需要以下内容：
- en: The QEMU binaries, provided after following the *Installing and configuring
    QEMU* recipe
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行*安装和配置QEMU*食谱之后提供的QEMU二进制文件
- en: The custom raw Debian image we built in the *Installing a custom OS on the image
    with debootstrap* recipe
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在*使用debootstrap安装自定义操作系统*食谱中构建的自定义Debian镜像
- en: Processor that supports virtualization
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持虚拟化的处理器
- en: The KVM kernel modules
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KVM内核模块
- en: 'To check whether your CPU supports virtualization, run the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查您的CPU是否支持虚拟化，请运行以下代码：
- en: '[PRE79]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The presence of the `vmx` (for Intel) or `svm` (for AMD) flags indicate that
    your CPU supports the virtualization extensions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmx`（对于Intel）或`svm`（对于AMD）标志的存在表明您的CPU支持虚拟化扩展。'
- en: The flags from the `cpuinfo` command output simply mean that your processor
    supports virtualization; however, make sure that this feature is enabled in the
    BIOS of your system; otherwise, the KVM instance will fail to start.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpuinfo`命令输出中的标志仅仅表示您的处理器支持虚拟化；然而，确保该功能在系统的BIOS中启用，否则KVM实例将无法启动。'
- en: 'To manually load the KVM kernel module and ensure that it''s been loaded, run
    the following code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动加载KVM内核模块并确保其已加载，请运行以下代码：
- en: '[PRE80]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How to do it...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To start a KVM instance, ensure that it''s running and finally terminate it,
    execute the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个KVM实例，请确保它正在运行，最后终止它，请执行以下操作：
- en: 'Start a QEMU instance with KVM support:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个带有KVM支持的QEMU实例：
- en: '[PRE81]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Ensure that the instance is running:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保实例正在运行：
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Terminate the instance:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止实例：
- en: '[PRE83]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works...
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To start a QEMU/KVM virtual machine, all we had to do differently from what
    we performed in the *Installing and configuring QEMU* recipe is pass the `-enable-kvm`
    flag to the `qemu-system-x86_64` command.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动QEMU/KVM虚拟机，我们与在*安装和配置QEMU*食谱中执行的操作的不同之处，仅仅是传递`-enable-kvm`标志给`qemu-system-x86_64`命令。
- en: In step 1, we specified a name for the VM with the `-name` flag, provided the
    IP address of our physical host to the `-vnc` flag, enabling VNC access for the
    virtual instance, allocated 1 GB of memory with the `-m` flag, specified the partition
    where the bootloader is located with the `index=2` parameter, the image format,
    and name, and finally we enabled KVM hardware acceleration with the `-enable-kvm`
    parameter and deamonized the process with the `-daemonize` flag.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们使用`-name`标志为虚拟机指定了一个名称，使用`-vnc`标志提供了物理主机的IP地址，从而启用了虚拟实例的VNC访问，使用`-m`标志分配了1
    GB内存，使用`index=2`参数指定了启动加载程序所在的分区、镜像格式和名称，最后使用`-enable-kvm`参数启用了KVM硬件加速，并使用`-daemonize`标志将进程转为后台运行。
- en: In step 2, we ensured that the instance is running and we terminated it in step
    3.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们确保实例正在运行，并在步骤3中将其终止。
- en: There's more...
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As an alternative to directly running the `qemu-system`-* commands, on Ubuntu
    systems there's the `qemu-kvm` package that provides the `/usr/bin/kvm` binary.
    This file is a wrapper to the `qemu-system-x86_64` command, and it passes the
    `-enable-kvm` parameter to it automatically.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 作为直接运行 `qemu-system`-* 命令的替代方案，在 Ubuntu 系统上有一个 `qemu-kvm` 包，它提供了 `/usr/bin/kvm`
    二进制文件。这个文件是 `qemu-system-x86_64` 命令的封装，它会自动传递 `-enable-kvm` 参数。
- en: 'To install the package and use the `kvm` command instead, run the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装该软件包并使用 `kvm` 命令，请运行以下命令：
- en: '[PRE84]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You might have noted that starting and stopping QEMU/KVM instances is somewhat
    of a manual process, especially having to kill the instance process in order to
    stop it. In [Chapter 2](part0068.html#20R680-c1e587dcccb14690b55c247c1809e6ce),
    *Using libvirt to Manage KVM*, we are going to walk you through a set of recipes
    that will make managing the life cycle of KVM virtual machines much easier, with
    the userspace tools that the libvirt package provides.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，启动和停止 QEMU/KVM 实例是一个相对手动的过程，尤其是需要手动终止实例进程才能停止它。在[第 2 章](part0068.html#20R680-c1e587dcccb14690b55c247c1809e6ce)，*使用
    libvirt 管理 KVM* 中，我们将带您一步步完成一系列食谱，使得管理 KVM 虚拟机的生命周期更加容易，借助 libvirt 包提供的用户空间工具。
- en: Connecting to a running instance with VNC
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到正在运行的实例并使用 VNC
- en: In this recipe, we are going to connect to a running KVM instance using a VNC
    client. Once connected, we are going to log in and check the CPU type and available
    memory of the instance. We've already seen how to start QEMU/KVM instances with
    VNC support in the previous recipes, but we are going to do it again, in case
    you are not reading this book from cover to cover.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 VNC 客户端连接到一个正在运行的 KVM 实例。连接后，我们将登录并检查实例的 CPU 类型和可用内存。我们已经在前面的食谱中介绍了如何启动带有
    VNC 支持的 QEMU/KVM 实例，但我们将再次演示，以防您没有通读本书。
- en: '**Virtual Network Computing** (**VNC**) uses the **Remote Frame Buffer** (**RFB**)
    protocol to remotely control another system. It relays the screen from the remote
    computer back to the client, allowing the full keyboard and mouse control.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟网络计算** (**VNC**) 使用 **远程帧缓冲** (**RFB**) 协议来远程控制另一台系统。它将远程计算机的屏幕转发回客户端，允许完全的键盘和鼠标控制。'
- en: There are many different VNC client and server implementations, but for this
    recipe, we are going to use a freely available version named chicken of the VNC
    for macOS. You can download the client from [https://sourceforge.net/projects/cotvnc/](https://sourceforge.net/projects/chicken/).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的 VNC 客户端和服务器实现，但在本食谱中，我们将使用名为 chicken of the VNC 的 macOS 版本。您可以从[https://sourceforge.net/projects/cotvnc/](https://sourceforge.net/projects/chicken/)下载客户端。
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In order to complete this recipe, you will need the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本食谱，您需要以下内容：
- en: The QEMU binaries, provided after following the *Installing and configuring
    QEMU* recipe
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照 *安装并配置 QEMU* 食谱操作后提供的 QEMU 二进制文件
- en: The custom raw Debian image we built in the *Installing a custom OS on the image
    with debootstrap* recipe
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 *使用 debootstrap 安装自定义操作系统到镜像* 食谱中构建的自定义原始 Debian 镜像
- en: A processor that supports virtualization
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持虚拟化的处理器
- en: The loaded KVM kernel modules
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载的 KVM 内核模块
- en: The chicken of the VNC client, installed, as described in the previous section
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一步中提到的 VNC 客户端 chicken 已经安装。
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Start a new KVM-accelerated `qemu` instance:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的 KVM 加速的 `qemu` 实例：
- en: '[PRE85]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Ensure that the instance is running:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保实例正在运行：
- en: '[PRE86]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Start the VNC client and connect to the VNC server on the IP address and display
    port you specified in step 1:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 VNC 客户端，并连接到步骤 1 中指定的 IP 地址和显示端口的 VNC 服务器：
- en: '![](img/00005.jpeg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: The VNC login screen
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: VNC 登录界面
- en: 'Log in to the instance using the root user, then check the CPU type and available
    memory as shown here:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 root 用户登录到实例，然后检查如图所示的 CPU 类型和可用内存：
- en: '![](img/00006.jpeg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: VNC session
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: VNC 会话
- en: How it works...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we started a new QEMU instance with KVM acceleration and enabled
    a VNC server on it with the specified IP address and display port. We specified
    the amount of available memory and the CPU model name.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们启动了一个新的 QEMU 实例，并启用了 KVM 加速，同时在指定的 IP 地址和显示端口上启用了 VNC 服务器。我们还指定了可用的内存大小和
    CPU 型号。
- en: In step 4, we logged in the instance using the root user and the password we
    created when building the image, then obtained the CPU information by running
    the `lscpu` command. Note how the CPU model name matches what we specified with
    the `-cpu` flag when we started the virtual machine. Next, we checked the allocated
    memory with the `free` command, which also matches what we previously specified
    with the `-m` parameter.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 4 中，我们使用 root 用户和在构建镜像时创建的密码登录了实例，然后通过运行 `lscpu` 命令获取了 CPU 信息。注意 CPU 模型名称与我们在启动虚拟机时使用
    `-cpu` 标志指定的内容相匹配。接下来，我们使用 `free` 命令检查了分配的内存，这也与我们之前通过 `-m` 参数指定的内容相符。
