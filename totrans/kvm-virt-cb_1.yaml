- en: Getting Started with QEMU and KVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring QEMU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing disk images with qemu-img
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing images for OS installation with qemu-nbd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a custom OS on the image with debootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pre-existing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running virtual machines with qemu-system-*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the QEMU VM with KVM support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a running instance with VNC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Quick Emulator** (**QEMU**) is the main component of the QEMU/KVM virtualization
    technology suit. It provides hardware virtualization and processor emulation.
    QEMU runs in userspace and, without the need for kernel, drivers can still provide
    fast system emulation. QEMU supports two operating modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Full system emulation, where QEMU emulates an entire computer system, including
    the CPU type and peripherals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User mode emulation, where QEMU can run a process that has been compiled on a
    different CPU architecture natively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we are going to focus on full system emulation with the hardware
    acceleration support provided by the **Kernel-based Virtual Machine** (**KVM**)
    hypervisor.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by installing QEMU on Linux, then explore various
    examples of building, managing, and using disk images for the virtual instances.
    We will then have an in-depth look at running QEMU in full system emulation mode,
    using the provided binaries. We will see examples of using the KVM kernel module
    to accelerate the QEMU processes. Finally, we are going to end the chapter with
    details on how to connect to the virtual machines we started earlier, using VNC
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring QEMU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at installing QEMU on a single server with the
    provided distribution packages. For production environments, we recommend using
    precompiled, packaged versions of QEMU for easier and more consistent deployments.
    However, we are going to see an example of how to compile QEMU from source, in
    case you need a certain version that you might want to package later.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your Linux distribution, the package name and installation commands
    will differ. You can use your system's package manager, such as `apt`, `dnf`,
    or `yum` to search for any packages containing the QEMU string and get familiar
    with what is available for your particular Linux variant. The source code can
    be downloaded from the official QEMU project website at [http://www.qemu-project.org/download/#source](http://www.qemu-project.org/download/#source).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to install QEMU from packages on Ubuntu/Debian
    and RHEL/CentOS distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu/Debian distributions, update your packages index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS/RHEL distributions execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To install from source, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the archive first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the files from the archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure and compile the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing QEMU is quite trivial, as we just saw. Let''s have a look at what
    the QEMU metapackage installed on Ubuntu looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that there are few packages involved.
    If you are interested, you can read the individual description to get more familiar
    with what each package provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth mentioning that all binaries provided from the earlier-mentioned packages
    start with the prefix QEMU. You can use tab completion to see the list of available
    executables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there's a single executable for each CPU architecture type that
    can be emulated.
  prefs: []
  type: TYPE_NORMAL
- en: Managing disk images with qemu-img
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run virtual machines, QEMU needs images to store the filesystem of the guest
    OS. The image itself is a type of file, and it represents the guest filesystem residing
    on a virtual disk. QEMU supports various images and provides tools to create and
    manage them. In this recipe, we are going to build a blank disk image with the
    `qemu-img` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use this recipe, we need to have the `qemu-img` utility installed. If you
    followed the steps in the first recipe, you should have that covered. To check
    what image types are supported on your Linux distribution, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that there are many supported images on
    the test system that we are using. Make sure that your QEMU version supports the
    raw image type, as it's the default and that is what we are going to use in this
    recipe. One of the most commonly used image type is `qcow2`, which supports copy
    on write, compression, encryption, and snapshotting. We are going to leverage that
    in later recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that even though QEMU supports multiple formats, that does not necessarily
    mean that you can run virtual machines on them. However, `qemu-img` can be used
    to convert different images to raw and `qcow2` formats. For best performance,
    use raw or `qcow2` image formats.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a blank raw image of a specified size
    and to verify that the file was created on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a raw image named `debian.img` with size of 10 GB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the file was created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Examine the file type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain more information about the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `qemu-img` utility allows us to create, convert, and modify guest images.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we used the `-f` flag specifying the image format; in this case,
    `raw`, the name of the image to be created and the size in gigabytes.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we used the `info` subcommand to gather additional information about
    the existing image. Note how the disk size is showing as currently being zero.
    This is due to the fact that this is a blank image, not containing a filesystem.
    We are going to create one in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we listed the supported disk image formats by QEMU. The following
    is a brief description of the most common types that you might encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`raw`: Raw disk image format. This is the default format and can be one of
    the fastest file-based formats. If you format this image with a filesystem that
    supports holes, for example, EXT3, then only sectors that have data will use space.
    The main drawback of the raw images is the lack of features, making them ideal
    for testing and quick prototyping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qcow2`: As we mentioned in the previous section, this is one of the most feature-rich
    formats. It supports VM snapshots, compression, and encryption for the price of
    slightly reduced performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qcow`: This is an older QEMU image format that supports backing files, compact
    image files, encryption, and compression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmg`: This is the Mac disk image format. The Mac disk image provides secure
    password protection and compression, and it is most commonly used to distribute
    software, rather than running virtual machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nbd`: The network block device, typically used for accessing remote storage
    devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vdi`: This disk format is used by the Oracle VirtualBox software and can be
    used to run virtual machines on various CPU platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vmdk`: This is the VMware disk image type, where a single virtual hard disk
    can span multiple files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vhdx`: Microsoft Hyper-V uses this image format. It provides large storage
    capacity, data corruption protection during power failures and read/write optimization
    for larger disk images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we are going to use the `raw` and `qcow2` disk formats, as they
    provide the best performance and toolset for running and manipulating them.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing images for OS installation with qemu-nbd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we created a blank raw image. In this recipe, we are
    going to make a partition and a filesystem on it, getting the image ready for
    full guest OS installation. When creating the partition and file system, you should
    consider the type of load that the virtual instance will create. If your applications
    running inside VM are IO bound, you might consider XFS for the image filesystem.
    For this recipe, we are going to use EXT4, as most Linux distributions support
    it out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to use the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qemu-nbd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sfdisk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `nbd` kernel module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkfs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most Linux distributions should already have the tools installed. If that's
    not the case, consult your distribution's documentation on how to install them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps outlined to partition and create a filesystem on
    the blank image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the `nbd` kernel module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `qemu-nbd` tool, associate the blank image file to the `/dev/nbd0`
    block device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two partitions on the block device. One will be used for swap, and the
    other as the root partition for the guest OS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'List the available block devices after the partitioning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the swap partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the EXT4 filesystem on the root partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We take advantage of the functionality that the `nbd` kernel module provides
    by allowing us to associate a raw image file to a block device using the `qemu-nbd`
    utility. To get more information about the kernel module run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can examine the block device metadata created in step 2 by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the two new partitions in step 3, the type of the image file
    has changed. Let''s examine it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We chose to use the `sfdisk` utility to create the partitions, but you can use
    the `fdisk` utility interactively instead if you prefer. The end result will be
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an image file that contains two partitions and a filesystem,
    we can proceed with installing the guest OS in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a custom OS on the image with debootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the `debootstrap` utility to install a Debian
    distribution on the raw image we prepared in the previous two recipes. The `debootstrap`
    command is used to bootstrap a basic Debian system using a specific public mirror.
    By the end of this recipe, we should have an image containing an entire Linux
    distribution, ready for QEMU execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to need the following in order to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: The block devices created in the previous recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `debootstrap` utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `chroot` utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To ensure that the swap and root block devices are still present on the system,
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If that's not the case, please refer to the *Preparing images for OS installation
    with qemu-nbd* recipe on how to associate the raw image with the `/deb/nbd0` block
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the `debootstrap` utility, if not already present on your system,
    execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps outlined to install a new Debian Linux distribution on the
    raw image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mount the root partition from the **Network Block Device** (**NBD**) device
    and ensure that it was mounted successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the latest stable Debian distribution on the root partition mounted
    on `/mnt` from the specified public repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure the root filesystem was created, by listing all the files at the mounted
    location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind and mount the devices directory from the host to the image filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the `nbd` devices are now present inside the mount location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the directory namespace to be the root filesystem of the image and ensure
    the operation succeeded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the distribution version inside the chroot environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Mount the `proc` and `sysfs` virtual filesystems inside the chrooted environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'While still inside the chrooted location, install the Debian kernel metapackage
    and the `grub2` utilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If asked to select target device for GRUB to install on, do not select any and
    just continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install GRUB on the root device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the GRUB configs and the `initrd` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the root password of the guest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Allow access to the pseudo Terminal inside the new guest OS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `systemd` run level to the `multi-user` level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the root mountpoint to the `fstab` file, so it can persist reboots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Unmount the following filesystems as we are done using them for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Exit the chrooted environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Install GRUB on the root partition of the block device associated with the
    raw image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the GRUB configuration file to reflect the correct block device for
    the guest image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Unmount the `nbd0` device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Disassociate the `nbd0` device from the raw image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot has happened in the previous section, so let's step through the commands
    and talk a little bit more about what exactly was performed and why.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we mounted the root partition we created earlier on the `/dev/nbd0p2`
    device to `/mnt`, so we can use it. Once mounted, in step 2, we installed an entire
    Debian distribution on that device using the mount-point as the target.
  prefs: []
  type: TYPE_NORMAL
- en: In order to install the GRUB boot loader on the root partition of the image,
    we bind and mounted the `/dev` directory from the host filesystem to the image
    filesystem in `/mnt` in step 4.
  prefs: []
  type: TYPE_NORMAL
- en: Then in step 6, we used the chroot tool to change our directory namespace to
    be `/mnt`, so we can perform operations, as we are directly on the new OS.
  prefs: []
  type: TYPE_NORMAL
- en: In step 8, we mounted the `proc` and `sysfs` virtual filesystems inside the
    image because the GRUB bootloader tool expect them.
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, we proceeded to install the kernel source and GRUB tools in preparation
    of installing the bootloader on the boot partition and in step 10 we installed
    the bootloader.
  prefs: []
  type: TYPE_NORMAL
- en: In step 11, the GRUB configuration files were generated and the boot ramdisk
    image was updated.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 12, 13, and 14, we changed the root password and ensured we get access
    to the pseudo Terminal, so we can log into the VM later and change the run-level
    from the default graphical interface to the multiuser.
  prefs: []
  type: TYPE_NORMAL
- en: Since the fstab file is empty right after installing the Debian OS on the image,
    we have to add the root mount point, or the VM will not be able to start. This
    was accomplished in step 15.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 16 and 17, we performed some cleaning up by unmounting the filesystems
    we mounted earlier and exited the chroot environment.
  prefs: []
  type: TYPE_NORMAL
- en: Back on the host filesystem in step 18, we installed GRUB on the `nbd0` device
    by specifying the mounted location of the image.
  prefs: []
  type: TYPE_NORMAL
- en: In step 19, we updated the GRUB config device name to be `sda2` because this
    is the name that will appear inside the virtual machine once we start it. The
    `nbd0p2` name is only present while we have the association between the raw image
    and the network block device on the host OS. From the VM perspective, the second
    partition inside the image we created by is named `sda2` by default.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, in steps 20 and 21, we performed some cleaning by removing the
    mount point and disassociating the raw image from the network block device `nbd0`.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to examine how to resize an existing raw image,
    the partitions hosted on it and the filesystem on top of the partitions. We are
    going to be using the raw image that we build in the previous recipes, which contains
    a swap and a root partition with an EXT4 filesystem formatted on it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to use the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qemu-img`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`losetup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tune2fs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e2fsck`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kpartx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fdisk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resize2fs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the utilities should already be installed on Ubuntu with the exception
    of `kpartx`. To install it, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next steps demonstrate how to add additional space to the raw image we created
    earlier, extend the root partition, and resize the filesystem. By the end of this
    recipe, the original raw image filesystem size should have changed from `10G`
    to `20G`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtain the current size of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add additional 10 GB to the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Please note that not all image types support resizing. In order to resize such
    an image, you will need to convert it to raw image first using  the `qemu-img`
    convert command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the new size of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the name of the first unused loop device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Associate the first unused loop device with the raw image file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the partition information from the associated loop device and create the
    device mappings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Examine the new device maps, representing the partitions on the raw image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain some information from the root partition mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the filesystem on the root partition of the mapped device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the journal from the root partition device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the journaling has been removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the partition mappings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Detach the loop device from the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Associate the raw image with the network block device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `fdisk`, list the available partitions, then delete the root partition,
    recreate it, and write the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Associate the first unused loop device with the raw image file, like we did
    in step 5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the partition information from the associated loop device and create the
    device mappings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After the partitioning is complete, perform a filesystem check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Resize the filesystem on the root partition of the mapped device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the filesystem journal because we removed it earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the device mappings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resizing an image for VM can be somewhat involving, as we saw from all the steps
    in the previous section. Things can get complicated when there are multiple Linux
    partitions inside the same image, even more so if we are not using **Logical Volume
    Management** (**LVM**). Let's step through all the commands we ran earlier and
    explain in more details why we ran them and what they do.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we confirmed the current size of the image being 10 GB.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we added 10 GB at the end of the image and confirm the new image
    size in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the image we built from earlier recipes contains two partitions,
    swap and root. We need a way to manipulate them individually. Particularly, we
    would like to allocate the extra space we added in step 2 to the root partition.
    To do that we need to expose it as a block device that we can easily manipulate
    with standard disk and filesystem utilities. We accomplished that using the `losetup`
    command in step 5, resulting in a mapping between the image and a new block device
    named `/dev/loop1`. In step 6, we exposed the individual partitions as two new
    device mappings. The `/dev/mapper/loop1p2` is the root partition that we would
    like to append the unused disk space to.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can resize the partitioned on the loop device, we need to check the
    integrity of the filesystem on it, and this is what we did in step 9\. Because
    we are using a journaling filesystem, we need to remove the journal prior to resizing.
    We do that in step 10 and made sure that the `has_journal` attribute is not showing
    after running the `tune2fs` command in step 11.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to work directly on the main block device and not the individual
    partitions. We remove the mappings in steps 12 and 13 and associated a new block
    device with the image file using the `qemu-nbd` command in step 14\. The new `/dev/nbd0`
    block device now represents the entire disk of the guest VM and it's a direct
    mapping to what's inside the raw image. We can use this block device just like
    any other regular disk, most importantly we can use tools such as `fdisk` to examine
    and manipulate the partitions residing on it.
  prefs: []
  type: TYPE_NORMAL
- en: In step 15, we use the `fdisk` utility to delete the root partition and recreate
    it. This does not destroy any filesystem data, but changes the metadata, allocating
    the extra space we added earlier as part of the root partition.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the block device has all the disk space allocated to the root partition,
    we need to extend the filesystem that is on top of it. We do that by first recreating
    the individual partition mappings like we did earlier, to expose the root partition
    directly so that we can yet again manipulate it. We do that in steps 16 and 17.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 18 and 19, we check the integrity of the root file system, then we
    resize it to the maximum available disk space on the root partition that it resides.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in step 20, we remove the mappings again. Now the image, the root partition
    inside the image, and the EXT4 filesystem on top of the Linux partition have been
    resized to 20 GB.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the new root partition size by starting a new QEMU instance using
    the image. We are going to do just that in a separate recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using pre-existing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Installing a custom OS on the image with debootstrap* recipe, we saw
    how to use the `debootstrap` command to install Debian on an image we built. Most
    Linux vendors provide already built images of their distributions for various
    architectures. Installable images are also available for manually installing the
    guest OS. In this recipe, we are going to demonstrate how to obtain and examine
    CentOS and Debian images that have already been built. In a later recipe, we are
    going to show how to start QEMU/KVM instances using those same images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we are going to need QEMU installed on the host OS. For instructions
    on how to install QEMU, please refer to the *Installing and configuring QEMU*
    recipe from this chapter. We are also going to need the `wget` utility to download
    the images from the upstream public repositories.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To obtain Debian Wheezy images for use with QEMU and KVM, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the image using `wget`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the type of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To download CentOS images run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the image using wget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the type of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many public repositories on the Internet that provide images of various
    types, most commonly `qcow2` for use with QEMU/KVM. In the previous section, we
    used the official CentOS repository to obtain the image and an another one containing
    prebuilt images for Debian.
  prefs: []
  type: TYPE_NORMAL
- en: Both images are in the `qcow2` format, as we confirmed in step 2.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've only seen how to build, examine, manipulate, and download images.
    In the next recipe, we are going to focus on how to actually use the images to
    start QEMU/KVM instances.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examine the following links to get more information about what prebuilt images
    are available for the listed distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: Official Ubuntu images: [https://uec-images.ubuntu.com/releases/](https://uec-images.ubuntu.com/releases/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official CentOS images: [https://cloud.centos.org/centos/](https://cloud.centos.org/centos/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official Debian images: [http://cdimage.debian.org/cdimage/openstack/](http://cdimage.debian.org/cdimage/openstack/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official Fedora images: [https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official openSUSE images: [http://download.opensuse.org/repositories/Cloud:/Images:/](http://download.opensuse.org/repositories/Cloud:/Images:/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running virtual machines with qemu-system-*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to demonstrate how to start virtual machines with
    QEMU. QEMU provides binaries that can emulate different CPU architectures using
    either custom or prebuilt images for the guest OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you completed the *Installing and configuring QEMU* recipe, you should have
    a host that contains the following binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Each command can start a QEMU-emulated instance for the specific CPU architecture.
    For this recipe, we are going to be using the `qemu-system-x86_64` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The QEMU binaries, provided after following the *Installing and configuring
    QEMU* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom raw Debian image we built in the *Installing a custom OS on the image
    with debootstrap* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CentOS `qcow2` image we downloaded in the *Using pre-existing images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at what CPU architectures QEMU  supports on the host system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see the list of CPUs that we can pass as parameters to
    the `-cpu` flag in order to emulate that CPU type inside our virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start a new virtual machine using the `qemu-system` utility, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new QEMU virtual machine using the `x86_64` CPU architecture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the instance is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminate the Debian QEMU instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new QEMU instance using the prebuilt CentOS image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the instance is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminate the CentOS QEMU instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to replace the IP address of the `-vnc` parameter with the one from
    your host machine.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to start a virtual machine with QEMU/KVM depends greatly on the type of
    image and how the partitions are structured inside that image.
  prefs: []
  type: TYPE_NORMAL
- en: We used two different image types with different partitioning schemes to demonstrate
    this concept.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we used the `qemu-system-x86_64` command to emulate a `x86_64` CPU
    architecture, specifically we passed the `-cpu Nehalem` flag, emulating the Nehalem
    CPU model. We passed the IP address of our host as a parameter to the `-vnc` flag.
    This starts a VNC server in the VM so that we can later use a VNC client to connect
    to the QEMU instance. We specified the amount of memory to be allocated to the instance,
    in this case, 1GB with the `-m` flag. We instructed QEMU that we are going to
    use a raw image with the `format=raw` option and the name and location of the
    actual image with the `file=debian.img` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that this raw image contains two partitions with the second partition
    containing the root filesystem where the bootloader is located. This is very important
    to remember because we need to specify from what partition index the guest OS
    should load. We do that with the `index=2` flag. Finally, we pass the `-daemonize`
    parameter to background the QEMU process.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we started another QEMU instance, this time using the `qcow2` CentOS
    image we downloaded earlier. We did not have to specify from what partition we
    need to boot from this this time because most prebuilt images use the first partition,
    or only have one partition. We also used the `-hda` flag instead of the `-drive`
    parameter, just to demonstrate that both options can be used with the same result.
    The `-hda` flag tells QEMU the first disk for the instance should be loaded from
    the filename that follows it.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the QEMU VM with KVM support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to start a QEMU virtual machine with KVM acceleration.
    **Kernel-based Virtual Machine** (**KVM**) is a full virtualization technology
    for CPU architectures that support virtualization extensions. For Intel-based
    processors, this is the Intel VT, and for AMD CPUS, it is the AMD-V hardware extension.
    The main parts of KVM are two loadable kernel modules, named `kvm.ko`, which provides
    the main virtualization functionality, and a second kernel module that is processor
    specific, `kvm-intel.ko` and `kvm-amd.ko` for both main CPU vendors.
  prefs: []
  type: TYPE_NORMAL
- en: QEMU is the userspace component to create virtual machines, where KVM resides
    in kernel space. If you completed the *Running virtual machines with qemu-system*-*
    recipe, you might note that the difference between running a KVM virtual machine
    and running a nonaccelerated QEMU instance is just a single command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to start a KVM instance, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The QEMU binaries, provided after following the *Installing and configuring
    QEMU* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom raw Debian image we built in the *Installing a custom OS on the image
    with debootstrap* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processor that supports virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The KVM kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check whether your CPU supports virtualization, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The presence of the `vmx` (for Intel) or `svm` (for AMD) flags indicate that
    your CPU supports the virtualization extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The flags from the `cpuinfo` command output simply mean that your processor
    supports virtualization; however, make sure that this feature is enabled in the
    BIOS of your system; otherwise, the KVM instance will fail to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually load the KVM kernel module and ensure that it''s been loaded, run
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start a KVM instance, ensure that it''s running and finally terminate it,
    execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a QEMU instance with KVM support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the instance is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminate the instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start a QEMU/KVM virtual machine, all we had to do differently from what
    we performed in the *Installing and configuring QEMU* recipe is pass the `-enable-kvm`
    flag to the `qemu-system-x86_64` command.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we specified a name for the VM with the `-name` flag, provided the
    IP address of our physical host to the `-vnc` flag, enabling VNC access for the
    virtual instance, allocated 1 GB of memory with the `-m` flag, specified the partition
    where the bootloader is located with the `index=2` parameter, the image format,
    and name, and finally we enabled KVM hardware acceleration with the `-enable-kvm`
    parameter and deamonized the process with the `-daemonize` flag.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we ensured that the instance is running and we terminated it in step
    3.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an alternative to directly running the `qemu-system`-* commands, on Ubuntu
    systems there's the `qemu-kvm` package that provides the `/usr/bin/kvm` binary.
    This file is a wrapper to the `qemu-system-x86_64` command, and it passes the
    `-enable-kvm` parameter to it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the package and use the `kvm` command instead, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: You might have noted that starting and stopping QEMU/KVM instances is somewhat
    of a manual process, especially having to kill the instance process in order to
    stop it. In [Chapter 2](part0068.html#20R680-c1e587dcccb14690b55c247c1809e6ce),
    *Using libvirt to Manage KVM*, we are going to walk you through a set of recipes
    that will make managing the life cycle of KVM virtual machines much easier, with
    the userspace tools that the libvirt package provides.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a running instance with VNC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to connect to a running KVM instance using a VNC
    client. Once connected, we are going to log in and check the CPU type and available
    memory of the instance. We've already seen how to start QEMU/KVM instances with
    VNC support in the previous recipes, but we are going to do it again, in case
    you are not reading this book from cover to cover.
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual Network Computing** (**VNC**) uses the **Remote Frame Buffer** (**RFB**)
    protocol to remotely control another system. It relays the screen from the remote
    computer back to the client, allowing the full keyboard and mouse control.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many different VNC client and server implementations, but for this
    recipe, we are going to use a freely available version named chicken of the VNC
    for macOS. You can download the client from [https://sourceforge.net/projects/cotvnc/](https://sourceforge.net/projects/chicken/).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to complete this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The QEMU binaries, provided after following the *Installing and configuring
    QEMU* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom raw Debian image we built in the *Installing a custom OS on the image
    with debootstrap* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A processor that supports virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loaded KVM kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chicken of the VNC client, installed, as described in the previous section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start a new KVM-accelerated `qemu` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the instance is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the VNC client and connect to the VNC server on the IP address and display
    port you specified in step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The VNC login screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to the instance using the root user, then check the CPU type and available
    memory as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: VNC session
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 1, we started a new QEMU instance with KVM acceleration and enabled
    a VNC server on it with the specified IP address and display port. We specified
    the amount of available memory and the CPU model name.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we logged in the instance using the root user and the password we
    created when building the image, then obtained the CPU information by running
    the `lscpu` command. Note how the CPU model name matches what we specified with
    the `-cpu` flag when we started the virtual machine. Next, we checked the allocated
    memory with the `free` command, which also matches what we previously specified
    with the `-m` parameter.
  prefs: []
  type: TYPE_NORMAL
