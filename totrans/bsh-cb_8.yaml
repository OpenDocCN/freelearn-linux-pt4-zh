- en: Advanced Scripting Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating and reducing the runtime of a script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing one-line conditional statements and loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding command not found warnings/errors and improving portability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a config file and using it in tandem with your scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving your shell – GCC and command line colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding aliases, and altering user paths/variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Echoing output to raw terminal devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating simple frontend GUIs for Bash scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling and installing your own Bash Shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording terminal sessions for automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing high-quality scripts by example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will help the readers to learn about advanced scripting techniques
    as well as how to customize their shell. Users will learn to calculate as well
    as reduce the runtime of the script. It will be easy for users to write one-line
    loops and conditional statements. Users will learn to write scripts to avoid warnings
    and errors. They will learn how to create a config file and use it. Users will
    learn to improve the shell, adding aliases, altering path variables, and echoing
    output to terminal devices. Users will also learn about recording terminal sessions
    and writing scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating and reducing the runtime of a script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to calculate and reduce the script’s
    runtime. A simple `time` command will help in calculating the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a terminal open, make sure you have the necessary scripts present
    in your system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will write a simple script that contains a few commands, and then, using
    the `time` command, we will get the runtime of that script. Create a script `cal_runtime.sh`
    and write the following code in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have written a script `cal_runtime.sh` and four commands in that script:
    `clear, ls, date,` and a `python3` installation command. Run your script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After the execution, you will get the runtime of the script at the bottom of
    your output.
  prefs: []
  type: TYPE_NORMAL
- en: Writing one-line conditional statements and loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to write scripts that will contain one-line conditional
    statements as well as looping statements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to have basic knowledge of conditional and looping statements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will write a script for a one-line conditional statement. In this script,
    we will write a simple `if` condition. Create a script named `if_oneline.sh` and
    write the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will write a script for a one-line `loop` statement. In it, we are
    going to write a command that will execute 10 times. Create a script `for_online.sh`,
    and write this code in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write a script for a one-line `while` statement. This will be
    an infinite loop. Create a script named `while_oneline.sh` and write the following
    code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we wrote three scripts for a one-line if statement, for loop,
    and while loop. In the if example, the condition will be checked and then the
    output will be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the `for` loop example, the `echo` command will be executed 10 times and
    Hello world will be displayed 10 times on the screen. In the while example, it
    will be an infinite loop. We have given a sleep of `2` seconds so that the output,
    10, will be executed infinitely every 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding command not found warnings/errors and improving portability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to avoid warnings and errors in a
    shell script. For that, we are going to use the concept of redirection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a terminal open, you need to have basic knowledge of the redirection
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, while debugging your shell scripts, you may not want to view the
    errors or warning messages as well as your standard output. So for that, we are
    going to use the redirection technique. Now, we will write `lynda` as a command
    in our terminal. Run the command as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7ed9fec7-b57e-4722-a086-e913a25c9419.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will get the `command not found` error. We can avoid this error by running
    the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will write a script with a wrong syntax for declaring the variable. And we
    will redirect that error message to `log.txt`. Create a script `avoid_error.sh`,
    and write following content in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the second line, `a = 100`, we will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whatever error message you get after pressing *Enter*, that error will get
    stored in `log.txt`. Now view the contents of `log.txt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/83deac13-d1ee-4119-80d9-f65d92f2118b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, in this way, you can avoid warnings as well as errors. Now, run the script
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The error message will get stored in `log.txt`. You can view it by running the `cat
    log.txt` command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a config file and using it in tandem with your scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a config file and use it in our shell
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a terminal open, you need basic knowledge of creating scripts
    and config files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to create a script and config file. The extension of the
    configuration file is `.conf`. Create a script called `sample_script.sh` and write
    this code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create a configuration file. Create a file called `sampleconfig.conf`
    and write the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After running the script username, password, and hostname, it will display the
    command we mentioned in  `PROMPT_COMMAND`.
  prefs: []
  type: TYPE_NORMAL
- en: Improving your shell – GCC and command line colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going learn how a user can improve the shell. We will
    do this using the PS1 bash environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides a terminal, you need basic knowledge of PS1.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The terminal appearance is taken by the `PS1` shell variable. The content allowed
    in `PS1` will contain backslash-escape special characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will see what PS1''s current contents in the system. For that, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/16726413-5619-429c-8eca-2dee1118ee41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the backslash-escape special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\u`: Current username'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\h`: Hostname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\W`: Current working directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\$`: Will display `#` if the user is root; otherwise it will display $ only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\@`: Current time in 12-hour AM/PM format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will modify our Bash. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7654f47a-4b67-4ee6-b8ff-d9c638fb4999.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we will write a command to change the colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the text color blue, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/19605f38-20c8-4883-b1d5-05474fd373d3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we, will see the `tput` command. Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ab886273-6eb9-4bfd-85ea-06292a5397f3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3a93a212-9120-47a3-b059-3d1ce40b04d6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We used the `PS1` shell variable to improve our shell. We add colors in the
    `PS1` variable and the colors were changed. We used the `tput` command too. This
    command is also used to modify the settings. `setaf` sets the foreground color,
    and `setab` sets the background color. The color codes for the `tput` command
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Color** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Black |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Red |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Green |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Yellow |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Blue |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Magenta |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Cyan |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | White |'
  prefs: []
  type: TYPE_TB
- en: Adding aliases, and altering user paths/variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to create an alias of a command and alter the user
    path variable. We are going to learn about the `alias` command. Using `alias`
    command, we are going to create aliases for other commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a terminal open, we need the basic knowledge of the alias command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a alias for the `pwd` command. Run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create an alias for the `ls` command. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `alias` command is used to create a shortcut for commonly used commands.
  prefs: []
  type: TYPE_NORMAL
- en: We have created an alias `p` for command `pwd`. So, we just run the `p` command
    to get the present working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have created an alias `l` for command `ls`. So, we just run the `l` command
    to get the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Echoing output to raw terminal devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how we can echo the output from one terminal
    to another. To achieve this, we are going to use `tty`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a terminal open, you need basic knowledge of `tty`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**tty** means **teletype.** `tty` displays terminal-related information. Everything
    in Linux is a file. So, `tty` prints the filename of the terminal that is connected
    to standard input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open a terminal and run tty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, the current `tty` session will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Open another terminal B and do the same; you will get that terminal’s tty session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I have two tty sessions as:'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal A = `/dev/pts/4`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal B = `/dev/pts/7`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Terminal A, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now check Terminal B; `Hello world` will be displayed on the terminal. Again,
    run the following command to send another string to terminal B.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following will be the output on terminal B.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating simple frontend GUIs for Bash scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a simple GUI. We are going to use the
    zenity tool to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a terminal open, make sure you have zenity installed in your
    system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Zenity** is used to add a graphical interface to shell scripts using a single
    command. Zenity comes by default with Ubuntu. If not, then install it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, we will catch a `yes/no` response in our shell script and then perform
    different commands based on the button. Run the following command to get the `yes/no`
    response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c8d69678-1488-4269-8d2d-703879be84df.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the following command to get the error message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/217d5a79-cacf-46da-acb2-d5e2092e5fad.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the following command to get the text entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d31b659d-2deb-4591-af99-77af34fd7c87.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we will create a script where the user has to enter a time and till that
    time the user has to wait. When the wait is over, the user will get a message.
    Create a script, `user_wait.sh`, and write the following content in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Use 10s for 10 seconds, 20m for 20 minutes, or 3h for 3 hours as shown in the
    following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f9dec70-4bc4-4fff-b35f-b6191178c535.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/25c0fec8-e204-45cb-91bc-17d83b379e9b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The timer is over:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d4b7d73-cf24-4e4f-930e-c18e652ddaae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zenity is an open source application that displays dialog boxes using shell
    scripts as well as the command line. Using zenity communication between the user
    and shell will be easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--question`: Displays question dialog box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--error`: Displays error dialog box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--entry`: Displays text entry dialog box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--info`: Displays info dialog box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the script `user_wait.sh`, we are creating a Timer using a text entry dialogbox
    and info dialogbox. We have created a variable named `time`. We are asking the
    user to enter a duration of time and that value will be stored in the time variable.
    Then we are providing that variable to sleep. Therefore, until that time, the
    user has to wait. After the time completes, the user will get the information
    dialogbox as the time is over.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and installing your own Bash shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn about compile and install the Bash shell.
    We are going to use SHC, which is shell script compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a terminal open, make sure you have SHC installed in your system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will write a simple shell script that will print `“Hello World”`. Using
    SHC, the Shell script will be converted into binaries directly. Create a script
    `hello.sh`, and write the following content in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to log all commands, run the `logger` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After executing the script, two extra files will be created. The files are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hello.sh.x`: This file is the stripped binary encrypted shell script in binary
    format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hello.sh.x.c`: This file is the C source code of `hello.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, execute the encrypted shell script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The logger command will make an entry about your file in the syslog file, which
    is present in the `/var/log` directory of your system. You can check out that
    file. Navigate to `/var/log` directory and run `nano syslog`; you will find the
    entry in it.
  prefs: []
  type: TYPE_NORMAL
- en: Recording terminal sessions for automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to record terminal sessions. We are
    going to use the **ttyrec** tool to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a Terminal open, make sure ttyrec is installed in your system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To record terminal data, we use the ttyrec tool. You can also play the recorded
    data. Now, to record the terminal session, enter the `ttyrec` command in the terminal.
    You can end the recording by typing `exit`. Run the following command to record
    the terminal session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you run the `ttyrec` command, the terminal record session will be started.
    The recording will go on until you type exit. As soon as you type `exit`, the
    recording will be stopped and a file will be created in your current working directory.
    The filename will be `ttyrecord`. You can play this file by running the `ttyplay`
    command. Run the `ttyrecord` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Writing high-quality scripts by example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to see functions in shell scripts. We will see
    how our program testing is done, sequentially on the various parts, using functions.
    Functions help improve the readability of a program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a terminal open, you need to have a basic knowledge of functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to write a simple function in our shell script to return the current
    date and time. Create a script `function_example.sh`, and write this code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now we will create another script containing two functions with the same name.
    Create a script `function2.sh`, and write the following content in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first script, we created a function named `print_date()` and we just
    printed a date using a function.
  prefs: []
  type: TYPE_NORMAL
- en: In the second script, we wrote two functions with the same name. However, after
    execution, the last value was printed on the screen. So in this case, Second block
    Number 2 will be printed on the screen.
  prefs: []
  type: TYPE_NORMAL
