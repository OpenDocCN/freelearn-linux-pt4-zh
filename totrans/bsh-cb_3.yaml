- en: Understanding and Gaining File System Mastery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并掌握文件系统管理
- en: 'In this chapter, we will introduce the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将介绍以下内容：
- en: Viewing files from various angles – head, tail, less, and more
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同角度查看文件——头部、尾部、less 和 more
- en: Searching for files by name and/or extension
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按名称和/或扩展名搜索文件
- en: Creating a diff of two files and patching
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个文件的差异并打补丁
- en: Creating symbolic links and using them effectively
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建符号链接并有效使用它们
- en: Crawling filesystem directories and printing a tree
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爬取文件系统目录并打印目录树
- en: Finding and deleting duplicate files or directories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找并删除重复的文件或目录
- en: Joining and splitting files at arbitrary positions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任意位置合并和拆分文件
- en: Generating datasets and random files of various size
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成各种大小的数据集和随机文件
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will extend some of the contents from Chapter 2, *Acting
    Like a Typewriter and File Explorer*, but aim to make you even stronger when creating,
    viewing, and managing files. After all, how does one look at a very large file?
    Find external software dependencies of a binary and manipulate files? Surely,
    these tasks are cornerstones in a number of tasks any one developer, administrator,
    or power user can think of.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将扩展第2章的部分内容，*像打字机和文件浏览器一样操作*，但目标是让你在创建、查看和管理文件时更强大。毕竟，如何查看一个非常大的文件？如何找到二进制文件的外部软件依赖并操作文件？这些任务无疑是每个开发者、管理员或高级用户都能想到的基础任务。
- en: For example, Bob the reader has already been introduced to VI, and perhaps he
    has his own GUI editor or application, such as Open Office, but what happens if
    that editor likes to crash upon opening a full file? Can he just look at the starting
    few lines? Absolutely. Can he split that file (if the structure is known like
    a CSV) at X number of lines? Again, absolutely!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，读者 Bob 已经了解了 VI，或许他有自己的 GUI 编辑器或应用程序，如 Open Office，但如果这个编辑器在打开完整文件时崩溃了怎么办？他可以只查看文件的前几行吗？完全可以。他能在
    X 行处拆分该文件（如果结构已知，如 CSV 格式）吗？当然可以！
- en: All of these things are not impossible, and the list of activities Bob can do
    can continue on forever. The idea of this chapter is to give you a segue into
    some of the things you can do if life isn't going your way or you need quick access/control
    over the files on your system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事情并非不可能，Bob 可以做的活动清单几乎是无止境的。本章的目的是让你了解如果生活不如意或你需要快速访问/控制系统中的文件时，你可以做的一些事情。
- en: The scripts for this chapter can be found at [https://github.com/PacktPublishing/Bash-Cookbook/tree/master/chapter%2003](https://github.com/PacktPublishing/Bash-Cookbook/tree/master/chapter%2003).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的脚本可以在 [https://github.com/PacktPublishing/Bash-Cookbook/tree/master/chapter%2003](https://github.com/PacktPublishing/Bash-Cookbook/tree/master/chapter%2003)
    找到。
- en: Viewing files from various angles – head, tail, less, and more
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从不同角度查看文件——头部、尾部、less 和 more
- en: As of this very moment, your system likely has many text files of various sizes
    including a never ending log file being written too. You might even have several
    large files containing copious amounts of code (such as the Linux kernel or a
    software project) and would like to quickly view them from the console without
    slowing your system down to a halt.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的系统可能有许多不同大小的文本文件，其中还包括一个不断写入的日志文件。你可能还拥有一些包含大量代码的大文件（如 Linux 内核或软件项目），并希望能快速查看这些文件，而不会让系统变得非常缓慢。
- en: 'To do this, there are four essential commands that should be able to provide
    you more than enough functionality for their purposes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，有四个基本命令，应该能够为你提供足够的功能来实现它们的目的：
- en: '**Head**: Can be used to output the beginning lines of a file'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Head**：可以用于输出文件的开头部分'
- en: '**Tail**: Can be used to output the end or tail of a file (continuously as
    well)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tail**：可以用于输出文件的末尾部分（也可以连续输出）'
- en: '**More**: A tool used as a *pager* to view large files page by page/line by
    line'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**More**：一个作为 *分页器* 用于逐页或逐行查看大文件的工具'
- en: '**Less**: Is the same as more, but it has more features, including backwards
    scrolling'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Less**：与 more 相同，但它有更多功能，包括向后滚动'
- en: Sometimes, you may see the command `more` on embedded systems and not the `less`
    command. This is because the less command is larger than `more`. Does your head
    hurt yet?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会在嵌入式系统上看到 `more` 命令，而不是 `less` 命令。这是因为 less 命令比 more 更大。你的头痛了吗？
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Besides having a terminal open, several large text files are needed for this
    recipe. If you have some already, great; if not, install the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打开终端之外，本食谱还需要几个大文本文件。如果你已经有了，那太好了；如果没有，可以安装以下内容：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `fmt` command is a simple optimal text formatter. It is used to clean up
    the output a bit for better results on the command line.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt` 命令是一个简单的文本格式化工具，用于清理输出内容，使命令行结果更为整洁。'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open a terminal and run the following commands:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并运行以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Interestingly enough, the `tail` command has a feature that is different than
    the `head` command: it can monitor the tail end of a file forever until the command
    is exited or killed when using the `-f` or `-F` flags. Run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`tail` 命令具有一个不同于 `head` 命令的特性：它可以持续监控文件的尾部，直到命令被退出或终止，前提是使用了 `-f` 或 `-F`
    标志。运行以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keeping the `tail` command running, try disconnecting your wireless or Ethernet
    port. What do you see?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 `tail` 命令运行，尝试断开你的无线或以太网端口。你看到了什么？
- en: 'Press *Ctrl* + *C* to quit `tail` and run the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 退出 `tail`，并运行以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Pressing the spacebar or *Enter* on your keyboard will progress through the
    file until the end. Pressing `q` will immediately exit `more` and return you to
    the console prompt.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 按下空格键或 *Enter* 键将使你浏览文件直到末尾。按 `q` 将立即退出 `more`，并返回到控制台提示符。
- en: 'Next, try the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试运行以下命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Try navigating through the file using *p**g up*, *pg dn*, the up and down arrow
    keys, and *Enter* and the spacebar. Notice anything?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 *pg up*、*pg dn*、上下箭头键、*Enter* 和空格键浏览文件。注意到什么了吗？
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before proceeding, note that the contents of the `loremipsum.txt` file will
    be different for every instance downloaded. **Lorem Ipsum** is pseudo random text
    that is used in a variety of text-related duties, often as placeholder values
    because it *looks* to be a language of sorts and is useful where the human brain
    is disturbed by copy and paste stub text.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意，`loremipsum.txt` 文件的内容在每次下载时都会有所不同。**Lorem Ipsum** 是一种伪随机文本，广泛用于各种与文本相关的任务，通常作为占位符值，因为它
    *看起来* 像某种语言，且在复制粘贴占位文本时能避免人类大脑的干扰。
- en: 'Great! Let''s get started:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们开始吧：
- en: 'In the first step, the commands should produce similar results to the following
    block (for brevity, we excluded much of the output to keep the recipe coherent),
    but notice that head begins at the beginning, or *head*, of `loremipsum.txt`,
    and tail begins at the end, or *tail*, of `loremipsum.txt`**.** When we specify
    the `-n` flag with a decimal number such as `1`, both utilities will output a
    single line or whatever number of lines is entered:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步中，命令应该会生成类似于以下的输出（为了简洁，我们省略了部分输出以保持教程的一致性），但注意，`head` 从文件的开头，即 `loremipsum.txt`
    的 *head* 开始，而 `tail` 从文件的末尾，即 `loremipsum.txt` 的 *tail* 开始。当我们指定带有小数数字（如 `1`）的
    `-n` 标志时，这两个工具都会输出一行或用户输入的任意行数：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the second step, we discover a key difference between the `head` and `tail`
    commands. Tail is able to monitor a file while continuously dumping the tail contents
    of the file to standard out `(stdout)`. If the file has a read error, or is moved/rotated
    out, `-f` (lowercase) will often stop outputting information, while `-F` will
    reopen the file and continue outputting the contents.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，我们发现 `head` 和 `tail` 命令之间的一个关键区别。`tail` 能够监控文件，并持续将文件的尾部内容输出到标准输出 `(stdout)`。如果文件发生读取错误，或者被移动/旋转出去，`-f`（小写）通常会停止输出信息，而
    `-F` 会重新打开文件并继续输出内容。
- en: '`-F` instead of `-f` is usually the desired option between the two if tailing
    system logs.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要监视系统日志，通常在两者之间选择 `-F` 而非 `-f`。
- en: 'With `tail` still running in continuous mode, several new entries should appear
    among the output. This sample is from when a system''s wireless adapter was forced
    to reconnect to a standard access point (AP):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tail` 命令仍然以连续模式运行的情况下，输出中应该会出现一些新的条目。这个示例来自于系统的无线适配器被强制重新连接到标准接入点（AP）时：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After killing the `tail` command, your console should be back at the prompt
    again: `$`.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 杀死 `tail` 命令后，控制台应该会恢复到提示符 `$`。
- en: Running `more` and using the spacebar or *Enter* keys will progress output through
    the entire `loremipsum.txt` file. The `more` command is only able to view from
    beginning to end, and not back and forth.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `more` 并使用空格键或 *Enter* 键可以浏览整个 `loremipsum.txt` 文件。`more` 命令只能从文件开头到末尾查看，无法前后跳转。
- en: The `less` command is certainly more powerful and offers the user to be able
    to navigate through `loremipsum.txt` using several key combinations. It also offers
    search facilities among other features.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`less` 命令无疑更强大，允许用户通过多个键盘组合来浏览 `loremipsum.txt` 文件，还提供了搜索功能等其他特性。'
- en: Searching for files by name and/or extension
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按名称和/或扩展名搜索文件
- en: 'When we have large number of files available for viewing, sometimes we need
    to find a file among many without using the GUI searching tools or provide a better
    set of granular filters to reduce returned results. To search on the command line,
    there are a few facilities/commands we can use:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有大量文件需要查看时，有时需要在众多文件中找到一个文件，而不使用图形界面搜索工具，或者提供更好的细粒度筛选器以减少返回的结果。要在命令行中搜索，有几个工具/命令可以使用：
- en: '`locate` (also a sibling of the `updatedb` command): Used to find files more
    efficiently using an index of files'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locate`（也是 `updatedb` 命令的兄弟命令）：用于通过文件索引更高效地查找文件'
- en: '`find`: Used to find files with specific attributes, extensions, and even names
    within a specific directory'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`：用于在特定目录中查找具有特定属性、扩展名甚至名称的文件'
- en: 'The `find` command is far more suitable for the command line and widespread
    (often being on embedded devices), but the `locate` command is a common facility
    for use on desktops, laptops, and servers. Locate is far more simpler and involves
    recursively indexing all of the files it is configured to keep track of and it
    can generate very quick file listings. The file index can be updated using the
    following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令更适合用于命令行，并且广泛应用（通常在嵌入式设备上），而 `locate` 命令则是桌面、笔记本和服务器常用的工具。Locate 要简单得多，它通过递归索引所有配置跟踪的文件，并且能够快速生成文件列表。文件索引可以通过以下命令更新：'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Updating the database for the first time or after large amounts of files have
    been created, moved, or copied may result in longer than average times to update
    the database. One particular mechanism to keep the database frequently up to date
    automatically is through the use of **cron scheduler**. More about this topic
    will be covered later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次更新数据库，或者在大量文件被创建、移动或复制后，更新数据库的时间可能会长于平均时间。保持数据库自动频繁更新的一种特定机制是通过使用 **cron
    调度器**。更多关于此主题的内容将在后续介绍。
- en: The `locate` command can also be used to test for the existence of a file before
    reporting its location (the database may be out of date), and also limit the number
    of entries returned.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`locate` 命令也可以在报告文件位置之前测试文件是否存在（数据库可能已经过时），并且可以限制返回的条目数量。'
- en: 'As noted, `find` does not have a fancy database, but it does have a number
    of user configurable flags, which can be passed to it at the time of execution.
    Some of the most commonly used flags used with the `find` command are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`find` 没有一个复杂的数据库，但它有许多用户可配置的标志，这些标志可以在执行时传递给它。一些与 `find` 命令一起使用的常用标志如下：
- en: '`-type`: This is used to specify the type of file, which can be either file
    or directory'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-type`：用于指定文件类型，可以是文件或目录'
- en: '`-delete`: This is used to delete files, but may not be present, which means
    that `exec` will be required'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-delete`：用于删除文件，但可能不可用，这意味着需要使用 `exec`'
- en: '`-name`: This is used to specify searching by name functionality'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-name`：用于指定按名称搜索功能'
- en: '`-exec`: This is used to specify what else to do upon match'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-exec`：用于指定匹配后的操作'
- en: '`-{a,c,m}time`: This is used to search for things such as time of access, creation,
    and modification'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-{a,c,m}time`：用于查找访问、创建和修改时间等信息'
- en: '`-d, -depth`: This is used to specify the depth searching may delve recursively
    into'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d, -depth`：用于指定搜索的递归深度'
- en: '`-maxdepth`: This is used to specify the maximum depth per recursion'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-maxdepth`：用于指定每次递归的最大深度'
- en: '`-mindepth`: This is used to specify the minimum depth when recursively searching'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mindepth`：用于指定递归搜索时的最小深度'
- en: '`-L`, `-H`, `-P`: In order, `-L` follow symbolic links, `-H` does not follow
    symbolic links except in specific cases, and `-P` never follows symbolic links'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-L`, `-H`, `-P`：按顺序，`-L` 跟随符号链接，`-H` 除特定情况外不跟随符号链接，`-P` 永远不跟随符号链接'
- en: '`-print`, `-print0`: These commands are used to print the name of the current
    file on a standard output'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-print`, `-print0`：这些命令用于打印当前文件的名称到标准输出'
- en: '`!`, `-not`: This is used to specify logical operations such as match everything,
    but not on this criteria'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!`, `-not`：用于指定逻辑操作，例如匹配所有文件，但不符合此标准'
- en: '`-i`: This is used to specify user interaction on a match such as -`iname test`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`：用于指定在匹配时与用户的交互，如 `-iname test`'
- en: Please be aware that your platform may not support all of GNU find's features.
    This may be the case with limited shells for embedding, resource constraints,
    or security reasons.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你的平台可能不支持 GNU find 的所有功能。这可能是由于嵌入式系统的限制、资源约束或安全原因。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Besides having a terminal open, several large text files are needed for this
    recipe. If you have some already, great; if not, install the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打开终端，还需要几个大文本文件来完成这个教程。如果你已经有了一些，太好了；如果没有，可以安装以下文件：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If a file is not found using the `locate` command, the database might be simply
    out of date and needs to be re-ran. It is possible that `updatedb` is also not
    indexing partitions such as those contained on removable media (USB sticks), and
    the file may be present there instead of the regular system partitions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `locate` 命令找不到文件，数据库可能只是过时了，需要重新运行。也可能是 `updatedb` 没有索引如可移动媒体（如 USB 闪存）的分区，文件可能存在于那里，而不是常规系统分区。
- en: 'In preparation for this recipe, be aware that two concepts were inadvertently
    introduced: `git` and `manpages.` Manpages are among one of the oldest forms of
    help documentation available in Linux, and git is a version control system that
    simplifies management, versioning, and distribution of files such as code. Knowing
    how to use either is certainly beneficial, but beyond the scope of this book.
    For more information about git, check out another Packt book: *GIT Version Control
    Cookbook*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在为这个教程做准备时，注意到两个概念不经意间被介绍了：`git` 和 `manpages`。`manpages` 是 Linux 中最古老的帮助文档之一，而
    git 是一个版本控制系统，它简化了文件（如代码）的管理、版本控制和分发。了解如何使用它们肯定是有益的，但超出了本书的范围。如需了解更多关于 git 的信息，可以参考
    Packt 另一部书籍：*GIT 版本控制实用手册*。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open a terminal and run the following commands in order to understand the `locate`
    command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端，运行以下命令以理解 `locate` 命令：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, run the following commands to demonstrate some of the power of `find`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令来演示 `find` 的一些强大功能：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we can chain the `find` commands together with `&&` and ultimately perform
    an `exec` instead of piping the output to another process, command, or script.
    Try the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `&&` 将 `find` 命令链在一起，最终执行 `exec`，而不是将输出传递给另一个进程、命令或脚本。尝试以下命令：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, one of the most common uses of find is to delete files using either
    the built-in `-delete` flag or by using `exec` combined with rm `-rf`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`find` 最常见的用途之一是删除文件，可以使用内建的 `-delete` 标志，或者通过 `exec` 与 `rm -rf` 结合使用：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Repeat after me—"*locate is simple* and needs to be updated, `find` works when
    in a bind, but powerful and cryptic and *can break things*." Lets continue and
    begin with the explanations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 跟我重复—"*locate 很简单*，但需要更新，`find` 在困境中有效，但功能强大且晦涩，*可能会破坏系统*。" 让我们继续，并开始讲解：
- en: 'As mentioned previously, the `locate` command is a relatively simple search
    tool that uses a database as a backend, which contains an indexed list of all
    of the files for quick and efficient searches. Locate is not real-time unlike
    the `find` command, which searches everything as it exists at the time of execution
    (depending on the parameters provided to find). Locating `stdio.h` will produce
    several results depending on your system. However, when we run locate again, it
    does not know or contain any information regarding the `/usr/filethatlocatedoesntknow.txt`
    and `/usr/filethatlocatedoesntknow2.txt` files. Running `updatedb` will re-index
    the files and then using the `locate` command will return the appropriate results.
    Notice that locate works with partial names or full path matching:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，`locate` 命令是一个相对简单的搜索工具，它使用数据库作为后端，该数据库包含所有文件的索引列表，便于快速高效地进行搜索。与 `find`
    命令不同，`locate` 不是实时的，`find` 命令会搜索在执行时存在的所有内容（具体取决于提供给 `find` 的参数）。在定位 `stdio.h`
    时，结果会根据你的系统不同而有所不同。然而，当我们再次运行 `locate` 时，它并不了解或包含关于 `/usr/filethatlocatedoesntknow.txt`
    和 `/usr/filethatlocatedoesntknow2.txt` 文件的信息。运行 `updatedb` 会重新索引文件，之后使用 `locate`
    命令将返回相应的结果。注意，`locate` 支持部分名称或完整路径匹配：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the second step, we are introduced to some of the amazing functionality provided
    by the `find` command.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，我们介绍了 `find` 命令提供的一些惊人功能。
- en: Again, be aware that using `find` for operations such as deletion can break
    your system if not handled appropriately or if the input isn't carefully monitored
    and filtered.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，使用 `find` 执行如删除操作等可能会破坏你的系统，如果没有适当处理或没有仔细监控和过滤输入。
- en: 'At a minimum, the `find` command is executed this way: `$ find ${START_SEARCH_HERE}
    ${OPTIONAL_PARAMETERS ...}`. In the first use of the find command, we begin searching
    within our user''s home directory (`${HOME}` environment variable), and then use
    a wild card to look for **hidden files** that begin with a `.`.Finally, we use
    `-ls` to create a file listing. This is not by accident as you may have observed;
    you can create files that are absent upon first inspection in the GUI''s file
    explorer (especially in your user''s home directory) or on the console (for example,
    unless you use the `ls` command with the `-a` flag). In the next command, we use
    `find -type d` to search for a directory named `.git`. Then, we search for files
    that match either `*.sh` or `*.txt` using a special notation for find: `-type
    f \( -name "*.sh" -o -name "*.txt" \).` Notice the forward slash `\` and then
    the parenthesis `(`. We can then specify multiple name matching arguments using
    `-o -name "string"`.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少，`find` 命令应按以下方式执行：`$ find ${START_SEARCH_HERE} ${OPTIONAL_PARAMETERS ...}`。在第一次使用
    `find` 命令时，我们从用户的主目录（`${HOME}` 环境变量）开始搜索，然后使用通配符查找以 `.` 开头的**隐藏文件**。最后，我们使用 `-ls`
    来创建文件列表。这并非偶然，正如你可能已经观察到的那样；你可以创建在 GUI 文件浏览器中首次查看时缺失的文件（特别是在用户的主目录中）或在控制台中（例如，除非你使用带有
    `-a` 标志的 `ls` 命令）。在接下来的命令中，我们使用 `find -type d` 来查找名为 `.git` 的目录。接着，我们使用特殊符号 `-type
    f \( -name "*.sh" -o -name "*.txt" \)` 来查找与 `*.sh` 或 `*.txt` 匹配的文件。注意正斜杠 `\` 和括号
    `(`。我们可以使用 `-o -name "string"` 来指定多个名称匹配参数。
- en: 'In the third step, we use find to search for subdirectories using `-type d`
    that are often present inside of cloned or exported git-related directories. We
    can chain the `find` commands together using this format: `$ cmd 1 && cmd2 &&
    cmd3 && ...`. This guarantees that if the proceeding command evaluates to true,
    then the next will execute and so on. Then, we introduce the `-exec` flag, which
    is used to execute another command once a match has been found. In this case,
    we search for all files and then use grep immediately to search within the file.
    Notice the `{} +` at the end of the `grep`. This is because `{}` will be replaced
    with find''s returned results. The `+` character delimits the end of the `exec`
    command, and appends the results so that `rm -rf` will be executed less times
    than the total number of files found/matched.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三步中，我们使用 `find` 来查找子目录，使用 `-type d`，这些子目录通常出现在克隆或导出的 git 相关目录中。我们可以按照如下格式将
    `find` 命令链式连接起来：`$ cmd 1 && cmd2 && cmd3 && ...`。这样可以确保如果前面的命令返回为 true，接下来的命令将会执行，依此类推。然后，我们引入了
    `-exec` 标志，用于在找到匹配项后执行另一个命令。在这种情况下，我们首先查找所有文件，然后立即使用 `grep` 来在文件中进行搜索。请注意 `grep`
    后面的 `{} +`。这是因为 `{}` 会被 `find` 返回的结果替换。`+` 字符表示 `exec` 命令的结束，并将结果追加，使得 `rm -rf`
    执行的次数比找到/匹配的文件总数少。
- en: In the final step, we delete files using two methods. The first method using
    the `-delete` flag may not be available on all distributions or implementations
    of find, but upon match, it will delete the file. It is more efficient than executing
    the sub process `rm` on large numbers of files. Secondly, using `-exec rm -rf
    {} \;`, we can delete files found easily and in a portable way. However, there
    is a difference between `\;` and `+` and the difference is that in the `\;` version,
    `rm -rf` is executed for each file found/matched. Be careful with this command
    as it is not interactive.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，我们使用两种方法来删除文件。第一种方法使用 `-delete` 标志，可能并非所有的 `find` 实现或版本都支持，但一旦匹配，它将删除文件。与对大量文件执行子进程
    `rm` 相比，它更高效。其次，使用 `-exec rm -rf {} \;`，我们可以以一种便捷且可移植的方式轻松删除找到的文件。然而，`\;` 和 `+`
    之间是有区别的，区别在于使用 `\;` 时，`rm -rf` 会对每个找到/匹配的文件执行一次。使用这个命令时要小心，因为它不是交互式的。
- en: Creating a diff of two files and patching
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建两个文件的 diff 并进行补丁操作
- en: 'In what case should you know what a diff is? Or a patch? In the Linux world,
    it is a way to determine the differences between files and also to solve problems
    at the OS level (especially if you have a broken driver in the Linux kernel).
    However, for the purposes of a cookbook, diffs and patches useful for a couple
    of main things:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下你需要知道什么是 diff？或者补丁（patch）？在 Linux 世界中，它是一种确定文件差异的方法，也用于解决操作系统层面的问题（特别是如果你在
    Linux 内核中遇到坏的驱动程序）。然而，对于一本食谱（cookbook）来说，diff 和补丁主要有以下几个用途：
- en: When determining whether a particular script or configuration file has modifications
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当确定某个脚本或配置文件是否被修改时
- en: When plotting differences between versions, or migrating data between an old
    to new script, and so on
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当绘制版本之间的差异，或者将数据从旧脚本迁移到新脚本时
- en: 'So, what is a **diff** or **differential**? A diff is the output that describes
    the differences between two files (file A and file B). The file A is the source,
    and the B file is the assumed to be modified file. If no diff output is created,
    then A and B are either empty or there are no differences. Diffs in a unified
    format typically look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是**差异（diff）**或**差分（differential）**？差异是描述两个文件（文件A和文件B）之间差异的输出。文件A是源文件，文件B是假定被修改的文件。如果没有生成差异输出，那么文件A和B要么为空，要么没有差异。统一格式的差异通常看起来像这样：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are several formats of diffs, but the unified format is among the most
    popular (and used by the FOSS crowd). It contains information about both files
    (A and B), the line numbers and counts in each, and the content added or changed.
    If we look at the preceding sample, we can see that in the original, the string
    `abcdef` is removed `(-)` and then re-added `(+)` as `abcdZZZ`. And there is the
    further addition of a new line containing `789aaa` (which can also be seen here:
    `@@ -1,3 +1,4 @@`).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种格式的差异，但统一格式是最流行的格式之一（并且被FOSS（自由和开源软件）社区广泛使用）。它包含关于两个文件（A和B）的信息，行号及每个文件中的行数，以及添加或更改的内容。如果我们查看前面的示例，我们可以看到在原始文件中，字符串`abcdef`被删除`(-)`，然后作为`abcdZZZ`重新添加`(+)`。此外，还添加了一个新行，包含`789aaa`（在这里也可以看到：`@@
    -1,3 +1,4 @@`）。
- en: A patch is a unified diff that contains changes to one or more files that are
    to be applied in a specific order or method, hence the concept of patching being
    the process of applying a patch (which contains diff information). A patch can
    consist of several diffs concatenated together as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁是一个统一差异（unified diff），包含对一个或多个文件的更改，这些更改需要按照特定的顺序或方法应用，因此补丁的概念是应用一个补丁（其中包含差异信息）的过程。一个补丁也可以由几个差异串联在一起组成。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Besides having a terminal open, these two utilities need to be installed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打开终端，还需要安装这两个工具：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, let''s create a fake configuration file that''s copied from a real one:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个假的配置文件，它是从一个真实文件复制的：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open `updatedb-v2.conf` and change the contents to look like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`updatedb-v2.conf`并将内容更改为如下所示：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the event that your `updatedb-v2.conf` looks drastically different, add `/media
    /mount` to the `PRUNEPATHS` variable. Notice that they are separated by a space.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的`updatedb-v2.conf`文件看起来有很大不同，请将`/media /mount`添加到`PRUNEPATHS`变量中。注意它们之间用空格分隔。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open a terminal, and run the following commands in order to understand the
    `diff` command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并运行以下命令以了解`diff`命令：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At this point, only the diff information has been output to the console''s
    standard out and a patch file has not been created. To create the actual patch
    file, execute the following command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，只有差异信息被输出到控制台的标准输出中，尚未创建补丁文件。要创建实际的补丁文件，请执行以下命令：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Patches can be found in many forms, but they usually have the `.patch` extension
    and are preceded by a number and a human readable name.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁可以有很多种形式，但通常它们具有`.patch`扩展名，并且在前面有一个数字和一个易于理解的名称。
- en: 'Now, before applying a patch, it can also be tested to ensure that the results
    are as expected. Try the following commands:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在应用补丁之前，还可以进行测试，以确保结果符合预期。尝试以下命令：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s see what happens when patches fail to apply using the following commands:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看使用以下命令时，当补丁应用失败会发生什么：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Repeat after me—"*locate is simple and needs to be updated, find works when
    in a bind, but powerful and cryptic and can break things*." Let''s continue and
    begin with the explanations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 跟我重复——“*locate简单且需要更新，find在遇到问题时有效，但强大且难懂，且可能会破坏一些东西*。”接下来，我们继续并开始解释：
- en: 'The first `diff` command outputs the changes in the simple diff format. However,
    in the second instance when running the diff command, we use the `-urN` flag(s).
    `-u` stands for unified format, `-r` stands for recursive, and `-N` stands for
    a new file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个`diff`命令以简单的差异格式输出更改。但是，在第二个运行`diff`命令时，我们使用了`-urN`标志。`-u`表示统一格式，`-r`表示递归，`-N`表示新文件：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we have created a patch by redirecting standard out to the `001-myfirst-patch-for-updatedb.patch`
    file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经通过将标准输出重定向到`001-myfirst-patch-for-updatedb.patch`文件来创建了一个补丁：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we have created a modified version of `~/updatedb-v3`, notice anything
    from the dry-run? Ignoring that `/etc/updatedb.conf` only has read-only permissions
    (we are just using it for the sake of example as dry-run doesn''t alter the contents
    anyway), we can see that HUNK #1 is applied successfully. A **hunk** stands for
    a section of the diff, and you can have several for one file or many files inside
    of the same patch. Did you notice that the line numbers didn''t match exactly
    as those in the patch? It still applied the patch as it knew enough information
    and **fudged** the data to match so that it would apply successfully. Be aware
    of this functionality when dealing with large files, which may have similar match
    criteria:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在我们已经创建了`~/updatedb-v3`的修改版本，注意到干运行时的任何情况吗？忽略`/etc/updatedb.conf`只有只读权限（我们只是为了举例而使用它，因为干运行本身不会改变内容），我们可以看到HUNK
    #1已经成功应用。**hunk**表示差异的一个部分，你可以为一个文件或多个文件拥有多个hunk。在补丁中的行号没有完全匹配吗？它仍然应用了补丁，因为它知道足够的信息，并**修正**了数据，使其匹配以便成功应用。在处理大文件时要注意这种功能，这些文件可能有相似的匹配标准：'
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we attempt to apply the patch to a file on a file that does not match, it
    will fail, like in the following output (if `--dry-run` is specified). If `--dry-run`
    is not specified, the failure will be stored in a reject file as is noted in this
    line: `1 out of 1 hunk FAILED -- saving rejects to file /home/rbrash/fileA.txt.rej`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试将补丁应用到与文件不匹配的文件上，它将失败，像下面的输出所示（如果指定了`--dry-run`）。如果没有指定`--dry-run`，失败将被存储在一个拒绝文件中，正如这一行所述：`1
    out of 1 hunk FAILED -- saving rejects to file /home/rbrash/fileA.txt.rej`：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating symbolic links and using them effectively
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建符号链接并有效使用它们
- en: 'Symbolic links mean shortcuts, right? Well, if you ever heard that explanation,
    it is only partially correct and they are present on most modern OS. In fact,
    there are two kinds of symbolic links when thinking in terms of files: hard and
    soft:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接意味着快捷方式，对吧？如果你曾听过这个解释，它只是部分正确，它们出现在大多数现代操作系统中。事实上，从文件的角度来看，符号链接有两种类型：硬链接和软链接：
- en: '| **Hard Links** | **Soft Links** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **硬链接** | **软链接** |'
- en: '| Only link to files | Can link to directories and files |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 仅链接文件 | 可以链接目录和文件 |'
- en: '| Link to contents on same disk | Can reference files/folders across disks
    or networks |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 本地磁盘内的内容链接 | 可以跨磁盘或网络引用文件/文件夹 |'
- en: '| Reference inode/physical locations | If the original file is deleted, the
    hard link will remain (in own inodes) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 引用inode/物理位置 | 如果原始文件被删除，硬链接将保留（在自己的inode中） |'
- en: '| Moving a file will still allow the link to work | Links don''t follow the
    reference file if moved |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 移动文件仍然允许链接工作 | 如果链接文件被移动，链接将无法跟随原文件 |'
- en: A soft link will most likely match your expectations of a shortcut and the behavior
    might not be very surprising, but what use is a hard link? One of the most prominent
    cases of when to use a hard link is when you don't want to break a link by moving
    the file it points to! A soft link is clearly more flexible and can work across
    file systems, which is unlike hard links, but soft links won't work if a file
    is moved.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 软链接最可能符合你对快捷方式的预期，行为可能不会让你感到意外，但硬链接有什么用呢？使用硬链接的一个突出例子是当你不想通过移动它指向的文件来破坏链接时！软链接显然更加灵活，可以跨文件系统工作，而硬链接则不同，但如果文件被移动，软链接将无法工作。
- en: Besides creating shortcuts, you can do neat tricks like renaming `argv[0]` when
    using symbolic links. The Busybox shell is an example of that, where it contains
    **applets** that are executed by a symlink that points to `./busybox`. For example,
    `ls` points to the same binary as `cd`! All of them point to `./busybox`. This
    is a neat way to save space and improve run-time flags without the use of flags.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建快捷方式外，你还可以做一些巧妙的操作，比如在使用符号链接时重命名`argv[0]`。Busybox shell 就是一个例子，它包含通过指向`./busybox`的符号链接执行的**applets**。例如，`ls`指向与`cd`相同的二进制文件！它们都指向`./busybox`。这是一种巧妙的方法，可以节省空间并在不使用标志的情况下提高运行时标志的效率。
- en: Soft links are also used in the `/usr/lib` or `/lib` folders for shared `librarys`.
    In fact, symlinks are very useful for aliasing paths or getting software to work
    with hard-coded paths that are inside of the binaries themselves.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 软链接也用于`/usr/lib`或`/lib`文件夹中的共享`library`。事实上，符号链接对于为路径创建别名或让软件与二进制文件中硬编码的路径一起工作非常有用。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open a terminal, and create the `whoami.sh` script:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，创建`whoami.sh`脚本：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Execute `whoami.sh` and observe what has happened:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`whoami.sh`并观察发生了什么：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, create a soft link to `whoami.sh` using the `ln` command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`ln`命令创建一个指向`whoami.sh`的软链接：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, run `ls` `-la`. Notice any differences?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行`ls` `-la`。注意有任何不同吗？
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On to hard links, which are created this way using `ln`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是硬链接，它是通过使用`ln`命令以这种方式创建的：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, let''s look at the difference in results when running the commands:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下运行命令时结果的不同：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step one, we created `whoami.sh`. It is similar to the `whoami` command,
    but different because we do not print the `$USER` variable, but rather argument
    `0` `(arg0`, as its typically known) or `$0`. In laymen's terms, we are printing
    out the name used to execute the code or script.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了`whoami.sh`。它类似于`whoami`命令，但不同之处在于，我们并没有打印`$USER`变量，而是打印参数`0`（通常被称为`arg0`）或`$0`。通俗地说，我们打印的是用于执行代码或脚本的名称。
- en: 'When we execute `whoami.sh`, it prints to the console:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`whoami.sh`时，它会打印到控制台：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To create a symbolic soft link, we use `ln` with the `-s` flag (for symbolic
    mode). The `ln` command expects to be executed in this way: `$ ln -s originalFileToBeLinkedTo
    newFileToLinkToOldFile`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建符号软链接，我们使用带有`-s`标志（符号模式）的`ln`命令。`ln`命令需要按以下方式执行：`$ ln -s 原始文件路径 新文件路径`。
- en: As we can see in the following code, executing `ghosts-there-be.sh` runs the
    code in `whoami.sh`, but `arg0` is `ghosts-there-be.sh`. Then, when the `ls` command
    is ran with the `-l -a` flags (`-la`), we can see the soft link to `whoami.sh`.
    Notice the small size of 9 bytes!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在以下代码中看到的，执行`ghosts-there-be.sh`会运行`whoami.sh`中的代码，但`arg0`是`ghosts-there-be.sh`。然后，当运行带有`-l
    -a`标志（`-la`）的`ls`命令时，我们可以看到指向`whoami.sh`的软链接。注意它只有9字节这么小！
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we create a hard link by using the `ls` command without the `-s` flag.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过不带`-s`标志的`ls`命令创建一个硬链接。
- en: 'The hard link, `real-ghosts-there-be.sh`, runs the same content as `ghosts-there-be.sh`,
    but points to the actual contents of `whoami.sh`, even if it is moved and renamed
    as `nobody.sh`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 硬链接`real-ghosts-there-be.sh`执行与`ghosts-there-be.sh`相同的内容，但指向`whoami.sh`的实际内容，即使它被移动并重命名为`nobody.sh`：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Crawling filesystem directories and printing a tree
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爬取文件系统目录并打印树状结构
- en: At this point, we already know about the commands locate, find, and grep (plus
    regular expressions), but what about if we wanted to create our own naive implementation
    of a directory crawler/scraper/indexer? It certainly won't be the fastest or have
    optimizations, but we can use recursive functionality and file tests to print
    a tree-like structure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了locate、find和grep（以及正则表达式），但如果我们想要创建一个简单的目录爬虫/抓取器/索引器呢？它肯定不是最快的，也没有优化，但我们可以使用递归功能和文件测试来打印树状结构。
- en: This exercise is a bit of a fun exercise and certainly recreates the proverbial
    "wheel". This can be easily done by running the tree command, however, this will
    be useful in an upcoming exercise when we'll be building arrays of arrays for
    files.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习是一个有趣的练习，当然也算是在重做“轮子”。通过运行tree命令可以轻松做到这一点，然而，这在接下来的练习中将会有用，我们将构建文件的数组数组。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Besides having a terminal open, let''s create some test data:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打开终端，让我们创建一些测试数据：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Open a terminal and create the `mytree.sh` script:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并创建`mytree.sh`脚本：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In your terminal, now run:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端中，现在运行：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The creation of `mytree.sh` is a trivial task, but the logic inside follows
    recursive functions. There is also the concept of `${CURRENT_LVL}`, which is used
    to produce the number of periods (or levels) deep the script is from its original
    starting point: **parentdir**. In each directory, we create a for loop to test
    each file/directory inside of it. The logic tests whether the entry is either
    a file or a director. If it is a directory, we increment `${CURRENT_LVL}` and
    then **recursively** execute the **same** logic inside of the `recursive_tree`
    function until done and then return. If the logic is a file, we merely print out
    and **continue**. The `tab_creator` function makes the variable string for the
    periods based on `${CURRENT_LVL}` and concatenation.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`mytree.sh`是一个微不足道的任务，但其中的逻辑遵循递归函数。还有`${CURRENT_LVL}`的概念，它用于表示脚本从最初起点**parentdir**开始的深度（即期间的数量或层级）。在每个目录中，我们创建一个for循环来测试其中的每个文件/目录。逻辑会测试该条目是文件还是目录。如果是目录，我们递增`${CURRENT_LVL}`，然后**递归**地执行`recursive_tree`函数中的**相同**逻辑，直到完成并返回。如果是文件，我们只是打印出来并**继续**。`tab_creator`函数根据`${CURRENT_LVL}`和拼接生成表示期间的变量字符串。
- en: 'Executing the script should produce an output similar to the following, but
    notice how the script remembers how many layers deep it might be, and that the
    directories are shown with a `\_` instead of `|_`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本时应产生类似如下的输出，但请注意脚本会记住它可能有多少层深度，并且目录显示时使用的是`\_`而不是`|_`：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finding and deleting duplicate files or directories
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找和删除重复的文件或目录
- en: 'At one point, we had already talked about checking to see if strings inside
    of a file were unique and if we could sort them, but we haven''t yet performed
    a similar operation on files. However, before diving in, let''s make some assumptions
    about what constitutes a duplicate file for the purpose of this recipe: a duplicate
    file is one that may have a different name, but the same contents as another.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经我们已经讨论过检查文件中字符串是否唯一以及是否可以对其进行排序，但我们还没有对文件进行类似的操作。然而，在深入之前，让我们对什么构成重复文件做一些假设：重复文件是指可能有不同名称，但内容与其他文件相同的文件。
- en: 'One way to investigate the contents of a file would be to remove all white
    space and purely check the strings contained within, or we could merely use tools
    such as **SHA****512sum** and **MD****5sum** to generate a unique hash (think
    unique string full of gibberish) of the contents of the files. The general flow
    would be as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调查文件内容的一种方法是移除所有空白字符，仅检查文件中包含的字符串，或者我们也可以仅使用**SHA**/**512sum**和**MD**/**5sum**等工具生成文件内容的唯一哈希值（可以理解为充满乱码的唯一字符串）。整体流程如下：
- en: Using this hash, we can compare the hash against a list of hashes already computed.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个哈希值，我们可以将其与已经计算的哈希值列表进行比较。
- en: If the has matches, we have seen the contents of this file before and so we
    can delete it.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果哈希值匹配，我们已经见过这个文件的内容，因此可以将其删除。
- en: If the hash is new, we can record the entry and move onto calculating the hash
    of the next file until all files have been *hashed.*
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果哈希值是新的，我们可以记录该条目并继续计算下一个文件的哈希值，直到所有文件都被*哈希化*。
- en: Using a hash does not require you to know how the mathematics work, but rather
    to be aware of how it's supposed to work IF it is a secure implementation and
    has enough possibilities to make finding a duplicate computationally unfeasible.
    Hashes are supposed to be one way, which means that they are different from encryption/decryption
    so that once a hash has been created, it should be impossible to determine the
    original input from the hash itself.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希不需要你了解数学是如何运作的，而是要了解它在安全实现的情况下应该如何工作，并且要有足够的可能性使得找到重复项在计算上不可行。哈希应该是单向的，这意味着它不同于加密/解密，因此一旦哈希值被创建，就不应该能够从哈希值本身确定原始输入。
- en: MD5sums are considered completely insecure (although useful where security may
    be less needed), and SHA1/2 are considered to be potentially on their way out
    of popularity with the use of SPONGE algorithms in SHA3 (use SHA3 where possible).
    For more information, please see the [NIST guidelines](https://csrc.nist.gov/Projects/Hash-Functions).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: MD5哈希被认为是完全不安全的（尽管在安全要求较低的场合仍有其用途），而SHA1/2被认为可能会随着SHA3中的SPONGE算法的使用而逐渐失宠（在可能的情况下使用SHA3）。更多信息，请参见[NIST指南](https://csrc.nist.gov/Projects/Hash-Functions)。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open a terminal and create a data set consisting of several files with the
    `dsetmkr.sh` script:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并使用`dsetmkr.sh`脚本创建一个包含多个文件的数据集：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, before jumping into scripting, a core concept needs to be discussed regarding
    arrays and whether they are static or dynamic; knowing how an array implementation
    works at its core is a key principle if performance is an objective.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在开始编写脚本之前，需要讨论一个核心概念，即数组是静态的还是动态的；如果性能是目标，了解数组实现的核心原理是一个关键原则。
- en: Arrays can be really helpful, but the performance of a Bash script is often
    sub-par to that of a compiled program or even choosing a language with the appropriate
    data structures. In Bash, arrays are linked lists and dynamic, which means that
    if you resize the array, there isn't a massive performance penalty.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 数组非常有用，但Bash脚本的性能通常不如编译程序或选择具有适当数据结构的语言。在Bash中，数组是链表且是动态的，这意味着如果你调整数组的大小，不会有巨大的性能损失。
- en: For our purposes, we are going to create a dynamic array and once the array
    becomes quite large, it will be the searching of the array which becomes the performance
    bottleneck. This naive iterative approach usually works well up to an arbitrary
    amount (let's say, `N`), and at which the benefits of using another mechanism
    may outweigh the simplicity of the current approach. For those who want to know
    more about data structures and the performance of them, check out Big O notation
    and complexity theory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将创建一个动态数组，一旦数组变得相当大，搜索该数组将成为性能瓶颈。这种简单的迭代方法通常在一个任意的数量（假设为`N`）之前效果良好，在这个点上，使用其他机制的好处可能会超过当前方法的简单性。对于那些想了解更多数据结构及其性能的人，可以查阅大O符号和复杂度理论。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到……
- en: Open a terminal, and create the `file-deduplicator.sh` script.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并创建`file-deduplicator.sh`脚本。
- en: 'The following is a code snippet of the script:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本的代码片段：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the `setup` command if not already: run `$ bash dsetmkr.sh` and then run
    `$ bash ./file-deduplicator.sh`. Enter `files_galore/` at the prompt and press
    *Enter*:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还未执行，请运行`setup`命令：运行`$ bash dsetmkr.sh`，然后运行`$ bash ./file-deduplicator.sh`。在提示符处输入`files_galore/`并按*Enter*键：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Review the results and verify the contents of `files_galore`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查结果并验证`files_galore`的内容。
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Before getting started, a proceeding note of caution: the `file-deduplicator.sh`
    script deletes duplicate files in the directory it is targeted at.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请注意：`file-deduplicator.sh`脚本会删除它所针对目录中的重复文件。
- en: 'Getting started (especially using the `dsetmkr.sh` script), we will produce
    a directory called `files_galore` that also contains several files: four are unique
    and three contain duplicate content:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始时（特别是使用`dsetmkr.sh`脚本），我们将生成一个名为`files_galore`的目录，并且该目录包含几个文件：四个是唯一的，三个包含重复的内容：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The study of cryptography, security, and mathematics are all very interesting
    and broad information domains! Hashes have a multitude of other uses such as integrity
    checking of files, lookup values to find data quickly, unique identifiers, and
    much more.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学、安全性和数学的研究都是非常有趣且广泛的信息领域！哈希值有许多其他用途，例如文件的完整性检查、查找值以快速找到数据、唯一标识符等。
- en: 'When you run `file-deduplicator.sh`, it begins by asking the user for input
    using `read` and then it prints out four different values with seemingly random
    strings of characters. *Random* looking is absolutely correct—they are SHA512
    hash sums! Each string is the sum of the contents inside of it. Even if the contents
    are even slightly different (for example, one bit has been flipped to a `1` instead
    of a `0`), then a totally different hash sum will be produced. Again, this bash
    script leverages a foreign concept of arrays (using a global array variable meaning
    accessible everywhere in the script) and hash sums using the **SHA512sum** tool
    combined with **awk** to retrieve the correct values. This script is not recursive
    though, and only looks at the files inside of `files_galore` to generate a list
    of files, a hash for each one, and search an array containing all *known* hashes.
    If a hash is unknown, then it is a new file and is inserted into the array for
    storage. Otherwise, if a hash is seen twice, the file is deleted because it contains
    DUPLICATE content (even if the file name is different). There is another aspect
    here, and that is the use of return values as strings. As you may remember, return
    only can return numeric values:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行`file-deduplicator.sh`时，它会首先通过`read`命令向用户请求输入，然后打印出四个不同的值，显示看似随机的字符字符串。*看似随机*是完全正确的——它们是SHA512哈希值！每个字符串是其内部内容的哈希值。即使内容仅有微小的差别（例如，一个比特从`0`翻转成`1`），也会生成一个完全不同的哈希值。再次强调，这个bash脚本利用了数组这一外部概念（使用全局数组变量意味着在脚本的任何地方都可以访问），并结合**SHA512sum**工具和**awk**来检索正确的值。这个脚本并不是递归的，它只查看`files_galore`中的文件，以生成一个文件列表，每个文件一个哈希值，并搜索一个包含所有*已知*哈希值的数组。如果一个哈希值是未知的，那么它代表一个新文件，并会被插入到数组中进行存储。否则，如果一个哈希值出现了两次，文件将被删除，因为它包含了重复的内容（即使文件名不同）。还有一个方面是使用返回值作为字符串。如你所记得，返回值只能返回数字值：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After executing the operation, we can see that the `files_galore` directory
    only contains four files out of the original seven. The duplicate data is now
    removed!
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行操作后，我们可以看到`files_galore`目录中只剩下四个文件，原本的七个文件中的重复数据已被移除！
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Joining and splitting files at arbitrary positions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在任意位置连接和拆分文件
- en: 'Let''s not be shy! Who has tried to open a large file by accident or even intentionally
    with an application and it didn''t quite go as planned? I certainly have, and
    I have certainly seen the limitations such as the number of rows loaded in Excel,
    or OpenOffice calculator. In these cases, we use a handy tool that can split files
    at arbitrary points, such as the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要害羞！谁曾经因意外或故意使用应用程序打开一个大文件，结果没有按计划进行的？我肯定有过，而且我也确实见过一些限制，比如在Excel或OpenOffice计算器中加载的行数。在这些情况下，我们使用一个方便的工具，它可以在任意位置拆分文件，类似下面这样：
- en: Before X number of lines
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在X行之前
- en: Before Z number of bytes/chars
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Z字节/字符之前
- en: 'In this recipe, you will create a singe dual purpose script: a script that
    can use an input file and produce *split* or multiple files, and a second script
    to join files using a combining method. There are a few caveats when passing around
    string variables as they:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，你将创建一个具有双重用途的脚本：一个可以使用输入文件并生成*拆分*或多个文件的脚本，另一个是使用合并方法将文件合并的脚本。传递字符串变量时有一些注意事项：
- en: Can sometimes lose special characters such as new lines
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时可能会丢失特殊字符，如换行符
- en: (Binary) Should be handled by different tools than the usual commands on the
    command line
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （二进制文件）应该由与常规命令不同的工具处理
- en: 'This file also reuses the `getopts` parameter parsing we saw earlier in Chapter
    1, *Crash Course in Bash*, but it also introduces the `mktemp` command and the
    `getconf` command with the `PAGESIZE` parameter. `Mktemp` is a useful command
    because it can produce unique temporary files that reside in the `/tmp` directory,
    but can even produce unique files that follow a template (notice the `XXX`—this
    will be replaced with random values, but `uniquefile.` will remain):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件还重用了我们在第一章《Bash快速入门》中看到的`getopts`参数解析，但它还引入了`mktemp`命令和带有`PAGESIZE`参数的`getconf`命令。`Mktemp`是一个有用的命令，因为它可以生成位于`/tmp`目录中的唯一临时文件，甚至可以生成遵循模板的唯一文件（注意`XXX`——它会被替换为随机值，但`uniquefile.`将保持不变）：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Another useful command is the `getconf` programming utility, which is a standards
    compliant tool designed to fetch useful system variables. One in particular called
    `PAGESIZE` is useful to determine the size of memory in one block. Obviously,
    this is in very simplistic terms, but choosing the appropriate size to write data
    can be very beneficial performance-wise.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的命令是`getconf`编程工具，它是一个符合标准的工具，用于获取有用的系统变量。特别是其中一个叫做`PAGESIZE`的变量，它有助于确定内存的块大小。显然，这是非常简单的描述，但选择合适的大小来写入数据在性能上是非常有益的。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Besides having a terminal open, a single text file called `input-lines` needs
    to be created with the following content (one character on each line):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打开一个终端外，还需要创建一个名为`input-lines`的文本文件，文件内容如下（每行一个字符）：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, create a second file called `merge-lines` with the following content:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个名为`merge-lines`的文件，内容如下：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Open a terminal and create a script named `file-splitter.sh`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并创建一个名为`file-splitter.sh`的脚本。
- en: 'The following is the code snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码片段：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, run `file-splitter.sh` with this command and flags ( `-i`, `-t`, `-l`):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令和标志（`-i`，`-t`，`-l`）运行`file-splitter.sh`：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Review the output and see what the difference is with `-t size` and when `-l
    line` is used. What about when `-l 1` or `-l 100` is used? Remember to remove
    the split files using `$ rm input-lines.*`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 查看输出并观察`-t size`与`-l line`使用时的差异。当使用`-l 1`或`-l 100`时会有什么不同？记得使用`$ rm input-lines.*`删除拆分后的文件：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the next step, create another script called `file-joiner.sh`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，创建另一个名为`file-joiner.sh`的脚本。
- en: 'The following is the code snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码片段：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, run the script using this command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令运行脚本：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before proceeding, notice that the type option (`-t`) on `final-join.txt` ignores
    `\n` newlines when reading in characters one at a time. Read suffices for the
    purpose of this recipe, but the reader should be aware that read/cat are not the
    best tools for this type of work.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意，`final-join.txt`上的类型选项（`-t`）在一次读取字符时会忽略`\n`换行符。`read`足以满足本教程的需求，但读者应意识到，`read/cat`并不是这种工作类型的最佳工具。
- en: Creating the script was trivial and for the most part shouldn't look like it
    came from the planet Mars.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建这个脚本很简单，大部分情况下它看起来不会像是来自火星的作品。
- en: 'Running the `$ bash file-splitter.sh -i input-lines -t line -l 10` command
    should produce three files, all of which are input-lines {1,...,3}. The reason
    that there is three files is that if you used the same input, which is 22 lines
    long, it will produce three files (10+10+2). Using read and echo using a concatenated
    buffer (`${BUFFER}`), we can write to the file based on a specific criteria (provided
    by `-l`). If the **EOF** or end of file is met and the done loop is done, we need
    to write the buffer to the file because it may be under the threshold of the write
    criteria—this would result in lost/missing bytes in the last file created by the
    `splitter` script:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令`$ bash file-splitter.sh -i input-lines -t line -l 10`应该会生成三个文件，文件名为input-lines
    {1,...,3}。之所以有三个文件，是因为如果使用的是相同的输入，即22行数据，它会生成三个文件（10+10+2）。使用`read`和`echo`配合连接缓冲区（`${BUFFER}`），我们可以根据特定的标准（由`-l`提供）将数据写入文件。如果遇到**EOF**（文件结束）并且循环完成，我们需要将缓冲区写入文件，因为它可能低于写入标准的阈值——这会导致`splitter`脚本生成的最后一个文件中的字节丢失或缺失。
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Depending on the usage of the `-l` flag, the value of `1` will produce a file
    for every line, and the value of 100 will produce a single file because if fits
    under the threshold. Using the side-feature `-t size`, which can be used to split
    based on bytes, read has an unfortunate side effect: when we pass the buffer,
    it is altered and the new lines are missing. This sort of activity would be better
    if we used a tool such as `dd`, which is better for copying, writing, and creating
    raw data to files or devices.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`-l`标志的使用情况，值为`1`时会为每一行生成一个文件，值为100时则会生成一个单独的文件，因为它符合阈值要求。使用辅助功能`-t size`，可以根据字节进行拆分，但`read`命令有一个不幸的副作用：当我们传递缓冲区时，它会被修改，导致新行丢失。如果我们使用类似`dd`的工具，这类操作会更好，因为`dd`更适合复制、写入以及创建原始数据到文件或设备中。
- en: 'Next, we created the script called `file-joiners.sh`. Again, it used `getopts`
    and requires four input parameters: `-i originalFile -o`, `otherFileToMerge -f`,
    `finalMergedFile -w`, and `whereInjectTheOtherFile`. The script is simpler overall,
    but uses the `mktemp` command to create a temporary file which we can use as a
    storage buffer without modifying the originals. When we are finished, we can use
    the `mv` command to move the file from `/tmp` to the terminal''s current directory
    (`.`). The `mv` command can also be used to rename files and is usually faster
    than `cp` (not so much in this case) because a copy does not occur, rather just
    a renaming operation at the file system level.'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个名为`file-joiners.sh`的脚本。它同样使用了`getopts`，并需要四个输入参数：`-i originalFile
    -o`，`otherFileToMerge -f`，`finalMergedFile -w`，以及`whereInjectTheOtherFile`。该脚本相对简单，但使用了`mktemp`命令来创建一个临时文件，作为存储缓冲区，而不会修改原文件。当完成操作后，我们可以使用`mv`命令将文件从`/tmp`移动到终端当前目录（`.`）。`mv`命令也可以用于重命名文件，并且通常比`cp`命令更快（虽然在这个例子中差别不大），因为它不执行复制操作，而只是进行文件系统级的重命名。
- en: 'Catting `final-join.txt` should contain the following output:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`查看`final-join.txt`应该显示如下输出：
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Generating datasets and random files of various size
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成各种大小的数据集和随机文件
- en: Usually, data that mimics real-world data is always the best, but sometimes
    we need an assortment of files of various content and size for validation testing
    without delay. Imagine that you have a web server and it is running some sort
    of application that accepts files for storage. However, the files have a size
    limit being enforced. Wouldn't it be great to just *whip up* a batch of files
    in an instant?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模仿真实数据的数据总是最好的，但有时我们需要各种内容和大小的文件集合来进行验证测试，而不希望有任何延迟。想象一下，你有一个Web服务器，并且它正在运行某个应用程序，该应用程序接收文件进行存储。然而，文件的大小有限制。要是能够瞬间*搞定*一批文件，不是很棒吗？
- en: 'To do this, we can use some few file system features such as `/dev/random`
    and a useful program called `dd`. The `dd` command is a utility that can be used
    to convert and copy files (including devices due to Linux''s concept of everything
    is a file, more or less). It can be used in a later recipe to back up data on
    an SD card (remember your favorite Raspberry Pi project?) or to "chomp" through
    files byte by byte without losses. Typical minimal dd usage can be `$ dd if="inputFile"
    of="outputFile" bs=1M count=10`. From this command, we can see:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用一些文件系统功能，比如`/dev/random`和一个有用的程序`dd`。`dd`命令是一个用于转换和复制文件的工具（包括设备，因为在Linux中一切皆文件）。它可以在后续的教程中用于备份SD卡上的数据（记得你最爱的Raspberry
    Pi项目吗？），或者逐字节读取文件而不丢失数据。`dd`的典型最小用法为`$ dd if="inputFile" of="outputFile" bs=1M
    count=10`。从这个命令中，我们可以看到：
- en: '`if=`: Stands for input file'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if=`：表示输入文件'
- en: '`of=`: Stands for output file'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of=`：表示输出文件'
- en: '`bs=`: Stands for block size'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bs=`：表示块大小'
- en: '`count=`: Stands for numbers of blocks to be copied'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count=`：表示要复制的块数'
- en: Options `bs=` and `count=` are optional if you want to perform a 1:1 (pure duplicate)
    copy of a file because `dd` will attempt to use reasonably efficient parameters
    to provide adequate performance. The dd command also has a number of other options
    such as `seek=`, which will be explored later when performing low-level backups
    in another recipe. The count option is typically not needed as it's far more common
    to copy an entire file instead of a section (when performing backups).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要执行文件的纯复制（1:1），则选项`bs=`和`count=`是可选的，因为`dd`命令会尝试使用合理有效的参数来提供足够的性能。`dd`命令还具有许多其他选项，如`seek=`，将在另一个配方中介绍，用于执行低级备份时通常不需要count选项，因为通常复制整个文件而不是部分文件（在执行备份时）。
- en: '`/dev/random` is a device in Linux (hence the `/dev` path) which can be used
    to produce random numbers for use in your scripts or applications. There are also
    other `/dev` paths such as the console and various adaptors (for example, USB
    sticks or mice), all of which may be accessible, and gaining knowledge of them
    is recommended.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/random`是Linux中的一个设备（因此使用`/dev`路径），可用于生成用于脚本或应用程序中的随机数。还有其他`/dev`路径，如控制台和各种适配器（例如，USB存储设备或鼠标），所有这些都可能是可访问的，建议您了解它们。'
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'To get ready for this recipe, install the `dd` command as follows and make
    a new directory called `qa-data/`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为此配方做好准备，请按以下步骤安装`dd`命令，并创建一个名为`qa-data/`的新目录：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This recipe uses the `dmesg` command, which is used to return system information
    such as interface status or the system boot process. It is nearly always present
    on a system and therefore a good substitute to reasonable system level "lorem
    ipsum". If you wish to use another type of random text, or a dictionary of words,
    `dmesg` can easily be replaced! Another two commands used are `seq` and `hexdump.`
    The **`seq`** command can generate an array of *n* numbers from a starting point
    using a specified increment, and `hexdump` produces a human readable representation
    of a binary (or executable) in hexadecimal format.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程使用`dmesg`命令，该命令用于返回系统信息，如接口状态或系统引导过程。它几乎在所有系统上都存在，因此是合理的系统级“lorem ipsum”的良好替代。如果您希望使用其他类型的随机文本或词典，则可以轻松替换`dmesg`！另外使用的两个命令是`seq`和`hexdump`。**`seq`**命令可以使用指定的增量从起始点生成一个*n*个数字的数组，而`hexdump`会以十六进制格式生成二进制（或可执行）的人类可读表示。
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行它……
- en: Open a terminal and create a new script called `data-maker.sh`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并创建一个名为`data-maker.sh`的新脚本。
- en: 'The following is the code snippet of the script:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本的代码片段：
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s begin the execution of the script using the following command. It uses
    the `-t` flag for type and is set to `text`, `-n` is used for the number of files,
    which is `5`, `-l` is the lower bound: 1 characters, and -u is `1000` characters:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令开始执行脚本。它使用`-t`标志指定类型为`text`，使用`-n`来指定文件数量为`5`，`-l`设置下限为1个字符，`-u`设置为`1000`个字符：
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To checkout the output, use the following command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查输出，请使用以下命令：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Again, let''s run the `data-maker.sh` script, but for binary files. Instead
    of the size limits being 1 char (1 byte) or `1000` chars (`1000` bytes or just
    less than one kilobyte), the sizes are in MB, with there being `1`-`10` MB files:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`data-maker.sh`脚本，但是这次生成的是二进制文件。大小限制不再是1个字符（1字节）或`1000`个字符（`1000`字节或略少于1千字节），而是以MB为单位，生成`1`到`10`
    MB的文件：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To check out the output, use the following command. The use of a new command
    called `hexdump` is because we cannot "dump" or "cat" a binary file the same way
    as we can a "regular" ASCII text file:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看输出，请使用以下命令。由于我们无法像处理“常规”ASCII文本文件那样“转储”或“cat”二进制文件，因此使用了一个名为`hexdump`的新命令：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理……
- en: 'Let''s understand, how things are happening:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下，事情是如何发生的：
- en: First, we create the `;data-maker.sh` script. This script introduces several
    new concepts including the ever fascinating concept of randomization. In computers,
    or really anything in life, true random events or number generation cannot happen
    and require several mathematical principles such as entropy. While this is beyond
    the scope of this cookbook, know that when reusing it randomly or even initially,
    you should give it a unique initialization vector or seed. Using a for loop, we
    can build an array of numbers using the `seq` command. Once the array is built,
    we choose a "random" value from the array. In each type of file output operation
    (binary or text), we determine approximately both minimum (`-l` or lower) and
    maximum (`-u` or upper) sizes to control the output data.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建了` ;data-maker.sh` 脚本。这个脚本引入了几个新概念，包括一直令人着迷的随机化概念。在计算机中，或者说在生活中的任何事情里，真正的随机事件或数字生成是无法实现的，它们需要几个数学原理，如熵。虽然这超出了本书的范围，但需要知道的是，无论是随机重复使用还是初次使用时，都应该给它一个唯一的初始化向量或种子。通过使用`for`循环，我们可以利用`seq`命令构建一个数字数组。一旦数组构建完成，我们从中选择一个“随机”的值。在每种类型的文件输出操作（无论是二进制文件还是文本文件）中，我们大致确定最小值（`-l`或下限）和最大值（`-u`或上限），以控制输出数据的大小。
- en: In step 2, we build `5` text files using the output of `dmesg` and our pseudo
    randomization process. We can see that we iterate until we have five text files
    created using different sizes and starting points with the `dd` command.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第2步中，我们使用`dmesg`的输出和我们的伪随机化过程创建了`5`个文本文件。我们可以看到，我们通过`dd`命令迭代，直到创建了五个不同大小和起始点的文本文件。
- en: In step 3, we verify that indeed we created five files, and in the fifth one,
    we viewed the `tail` of the `garbage4.txt` file.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第3步中，我们验证了确实创建了五个文件，并且在第五个文件中，我们查看了`garbage4.txt`文件的`tail`部分。
- en: In step 4, we create five binary files (full of zeros) using the `dd` command.
    Instead of using a number of chars, we used megabytes or (MB).
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第4步中，我们使用`dd`命令创建了五个二进制文件（全是零）。我们没有使用字符数，而是使用了兆字节（MB）作为单位。
- en: In step 5, we verify that indeed we created five binary files, and in the fifth
    one, we viewed the contents of the binary file using the `hexdump` command. The
    `hexdump` command created a simplified "dump" of all of the bytes inside of the
    `garbage0.bin` file.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第5步中，我们验证了确实创建了五个二进制文件，并且在第五个文件中，我们使用`hexdump`命令查看了二进制文件的内容。`hexdump`命令创建了一个简化的“转储”，展示了`garbage0.bin`文件中的所有字节。
