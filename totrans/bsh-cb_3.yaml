- en: Understanding and Gaining File System Mastery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing files from various angles – head, tail, less, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for files by name and/or extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a diff of two files and patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating symbolic links and using them effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crawling filesystem directories and printing a tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding and deleting duplicate files or directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining and splitting files at arbitrary positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating datasets and random files of various size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will extend some of the contents from Chapter 2, *Acting
    Like a Typewriter and File Explorer*, but aim to make you even stronger when creating,
    viewing, and managing files. After all, how does one look at a very large file?
    Find external software dependencies of a binary and manipulate files? Surely,
    these tasks are cornerstones in a number of tasks any one developer, administrator,
    or power user can think of.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Bob the reader has already been introduced to VI, and perhaps he
    has his own GUI editor or application, such as Open Office, but what happens if
    that editor likes to crash upon opening a full file? Can he just look at the starting
    few lines? Absolutely. Can he split that file (if the structure is known like
    a CSV) at X number of lines? Again, absolutely!
  prefs: []
  type: TYPE_NORMAL
- en: All of these things are not impossible, and the list of activities Bob can do
    can continue on forever. The idea of this chapter is to give you a segue into
    some of the things you can do if life isn't going your way or you need quick access/control
    over the files on your system.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts for this chapter can be found at [https://github.com/PacktPublishing/Bash-Cookbook/tree/master/chapter%2003](https://github.com/PacktPublishing/Bash-Cookbook/tree/master/chapter%2003).
  prefs: []
  type: TYPE_NORMAL
- en: Viewing files from various angles – head, tail, less, and more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of this very moment, your system likely has many text files of various sizes
    including a never ending log file being written too. You might even have several
    large files containing copious amounts of code (such as the Linux kernel or a
    software project) and would like to quickly view them from the console without
    slowing your system down to a halt.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, there are four essential commands that should be able to provide
    you more than enough functionality for their purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Head**: Can be used to output the beginning lines of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tail**: Can be used to output the end or tail of a file (continuously as
    well)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More**: A tool used as a *pager* to view large files page by page/line by
    line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less**: Is the same as more, but it has more features, including backwards
    scrolling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, you may see the command `more` on embedded systems and not the `less`
    command. This is because the less command is larger than `more`. Does your head
    hurt yet?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, several large text files are needed for this
    recipe. If you have some already, great; if not, install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `fmt` command is a simple optimal text formatter. It is used to clean up
    the output a bit for better results on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a terminal and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly enough, the `tail` command has a feature that is different than
    the `head` command: it can monitor the tail end of a file forever until the command
    is exited or killed when using the `-f` or `-F` flags. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Keeping the `tail` command running, try disconnecting your wireless or Ethernet
    port. What do you see?
  prefs: []
  type: TYPE_NORMAL
- en: 'Press *Ctrl* + *C* to quit `tail` and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Pressing the spacebar or *Enter* on your keyboard will progress through the
    file until the end. Pressing `q` will immediately exit `more` and return you to
    the console prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, try the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Try navigating through the file using *p**g up*, *pg dn*, the up and down arrow
    keys, and *Enter* and the spacebar. Notice anything?
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before proceeding, note that the contents of the `loremipsum.txt` file will
    be different for every instance downloaded. **Lorem Ipsum** is pseudo random text
    that is used in a variety of text-related duties, often as placeholder values
    because it *looks* to be a language of sorts and is useful where the human brain
    is disturbed by copy and paste stub text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, the commands should produce similar results to the following
    block (for brevity, we excluded much of the output to keep the recipe coherent),
    but notice that head begins at the beginning, or *head*, of `loremipsum.txt`,
    and tail begins at the end, or *tail*, of `loremipsum.txt`**.** When we specify
    the `-n` flag with a decimal number such as `1`, both utilities will output a
    single line or whatever number of lines is entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the second step, we discover a key difference between the `head` and `tail`
    commands. Tail is able to monitor a file while continuously dumping the tail contents
    of the file to standard out `(stdout)`. If the file has a read error, or is moved/rotated
    out, `-f` (lowercase) will often stop outputting information, while `-F` will
    reopen the file and continue outputting the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-F` instead of `-f` is usually the desired option between the two if tailing
    system logs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `tail` still running in continuous mode, several new entries should appear
    among the output. This sample is from when a system''s wireless adapter was forced
    to reconnect to a standard access point (AP):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After killing the `tail` command, your console should be back at the prompt
    again: `$`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running `more` and using the spacebar or *Enter* keys will progress output through
    the entire `loremipsum.txt` file. The `more` command is only able to view from
    beginning to end, and not back and forth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `less` command is certainly more powerful and offers the user to be able
    to navigate through `loremipsum.txt` using several key combinations. It also offers
    search facilities among other features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Searching for files by name and/or extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we have large number of files available for viewing, sometimes we need
    to find a file among many without using the GUI searching tools or provide a better
    set of granular filters to reduce returned results. To search on the command line,
    there are a few facilities/commands we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`locate` (also a sibling of the `updatedb` command): Used to find files more
    efficiently using an index of files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find`: Used to find files with specific attributes, extensions, and even names
    within a specific directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `find` command is far more suitable for the command line and widespread
    (often being on embedded devices), but the `locate` command is a common facility
    for use on desktops, laptops, and servers. Locate is far more simpler and involves
    recursively indexing all of the files it is configured to keep track of and it
    can generate very quick file listings. The file index can be updated using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Updating the database for the first time or after large amounts of files have
    been created, moved, or copied may result in longer than average times to update
    the database. One particular mechanism to keep the database frequently up to date
    automatically is through the use of **cron scheduler**. More about this topic
    will be covered later.
  prefs: []
  type: TYPE_NORMAL
- en: The `locate` command can also be used to test for the existence of a file before
    reporting its location (the database may be out of date), and also limit the number
    of entries returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, `find` does not have a fancy database, but it does have a number
    of user configurable flags, which can be passed to it at the time of execution.
    Some of the most commonly used flags used with the `find` command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-type`: This is used to specify the type of file, which can be either file
    or directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-delete`: This is used to delete files, but may not be present, which means
    that `exec` will be required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-name`: This is used to specify searching by name functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-exec`: This is used to specify what else to do upon match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-{a,c,m}time`: This is used to search for things such as time of access, creation,
    and modification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d, -depth`: This is used to specify the depth searching may delve recursively
    into'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-maxdepth`: This is used to specify the maximum depth per recursion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mindepth`: This is used to specify the minimum depth when recursively searching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-L`, `-H`, `-P`: In order, `-L` follow symbolic links, `-H` does not follow
    symbolic links except in specific cases, and `-P` never follows symbolic links'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-print`, `-print0`: These commands are used to print the name of the current
    file on a standard output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!`, `-not`: This is used to specify logical operations such as match everything,
    but not on this criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i`: This is used to specify user interaction on a match such as -`iname test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please be aware that your platform may not support all of GNU find's features.
    This may be the case with limited shells for embedding, resource constraints,
    or security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, several large text files are needed for this
    recipe. If you have some already, great; if not, install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If a file is not found using the `locate` command, the database might be simply
    out of date and needs to be re-ran. It is possible that `updatedb` is also not
    indexing partitions such as those contained on removable media (USB sticks), and
    the file may be present there instead of the regular system partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In preparation for this recipe, be aware that two concepts were inadvertently
    introduced: `git` and `manpages.` Manpages are among one of the oldest forms of
    help documentation available in Linux, and git is a version control system that
    simplifies management, versioning, and distribution of files such as code. Knowing
    how to use either is certainly beneficial, but beyond the scope of this book.
    For more information about git, check out another Packt book: *GIT Version Control
    Cookbook*.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a terminal and run the following commands in order to understand the `locate`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following commands to demonstrate some of the power of `find`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can chain the `find` commands together with `&&` and ultimately perform
    an `exec` instead of piping the output to another process, command, or script.
    Try the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, one of the most common uses of find is to delete files using either
    the built-in `-delete` flag or by using `exec` combined with rm `-rf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Repeat after me—"*locate is simple* and needs to be updated, `find` works when
    in a bind, but powerful and cryptic and *can break things*." Lets continue and
    begin with the explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the `locate` command is a relatively simple search
    tool that uses a database as a backend, which contains an indexed list of all
    of the files for quick and efficient searches. Locate is not real-time unlike
    the `find` command, which searches everything as it exists at the time of execution
    (depending on the parameters provided to find). Locating `stdio.h` will produce
    several results depending on your system. However, when we run locate again, it
    does not know or contain any information regarding the `/usr/filethatlocatedoesntknow.txt`
    and `/usr/filethatlocatedoesntknow2.txt` files. Running `updatedb` will re-index
    the files and then using the `locate` command will return the appropriate results.
    Notice that locate works with partial names or full path matching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the second step, we are introduced to some of the amazing functionality provided
    by the `find` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, be aware that using `find` for operations such as deletion can break
    your system if not handled appropriately or if the input isn't carefully monitored
    and filtered.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a minimum, the `find` command is executed this way: `$ find ${START_SEARCH_HERE}
    ${OPTIONAL_PARAMETERS ...}`. In the first use of the find command, we begin searching
    within our user''s home directory (`${HOME}` environment variable), and then use
    a wild card to look for **hidden files** that begin with a `.`.Finally, we use
    `-ls` to create a file listing. This is not by accident as you may have observed;
    you can create files that are absent upon first inspection in the GUI''s file
    explorer (especially in your user''s home directory) or on the console (for example,
    unless you use the `ls` command with the `-a` flag). In the next command, we use
    `find -type d` to search for a directory named `.git`. Then, we search for files
    that match either `*.sh` or `*.txt` using a special notation for find: `-type
    f \( -name "*.sh" -o -name "*.txt" \).` Notice the forward slash `\` and then
    the parenthesis `(`. We can then specify multiple name matching arguments using
    `-o -name "string"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the third step, we use find to search for subdirectories using `-type d`
    that are often present inside of cloned or exported git-related directories. We
    can chain the `find` commands together using this format: `$ cmd 1 && cmd2 &&
    cmd3 && ...`. This guarantees that if the proceeding command evaluates to true,
    then the next will execute and so on. Then, we introduce the `-exec` flag, which
    is used to execute another command once a match has been found. In this case,
    we search for all files and then use grep immediately to search within the file.
    Notice the `{} +` at the end of the `grep`. This is because `{}` will be replaced
    with find''s returned results. The `+` character delimits the end of the `exec`
    command, and appends the results so that `rm -rf` will be executed less times
    than the total number of files found/matched.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the final step, we delete files using two methods. The first method using
    the `-delete` flag may not be available on all distributions or implementations
    of find, but upon match, it will delete the file. It is more efficient than executing
    the sub process `rm` on large numbers of files. Secondly, using `-exec rm -rf
    {} \;`, we can delete files found easily and in a portable way. However, there
    is a difference between `\;` and `+` and the difference is that in the `\;` version,
    `rm -rf` is executed for each file found/matched. Be careful with this command
    as it is not interactive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a diff of two files and patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In what case should you know what a diff is? Or a patch? In the Linux world,
    it is a way to determine the differences between files and also to solve problems
    at the OS level (especially if you have a broken driver in the Linux kernel).
    However, for the purposes of a cookbook, diffs and patches useful for a couple
    of main things:'
  prefs: []
  type: TYPE_NORMAL
- en: When determining whether a particular script or configuration file has modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When plotting differences between versions, or migrating data between an old
    to new script, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, what is a **diff** or **differential**? A diff is the output that describes
    the differences between two files (file A and file B). The file A is the source,
    and the B file is the assumed to be modified file. If no diff output is created,
    then A and B are either empty or there are no differences. Diffs in a unified
    format typically look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several formats of diffs, but the unified format is among the most
    popular (and used by the FOSS crowd). It contains information about both files
    (A and B), the line numbers and counts in each, and the content added or changed.
    If we look at the preceding sample, we can see that in the original, the string
    `abcdef` is removed `(-)` and then re-added `(+)` as `abcdZZZ`. And there is the
    further addition of a new line containing `789aaa` (which can also be seen here:
    `@@ -1,3 +1,4 @@`).'
  prefs: []
  type: TYPE_NORMAL
- en: A patch is a unified diff that contains changes to one or more files that are
    to be applied in a specific order or method, hence the concept of patching being
    the process of applying a patch (which contains diff information). A patch can
    consist of several diffs concatenated together as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, these two utilities need to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a fake configuration file that''s copied from a real one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `updatedb-v2.conf` and change the contents to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the event that your `updatedb-v2.conf` looks drastically different, add `/media
    /mount` to the `PRUNEPATHS` variable. Notice that they are separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a terminal, and run the following commands in order to understand the
    `diff` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, only the diff information has been output to the console''s
    standard out and a patch file has not been created. To create the actual patch
    file, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Patches can be found in many forms, but they usually have the `.patch` extension
    and are preceded by a number and a human readable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before applying a patch, it can also be tested to ensure that the results
    are as expected. Try the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens when patches fail to apply using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Repeat after me—"*locate is simple and needs to be updated, find works when
    in a bind, but powerful and cryptic and can break things*." Let''s continue and
    begin with the explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `diff` command outputs the changes in the simple diff format. However,
    in the second instance when running the diff command, we use the `-urN` flag(s).
    `-u` stands for unified format, `-r` stands for recursive, and `-N` stands for
    a new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have created a patch by redirecting standard out to the `001-myfirst-patch-for-updatedb.patch`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created a modified version of `~/updatedb-v3`, notice anything
    from the dry-run? Ignoring that `/etc/updatedb.conf` only has read-only permissions
    (we are just using it for the sake of example as dry-run doesn''t alter the contents
    anyway), we can see that HUNK #1 is applied successfully. A **hunk** stands for
    a section of the diff, and you can have several for one file or many files inside
    of the same patch. Did you notice that the line numbers didn''t match exactly
    as those in the patch? It still applied the patch as it knew enough information
    and **fudged** the data to match so that it would apply successfully. Be aware
    of this functionality when dealing with large files, which may have similar match
    criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to apply the patch to a file on a file that does not match, it
    will fail, like in the following output (if `--dry-run` is specified). If `--dry-run`
    is not specified, the failure will be stored in a reject file as is noted in this
    line: `1 out of 1 hunk FAILED -- saving rejects to file /home/rbrash/fileA.txt.rej`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating symbolic links and using them effectively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symbolic links mean shortcuts, right? Well, if you ever heard that explanation,
    it is only partially correct and they are present on most modern OS. In fact,
    there are two kinds of symbolic links when thinking in terms of files: hard and
    soft:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hard Links** | **Soft Links** |'
  prefs: []
  type: TYPE_TB
- en: '| Only link to files | Can link to directories and files |'
  prefs: []
  type: TYPE_TB
- en: '| Link to contents on same disk | Can reference files/folders across disks
    or networks |'
  prefs: []
  type: TYPE_TB
- en: '| Reference inode/physical locations | If the original file is deleted, the
    hard link will remain (in own inodes) |'
  prefs: []
  type: TYPE_TB
- en: '| Moving a file will still allow the link to work | Links don''t follow the
    reference file if moved |'
  prefs: []
  type: TYPE_TB
- en: A soft link will most likely match your expectations of a shortcut and the behavior
    might not be very surprising, but what use is a hard link? One of the most prominent
    cases of when to use a hard link is when you don't want to break a link by moving
    the file it points to! A soft link is clearly more flexible and can work across
    file systems, which is unlike hard links, but soft links won't work if a file
    is moved.
  prefs: []
  type: TYPE_NORMAL
- en: Besides creating shortcuts, you can do neat tricks like renaming `argv[0]` when
    using symbolic links. The Busybox shell is an example of that, where it contains
    **applets** that are executed by a symlink that points to `./busybox`. For example,
    `ls` points to the same binary as `cd`! All of them point to `./busybox`. This
    is a neat way to save space and improve run-time flags without the use of flags.
  prefs: []
  type: TYPE_NORMAL
- en: Soft links are also used in the `/usr/lib` or `/lib` folders for shared `librarys`.
    In fact, symlinks are very useful for aliasing paths or getting software to work
    with hard-coded paths that are inside of the binaries themselves.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a terminal, and create the `whoami.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `whoami.sh` and observe what has happened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a soft link to `whoami.sh` using the `ln` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, run `ls` `-la`. Notice any differences?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On to hard links, which are created this way using `ln`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the difference in results when running the commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step one, we created `whoami.sh`. It is similar to the `whoami` command,
    but different because we do not print the `$USER` variable, but rather argument
    `0` `(arg0`, as its typically known) or `$0`. In laymen's terms, we are printing
    out the name used to execute the code or script.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute `whoami.sh`, it prints to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a symbolic soft link, we use `ln` with the `-s` flag (for symbolic
    mode). The `ln` command expects to be executed in this way: `$ ln -s originalFileToBeLinkedTo
    newFileToLinkToOldFile`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the following code, executing `ghosts-there-be.sh` runs the
    code in `whoami.sh`, but `arg0` is `ghosts-there-be.sh`. Then, when the `ls` command
    is ran with the `-l -a` flags (`-la`), we can see the soft link to `whoami.sh`.
    Notice the small size of 9 bytes!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a hard link by using the `ls` command without the `-s` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hard link, `real-ghosts-there-be.sh`, runs the same content as `ghosts-there-be.sh`,
    but points to the actual contents of `whoami.sh`, even if it is moved and renamed
    as `nobody.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Crawling filesystem directories and printing a tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we already know about the commands locate, find, and grep (plus
    regular expressions), but what about if we wanted to create our own naive implementation
    of a directory crawler/scraper/indexer? It certainly won't be the fastest or have
    optimizations, but we can use recursive functionality and file tests to print
    a tree-like structure.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is a bit of a fun exercise and certainly recreates the proverbial
    "wheel". This can be easily done by running the tree command, however, this will
    be useful in an upcoming exercise when we'll be building arrays of arrays for
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, let''s create some test data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a terminal and create the `mytree.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In your terminal, now run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The creation of `mytree.sh` is a trivial task, but the logic inside follows
    recursive functions. There is also the concept of `${CURRENT_LVL}`, which is used
    to produce the number of periods (or levels) deep the script is from its original
    starting point: **parentdir**. In each directory, we create a for loop to test
    each file/directory inside of it. The logic tests whether the entry is either
    a file or a director. If it is a directory, we increment `${CURRENT_LVL}` and
    then **recursively** execute the **same** logic inside of the `recursive_tree`
    function until done and then return. If the logic is a file, we merely print out
    and **continue**. The `tab_creator` function makes the variable string for the
    periods based on `${CURRENT_LVL}` and concatenation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the script should produce an output similar to the following, but
    notice how the script remembers how many layers deep it might be, and that the
    directories are shown with a `\_` instead of `|_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finding and deleting duplicate files or directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At one point, we had already talked about checking to see if strings inside
    of a file were unique and if we could sort them, but we haven''t yet performed
    a similar operation on files. However, before diving in, let''s make some assumptions
    about what constitutes a duplicate file for the purpose of this recipe: a duplicate
    file is one that may have a different name, but the same contents as another.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to investigate the contents of a file would be to remove all white
    space and purely check the strings contained within, or we could merely use tools
    such as **SHA****512sum** and **MD****5sum** to generate a unique hash (think
    unique string full of gibberish) of the contents of the files. The general flow
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using this hash, we can compare the hash against a list of hashes already computed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the has matches, we have seen the contents of this file before and so we
    can delete it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the hash is new, we can record the entry and move onto calculating the hash
    of the next file until all files have been *hashed.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a hash does not require you to know how the mathematics work, but rather
    to be aware of how it's supposed to work IF it is a secure implementation and
    has enough possibilities to make finding a duplicate computationally unfeasible.
    Hashes are supposed to be one way, which means that they are different from encryption/decryption
    so that once a hash has been created, it should be impossible to determine the
    original input from the hash itself.
  prefs: []
  type: TYPE_NORMAL
- en: MD5sums are considered completely insecure (although useful where security may
    be less needed), and SHA1/2 are considered to be potentially on their way out
    of popularity with the use of SPONGE algorithms in SHA3 (use SHA3 where possible).
    For more information, please see the [NIST guidelines](https://csrc.nist.gov/Projects/Hash-Functions).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a terminal and create a data set consisting of several files with the
    `dsetmkr.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Then, before jumping into scripting, a core concept needs to be discussed regarding
    arrays and whether they are static or dynamic; knowing how an array implementation
    works at its core is a key principle if performance is an objective.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays can be really helpful, but the performance of a Bash script is often
    sub-par to that of a compiled program or even choosing a language with the appropriate
    data structures. In Bash, arrays are linked lists and dynamic, which means that
    if you resize the array, there isn't a massive performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we are going to create a dynamic array and once the array
    becomes quite large, it will be the searching of the array which becomes the performance
    bottleneck. This naive iterative approach usually works well up to an arbitrary
    amount (let's say, `N`), and at which the benefits of using another mechanism
    may outweigh the simplicity of the current approach. For those who want to know
    more about data structures and the performance of them, check out Big O notation
    and complexity theory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a terminal, and create the `file-deduplicator.sh` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is a code snippet of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `setup` command if not already: run `$ bash dsetmkr.sh` and then run
    `$ bash ./file-deduplicator.sh`. Enter `files_galore/` at the prompt and press
    *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Review the results and verify the contents of `files_galore`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting started, a proceeding note of caution: the `file-deduplicator.sh`
    script deletes duplicate files in the directory it is targeted at.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting started (especially using the `dsetmkr.sh` script), we will produce
    a directory called `files_galore` that also contains several files: four are unique
    and three contain duplicate content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The study of cryptography, security, and mathematics are all very interesting
    and broad information domains! Hashes have a multitude of other uses such as integrity
    checking of files, lookup values to find data quickly, unique identifiers, and
    much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run `file-deduplicator.sh`, it begins by asking the user for input
    using `read` and then it prints out four different values with seemingly random
    strings of characters. *Random* looking is absolutely correct—they are SHA512
    hash sums! Each string is the sum of the contents inside of it. Even if the contents
    are even slightly different (for example, one bit has been flipped to a `1` instead
    of a `0`), then a totally different hash sum will be produced. Again, this bash
    script leverages a foreign concept of arrays (using a global array variable meaning
    accessible everywhere in the script) and hash sums using the **SHA512sum** tool
    combined with **awk** to retrieve the correct values. This script is not recursive
    though, and only looks at the files inside of `files_galore` to generate a list
    of files, a hash for each one, and search an array containing all *known* hashes.
    If a hash is unknown, then it is a new file and is inserted into the array for
    storage. Otherwise, if a hash is seen twice, the file is deleted because it contains
    DUPLICATE content (even if the file name is different). There is another aspect
    here, and that is the use of return values as strings. As you may remember, return
    only can return numeric values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: After executing the operation, we can see that the `files_galore` directory
    only contains four files out of the original seven. The duplicate data is now
    removed!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Joining and splitting files at arbitrary positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s not be shy! Who has tried to open a large file by accident or even intentionally
    with an application and it didn''t quite go as planned? I certainly have, and
    I have certainly seen the limitations such as the number of rows loaded in Excel,
    or OpenOffice calculator. In these cases, we use a handy tool that can split files
    at arbitrary points, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Before X number of lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before Z number of bytes/chars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, you will create a singe dual purpose script: a script that
    can use an input file and produce *split* or multiple files, and a second script
    to join files using a combining method. There are a few caveats when passing around
    string variables as they:'
  prefs: []
  type: TYPE_NORMAL
- en: Can sometimes lose special characters such as new lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Binary) Should be handled by different tools than the usual commands on the
    command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This file also reuses the `getopts` parameter parsing we saw earlier in Chapter
    1, *Crash Course in Bash*, but it also introduces the `mktemp` command and the
    `getconf` command with the `PAGESIZE` parameter. `Mktemp` is a useful command
    because it can produce unique temporary files that reside in the `/tmp` directory,
    but can even produce unique files that follow a template (notice the `XXX`—this
    will be replaced with random values, but `uniquefile.` will remain):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Another useful command is the `getconf` programming utility, which is a standards
    compliant tool designed to fetch useful system variables. One in particular called
    `PAGESIZE` is useful to determine the size of memory in one block. Obviously,
    this is in very simplistic terms, but choosing the appropriate size to write data
    can be very beneficial performance-wise.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, a single text file called `input-lines` needs
    to be created with the following content (one character on each line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a second file called `merge-lines` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a terminal and create a script named `file-splitter.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run `file-splitter.sh` with this command and flags ( `-i`, `-t`, `-l`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the output and see what the difference is with `-t size` and when `-l
    line` is used. What about when `-l 1` or `-l 100` is used? Remember to remove
    the split files using `$ rm input-lines.*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the next step, create another script called `file-joiner.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the script using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before proceeding, notice that the type option (`-t`) on `final-join.txt` ignores
    `\n` newlines when reading in characters one at a time. Read suffices for the
    purpose of this recipe, but the reader should be aware that read/cat are not the
    best tools for this type of work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the script was trivial and for the most part shouldn't look like it
    came from the planet Mars.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running the `$ bash file-splitter.sh -i input-lines -t line -l 10` command
    should produce three files, all of which are input-lines {1,...,3}. The reason
    that there is three files is that if you used the same input, which is 22 lines
    long, it will produce three files (10+10+2). Using read and echo using a concatenated
    buffer (`${BUFFER}`), we can write to the file based on a specific criteria (provided
    by `-l`). If the **EOF** or end of file is met and the done loop is done, we need
    to write the buffer to the file because it may be under the threshold of the write
    criteria—this would result in lost/missing bytes in the last file created by the
    `splitter` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the usage of the `-l` flag, the value of `1` will produce a file
    for every line, and the value of 100 will produce a single file because if fits
    under the threshold. Using the side-feature `-t size`, which can be used to split
    based on bytes, read has an unfortunate side effect: when we pass the buffer,
    it is altered and the new lines are missing. This sort of activity would be better
    if we used a tool such as `dd`, which is better for copying, writing, and creating
    raw data to files or devices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we created the script called `file-joiners.sh`. Again, it used `getopts`
    and requires four input parameters: `-i originalFile -o`, `otherFileToMerge -f`,
    `finalMergedFile -w`, and `whereInjectTheOtherFile`. The script is simpler overall,
    but uses the `mktemp` command to create a temporary file which we can use as a
    storage buffer without modifying the originals. When we are finished, we can use
    the `mv` command to move the file from `/tmp` to the terminal''s current directory
    (`.`). The `mv` command can also be used to rename files and is usually faster
    than `cp` (not so much in this case) because a copy does not occur, rather just
    a renaming operation at the file system level.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Catting `final-join.txt` should contain the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Generating datasets and random files of various size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, data that mimics real-world data is always the best, but sometimes
    we need an assortment of files of various content and size for validation testing
    without delay. Imagine that you have a web server and it is running some sort
    of application that accepts files for storage. However, the files have a size
    limit being enforced. Wouldn't it be great to just *whip up* a batch of files
    in an instant?
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can use some few file system features such as `/dev/random`
    and a useful program called `dd`. The `dd` command is a utility that can be used
    to convert and copy files (including devices due to Linux''s concept of everything
    is a file, more or less). It can be used in a later recipe to back up data on
    an SD card (remember your favorite Raspberry Pi project?) or to "chomp" through
    files byte by byte without losses. Typical minimal dd usage can be `$ dd if="inputFile"
    of="outputFile" bs=1M count=10`. From this command, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if=`: Stands for input file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of=`: Stands for output file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bs=`: Stands for block size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count=`: Stands for numbers of blocks to be copied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options `bs=` and `count=` are optional if you want to perform a 1:1 (pure duplicate)
    copy of a file because `dd` will attempt to use reasonably efficient parameters
    to provide adequate performance. The dd command also has a number of other options
    such as `seek=`, which will be explored later when performing low-level backups
    in another recipe. The count option is typically not needed as it's far more common
    to copy an entire file instead of a section (when performing backups).
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/random` is a device in Linux (hence the `/dev` path) which can be used
    to produce random numbers for use in your scripts or applications. There are also
    other `/dev` paths such as the console and various adaptors (for example, USB
    sticks or mice), all of which may be accessible, and gaining knowledge of them
    is recommended.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get ready for this recipe, install the `dd` command as follows and make
    a new directory called `qa-data/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This recipe uses the `dmesg` command, which is used to return system information
    such as interface status or the system boot process. It is nearly always present
    on a system and therefore a good substitute to reasonable system level "lorem
    ipsum". If you wish to use another type of random text, or a dictionary of words,
    `dmesg` can easily be replaced! Another two commands used are `seq` and `hexdump.`
    The **`seq`** command can generate an array of *n* numbers from a starting point
    using a specified increment, and `hexdump` produces a human readable representation
    of a binary (or executable) in hexadecimal format.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a terminal and create a new script called `data-maker.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code snippet of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s begin the execution of the script using the following command. It uses
    the `-t` flag for type and is set to `text`, `-n` is used for the number of files,
    which is `5`, `-l` is the lower bound: 1 characters, and -u is `1000` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To checkout the output, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, let''s run the `data-maker.sh` script, but for binary files. Instead
    of the size limits being 1 char (1 byte) or `1000` chars (`1000` bytes or just
    less than one kilobyte), the sizes are in MB, with there being `1`-`10` MB files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To check out the output, use the following command. The use of a new command
    called `hexdump` is because we cannot "dump" or "cat" a binary file the same way
    as we can a "regular" ASCII text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand, how things are happening:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create the `;data-maker.sh` script. This script introduces several
    new concepts including the ever fascinating concept of randomization. In computers,
    or really anything in life, true random events or number generation cannot happen
    and require several mathematical principles such as entropy. While this is beyond
    the scope of this cookbook, know that when reusing it randomly or even initially,
    you should give it a unique initialization vector or seed. Using a for loop, we
    can build an array of numbers using the `seq` command. Once the array is built,
    we choose a "random" value from the array. In each type of file output operation
    (binary or text), we determine approximately both minimum (`-l` or lower) and
    maximum (`-u` or upper) sizes to control the output data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In step 2, we build `5` text files using the output of `dmesg` and our pseudo
    randomization process. We can see that we iterate until we have five text files
    created using different sizes and starting points with the `dd` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In step 3, we verify that indeed we created five files, and in the fifth one,
    we viewed the `tail` of the `garbage4.txt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In step 4, we create five binary files (full of zeros) using the `dd` command.
    Instead of using a number of chars, we used megabytes or (MB).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In step 5, we verify that indeed we created five binary files, and in the fifth
    one, we viewed the contents of the binary file using the `hexdump` command. The
    `hexdump` command created a simplified "dump" of all of the bytes inside of the
    `garbage0.bin` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
