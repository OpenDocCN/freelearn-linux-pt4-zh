- en: Chapter 5. Adding a Passive Infrared Motion Sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started adding basic but commonly used magnetic
    switch sensors to our home security system and reading their status to protect
    doors and windows from intrusion. We also looked at how we can divide our home
    into zones, such as by individual rooms, so that we can group our sensors into
    logical circuits, which can then be identified as part of these zones rather than
    as individual sensor inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We will now add **motion sensors** to our system in the form of **Passive Infra-Red**
    (**PIR**) detectors. These detectors come in a variety of types, and you may have
    seen them lurking in the corners of rooms. Fundamentally, they all work in the
    same way, which is detecting the presence of body heat within a certain range;
    so, they are commonly used to trigger alarm systems when somebody (or something,
    such as a pet cat) enters a room.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a Passive Infrared Motion Sensor](img/B04579_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A typical PIR motion sensor (type GardScan QX-PIR)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how PIR detectors work and how they are set up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect a wired PIR detector to an input on our port expander
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start using a 12V power supply instead of 3.3V in our zone circuits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to interface 12V circuits safely with our GPIO ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to connect a 433 MHz wireless receiver to our Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect a remote-controlled switch to our system using 433 MHz radio signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a script that will detect and log the state of our detector inputs when
    it changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll need the following parts for this chapter (apart from the components
    used in the previous chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: A passive infrared detector, the wired type (this is available from any DIY
    store)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 4N25/4N35 opto-isolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 1N4148 diode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 1-Kohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 10-Kohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 433 MHz receiver module and remote transmitter (this is optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 12V power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hook-up wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 6 core alarm wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive infrared sensors explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might not realize it, but all objects radiate heat energy (including your
    coffee table); it's just that you can't see it because heat consists essentially
    of infrared waves, which are invisible to the human eye (exactly the same as your
    TV remote control). These waves can, however, be detected by electronic devices
    designed for such a purpose, such as the infrared receiver in your TV that detects
    the energy emitted by your remote control when the buttons are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: You probably do realize, however, that living things such as us, our cat, and
    the mouse under the floorboards generate quite a bit of heat. Passive infrared
    motion sensors used in security systems and automatic lights are designed to detect
    this level of heat. The term *passive* is used because the sensors themselves
    do not radiate any energy for detection purposes—instead, they just detect the
    infrared radiation emitted by objects. This is notably different from devices
    such as ultrasonic sensors and radars, which rely on detecting reflections from
    objects of the pulses of energy that the sensors send out.
  prefs: []
  type: TYPE_NORMAL
- en: PIR sensors need to be a little smart because they effectively have to cope
    with constantly varying temperatures in the room. They settle on the background
    temperature of the room they are in, such as that of a wall or floor that they
    point to. When an object, such as one of us or our cat, moves between the detector
    unit and the background object, the temperature in front of the sensor rises to
    the body temperature quickly, and this in turn triggers the system.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your PIR sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PIR sensor devices come in many formats, including different materials in sensor
    chips and the lens in front of the sensor view window that can widely affect the
    range, field of view, and sensitivity of the device. Therefore, your best guide
    to setting up a sensor will usually be in that little bit of instruction paper
    that comes with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, regardless of the type of PIR sensor you have, here are some general
    guidelines when considering where you mount your sensor in order to avoid false
    triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the device is mounted on a solid foundation and not affected by
    vibration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never mount it in a location where direct or reflected sunlight can be picked
    up by the lens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, never mount the device facing or above heat sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't mount the unit in draughty locations as this will affect its background
    temperature calibration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location of the unit also depends on the area you want to protect. You may
    want to detect people entering your living room from the hallway, so your coverage
    area could be defined as being from the corner of the room where the device is
    mounted to the living room door.
  prefs: []
  type: TYPE_NORMAL
- en: PIR sensors usually offer a fixed field of view (for example 90 or 110 degrees)
    but have a varying range, depending on the angle at which they are pointing down
    and the height at which they are located.
  prefs: []
  type: TYPE_NORMAL
- en: In my system, I will use a Gardscan QX PIR Detector for my wired units, which
    is a pretty good, low-cost unit available from RS Components (the order code is
    493-1289). This unit has a field view of 110 degrees and a range of up to 12 meters,
    depending on the configurable down angle that it's mounted at. The coverage patterns
    for this particular unit, as taken from its datasheet, are shown in the following
    figure. Note that from these patterns not every part of the area in front of the
    device is covered, which is possibly not quite what you expect. This is why positioning
    the units in accordance with the device's datasheet is so important.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up your PIR sensor](img/B04579_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GardScan QX-PIR coverage pattern for its 110 degree field view (top/plan view)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram of the side view as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up your PIR sensor](img/B04579_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GardScan QX-PIR coverage pattern depending on the angle configured plus a "look-down"
    window (side view)
  prefs: []
  type: TYPE_NORMAL
- en: Give me power (again)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can go on to connect off-the-shelf security devices to our alarm system,
    we need to have a power supply that's compatible with such devices. Typically,
    alarm circuits and their devices use a 12V supply with enough current to drive
    all the devices and the alarm control system itself.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this is not too difficult to sort out, but it is something we need
    to do now; otherwise, we won't be able to connect and power our PIR sensors. The
    easiest way to do this is to buy a high-quality 12V mains adapter that provides
    a nice regulated supply. These are readily available from online stores or electronics
    suppliers. Alternatively, you can build your own 12V regulated supply and add
    it to the power supply strip board that we built in [Chapter 3](ch03.html "Chapter 3. Extending
    Your Pi to Connect More Things"), *Extending Your Pi to Connect More Things*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another option is to use battery-powered PIR sensors, which means that you wouldn't
    have to power the unit from the security system's panel itself; however, it obviously
    also means that the batteries would need replacing from time to time. The wireless
    PIR we will look at later in this chapter is battery-powered.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a look at handling higher-voltage sensor circuits later on in this
    chapter so that we don't blow up our home security control circuits or the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting our PIR motion sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commercially available alarm systems connect to their devices using a 4 core
    or 6 core alarm cable. In the previous chapter, we used a 4 core cable because
    we were connecting a switch that needed two wires plus an antitamper loop, which
    needed another two wires.
  prefs: []
  type: TYPE_NORMAL
- en: For our PIR sensor circuit, we need the same four wires; however, we also need
    to send power to the device from the control panel, so an additional two wires
    are needed for this—hence the requirement for a 6 core cable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the wiring connections for my GardScan PIR sensor,
    but this is in fact typical for most off-the-shelf security system devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting our PIR motion sensor](img/B04579_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Typical connections for security system sensor devices
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the magnetic contact sensors that we looked at in the previous chapter,
    devices can come with either a **normally closed** (**NC**) or a **normally open**
    (**NO**) alarm. This particular device has a normally closed output, which means
    that the alarm circuit will be broken when the detector is triggered. This is
    the preferred configuration for our sensor devices as this means that they can
    be wired in a series within each of our zones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add this sensor device into the alarm circuit that we started putting
    together in the previous chapter. The following diagram shows the circuit for
    all our sensors so far wired into a single zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting our PIR motion sensor](img/B04579_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A schematic for our zone with all three sensors plus tamper loop in the same
    zone
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we used the +3.3V power supply to pass through the sensor switches
    and alarm circuit. In fact, this is not a good idea, and we've been doing this
    only for convenience to test out our GPIO inputs.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, and in our final system, we really should use a 12V supply to pass
    through the sensor and antitamper circuits. This is because a higher voltage travels
    better through the system and is less susceptible to noise, which could prevent
    triggering or cause false triggering. This also makes it compatible with commercially
    available systems and accessories.
  prefs: []
  type: TYPE_NORMAL
- en: 12V alarm zone circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making our zone circuits use 12V instead of 3.3V is as simple as changing the
    power supply, and in fact all of sensors we used so far can handle 12V power passed
    through their switches.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we were to present the 12V circuit to the inputs on our GPIO port
    on the Raspberry Pi or our port expander, we would expect to see some magic smoke
    and smell something burning. So, we need to add some circuitry that allows us
    to use 12V alarm circuits as well as protect our control board inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Alarm circuit protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An effective way to protect our zone inputs from 12V alarm inputs is to use
    a little low-cost device called an opto-isolator. As the name suggests, this isolates
    the alarm circuit from the digital inputs of the control board using light.
  prefs: []
  type: TYPE_NORMAL
- en: Inside an opto-isolator (also called an opto-coupler) is an infrared LED, which
    transmits light to a photo-transistor when a current is passed through it, thus
    switching it on. The circuits are electrically isolated as they are controlled
    only by light.
  prefs: []
  type: TYPE_NORMAL
- en: '![Alarm circuit protection](img/B04579_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The 4N25 (shown in the preceding image) and 4N35 are low-cost, 6-pin opto-coupler
    devices, and most manufactures tend to use the pin layout shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Alarm circuit protection](img/B04579_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know how we will couple our 12V alarm circuit with the inputs on
    our control panel, let's build the entire circuit, which we'll use for each of
    the zones that we add to our system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Alarm circuit protection](img/B04579_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A 12V zone circuit optically isolated from the GPIO input
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this time, we're assuming that our zone circuits are normally closed—that
    is, the alarm triggers when the circuit is broken.
  prefs: []
  type: TYPE_NORMAL
- en: The 12V supply is passed through the LED of the opto-isolator with the current
    being limited by the 1-Kohm resistor. The 1N4148 diode, in reverse, is there to
    protect the opto-coupler from reverse-polarity voltages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 1-Kohm resistor is calculated from the fact that we have a 12V supply and
    a forward voltage drop (Vf) of 1.2V across the LED with a current (If) of about
    10 mA.
  prefs: []
  type: TYPE_NORMAL
- en: While the alarm circuit is closed, the current flows, and the LED is on. This
    keeps the transistor on and the input to the GPIO port is held low. If the alarm
    circuit is broken, the opto-coupler LED switches off, and this in turn switches
    off the transistor. The GPIO input is then pulled high by the 10-Kohm resistor.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite simple but effective, eh?
  prefs: []
  type: TYPE_NORMAL
- en: The other advantage of this circuit is that it should fail positive—that is,
    if the opto-coupler should fail for any reason, the alarm input on the GPIO port
    should be pulled high, thus triggering it rather than it just failing silently.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless PIR motion sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Wireless motion sensors** are now commonly available at a low cost, allowing
    them to be installed practically anywhere without any wiring from the alarm control
    panel. Some of them still require an external power supply, but many operate on
    batteries. The alarm system must contain a wireless receiver compatible with the
    wireless sensor.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll take a look at how we can use our Raspberry Pi-based
    security system with wireless receiver devices.
  prefs: []
  type: TYPE_NORMAL
- en: 433-MHz wireless alarm systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wireless systems use an unlicensed radio frequency to communicate between the
    various components of an alarm system. In the UK, the two most popular frequencies
    used are **433 MHz** and **868 MHz**. While the more recent systems now use the
    868-MHz frequency, 433 MHz is still in widespread use as it has a slightly longer
    range than an 868-MHz system. However, the 433-MHz band is also used by many other
    devices, which makes it congested, whereas 868 MHz is generally used only for
    alarm systems.
  prefs: []
  type: TYPE_NORMAL
- en: While wireless security systems can be convenient, it's important to understand
    the advantages and disadvantages of using wireless rather than wired systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Their ease and speed of installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their ease of removal, which means that you can take them anywhere with you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding the system in the future can be easier, with most systems automatically
    detecting new units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They are more expensive than wired systems, sometimes three or four times the
    cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are not as secure as wired systems and cannot achieve a security grading
    greater than two in accordance with European Standard BSEN 50131 (although, this
    grade is suitable for domestic properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireless devices need to have their batteries replaced at regular intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireless systems are less reliable and susceptible to interference and even
    radio jamming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting a 433-MHz receiver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the past, it was possible to roll out your own 433-MHz receiver for the Raspberry
    Pi using an inexpensive receiver, such as the XY-MV-5V module along with the **433-Util**
    library that was put together by a guy called Mark Wolfe, a contributor on GitHub.
    Essentially, he gathered together code relating to 433-MHz communications and
    put it all into this library. Originally developed for Arduino, this has now been
    ported to the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: You can then use a readily available transmitter, such as a key fob or any other
    433-MHz transmitter, and take a look at the incoming code as you press each button
    on the transmitter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting a 433-MHz receiver](img/B04579_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A XY-MK-5V Generic 433-MHz receiver module
  prefs: []
  type: TYPE_NORMAL
- en: Finding a suitable 433-MHz receiver should be easy as websites such as Amazon
    and eBay are awash with them, and they cost as little as a couple of pounds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the 433-MHz band is a free for many types of devices. As such, there
    are various different types of receiver, and although they may all state that
    they are 433-MHz receivers, they can operate using AM or FM, and some only detect
    certain types of data. Some, such as the Quasar QAM range, may also require special
    decoder chips in order to read transmitted data and may only work with paired
    transmitters.
  prefs: []
  type: TYPE_NORMAL
- en: The receiver module can pick up signals from a key fob remote control, such
    as the one shown in the following image (this can be picked up from the home security
    section of any local DIY store), which gets an output as a series of square waves.
    These square waves are then decoded by the 433-Util software.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting a 433-MHz receiver](img/B04579_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A Novar/Blyss 433MHz wireless remote control
  prefs: []
  type: TYPE_NORMAL
- en: I liked this particular remote control because I thought it would be good as
    the **arm** and **disarm** device for our home security system. I will talk about
    arming and disarming in [Chapter 8](ch08.html "Chapter 8. A Miscellany of Things"),
    *A Miscellany of Things*, where we will look at the ways to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative approach (because we have no choice)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I started off the previous section with the words "In the past…". This is because
    in recent times, I've not been able to get the 433-Util software working with
    receiver modules, which used to work in the past). I'm not entirely sure why this
    is so; however, I can only guess that because the software uses "bit banging"
    to decode incoming data signals, the timing is no longer correct, perhaps because
    later Raspberry Pi boards are faster and therefore mess up the routines.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is bit banging?**'
  prefs: []
  type: TYPE_NORMAL
- en: Bit banging is a way of using software for serial communication instead of dedicated
    hardware. The software is responsible for all the parameters of the signal, including
    timing, levels, and synchronization. Bit banging can be seen as a bit of a hack,
    but it does allow the implementation of different protocols at a very low cost
    without any hardware changes.
  prefs: []
  type: TYPE_NORMAL
- en: So, in order to make our lives easier (and actually make the device work on
    all flavors of Pi), we will resort to using a dedicated receiver module that you
    can pick up for less than £5 on Amazon and doesn't require all this software bit
    banging nonsense. You'll notice from the following image that it still uses a
    similar XY-MK-5V radio receiver; it's just that the host board decodes the signals
    for us and switches a relay on or off in response to a command from the remote
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're still interested in the 433-Util software project and want to try
    and roll out your own receiver, you can find the original project at [https://github.com/ninjablocks/433Utils](https://github.com/ninjablocks/433Utils).
  prefs: []
  type: TYPE_NORMAL
- en: '![The alternative approach (because we have no choice)](img/B04579_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A Hielec transmitter fob and receiver module, available on Amazon
  prefs: []
  type: TYPE_NORMAL
- en: The fact that it just switches a relay on and off means that we can easily implement
    this in our home security system because it simply acts as a switch. When you
    press the button on the transmitter, the relay switches the contacts on; press
    it again, and the relay switches off. The screw terminals on the board provide
    us with access to the relay terminals.
  prefs: []
  type: TYPE_NORMAL
- en: The receiver wiring diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are just dealing with a switch input, we can use the same circuit as we
    did with the zone circuit earlier but connected to our arm/disarm GPIO input,
    which we'll determine in [Chapter 9](ch09.html "Chapter 9. Putting It All Together"),
    *Putting It All Together*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The receiver wiring diagram](img/B04579_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Circuit to interface the receiver module with a GPIO input
  prefs: []
  type: TYPE_NORMAL
- en: When the receiver module switches the relay on, this will complete the 12V circuit
    through the opto-coupler's LED by turning it on. This will make the transistor
    pull the GPIO pin down to ground, giving it a low input.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this type of circuit for any paired receiver for the wireless security
    devices that you want to use in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Logging detection data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any system, it's useful to be able to log data when something happens.
    We can do this with our detectors too by writing to a log file every time a detector
    in a zone is triggered. This way, you can keep a log of every time someone enters
    a room, which you can review at a later date even if the system isn't armed. You
    can also keep a log of when the system is armed and disarmed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple script that shows you how to do this whenever an event happens
    on our zones connected to the GPIO inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is quite simple, but it can be made more useful by actually
    writing out the zone or zones that change by decoding the hex value that's returned
    by the `i2cget` command in the constituent zones.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.html "Chapter 9. Putting It All Together"), *Putting It
    All Together*, you'll learn how this is done in order to display the individual
    status of each zone on a web page. You can use exactly the same technique to do
    this for your log files and, in fact, output to the log file by expanding on the
    same script.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started off by learning how passive infrared sensors are
    used to detect motion to protect a predefined coverage area from intrusion. We
    then looked at connecting these to the inputs on our port expander via opto-couplers
    as we will now use 12V to power the alarm zone circuits.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at wireless alarm systems that operate on the open 433-MHz band,
    which is commonly used for security devices. After exploring the possibility of
    using the legacy 433-Util bit-banging software on our Raspberry Pi to decode the
    signals transmitted by devices using a simple receiver, we opted to use a paired
    receiver device that will interface easily with our alarm circuit inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created a simple script that will log the changes in our alarm inputs
    to a text file, which can later be expanded to log exactly what's going on with
    the system in detail.
  prefs: []
  type: TYPE_NORMAL
