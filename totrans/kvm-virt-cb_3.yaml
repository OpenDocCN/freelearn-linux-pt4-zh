- en: KVM Networking with libvirt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Open vSwitch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring NAT forwarding network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring bridged network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring PCI passthrough network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating network interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With libvirt, we can define different network types for our KVM guests, using
    the already familiar XML definition syntax and the `virsh` and `virt-install`
    userspace tools. In this chapter, we are going to deploy three different network
    types, explore the network XML format, and see examples on how to define and manipulate
    virtual interfaces for the KVM instances.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to connect the virtual machines to the host OS or to each other,
    we are going to use the Linux bridge and the **Open vSwitch** (**OVS**) daemons,
    userspace tools, and kernel modules. Both software bridging technologies are great
    at creating **Software-defined Networking** (**SDN**) of various complexity, in
    a consistent and easy-to-manipulate manner. The Linux bridge and OVS both act
    as a bridge/switch that the virtual interfaces of the KVM guests can connect to.
  prefs: []
  type: TYPE_NORMAL
- en: With all this in mind, let's start by learning more about the software bridges
    in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux bridge is a software layer 2 device that provides some of the functionality
    of a physical bridge device. It can forward frames between KVM guests, the host
    OS, and virtual machines running on other servers, or networks. The Linux bridge
    consists of two components--a userspace administration tool that we are going
    to use in this recipe and a kernel module that performs all the work of connecting
    multiple Ethernet segments together. Each software bridge we create can have a
    number of ports attached to it, where network traffic is forwarded to and from.
    When creating KVM instances, we can attach the virtual interfaces that are associated
    with them to the bridge, which is similar to plugging a network cable from a physical
    server's NIC to a bridge/switch device. Being a layer 2 device, the Linux bridge
    works with MAC addresses and maintains a kernel structure to keep track of ports
    and associated MAC addresses in the form of a **Content Addressable Memory** (**CAM**)
    table.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a new Linux bridge and use the `brctl`
    utility to manipulate it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Recent Linux kernel with enabled `802.1d Ethernet` bridging options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check whether your kernel is compiled with those features or exposed as
    kernel modules, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `bridge` kernel module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To verify that the module is loaded and to obtain more information about its
    version and features, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `bridge-utils` package that provides the tool to create and manipulate the
    Linux bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to create new KVM guests using libvirt or the QEMU utilities or
    an existing KVM instance from the previous chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create, list, and manipulate a new Linux bridge, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Linux bridge package, if it is not already present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Build a new KVM instance using the raw image from the *Installing a custom
    OS on the image with debootstrap *recipe from [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM*, if you are not reading this book cover to
    cover:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'List all the available bridge devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Bring the virtual bridge down, delete it, and ensure that it''s been deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new bridge and bring it up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign an IP address to bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'List the virtual interfaces on the host OS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the virtual interface `vnet0` to the bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the **Spanning Tree Protocol** (**STP**) on bridge and obtain more information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From inside the KVM instance, bring the interface up, request an IP address,
    and test connectivity to the host OS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we first installed and started the `libvirt` daemon, a few things happened
    automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: A new Linux bridge was created with the name and IP address defined in the `/etc/libvirt/qemu/networks/default.xml`
    configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dnsmasq` service was started with a configuration specified in the `/var/lib/libvirt/dnsmasq/default.conf`
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s examine the default `libvirt` bridge configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is the default network that libvirt created for us, specifying the bridge
    name, IP address, and the IP range used by the DHCP server that was started. We
    are going to talk about libvirt networking in much more detail later in this chapter;
    however, we've shown it here to help you understand where all the IP addresses
    and the bridge name came from.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that a DHCP server is running on the host OS and its configuration
    file by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: From the configuration file earlier, note how the IP address range for the DHCP
    service  and the name of the virtual bridge match what is configured in the default
    libvirt network file that we just saw.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this in mind, let''s step through all the actions we performed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we installed the userspace tool `brctl` that we use to create, configure,
    and inspect the Linux bridge configuration in the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we provisioned a new KVM instance using a custom raw image containing
    the guest OS. This step is not required if you completed the recipes in the previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In step 3, we invoked the `bridge` utility to list all available bridge devices.
    From the output, we can observe that currently there's one bridge, named `virbr0`,
    which libvirt created automatically. Note that under the interfaces column, we
    can see the `vnet0` interface. This is the virtual NIC that was exposed to the
    host OS, when we started the KVM instance. This means that the virtual machine
    is connected to the host bridge.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we first bring the bridge down in order to delete it, then we use
    the `brctl` command again to remove the bridge and ensure that it's not present
    on the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, we recreated the bridge and brought it back up. We do this to demonstrate
    the steps required to create a new bridge.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we reassigned the same IP address to the bridge and listed it.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 7 and 8, we list all virtual interfaces on the host OS. Because we
    only have one KVM guest currently running on the server, we only see one virtual
    interface, that is, `vnet0`. We then proceed to add/connect the virtual NIC to
    the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, we enabled the STP on the bridge. STP is a layer 2 protocol that
    helps prevent network loops if we have redundant network paths. This is especially
    useful in larger, more complex network topologies, where multiple bridges are
    connected together.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in step 10, we connect to the KVM guest using the console, list its
    interface configuration, and ensure that we can ping the bridge on the host OS.
    In order to do that, we need to bring the network interface inside the guest up
    with `ifconfig eth0 up`, then obtain an IP address with the `dhclient eth0` command
    from the `dnsmasq` server running on the host.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are few more useful commands we can use on the Linux bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know that a bridge forwards frames based on the MAC addresses contained
    therein. To examine the table of MAC addresses the bridge knows about, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, we can see that the bridge has recorded two MAC
    addresses on its only port. The first record is a nonlocal address, and it belongs
    to the network interface inside the KVM instances. We can confirm that by connecting
    to the KVM guest as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The second MAC address is the address of the bridge itself and the MAC address
    of the virtual interface, belonging to the KVM virtual machine, exposed to the
    host OS. To confirm this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When the bridge sees a frame on one of its ports, it records the time then after
    a set amount of time not seeing the same MAC address again, it will remove the
    record from the its CAM table. We can set the time limit in seconds before the
    bridge will expire the MAC address entry by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `brctl` command is well documented; to list all available subcommands,
    run it without any parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Most Linux distributions package the `brctl` utility and this is what we used
    in this recipe. However, to use the latest version, or if a package is not available
    for your distribution, we can build the utility from source by cloning the project
    with `git`, then configure and compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that we first cloned the `git` repository
    for the `bridge-utils` project and then compiled the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a RedHat/CentOS host, the process is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Open vSwitch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OVS is another software bridging/switching device that can be used to create
    various virtual network topologies and connect KVM instances to it. OVS can be
    used instead of the Linux bridge, and it provides an extensive feature set, including policy
    routing, **Access Control Lists** (**ACLs**), **Quality of Service** (**QoS**)
    policing, traffic monitoring, flow management, VLAN tagging, GRE tunneling, and
    much more.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to install, configure, and use the OVS bridge to
    connect a KVM instance to the host OS, in a similar way to what we did in the
    previous recipe with the Linux bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for this recipe to work, we need to ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux bridge is deleted, if present, and OVS is installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have at least one KVM instance running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new OVS bridge and attach the virtual interface of a KVM guest,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing Linux bridge, if any:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: On some Linux distributions, it helps to unload the kernel module for the Linux
    bridge before using OVS. To do this, execute `root@kvm:/usr/src# modprobe -r bridge`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the OVS package on Ubuntu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the OVS processes are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the OVS kernel module has been loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'List the available OVS switches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new OVS switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the interface of the running KVM instance to the OVS switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure an IP address on the OVS switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure an IP address inside the KVM guest and ensure connectivity to the
    host OS (if the image does not have console access configure, connect to it using
    VNC):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to simplify our setup and avoid conflicts, it's prudent to first remove
    the Linux bridge before creating a new OVS switch. We delete the bridge in step
    1 and optionally unloaded the kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we install the OVS package that also starts the main OVS daemon `ovs-vswitchd` responsible
    for creating and modifying the bridges/switches on the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we make sure that the OVS kernel module has been loaded, and we list
    all available OVS switches on the host in step 5.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 6 and 7, we create a new OVS switch and add the KVM virtual interface
    to the switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ovsdb`-server process that was also started after installing the package,
    as seen from the output in step 3, is a database engine that uses JSON **Remote
    Procedure Calls** (**RPC**) to communicate with the main OVS daemon. The `ovsdb` server
    process stores information, such as the switch network flows, ports, and `QoS`
    to name just few. You can query the database by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note from the preceding output that the new switch `virbr1` and port `vnet0`
    are now displaying, when querying the OVS database.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 8 and 9, we assign IP addresses to the OVS switch and the KVM guest
    and ensure that we can reach the host bridge from inside the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OVS is a rather complex software switch; in this recipe, we only scratched the
    surface. In the next few recipes, we can use both the Linux bridge and OVS, with
    minor configuration changes in libvirt, which we are going to point out as we
    go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the KVM virtual interface from the OVS switch, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To completely delete the OVS switch, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For more information about the OVS, please visit the projects website, [http://openvswitch.org/](http://openvswitch.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring NAT forwarding network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the `libvirt` daemon starts, it creates a default network defined in the
    `/etc/libvirt/qemu/networks/default.xml` configuration file. When a new KVM guest
    is build without specifying any networking options, it will use the default network
    to communicate with the host OS and other guests and networks. The default `libvirt`
    network is using the **Network Address Translation** (**NAT**) method.  NAT provides
    a mapping from one IP address space to another, by modifying the IP address in
    the header of the IP datagram packet. This is especially useful when the host
    OS provides one IP address allowing multiple guests on the same host to use that
    address to establish outbound connections. The virtual machines IP addresses are
    essentially translated to appear as the host machine's IP address.
  prefs: []
  type: TYPE_NORMAL
- en: The default NAT forwarding network defines and sets up a Linux bridge, for the
    guests to connect to. In this recipe, we are going to explore the default NAT
    network and learn about the XML attributes used to define it. Then, we are going
    to create a new NAT network and connect our KVM guest to it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux host with libvirt installed and the daemon running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `iptables` and `iproute2` packages installed on the host OS. If you installed
    libvirt from a package, chances are that `iptables` and `iproute2`  have been installed,
    as dependencies of the `libvirt` package. If you've built libvirt from source,
    you might need to install them manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running KVM instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure a new NAT network and connect a KVM instance to it, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List all available networks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Dump the configuration of the default network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare that with the XML definition file for the default network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'List all running instances on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the KVM instances are connected to the default Linux bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new NAT network definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the new network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the new network and enable autostarting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain more information about the new network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the XML definition of the `kvm1` instance and change the name of the source
    network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the KVM guest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'List all software bridges on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the KVM instances and check the IP address of the `eth0` interface
    and ensure connectivity to the host bridge (if the image is not configured for
    console access, use a VNC client instead):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'On the host OS, examine which DHCP services are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the IP of the new bridge interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'List the `iptables` rules for the NAT table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by listing all available networks on the host OS in step 1\. As we
    can see from the output of the `virsh` command, there's only one default network
    running.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 2, we examine the configuration of the default network. The XML definition
    uses the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `<network>` attribute is the root element, instructing libvirt that we are
    defining a network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<name>` element specifies the name of the network and needs to be unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<uuid>` attribute provides a globally unique identifier for the virtual
    network and if omitted, it will be autogenerated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<forward>` element and its mode attribute define the network as being connected
    to the host network stack, using NAT. If this element is missing, libvirt will
    create an isolated network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<nat>` subelement further defines the `<port>` range that will be used
    while the host is preforming NAT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<bridge>` element specifies the bridge to be created, its name, and STP
    options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<ip>` attribute defines the IP range for the DHCP server to assign addresses
    to the guest VMs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In step 3, we look at the config file for the default network on this. Note
    that some of the attributes are missing. Libvirt autogenerates certain attributes
    and assigns default values where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4 and 5, we make sure that we have a running instance connected to the
    default Linux bridge.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we create a new network definition using the default network as a
    template. We change the name of the network and define new IP range.
  prefs: []
  type: TYPE_NORMAL
- en: With the new network definition file ready, in steps 7 and 8, we define the
    new network, start it, and make sure that it will automatically start when the
    `libvirt` daemon starts, in the case of a server reboot.
  prefs: []
  type: TYPE_NORMAL
- en: After obtaining more information about the newly created network in step 9,
    we proceed to edit the XML definition of the KVM guest in step 10\. To make the
    VM part of the new network, all we need to do is update the `<source network>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: After restarting the KVM guest in step 11, we proceed to list all available
    software bridges on the host OS in step 12\. Note that we now have two bridges,
    with the new bridge having the VMs virtual interface `vnet0` connected to it.
  prefs: []
  type: TYPE_NORMAL
- en: We then connect to the running KVM guest and ensure that its eth0 network interface
    has obtained an IP address from the DHCP server running on the host and that the
    IP is part of the address range we configured earlier. We also ensured connectivity
    to the host bridge using the `ping` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back on the host OS, in steps 14 and 15, we check what DHCP services are running.
    Note, from the output of the `pgrep` command, that we now have two `dnsmasq` processes
    running: one for each defined network.'
  prefs: []
  type: TYPE_NORMAL
- en: The NAT forwarding is achieved by setting iptables rules as we can see in step
    18\. Each time we define and start a new NAT network, libvirt creates the required
    rules in iptables. From the output in step 18, we can observe the presence of
    two sets of NAT rules, one for each running NAT network.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring bridged network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With full bridging, we can connect the KVM guests directly to the host network,
    without using NAT. However, this setup requires an IP address, which is part of
    the host subnet, for each virtual machine. If you cannot allocate that many IP
    addresses, consider using the NAT network setup, as described in the *Configuring
    NAT forwarding network* recipe given before. In this networking mode, the virtual
    machines still use the host OS bridge for connectivity; however, the bridge enslaves
    the physical interface that is going to be used for the guests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A server with at least two physical interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to provision and start KVM instances with libvirt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running KVM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define a new bridged network and attach a guest to it, follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take down the interface we are going to bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the network configuration file on the host and replace the `eth1` block
    with the following, if your host OS is Debian/Ubuntu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If using RedHat/CentOS distributions, edit the following two files instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the new interface up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Disable sending packets to `iptables` that originate from the guest VMs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'List all bridges on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the XML definition for the KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up bridge networking, in steps 1 and 2, we first bring the physical interface
    (`eth1` in this example) down, in order to enslave it (make it a part of the new
    bridge we are going to create). We then create the network configuration, specifying
    the new bridge and the physical interface that is going to be a part of that bridge.
    This in effect maps the subnet that is configured on the physical interface to
    the bridge. If your server has only one network interface, you can still enslave
    it. However, you will need an additional way of connecting to the server because
    once you bring your main interface down, you will loose connectivity and troubleshooting
    might be impossible over an SSH connection.
  prefs: []
  type: TYPE_NORMAL
- en: Once the new bridge has been configured, we start it in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we instruct the kernel not to apply iptable rules to any traffic
    originating from the virtual guests connected to the Linux bridge because we are
    not using any NAT rules.
  prefs: []
  type: TYPE_NORMAL
- en: With the new interface up, we can now see the bridge and the enslaved physical
    interface attached to it, in step 5.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we edit the XML definition of the `kvm1` instance, where we specify
    the type of network we would like to use; for this recipe, it's the bridge network.
    If you recall from the *Configuring NAT forwarding network* recipe, we used the
    network type instead of bridge and we specified a `libvirt` network name, instead
    of the bridge name.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after restarting the KVM instance in step 7, the guest OS should now
    be able to reach other instances that are a part of the same subnet without using
    NAT.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring PCI passthrough network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The KVM hypervisor supports directly attaching PCI devices from the host OS
    to the virtual machines. We can use this feature to attach a network interface
    directly to the guest OS, without the need for using NAT or software bridges.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to attach a **Network Interface Card** (**NIC**)
    that supports SR-IOV **Single Root I/O Virtualization** (**SR-IOV**) from the
    host to the KVM guest. SR-IOV is a specification that allows a **Peripheral Component
    Interconnect Expres**s (**PCIe** ) device to appear as multiple separate physical
    devices that can be shared between many virtual machines on the same host, bypassing
    the hypervisor layer, thus achieving native network speeds. Cloud providers such
    as Amazon AWS expose this feature for its EC2 compute instances through API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to complete this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A physical host with NIC that supports SR-IOV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `802.1Qbh` capable switch with connection to the physical server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU with either the Intel VT-d or AMD IOMMU extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux host with `libvirt` installed, ready-to-provision KVM instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up a new PCI passthrough network follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enumerate all devices on the host OS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'List all PCI `Ethernet` adapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain more information about NIC that the `eth1` device is using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the domain, bus, slot, and function values to hexadecimal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `libvirt` network definition file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Define, start, and enable autostarting on the new `libvirt` network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the XML definition for the KVM guest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'List the **Virtual Functions** (**VFs**) provided by SR-IOV NIC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to directly attach PCI NIC from the host OS to the guest VM, we first
    need to gather some hardware information about the device, such as domain, bus,
    slot, and function IDs. In step 1, we collect information about all available
    devices on the host server. We are interested in using the eth1 network interface
    for this example; therefore, we note down the unique PCI identification from the
    output--`pci_0000_03_00_1` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm this is indeed NIC we would like to expose to the guest, we list
    all PCI devices in step 2\. From the output, we can see that the PCI ID is the
    same `03:00.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the PCI ID from step 1, we proceed to collect more information about NIC
    in step 3\. Note that `0000_03_00_1 ID` is broken down into domain ID, bus ID,
    slot ID, and function ID, as shown by the XML attributes. We are going to use
    those IDs in step 7; however, we need to convert them to hexadecimals first, which
    we do in step 4.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 5 and 6, we define a new `libvirt` network for our guest, start the
    network, and enable autostarting in case the host server restarts. If you completed
    the other recipes in this chapter, you should be already familiar with most of
    the attributes in the XML definition file for the network we just created. The
    `hostdev` mode defined in the `<forward>` attribute is what instructs `libvirt`
    that the new network is going to use PCI passthrough. The `managed=yes` parameter,
    as specified in the `<forward>` attribute, tells `libvirt` to first detach the
    PCI device from the host before passing it on to the guest and reattaching it
    back to the host after the guest terminates. Finally, the `<pf>` subelement specifies
    the physical interface that will be virtualized and presented to the guest.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the available XML attributes, please refer to [http://libvirt.org/formatdomain.html](http://libvirt.org/formatdomain.html).
  prefs: []
  type: TYPE_NORMAL
- en: In step 7, we edit the XML definition of the KVM instance, specifying the PCI
    IDs we obtained in step 3 and defined an interface that will use the new PCI passthrough
    network we created in steps 5 and 6.
  prefs: []
  type: TYPE_NORMAL
- en: We restart the KVM instance in step 8 and finally verify that the physical PCI
    NIC device is now part of the new passthrough network we defined earlier. Note
    the presence of multiple PCI type devices. This is because the PCI passthrough
    device we are using supports SR-IOV. All KVM guests that will use this network
    will now be able to directly use the host NIC by assigning one of the listed virtual
    PCI devices.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating network interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libvirt provides a handy way to manage network interfaces on the host through the
    already familiar XML definition syntax. We can use the `virsh` command to define,
    provision, and delete Linux bridges and obtain more information about existing
    network interfaces, as you've already seen in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to define a new Linux bridge, create it, and finally
    remove it using `virsh`. If you recall from earlier recipes, we can manipulate
    the Linux bridge through utilities such as `brctl`. With libvirt, however, we
    have a way to control this programmatically by writing the definition file and
    using the API bindings, as we'll see in [Chapter 7](part0248.html#7CGBG0-c1e587dcccb14690b55c247c1809e6ce)*,
    Using Python to Build and Manage KVM Instances*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `libvirt` package installed on the host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux host with the bridge kernel module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new bridge interface using libvirt, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new bridge interface configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the new interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'List all interfaces libvirt knows about:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the new bridge interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'List all bridge devices on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the active network configuration of the new bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the MAC address of bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the name of the bridge based by providing its MAC address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Destroy the interface, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 1, we write the XML definition for the new network interface. We specify
    bridge as the type, an IP address for the interface, and optionally a MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 2 and 3, we define the new bridge interface and list it. Defining an
    interface does not automatically make it active, so we activate it in step 4.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the bridge creates the actual interface on the host, as shown in
    step 5.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we confirm that the IP and MAC address assigned to the bridge are indeed
    what we specified in step 1.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 7 and 8, we obtain both the name and MAC address using the `virsh`
    utility and finally, in step 9, we remove the `bridge` interface.
  prefs: []
  type: TYPE_NORMAL
