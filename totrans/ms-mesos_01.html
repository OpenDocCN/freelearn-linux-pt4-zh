<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Introducing Mesos"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introducing Mesos</h1></div></div></div><p>Apache Mesos is open source, distributed cluster management software that came out of AMPLab, UC Berkeley in 2011. It abstracts CPU, memory, storage, and other computer resources away from machines (physical or virtual), enabling fault-tolerant and elastic distributed systems to be easily <a class="indexterm" id="id0"/>built and run effectively. It is referred to as a <span class="strong"><strong>metascheduler</strong></span> (scheduler of schedulers) and a "distributed systems kernel/distributed datacenter OS".</p><p>It improves resource utilization, simplifies system administration, and supports a wide variety of distributed applications that can be deployed by leveraging its pluggable architecture. It is scalable and efficient and provides a host of features, such as resource isolation and high availability, which, along with a strong and vibrant open source community, makes this one of the most exciting projects.</p><p>We will cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to the datacenter OS and architecture of Mesos</li><li class="listitem" style="list-style-type: disc">Introduction to frameworks</li><li class="listitem" style="list-style-type: disc">Attributes, resources and resource scheduling, allocation, and isolation</li><li class="listitem" style="list-style-type: disc">Monitoring and APIs provided by Mesos</li><li class="listitem" style="list-style-type: disc">Mesos in production</li></ul></div><div class="section" title="Introduction to the datacenter OS and architecture of Mesos"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction to the datacenter OS and architecture of Mesos</h1></div></div></div><p>Over the past decade, datacenters have graduated from packing multiple applications into a single server box to having large datacenters that aggregate thousands of servers to serve as a massively distributed computing infrastructure. With the advent of virtualization, microservices, cluster computing, and hyperscale infrastructure, the need of the hour is the creation of an application-centric enterprise that follows a software-defined datacenter strategy.</p><p>Currently, server clusters are predominantly managed individually, which can be likened to having multiple operating systems on the PC, one each for processor, disk drive, and so on. With an abstraction model that treats these machines as individual entities being managed in isolation, the ability of the datacenter to effectively build and run distributed applications is greatly reduced.</p><p>Another way of looking at the situation is comparing running applications in a datacenter to running them on a laptop. One major difference is that while launching a text editor or web browser, we are not required to check which memory modules are free and choose ones that suit our need. Herein lies the significance of a platform that acts like a host operating system and allows multiple users to run multiple applications simultaneously by utilizing a shared set of resources.</p><p>Datacenters now run varied distributed application workloads, such as Spark, Hadoop, and so on, and need the capability to intelligently match resources and applications. The datacenter ecosystem today has to be equipped to manage and monitor resources and efficiently distribute workloads across a unified pool of resources with the agility and ease to cater to a diverse user base (noninfrastructure teams included). A datacenter OS brings to the table a comprehensive and sustainable approach to resource management and monitoring. This not only reduces the cost of ownership but also allows a flexible handling of resource requirements in a manner that isolated datacenter infrastructure cannot support.</p><p>The idea behind a datacenter OS is that of intelligent software that sits above all the hardware in a datacenter and ensures efficient and dynamic resource sharing. Added to this is the capability to constantly monitor resource usage and improve workload and infrastructure management in a seamless way that is not tied to specific application requirements. In its absence, we have a scenario with silos in a datacenter that force developers to build software catering to machine-specific characteristics and make the moving and resizing of applications a highly cumbersome procedure.</p><p>The datacenter OS acts as a software layer that aggregates all servers in a datacenter into one giant supercomputer to deliver the benefits of multilatency, isolation, and resource control across all microservice applications. Another major advantage is the elimination of human-induced error during the continual assigning and reassigning of virtual resources.</p><p>From a developer's perspective, this will allow them to easily and safely build distributed applications without restricting them to a bunch of specialized tools, each catering to a specific set of requirements. For instance, let's consider the case of Data Science teams who develop analytic applications that are highly resource intensive. An operating system that can simplify how the resources are accessed, shared, and distributed successfully alleviates their concern about reallocating hardware every time the workloads change.</p><p>Of key importance is the relevance of the datacenter OS to DevOps, primarily a software development approach that emphasizes automation, integration, collaboration, and communication between traditional software developers and other IT professionals. With a datacenter OS that effectively transforms individual servers into a pool of resources, DevOps teams can focus on accelerating development and not continuously worry about infrastructure issues.</p><p>In a world where distributed computing becomes the norm, the datacenter OS is a boon in disguise. With freedom from manually configuring and maintaining individual machines and applications, system engineers need not configure specific machines for specific applications as all applications would be capable of running on any available resources from any machine, even if there are other applications already running on them. Using a datacenter OS results in centralized control and smart utilization of resources that eliminate hardware and software silos to ensure greater accessibility and usability even for noninfrastructural professionals.</p><p>Examples of some organizations administering their hyperscale datacenters via the datacenter OS are Google with the Borg (and next generation Omega) systems. The merits of the datacenter OS are undeniable, with benefits ranging from the scalability of computing resources and flexibility to support data sharing across applications to saving team effort, time, and money while launching and managing interoperable cluster applications.</p><p>It is this vision of transforming the datacenter into a single supercomputer that Apache Mesos seeks to achieve. Born out of a Berkeley AMPLab research paper in 2011, it has since come a long way with a number of leading companies, such as Apple, Twitter, Netflix, and AirBnB among others, using it in production. Mesosphere is a start-up that is developing a distributed OS product with Mesos at its core.</p></div></div>
<div class="section" title="The architecture of Mesos"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The architecture of Mesos</h1></div></div></div><p>Mesos is an open-source platform for sharing clusters of commodity servers between different distributed applications (or frameworks), such as Hadoop, Spark, and Kafka among others. The idea is to act as a centralized cluster manager by pooling together all the physical resources<a class="indexterm" id="id1"/> of the cluster and making it available as a single reservoir of highly available resources for all the different frameworks to utilize. For example, if an organization has one 10-node cluster (16 CPUs and 64 GB RAM) and another 5-node cluster (4 CPUs and 16 GB RAM), then Mesos can be leveraged to pool them into one virtual cluster of 720 GB RAM and 180 CPUs, where multiple distributed applications can be run. Sharing resources in this fashion greatly improves cluster utilization and eliminates the need for an expensive data replication process per-framework.</p><p>Some of the important features of Mesos are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scalability</strong></span>: It can elastically scale to over 50,000 nodes</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resource isolation</strong></span>: This is achieved through Linux/Docker containers</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Efficiency</strong></span>: This is achieved through CPU and memory-aware resource scheduling across multiple frameworks</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>High availability</strong></span>: This is through Apache ZooKeeper</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Monitoring Interface</strong></span>: A Web UI for monitoring the cluster state</li></ul></div><p>Mesos is based on the same principles as the Linux kernel and aims to provide a highly available, scalable, and fault-tolerant base for enabling various frameworks to share cluster resources effectively and in isolation. Distributed applications are varied and continuously evolving, a fact that leads Mesos design philosophy towards a thin interface that allows an efficient resource allocation between different frameworks and delegates the task of scheduling and job execution to the frameworks themselves. The two advantages of doing so are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Different frame data replication works can independently devise methods to address their data locality, fault-tolerance, and other such needs</li><li class="listitem" style="list-style-type: disc">It simplifies the Mesos codebase and allows it to be scalable, flexible, robust, and agile</li></ul></div><p>Mesos' architecture hands over the responsibility of scheduling tasks to the respective frameworks by employing a resource offer abstraction that packages a set of resources and makes offers to each framework. The Mesos master node decides the quantity of resources to offer each framework, while each framework decides which resource offers to accept and which tasks to execute on these accepted resources. This method of resource allocation is shown to achieve a good degree of data locality for each framework sharing the same cluster.</p><p>An alternative architecture would implement a global scheduler that took framework requirements, organizational priorities, and resource availability as inputs and provided a task schedule breakdown by framework and resource as output, essentially acting as a matchmaker for jobs and resources with priorities acting as constraints. The challenges with this architecture, such as developing a robust API that could capture all the varied requirements of different frameworks, anticipating new frameworks, and solving a complex scheduling problem for millions of jobs, made the former approach a much more attractive option for the creators.</p></div>
<div class="section" title="Introduction to frameworks"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Introduction to frameworks</h1></div></div></div><p>A Mesos framework <a class="indexterm" id="id2"/>sits between Mesos and the application and acts as a layer to manage task scheduling and execution. As its implementation is application-specific, the term is often used to refer to the application itself. Earlier, a Mesos framework could interact with the Mesos API using only the libmesos C++ library, due to which other language bindings were developed for Java, Scala, Python, and Go among others that leveraged libmesos heavily. Since v0.19.0, the changes made to the HTTP-based<a class="indexterm" id="id3"/> protocol enabled developers to develop frameworks using the language they wanted without having to rely on the C++ code. A framework consists of two components: a) Scheduler and b) Executor.</p><p>
<span class="strong"><strong>Scheduler</strong></span> is responsible for making decisions on the resource offers made to it and tracking the current state of the cluster. Communication with the Mesos master is handled by the <span class="strong"><strong>SchedulerDriver</strong></span> module, which registers the framework with the master, launches tasks, and passes messages to other components.</p><p>The second component, <span class="strong"><strong>Executor</strong></span>, is responsible, as its name suggests, for the execution of tasks on slave nodes. Communication with the slaves is handled by the <span class="strong"><strong>ExecutorDriver</strong></span> module, which is also responsible for sending status updates to the scheduler.</p><p>The Mesos API, discussed later in this chapter, allows programmers to develop their own custom frameworks that can run on top of Mesos. Some other features of frameworks, such as authentication, authorization, and user management, will be discussed at length in <a class="link" href="ch06.html" title="Chapter 6. Mesos Frameworks">Chapter 6</a>, <span class="emphasis"><em>Mesos Frameworks</em></span>.</p><div class="mediaobject"><img alt="Introduction to frameworks" src="graphics/B05186_01_01.jpg"/></div><div class="section" title="Frameworks built on Mesos"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Frameworks built on Mesos</h2></div></div></div><p>A list of some <a class="indexterm" id="id4"/>of the services and frameworks built on Mesos is given here. This<a class="indexterm" id="id5"/> list is not exhaustive, and support for new frameworks is added almost every day. You can also refer to <a class="ulink" href="http://mesos.apache.org/documentation/latest/frameworks/">http://mesos.apache.org/documentation/latest/frameworks/</a> apart from the following<a class="indexterm" id="id6"/> list:</p><div class="section" title="Long-running services"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Long-running services</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Aurora</strong></span>: This is a service scheduler that runs on top of Mesos, enabling you to run long-running <a class="indexterm" id="id7"/>services that take advantage of the scalability, fault-tolerance, and resource<a class="indexterm" id="id8"/> isolation of Mesos.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Marathon</strong></span>: This is a <a class="indexterm" id="id9"/>private PaaS built on Mesos. It automatically handles hardware or software failures and ensures that an app is "always on".</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Singularity</strong></span>: This is a <a class="indexterm" id="id10"/>scheduler (the HTTP API and web interface) for running Mesos tasks, such as long-running processes, one-off tasks, and scheduled jobs.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SSSP</strong></span>: This is a simple web <a class="indexterm" id="id11"/>application that provides a "Megaupload" white label to store and share files in S3.</li></ul></div></div><div class="section" title="Big data processing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Big data processing</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cray Chapel is a productive <a class="indexterm" id="id12"/>parallel programming language. The <a class="indexterm" id="id13"/>Chapel Mesos scheduler lets you run Chapel programs on Mesos.</li><li class="listitem" style="list-style-type: disc">Dark is a Python<a class="indexterm" id="id14"/> clone of Spark, a MapReduce-like framework written in Python and running on Mesos.</li><li class="listitem" style="list-style-type: disc">Exelixi is a distributed<a class="indexterm" id="id15"/> framework used to<a class="indexterm" id="id16"/> run genetic algorithms at scale.</li><li class="listitem" style="list-style-type: disc">Hadoop <a class="indexterm" id="id17"/>Running Hadoop on Mesos distributes MapReduce jobs efficiently across an entire cluster.</li><li class="listitem" style="list-style-type: disc">Hama is a <a class="indexterm" id="id18"/>distributed computing framework based on Bulk Synchronous Parallel computing techniques for massive scientific computations—for example, matrix, graph, and network algorithms.</li><li class="listitem" style="list-style-type: disc">MPI is a <a class="indexterm" id="id19"/>message-passing system designed to function on a wide variety of parallel computers.</li><li class="listitem" style="list-style-type: disc">Spark is a fast <a class="indexterm" id="id20"/>and general-purpose cluster computing system that makes parallel jobs easy to write.</li><li class="listitem" style="list-style-type: disc">Storm is a distributed real-time computation system. Storm makes it easy to reliably process<a class="indexterm" id="id21"/> unbounded streams of data, doing for real-time processing what Hadoop does for batch processing.</li></ul></div></div><div class="section" title="Batch scheduling"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Batch scheduling</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Chronos is a distributed job scheduler that supports complex job topologies. It can be used as a more<a class="indexterm" id="id22"/> fault-tolerant<a class="indexterm" id="id23"/> replacement for cron.</li><li class="listitem" style="list-style-type: disc">Jenkins is a <a class="indexterm" id="id24"/>continuous integration server. The Mesos-Jenkins plugin allows it to dynamically launch workers on a Mesos cluster, depending on the workload.</li><li class="listitem" style="list-style-type: disc">JobServer is a <a class="indexterm" id="id25"/>distributed job scheduler and processor that allows developers to build custom batch processing Tasklets using a point and click Web UI.</li></ul></div></div><div class="section" title="Data storage"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Data storage</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cassandra is<a class="indexterm" id="id26"/> a performant and highly available distributed<a class="indexterm" id="id27"/> database. Linear scalability and proven fault-tolerance on commodity hardware or cloud infrastructure make it the perfect platform for mission-critical data.</li><li class="listitem" style="list-style-type: disc">Elasticsearch is a <a class="indexterm" id="id28"/>distributed search engine. Mesos makes it easy for it to run and scale.</li></ul></div></div></div></div>
<div class="section" title="The attributes and resources of Mesos"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>The attributes and resources of Mesos</h1></div></div></div><p>Mesos <a class="indexterm" id="id29"/>describes the slave nodes<a class="indexterm" id="id30"/> present in the cluster by the following two methods:</p><div class="section" title="Attributes"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Attributes</h2></div></div></div><p>Attributes are used to <a class="indexterm" id="id31"/>describe certain additional information regarding the slave node, such as its OS version, whether it has a particular type of hardware, and so on. They are expressed as key-value pairs with support for three different value types—scalar, range, and text—that are sent along with the offers to frameworks. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">attributes : attribute ( ";" attribute )*

attribute : text ":" ( scalar | range | text )</pre></div></div><div class="section" title="Resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Resources</h2></div></div></div><p>Mesos can manage<a class="indexterm" id="id32"/> three different types of resources: scalars, ranges, and sets. These are used to represent the different resources that a Mesos slave has to offer. For example, a scalar resource type could be used to represent the amount of CPU on a slave. Each resource is identified by a key string, as follows:</p><div class="informalexample"><pre class="programlisting">resources : resource ( ";" resource )*

resource : key ":" ( scalar | range | set )

key : text ( "(" resourceRole ")" )?

resourceRole : text | "*"</pre></div><p>Predefined uses and conventions</p><p>The Mesos<a class="indexterm" id="id33"/> master predefines how it handles the following list of resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">cpus</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mem</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">disk</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ports</code></li></ul></div><p>In particular, a slave without the <code class="literal">cpu</code> and <code class="literal">mem</code> resources will never have its resources advertised to any frameworks. Also, the master's user interface interprets the scalars in <code class="literal">mem</code> and <code class="literal">disk</code> in terms of MB. For example, the value <code class="literal">15000</code> is displayed as <code class="literal">14.65GB</code>.</p><div class="section" title="Examples"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Examples</h3></div></div></div><p>Here are some examples<a class="indexterm" id="id34"/> of configuring the Mesos slaves:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">resources='cpus:24;mem:24576;disk:409600;ports:[21000-24000];bugs:{a,b,c}'</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">attributes='rack:abc;zone:west;os:centos5;level:10;keys:[1000-1500]'</code></li></ul></div><p>In this case, we have three different types of resources, scalars, a range, and a set. They are called <code class="literal">cpus</code>, <code class="literal">mem</code>, and <code class="literal">disk</code>, and the range type is <code class="literal">ports</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A scalar called <code class="literal">cpus</code> with the value <code class="literal">24</code></li><li class="listitem" style="list-style-type: disc">A scalar called <code class="literal">mem</code> with the value <code class="literal">24576</code></li><li class="listitem" style="list-style-type: disc">A scalar called <code class="literal">disk</code> with the value <code class="literal">409600</code></li><li class="listitem" style="list-style-type: disc">A range called <code class="literal">ports</code> with values <code class="literal">21000</code> through <code class="literal">24000</code> (inclusive)</li><li class="listitem" style="list-style-type: disc">A set called <code class="literal">bugs</code> with the values <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code></li></ul></div><p>In the case of attributes, we will end up with three attributes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">rack</code> attribute with<a class="indexterm" id="id35"/> the text value <code class="literal">abc</code></li><li class="listitem" style="list-style-type: disc">A <code class="literal">zone</code> attribute<a class="indexterm" id="id36"/> with the text value <code class="literal">west</code></li><li class="listitem" style="list-style-type: disc">An <code class="literal">os</code> attribute with the<a class="indexterm" id="id37"/> text value <code class="literal">centos5</code></li><li class="listitem" style="list-style-type: disc">A <code class="literal">level</code> attribute <a class="indexterm" id="id38"/>with the scalar value <code class="literal">10</code></li><li class="listitem" style="list-style-type: disc">A <code class="literal">keys</code> attribute <a class="indexterm" id="id39"/>with range values <code class="literal">1000</code> through <code class="literal">1500</code> (inclusive)</li></ul></div></div></div></div>
<div class="section" title="Two-level scheduling"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Two-level scheduling</h1></div></div></div><p>Mesos has a two-level <a class="indexterm" id="id40"/>scheduling mechanism to allocate resources to and launch tasks on different frameworks. In the first level, the master process that manages slave processes running on each node in the Mesos cluster determines the free resources available on each node, groups them, and offers them to different frameworks based on organizational policies, such as priority or fair sharing. Organizations have the ability to define their own sharing policies via a custom allocation module as well. </p><p>In the second level, each framework's scheduler component that is registered as a client with the master accepts or rejects the resource offer made depending on the framework's requirements. If the offer is accepted, the framework's scheduler sends information regarding the tasks that need to be executed and the number of resources that each task requires to the Mesos master. The master transfers the tasks to the corresponding slaves, which assign the necessary resources to the framework's executor component, which manages the execution of all the required tasks in containers. When the tasks are completed, the containers are dismantled, and the resources are freed up for use by other tasks.</p><p>The following diagram and <a class="indexterm" id="id41"/>explanation from the Apache Mesos documentation (<a class="ulink" href="http://mesos.apache.org/documentation/latest/architecture/">http://mesos.apache.org/documentation/latest/architecture/</a>) explains this concept in more detail:</p><div class="mediaobject"><img alt="Two-level scheduling" src="graphics/B05186_01_02.jpg"/></div><p>Let's have a look at the<a class="indexterm" id="id42"/> pointers mentioned in the preceding diagram:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>1</strong></span>: Slave 1 reports to the master that it has four CPUs and 4 GB of memory free. The master then invokes the allocation module, which tells it that Framework 1 should be offered all the available resources.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>2</strong></span>: The master sends a resource offer describing these resources to Framework 1.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>3</strong></span>: The framework's scheduler replies to the master with information about two tasks to run on the slave using two CPUs and 1 GB RAM for the first task and one CPU and 2 GB RAM for the second task.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>4</strong></span>: The master sends the tasks to the slave, which allocates appropriate resources to the framework's executor, which in turn launches the two tasks. As one CPU and 1 GB of RAM are still free, the allocation module may now offer them to Framework 2. In addition, this resource offers process repeats when tasks finish and new resources become free.</li></ul></div><p>Mesos also provides frameworks with the ability to reject resource offers. A framework can reject the offers that do not meet its requirements. This allows frameworks to support a wide variety of complex resource constraints while keeping Mesos simple at the same time. A policy called <a class="indexterm" id="id43"/>
<span class="strong"><strong>delay scheduling</strong></span>, in which frameworks wait for a finite time to get access to the nodes storing their input data, gives a fair level of data locality albeit with a slight latency tradeoff.</p><p>If the framework<a class="indexterm" id="id44"/> constraints are complex, it is possible that a framework might need to wait before it receives a suitable resource offer that meets its requirements. To tackle this, Mesos allows frameworks to set filters specifying the criteria that they will use to always reject certain resources. A framework can set a filter stating that it can run only on nodes with at least 32 GB of RAM space free, for example. This allows it to bypass the rejection process, minimizes communication overheads, and thus reduces overall latency.</p></div>
<div class="section" title="Resource allocation"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Resource allocation</h1></div></div></div><p>The resource<a class="indexterm" id="id45"/> allocation module contains the policy that the Mesos master uses to determine the type and quantity of resource offers that need to be made to each framework. Organizations can customize it to implement their own allocation policy—for example, fair sharing, priority, and so on—which allows for fine-grained resource sharing. Custom allocation modules can be developed to address specific needs.</p><p>The resource allocation module is responsible for making sure that resources are shared in a fair manner among competing frameworks. The choice of algorithm used to determine the sharing policy has a great bearing on the efficiency of a cluster manager. One of the most popular allocation algorithms, max-min fairness, and its weighted derivative are described in the following section.</p><div class="section" title="Max-min fair share algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Max-min fair share algorithm</h2></div></div></div><p>Imagine a set of <a class="indexterm" id="id46"/>sources (1, 2, ..., m) that has resource demands x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>m</sub>. Let the total number of resources be R. We will initially give <span class="emphasis"><em>R</em></span>/<span class="emphasis"><em>m</em></span> of the resource to each of the <span class="emphasis"><em>m</em></span> sources. Now, starting with the source with the least demand, we will compare the allocation to the actual demand. If initial allocation (<span class="emphasis"><em>R</em></span>/<span class="emphasis"><em>m</em></span>) is more than the demand requirements of source 1, we will redistribute the excess resources equally among the remaining sources. We will then compare the new allocation to the actual demand of the source with the second-lowest demand and continue the process as before. The process ends when each source gets allocated resources that are less than or equal to its actual demand. If any source gets allocated resources less than what it actually needs, the algorithm ensures that no other source can get more resources than such a source. Such an allocation is called a max-min fair share allocation because it maximizes the minimum share of sources whose demands are not met.</p><p>Consider the following example:</p><p>How to compute the max-min fair allocation for a set of four sources, <span class="emphasis"><em>S1</em></span>, <span class="emphasis"><em>S2</em></span>, <span class="emphasis"><em>S3</em></span>, and <span class="emphasis"><em>S4</em></span>, with demands 2, 2.5, 4, and 5, respectively, when the resource has an overall capacity of 10.</p><p>Following the methodology described earlier, to solve this, we will tentatively divide the resource into four portions of size 2.5 each. Next, we will compare this allocation with the actual demand of the source with the least demand (in this case, <span class="emphasis"><em>S1</em></span>). As the allocation is greater than the actual demand, the excess 0.5 is divided equally among the remaining three sources, <span class="emphasis"><em>S2</em></span>, <span class="emphasis"><em>S3</em></span>, and <span class="emphasis"><em>S4</em></span>, giving them 2.666 each. Continuing the process, we will note that the new allocation is greater than the actual demand of source <span class="emphasis"><em>S2</em></span>. The excess 0.166 is again divided evenly among the remaining two sources <span class="emphasis"><em>S3</em></span> and <span class="emphasis"><em>S4</em></span>, giving them <span class="emphasis"><em>2.666 + 0.084 = 2.75</em></span> each. The allocation for each of the sources is now less than or equal to the actual <a class="indexterm" id="id47"/>demand, so the process is stopped here. The final allocation is, therefore, <span class="emphasis"><em>S1 – 2</em></span>, <span class="emphasis"><em>S2 – 2.5</em></span>, <span class="emphasis"><em>S3 – 2.75</em></span>, and <span class="emphasis"><em>S4 – 2.75</em></span>.</p><p>This works well in a homogenous environment—that is, one where resource requirements are fairly proportional between different competing users, such as a Hadoop cluster. However, scheduling resources across frameworks with heterogeneous resource demands poses a more complex challenge. What is a suitable fair share allocation policy if user A runs tasks that require two CPUs and 8 GB RAM each and user B runs tasks that require four CPUs and 2 GB RAM each? As can be noted, user A's tasks are RAM-heavy, while user B's tasks are CPU-heavy. How, then, should a set of combined RAM and CPU resources be distributed between the two users?</p><p>The latter scenario is a common one faced by Mesos, designed as it is to manage resources primarily in a heterogeneous environment. To address this, Mesos has the <span class="strong"><strong>Dominant Resource Fairness</strong></span> algorithm (<span class="strong"><strong>DRF</strong></span>) as its default resource allocation policy, which is far more suitable for heterogeneous environments. The algorithm and its role in efficient resource allocation will be discussed in more detail in the next chapter.</p></div></div>
<div class="section" title="Resource isolation"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Resource isolation</h1></div></div></div><p>One of the key<a class="indexterm" id="id48"/> requirements of a cluster manager is to ensure that the allocation of resources to a particular framework does not have an impact on any active running jobs of some other framework. Provision for isolation mechanisms on slaves to compartmentalize different tasks is thus a key feature of Mesos. Containers are leveraged for resource isolation with a pluggable architecture. The Mesos slave uses the Containerizer API to provide an isolated environment to run a framework's executor and its corresponding tasks. The Containerizer API's objective is to support a wide range of implementations, which implies that custom containerizers and isolators can be developed. When a slave process starts, the containerizer to be used to launch containers and a set of isolators to enforce the resource constraints can be specified.</p><p>The Mesos Containerizer API provides a resource isolation of framework executors using Linux-specific functionality, such as control groups and namespaces. It also provides basic support for POSIX systems (only resource usage reporting and not actual isolation). This important topic will be explored at length in subsequent chapters.</p><p>Mesos also provides <a class="indexterm" id="id49"/>network isolation at a container level to prevent a single framework from capturing all the available network bandwidth or ports. This is not supported by default, however, and additional dependencies need to be installed and configured in order to activate this feature.</p></div>
<div class="section" title="Monitoring in Mesos"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Monitoring in Mesos</h1></div></div></div><p>In this section, we <a class="indexterm" id="id50"/>will take a look at the different metrics that Mesos provides to <a class="indexterm" id="id51"/>monitor the various components.</p><div class="section" title="Monitoring provided by Mesos"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Monitoring provided by Mesos</h2></div></div></div><p>Mesos master and slave nodes provide rich data that enables resource utilization monitoring and anomaly detection. The information includes details about available resources, used resources, registered frameworks, active slaves, and task state. This can be used to create<a class="indexterm" id="id52"/> automated alerts and develop a cluster health monitoring dashboard. More details can be found here:</p><p>
<a class="ulink" href="http://mesos.apache.org/documentation/latest/monitoring/">http://mesos.apache.org/documentation/latest/monitoring/</a>.</p><p>Network statistics for each active container are published through the <code class="literal">/monitor/statistics.json</code> endpoint on the slave.</p><div class="section" title="Types of metrics"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Types of metrics</h3></div></div></div><p>Mesos provides two<a class="indexterm" id="id53"/> different kinds of metrics: counters and gauges. These can<a class="indexterm" id="id54"/> be explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Counters</strong></span>: This is<a class="indexterm" id="id55"/> used to measure discrete events, such as the number of finished tasks or invalid status updates. The values are always whole numbers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Gauges</strong></span>: This is<a class="indexterm" id="id56"/> used to check the snapshot of a particular metric, such as the number of active frameworks or running tasks at a particular time.</li></ul></div></div></div></div>
<div class="section" title="The Mesos API"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>The Mesos API</h1></div></div></div><p>Mesos provides an <a class="indexterm" id="id57"/>API to allow developers to build custom frameworks that can run on top of the underlying distributed infrastructure. The detailed steps involved in developing bespoke frameworks leveraging this API and the new HTTP API will be explored in detail in <a class="link" href="ch06.html" title="Chapter 6. Mesos Frameworks">Chapter 6</a>, <span class="emphasis"><em>Mesos Frameworks</em></span>.</p><div class="section" title="Messages"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Messages</h2></div></div></div><p>Mesos implements an actor-style message-passing programming model to enable nonblocking <a class="indexterm" id="id58"/>communication between different Mesos components and leverages protocol buffers for the same. For example, a scheduler needs to tell the executor to utilize a certain number of resources, an executor needs to provide status updates to the scheduler regarding the tasks that are executed, and so on. Protocol buffers provide the required flexible message delivery mechanism to enable this communication by allowing developers to define custom formats and protocols that can be used across different languages. For more details regarding the messages that are passed between different <a class="indexterm" id="id59"/>Mesos components, refer to <a class="ulink" href="https://github.com/apache/mesos/blob/master/include/mesos/mesos.proto">https://github.com/apache/mesos/blob/master/include/mesos/mesos.proto</a>
</p></div><div class="section" title="API details"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>API details</h2></div></div></div><p>A brief description <a class="indexterm" id="id60"/>of the different APIs and methods that Mesos provides is provided in the following section:</p><div class="section" title="Executor API"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Executor API</h3></div></div></div><p>A brief description <a class="indexterm" id="id61"/>of the Executor API is given below. For more<a class="indexterm" id="id62"/> details, visit <a class="ulink" href="http://mesos.apache.org/api/latest/java/org/apache/mesos/Executor.html">http://mesos.apache.org/api/latest/java/org/apache/mesos/Executor.html</a>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">registered</code>: This<a class="indexterm" id="id63"/> can be registered via the following code:<div class="informalexample"><pre class="programlisting">void registered(ExecutorDriver driver,
  ExecutorInfo executorInfo,
  FrameworkInfo frameworkInfo,
  SlaveInfo slaveInfo)</pre></div><p>This code is<a class="indexterm" id="id64"/> invoked once the executor driver is able to successfully connect with Mesos. In particular, a scheduler can pass some data to its executors through the <code class="literal">ExecutorInfo.getData()</code> field.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the executor driver that was registered and connected to the Mesos cluster</li><li class="listitem" style="list-style-type: disc"><code class="literal">executorInfo</code>: This describes information about the executor that was registered</li><li class="listitem" style="list-style-type: disc"><code class="literal">frameworkInfo</code>: This describes the framework that was registered</li><li class="listitem" style="list-style-type: disc"><code class="literal">slaveInfo</code>: This describes the slave that will be used to launch the tasks for this executor</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">reregistered</code>: This <a class="indexterm" id="id65"/>can be <span class="emphasis"><em>reregistered</em></span> as follows:<div class="informalexample"><pre class="programlisting">void reregistered(ExecutorDriver driver,
  SlaveInfo slaveInfo)</pre></div><p>This code is invoked when the executor reregisters with a restarted slave.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the executor driver that was reregistered with the Mesos master</li><li class="listitem" style="list-style-type: disc"><code class="literal">slaveInfo</code>: This describes the slave that will be used to launch the tasks for this executor</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">disconnected</code>: This can <a class="indexterm" id="id66"/>be disconnected via the following code:<div class="informalexample"><pre class="programlisting">void disconnected(ExecutorDriver driver)</pre></div><p>The preceding code is invoked when the executor gets "disconnected" from the slave—for example, when the slave is restarted due to an upgrade).</p><p>The following is the parameter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the executor driver that was disconnected.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">launchTask</code>: Take a<a class="indexterm" id="id67"/> look at the following code:<div class="informalexample"><pre class="programlisting">void launchTask(ExecutorDriver driver,
  TaskInfo task)</pre></div><p>The preceding code is invoked when a task is launched on this executor (initiated via <code class="literal">SchedulerDriver.launchTasks(java.util.Collection&lt;OfferID&gt;, java.util.Collection&lt;TaskInfo&gt;, Filters</code>). Note that this task can be realized with a thread, a process, or some simple computation; however, no other callbacks will be invoked on this executor until this callback<a class="indexterm" id="id68"/> returns.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the executor driver that launched the task</li><li class="listitem" style="list-style-type: disc"><code class="literal">task</code>: This describes the task that was launched</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">killTask</code>: Run the following code:<div class="informalexample"><pre class="programlisting">void killTask(ExecutorDriver driver,
  TaskID taskId)</pre></div><p>This is invoked <a class="indexterm" id="id69"/>when a task running within this executor is killed via <code class="literal">SchedulerDriver.killTask</code> (TaskID). Note that no status update will be sent on behalf of the executor, and the executor is responsible for creating a new <code class="literal">TaskStatus</code> protobuf message (that is, with <code class="literal">TASK_KILLED</code>) and invoking <code class="literal">ExecutorDriver.sendStatusUpdate</code> (<code class="literal">TaskStatus</code>).</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the executor driver that owned the task that was killed</li><li class="listitem" style="list-style-type: disc"><code class="literal">taskId</code>: This is the ID of the task that was killed</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">frameworkMessage</code>: Run<a class="indexterm" id="id70"/> the following code:<div class="informalexample"><pre class="programlisting">void frameworkMessage(ExecutorDriver driver,
  byte[] data)</pre></div><p>This is invoked when a framework message arrives for this executor. These messages are the best effort; do not expect a framework message to be retransmitted in any reliable fashion.</p><p> The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the executor driver that received the message</li><li class="listitem" style="list-style-type: disc"><code class="literal">data</code>: This is the message payload</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">shutdown</code>: Execute the<a class="indexterm" id="id71"/> following code:<div class="informalexample"><pre class="programlisting">void shutdown(ExecutorDriver driver)</pre></div><p>This is invoked when the executor terminates all of its currently running tasks. Note that after Mesos determines that an executor has terminated, any tasks that the executor did not send Terminal status updates for (for example, <code class="literal">TASK_KILLED</code>, <code class="literal">TASK_FINISHED</code>, <code class="literal">TASK_FAILED</code>, and so on), and a <code class="literal">TASK_LOST</code> status update will be created.</p><p>The following<a class="indexterm" id="id72"/> is the parameter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the executor driver that should terminate.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">error</code>: Run the following:<div class="informalexample"><pre class="programlisting">void error(ExecutorDriver driver,
  java.lang.String message)</pre></div><p>The previous code<a class="indexterm" id="id73"/> is invoked when a fatal error occurs with the executor and/or executor driver. The driver will be aborted BEFORE invoking this callback.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the executor driver that was aborted due to this error</li><li class="listitem" style="list-style-type: disc"><code class="literal">message</code>: This is the error message</li></ul></div></li></ul></div></div><div class="section" title="The Executor Driver API"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>The Executor Driver API</h3></div></div></div><p>A brief description of the<a class="indexterm" id="id74"/> Executor Driver API is given below. For<a class="indexterm" id="id75"/> more details, visit <a class="ulink" href="http://mesos.apache.org/api/latest/java/org/apache/mesos/ExecutorDriver.html">http://mesos.apache.org/api/latest/java/org/apache/mesos/ExecutorDriver.html</a>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">start</code>: Run the<a class="indexterm" id="id76"/> following line:<div class="informalexample"><pre class="programlisting">Status start()</pre></div><p>The preceding code starts the executor driver. This needs to be called before any other driver calls are made.</p><p>The state of the driver after the call is returned.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">stop</code>: Run the<a class="indexterm" id="id77"/> following line:<div class="informalexample"><pre class="programlisting">Status stop()</pre></div><p>This stops the executor driver.</p><p>The state of the driver after the call is the return.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">abort</code>: Run the<a class="indexterm" id="id78"/> following line:<div class="informalexample"><pre class="programlisting">Status abort()</pre></div><p>This aborts the driver so that no more callbacks can be made to the executor. The semantics of abort and stop are deliberately separated so that the code can detect an aborted driver (via the return status of <code class="literal">join()</code>; refer to the following section) and instantiate and start another driver if desired (from within the same process, although this functionality is currently not supported for executors).</p><p>The state of the driver after the call is the return.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">join</code>: Run the following:<div class="informalexample"><pre class="programlisting">Status join()</pre></div><p>This waits<a class="indexterm" id="id79"/> for the driver to be stopped or aborted, possibly blocking the current thread indefinitely. The return status of this function can be used to determine whether the driver was aborted (take a look at <code class="literal">mesos.proto</code> for a description of status).</p><p>The state of the driver after the call is the return.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">run</code>: Take a look <a class="indexterm" id="id80"/>at the following line of code:<div class="informalexample"><pre class="programlisting">Status run()</pre></div><p>This starts and immediately joins (that is, blocks) the driver.</p><p>The state of the driver after the call is the return.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">sendStatusUpdate</code>: Here's the code to execute:<div class="informalexample"><pre class="programlisting">Status sendStatusUpdate(TaskStatus status)</pre></div><p>This sends a<a class="indexterm" id="id81"/> status update to the framework scheduler, retrying as necessary until an acknowledgement is received or the executor is terminated (in which case, a <code class="literal">TASK_LOST</code> status update will be sent). Take a look at <code class="literal">Scheduler.statusUpdate(org.apache.mesos.SchedulerDriver, TaskStatus)</code> for more information about status update acknowledgements.</p><p>The following is the parameter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">status</code>: This is the<a class="indexterm" id="id82"/> status update to send.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The state of the driver after the call is the return.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sendFrameworkMessage</code>: Run the following code:<div class="informalexample"><pre class="programlisting">Status sendFrameworkMessage(byte[] data)</pre></div><p>This sends a<a class="indexterm" id="id83"/> message to the framework scheduler. These messages are sent on a best effort basis and should not be expected to be retransmitted in any reliable fashion.</p><p>The parameters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">data</code>: This is the message payload.</li></ul></div><p>The state of the driver after the call is the return.</p></li></ul></div></div><div class="section" title="The Scheduler API"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>The Scheduler API</h3></div></div></div><p>A brief description of the<a class="indexterm" id="id84"/> Scheduler API is given below. For more<a class="indexterm" id="id85"/> details, visit <a class="ulink" href="http://mesos.apache.org/api/latest/java/org/apache/mesos/Scheduler.html">http://mesos.apache.org/api/latest/java/org/apache/mesos/Scheduler.html</a>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">registered</code>: This can <a class="indexterm" id="id86"/>be registered via the following code:<div class="informalexample"><pre class="programlisting">void registered(SchedulerDriver driver,
  FrameworkID frameworkId,
  MasterInfo masterInfo)</pre></div><p>The preceding is invoked when the scheduler successfully registers with a Mesos master. A unique ID (generated by the master) is used to distinguish this framework from others, and <code class="literal">MasterInfo</code> with the IP and port of the current master are provided as arguments.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the scheduler driver that was registered</li><li class="listitem" style="list-style-type: disc"><code class="literal">FrameworkID</code>: This is the <code class="literal">FrameworkID</code> generated by the master</li><li class="listitem" style="list-style-type: disc"><code class="literal">MasterInfo</code>: This is the information about the current master, including the IP and port.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">reregistered</code>: The preceding code <a class="indexterm" id="id87"/>can be reregistered as follows:<div class="informalexample"><pre class="programlisting">void reregistered(SchedulerDriver driver,
  MasterInfo masterInfo)</pre></div><p>The preceding code is invoked when the scheduler reregisters with a newly elected Mesos master. This is only called when the scheduler is previously registered. <code class="literal">MasterInfo</code> containing the updated information about the elected master is provided as an argument.</p><p>The parameters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the driver that was reregistered</li><li class="listitem" style="list-style-type: disc"><code class="literal">MasterInfo</code>: This is the updated information about the elected master</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">resourceOffers</code>: Execute the following code:<div class="informalexample"><pre class="programlisting">void resourceOffers(SchedulerDriver driver,
  java.util.List&lt;Offer&gt; offers)</pre></div><p>The preceding code is<a class="indexterm" id="id88"/> invoked when resources are offered to this framework. A single offer will only contain resources from a single slave. Resources associated with an offer will not be reoffered to this framework until either; (a) this framework rejects these resources (refer to <code class="literal">SchedulerDriver.launchTasks(java.util.Collection&lt;OfferID&gt;, java.util.Collection&lt;TaskInfo&gt;, Filters)</code>), or (b) these resources are rescinded (refer to <code class="literal">offerRescinded(org.apache.mesos.SchedulerDriver, OfferID)</code>). Note that resources may be concurrently offered to more than one framework at a time, depending on the allocator being used. In this case, the first framework to launch tasks using these resources will be able to use them, while the other frameworks will have these resources rescinded. (Alternatively, if a framework has already launched tasks with these resources, these tasks will fail with a <code class="literal">TASK_LOST</code> status and a message saying as much).</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the<a class="indexterm" id="id89"/> driver that was used to run this scheduler</li><li class="listitem" style="list-style-type: disc"><code class="literal">offers</code>: These are the resources offered to this framework</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">offerRescinded</code>: Run the following code:<div class="informalexample"><pre class="programlisting">void offerRescinded(SchedulerDriver driver,
  OfferID offerId)</pre></div><p>This is invoked<a class="indexterm" id="id90"/> when an offer is no longer valid (for example, the slave is lost or another framework is used resources in the offer). If, for whatever reason, an offer is never rescinded (for example, a dropped message, failing over framework, and so on), a framework that attempts to launch tasks using an invalid offer will receive a <code class="literal">TASK_LOST</code> status update for these tasks (take a look at <code class="literal">resourceOffers(org.apache.mesos.SchedulerDriver, java.util.List&lt;Offer&gt;)</code>).</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the driver that was used to run this scheduler</li><li class="listitem" style="list-style-type: disc"><code class="literal">offerID</code>: This is the ID of the offer that was rescinded</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">statusUpdate</code>: Take a look at the following code:<div class="informalexample"><pre class="programlisting">void statusUpdate(SchedulerDriver driver,
  TaskStatus status)</pre></div><p>The preceding <a class="indexterm" id="id91"/>code is invoked when the status of a task changes (for example, a slave is lost, so the task is lost; a task is finished, and an executor sends a status update saying so; and so on). If, for whatever reason, the scheduler is aborted during this callback or the process exits, then another status update will be delivered. (Note, however, that this is currently not true if the slave sending the status update is lost or fails during this time.)</p><p>The parameters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the driver that was used to run this scheduler</li><li class="listitem" style="list-style-type: disc"><code class="literal">status</code>: This is the status update, which includes the task ID and status</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">frameworkMessage</code>: Take a look at the following code:<div class="informalexample"><pre class="programlisting">void frameworkMessage(SchedulerDriver driver,
  ExecutorID executorId,
  SlaveID slaveId,
  byte[] data)</pre></div><p>The preceding code is invoked when an executor sends a message. These messages are <a class="indexterm" id="id92"/>sent on a best effort basis and should not be expected to be retransmitted in any reliable fashion.</p><p>The parameters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the driver that received the message</li><li class="listitem" style="list-style-type: disc"><code class="literal">ExecutorID</code>: This is the ID of the executor that sent the message</li><li class="listitem" style="list-style-type: disc"><code class="literal">SlaveID</code>: This is the ID of the slave that launched the executor</li><li class="listitem" style="list-style-type: disc"><code class="literal">data</code>: This is the message payload</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">disconnected</code>: Run the following:<div class="informalexample"><pre class="programlisting">void disconnected(SchedulerDriver driver)</pre></div><p>This is invoked <a class="indexterm" id="id93"/>when the scheduler becomes disconnected from the master (for example, the master fails and another takes over).</p><p>The following is the parameter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the driver that was used to run this scheduler</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">slaveLost</code>: Execute the<a class="indexterm" id="id94"/> following code:<div class="informalexample"><pre class="programlisting">void slaveLost(SchedulerDriver driver,
  SlaveID slaveId)</pre></div><p>This is invoked when a slave is determined unreachable (for example, machine failure or network partition). Most frameworks need to reschedule any tasks launched on this slave on a new slave.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the driver that was used to run this scheduler</li><li class="listitem" style="list-style-type: disc"><code class="literal">SlaveID</code>: This is the ID of the slave that was lost</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">executorLost</code>: Run the following:<div class="informalexample"><pre class="programlisting">void executorLost(SchedulerDriver driver,
  ExecutorID executorId,
  SlaveID slaveId,
  int status)</pre></div><p>The preceding is invoked<a class="indexterm" id="id95"/> when an executor is exited or terminated. Note that any running task will have the <code class="literal">TASK_LOST</code> status update automatically generated.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the driver that was used to run this scheduler</li><li class="listitem" style="list-style-type: disc"><code class="literal">ExecutorID</code>: This is the ID of the executor that was lost</li><li class="listitem" style="list-style-type: disc"><code class="literal">slaveID</code>: This is the ID of the slave that launched the executor</li><li class="listitem" style="list-style-type: disc"><code class="literal">status</code>: This is the exit status of the executor</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">error</code>: Run the <a class="indexterm" id="id96"/>following code:<div class="informalexample"><pre class="programlisting">void error(SchedulerDriver driver,
  java.lang.String message)</pre></div><p>The preceding is invoked when there is an unrecoverable error in the scheduler or driver. The driver will be aborted <span class="emphasis"><em>before</em></span> invoking this callback.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This is the driver that was used to run this scheduler</li><li class="listitem" style="list-style-type: disc"><code class="literal">message</code>: This is the error message</li></ul></div></li></ul></div></div><div class="section" title="The Scheduler Driver API"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>The Scheduler Driver API</h3></div></div></div><p>A brief description of the <a class="indexterm" id="id97"/>Scheduler Driver API is given below. For more <a class="indexterm" id="id98"/>details, visit <a class="ulink" href="http://mesos.apache.org/api/latest/java/org/apache/mesos/SchedulerDriver.html">http://mesos.apache.org/api/latest/java/org/apache/mesos/SchedulerDriver.html</a>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">start</code>: Run the<a class="indexterm" id="id99"/> following code:<div class="informalexample"><pre class="programlisting">Status start()</pre></div><p>This starts the scheduler driver. It needs to be called before any other driver calls are made.</p><p>The preceding returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">stop</code>: Execute the<a class="indexterm" id="id100"/> following code:<div class="informalexample"><pre class="programlisting">Status stop(boolean failover)</pre></div><p>This stops the scheduler driver. If the <code class="literal">failover</code> flag is set to false, it is expected that this framework will never reconnect to Mesos. So, Mesos will unregister the framework and shut down all its tasks and executors. If <code class="literal">failover</code> is true, all executors and tasks will remain running (for some framework-specific failover timeout), allowing the scheduler to reconnect (possibly in the same process or from a different process—for example, on a different machine).</p><p>The following is the parameter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">failover</code>: This is whether framework failover is expected</li></ul></div><p>This returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">Stop</code>: Run the following<a class="indexterm" id="id101"/> line:<div class="informalexample"><pre class="programlisting">Status stop()</pre></div><p>This stops the scheduler driver assuming no failover. This will cause Mesos to unregister the framework and shut down all its tasks and executors.</p><p>This returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">abort</code>: Execute the following code:<div class="informalexample"><pre class="programlisting">Status abort()</pre></div><p>This aborts the <a class="indexterm" id="id102"/>driver so that no more callbacks can be made to the scheduler. The semantics of abort and stop are deliberately separated so that code can detect an aborted driver (via the return status of <code class="literal">join()</code>; refer to the following section) and instantiate and start another driver if desired from within the same process.</p><p>This returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">join</code>: Run the<a class="indexterm" id="id103"/> following:<div class="informalexample"><pre class="programlisting">Status join()</pre></div><p>This waits for the driver to be stopped or aborted, possibly <span class="emphasis"><em>blocking</em></span> the current thread indefinitely. The return status of this function can be used to<a class="indexterm" id="id104"/> determine whether the driver was aborted (take a look at <code class="literal">mesos.proto</code> for a description of <code class="literal">Status</code>).</p><p>This returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">run</code>: Execute the following:<div class="informalexample"><pre class="programlisting">Status run()</pre></div><p>This starts<a class="indexterm" id="id105"/> and immediately joins (that is, blocks) the driver.</p><p>It returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">requestResources</code>: Take a look at the following:<div class="informalexample"><pre class="programlisting">Status requestResources(java.util.Collection&lt;Request&gt; requests)</pre></div><p>This requests<a class="indexterm" id="id106"/> resources from Mesos (take a look at <code class="literal">mesos.proto</code> for a description of Request and how, for example, to request resources from specific slaves). Any resources available are offered to the framework via the <code class="literal">Scheduler.resourceOffers(org.apache.mesos.SchedulerDriver, java.util.List&lt;Offer&gt;)</code> callback asynchronously.</p><p>The following is the parameter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">requests</code>: These are the resource requests.</li></ul></div><p>It returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">launchTasks</code>: Use the following code:<div class="informalexample"><pre class="programlisting">Status launchTasks(java.util.Collection&lt;OfferID&gt; offerIds,
  java.util.Collection&lt;TaskInfo&gt; tasks,
  Filters filters)</pre></div><p>The preceding code<a class="indexterm" id="id107"/> launches the given set of tasks on a set of offers. Resources from offers are aggregated when more than one is provided. Note that all the offers must belong to the same slave. Any resources remaining (that is, not used by the tasks or their executors) will be considered declined. The specified filters are applied on all unused resources (take a look at <code class="literal">mesos.proto</code> for a description of Filters). Invoking this function with an empty collection of tasks declines offers in their entirety (refer to <code class="literal">declineOffer(OfferID, Filters)</code>).</p><p>The following are<a class="indexterm" id="id108"/> the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">offerIds</code>: This is the collection of offer IDs</li><li class="listitem" style="list-style-type: disc"><code class="literal">tasks</code>: This is the collection of tasks to be launched</li><li class="listitem" style="list-style-type: disc"><code class="literal">filters</code>: This is the filters to set for any remaining resources.</li></ul></div><p>It returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">killTask</code>: Execute the following code:<div class="informalexample"><pre class="programlisting">Status killTask(TaskID taskId)</pre></div><p>This kills the specified task. Note that attempting to kill a task is currently not<a class="indexterm" id="id109"/> reliable. If, for example, a scheduler fails over while it attempts to kill a task, it will need to retry in the future. Likewise, if unregistered/disconnected, the request will be dropped (these semantics may be changed in the future).</p><p>The following is the parameter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">taskId</code>: This is the ID of the task to be killed</li></ul></div><p>It returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">declineOffer</code>: Run the following code:<div class="informalexample"><pre class="programlisting">Status declineOffer(OfferID offerId,
  Filters filters)</pre></div><p>This declines <a class="indexterm" id="id110"/>an offer in its entirety and applies the specified filters on the resources (take a look at <code class="literal">mesos.proto</code> for a description of Filters). Note that this can be done at any time, and it is not necessary to do this within the <code class="literal">Scheduler.resourceOffers(org.apache.mesos.SchedulerDriver, java.util.List&lt;Offer&gt;)</code> callback.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">offerId</code>: This is the ID of the offer to be declined</li><li class="listitem" style="list-style-type: disc"><code class="literal">filters</code>: These are the filters to be set for any remaining resources</li></ul></div><p>It returns the <a class="indexterm" id="id111"/>state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">reviveOffers</code>: Execute the following:<div class="informalexample"><pre class="programlisting">Status reviveOffers()</pre></div><p>This removes<a class="indexterm" id="id112"/> all the filters previously set by the framework (via <code class="literal">launchTasks(java.util.Collection&lt;OfferID&gt;, java.util.Collection&lt;TaskInfo&gt;, Filters)</code>). This enables the framework to receive offers from these filtered slaves.</p><p>It returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">sendFrameworkMessage</code>: Take a look at the following:<div class="informalexample"><pre class="programlisting">Status sendFrameworkMessage(ExecutorID executorId,
  SlaveID slaveId,
  byte[] data)</pre></div><p>This sends a message<a class="indexterm" id="id113"/> from the framework to one of its executors. These messages are sent on a best effort basis and should not be expected to be retransmitted in any reliable fashion.</p><p>The parameters are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">executorId</code>: This is the ID of the executor to send the message to</li><li class="listitem" style="list-style-type: disc"><code class="literal">slaveId</code>: This is the ID of the slave that runs the executor</li><li class="listitem" style="list-style-type: disc"><code class="literal">data</code>: This is the message</li></ul></div><p>It returns the state of the driver after the call.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">reconcileTasks</code>: Take a look <a class="indexterm" id="id114"/>at the following code:<div class="informalexample"><pre class="programlisting">Status reconcileTasks(java.util.Collection&lt;TaskStatus&gt; statuses)</pre></div><p>This allows the framework to query the status for nonterminal tasks. This causes the master to send back the latest task status for each task in <code class="literal">statuses</code> if possible. Tasks that are no longer known will result in a <code class="literal">TASK_LOST</code> update. If <code class="literal">statuses</code> is empty, the master will send the latest status<a class="indexterm" id="id115"/> for each task currently known.</p><p>The following are the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">statuses</code>: This is the collection of nonterminal <code class="literal">TaskStatus</code> protobuf messages to reconcile.</li></ul></div><p>It returns the state of the driver after the call.</p></li></ul></div></div></div></div>
<div class="section" title="Mesos in production"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Mesos in production</h1></div></div></div><p>Mesos is in production at several companies such as Apple, Twitter, and HubSpot and has even been<a class="indexterm" id="id116"/> used by start-ups such as Mattermark and Sigmoid. This broad appeal is a validation of Mesos' tremendous utility. Apple, for example, powers its consumer-facing, mission–critical, popular <span class="emphasis"><em>Siri</em></span> application through a large Mesos cluster (allegedly spanning tens of thousands of nodes). One such case study (published on the Mesosphere website) is discussed here.</p><div class="section" title="Case study on HubSpot"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Case study on HubSpot</h2></div></div></div><p>Following case<a class="indexterm" id="id117"/> study on HubSpot can be found here <a class="ulink" href="https://mesosphere.com/mesos-case-study-hubspot/">https://mesosphere.com/mesos-case-study-hubspot/</a>. An excerpt from this link is given below:</p><p>HubSpot uses Apache<a class="indexterm" id="id118"/> Mesos to run a mixture of web services, long-running processes, and scheduled jobs that comprise their SaaS application. Mesos allows HubSpot to dynamically deploy services, which in turn reduces developer friction and time to deploy, increases reliability, achieves better resource utilization, and reduces hardware costs.</p><p>Mesos provides the core infrastructure to build a next-generation deployment system similar to what Heroku provides as a product. On top of Mesos, HubSpot built their own scheduler that is capable of executing both long-running services and scheduled jobs and is the interface through which the development team can view the state of their applications inside the cloud. Building a scheduler framework enables HubSpot to better understand the core concepts inside Mesos, be comfortable with failure modes, and customize user experience.</p><div class="section" title="The cluster environment"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"/>The cluster environment</h3></div></div></div><p>Over 150 services run inside Mesos at HubSpot. HubSpot utilizes many hundreds of servers inside Amazon EC2, and the Mesos cluster comprises about 30% of these resources and is aggressively ramping up as more and more services are migrated to Mesos. As Mesos can <a class="indexterm" id="id119"/>easily handle large or small server footprints, hundreds of smaller servers are replaced with dozens of larger ones.</p></div><div class="section" title="Benefits"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec12"/>Benefits</h3></div></div></div><p>Mesos provides numerous<a class="indexterm" id="id120"/> benefits to both the development team and the company. At HubSpot, developers own the operation of their applications. With Mesos, developers can deploy services faster and with less maintenance. Here are some of the other benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Developers get immediate access to cluster resources, whether it be to scale or introduce new services.</li><li class="listitem" style="list-style-type: disc">Developers no longer need to understand the process of requisitioning hardware or servers, and it is easier to scale up the resource requirements inside Mesos than it is to recreate servers with more or less CPUs and memory.</li><li class="listitem" style="list-style-type: disc">Hardware failures are more transparent to developers as services are automatically replaced when tasks are lost or they fail. In other words, developers are no longer paged because of a simple hardware failure.</li><li class="listitem" style="list-style-type: disc">Scheduled tasks (cron jobs) are now exposed via a web interface and are not tied to a single server, which may fail at any time, taking the cron job with it.</li></ul></div><p>Mesos also simplifies the technology stack required to requisition hardware and manage it from an operations perspective. HubSpot can standardize server footprints and simplify the base image upon which Mesos slaves are executed.</p><p>Lastly, resource utilization is improved, which directly corresponds with reducing costs. Services, which previously ran on overprovisioned hardware now use the exact amount of resources requested.</p><p>Additionally, the QA environment runs at 50% of its previous capacity as the HubSpot scheduler ensures that services are restarted when they fail. This means that it is no longer necessary to run multiple copies of services inside QA for high availability.</p></div><div class="section" title="Challenges"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec13"/>Challenges</h3></div></div></div><p>A core challenge <a class="indexterm" id="id121"/>behind adoption is introducing a new deployment technology to a group of 100 engineers who are responsible for managing their applications on a daily basis. HubSpot mitigated this challenge by building a UI around Mesos and utilizing Mesos to make the deployment process as simple and rewarding as possible.</p></div><div class="section" title="Looking ahead"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec14"/>Looking ahead</h3></div></div></div><p>HubSpot sees Mesos as a core technology behind future migrations into other datacenters. As<a class="indexterm" id="id122"/> both a virtualization and deployment technology, Mesos has proven to be a rewarding path forward. Additionally, HubSpot hopes to eventually leverage Mesos to dynamically scale out processes based on load, shrink and grow the cluster size relative to demand, and assist developers with resource estimation.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>Detailed steps to download the code bundle are mentioned in the Preface of this book. Please have a look. The code bundle for the book is also hosted on GitHub at <a class="ulink" href="https://github.com/PacktPublishing/Mastering-Mesos">https://github.com/PacktPublishing/Mastering-Mesos</a>. We also have other code bundles from our rich catalog of books and videos available at <a class="ulink" href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Check them out!</p></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, we introduced Mesos, dived deep into its architecture, and discussed some important topics, such as frameworks, resource allocation, and resource isolation. We also discussed the two-level scheduling approach that Mesos employs and provided a detailed overview of its API. The HubSpot case study at the end was to show how it is used in production and that it is ready for prime time. The objective was to explain what Mesos is and why it is required and provide a high-level overview of how it works.</p><p>In the next chapter, we will deep dive into its important features and understand how it contributes to scaling, efficiency, high availability, and extendibility.</p></div></body></html>