- en: Making a Script Behave Like a Daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running a program continuously (forever) using looping constructs or recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping programs/scripts running after logoff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking commands when they require permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitizing user input and for repeatable results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a simple multi-level user menu using select
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating and trapping signals for cleanup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using temporary files and lock files in your program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging timeout when waiting for command completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a file-in-file-out program and running processes in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing your script on startup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is about creating components that mimic application functionality
    such as menus or a daemon. For that to happen, let''s step back for a second and
    determine: what defines an application or daemon? Is it menus? Is it the ability
    to run *forever?* Or the ability to run *headless* in the background? All of this
    defines behaviors that an application may exhibit, but nothing prevents a script
    from also having these behaviors as well!'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a bash script did not have an extension (for example, `.sh`)
    and was not ran explicitly with the Bash interpreter, how would you know on the
    first inspection that it was a script and not a binary? While there are a number
    of ways such as opening, or using the `file` command, on the surface, a script
    can appear the same as a program!
  prefs: []
  type: TYPE_NORMAL
- en: Running a program continuously (forever) using looping constructs or recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, this cookbook has mostly shown scripts that serve a single purpose and
    exit upon task completion. This is great for single use scripts, but what about
    if we wanted to have scripts execute multiple scripts through a menu, or perform
    tasks in the background automatically forever without being executed each time
    by scheduling processes (like cron)? This recipe introduces a few ways for a script
    to run forever until it is killed or exits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, we need to remember a few concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions combined with a prompt (for example, the `read` command)
    can result in a script that loops based on user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping constructs such as `for`, `while`, and `until` can be executed in such
    a way that a condition is never met and cannot exit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, a loop or something that causes a loop will force a program to run
    for an indefinite period of time until an exit event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In many programming languages, a program will be executed through the concept
    of a main function. Within this `main` function, often programmers create what's
    called a run loop, which allows the program to run forever (even if it is doing
    nothing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the recursive method, the operation may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The script or program enters a recursive function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The recursive function can continue calling itself indefinitely, or, wait for
    a blocking input (for example, the `read`command)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the input provided by the `read` command, you could call the same function
    again
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to step 1 until exit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, the looping mechanism is similar except functions are not necessarily
    executed. A loop with an effectively unreachable condition will continuously run
    unless something interrupts the execution (for example, `sleep`).
  prefs: []
  type: TYPE_NORMAL
- en: A loop running continuously without pause will use CPU resources that could
    be used elsewhere or waste CPU cycles. If you are running on a battery or a resource
    constrained platform, extra CPU activity is best to be avoided where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `sleep` command is an excellent way to limit CPU usage when using
    loops in simple scripts. However, time adds up if you are running a long script!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and create the `recursive_read_input.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Execute the `$ bash recursive_read_input.sh`script—press *Enter* at the prompt
    and wait for another prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the program with *Ctrl* + C.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal and create the `loop_for_input.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Execute the `$ bash loop_for_input.sh`script—press *Enter* at the prompt and
    wait for another prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the program with *Ctrl* + *C.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal and create the `loop_while_input.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Execute the `$ bash loop_while_input.sh` script—press *Enter* at the prompt
    and wait for another prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the program with *Ctrl* + *C.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal and create the `loop_until_input.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the `$ bash loop_until_input.sh` script—press *Enter* at the prompt
    and wait for another prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the program with *Ctrl* + *C.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand our script in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `recursive_read_input.sh` script is a simple process. We can see
    that the `read` command expects input (and will store it in the `$input` variable),
    then the script calls `recursive_func()` again for *each* time a read exits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the script with `$ bash recursive_read_input.sh`runs the script indefinitely.
    No matter the input, *Ctrl + C* or killing the script will exit it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creating the `loop_for_input.sh` script is relatively trivial as well. We can
    notice two things: the for loop has no parameters, except for `(( ; ; ))` and
    the `sleep` command. This will make it run forever, but upon each execution of
    the loop, it will echo `Shall run for ever` to the console and sleep one second
    before continuing to the next loop.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the `$ bash loop_for_input.sh` scriptwill cause the script to loop
    forever.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl* + *C* will cause the script to exit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `loop_while_input.sh` script by using a `while` loop with the `: noop`
    command. However, there is a small difference of an if statement (which will never
    evaluate to true), but it can still be used in another script to set a condition
    which causes the script to break the `while` loop and exit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the `$ bash loop_while_input.sh` script will cause the script to loop
    forever.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl* + *C* will cause the script to exit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `loop_until_input.sh` script is similar to the `while` loop forever example,
    but it is different because you can also embed a condition, which will never evaluate
    to `true.` This causes the script to loop forever unless the `$EXIT_PLEASE` variable
    is set to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the `$ bash loop_until_input.sh` script will cause the script to loop
    forever.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl* + *C* will cause the script to exit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping programs/scripts running after logoff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leading up to getting our scripts to run as daemons, we need to know how to
    keep commands running after a user logs off (or better yet, have them started
    by the system itself (we will look at this in more detail later). When a user
    logs in, a session for that user is created, but when they log off—unless the
    system owns it, processes and scripts typically get killed or closed.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is about keeping your scripts and activities running in the background
    after you log off.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, we need to remember a few concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user logs off, any apps or processes owned by the current user will exit
    (the shell will send a signal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shell is configurable to not send a shutdown signal to processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications and scripts use stdin and stdout for the usual operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications or scripts in the background can be referred to as **jobs**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The purpose of this chapter is to not show you process management, but how
    we can manipulate the shell to keep our programs running. One neat way is by using `&`,which
    is used this way: `$ bash runforver.sh &`. Unfortunately, using only this technique,
    we are back at square one—our binary still dies when we exit. Therefore, we need
    to use programs such as **screen**, **disown**, and **sighup**.'
  prefs: []
  type: TYPE_NORMAL
- en: The screen command is not available on all systems. It is recommended that we
    use another command in case **screen** is absent (it is still useful to know!).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and create the `loop_and_print.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a terminal and run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, log off, then log in and run the following command in a new terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you find the process running? Next, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, log off, then log in and run the following command in a new terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, log off, then log in and run the following command in a new terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 1, we opened a terminal and created the `loop_and_print.sh`script. This
    script merely loops forever, printing as it does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following commands will use the `loop_and_print.sh` script and run in the
    background as a **job**. The `ps` command outputs process information and is piped
    through grep to simplify the output. In the command, we can see the process ID
    (PID) next to the username column. Keep note of PIDs so that you can kill zombie
    processes or stop unnecessary applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Logging back on and running the `ps` command will produce *zero* results. This
    is because the script we put into the background using `&` has been sent a signal
    to shutdown or die.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, we run the `loop_and_print.sh` script; command puts it into the *background*,
    and disown removes the the background process(es) from the known list of jobs.
    This *disconnects* the script and *all* output from any terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon logging back in and using the `ps` command, you shall see the PID of the
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nohup` command is similar to the `disown` command, except that it explicitly
    *disconnects* the script from the current shell. It is *also* different from disown
    because `nohup` allows you still retain output from the script, which is accessible
    by other applications after the fact in the `nohup.out` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon logging back in and using the `ps` command, you shall see the PIDs of
    the *two* scripts that survived the logoff:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Invoking commands when they require permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running as root is dangerous, although sometimes convenient—especially when
    you are new to Linux and password prompts seem to be a hassle. So far, as a Linux
    user, you may have seen the `sudo` command or the `su`command. These commands
    can allow a user to change users on the system at the console or execute commands
    momentarily with higher permissions (if the user has `sudo` permissions). `Sudo`,
    or **substitute user do, **enables a regular user to escalate (raise) their user
    permissions to a more privileged level for a SINGLE command.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the substitute user command, or `su`, allows you to also run
    commands that are privileged and to even change shells (for example, to become
    a root user). `Sudo` doesn't activate a root shell or allow you access to other
    user accounts, which is unlike the `su` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example uses of the two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'While both commands require knowledge of a root password, `sudo` also requires
    that the user executing the `sudo` command is listed in the `/etc/sudoers` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding standard Ubuntu sudoers file, we can see that the admin group
    of users can use the `sudo` command (and likely the reason you are able to do
    so as well without tinkering). We can also see that there can be specific user
    privilege execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the root user can run all the commands available on the
    system. In fact, we could add a line for a user named `rbrash`, such as `rbrash
    ALL=(ALL) ALL`.
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/sudoers` can be edited by a user with root permissions using the `visudo`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when adding permissions or alterations to users. It could become
    a security risk if the account is not secure!
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, you might wonder why this is so important for a Bash
    script (besides being able to escalate permissions). Well, imagine that you might
    have a system in place that performs Continuous Integration or a process that
    builds software continuously (for example, Jenkins)—it might just be desirable
    to have a build running various commands without your input, hence the use of
    giving a user access to specific commands (especially if they are **sandboxed **or
    within a **virtual machine**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open, we need to remember a few concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo` requires a password (unless specified)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo` can also be limited to specific commands, users, or hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo` commands are also logged in either `/var/log/secure` or `/var/log/auth.log`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can create a new user for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the command in a new terminal, *not* as `root`, and without any previous
    `sudo` authorization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the **`$ sudo visudo`** command and edit the script to include
    the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the command in a new terminal, *not* as `root` and without any previous
    `sudo` authorization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice anything different? Now, make sure to cancel the shutdown using the previous
    command:` $ shutdown -c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding recipe is pretty slim, but there is a fair bit of assumption
    and knowledge that you need to know about in regards to `sudo`. First, be careful.
    Second, be more careful. And finally, take care to keep your account secure with
    adequate password policies:'
  prefs: []
  type: TYPE_NORMAL
- en: In step one, we tried to run two commands that require user permissions. Normally,
    rebooting or halting a system requires privilege escalation (unless done through
    the GUI). The `shutdown -c` command cancels a shutdown. If you used `shutdown
    -h` now, the system would shut down immediately. This cannot be stopped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second step, we use the new `visudo` command to make edits to the `/etc/sudoers`
    file. In bold, `Cmnd_Alias` allows you define a group of commands, however, you
    have to use the full path of binaries. The user Bob is assigned to this Alias
    as well. `NOPASSWD:` is used to specify that the password is not required for
    these commands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the third step, shutdown commands can be run without a password prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to guarantee an accidental shutdown is cancelled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sanitizing user input and for repeatable results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best practices for scripts (or programs, for that matter) is controlling
    user input, not only for security, but for controlling functionality in a way
    that input provides predictable results. For example, imagine a user who enters
    a number instead of a string. Did you check it? Will it cause your script to exit
    prematurely? Or will an unforeseen event occur such as the user entering `rm -rf
    /*` instead of a valid user name?
  prefs: []
  type: TYPE_NORMAL
- en: In any case, limiting program user input is also useful to you as the author
    because it can limit paths users take and reduce undefined behavior or bugs. Therefore,
    if quality assurance is important, test cases and input/output validation can
    be reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe might be introducing some readers to a concept they would like
    to avoid: software engineering. It''s true, you are probably writing scripts to
    quickly get a task completed, but if your script is to be used by other people
    (or for a long time), its great to catch errors early when they occur and prevent
    program misbehaviour.'
  prefs: []
  type: TYPE_NORMAL
- en: Even without formal computer science or engineering training, the idea of use
    cases is based on having any particular piece of functionality, with X input,
    and seeing whether Y does as expected. Sometimes, limits or ranges can be imposed,
    an action may complete or fail, and any results compared can conclude whether
    the "use case" passes or fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a step by step example using a program that should `echo` the
    username of the user who executed the script via a prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: The script expects input to be read into a variable using the read command (for
    example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The variable is assumed to be a string, but it could be the user's name, a number,
    a post address in a foreign country, an email, or even a malicious command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script reads the variable and runs the `echo` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The results returned could be garbage, but could also be executed by another
    script—what could go wrong?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, usernames, by default, should contain alphabetic characters and
    numbers, but no special characters except underscores, periods, dashes, and a
    dollar sign (`$`) at the *end* of a name.
  prefs: []
  type: TYPE_NORMAL
- en: In all efforts, if security is not important, then the robustness of an application
    could be!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by opening a terminal and a new shell script called `bad_input.sh` with
    the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a second script called `better_input.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the script using these commands and not the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new script called `validate_email.sh` to validate email addresses
    (similarly to how one would validate DNS names):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can test the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common task would be to validate IP addresses. Create another script
    called `validate_ip.sh` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand our script in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we begin by creating the `bad_input.sh` script—it takes `$1` (or argument
    1) and runs the list or `ls` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running the following commands, we can either list everything in the directory,
    subdirectory, or even traverse directories backwards! This is clearly not good
    and security vulnerabilities have even allowed malicious hackers to traverse through
    a web server—the idea is to contain the input for predictable results and to control
    input instead of allowing everything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second script, `better_input.sh`, the input is sanitized by the following
    steps. Additionally, one could also check whether the file being listed is in
    fact there as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove any underscores (necessary).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove any sets of double spaces.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace spaces with underscores.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove any non-alphanumeric values or anything else that is not an underscore.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, run the `ls` command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, running `better_input.sh` will allow us to view the current working directory
    or any file contained within it. Wildcards have been removed and now we cannot
    traverse directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To validate the form of an email, we use the `grep` command combined with a
    regex. We are merely looking for the form of an email account name, an `@` symbol,
    and a domain name in the form of acme.x. It is important to note that we are not
    looking to see whether an email is truly valid or can make its way to the intended
    destination, but merely whether it fits what an email should look like. Additional
    tests such as testing the domain's MX or DNS mail records could extend this functionality
    to improve the likelihood of a user entering a valid email.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, we test two domain names—one without the `@` symbol (invalid)
    and one with the `@` symbol (valid). Feel free to try several combinations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating an IP address is always something that could be done with a regex,
    but for the purpose of easy-to-use tools that get the job done, **read** and simple
    tests using **test** (and evaluations) will work just fine. In its basic form,
    an IP address consists of four octets (or in layman terms, four values separated
    by a period). Without exploring what a truly valid IP address is, normally a valid
    octet is between `0` and `255` (never more and never less). IP addresses can have
    various categories and classes called **subnets**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our examples, we know that an IP address containing alphabetic characters
    is not a valid IP address (excluding the periods), and that the values range between
    `0` and `255` per octet. `192.168.0.x` (or `192.168.1.x`) is an IP subnet many
    people see on their home routers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making a simple multi-level user menu using select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this book, we saw that you can make a script that uses recursive
    functions and conditional logic to create a simple menu. It worked, but another
    tool that can be used is `select`. Select works using a provided list (for example,
    it can be a wildcard selection for files) and will give you a list, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, a menu such as about is very trivial; it can be useful for utility
    functions and for repeatable subtasks like deleting users or modifying files/archives.
  prefs: []
  type: TYPE_NORMAL
- en: Simple select scripts could also be useful for a number of activities such as
    mounting a drop box, decrypting or mounting a drive, or generating administrative
    reports.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Select is already a part of the Bash shell, but it has a few less than obvious
    points. Select relies on three variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PS3`: The prompt that''s echoed to the user before the menu is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPLY`: The index of the item selected from the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opt`: The value of the item selected from the array—not the index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, `opt` is not mandatory, but it is the value of the element being
    iterated by Select in our example. You could use another name and call it **element**,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and create a script called `select_menu.sh` with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the script using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Press *1* to enter the file list functionality. Enter the number of any files
    in the menu. Once satisfied, type "back" and press *Enter* to return to the main
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand our script in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the `select_menu.sh` script was trivial, but besides the use of select,
    some of the concepts should look familiar: functions, return, case statements,
    and recursion.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script enters the menu by calling the `main_menu` function and then proceeds
    to use select to generate a menu from the `${OPTIONS}`array. The hard-coded variable
    named `PS3` will output the prompt before the menu, and `$REPLY` contains the
    index of the item selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pressing *1* and pressing *Enter* will cause select to walk through the items
    and then execute the `list_files` function. This function creates a submenu by
    using select for the second time to list all of the files in the directory. Selecting
    any directory will return a `$OPT was selected` message, but if `back` is entered,
    then the script will return from this function and call `main_menu` from within
    itself (recursion). At this point, you may select any items in the main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating and trapping signals for cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, you have probably pressed *Ctrl* + *C* or *Ctrl* + *Z*
    without knowing what was occurring—it's just like pressing *Ctrl* + *Alt* + *Delete*
    in another OS, right? Well, in one regard, yes—it is a signal, but the action
    itself is very different in Linux. A signal at the hardware level is similar to
    a flag or some sort of immediate notification that says *hey - something happened
    here*. If the appropriate listener is set up, that signal can execute some sort
    of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, software signaling is far more flexible and we can use signals
    as *simple* notification mechanisms that are far more flexible than their hardware
    siblings. In Linux, *Ctrl* + *C* equates to SIGINT (program interrupt), which
    typically exits a program. It can be stopped, and other functionality such as
    cleanup can be executed. *Ctrl* + *Z* or SIGTSTP (keyboard stop) typically tells
    a program to be **suspended** and pushed to the background (more about jobs in
    a later section), but it can also be blocked—just like SIGINT.
  prefs: []
  type: TYPE_NORMAL
- en: SIGHUP is already a signal we are familiar with—the same as with SIGKILL. We
    saw them when we used `disown` or exited a shell. For more information regarding
    signals, see the [manual page for a great signal overview](http://man7.org/linux/man-pages/man7/signal.7.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides using the keyboard within a program, we can also send signals to programs
    using the `kill` command. The `kill` command can kill programs, but these signals
    can also be used for reloading configurations or sending user-defined signals.
    The most common signals you may use are SIGHUP (1), SIGINT (2), SIGKILL(9), SIGTERM(15),
    SIGSTOP(17,18,23), SIGSEGV(12), and SIGUSR1(10)/SIGUSR2(12). The latter two can
    be defined within your program or leveraged by other developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kill` command can be used easily as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `kill` command can refer to the signal number itself or by its name. It
    does require a process ID number to target. This can easily be found either by
    searching using `ps | grep X` or by using the preceding `final` using `pidof`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and begin a new script called `mytrap.sh` with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Execute the script with `$ bash mtrap.sh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter* several times and watch the behavior of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *C*; notice anything different?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand our script in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mytrap.sh` script leverages functions and the trap call. Inside of the
    `setup` function, we set the function to be called by the `trap` command. Therefore,
    when *Ctrl* + *C* is called, the `cleanup`functionis executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the script will cause the script to run forever after printing out the
    PID of the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pressing regular keys such as *Enter* will not have an effect on the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pressing *Ctrl+* *C* will echo `cleanup` on the console and the script will
    exit using the `exit` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using temporary files and lock files in your program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another mechanism or component programs and scripts often use is called a lock
    file. It's usually temporary (it resides in `/tmp`) and is sometimes used when
    multiple entities rely on a single source of data or need to know that other programs
    exist. Sometimes, it's merely the presence of a file, a particular timestamp on
    a file, or another simple artifact.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to test for the existence of a file, but one important
    attribute that has not been demonstrated or explored is the concept of a **hidden**
    file. A hidden file in Linux is not really hidden (like in Windows), but it is
    not usually apparently unless a particular flag or command is ran. For example,
    the `ls` command does not return hidden files among the results, but the `ls`command
    with the `-a`flag will (`-a` for all).
  prefs: []
  type: TYPE_NORMAL
- en: Most file explorers have hidden files that aren't visible by default. In Ubuntu, *Ctrl*
    + *H* inside of the file explorer toggles this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a hidden file, a `.` (period) needs to be present at the beginning
    of a file''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Besides the presence of any regular file, we can also use the `mktemp` command
    to create lock files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly mentioned that temporary files can reside inside the `/tmp` directory.
    Often, `/tmp` is home to short lived files such as lock files or information that
    can be volatile (destroyed on a power event without any detriment to the system).
    It is also usually RAM-based, which can offer performance benefits as well, especially
    if used as part of an inter-process communication system (more on this later in
    another recipe).
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to know that other programs can access your file in
    `/tmp`, so it should be secured with the sufficient permissions. It should also
    be given a name that is suitably random so that a filename collision does not
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal and create a new script by the name of `mylock.sh` with
    the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Execute the script with the `$ bash mylock.sh` script and review the console's
    output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we know that the script is looking for a particular lock file. What happens
    when we create a lock file and then re-run the script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand our script in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mylock.sh` script reuses a couple of concepts that we are already familiar
    with: traps and symbolic links. We know that if a trap is called or rather, it
    catches a particular signal, it can clean up a lock file (as is the case in this
    script). Symbolic links are used since they can survive atomic operations over
    network file systems. If a file is present at the `LOCKFILE` location, then a
    lock is present. If the `LOCKFILE` is absent, the doors are open.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we run `mylock.sh`, we will get the following because no lock file exists
    yet—including any temporary ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since the preceding script exited correctly, the `SIGKILL` signal was handled
    and the temporary lockfile was removed. In this case, we want to create our own
    lockfiles that bypass this mechanism. Create a lockfile with a faux PID of `1000`;
    running the script will return `Locked by 1000`, and upon deleting the lockfile,
    the regular behavior will occur once more (doors are unlocked).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leveraging timeout when waiting for command completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, waiting for a command to finish execution or ignoring commands until
    completion might not be considered a solid practice in scripting, though it does
    have applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Where commands take variable lengths of time to complete (for example, pinging
    a network host)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where tasks or commands can be executed in such a way that the *master* script
    waits for the success or failure of several multiple operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the important thing to note is that timeout/wait requires a process,
    or even a subshell so that it can be monitored (by the Process ID or PID). In
    this recipe, we will demonstrate the use of waiting for a subshell with the timeout
    command (which was added into the coreutils package 7.0) and how to do so using
    trap and kill (for alarms/timers).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In earlier recipes, we introduced the use of `trap` to catch signals, and the
    use of `kill` to send signals to processes. These will be explained further in
    this recipe, but here are three new native Bash variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$$`: Which returns the PID of the current script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$?`: Which returns the PID of the last job that was sent to the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$@` :Which returns the array of input variables (for example, `$!`, `$2`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are skirting around the ideas of jobs, tasks, background, and foreground
    as they will appear again in proper detail in a later administrative recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We begin this recipe knowing that there is a command called `timeout` available
    to the Bash shell. However, it falls short of being able to provide the functionality
    of timeouts in functions within a script itself. Using `trap`, `kill`, and signals,
    we can set timers or `alarms` (`ALRM`) to perform clean exits from runaway functions
    or commands. Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal and create a new script by the name of `mytimeout.sh` with
    the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using a command with variable times (`ping`), we can test `mytimeout.sh` using the
    first parameter to `mytimeout.sh` as the timeout variable!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be asking yourself, *can I put functions to the background?* Absolutely—and
    you could even use a command called `export` with the -f flag (although it may
    not be supported in all environments). If you were to use the timeout command
    instead, you would have to either run ONLY the command you wish to monitor or
    put the function inside of a second script to be called by timeout. Clearly, this
    is less than optimal in some situations. In this recipe, we use signals or rather,
    the `alarm` signal, to act as a timer. When we set the alarm with a specific variable,
    it will raise `SIGALARM` once the timer expires! If the process is still alive,
    we merely kill it and exit the script if we haven''t already exited:'
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we create the `mytimeout.sh` script. It uses a few of our new primitives
    such as `$!` to monitor the PID of the function we sent to execute in the background
    as a job (or subshell, in this case). We `arm` the timer and then carry on with
    the execution of the script. Then, we use shift to literally *shift*the parameters
    passed to our script to ignore `$1` (or the timeout variable). Finally, we watch
    for `SIGALRM` and perform a cleanup if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In step 2, `mytimeout.sh` is executed twice using the `ping` command, which
    is targeting `google.ca`. In the first instance, we use a timeout of `1` second,
    and in the second instance, we use a timeout of 10 seconds. Ping, in both cases,
    will perform 10 pings (for example, one ping there and back to whatever host is
    answering ICMP requests for the DNS entry for google.ca). The first instance will
    execute early, and the second allows 10 pings to execute cleanly and exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice that google.ca could be replaced with another DNS name, but the times
    may vary depending on your location. Therefore, 10 PINGs may not actually have
    time to be executed fully.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a file-in-file-out program and running processes in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we use a concept called file-in-file-out (FIFO), also known
    as **pipes**, to pass along a parameter to several "worker" scripts. These workers
    operate in parallel (in other words, mostly independent of the master process),
    read an input, and execute a command. FIFOS are useful because they can reduce
    file system activities or input/output (IO), and data can flow directly to listeners
    or recipients. They are represented on the file system as files and are bidirectional—they
    can be read and written to at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create FIFOs, we use the `mkinfo` command to create what appears to be a
    file (everything is a file in Linux). This file has a special property, though,
    which is different than normal files and also different from the pipes we had
    been previously using: the pipes, in this case, can allow for multiple readers
    and writers!'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any file, you can also provide permissions using the `-m` flag such
    as this: `-m a=rw`, or use the `mknod` command (this isn''t covered as it requires
    that you use a second command called `chown` to change **`permissions`** after
    creation).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start this exercise, we will introduce two terms: leader and follower, or
    master and worker. In this case, the master (the central host) will create the
    workers (or minions). While the recipe is a bit contrived, it should make for
    an easy go-to template for a simple **named pipes** or FIFO pattern. Essentially,
    there is a master that creates five workers, and those newly created workers echo
    out what is provided to them through the named pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, open a new terminal and create two new scripts: `master.sh`
    and `worker.sh`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `master.sh`, add the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In `worker.sh`, add the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the terminal, run the following command and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of this recipe is that if you have several repetitive tasks such as
    bulk operations and potentially multiple cores, you can perform tasks in parallel
    (often seen in the Linux world as Jobs). This recipe creates a single master that
    spawns several worker scripts into the background, which await input from the
    named pipe. Once they read input from the named pipe, they will echo it to the
    screen and then exit. Eventually, the master will exit too, removing the pipe
    along with it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 1, we open a new terminal and create the two scripts: `master.sh` and
    `worker.sh`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In step 2, we create the `master.sh` script. It uses two while loops to create *n*
    numbers of worker scripts with `$I` identifiers and then sends the same number
    of values to the FIFO before sleeping/exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In step 3, we create the `worker.sh` script, which echos an initialization message
    and then waits until `$BUFFER` is not empty (NULL, as it can be sometimes referred
    to). Once `$BUFFER` is full or rather, contains a message, then it echos it to
    the console and the script exits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In step 4, the console should contain an output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With the two scripts working in tandem over the FIFO, a numeric value is passed
    between them and the workers perform their *work*. These values or messages could
    easily be modified so that the workers execute commands instead!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the output can be in a different order. This is because Linux is
    not deterministic and spawning processes or reading from the FIFO might be blocked,
    or someone might get there before it (due to scheduling). Keep this in mind as
    the FIFO is also not atomic or synchronous—if you wish to designate which message
    goes to what host, you could create an identifier or messaging scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Executing your script on startup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is not limited to running only applications or services at startup,
    but to also start scripts on bootup (power on) of a system. For example, if your
    system boots up and you would like to apply several tweaks to the OS such as performance
    enhancements or battery tweaks, you can do this on startup via the `systemd` or
    `init.d` script. Another example could be to run a never ending script that creates
    logging events, like an electronic version of a pulse monitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, Linux or most *NIX systems use either the venerable `rc.d` system
    or the newer and more controversial systemd system to manage the starting and
    stopping of system resources. Without diving into the entire boot sequence of
    Linux, here is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel is loaded and mounts the root filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rootfile system contains a shell at a particular path (the init level).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the systemd works its way through a series of services to start (the run
    level).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a service or script is added, it will likely be added at the **run level**.
    It can also be started, stopped, reloaded, and restarted from the command line
    at any time as well. When the system is booting, it merely uses the start functionality
    provided by the `init.d` or `system.d` script. However, even though the semantics
    of either the rc.d or systemd system differ, they still require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scripts or services need to be enabled for specific system startup levels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts to be started and/or stopped can be configured to be started in a specific
    order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives for starting (at a minimum), stopping, restarting and/or reloading
    are executed based on a parameter when executing one of these actions (or blocks).
    Any number of commands can also be executed when calling start, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may notice when scouring the web when looking for resources that a number
    of init systems exist: upstart, SysVinit, rc.d, procd, and the list goes on. You
    can refer to your distribution documentation for a current explanation on the
    startup system in use.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Ubuntu 16.04 LTS (and other distributions), use systemd. Knowledge of both
    the init.d and systemd service control systems is certainly worth having as many
    embedded systems use Busybox. BusyBox uses the init.d system instead of systemd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into the "how to do it" section, we are going to create a template
    init script for posterity and awareness should you run into them. It will be called `myscript`
    and it will run `myscript.sh`. At a minimum, a system.d compatible script looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The content should be fairly easy to read if you have worked through the cookbook
    until this point. It relies on the comments in the header to determine the name,
    run levels, orders, and dependencies. Below that, it uses a switch statement while
    looking for several predetermined/standardized parameters: start, stop, restart,
    force-reload, and status. Inside of the start case, we start the binary, and in
    the stop case, we use the `killall` function to stop the binary.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that the mere installation of an init script does not
    guarantee execution on startup. There is a process to **enable** the service or
    script. In the older system (SysV), you may have heard/seen of the command `chkconfig`
    being used. In systemd, you may use the `systemctl` command to enable/disable
    a service. In this section, we are only going to focus on systemd.
  prefs: []
  type: TYPE_NORMAL
- en: SysV executes the scripts in sequential order based on their number in the filename
    (for example, `S99-myinit`). Systemd does not because it also reviews dependencies and
    waits for their completion.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script called `myscript.sh` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add the correct permissions to the script so that we can create
    a systemd service using it. Notice the use of the `sudo`command—enter your password
    where appropriate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have something to execute on start, we need to create a service
    configuration file to describe our service; we used `vi` in this example and `sudo`
    (note down its location):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the `myscript` service, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To start and verify the presence of the process, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You may reboot the system to see our service in action on startup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand our script in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we create a trivial looping program to be ran at system startup called `myscript.sh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In step 2, we copy the script to the `/usr/bin` directory and add permissions
    using the `chmod` command for everyone to be able to execute the script (`chmod
    a+x myscript.sh`). Notice the use of `sudo` permissions to create a file in this
    directory and to apply permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the third step, we create the service configuration file, which describes
    a service unit for systemd. It goes by the name of `myscript` and within the `[Service]`
    directive, the two most important parameters are present: `ExecStart` and `ExecStop`.
    Notice that the start and stop sections look similar to the SysV/init.d approach.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we use the `systemctl` command to enable `myscript`. Conversely, it can
    be used in the following way to disable `myscript:` `` $systemctl disable myscript`.`
    ``
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we use `systemctl` to start `myscript` and verify the status of our script.
    You should get a similar output to the following (notice that we double checked
    the presence using `ps`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: On reboot, if enable was set, our script will be running as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
