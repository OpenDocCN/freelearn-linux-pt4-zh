<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Adding Vision to Your Biped"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Adding Vision to Your Biped</h1></div></div></div><p>Now that your biped is up and mobile, is able to find barriers, and knows how to plan its path, you can now start to have it move around autonomously. However, you may want your robot to follow a color or motion.</p><p>In this chapter, you will be learning:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to add a webcam to your biped robot</li><li class="listitem" style="list-style-type: disc">How to add RaspiCam to your biped robot</li><li class="listitem" style="list-style-type: disc">How to install and use OpenCV, an open source vision package</li><li class="listitem" style="list-style-type: disc">How to follow motion with your biped robot</li></ul></div><div class="section" title="Installing a camera on your biped robot"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Installing a camera on your biped robot</h1></div></div></div><p>Having <a id="id245" class="indexterm"/>vision capability is a real advantage for your biped robot; you'll use this functionality in lots of different applications. Fortunately, adding <a id="id246" class="indexterm"/>hardware and software for vision is both easy and inexpensive. There are two choices as far as vision hardware is<a id="id247" class="indexterm"/> concerned. You can add a USB webcam to your system, or you can add RaspiCam, a camera designed specifically for Raspberry Pi.</p><div class="section" title="Installing a USB camera on Raspberry Pi"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec12"/>Installing a USB camera on Raspberry Pi</h2></div></div></div><p>Connecting <a id="id248" class="indexterm"/>a <a id="id249" class="indexterm"/>USB camera is very easy. Just plug it into the USB slot. To make sure that your device is connected, type <code class="literal">lsusb</code>. You should see the following:</p><div class="mediaobject"><img src="graphics/B04591_06_01.jpg" alt="Installing a USB camera on Raspberry Pi"/></div><p>This<a id="id250" class="indexterm"/> shows <a id="id251" class="indexterm"/>a Creative Webcam located at Bus 001 Device 004: ID 041e:4095. To make sure that the system sees this as a video device, type <code class="literal">ls /dev/v*</code> command and you should see something like the following:</p><div class="mediaobject"><img src="graphics/B04591_06_02.jpg" alt="Installing a USB camera on Raspberry Pi"/></div><p>The <code class="literal">/dev/video0</code> is the webcam device. Now that your device is connected, let's actually see if you can capture images and video. There are several tools that can allow you to access the webcam, but a simple program with video controls is called luvcview. To<a id="id252" class="indexterm"/> install this, type <code class="literal">sudo apt-get install luvcview</code>. Once the application is installed, you'll want to run it. To do this, you'll either <a id="id253" class="indexterm"/>need to be connected directly to a display or able to access Raspberry Pi via a remote VNC connection, such as vncserver, as displaying images will require a graphical interface.</p><p>Once you are connected in this manner, open a terminal window on Raspberry Pi and run <code class="literal">luvcview</code>. You should see something like the following:</p><div class="mediaobject"><img src="graphics/B04591_06_03.jpg" alt="Installing a USB camera on Raspberry Pi"/></div><p>Don't worry about the quality of the image, you'll be capturing and processing your images inside of OpenCV, a vision framework.</p></div><div class="section" title="Installing RaspiCam on Raspberry Pi"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec13"/>Installing RaspiCam on Raspberry Pi</h2></div></div></div><p>The <a id="id254" class="indexterm"/>other <a id="id255" class="indexterm"/>choice for seeing the outside world on Raspberry Pi is to use the RaspiCam. Installing this camera is a bit more involved; you are going to connect it to a special connector on the Raspberry Pi. The following is a picture of the camera with its special connector:</p><div class="mediaobject"><img src="graphics/B04591_06_04.jpg" alt="Installing RaspiCam on Raspberry Pi"/></div><p>You<a id="id256" class="indexterm"/> may also <a id="id257" class="indexterm"/>want to add the protective cover for the camera; assembling it looks like the following:</p><div class="mediaobject"><img src="graphics/B04591_06_05.jpg" alt="Installing RaspiCam on Raspberry Pi"/></div><p>Now <a id="id258" class="indexterm"/>you are ready to connect the camera to Raspberry Pi. The camera connects to the Raspberry Pi by installing it into the connector <a id="id259" class="indexterm"/>marked Camera on the Raspberry Pi. To see how this is done, see the video at <a class="ulink" href="http://www.raspberrypi.org/help/camera-module-setup/">http://www.raspberrypi.org/help/camera-module-setup/</a>.</p><p>Now<a id="id260" class="indexterm"/> that the camera is connected, you'll want to enable the camera using the <code class="literal">raspi-config</code> utility. Type <code class="literal">sudo raspi-config</code>, then select the <span class="strong"><strong>Enable Camera</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04591_06_06.jpg" alt="Installing RaspiCam on Raspberry Pi"/></div><p>Now <a id="id261" class="indexterm"/>reboot Raspberry Pi. If you are developing<a id="id262" class="indexterm"/> from a remote computer and want to see your images, you will want to open a vncserver connection between your computer and the Raspberry Pi. For details, see <a class="link" href="ch01.html" title="Chapter 1. Configuring and Programming Raspberry Pi">Chapter 1</a>, <span class="emphasis"><em>Configuring and Programming Raspberry Pi</em></span>. To take a picture with the camera, simply type <code class="literal">raspistill -o image.jpg</code>. This will take a picture with the camera, and then store the image in the <code class="literal">image.jpg</code> file. Once you have the picture, you can view it by opening the Raspberry Pi image viewer by selecting the lower left icon for <span class="strong"><strong>Menu</strong></span>, then <span class="strong"><strong>Accessories</strong></span>, and then <span class="strong"><strong>Image Viewer</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04591_06_07.jpg" alt="Installing RaspiCam on Raspberry Pi"/></div><p>Open <a id="id263" class="indexterm"/>the <span class="strong"><strong>image.jpg</strong></span> file, and you should see the<a id="id264" class="indexterm"/> results of your picture:</p><div class="mediaobject"><img src="graphics/B04591_06_08.jpg" alt="Installing RaspiCam on Raspberry Pi"/></div><p>Before you can access OpenCV with the Raspberry Pi camera, you'll need to do two things. First, you'll need to add a Python library; it is called <code class="literal">picamera</code>. To get this, and the required <a id="id265" class="indexterm"/>libraries, type <code class="literal">sudo apt-get install python-picamera python3-picamera python-rpi.gpio</code>. Second, you'll need to <a id="id266" class="indexterm"/>type <code class="literal">sudo modprobe bcm2835-v4l2</code>. The <a id="id267" class="indexterm"/>Raspberry Pi camera can now be used in the OpenCV examples in the next section.</p></div></div></div>
<div class="section" title="Downloading and installing OpenCV &#x2013; a fully featured vision library"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Downloading and installing OpenCV – a fully featured vision library</h1></div></div></div><p>Now<a id="id268" class="indexterm"/> that you have your camera connected, you can begin to access <a id="id269" class="indexterm"/>some amazing capabilities that have been provided by the open source community. Open a terminal window and type the following commands:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">sudo apt-get update</code>: You're going to download a number of new software <a id="id270" class="indexterm"/>packages, so it is good to make sure that everything is up to date.</li><li class="listitem"><code class="literal">sudo apt-get install build-essential</code>: Although you may have done <a id="id271" class="indexterm"/>this earlier, this library is essential to build OpenCV.</li><li class="listitem"><code class="literal">sudo apt-get install libavformat-dev</code>: This<a id="id272" class="indexterm"/> library provides a way to code and decode audio and video streams.</li><li class="listitem"><code class="literal">sudo apt-get install ffmpeg</code>: This library <a id="id273" class="indexterm"/>provides a way to transcode audio and video streams.</li><li class="listitem"><code class="literal">sudo apt-get install libcv2.4 libcvaux2.4 libhighgui2.4</code>: This command <a id="id274" class="indexterm"/>shows the basic OpenCV libraries. Note the number in the command. This will almost certainly change as new versions of OpenCV become available. If 2.4 does not work, either try 3.0 or search on Google for the latest version of OpenCV.</li><li class="listitem"><code class="literal">sudo apt-get install python-opencv</code>: This<a id="id275" class="indexterm"/> is the Python development kit needed for OpenCV, as you are going to use Python.</li><li class="listitem"><code class="literal">sudo apt-get install opencv-doc</code>: This <a id="id276" class="indexterm"/>command will show the documentation for OpenCV just in case you need it.</li><li class="listitem"><code class="literal">sudo apt-get install libcv-dev</code>: This <a id="id277" class="indexterm"/>command shows the header file and static libraries to compile OpenCV.</li><li class="listitem"><code class="literal">sudo apt-get install libcvaux-dev</code>: This <a id="id278" class="indexterm"/>command shows more development tools for compiling OpenCV.</li><li class="listitem"><code class="literal">sudo apt-get install libhighgui-dev</code>: This<a id="id279" class="indexterm"/> is another package that provides header files and static libraries to compile OpenCV.</li><li class="listitem">Now<a id="id280" class="indexterm"/> type <code class="literal">cp -r /usr/share/doc/opencv-doc/examples /home/pi/</code>. This will copy all the examples to your home directory.<p>Now that OpenCV is installed, you can try one of the examples. Go to the <code class="literal">/home/pi/examples/python</code> directory. If you do an <code class="literal">ls</code>, you'll see a file named <code class="literal">camera.py</code>. This file has the most basic code for capturing and<a id="id281" class="indexterm"/> displaying a stream of picture images. Before <a id="id282" class="indexterm"/>you run the code, make a copy of it using <code class="literal">cp camera.py myCamera.py</code>. Then, edit the file to look like the following:</p><div class="mediaobject"><img src="graphics/B04591_06_09.jpg" alt="Downloading and installing OpenCV – a fully featured vision library"/></div><p>The two lines that you'll add are the two with the <code class="literal">cv.SetCaptureProperty</code>; they will set the resolution of the image to 360 by 240. To run this program, you'll need to either have a display and keyboard connected to Raspberry Pi or use vncviewer. When you run the code, you should see the window displayed, as shown in the following image:</p><div class="mediaobject"><img src="graphics/B04591_06_10.jpg" alt="Downloading and installing OpenCV – a fully featured vision library"/></div><p>If you <a id="id283" class="indexterm"/>are using RaspiCam and don't see an <a id="id284" class="indexterm"/>image, you will need to run the <code class="literal">sudo modprobe bcm2835-v4l2</code> command. Now you can see the outside world!</p><p>You may want to play with the resolution to find the optimum settings for your application. Bigger images are great—they give you a more detailed view on the world—but they also take up significantly more processing power. You'll play with this more as you actually ask your system to do some real image processing. Be careful if you are going to use vncserver to understand your system performance, as this will significantly slow down the update rate. An image that is twice the size (width/height) will involve four times more processing. You can now use this capability to do a number of impressive tasks.</p></li></ol></div></div>
<div class="section" title="Edge Detection and OpenCv"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Edge Detection and OpenCv</h1></div></div></div><p>Fortunately, one<a id="id285" class="indexterm"/> of the examples in <a id="id286" class="indexterm"/>the OpenCV Python set is a program named <code class="literal">edge.py</code>. The following is that file (with blank lines removed):</p><div class="mediaobject"><img src="graphics/B04591_06_11.jpg" alt="Edge Detection and OpenCv"/></div><p>This program uses the Canny image detection algorithm implemented by OpenCV to find the edges in any image. For <a id="id287" class="indexterm"/>more on the Canny edge algorithm, refer to <a class="ulink" href="http://dasl.mem.drexel.edu/alumni/bGreen/www.pages.drexel.edu/_weg22/can_tut.html">http://dasl.mem.drexel.edu/alumni/bGreen/www.pages.drexel.edu/_weg22/can_tut.html</a> or <a class="ulink" href="http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html">http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html</a>. You <a id="id288" class="indexterm"/>captured an image earlier; you can use this program to look at the edges and to also see how setting a different threshold can show more/less edges. Run the program with the image captured earlier and you will see the following:</p><div class="mediaobject"><img src="graphics/B04591_06_12.jpg" alt="Edge Detection and OpenCv"/></div><p>You <a id="id289" class="indexterm"/>will<a id="id290" class="indexterm"/> notice that there is a threshold slide bar setting at the top. If you adjust this threshold up, it will find fewer edges—the edges that have a larger threshold. The picture for a setting of 30 is as follows:</p><div class="mediaobject"><img src="graphics/B04591_06_13.jpg" alt="Edge Detection and OpenCv"/></div><p>Now you <a id="id291" class="indexterm"/>can<a id="id292" class="indexterm"/> see how this process could be translated to an image of a blank floor and a barrier. The following is such an image with a possible barrier:</p><div class="mediaobject"><img src="graphics/B04591_06_14.jpg" alt="Edge Detection and OpenCv"/></div><p>You<a id="id293" class="indexterm"/> can calibrate the distance to the object based on the pixels and the <a id="id294" class="indexterm"/>position of the camera.</p></div>
<div class="section" title="Color and motion finding"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Color and motion finding</h1></div></div></div><p>OpenCV <a id="id295" class="indexterm"/>and your webcam can also track colored objects. This <a id="id296" class="indexterm"/>will be useful if you want your biped to follow a colored object. OpenCV makes this amazingly simple by providing some high-level libraries that can help us with this task. To accomplish this, you'll edit a file to look something like what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04591_06_15.jpg" alt="Color and motion finding"/></div><p>Let's look <a id="id297" class="indexterm"/>specifically at the code that makes it possible to isolate the <a id="id298" class="indexterm"/>colored ball:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hue_img = cv.CvtColor(frame, cv.CV_BGR2HSV):</code> This line creates a new<a id="id299" class="indexterm"/> image that stores the image as <a id="id300" class="indexterm"/>per the values of <span class="strong"><strong>hue</strong></span> (color), <span class="strong"><strong>saturation</strong></span>, and <span class="strong"><strong>value</strong></span> (<span class="strong"><strong>HSV</strong></span>), instead of the <span class="strong"><strong>red</strong></span>, <span class="strong"><strong>green</strong></span>, and <span class="strong"><strong>blue</strong></span> (<span class="strong"><strong>RGB</strong></span>) pixel values of the original image. Converting to HSV focuses our processing more on the color, as opposed to the amount of light hitting it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">threshold_img = cv.InRangeS(hue_img, low_range, high_range</code>): The <code class="literal">low_range, high_range</code> parameters determine the color range. In this case, it is an orange ball, so you want to detect the color orange. For a good tutorial on <a id="id301" class="indexterm"/>using hue to specify color, refer to <a class="ulink" href="http://www.tomjewett.com/colors/hsb.html">http://www.tomjewett.com/colors/hsb.html</a>. Also, <a class="ulink" href="http://www.shervinemami.info/colorConversion.html">http://www.shervinemami.info/colorConversion.html</a> includes a program that you can use to determine your values by selecting a specific color.<p>Run the program. If you see a single black image, move this window, and you will expose the original image window as well. Now, take your target (in this case, an orange ping-pong ball) and move it into the frame. You should see something like what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04591_06_16.jpg" alt="Color and motion finding"/></div><p>Notice <a id="id302" class="indexterm"/>the white pixels in our threshold <a id="id303" class="indexterm"/>image showing where the ball is located. You can add more OpenCV code that gives the actual location of the ball. In our original image file of the ball's location, you can actually draw a rectangle around the ball as an indicator. Edit the file to look as follows:</p><div class="mediaobject"><img src="graphics/B04591_06_17.jpg" alt="Color and motion finding"/></div></li></ul></div><p>The <a id="id304" class="indexterm"/>added lines look like <a id="id305" class="indexterm"/>the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hue_image = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV):</code> This line creates a hue image out of the RGB image that was captured. Hue is easier to deal with<a id="id306" class="indexterm"/> when trying to capture real world images; for details, refer to <a class="ulink" href="http://www.bogotobogo.com/python/OpenCV_Python/python_opencv3_Changing_ColorSpaces_RGB_HSV_HLS.php">http://www.bogotobogo.com/python/OpenCV_Python/python_opencv3_Changing_ColorSpaces_RGB_HSV_HLS.php</a>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">threshold_img = cv2.inRange(hue_image, low_range, high_range):</code> This creates a new image that contains only those pixels that occur between the <code class="literal">low_range</code> and <code class="literal">high_range</code> n-tuples.</li><li class="listitem" style="list-style-type: disc"><code class="literal">contour, hierarchy = cv2.findContours(threshold_img, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE):</code> This finds the contours, or groups of like pixels, in the <code class="literal">threshold_img</code> image.</li><li class="listitem" style="list-style-type: disc"><code class="literal">center = contour[0]:</code> This identifies the first contour.</li><li class="listitem" style="list-style-type: disc"><code class="literal">moment = cv2.moments(center):</code> This finds the moment of this group of pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(x,y),radius = cv2.minEnclosingCircle(center):</code> This gives the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> locations and the radius of the minimum circle that will enclose this group of pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">center = (int(x),int(y)):</code> Find the center of the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> locations.</li><li class="listitem" style="list-style-type: disc"><code class="literal">radius = int(radius):</code> The integer radius of the circle.</li><li class="listitem" style="list-style-type: disc"><code class="literal">img = cv2.circle(frame,center,radius,(0,255,0),2):</code> Draw a circle on the image.</li></ul></div><p>Now<a id="id307" class="indexterm"/> that the code is ready, you can run it. You should see <a id="id308" class="indexterm"/>something that looks like the following screenshot:
</p><div class="mediaobject"><img src="graphics/B04591_06_18.jpg" alt="Color and motion finding"/></div><p>You can now track your object. You can modify the color by changing the low_range and high_range n-tuples. You also have the location of your object, so you can use the location to do path planning for your robot.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Summary</h1></div></div></div><p>Your biped robot can walk, use sensors to avoid barriers, plans its path, and even see barriers or target. In the final chapter, you'll learn to connect your biped robot remotely so that you can control it and monitor it, without the wires.</p></div></body></html>