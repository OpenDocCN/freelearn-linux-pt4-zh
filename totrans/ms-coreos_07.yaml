- en: Chapter 7. Container Integration with CoreOS – Docker and Rkt
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章：容器与 CoreOS 的集成 —— Docker 和 Rkt
- en: Containers have drastically changed application development and deployment,
    and are the biggest trend in the computer industry currently. We have talked about
    Containers in almost all the chapters of this book. In this chapter, we will focus
    on the Container standards, advanced Docker topics, and basics of the Rkt Container
    runtime and how all these topics integrate with CoreOS. As Docker is pretty mature,
    we have covered only advanced Docker topics in this chapter. As the Rkt container
    runtime is still evolving, we have covered the basics of Rkt in this chapter.
    Even though Docker started as a Container runtime, Docker has evolved into a Container
    platform providing orchestration, networking, storage, and security solutions
    around containers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器彻底改变了应用程序开发和部署，是目前计算机行业的最大趋势。我们在本书的几乎所有章节中都提到了容器。在这一章中，我们将专注于容器标准、高级 Docker
    话题、Rkt 容器运行时的基础以及这些主题如何与 CoreOS 集成。由于 Docker 已经相当成熟，我们在本章中只涉及了高级 Docker 话题。由于
    Rkt 容器运行时仍在发展中，我们在本章中介绍了 Rkt 的基础内容。尽管 Docker 最初作为容器运行时起步，但它已经发展成一个容器平台，提供围绕容器的编排、网络、存储和安全解决方案。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Container standards—App Container (appc) specification , Open Container Initiative
    (OCI), Libnetwork, Container Network Interface (CNI), and Cloud Native Computing
    Foundation (CNCF)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器标准——应用容器（appc）规范、开放容器倡议（OCI）、Libnetwork、容器网络接口（CNI）和云原生计算基金会（CNCF）
- en: The Docker daemon configuration, Docker registry, Docker image signing, and
    basic Docker debugging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 守护进程配置、Docker 注册表、Docker 镜像签名和基础 Docker 调试
- en: Rkt basics and how to use Rkt with image signing, systemd, and Flannel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rkt 基础知识以及如何与镜像签名、systemd 和 Flannel 一起使用 Rkt
- en: Container standards
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 容器标准
- en: 'Standards are an important part of any technology. Standards and specifications
    allow products and technologies from different vendors to interoperate with each
    other. As developments in the Container space happened very fast in the last 1-2
    years, there was limited attention paid to standards and specifications. In the
    recent past, the industry has been working toward standards for Container runtime,
    Container networking, and Container orchestration. In majority of these cases,
    there are runtime implementations that get released along with the specification
    and this encourages faster adoption. The following are the standards'' categories
    covered in this section:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 标准是任何技术的重要组成部分。标准和规范允许来自不同供应商的产品和技术互相兼容。由于容器领域在过去 1-2 年的发展非常快速，标准和规范的关注度相对较少。近年来，行业一直在为容器运行时、容器网络和容器编排制定标准。在大多数情况下，规范发布时会附带运行时实现，这有助于更快地采用标准。以下是本节中涵盖的标准类别：
- en: 'Container image and runtime: APPC and OCI'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像与运行时：APPC 和 OCI
- en: 'Container Networking: Libnetwork and CNI'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器网络：Libnetwork 和 CNI
- en: 'Container orchestration: CNCF'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器编排：CNCF
- en: App container specification
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器规范
- en: The APPC specification provides you with a standard to describe the container
    image format, Container image discovery, Container grouping or Pods, and Container
    execution environment. Different Container runtimes implementing the APPC specification
    will be interoperable with each other. The APPC specification is primarily driven
    by CoreOS along with a few other community members. Rkt, Kurma, and Jetpack are
    examples of Container runtime implementing APPC. The following are some important
    components of APPC.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: APPC 规范为你提供了一个标准，用于描述容器镜像格式、容器镜像发现、容器编组或 Pods，以及容器执行环境。实现 APPC 规范的不同容器运行时将能够互操作。APPC
    规范主要由 CoreOS 和其他一些社区成员推动。Rkt、Kurma 和 Jetpack 是实现 APPC 的容器运行时的例子。以下是 APPC 中一些重要的组件。
- en: The Container image format
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像格式
- en: This describes the container image layout, manifest file with image details,
    and image signing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了容器镜像的布局、包含镜像详细信息的清单文件以及镜像签名。
- en: 'Application Container Image (ACI) is a Container image created according to
    the APPC specification. For example, the `nginx.aci` image is an ACI for the nginx
    Container. To understand Container image format, let''s look at what is contained
    within nginx.aci APPC image. The following command extracts the contents of the
    `nginx.aci` image to the `nginx` directory: (We got the `nginx.aci` image from
    the `docker2aci` tool that will be covered later in the chapter.)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器镜像（ACI）是按照 APPC 规范创建的容器镜像。例如，`nginx.aci` 镜像是 nginx 容器的 ACI。为了理解容器镜像格式，让我们看看
    nginx.aci APPC 镜像中包含的内容。以下命令将 `nginx.aci` 镜像的内容提取到 `nginx` 目录：（我们从稍后章节中将介绍的 `docker2aci`
    工具获得了 `nginx.aci` 镜像。）
- en: '`tar -xvf nginx.aci -C nginx`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`tar -xvf nginx.aci -C nginx`'
- en: 'The following set of screenshots shows you the base layout and rootfs layout
    for the `nginx.aci` image:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一组截图展示了 `nginx.aci` 镜像的基础布局和 rootfs 布局：
- en: '![](img/00119.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.jpg)'
- en: '![](img/00121.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00121.jpg)'
- en: 'The following are some important sections in the `nginx.aci` manifest. The
    first screenshot shows the container name and version. The second screenshot describes
    the exposed ports, mountpoints, environment variables, and so on:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `nginx.aci` 清单中的一些重要部分。第一张截图显示了容器的名称和版本。第二张截图描述了暴露的端口、挂载点、环境变量等：
- en: '![](img/00073.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpg)'
- en: '![](img/00077.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpg)'
- en: From the preceding screenshot, we can see that nginx ACI image is exposing ports
    `80` and `443` and it has mount `point /var/cache/nginx`. Container image signing
    is done using GPG ([https://www.gnupg.org/](https://www.gnupg.org/)). GPG is a
    public key cryptography implementation that can be used for the encryption of
    messages as well as image signing using a public and private key pair.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述截图中，我们可以看到 nginx ACI 镜像暴露了 `80` 和 `443` 端口，并且它有挂载点 `/var/cache/nginx`。容器镜像的签名使用
    GPG 完成（[https://www.gnupg.org/](https://www.gnupg.org/)）。GPG 是一种公钥加密实现，可用于消息加密以及使用公钥和私钥对进行镜像签名。
- en: Container image discovery
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像发现
- en: 'Container image discovery describes ways to find the location of Container
    images from image name. Container images use the URL format. Container image discovery
    describes ways to find the location of Container images from image name. The following
    is the image format used:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像发现描述了如何根据镜像名称查找容器镜像的位置。容器镜像使用 URL 格式。容器镜像发现描述了如何根据镜像名称查找容器镜像的位置。以下是使用的镜像格式：
- en: '`https://{name}-{version}-{os}-{arch}.{ext}`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://{name}-{version}-{os}-{arch}.{ext}`'
- en: Simple discovery
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 简单发现
- en: 'Here, the complete URL is mentioned to retrieve the ACI image. An example is
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，提到了完整的 URL 来检索 ACI 镜像。示例如下：
- en: '[https://github.com/coreos/etcd/releases/download/v2.0.0/etcd-v2.0.0-linux-amd64.aci](https://github.com/coreos/etcd/releases/download/v2.0.0/etcd-v2.0.0-linux-amd64.aci)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/coreos/etcd/releases/download/v2.0.0/etcd-v2.0.0-linux-amd64.aci](https://github.com/coreos/etcd/releases/download/v2.0.0/etcd-v2.0.0-linux-amd64.aci)'
- en: Meta discovery
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Meta 发现
- en: Here, the image URL and public key is discovered automatically by using the
    meta tag embedded in the HTTP location. The following example shows you how to
    retrieve the meta tag and the ACI image from meta tags for the CoreOS etcd container
    image.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，图像 URL 和公钥是通过使用嵌入在 HTTP 位置中的 meta 标签自动发现的。以下示例展示了如何从 meta 标签中检索 meta 标签和
    ACI 图像，用于 CoreOS etcd 容器镜像。
- en: The first step is to retrieve the meta tags. The `https://coreos.com/etcd` location
    contains the `ac-discovery` meta tag that contains the image location and the
    `ac-discovery-pubkeys` meta tag that contains the public key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是检索 meta 标签。`https://coreos.com/etcd` 位置包含 `ac-discovery` meta 标签，该标签包含镜像位置，还有
    `ac-discovery-pubkeys` meta 标签，其中包含公钥。
- en: 'The link, [https://coreos.com/etcd/](https://coreos.com/etcd/), contains the
    following meta tags that can be retrieved as an HTTP request:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 链接 [https://coreos.com/etcd/](https://coreos.com/etcd/) 包含以下可以作为 HTTP 请求检索的
    meta 标签：
- en: '`<meta name="ac-discovery" content="coreos.com/etcd https://github.com/coreos/etcd/releases/download/{version}/etcd-{version}-{os}-{arch}.{ext}">
    <meta name="ac-discovery-pubkeys" content="coreos.com/etcd https://coreos.com/dist/pubkeys/aci-pubkeys.gpg">`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`<meta name="ac-discovery" content="coreos.com/etcd https://github.com/coreos/etcd/releases/download/{version}/etcd-{version}-{os}-{arch}.{ext}">
    <meta name="ac-discovery-pubkeys" content="coreos.com/etcd https://coreos.com/dist/pubkeys/aci-pubkeys.gpg">`'
- en: 'Using the preceding meta tag content, the Container image can be retrieved
    from the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述 meta 标签内容，可以从以下位置检索容器镜像：
- en: '`https://github.com/coreos/etcd/releases/download/{version}/etcd-{version}-{os}-{arch}.{ext}`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://github.com/coreos/etcd/releases/download/{version}/etcd-{version}-{os}-{arch}.{ext}`'
- en: 'The public key can be retrieved from the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从以下位置获取公钥：
- en: '`https://coreos.com/dist/pubkeys/aci-pubkeys.gpg`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://coreos.com/dist/pubkeys/aci-pubkeys.gpg`'
- en: The app container executor
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器执行器
- en: 'The app container executor takes care of the following to set up runtime for
    the Container:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器执行器负责以下操作，以设置容器的运行时环境：
- en: 'UUID setup: This is a Unique ID for the Pod that contains multiple containers.
    UUID is registered with the metadata service that allows other containers to find
    each other.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UUID设置：这是包含多个容器的Pod的唯一ID。UUID会在元数据服务中注册，允许其他容器找到彼此。
- en: 'Filesystem setup: A filesystem is created in its own namespace.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统设置：在其自己的命名空间中创建文件系统。
- en: 'Volume setup: These are files to be mounted to the container.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷设置：这些是要挂载到容器的文件。
- en: 'Networking: This specifies Container networking to the host and other Containers.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设置：指定容器与主机及其他容器的网络连接。
- en: 'Isolators: This controls the CPU and memory limit for the Container.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离器：用于控制容器的CPU和内存限制。
- en: App container pods
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器Pod
- en: The concept of pods comes from Kubernetes where related containers are packed
    together in a Pod. Containers within a pod share the process PID, network, and
    IPC namespace. A manifest can be created for the Pod in addition to individual
    containers in order to describe properties for the Pod.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Pods的概念来自Kubernetes，其中相关的容器被打包在一个Pod中。Pod中的容器共享进程PID、网络和IPC命名空间。除了单独的容器之外，还可以为Pod创建清单，以描述Pod的属性。
- en: The app container metadata service
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器元数据服务
- en: The app container metadata service is a service that runs externally, and container
    pods can register information about pods and applications. This metadata service
    can be used by pods to find information about other pods as well as by containers
    within a pod to find information about other containers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用容器元数据服务是一个外部运行的服务，容器Pod可以注册关于Pod和应用的信息。Pod可以使用此元数据服务查找其他Pod的信息，Pod中的容器也可以通过此服务查找其他容器的信息。
- en: APPC tools
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: APPC工具
- en: APPC provides you with tools to create, validate, and convert ACI images.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: APPC为您提供了创建、验证和转换ACI镜像的工具。
- en: Actool
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Actool
- en: 'Using Actool for ACI validation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Actool进行ACI验证：
- en: 'The following output shows you that the generated ACI image, `busybox-latest.aci`,
    is a valid APPC image:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示生成的ACI镜像`busybox-latest.aci`是一个有效的APPC镜像：
- en: '![](img/00081.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpg)'
- en: 'Using Actool for ACI discovery:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Actool进行ACI发现：
- en: 'The following output shows you the discovery URL and public key from the ACI
    image:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了ACI镜像的发现URL和公钥：
- en: '![](img/00086.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpg)'
- en: 'Using Actool for checking manifest:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Actool检查清单：
- en: 'The following output shows you how to see the manifest from the ACI image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了如何查看ACI镜像的清单：
- en: '![](img/00091.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpg)'
- en: Acbuild
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Acbuild
- en: The Acbuild tool is used to build ACI images. The concept is similar to the
    Dockerfile approach to build Docker Container images, but Acbuild provides more
    flexibility to build Container images by having better integration with Linux
    tools such as makefile, environment variables, and others.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Acbuild工具用于构建ACI镜像。其概念类似于使用Dockerfile构建Docker容器镜像的方法，但Acbuild通过更好的与Linux工具（如makefile、环境变量等）集成，提供了更大的灵活性来构建容器镜像。
- en: 'The following is an example of building a container image from a GO executable
    `hello`. Before running the following commands, we need to link the `hello` executable
    in the current directory statically:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从GO可执行文件`hello`构建容器镜像的示例。在运行以下命令之前，我们需要静态链接当前目录中的`hello`可执行文件：
- en: '`acbuild begin``acbuild set-name example.com/hello``acbuild copy hello /bin/hello``acbuild set-exec /bin/hello``acbuild port add www tcp 5000``acbuild label add version 0.0.1``acbuild annotation add authors "Sreenivas Makam<sxxxm@yahoo.com>"``acbuild write hello-0.0.1-linux-amd64.aci``acbuild end`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`acbuild begin``acbuild set-name example.com/hello``acbuild copy hello /bin/hello``acbuild
    set-exec /bin/hello``acbuild port add www tcp 5000``acbuild label add version
    0.0.1``acbuild annotation add authors "Sreenivas Makam<sxxxm@yahoo.com>"``acbuild
    write hello-0.0.1-linux-amd64.aci``acbuild end`'
- en: If we run the preceding commands, it will create an APPC image, `hello-0.0.1-linux-amd64.aci`,
    which we can run with the Rkt Container runtime.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的命令，它将创建一个APPC镜像`hello-0.0.1-linux-amd64.aci`，我们可以使用Rkt容器运行时运行该镜像。
- en: 'The following is another example that is similar to the Dockerfile approach
    to build an ACI image. In this example, we take a base Ubuntu image, install Apache,
    and start Apache in a container to create the `ubuntu-nginx.aci` image:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个示例，它类似于Dockerfile方法来构建ACI镜像。在这个示例中，我们以基础的Ubuntu镜像为基础，安装Apache，并在容器中启动Apache，以创建`ubuntu-nginx.aci`镜像：
- en: '`acbuild begin``acbuild dependency add quay.io/fermayo/ubuntu``acbuild run -- apt-get update``acbuild run -- apt-get -y install nginx``acbuild set-exec -- /usr/sbin/nginx –g "daemon=off;"``acbuild set-name example.com/ubuntu-nginx``acbuild write ubuntu-nginx.aci``acbuild end`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`acbuild begin``acbuild dependency add quay.io/fermayo/ubuntu``acbuild run
    -- apt-get update``acbuild run -- apt-get -y install nginx``acbuild set-exec --
    /usr/sbin/nginx –g "daemon=off;"``acbuild set-name example.com/ubuntu-nginx``acbuild
    write ubuntu-nginx.aci``acbuild end`'
- en: 'To run acbuild, it''s necessary to have systemd-nspawn in the system. This
    is present by default in CoreOS nodes. The following is the APPC image that was
    created from the preceding script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行acbuild，系统中需要有systemd-nspawn。CoreOS节点默认包含此功能。以下是通过前面脚本创建的APPC镜像：
- en: '![](img/00096.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpg)'
- en: 'Let''s start the Container using Rkt:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Rkt启动容器：
- en: '![](img/00101.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpg)'
- en: 'The following is the running Container''s status:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是正在运行的容器状态：
- en: '![](img/00107.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpg)'
- en: Docker2aci
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Docker2aci
- en: 'The Docker2aci utility is used to convert Docker Containers to the ACI format.
    The following is an example that takes a docker `busybox` container and converts
    it to a `busybox.aci` image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Docker2aci工具用于将Docker容器转换为ACI格式。以下是一个示例，将docker `busybox`容器转换为`busybox.aci`镜像：
- en: '![](img/00113.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpg)'
- en: Open Container Initiative
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 开放容器倡议
- en: 'OCI is the Open Container Initiative open source project started in April 2015
    by Docker and has members from all major companies including Docker and CoreOS.
    OCI defines the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: OCI是开放容器倡议（Open Container Initiative）开源项目，由Docker于2015年4月启动，并且有来自所有主要公司的成员，包括Docker和CoreOS。OCI定义了以下内容：
- en: 'The Container image format: This describes the filesystem bundle along with
    `config.json` that describes the host-independent property of a container and
    `runtime.json` that describes the host-dependent property of a container.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像格式：这描述了文件系统包，以及`config.json`，它描述了容器的主机无关属性，以及`runtime.json`，它描述了容器的主机相关属性。
- en: 'Runtime: This describes how a container can be started and stopped using namespaces
    and cgroups.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时：这描述了如何使用命名空间和cgroups启动和停止容器。
- en: Docker's goal is to follow the OCI specification for its Container runtime.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的目标是遵循OCI规范来实现其容器运行时。
- en: Runc
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Runc
- en: Runc is an implementation of the OCI specification. Docker engine uses runc
    to implement Container runtime in Docker. Runc can be installed using the procedure
    described at [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Runc是OCI规范的实现。Docker引擎使用runc在Docker中实现容器运行时。可以按照[https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)中的过程安装runc。
- en: 'The following procedure can be used to start a Ubuntu container using `runc`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程可用于使用`runc`启动Ubuntu容器：
- en: '`Docker pull Ubuntu``docker export $(docker create ubuntu) > ubuntu.tar``mkdir rootfs``tar -C rootfs -xf ubuntu.tar``runc spec`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Docker pull Ubuntu``docker export $(docker create ubuntu) > ubuntu.tar``mkdir
    rootfs``tar -C rootfs -xf ubuntu.tar``runc spec`'
- en: The first step pulls the Ubuntu Docker Container. The second step exports the
    Ubuntu Container to a filesystem. The third and fourth steps put the Ubuntu filesystem
    content in the `rootfs` directory. The last step generates `config.json` and `runtime.json`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步拉取Ubuntu Docker容器。第二步将Ubuntu容器导出为文件系统。第三步和第四步将Ubuntu文件系统内容放入`rootfs`目录。最后一步生成`config.json`和`runtime.json`。
- en: 'The following output shows you the Ubuntu container started using `runc`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出展示了使用`runc`启动的Ubuntu容器：
- en: '![](img/00118.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00118.jpg)'
- en: The relationship of OCI with APPC
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OCI与APPC的关系
- en: CoreOS, along with a few other community members, created the APPC specification
    to standardize the Container image format that makes Containers interoperable
    between different implementations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS和一些其他社区成员创建了APPC规范，以标准化容器镜像格式，使容器在不同的实现之间互操作。
- en: 'The original APPC container specification proposed by CoreOS covers four different
    elements of container management: packaging, signing, naming (sharing the container
    with others), and runtime. Docker felt the same need for interoperability and
    created OCI along with other community members including CoreOS. OCI focuses only
    on packaging and runtime currently, though this might change in the future. The
    goals of APPC and OCI are common even though specifics slightly differ. It is
    possible that these two standards will converge into one standard at some later
    point.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS 提出的原始 APPC 容器规范涵盖了容器管理的四个不同元素：打包、签名、命名（与他人共享容器）和运行时。Docker 也感受到互操作性的需求，并与包括
    CoreOS 在内的其他社区成员共同创建了 OCI。当前，OCI 主要专注于打包和运行时，尽管未来可能会有所变化。尽管具体细节略有不同，APPC 和 OCI
    的目标是相同的。这两个标准可能会在未来某个时刻合并为一个标准。
- en: OCI and APPC latest updates
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: OCI 和 APPC 最新更新
- en: As per the latest CoreOS blog update ([https://coreos.com/blog/making-sense-of-standards.html](https://coreos.com/blog/making-sense-of-standards.html)),
    APPC and OCI will intersect only in runtime and APPC will continue to focus on
    image format, signing, and distribution.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 CoreOS 最新的博客更新（[https://coreos.com/blog/making-sense-of-standards.html](https://coreos.com/blog/making-sense-of-standards.html)），APPC
    和 OCI 仅在运行时相交，APPC 将继续关注镜像格式、签名和分发。
- en: Libnetwork
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Libnetwork
- en: 'Libnetwork was covered briefly in [Chapter 5](index_split_122.html#filepos342077),
    CoreOS Networking and Flannel Internals. Libnetwork is an open source project
    started by Docker and a few other community members with the following objectives:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Libnetwork 在[第 5 章](index_split_122.html#filepos342077)中简要介绍过，内容涉及 CoreOS 网络和
    Flannel 内部结构。Libnetwork 是由 Docker 和其他一些社区成员发起的开源项目，目标如下：
- en: Keep networking as a library separate from the Container runtime.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将网络作为库与容器运行时分离。
- en: Provide Container connectivity in the same host as well as across hosts.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供同一主机以及跨主机的容器连接。
- en: Networking implementation will be done as a plugin implemented by drivers. The
    plugin mechanism is provided to add new third-party drivers easily.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络实现将作为由驱动程序实现的插件进行。提供插件机制以便轻松添加新的第三方驱动程序。
- en: Control IP address assignment for the Containers using local IPAM drivers and
    plugins.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地 IPAM 驱动程序和插件控制容器的 IP 地址分配。
- en: Docker uses Libnetwork to provide Container networking.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使用 Libnetwork 提供容器网络。
- en: 'There are three primary components in Libnetwork:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Libnetwork 中有三个主要组件：
- en: 'Sandbox: All networking functionality is encapsulated in a sandbox. This can
    be implemented using networking namespace or a similar function.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙箱：所有网络功能都封装在沙箱中。可以使用网络命名空间或类似功能来实现。
- en: 'Endpoint: This attaches sandbox to the network.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点：将沙箱附加到网络。
- en: 'Network: Multiple endpoints in the same network can talk to each other.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络：同一网络中的多个端点可以相互通信。
- en: 'The following diagram shows Sandbox, Endpoint, and Network and how two containers
    can talk to each other using these constructs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了沙箱、端点和网络，以及两个容器如何通过这些结构相互通信：
- en: '![](img/00020.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpg)'
- en: Libnetwork supports local drivers such as null, bridge, and overlay. The bridge
    driver can be used for Container connectivity in a single host, and the overlay
    driver can be used for Container connectivity across hosts. Remote drivers such
    as Weave and Calico are also supported.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Libnetwork 支持本地驱动程序，如 null、bridge 和 overlay。bridge 驱动程序可用于单一主机中的容器连接，overlay
    驱动程序可用于跨主机的容器连接。也支持远程驱动程序，如 Weave 和 Calico。
- en: CNI
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: CNI
- en: CNI was covered briefly in [Chapter 5](index_split_122.html#filepos342077),
    CoreOS Networking and Flannel Internals.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CNI 在[第 5 章](index_split_122.html#filepos342077)中简要介绍过，内容涉及 CoreOS 网络和 Flannel
    内部结构。
- en: CNI is the Container networking interface open source project developed by CoreOS
    along with a few other community members to provide networking facility for Containers
    as a pluggable and extensible mechanism. CoreOS's Container runtime, Rkt, uses
    CNI to establish Container networking. The objectives of Libnetwork and CNI are
    pretty much the same.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: CNI 是由 CoreOS 和其他一些社区成员开发的开源容器网络接口项目，为容器提供作为可插拔和可扩展机制的网络功能。CoreOS 的容器运行时 Rkt
    使用 CNI 来建立容器网络。Libnetwork 和 CNI 的目标几乎相同。
- en: 'The following are some notes on CNI:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于 CNI 的一些说明：
- en: The CNI interface calls the API of the CNI plugin to set up Container networking.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CNI 接口调用 CNI 插件的 API 来设置容器网络。
- en: The CNI plugin is responsible for creating the network interface to the container.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CNI 插件负责为容器创建网络接口。
- en: The CNI plugin calls the IPAM plugin to set up the IP address for the container.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CNI 插件调用 IPAM 插件来为容器设置 IP 地址。
- en: The CNI plugin needs to implement an API for container network creation and
    deletion.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CNI 插件需要实现一个 API，用于容器网络的创建和删除。
- en: The plugin type and parameters are specified as a JSON file that the Container
    runtime reads and sets up.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件类型和参数被指定为一个 JSON 文件，容器运行时读取并设置该文件。
- en: Available CNI plugins are Bridge, macvlan, ipvlan, and ptp. Available IPAM plugins
    are host-local and DHCP. CNI plugins and the IPAM plugin can be used in any combination.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的 CNI 插件包括桥接、macvlan、ipvlan 和 ptp。可用的 IPAM 插件包括 host-local 和 DHCP。CNI 插件和
    IPAM 插件可以任意组合使用。
- en: External CNI plugins such as Flannel and Weave are also supported. External
    plugins reuse the bridge plugin to set up the final networking.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也支持外部 CNI 插件，如 Flannel 和 Weave。外部插件重用桥接插件来设置最终的网络。
- en: 'The following is a sample JSON configuration with the bridge CNI plugin and
    host-local IPAM plugin along with the IP allocation range:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个示例 JSON 配置，包含桥接 CNI 插件和主机本地 IPAM 插件，以及 IP 分配范围：
- en: '`{     "name": "mynet",     "type": "bridge",     "bridge": "mynet0",     "isGateway": true,
        "ipMasq": true,     "ipam": {         "type": "host-local",         "subnet": "10.10.0.0/16"
        } }`'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{     "name": "mynet",     "type": "bridge",     "bridge": "mynet0",     "isGateway": true,
        "ipMasq": true,     "ipam": {         "type": "host-local",         "subnet": "10.10.0.0/16"
        } }`'
- en: 'The following is a sample JSON configuration that uses the Flannel CNI type:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个示例 JSON 配置，使用了 Flannel CNI 类型：
- en: '`{         "name": "containernet",         "type": "flannel" }`'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{         "name": "containernet",         "type": "flannel" }`'
- en: 'The following figure shows you the relationship between Rkt, CNI, the CNI plugin,
    and IPAM plugin:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Rkt、CNI、CNI 插件和 IPAM 插件之间的关系：
- en: '![](img/00022.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpg)'
- en: The relationship between Libnetwork and CNI
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Libnetwork 与 CNI 之间的关系
- en: Libnetwork and CNI have similar objectives. Docker uses Libnetwork and CoreOS,
    with Rkt, uses CNI. Libnetwork's overlay driver does something that is similar
    to CNI's flannel driver. The goal of external plugins such as Weave and Calico
    is to work with both Libnetwork and CNI.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Libnetwork 和 CNI 的目标相似。Docker 使用 Libnetwork，而 CoreOS 使用 Rkt 并使用 CNI。Libnetwork
    的覆盖驱动程序与 CNI 的 Flannel 驱动程序执行类似的操作。像 Weave 和 Calico 这样的外部插件的目标是与 Libnetwork 和
    CNI 一起工作。
- en: Cloud Native Computing Foundation
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生计算基金会
- en: The goal of CNCF is to make it easier to build Cloud native applications using
    Containers. CNCF will create reference architectures using best open source technologies
    around Containers for microservice based distributed application. The initial
    goal of CNCF is Container orchestration and the integration work is focused on
    Kubernetes with Mesos. CNCF will create the reference architecture for microservice
    development that can help enterprises to build on the reference architecture rather
    than integrating components by themselves. As per the latest CoreOS blog ([https://coreos.com/blog/making-sense-of-standards.html](https://coreos.com/blog/making-sense-of-standards.html)),
    CoreOS will be donating etcd, flannel, and appc to CNCF.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: CNCF 的目标是简化使用容器构建云原生应用的过程。CNCF 将使用容器周围的最佳开源技术，为基于微服务的分布式应用创建参考架构。CNCF 的初始目标是容器编排，集成工作重点放在
    Kubernetes 与 Mesos 上。CNCF 将为微服务开发创建参考架构，帮助企业基于参考架构进行构建，而不是自行集成组件。根据最新的 CoreOS
    博客（[https://coreos.com/blog/making-sense-of-standards.html](https://coreos.com/blog/making-sense-of-standards.html)），CoreOS
    将把 etcd、flannel 和 appc 捐赠给 CNCF。
- en: Docker
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Docker
- en: Even though Container technology has been available for a long time, Docker
    has revolutionized the Container technology by making the creation and transportation
    of Containers very user-friendly. Other than providing Container runtime, Docker
    provides you with networking, storage, and orchestration solutions for containers.
    For the majority of these solutions, Docker provides a pluggable model where the
    Docker native solution is provided, which can be swapped with any other third-party
    solution. This gives flexibility to the customer to use technologies that they
    are already comfortable with.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器技术已经存在很长时间，Docker 通过使容器的创建和传输变得非常用户友好，彻底革新了容器技术。除了提供容器运行时，Docker 还为容器提供网络、存储和编排解决方案。对于这些解决方案中的大多数，Docker
    提供了一个可插拔的模型，提供 Docker 原生解决方案，并且可以与任何第三方解决方案交换。这为客户提供了灵活性，允许他们使用自己已经熟悉的技术。
- en: In [Chapter 1](index_split_023.html#filepos77735), CoreOS Overview, we covered
    the Docker architecture. As Docker technology is pretty mature, we will cover
    only the advanced Docker concepts in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](index_split_023.html#filepos77735)，CoreOS概述中，我们讲解了Docker架构。由于Docker技术已经相当成熟，本章将只讲解高级Docker概念。
- en: The Docker daemon and an external connection
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程和外部连接
- en: Docker runs as a daemon and by default listens on the Unix socket, `unix:///var/run/docker.sock`.
    Docker start options are specified in `/etc/default/docker`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Docker作为守护进程运行，默认情况下监听Unix套接字`unix:///var/run/docker.sock`。Docker启动选项在`/etc/default/docker`中指定。
- en: 'To allow external Docker clients to talk to the Docker daemon, the following
    procedure is to be performed in the Ubuntu node:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许外部Docker客户端与Docker守护进程通信，需要在Ubuntu节点中执行以下步骤：
- en: 'Add the TCP server with the local address and port number:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加具有本地地址和端口号的TCP服务器：
- en: '`DOCKER_OPTS="-D -H unix:///var/run/docker.sock -H tcp://192.168.56.101:2376"`'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DOCKER_OPTS="-D -H unix:///var/run/docker.sock -H tcp://192.168.56.101:2376"`'
- en: 'Restart the docker daemon:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启Docker守护进程：
- en: '`Sudo service docker restart`'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Sudo service docker restart`'
- en: 'Now, we can see that the Docker daemon is exposing external connectivity on
    the IP address `192.168.56.101` and TCP port number `2376`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以看到Docker守护进程正在通过IP地址`192.168.56.101`和TCP端口号`2376`暴露外部连接：
- en: '![](img/00026.jpg)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00026.jpg)'
- en: 'We can connect from external Docker clients as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式从外部Docker客户端连接：
- en: '`docker –H tcp://192.168.56.101:2376 ps`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker -H tcp://192.168.56.101:2376 ps`'
- en: 'The following image shows that apache container is running:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了Apache容器正在运行：
- en: '![](img/00027.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpg)'
- en: Dockerfile
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Dockerfile is used to create Docker Container images using specified instructions
    in Dockerfile. Typically, Dockerfile starts with a base container image, installs
    the necessary applications, and starts the process associated with the container.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile用于通过Dockerfile中的指定指令创建Docker容器镜像。通常，Dockerfile以基础容器镜像开始，安装必要的应用程序，然后启动与容器相关的进程。
- en: 'For Dockerfile best practices, you can refer to the following link:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Dockerfile的最佳实践，您可以参考以下链接：
- en: '[https://docs.docker.com/engine/articles/dockerfile_best-practices/](https://docs.docker.com/engine/articles/dockerfile_best-practices/)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/articles/dockerfile_best-practices/](https://docs.docker.com/engine/articles/dockerfile_best-practices/)'
- en: 'The following is an example Dockerfile for creating an Apache container from
    the Ubuntu base image. This Dockerfile installs the Apache package and exposes
    port `80` to the outside world from the Container:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例Dockerfile，用于从Ubuntu基础镜像创建一个Apache容器。此Dockerfile安装Apache包并将`80`端口暴露给外部世界：
- en: '`FROM ubuntu:14.04 MAINTAINER Sreenivas Makam <sxxxm@yahoo.com> # Update RUN apt-get update
    # Install apache2 RUN apt-get install -y apache2 # Expose necessary ports EXPOSE 80
    # Start application ENTRYPOINT ["/usr/sbin/apache2ctl"] CMD ["-D", "FOREGROUND"]`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM ubuntu:14.04 MAINTAINER Sreenivas Makam <sxxxm@yahoo.com> # 更新 RUN apt-get
    update # 安装apache2 RUN apt-get install -y apache2 # 暴露必要端口 EXPOSE 80 # 启动应用程序
    ENTRYPOINT ["/usr/sbin/apache2ctl"] CMD ["-D", "FOREGROUND"]`'
- en: To create a Docker image, execute the following command in the directory where
    the preceding Dockerfile is present. In the example below, `smakam/apache1` is
    the name of the Container image. The default convention for Container image name
    is `username/imagename:tag`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Docker镜像，在包含上述Dockerfile的目录中执行以下命令。以下示例中，`smakam/apache1`是容器镜像的名称。容器镜像名称的默认约定是`用户名/镜像名称:标签`。
- en: '`docker build -t smakam/apache1 .`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build -t smakam/apache1 .`'
- en: 'The following screenshot shows you the created Apache container image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了创建的Apache容器镜像：
- en: '![](img/00030.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpg)'
- en: The Docker Image repository
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像仓库
- en: 'The Docker image repository is used to save and restore Docker Container images
    from a common server location. There are three possible solutions that Docker
    provides for storing Container images:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像仓库用于从公共服务器位置保存和恢复Docker容器镜像。Docker为存储容器镜像提供了三种可能的解决方案：
- en: 'Docker hub: This is the Docker image repository service that''s hosted by Docker
    itself at [https://hub.docker.com/](https://hub.docker.com/). This is a free service
    provided by Docker.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub：这是由Docker公司提供的Docker镜像仓库服务，网址为[https://hub.docker.com/](https://hub.docker.com/)。这是一个由Docker免费提供的服务。
- en: 'Docker registry: This is an open source project ([https://github.com/docker/distribution](https://github.com/docker/distribution))
    that allows customers to host the Docker registry in their own premises. The latest
    Docker registry is version 2.0\. Docker registry 2.0 overcomes some of the shortcomings
    of Docker registry 1.x for better security and performance.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 注册表：这是一个开源项目（[https://github.com/docker/distribution](https://github.com/docker/distribution)），允许客户在自己的本地环境中托管
    Docker 注册表。最新的 Docker 注册表是版本 2.0。Docker 注册表 2.0 克服了 Docker 注册表 1.x 的一些不足，提供了更好的安全性和性能。
- en: 'Docker Trusted registry: This is Docker''s commercial implementation ([https://www.docker.com/docker-trusted-registry](https://www.docker.com/docker-trusted-registry))
    of the Docker registry and adds features such as role-based user authentication,
    integration with an external directory service such as LDAP, GUI-based administrative
    management, support, and so on. Both the Docker registry and Docker Trusted registry
    support integration with external storage drivers such as AWS, Azure, and Swift
    to store Docker images.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Trusted Registry：这是 Docker 的商业实现（[https://www.docker.com/docker-trusted-registry](https://www.docker.com/docker-trusted-registry)），增加了角色基于的用户身份验证、与
    LDAP 等外部目录服务的集成、基于 GUI 的管理管理、技术支持等功能。Docker 注册表和 Docker Trusted Registry 都支持与
    AWS、Azure 和 Swift 等外部存储驱动程序集成，以存储 Docker 镜像。
- en: 'The following diagram captures the three Docker image repository types:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了三种 Docker 镜像仓库类型：
- en: '![](img/00031.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpg)'
- en: 'Docker images have this format:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像格式如下：
- en: '`[REGISTRYHOST/][USERNAME/]NAME[:TAG]`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`[REGISTRYHOST/][USERNAME/]NAME[:TAG]`'
- en: '`REGISTRYHOST`: The registry server address'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REGISTRYHOST`：注册表服务器地址'
- en: '`USERNAME`: The username that created the image'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USERNAME`：创建镜像的用户名'
- en: '`NAME`: The Container image name'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME`：容器镜像的名称'
- en: '`TAG`: The version of the Container image'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TAG`：容器镜像的版本'
- en: Except `NAME`, the other arguments are optional
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 `NAME` 外，其他参数是可选的
- en: 'For example, the following command will pull a standard Ubuntu container image
    from the Docker hub; `registry-1.docker.io/library` is the registry host, the
    name is `Ubuntu`, and the tag is `latest`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的命令将从 Docker Hub 拉取一个标准的 Ubuntu 容器镜像；`registry-1.docker.io/library` 是注册表主机，镜像名为
    `Ubuntu`，标签为 `latest`：
- en: '`docker pull registry-1.docker.io/library/Ubuntu:latest`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker pull registry-1.docker.io/library/Ubuntu:latest`'
- en: Similar to the Docker registry, CoreOS has the Quay registry ([https://quay.io/](https://quay.io/))
    to store Docker and Rkt images, and they have a public and enterprise version
    available.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Docker 注册表，CoreOS 也有 Quay 注册表（[https://quay.io/](https://quay.io/)），用于存储
    Docker 和 Rkt 镜像，它们提供了公共版和企业版。
- en: Creating your own Docker registry
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你自己的 Docker 注册表
- en: It is useful to create a local registry to share images in a particular company
    or group. This is important from a security perspective since there is no need
    to access Internet to access registry. The Docker registry provides you with options
    for authentication, backend storage drivers (for example, S3, Azure, and Swift),
    logging, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建本地注册表以在特定公司或团队内部共享镜像是非常有用的。从安全角度来看，这一点尤其重要，因为这样就无需访问互联网即可访问注册表。Docker 注册表为你提供了身份验证、后端存储驱动程序（例如，S3、Azure
    和 Swift）、日志记录等功能。
- en: 'To start a local registry, use the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动本地注册表，使用以下命令：
- en: '`docker run -d -p 5000:5000 --restart=always --name registry registry:2`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run -d -p 5000:5000 --restart=always --name registry registry:2`'
- en: 'The following screenshot shows you the registry running as container. The registry
    service is exposed on port `5000` in the localhost:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了作为容器运行的注册表。注册表服务通过本地 `5000` 端口暴露：
- en: '![](img/00033.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpg)'
- en: The registry configuration is specified either as an environment variable as
    part of starting the registry container or using a YAML file with the configuration
    and mounting this YAML file to `/etc/config/registry/config.yaml` in the container.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表配置可以通过环境变量的方式在启动注册表容器时指定，或者使用包含配置的 YAML 文件并将该 YAML 文件挂载到容器中的 `/etc/config/registry/config.yaml`。
- en: 'The following set of commands pulls a busybox container from the Docker hub,
    pushes the busybox container in the local registry, and then pulls it out from
    the local registry:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令组从 Docker Hub 拉取一个 busybox 容器，推送 busybox 容器到本地注册表，然后从本地注册表拉取它：
- en: '`docker pull busybox``docker tag busybox localhost:5000/mybusybox``docker push localhost:5000/mybusybox``docker pull localhost:5000/mybusybox`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker pull busybox``docker tag busybox localhost:5000/mybusybox``docker push
    localhost:5000/mybusybox``docker pull localhost:5000/mybusybox`'
- en: 'The following screenshot shows you the `mybusybox` container that has been
    pulled from the local registry:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了已从本地注册表拉取的`mybusybox`容器：
- en: '![](img/00034.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpg)'
- en: 'The following screenshot shows you the instantiation of the `mybusybox` container
    from the local registry:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了从本地注册表实例化`mybusybox`容器的过程：
- en: '![](img/00035.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpg)'
- en: Continuous integration
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成
- en: 'When we push Docker images to the Docker Hub, Dockerfile does not get pushed.
    To push the Dockerfile and use it for automated Container builds, we need to link
    it with a repository management tool such as GitHub or Bitbucket. The steps are
    as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将Docker镜像推送到Docker Hub时，Dockerfile不会被推送。为了将Dockerfile推送并用于自动化容器构建，我们需要将其与一个仓库管理工具（如GitHub或Bitbucket）关联。具体步骤如下：
- en: Get an account in GitHub or Bitbucket.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub或Bitbucket中创建一个账户。
- en: From Docker Hub, we can link either to GitHub or Bitbucket.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker Hub，我们可以链接到GitHub或Bitbucket。
- en: Push the Dockerfile to GitHub.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Dockerfile推送到GitHub。
- en: From DockerHub, when we create a repository, select automated build, and select
    the location from GitHub where Dockerfile is present. This will build the image
    automatically. Additionally, when there are changes to Dockerfile committed to
    GitHub, automatic builds are triggered.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker Hub，当我们创建一个仓库时，选择自动构建，并选择GitHub中Dockerfile所在的位置。这将自动构建镜像。此外，当Dockerfile在GitHub上有变更并提交时，自动构建会被触发。
- en: 'The following diagram shows you the CI sequence using Dockerfile, from staging
    to production:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了使用Dockerfile的CI流程，从暂存到生产：
- en: '![](img/00038.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpg)'
- en: 'The following screenshot shows the automated build creation in Docker Hub after
    creating Dockerfile in GitHub. In the following example, Dockerfile is present
    in [https://github.com/smakam/docker.git](https://github.com/smakam/docker.git)
    under the Apache directory:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在GitHub中创建Dockerfile后，Docker Hub中的自动化构建创建过程。在以下示例中，Dockerfile位于[https://github.com/smakam/docker.git](https://github.com/smakam/docker.git)的Apache目录下：
- en: '![](img/00039.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpg)'
- en: 'When any changes are made, an automatic container image is built. The following
    screenshot shows the successful container image build log for `smakam/apacheauto`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当有任何更改时，自动构建容器镜像。以下截图显示了`smakam/apacheauto`的成功容器镜像构建日志：
- en: '![](img/00041.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpg)'
- en: 'The following screenshot shows a successful pull of the `smakam/apacheauto`
    container image:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了成功拉取`smakam/apacheauto`容器镜像：
- en: '![](img/00043.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpg)'
- en: The Docker content trust
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Docker内容信任
- en: 'The Docker content trust provides you with a mechanism to sign and publish
    Docker images so that the client who pulls the image can be guaranteed that the
    image is from a trusted source and has not been modified by any man-in-the-middle
    attack. The following are some features of the Docker content trust:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Docker内容信任为您提供了一种机制，用于签署和发布Docker镜像，以确保拉取镜像的客户端能够确认该镜像来自受信任的来源，并且没有被中间人攻击篡改。以下是Docker内容信任的一些特性：
- en: The Docker content trust is an implementation of the Notary open source project
    ([https://github.com/docker/notary](https://github.com/docker/notary)). The Notary
    open source project is based on The Update Framework (TUF) project ([https://theupdateframework.github.io/](https://theupdateframework.github.io/)).
    TUF provides a mechanism to secure software updates.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker内容信任是Notary开源项目的实现（[https://github.com/docker/notary](https://github.com/docker/notary)）。Notary开源项目基于The
    Update Framework（TUF）项目（[https://theupdateframework.github.io/](https://theupdateframework.github.io/)）。TUF提供了一种机制来保障软件更新的安全性。
- en: Compared to the GPG approach of signing keys, TUF has some unique differentiators.
    TUF takes care of the freshness of keys so that the client always knows that they
    are getting the latest content. Key compromise can be handled better with TUF
    using the key rotation scheme, which clients need not be aware of. TUF also provides
    you with the capability of signing collections rather than individual software.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与GPG签名密钥的方法相比，TUF具有一些独特的区分点。TUF负责密钥的新鲜度，以确保客户端始终知道他们获得的是最新的内容。使用TUF的密钥轮换机制，可以更好地处理密钥泄露问题，客户端无需了解此过程。TUF还为您提供了签署集合而不是单独软件的能力。
- en: There are four keys with Notary—the Timestamp key to maintain the freshness
    of the image, the Snapshot key to sign image collections, the Target key for the
    regular signing of images, and the Offline key for key rotation.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Notary有四个密钥——Timestamp密钥用于保持镜像的新鲜度，Snapshot密钥用于签署镜像集合，Target密钥用于定期签署镜像，Offline密钥用于密钥轮换。
- en: The Docker content trust has been released with Docker version 1.8\. The default
    option is trust-disabled and can be enabled using the `DOCKER_CONTENT_TRUST` environment
    variable. At some later point, the default option would be to keep the trust enabled.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker内容信任已随Docker版本1.8发布。默认选项为禁用信任，可以通过`DOCKER_CONTENT_TRUST`环境变量启用。在某个时刻，默认选项将变为保持启用信任。
- en: 'The following figure shows you the relationship between TUF, Notary, and the
    Docker content trust:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了TUF、Notary和Docker内容信任之间的关系：
- en: '![](img/00044.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpg)'
- en: 'The following is the workflow with the Docker content trust:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是启用Docker内容信任的工作流程：
- en: The Docker registry needs to support the Docker content trust. The Docker Hub
    supports the content trust. The Docker trusted registry and private registry do
    not yet support the content trust; this will be added soon.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册表需要支持Docker内容信任。Docker Hub支持内容信任。Docker受信任注册表和私有注册表尚不支持内容信任；此功能将在不久的将来添加。
- en: The usual Docker commands can be used for push and pull, and care has been taken
    not to change Docker commands. For advanced key management, the Notary CLI can
    be used.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用常规的Docker命令进行推送和拉取，并且特别注意不更改Docker命令。对于高级密钥管理，可以使用Notary CLI。
- en: When the publisher pushes the image for the first time using `docker push`,
    there is a need to enter a passphrase for the root key and tagging key. All other
    keys are generated automatically. These keys need to be stored safely.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发布者第一次使用`docker push`推送镜像时，需要输入根密钥和标记密钥的密码短语。其他所有密钥会自动生成。这些密钥需要安全存储。
- en: For any further image publishing, only the tagging key is necessary.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何进一步的镜像发布，只需要标记密钥。
- en: The client has the option to pull signed or unsigned images. With the Docker
    trust enabled, the client will get an error if they try to pull unsigned images.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以选择拉取签名或未签名的镜像。启用Docker信任时，如果尝试拉取未签名的镜像，客户端会收到错误提示。
- en: Pushing secure image
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 推送安全镜像
- en: 'First, we enable the Docker content trust using the `DOCKER_CONTENT_TRUST`
    environment variable. The following is the output when the Docker content trust
    is enabled and we are publishing the image for the first time. Here, we are pushing
    the signed `smakam/mybusybox:v1` container:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过`DOCKER_CONTENT_TRUST`环境变量启用Docker内容信任。以下是启用Docker内容信任并首次发布镜像时的输出。这里，我们正在推送签名的`smakam/mybusybox:v1`容器：
- en: '![](img/00045.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpg)'
- en: Pulling secure image
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取安全镜像
- en: 'The following is the output when we are pulling the same secure image, `smakam/mybusybox:v1`,
    from the Docker hub:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们从Docker Hub拉取相同安全镜像`smakam/mybusybox:v1`时的输出：
- en: '![](img/00048.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.jpg)'
- en: Pulling same image with no security
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有安全性的情况下拉取相同的镜像
- en: 'The following is the output when we try to pull the same image, `smakam/mybusybox:v1`,
    with no Docker content trust. In this case, image verification is not done:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们尝试在没有Docker内容信任的情况下拉取相同镜像`smakam/mybusybox:v1`时的输出。在这种情况下，不会进行镜像验证：
- en: '![](img/00001.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00001.jpg)'
- en: 'The following is the error message that we will get if we enable the trust
    and try to pull Docker images that are not signed. As `smakam/hellocounter` is
    not signed and we have `DOCKER_CONTENT_TRUST` enabled, we get an error:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如果我们启用信任并尝试拉取未签名的Docker镜像时会得到的错误消息。由于`smakam/hellocounter`没有签名，并且我们已启用`DOCKER_CONTENT_TRUST`，因此会出现错误：
- en: '![](img/00003.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00003.jpg)'
- en: Recently, Docker has enabled the content trust using hardware keys ([https://blog.docker.com/2015/11/docker-content-trust-yubikey/](https://blog.docker.com/2015/11/docker-content-trust-yubikey/)).
    This is currently in the experimental mode.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Docker启用了使用硬件密钥的内容信任（[https://blog.docker.com/2015/11/docker-content-trust-yubikey/](https://blog.docker.com/2015/11/docker-content-trust-yubikey/)）。目前处于实验模式。
- en: Container debugging
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 容器调试
- en: The following are some basic Container debugging approaches.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些基本的容器调试方法。
- en: Logs
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 日志
- en: The following command will show container logs. This can be a useful debugging
    tool. In [Chapter 10](index_split_219.html#filepos708963), CoreOS and Containers
    - Troubleshooting and Debugging, you will learn how to aggregate and analyze Container
    logs from a central location.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将显示容器日志。这是一个有用的调试工具。在[第10章](index_split_219.html#filepos708963)《CoreOS与容器
    - 故障排除与调试》中，您将学习如何从中央位置汇总和分析容器日志。
- en: '`docker logs <containername or id>`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker logs <containername or id>`'
- en: Login inside Container
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到容器内
- en: 'The `docker exec` command can be used to log in to the container. The following
    is an example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker exec`命令可以用于登录到容器。以下是一个示例：'
- en: '![](img/00006.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpg)'
- en: Common Linux commands can be executed from the Container shell.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从容器 shell 中执行常见的 Linux 命令。
- en: Container properties
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 容器属性
- en: 'The following command will show container properties such as mount points,
    resource limits, and so on:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将显示容器属性，如挂载点、资源限制等：
- en: '`docker inspect <containername or id>`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker inspect <containername or id>`'
- en: Container processes
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 容器进程
- en: 'The following command will show processes running in the container sorted by
    the process CPU usage:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将显示容器中按 CPU 使用率排序的进程：
- en: '`docker top <containername or id>`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker top <containername or id>`'
- en: 'The following is a sample output for a `redis` container:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`redis`容器的示例输出：
- en: '![](img/00009.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpg)'
- en: The Container's CPU and memory usage
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的 CPU 和内存使用情况
- en: 'The following command will show the resource usage of a Container:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将显示容器的资源使用情况：
- en: '`docker stats <containername or id>`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker stats <containername or id>`'
- en: 'The following is a sample output for the Apache container:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Apache 容器的示例输出：
- en: '![](img/00013.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpg)'
- en: Rkt
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt
- en: 'Rkt is the Container runtime from CoreOS based on the APPC specification. The
    following are some differences in Rkt compared to Docker:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt 是 CoreOS 基于 APPC 规范的容器运行时。以下是与 Docker 相比 Rkt 的一些区别：
- en: Rkt is daemonless. The problem of Containers going away if the Docker daemon
    restarts does not exist with Rkt.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rkt 是无守护进程的。容器在 Docker 守护进程重启时消失的问题在 Rkt 中不存在。
- en: Rkt integrates well with systemd so that container resource limits can be set
    easily for the Containers.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rkt 与 systemd 集成良好，因此容器的资源限制可以轻松设置。
- en: 'There are three stages in the Rkt execution:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt 执行有三个阶段：
- en: '`Stage0`: This does the image discovery and retrieval and sets up a filesystem
    for stages 1 and 2.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stage0`：此阶段进行镜像发现和检索，并为阶段 1 和 2 设置文件系统。'
- en: '`Stage1`: This sets up the execution environment for the container execution
    using the filesystem set up by `stage0`. Rkt uses systemd-nspawn to set up cgroups,
    networking, and so on in this stage. The goal here is to keep `stage1` swappable
    by other implementations.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stage1`：此阶段使用由`stage0`设置的文件系统来设置容器执行环境。Rkt 在此阶段使用 systemd-nspawn 来设置 cgroups、网络等。目标是使`stage1`可以被其他实现替换。'
- en: '`Stage2`: This is the actual execution of the Container pod and application
    itself using the execution environment set up by `stage1` and filesystem set up
    by `stage0`.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stage2`：这是实际执行容器 Pod 和应用程序本身，使用由`stage1`设置的执行环境和由`stage0`设置的文件系统。'
- en: 'The following example illustrates the stages. Let''s start the `hello` ACI
    image using Rkt:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了各个阶段。让我们使用 Rkt 启动 `hello` ACI 镜像：
- en: '`sudo rkt --insecure-skip-verify run hello-0.0.1-linux-amd64.aci`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt --insecure-skip-verify run hello-0.0.1-linux-amd64.aci`'
- en: '![](img/00015.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpg)'
- en: 'The following shows the `stage1` filesystem setup by `stage0`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了由`stage0`设置的`stage1`文件系统：
- en: '![](img/00018.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpg)'
- en: 'The manifest here shows the Rkt `stage1` ACI that sets up the container environment:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的清单展示了设置容器环境的 Rkt `stage1` ACI：
- en: '![](img/00021.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpg)'
- en: 'The following shows the `stage2` filesystem:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了`stage2`文件系统：
- en: '![](img/00025.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpg)'
- en: 'The manifest here shows the hello Rkt container image:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的清单展示了 hello Rkt 容器镜像：
- en: '![](img/00002.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00002.jpg)'
- en: 'The following shows the filesystem for the hello application:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了 hello 应用程序的文件系统：
- en: '![](img/00004.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00004.jpg)'
- en: 'Rkt application is available in the CoreOS base image. Rkt can also be installed
    in any Linux system using the procedure described at [https://github.com/coreos/rkt](https://github.com/coreos/rkt).
    The following is the Rkt version running in the Ubuntu 14.04 system:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt 应用程序在 CoreOS 基础镜像中可用。也可以按照 [https://github.com/coreos/rkt](https://github.com/coreos/rkt)
    中的步骤在任何 Linux 系统上安装 Rkt。以下是在 Ubuntu 14.04 系统中运行的 Rkt 版本：
- en: '![](img/00007.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpg)'
- en: 'The following is the Rkt and APPC version used in the CoreOS alpha image 815.0.0:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 CoreOS alpha 镜像 815.0.0 中使用的 Rkt 和 APPC 版本：
- en: '![](img/00010.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpg)'
- en: Basic commands
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 基本命令
- en: The following are some basic commands to manipulate Rkt Containers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些基本命令，用于操作 Rkt 容器。
- en: Fetch image
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 获取镜像
- en: 'The following command fetches a Container image from the repository in the
    ACI format:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令从仓库中以 ACI 格式获取容器镜像：
- en: '`sudo rkt --insecure-skip-verify fetch docker://busybox`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt --insecure-skip-verify fetch docker://busybox`'
- en: '![](img/00014.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpg)'
- en: List images
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列出镜像
- en: 'The following command lists Rkt Container images:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出 Rkt 容器镜像：
- en: '`sudo rkt image list`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt image list`'
- en: '![](img/00016.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpg)'
- en: Run image
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 运行镜像
- en: 'The following command runs the Rkt Container image:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令运行 Rkt 容器镜像：
- en: '`sudo rkt run --insecure-skip-verify --interactive docker://busybox`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt run --insecure-skip-verify --interactive docker://busybox`'
- en: 'By default, signature verification is turned on; we disable signature verification
    using the `skip-verify` option:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，签名验证是启用的；我们使用 `skip-verify` 选项禁用签名验证：
- en: '![](img/00019.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpg)'
- en: List pods
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 pods
- en: 'The following command lists the running pods:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出正在运行的 pods：
- en: '`sudo rkt list pods`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt list pods`'
- en: '![](img/00422.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00422.jpg)'
- en: Garbage collection
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: 'The following screenshot shows two pods that have exited:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了两个已退出的 Pod：
- en: '![](img/00423.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00423.jpg)'
- en: 'The exited Containers will be garbage collected periodically. To force garbage
    collection, we can perform the following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 已退出的容器将定期进行垃圾回收。要强制进行垃圾回收，我们可以执行以下命令：
- en: '`rkt gc --grace-period=0`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`rkt gc --grace-period=0`'
- en: '![](img/00426.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00426.jpg)'
- en: 'Now, we can see that there are no active pods:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到没有活动的 Pod：
- en: '![](img/00427.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00427.jpg)'
- en: Delete image
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 删除镜像
- en: 'The following command deletes the local Container image:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令删除本地的容器镜像：
- en: '`sudo rkt image rm sha512-cf74c26d8d35555066dce70bd94f513b90cbef6e7e9c01ea0c971f4f6d689848`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt image rm sha512-cf74c26d8d35555066dce70bd94f513b90cbef6e7e9c01ea0c971f4f6d689848`'
- en: 'The following screenshot shows the deletion of the busybox image using UUID:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了如何使用 UUID 删除 busybox 镜像：
- en: '![](img/00429.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00429.jpg)'
- en: Export image
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 导出镜像
- en: 'The following command converts a Docker image to the ACI format:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将 Docker 镜像转换为 ACI 格式：
- en: '`sudo rkt image export nginx nginx.aci`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt image export nginx nginx.aci`'
- en: '![](img/00431.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00431.jpg)'
- en: The nginx container with volume mounting and port forwarding
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 含有卷挂载和端口转发的 nginx 容器
- en: 'The following command starts the nginx container forwarding the container port
    `80` to the host port `8080` and setting up the host volume. The volume directory
    and port name are as specified in the manifest file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令启动 nginx 容器，将容器端口 `80` 转发到主机端口 `8080` 并设置主机卷。卷目录和端口名称如清单文件中所指定：
- en: '`sudo rkt run --insecure-skip-verify --private-net --port=80-tcp:8080 --volume volume-var-cache-nginx,kind=host,source=/home/core docker://nginx`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt run --insecure-skip-verify --private-net --port=80-tcp:8080 --volume
    volume-var-cache-nginx,kind=host,source=/home/core docker://nginx`'
- en: '![](img/00433.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00433.jpg)'
- en: 'The following screenshot shows successful web page access using the nginx container
    and host port `8080`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了通过 nginx 容器和主机端口 `8080` 成功访问网页：
- en: '![](img/00434.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00434.jpg)'
- en: Pod status
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 状态
- en: 'The following command lists the status of a particular Pod using UUID:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出特定 Pod 的状态，使用 UUID：
- en: '`sudo rkt status 2b165196`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt status 2b165196`'
- en: '![](img/00436.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00436.jpg)'
- en: Rkt image signing
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt 镜像签名
- en: Container image signing allows us to verify that the image is coming from a
    trusted location and has not been tampered with. I used the procedure at [https://github.com/coreos/rkt/blob/master/Documentation/signing-and-verification-guide.md](https://github.com/coreos/rkt/blob/master/Documentation/signing-and-verification-guide.md)
    to sign the ACI image and use Rkt to run the signed image.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像签名允许我们验证镜像是否来自受信任的来源，并且没有被篡改。我使用了 [https://github.com/coreos/rkt/blob/master/Documentation/signing-and-verification-guide.md](https://github.com/coreos/rkt/blob/master/Documentation/signing-and-verification-guide.md)
    中的过程来签名 ACI 镜像，并使用 Rkt 运行签名镜像。
- en: 'The following is a sample `nginx.service` systemd unit file:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例 `nginx.service` systemd 单元文件：
- en: 'Generate keys:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成密钥：
- en: '`gpg --batch --gen-key gpg-batch`'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gpg --batch --gen-key gpg-batch`'
- en: Note
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'In case you get this error message, `Not enough random bytes available. Please
    do some other work to give the OS a chance to collect more entropy!`, it can be
    solved by the following rngd tool that can be run in parallel:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你看到这个错误信息，`Not enough random bytes available. Please do some other work to
    give the OS a chance to collect more entropy!`，可以通过以下的 rngd 工具来解决，该工具可以并行运行：
- en: '`apt-get install rng-tools``sudo rngd -r /dev/urandom`'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`apt-get install rng-tools``sudo rngd -r /dev/urandom`'
- en: 'Trust the keys:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信任密钥：
- en: '`gpg --no-default-keyring --secret-keyring ./rkt.sec --keyring ./rkt.pub --edit-key 1FEEF0ED trust`'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gpg --no-default-keyring --secret-keyring ./rkt.sec --keyring ./rkt.pub --edit-key
    1FEEF0ED trust`'
- en: 'Export the public key:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出公钥：
- en: '`gpg --no-default-keyring --armor \``--secret-keyring ./rkt.sec --keyring ./rkt.pub \``--export <email> > pubkeys.gpg`'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gpg --no-default-keyring --armor \``--secret-keyring ./rkt.sec --keyring ./rkt.pub
    \``--export <email> > pubkeys.gpg`'
- en: 'Sign the image using the public key:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用公钥签名镜像：
- en: '`gpg --no-default-keyring --armor \``--secret-keyring ./rkt.sec --keyring ./rkt.pub \``--output hello-0.0.1-linux-amd64.aci.asc \``--detach-sig hello-0.0.1-linux-amd64.aci`'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gpg --no-default-keyring --armor \``--secret-keyring ./rkt.sec --keyring ./rkt.pub
    \``--output hello-0.0.1-linux-amd64.aci.asc \``--detach-sig hello-0.0.1-linux-amd64.aci`'
- en: 'Host the web server with the ACI image, public key, and signature. The following
    are the contents in my web server location:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ACI 镜像、公共密钥和签名托管 web 服务器。以下是我 web 服务器位置中的内容：
- en: '![](img/00437.jpg)'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00437.jpg)'
- en: 'The following is the `index.html` content:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是 `index.html` 的内容：
- en: '`<head> <meta name="ac-discovery" content="example.com/hello http://example.com/hello-0.0.1-linux-amd64.aci">
    <meta name="ac-discovery-pubkeys" content="example.com/hello http://example.com/pubkeys.gpg">
    </head>`'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<head> <meta name="ac-discovery" content="example.com/hello http://example.com/hello-0.0.1-linux-amd64.aci">
    <meta name="ac-discovery-pubkeys" content="example.com/hello http://example.com/pubkeys.gpg">
    </head>`'
- en: 'Trust the web server location and key:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信任 web 服务器位置和密钥：
- en: '`sudo rkt trust --prefix=example.com/hello http://example.com/pubkeys.gpg --insecure-allow-http`'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sudo rkt trust --prefix=example.com/hello http://example.com/pubkeys.gpg --insecure-allow-http`'
- en: Modify `/etc/hosts` to point `example.com` to localhost.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `/etc/hosts` 将 `example.com` 指向 localhost。
- en: 'Start a simple web server:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个简单的 web 服务器：
- en: '`sudo python -m SimpleHTTPServer 80`'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sudo python -m SimpleHTTPServer 80`'
- en: 'Now, we can run the Rkt image with signature verification:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行带有签名验证的 Rkt 镜像：
- en: '`sudo rkt run --debug http://example.com/hello-0.0.1-linux-amd64.aci`'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo rkt run --debug http://example.com/hello-0.0.1-linux-amd64.aci`'
- en: 'The following screenshot shows the signature being verified. The signature
    location and public key are provided by the hosted web server at `example.com`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了签名正在被验证。签名位置和公钥由托管的 web 服务器 `example.com` 提供：
- en: '![](img/00439.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00439.jpg)'
- en: Rkt with systemd
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt 与 systemd
- en: Systemd provides you with a lot of control over how processes are managed. Rkt
    pods can be managed by systemd. With systemd, we can control the process execution
    order, restartability, resource limit, and so on.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd 为你提供了对进程管理的强大控制。Rkt pods 可以由 systemd 管理。通过 systemd，我们可以控制进程执行顺序、重启能力、资源限制等。
- en: 'The following is a sample `nginx.service` systemd unit file:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 `nginx.service` systemd 单元文件的示例：
- en: '`[Unit] Description=nginx  [Service] # Resource limits CPUShares=512 MemoryLimit=1G
    # Prefetch the image ExecStartPre=/usr/bin/rkt fetch --insecure-skip-verify docker://nginx
    ExecStart=/usr/bin/rkt run --insecure-skip-verify --private-net --port=80-tcp:8080 --volume volume-var-cache-nginx,kind=host,source=/home/co
    re docker://nginx KillMode=mixed Restart=always`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Unit] Description=nginx  [Service] # 资源限制 CPUShares=512 MemoryLimit=1G #
    预取镜像 ExecStartPre=/usr/bin/rkt fetch --insecure-skip-verify docker://nginx ExecStart=/usr/bin/rkt
    run --insecure-skip-verify --private-net --port=80-tcp:8080 --volume volume-var-cache-nginx,kind=host,source=/home/core
    docker://nginx KillMode=mixed Restart=always`'
- en: In the preceding service file, we started the nginx container and also limited
    the CPU and memory usage for this `nginx.service` using the systemd construct.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的服务文件中，我们启动了 nginx 容器，并使用 systemd 构造限制了该 `nginx.service` 的 CPU 和内存使用。
- en: 'To start the service, it''s necessary to place `nginx.service` in `/etc/systemd/system`.
    The service can be started as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务，必须将 `nginx.service` 放置在 `/etc/systemd/system` 目录中。可以通过以下命令启动服务：
- en: '`Sudo systemctl start nginx.service`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sudo systemctl start nginx.service`'
- en: 'The following screenshot shows you the status of `nginx.service`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了 `nginx.service` 的状态：
- en: '![](img/00442.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00442.jpg)'
- en: 'To show the power of integration with systemd, let''s kill the Rkt nginx process
    and demonstrate restartability:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示与 systemd 集成的强大功能，让我们终止 Rkt nginx 进程并演示重启功能：
- en: '![](img/00444.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00444.jpg)'
- en: Systemd will restart the nginx container because `restart` is turned on in `nginx.service`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 `nginx.service` 中启用了 `restart`，所以 systemd 会重新启动 nginx 容器。
- en: 'From the following `journalctl` logs on `nginx.service`, we can see that the
    service has been restarted:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下 `journalctl` 日志中，我们可以看到服务已被重新启动：
- en: '![](img/00445.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00445.jpg)'
- en: 'In the following screenshot, we can see that the Rkt nginx process is running
    with a different PID:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们可以看到 Rkt nginx 进程正在以不同的 PID 运行：
- en: '![](img/00448.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00448.jpg)'
- en: Rkt with Flannel
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt 与 Flannel
- en: Rkt uses the CNI interface to talk to the Flannel plugin to establish container
    networking across hosts.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt 使用 CNI 接口与 Flannel 插件进行通信，跨主机建立容器网络。
- en: 'The following example sets up a three-node CoreOS cluster using Rkt and Flannel
    for Container networking. The following is the necessary `cloud-config`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 Rkt 和 Flannel 配置一个三节点的 CoreOS 集群，用于容器网络。以下是必要的 `cloud-config`：
- en: '`#cloud-config  coreos:   etcd2:     #generate a new token for each unique cluster from https://discovery.etcd.io/new
        discovery: <your token>     # multi-region and multi-cloud deployments need to use $public_ipv4
        advertise-client-urls: http://$public_ipv4:2379     initial-advertise-peer-urls: http://$private_ipv4:2380
        # listen on both the official ports and the legacy ports     # legacy ports can be omitted if your application doesn''t depend on them
        listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001     listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001
      fleet:     public-ip: $public_ipv4   flannel:     interface: $public_ipv4   units:
        - name: etcd2.service       command: start     - name: fleet.service       command: start
        - name: flanneld.service       drop-ins:         - name: 50-network-config.conf
              content: |             [Service]             ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config ''{ "network": "10.1.0.0/16" }''
          command: start     - name: docker-tcp.socket       command: start       enable: true
          content: |         [Unit]         Description=Docker Socket for the API          [Socket]
            ListenStream=2375         Service=docker.service         BindIPv6Only=both          [Install]
            WantedBy=sockets.target write_files:   - path: "/etc/rkt/net.d/10-containernet.conf"
        permissions: "0644"     owner: "root"     content: |       {         "name": "containernet",
            "type": "flannel"       }`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`#cloud-config  coreos:   etcd2:     #为每个唯一集群从https://discovery.etcd.io/new生成一个新的令牌
        discovery: <your token>     # 多区域和多云部署需要使用$public_ipv4     advertise-client-urls: http://$public_ipv4:2379
        initial-advertise-peer-urls: http://$private_ipv4:2380     # 监听官方端口和传统端口     # 如果您的应用程序不依赖于传统端口，可以省略
        listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001     listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001
      fleet:     public-ip: $public_ipv4   flannel:     interface: $public_ipv4   units:
        - name: etcd2.service       command: start     - name: fleet.service       command: start
        - name: flanneld.service       drop-ins:         - name: 50-network-config.conf
              content: |             [Service]             ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config ''{ "network": "10.1.0.0/16" }''
          command: start     - name: docker-tcp.socket       command: start       enable: true
          content: |         [Unit]         Description=Docker Socket for the API          [Socket]
            ListenStream=2375         Service=docker.service         BindIPv6Only=both          [Install]
            WantedBy=sockets.target write_files:   - path: "/etc/rkt/net.d/10-containernet.conf"
        permissions: "0644"     owner: "root"     content: |       {         "name": "containernet",
            "type": "flannel"       }`'
- en: The `/etc/rkt/net.d/10-containernet.conf` file sets up the CNI plugin type as
    Flannel.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/rkt/net.d/10-containernet.conf`文件将CNI插件类型设置为Flannel。'
- en: Flannel gets an individual subnet for each host using the IP range specified
    in the flannel configuration `10.1.0.0/16`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Flannel为每个主机分配了一个独立的子网，使用的是在flannel配置中指定的IP范围`10.1.0.0/16`。
- en: 'The following output shows you the subnet allocated in `node1` and `node2`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了在`node1`和`node2`中分配的子网：
- en: '![](img/00449.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00449.jpg)'
- en: '![](img/00451.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00451.jpg)'
- en: 'Let''s create Rkt containers in each node and check inter-container connectivity:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在每个节点上创建Rkt容器，并检查容器间的连接性：
- en: '![](img/00452.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00452.jpg)'
- en: 'The following output shows you that the busybox container in `core-01` got
    the IP, `10.1.74.4`, which is in the `10.1.74.1/24` range allocated for `core-01`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了`core-01`上的busybox容器获得了IP地址`10.1.74.4`，该IP地址位于为`core-01`分配的`10.1.74.1/24`范围内：
- en: '![](img/00454.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00454.jpg)'
- en: 'The following output shows you that the busybox container in `core-03` got
    the IP, `10.1.3.2`, which is in the `10.1.3.1/24` range allocated for `core-03`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了`core-03`上的busybox容器获得了IP地址`10.1.3.2`，该IP地址位于为`core-03`分配的`10.1.3.1/24`范围内：
- en: '![](img/00455.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00455.jpg)'
- en: 'The following output shows you a successful ping from container 1 on `core-01`
    to container 2 on `core-03`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了从`core-01`上的容器1成功ping通`core-03`上的容器2：
- en: '![](img/00457.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00457.jpg)'
- en: Summary
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered different Container standards for Container runtime,
    networking, and orchestration. Having these standards is important from the industry
    perspective for interoperability reasons. Container runtime systems like Docker
    and Rkt were covered in detail. For Docker, the focus was on advanced concepts,
    and for Rkt, we covered the basics as Rkt is still in the early stages. Even though
    CoreOS is actively developing Rkt, CoreOS is committed to supporting Docker in
    its OS. It will be interesting to see how Docker and Rkt run together in CoreOS
    and how customers adopt the two Container runtime technologies. In the next chapter,
    we will cover Container orchestration.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了不同的容器标准，包括容器运行时、网络和编排。从行业角度来看，拥有这些标准对于互操作性非常重要。我们详细讨论了 Docker 和 Rkt
    这两种容器运行时系统。对于 Docker，我们关注了高级概念，而对于 Rkt，我们介绍了基础知识，因为 Rkt 仍处于早期阶段。尽管 CoreOS 正在积极开发
    Rkt，但 CoreOS 承诺在其操作系统中支持 Docker。接下来，Docker 和 Rkt 如何在 CoreOS 中一起运行以及客户如何采纳这两种容器运行时技术将是非常有趣的。在下一章中，我们将介绍容器编排。
- en: References
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Notary GitHub: [https://github.com/docker/notary](https://github.com/docker/notary)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Notary GitHub: [https://github.com/docker/notary](https://github.com/docker/notary)'
- en: 'Docker registry: [https://github.com/docker/distribution](https://github.com/docker/distribution)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker 注册表: [https://github.com/docker/distribution](https://github.com/docker/distribution)'
- en: 'Docker content trust documentation: [https://docs.docker.com/security/trust/content_trust/](https://docs.docker.com/security/trust/content_trust/)'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker 内容信任文档: [https://docs.docker.com/security/trust/content_trust/](https://docs.docker.com/security/trust/content_trust/)'
- en: 'Docker content trust blog: [https://blog.docker.com/2015/08/content-trust-docker-1-8/](https://blog.docker.com/2015/08/content-trust-docker-1-8/)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker 内容信任博客: [https://blog.docker.com/2015/08/content-trust-docker-1-8/](https://blog.docker.com/2015/08/content-trust-docker-1-8/)'
- en: 'The Update framework: [http://theupdateframework.com/](http://theupdateframework.com/)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Update 框架: [http://theupdateframework.com/](http://theupdateframework.com/)'
- en: 'Cloud native compute foundation: [https://cncf.io](https://cncf.io)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '云原生计算基金会: [https://cncf.io](https://cncf.io)'
- en: 'Open container initiative: [https://github.com/opencontainers](https://github.com/opencontainers)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '开放容器倡议: [https://github.com/opencontainers](https://github.com/opencontainers)'
- en: 'APPC specification: [https://github.com/appc](https://github.com/appc)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'APPC 规范: [https://github.com/appc](https://github.com/appc)'
- en: 'Libnetwork: [https://github.com/docker/libnetwork](https://github.com/docker/libnetwork)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Libnetwork: [https://github.com/docker/libnetwork](https://github.com/docker/libnetwork)'
- en: 'Docker2aci: [https://github.com/appc/docker2aci](https://github.com/appc/docker2aci)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker2aci: [https://github.com/appc/docker2aci](https://github.com/appc/docker2aci)'
- en: 'CoreOS Rkt documentation: [https://coreos.com/rkt/docs/latest/](https://coreos.com/rkt/docs/latest/)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CoreOS Rkt 文档: [https://coreos.com/rkt/docs/latest/](https://coreos.com/rkt/docs/latest/)'
- en: 'Acbuild: [https://github.com/appc/acbuild](https://github.com/appc/acbuild)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Acbuild: [https://github.com/appc/acbuild](https://github.com/appc/acbuild)'
- en: Further reading and tutorials
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读和教程
- en: 'The CNI presentation: [https://www.youtube.com/watch?v=_-9kItVUUCw](https://www.youtube.com/watch?v=_-9kItVUUCw)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CNI 演示文稿: [https://www.youtube.com/watch?v=_-9kItVUUCw](https://www.youtube.com/watch?v=_-9kItVUUCw)'
- en: 'Docker registry presentations: [https://www.youtube.com/watch?v=RnO9JnEO8tY](https://www.youtube.com/watch?v=RnO9JnEO8tY)
    and [https://www.youtube.com/watch?v=cVsUhoJFPvQ](https://www.youtube.com/watch?v=cVsUhoJFPvQ)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker 注册表演示文稿: [https://www.youtube.com/watch?v=RnO9JnEO8tY](https://www.youtube.com/watch?v=RnO9JnEO8tY)
    和 [https://www.youtube.com/watch?v=cVsUhoJFPvQ](https://www.youtube.com/watch?v=cVsUhoJFPvQ)'
- en: 'The Docker Notary presentation: [https://www.youtube.com/watch?v=JvjdfQC8jxM](https://www.youtube.com/watch?v=JvjdfQC8jxM)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker Notary 演示文稿: [https://www.youtube.com/watch?v=JvjdfQC8jxM](https://www.youtube.com/watch?v=JvjdfQC8jxM)'
- en: 'The Container standards presentation: [http://containersummit.io/events/sf-2015/videos/container-ecosystem-standards-needs-and-progress](http://containersummit.io/events/sf-2015/videos/container-ecosystem-standards-needs-and-progress)'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '容器标准演示文稿: [http://containersummit.io/events/sf-2015/videos/container-ecosystem-standards-needs-and-progress](http://containersummit.io/events/sf-2015/videos/container-ecosystem-standards-needs-and-progress)'
- en: 'The Rkt and APPC presentation: [https://www.youtube.com/watch?v=C8Qpdrpm16Y](https://www.youtube.com/watch?v=C8Qpdrpm16Y)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Rkt 和 APPC 演示文稿: [https://www.youtube.com/watch?v=C8Qpdrpm16Y](https://www.youtube.com/watch?v=C8Qpdrpm16Y)'
