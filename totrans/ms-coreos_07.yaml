- en: Chapter 7. Container Integration with CoreOS – Docker and Rkt
  prefs: []
  type: TYPE_NORMAL
- en: Containers have drastically changed application development and deployment,
    and are the biggest trend in the computer industry currently. We have talked about
    Containers in almost all the chapters of this book. In this chapter, we will focus
    on the Container standards, advanced Docker topics, and basics of the Rkt Container
    runtime and how all these topics integrate with CoreOS. As Docker is pretty mature,
    we have covered only advanced Docker topics in this chapter. As the Rkt container
    runtime is still evolving, we have covered the basics of Rkt in this chapter.
    Even though Docker started as a Container runtime, Docker has evolved into a Container
    platform providing orchestration, networking, storage, and security solutions
    around containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Container standards—App Container (appc) specification , Open Container Initiative
    (OCI), Libnetwork, Container Network Interface (CNI), and Cloud Native Computing
    Foundation (CNCF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker daemon configuration, Docker registry, Docker image signing, and
    basic Docker debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rkt basics and how to use Rkt with image signing, systemd, and Flannel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container standards
  prefs: []
  type: TYPE_NORMAL
- en: 'Standards are an important part of any technology. Standards and specifications
    allow products and technologies from different vendors to interoperate with each
    other. As developments in the Container space happened very fast in the last 1-2
    years, there was limited attention paid to standards and specifications. In the
    recent past, the industry has been working toward standards for Container runtime,
    Container networking, and Container orchestration. In majority of these cases,
    there are runtime implementations that get released along with the specification
    and this encourages faster adoption. The following are the standards'' categories
    covered in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Container image and runtime: APPC and OCI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Container Networking: Libnetwork and CNI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Container orchestration: CNCF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App container specification
  prefs: []
  type: TYPE_NORMAL
- en: The APPC specification provides you with a standard to describe the container
    image format, Container image discovery, Container grouping or Pods, and Container
    execution environment. Different Container runtimes implementing the APPC specification
    will be interoperable with each other. The APPC specification is primarily driven
    by CoreOS along with a few other community members. Rkt, Kurma, and Jetpack are
    examples of Container runtime implementing APPC. The following are some important
    components of APPC.
  prefs: []
  type: TYPE_NORMAL
- en: The Container image format
  prefs: []
  type: TYPE_NORMAL
- en: This describes the container image layout, manifest file with image details,
    and image signing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application Container Image (ACI) is a Container image created according to
    the APPC specification. For example, the `nginx.aci` image is an ACI for the nginx
    Container. To understand Container image format, let''s look at what is contained
    within nginx.aci APPC image. The following command extracts the contents of the
    `nginx.aci` image to the `nginx` directory: (We got the `nginx.aci` image from
    the `docker2aci` tool that will be covered later in the chapter.)'
  prefs: []
  type: TYPE_NORMAL
- en: '`tar -xvf nginx.aci -C nginx`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following set of screenshots shows you the base layout and rootfs layout
    for the `nginx.aci` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/00121.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are some important sections in the `nginx.aci` manifest. The
    first screenshot shows the container name and version. The second screenshot describes
    the exposed ports, mountpoints, environment variables, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that nginx ACI image is exposing ports
    `80` and `443` and it has mount `point /var/cache/nginx`. Container image signing
    is done using GPG ([https://www.gnupg.org/](https://www.gnupg.org/)). GPG is a
    public key cryptography implementation that can be used for the encryption of
    messages as well as image signing using a public and private key pair.
  prefs: []
  type: TYPE_NORMAL
- en: Container image discovery
  prefs: []
  type: TYPE_NORMAL
- en: 'Container image discovery describes ways to find the location of Container
    images from image name. Container images use the URL format. Container image discovery
    describes ways to find the location of Container images from image name. The following
    is the image format used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://{name}-{version}-{os}-{arch}.{ext}`'
  prefs: []
  type: TYPE_NORMAL
- en: Simple discovery
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the complete URL is mentioned to retrieve the ACI image. An example is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/coreos/etcd/releases/download/v2.0.0/etcd-v2.0.0-linux-amd64.aci](https://github.com/coreos/etcd/releases/download/v2.0.0/etcd-v2.0.0-linux-amd64.aci)'
  prefs: []
  type: TYPE_NORMAL
- en: Meta discovery
  prefs: []
  type: TYPE_NORMAL
- en: Here, the image URL and public key is discovered automatically by using the
    meta tag embedded in the HTTP location. The following example shows you how to
    retrieve the meta tag and the ACI image from meta tags for the CoreOS etcd container
    image.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to retrieve the meta tags. The `https://coreos.com/etcd` location
    contains the `ac-discovery` meta tag that contains the image location and the
    `ac-discovery-pubkeys` meta tag that contains the public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The link, [https://coreos.com/etcd/](https://coreos.com/etcd/), contains the
    following meta tags that can be retrieved as an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<meta name="ac-discovery" content="coreos.com/etcd https://github.com/coreos/etcd/releases/download/{version}/etcd-{version}-{os}-{arch}.{ext}">
    <meta name="ac-discovery-pubkeys" content="coreos.com/etcd https://coreos.com/dist/pubkeys/aci-pubkeys.gpg">`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding meta tag content, the Container image can be retrieved
    from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://github.com/coreos/etcd/releases/download/{version}/etcd-{version}-{os}-{arch}.{ext}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The public key can be retrieved from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://coreos.com/dist/pubkeys/aci-pubkeys.gpg`'
  prefs: []
  type: TYPE_NORMAL
- en: The app container executor
  prefs: []
  type: TYPE_NORMAL
- en: 'The app container executor takes care of the following to set up runtime for
    the Container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'UUID setup: This is a Unique ID for the Pod that contains multiple containers.
    UUID is registered with the metadata service that allows other containers to find
    each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filesystem setup: A filesystem is created in its own namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Volume setup: These are files to be mounted to the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Networking: This specifies Container networking to the host and other Containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Isolators: This controls the CPU and memory limit for the Container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App container pods
  prefs: []
  type: TYPE_NORMAL
- en: The concept of pods comes from Kubernetes where related containers are packed
    together in a Pod. Containers within a pod share the process PID, network, and
    IPC namespace. A manifest can be created for the Pod in addition to individual
    containers in order to describe properties for the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: The app container metadata service
  prefs: []
  type: TYPE_NORMAL
- en: The app container metadata service is a service that runs externally, and container
    pods can register information about pods and applications. This metadata service
    can be used by pods to find information about other pods as well as by containers
    within a pod to find information about other containers.
  prefs: []
  type: TYPE_NORMAL
- en: APPC tools
  prefs: []
  type: TYPE_NORMAL
- en: APPC provides you with tools to create, validate, and convert ACI images.
  prefs: []
  type: TYPE_NORMAL
- en: Actool
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Actool for ACI validation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows you that the generated ACI image, `busybox-latest.aci`,
    is a valid APPC image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using Actool for ACI discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows you the discovery URL and public key from the ACI
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using Actool for checking manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows you how to see the manifest from the ACI image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Acbuild
  prefs: []
  type: TYPE_NORMAL
- en: The Acbuild tool is used to build ACI images. The concept is similar to the
    Dockerfile approach to build Docker Container images, but Acbuild provides more
    flexibility to build Container images by having better integration with Linux
    tools such as makefile, environment variables, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of building a container image from a GO executable
    `hello`. Before running the following commands, we need to link the `hello` executable
    in the current directory statically:'
  prefs: []
  type: TYPE_NORMAL
- en: '`acbuild begin``acbuild set-name example.com/hello``acbuild copy hello /bin/hello``acbuild set-exec /bin/hello``acbuild port add www tcp 5000``acbuild label add version 0.0.1``acbuild annotation add authors "Sreenivas Makam<sxxxm@yahoo.com>"``acbuild write hello-0.0.1-linux-amd64.aci``acbuild end`'
  prefs: []
  type: TYPE_NORMAL
- en: If we run the preceding commands, it will create an APPC image, `hello-0.0.1-linux-amd64.aci`,
    which we can run with the Rkt Container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is another example that is similar to the Dockerfile approach
    to build an ACI image. In this example, we take a base Ubuntu image, install Apache,
    and start Apache in a container to create the `ubuntu-nginx.aci` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`acbuild begin``acbuild dependency add quay.io/fermayo/ubuntu``acbuild run -- apt-get update``acbuild run -- apt-get -y install nginx``acbuild set-exec -- /usr/sbin/nginx –g "daemon=off;"``acbuild set-name example.com/ubuntu-nginx``acbuild write ubuntu-nginx.aci``acbuild end`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run acbuild, it''s necessary to have systemd-nspawn in the system. This
    is present by default in CoreOS nodes. The following is the APPC image that was
    created from the preceding script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start the Container using Rkt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the running Container''s status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Docker2aci
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker2aci utility is used to convert Docker Containers to the ACI format.
    The following is an example that takes a docker `busybox` container and converts
    it to a `busybox.aci` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Open Container Initiative
  prefs: []
  type: TYPE_NORMAL
- en: 'OCI is the Open Container Initiative open source project started in April 2015
    by Docker and has members from all major companies including Docker and CoreOS.
    OCI defines the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Container image format: This describes the filesystem bundle along with
    `config.json` that describes the host-independent property of a container and
    `runtime.json` that describes the host-dependent property of a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Runtime: This describes how a container can be started and stopped using namespaces
    and cgroups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker's goal is to follow the OCI specification for its Container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Runc
  prefs: []
  type: TYPE_NORMAL
- en: Runc is an implementation of the OCI specification. Docker engine uses runc
    to implement Container runtime in Docker. Runc can be installed using the procedure
    described at [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following procedure can be used to start a Ubuntu container using `runc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Docker pull Ubuntu``docker export $(docker create ubuntu) > ubuntu.tar``mkdir rootfs``tar -C rootfs -xf ubuntu.tar``runc spec`'
  prefs: []
  type: TYPE_NORMAL
- en: The first step pulls the Ubuntu Docker Container. The second step exports the
    Ubuntu Container to a filesystem. The third and fourth steps put the Ubuntu filesystem
    content in the `rootfs` directory. The last step generates `config.json` and `runtime.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows you the Ubuntu container started using `runc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The relationship of OCI with APPC
  prefs: []
  type: TYPE_NORMAL
- en: CoreOS, along with a few other community members, created the APPC specification
    to standardize the Container image format that makes Containers interoperable
    between different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original APPC container specification proposed by CoreOS covers four different
    elements of container management: packaging, signing, naming (sharing the container
    with others), and runtime. Docker felt the same need for interoperability and
    created OCI along with other community members including CoreOS. OCI focuses only
    on packaging and runtime currently, though this might change in the future. The
    goals of APPC and OCI are common even though specifics slightly differ. It is
    possible that these two standards will converge into one standard at some later
    point.'
  prefs: []
  type: TYPE_NORMAL
- en: OCI and APPC latest updates
  prefs: []
  type: TYPE_NORMAL
- en: As per the latest CoreOS blog update ([https://coreos.com/blog/making-sense-of-standards.html](https://coreos.com/blog/making-sense-of-standards.html)),
    APPC and OCI will intersect only in runtime and APPC will continue to focus on
    image format, signing, and distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Libnetwork
  prefs: []
  type: TYPE_NORMAL
- en: 'Libnetwork was covered briefly in [Chapter 5](index_split_122.html#filepos342077),
    CoreOS Networking and Flannel Internals. Libnetwork is an open source project
    started by Docker and a few other community members with the following objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep networking as a library separate from the Container runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide Container connectivity in the same host as well as across hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking implementation will be done as a plugin implemented by drivers. The
    plugin mechanism is provided to add new third-party drivers easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control IP address assignment for the Containers using local IPAM drivers and
    plugins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker uses Libnetwork to provide Container networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three primary components in Libnetwork:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sandbox: All networking functionality is encapsulated in a sandbox. This can
    be implemented using networking namespace or a similar function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Endpoint: This attaches sandbox to the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network: Multiple endpoints in the same network can talk to each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows Sandbox, Endpoint, and Network and how two containers
    can talk to each other using these constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Libnetwork supports local drivers such as null, bridge, and overlay. The bridge
    driver can be used for Container connectivity in a single host, and the overlay
    driver can be used for Container connectivity across hosts. Remote drivers such
    as Weave and Calico are also supported.
  prefs: []
  type: TYPE_NORMAL
- en: CNI
  prefs: []
  type: TYPE_NORMAL
- en: CNI was covered briefly in [Chapter 5](index_split_122.html#filepos342077),
    CoreOS Networking and Flannel Internals.
  prefs: []
  type: TYPE_NORMAL
- en: CNI is the Container networking interface open source project developed by CoreOS
    along with a few other community members to provide networking facility for Containers
    as a pluggable and extensible mechanism. CoreOS's Container runtime, Rkt, uses
    CNI to establish Container networking. The objectives of Libnetwork and CNI are
    pretty much the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some notes on CNI:'
  prefs: []
  type: TYPE_NORMAL
- en: The CNI interface calls the API of the CNI plugin to set up Container networking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CNI plugin is responsible for creating the network interface to the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CNI plugin calls the IPAM plugin to set up the IP address for the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CNI plugin needs to implement an API for container network creation and
    deletion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plugin type and parameters are specified as a JSON file that the Container
    runtime reads and sets up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available CNI plugins are Bridge, macvlan, ipvlan, and ptp. Available IPAM plugins
    are host-local and DHCP. CNI plugins and the IPAM plugin can be used in any combination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External CNI plugins such as Flannel and Weave are also supported. External
    plugins reuse the bridge plugin to set up the final networking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a sample JSON configuration with the bridge CNI plugin and
    host-local IPAM plugin along with the IP allocation range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{     "name": "mynet",     "type": "bridge",     "bridge": "mynet0",     "isGateway": true,
        "ipMasq": true,     "ipam": {         "type": "host-local",         "subnet": "10.10.0.0/16"
        } }`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is a sample JSON configuration that uses the Flannel CNI type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{         "name": "containernet",         "type": "flannel" }`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following figure shows you the relationship between Rkt, CNI, the CNI plugin,
    and IPAM plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The relationship between Libnetwork and CNI
  prefs: []
  type: TYPE_NORMAL
- en: Libnetwork and CNI have similar objectives. Docker uses Libnetwork and CoreOS,
    with Rkt, uses CNI. Libnetwork's overlay driver does something that is similar
    to CNI's flannel driver. The goal of external plugins such as Weave and Calico
    is to work with both Libnetwork and CNI.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Native Computing Foundation
  prefs: []
  type: TYPE_NORMAL
- en: The goal of CNCF is to make it easier to build Cloud native applications using
    Containers. CNCF will create reference architectures using best open source technologies
    around Containers for microservice based distributed application. The initial
    goal of CNCF is Container orchestration and the integration work is focused on
    Kubernetes with Mesos. CNCF will create the reference architecture for microservice
    development that can help enterprises to build on the reference architecture rather
    than integrating components by themselves. As per the latest CoreOS blog ([https://coreos.com/blog/making-sense-of-standards.html](https://coreos.com/blog/making-sense-of-standards.html)),
    CoreOS will be donating etcd, flannel, and appc to CNCF.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs: []
  type: TYPE_NORMAL
- en: Even though Container technology has been available for a long time, Docker
    has revolutionized the Container technology by making the creation and transportation
    of Containers very user-friendly. Other than providing Container runtime, Docker
    provides you with networking, storage, and orchestration solutions for containers.
    For the majority of these solutions, Docker provides a pluggable model where the
    Docker native solution is provided, which can be swapped with any other third-party
    solution. This gives flexibility to the customer to use technologies that they
    are already comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](index_split_023.html#filepos77735), CoreOS Overview, we covered
    the Docker architecture. As Docker technology is pretty mature, we will cover
    only the advanced Docker concepts in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker daemon and an external connection
  prefs: []
  type: TYPE_NORMAL
- en: Docker runs as a daemon and by default listens on the Unix socket, `unix:///var/run/docker.sock`.
    Docker start options are specified in `/etc/default/docker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow external Docker clients to talk to the Docker daemon, the following
    procedure is to be performed in the Ubuntu node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the TCP server with the local address and port number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DOCKER_OPTS="-D -H unix:///var/run/docker.sock -H tcp://192.168.56.101:2376"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Restart the docker daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Sudo service docker restart`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can see that the Docker daemon is exposing external connectivity on
    the IP address `192.168.56.101` and TCP port number `2376`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00026.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We can connect from external Docker clients as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker –H tcp://192.168.56.101:2376 ps`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows that apache container is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile is used to create Docker Container images using specified instructions
    in Dockerfile. Typically, Dockerfile starts with a base container image, installs
    the necessary applications, and starts the process associated with the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Dockerfile best practices, you can refer to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/engine/articles/dockerfile_best-practices/](https://docs.docker.com/engine/articles/dockerfile_best-practices/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example Dockerfile for creating an Apache container from
    the Ubuntu base image. This Dockerfile installs the Apache package and exposes
    port `80` to the outside world from the Container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM ubuntu:14.04 MAINTAINER Sreenivas Makam <sxxxm@yahoo.com> # Update RUN apt-get update
    # Install apache2 RUN apt-get install -y apache2 # Expose necessary ports EXPOSE 80
    # Start application ENTRYPOINT ["/usr/sbin/apache2ctl"] CMD ["-D", "FOREGROUND"]`'
  prefs: []
  type: TYPE_NORMAL
- en: To create a Docker image, execute the following command in the directory where
    the preceding Dockerfile is present. In the example below, `smakam/apache1` is
    the name of the Container image. The default convention for Container image name
    is `username/imagename:tag`.
  prefs: []
  type: TYPE_NORMAL
- en: '`docker build -t smakam/apache1 .`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows you the created Apache container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Docker Image repository
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker image repository is used to save and restore Docker Container images
    from a common server location. There are three possible solutions that Docker
    provides for storing Container images:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker hub: This is the Docker image repository service that''s hosted by Docker
    itself at [https://hub.docker.com/](https://hub.docker.com/). This is a free service
    provided by Docker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker registry: This is an open source project ([https://github.com/docker/distribution](https://github.com/docker/distribution))
    that allows customers to host the Docker registry in their own premises. The latest
    Docker registry is version 2.0\. Docker registry 2.0 overcomes some of the shortcomings
    of Docker registry 1.x for better security and performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Trusted registry: This is Docker''s commercial implementation ([https://www.docker.com/docker-trusted-registry](https://www.docker.com/docker-trusted-registry))
    of the Docker registry and adds features such as role-based user authentication,
    integration with an external directory service such as LDAP, GUI-based administrative
    management, support, and so on. Both the Docker registry and Docker Trusted registry
    support integration with external storage drivers such as AWS, Azure, and Swift
    to store Docker images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram captures the three Docker image repository types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Docker images have this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[REGISTRYHOST/][USERNAME/]NAME[:TAG]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`REGISTRYHOST`: The registry server address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USERNAME`: The username that created the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NAME`: The Container image name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TAG`: The version of the Container image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except `NAME`, the other arguments are optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following command will pull a standard Ubuntu container image
    from the Docker hub; `registry-1.docker.io/library` is the registry host, the
    name is `Ubuntu`, and the tag is `latest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker pull registry-1.docker.io/library/Ubuntu:latest`'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the Docker registry, CoreOS has the Quay registry ([https://quay.io/](https://quay.io/))
    to store Docker and Rkt images, and they have a public and enterprise version
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own Docker registry
  prefs: []
  type: TYPE_NORMAL
- en: It is useful to create a local registry to share images in a particular company
    or group. This is important from a security perspective since there is no need
    to access Internet to access registry. The Docker registry provides you with options
    for authentication, backend storage drivers (for example, S3, Azure, and Swift),
    logging, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a local registry, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker run -d -p 5000:5000 --restart=always --name registry registry:2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows you the registry running as container. The registry
    service is exposed on port `5000` in the localhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The registry configuration is specified either as an environment variable as
    part of starting the registry container or using a YAML file with the configuration
    and mounting this YAML file to `/etc/config/registry/config.yaml` in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following set of commands pulls a busybox container from the Docker hub,
    pushes the busybox container in the local registry, and then pulls it out from
    the local registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker pull busybox``docker tag busybox localhost:5000/mybusybox``docker push localhost:5000/mybusybox``docker pull localhost:5000/mybusybox`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows you the `mybusybox` container that has been
    pulled from the local registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows you the instantiation of the `mybusybox` container
    from the local registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Continuous integration
  prefs: []
  type: TYPE_NORMAL
- en: 'When we push Docker images to the Docker Hub, Dockerfile does not get pushed.
    To push the Dockerfile and use it for automated Container builds, we need to link
    it with a repository management tool such as GitHub or Bitbucket. The steps are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get an account in GitHub or Bitbucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From Docker Hub, we can link either to GitHub or Bitbucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the Dockerfile to GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From DockerHub, when we create a repository, select automated build, and select
    the location from GitHub where Dockerfile is present. This will build the image
    automatically. Additionally, when there are changes to Dockerfile committed to
    GitHub, automatic builds are triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows you the CI sequence using Dockerfile, from staging
    to production:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the automated build creation in Docker Hub after
    creating Dockerfile in GitHub. In the following example, Dockerfile is present
    in [https://github.com/smakam/docker.git](https://github.com/smakam/docker.git)
    under the Apache directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When any changes are made, an automatic container image is built. The following
    screenshot shows the successful container image build log for `smakam/apacheauto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows a successful pull of the `smakam/apacheauto`
    container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Docker content trust
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker content trust provides you with a mechanism to sign and publish
    Docker images so that the client who pulls the image can be guaranteed that the
    image is from a trusted source and has not been modified by any man-in-the-middle
    attack. The following are some features of the Docker content trust:'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker content trust is an implementation of the Notary open source project
    ([https://github.com/docker/notary](https://github.com/docker/notary)). The Notary
    open source project is based on The Update Framework (TUF) project ([https://theupdateframework.github.io/](https://theupdateframework.github.io/)).
    TUF provides a mechanism to secure software updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compared to the GPG approach of signing keys, TUF has some unique differentiators.
    TUF takes care of the freshness of keys so that the client always knows that they
    are getting the latest content. Key compromise can be handled better with TUF
    using the key rotation scheme, which clients need not be aware of. TUF also provides
    you with the capability of signing collections rather than individual software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are four keys with Notary—the Timestamp key to maintain the freshness
    of the image, the Snapshot key to sign image collections, the Target key for the
    regular signing of images, and the Offline key for key rotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker content trust has been released with Docker version 1.8\. The default
    option is trust-disabled and can be enabled using the `DOCKER_CONTENT_TRUST` environment
    variable. At some later point, the default option would be to keep the trust enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows you the relationship between TUF, Notary, and the
    Docker content trust:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the workflow with the Docker content trust:'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker registry needs to support the Docker content trust. The Docker Hub
    supports the content trust. The Docker trusted registry and private registry do
    not yet support the content trust; this will be added soon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The usual Docker commands can be used for push and pull, and care has been taken
    not to change Docker commands. For advanced key management, the Notary CLI can
    be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the publisher pushes the image for the first time using `docker push`,
    there is a need to enter a passphrase for the root key and tagging key. All other
    keys are generated automatically. These keys need to be stored safely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any further image publishing, only the tagging key is necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client has the option to pull signed or unsigned images. With the Docker
    trust enabled, the client will get an error if they try to pull unsigned images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing secure image
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we enable the Docker content trust using the `DOCKER_CONTENT_TRUST`
    environment variable. The following is the output when the Docker content trust
    is enabled and we are publishing the image for the first time. Here, we are pushing
    the signed `smakam/mybusybox:v1` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pulling secure image
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output when we are pulling the same secure image, `smakam/mybusybox:v1`,
    from the Docker hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pulling same image with no security
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output when we try to pull the same image, `smakam/mybusybox:v1`,
    with no Docker content trust. In this case, image verification is not done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the error message that we will get if we enable the trust
    and try to pull Docker images that are not signed. As `smakam/hellocounter` is
    not signed and we have `DOCKER_CONTENT_TRUST` enabled, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Recently, Docker has enabled the content trust using hardware keys ([https://blog.docker.com/2015/11/docker-content-trust-yubikey/](https://blog.docker.com/2015/11/docker-content-trust-yubikey/)).
    This is currently in the experimental mode.
  prefs: []
  type: TYPE_NORMAL
- en: Container debugging
  prefs: []
  type: TYPE_NORMAL
- en: The following are some basic Container debugging approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs: []
  type: TYPE_NORMAL
- en: The following command will show container logs. This can be a useful debugging
    tool. In [Chapter 10](index_split_219.html#filepos708963), CoreOS and Containers
    - Troubleshooting and Debugging, you will learn how to aggregate and analyze Container
    logs from a central location.
  prefs: []
  type: TYPE_NORMAL
- en: '`docker logs <containername or id>`'
  prefs: []
  type: TYPE_NORMAL
- en: Login inside Container
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker exec` command can be used to log in to the container. The following
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Common Linux commands can be executed from the Container shell.
  prefs: []
  type: TYPE_NORMAL
- en: Container properties
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will show container properties such as mount points,
    resource limits, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker inspect <containername or id>`'
  prefs: []
  type: TYPE_NORMAL
- en: Container processes
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will show processes running in the container sorted by
    the process CPU usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker top <containername or id>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample output for a `redis` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Container's CPU and memory usage
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will show the resource usage of a Container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker stats <containername or id>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample output for the Apache container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rkt
  prefs: []
  type: TYPE_NORMAL
- en: 'Rkt is the Container runtime from CoreOS based on the APPC specification. The
    following are some differences in Rkt compared to Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: Rkt is daemonless. The problem of Containers going away if the Docker daemon
    restarts does not exist with Rkt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rkt integrates well with systemd so that container resource limits can be set
    easily for the Containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three stages in the Rkt execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stage0`: This does the image discovery and retrieval and sets up a filesystem
    for stages 1 and 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stage1`: This sets up the execution environment for the container execution
    using the filesystem set up by `stage0`. Rkt uses systemd-nspawn to set up cgroups,
    networking, and so on in this stage. The goal here is to keep `stage1` swappable
    by other implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stage2`: This is the actual execution of the Container pod and application
    itself using the execution environment set up by `stage1` and filesystem set up
    by `stage0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example illustrates the stages. Let''s start the `hello` ACI
    image using Rkt:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt --insecure-skip-verify run hello-0.0.1-linux-amd64.aci`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following shows the `stage1` filesystem setup by `stage0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The manifest here shows the Rkt `stage1` ACI that sets up the container environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following shows the `stage2` filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The manifest here shows the hello Rkt container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following shows the filesystem for the hello application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rkt application is available in the CoreOS base image. Rkt can also be installed
    in any Linux system using the procedure described at [https://github.com/coreos/rkt](https://github.com/coreos/rkt).
    The following is the Rkt version running in the Ubuntu 14.04 system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the Rkt and APPC version used in the CoreOS alpha image 815.0.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Basic commands
  prefs: []
  type: TYPE_NORMAL
- en: The following are some basic commands to manipulate Rkt Containers.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch image
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command fetches a Container image from the repository in the
    ACI format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt --insecure-skip-verify fetch docker://busybox`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: List images
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command lists Rkt Container images:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt image list`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Run image
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command runs the Rkt Container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt run --insecure-skip-verify --interactive docker://busybox`'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, signature verification is turned on; we disable signature verification
    using the `skip-verify` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: List pods
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command lists the running pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt list pods`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00422.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Garbage collection
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows two pods that have exited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00423.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The exited Containers will be garbage collected periodically. To force garbage
    collection, we can perform the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rkt gc --grace-period=0`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can see that there are no active pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00427.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delete image
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command deletes the local Container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt image rm sha512-cf74c26d8d35555066dce70bd94f513b90cbef6e7e9c01ea0c971f4f6d689848`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the deletion of the busybox image using UUID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00429.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Export image
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command converts a Docker image to the ACI format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt image export nginx nginx.aci`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00431.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The nginx container with volume mounting and port forwarding
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command starts the nginx container forwarding the container port
    `80` to the host port `8080` and setting up the host volume. The volume directory
    and port name are as specified in the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt run --insecure-skip-verify --private-net --port=80-tcp:8080 --volume volume-var-cache-nginx,kind=host,source=/home/core docker://nginx`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00433.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows successful web page access using the nginx container
    and host port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00434.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pod status
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command lists the status of a particular Pod using UUID:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt status 2b165196`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rkt image signing
  prefs: []
  type: TYPE_NORMAL
- en: Container image signing allows us to verify that the image is coming from a
    trusted location and has not been tampered with. I used the procedure at [https://github.com/coreos/rkt/blob/master/Documentation/signing-and-verification-guide.md](https://github.com/coreos/rkt/blob/master/Documentation/signing-and-verification-guide.md)
    to sign the ACI image and use Rkt to run the signed image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample `nginx.service` systemd unit file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpg --batch --gen-key gpg-batch`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In case you get this error message, `Not enough random bytes available. Please
    do some other work to give the OS a chance to collect more entropy!`, it can be
    solved by the following rngd tool that can be run in parallel:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`apt-get install rng-tools``sudo rngd -r /dev/urandom`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Trust the keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpg --no-default-keyring --secret-keyring ./rkt.sec --keyring ./rkt.pub --edit-key 1FEEF0ED trust`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Export the public key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpg --no-default-keyring --armor \``--secret-keyring ./rkt.sec --keyring ./rkt.pub \``--export <email> > pubkeys.gpg`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Sign the image using the public key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpg --no-default-keyring --armor \``--secret-keyring ./rkt.sec --keyring ./rkt.pub \``--output hello-0.0.1-linux-amd64.aci.asc \``--detach-sig hello-0.0.1-linux-amd64.aci`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Host the web server with the ACI image, public key, and signature. The following
    are the contents in my web server location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00437.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The following is the `index.html` content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<head> <meta name="ac-discovery" content="example.com/hello http://example.com/hello-0.0.1-linux-amd64.aci">
    <meta name="ac-discovery-pubkeys" content="example.com/hello http://example.com/pubkeys.gpg">
    </head>`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Trust the web server location and key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo rkt trust --prefix=example.com/hello http://example.com/pubkeys.gpg --insecure-allow-http`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modify `/etc/hosts` to point `example.com` to localhost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a simple web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo python -m SimpleHTTPServer 80`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can run the Rkt image with signature verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo rkt run --debug http://example.com/hello-0.0.1-linux-amd64.aci`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the signature being verified. The signature
    location and public key are provided by the hosted web server at `example.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00439.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rkt with systemd
  prefs: []
  type: TYPE_NORMAL
- en: Systemd provides you with a lot of control over how processes are managed. Rkt
    pods can be managed by systemd. With systemd, we can control the process execution
    order, restartability, resource limit, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample `nginx.service` systemd unit file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[Unit] Description=nginx  [Service] # Resource limits CPUShares=512 MemoryLimit=1G
    # Prefetch the image ExecStartPre=/usr/bin/rkt fetch --insecure-skip-verify docker://nginx
    ExecStart=/usr/bin/rkt run --insecure-skip-verify --private-net --port=80-tcp:8080 --volume volume-var-cache-nginx,kind=host,source=/home/co
    re docker://nginx KillMode=mixed Restart=always`'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding service file, we started the nginx container and also limited
    the CPU and memory usage for this `nginx.service` using the systemd construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the service, it''s necessary to place `nginx.service` in `/etc/systemd/system`.
    The service can be started as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sudo systemctl start nginx.service`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows you the status of `nginx.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00442.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To show the power of integration with systemd, let''s kill the Rkt nginx process
    and demonstrate restartability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00444.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Systemd will restart the nginx container because `restart` is turned on in `nginx.service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the following `journalctl` logs on `nginx.service`, we can see that the
    service has been restarted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00445.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following screenshot, we can see that the Rkt nginx process is running
    with a different PID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00448.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rkt with Flannel
  prefs: []
  type: TYPE_NORMAL
- en: Rkt uses the CNI interface to talk to the Flannel plugin to establish container
    networking across hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example sets up a three-node CoreOS cluster using Rkt and Flannel
    for Container networking. The following is the necessary `cloud-config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#cloud-config  coreos:   etcd2:     #generate a new token for each unique cluster from https://discovery.etcd.io/new
        discovery: <your token>     # multi-region and multi-cloud deployments need to use $public_ipv4
        advertise-client-urls: http://$public_ipv4:2379     initial-advertise-peer-urls: http://$private_ipv4:2380
        # listen on both the official ports and the legacy ports     # legacy ports can be omitted if your application doesn''t depend on them
        listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001     listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001
      fleet:     public-ip: $public_ipv4   flannel:     interface: $public_ipv4   units:
        - name: etcd2.service       command: start     - name: fleet.service       command: start
        - name: flanneld.service       drop-ins:         - name: 50-network-config.conf
              content: |             [Service]             ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config ''{ "network": "10.1.0.0/16" }''
          command: start     - name: docker-tcp.socket       command: start       enable: true
          content: |         [Unit]         Description=Docker Socket for the API          [Socket]
            ListenStream=2375         Service=docker.service         BindIPv6Only=both          [Install]
            WantedBy=sockets.target write_files:   - path: "/etc/rkt/net.d/10-containernet.conf"
        permissions: "0644"     owner: "root"     content: |       {         "name": "containernet",
            "type": "flannel"       }`'
  prefs: []
  type: TYPE_NORMAL
- en: The `/etc/rkt/net.d/10-containernet.conf` file sets up the CNI plugin type as
    Flannel.
  prefs: []
  type: TYPE_NORMAL
- en: Flannel gets an individual subnet for each host using the IP range specified
    in the flannel configuration `10.1.0.0/16`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows you the subnet allocated in `node1` and `node2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00449.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/00451.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create Rkt containers in each node and check inter-container connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00452.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following output shows you that the busybox container in `core-01` got
    the IP, `10.1.74.4`, which is in the `10.1.74.1/24` range allocated for `core-01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00454.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following output shows you that the busybox container in `core-03` got
    the IP, `10.1.3.2`, which is in the `10.1.3.1/24` range allocated for `core-03`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00455.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following output shows you a successful ping from container 1 on `core-01`
    to container 2 on `core-03`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00457.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered different Container standards for Container runtime,
    networking, and orchestration. Having these standards is important from the industry
    perspective for interoperability reasons. Container runtime systems like Docker
    and Rkt were covered in detail. For Docker, the focus was on advanced concepts,
    and for Rkt, we covered the basics as Rkt is still in the early stages. Even though
    CoreOS is actively developing Rkt, CoreOS is committed to supporting Docker in
    its OS. It will be interesting to see how Docker and Rkt run together in CoreOS
    and how customers adopt the two Container runtime technologies. In the next chapter,
    we will cover Container orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: 'Notary GitHub: [https://github.com/docker/notary](https://github.com/docker/notary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker registry: [https://github.com/docker/distribution](https://github.com/docker/distribution)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker content trust documentation: [https://docs.docker.com/security/trust/content_trust/](https://docs.docker.com/security/trust/content_trust/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker content trust blog: [https://blog.docker.com/2015/08/content-trust-docker-1-8/](https://blog.docker.com/2015/08/content-trust-docker-1-8/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Update framework: [http://theupdateframework.com/](http://theupdateframework.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloud native compute foundation: [https://cncf.io](https://cncf.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open container initiative: [https://github.com/opencontainers](https://github.com/opencontainers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'APPC specification: [https://github.com/appc](https://github.com/appc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Libnetwork: [https://github.com/docker/libnetwork](https://github.com/docker/libnetwork)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker2aci: [https://github.com/appc/docker2aci](https://github.com/appc/docker2aci)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CoreOS Rkt documentation: [https://coreos.com/rkt/docs/latest/](https://coreos.com/rkt/docs/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acbuild: [https://github.com/appc/acbuild](https://github.com/appc/acbuild)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading and tutorials
  prefs: []
  type: TYPE_NORMAL
- en: 'The CNI presentation: [https://www.youtube.com/watch?v=_-9kItVUUCw](https://www.youtube.com/watch?v=_-9kItVUUCw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker registry presentations: [https://www.youtube.com/watch?v=RnO9JnEO8tY](https://www.youtube.com/watch?v=RnO9JnEO8tY)
    and [https://www.youtube.com/watch?v=cVsUhoJFPvQ](https://www.youtube.com/watch?v=cVsUhoJFPvQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Docker Notary presentation: [https://www.youtube.com/watch?v=JvjdfQC8jxM](https://www.youtube.com/watch?v=JvjdfQC8jxM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Container standards presentation: [http://containersummit.io/events/sf-2015/videos/container-ecosystem-standards-needs-and-progress](http://containersummit.io/events/sf-2015/videos/container-ecosystem-standards-needs-and-progress)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Rkt and APPC presentation: [https://www.youtube.com/watch?v=C8Qpdrpm16Y](https://www.youtube.com/watch?v=C8Qpdrpm16Y)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
