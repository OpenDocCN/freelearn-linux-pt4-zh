- en: Overview of Essential Advance Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn some advanced and essential concepts related
    to the system, such as logging, controlling system services, firewalls, and **Security
    Enhanced Linux** (**SELinux**). Logging plays a key role in debugging and troubleshooting
    system applications. A solid understanding of logging will make your daily operations
    easier to handle and will also give you a deep insight into the application's
    functioning.
  prefs: []
  type: TYPE_NORMAL
- en: In this final chapter, we will learn the different logging mechanisms available
    in CentOS 7, such as journald and rsyslog. By now, you have seen how to install,
    update, and remove applications. Now, we will see how to control these applications
    and system services using the systemd and systemctl utilities. Finally, we will
    understand the basic usage of firewalld and SELinux to secure running services
    and harden the security of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding system logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with rsyslogd and journald
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding control of systems and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with systemd and systemctl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding SELinux concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with SELinux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding firewall concepts in CentOS 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with firewalld
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding system logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most application programs and the kernel write their event information in log
    files maintained at different locations. It helps in keeping track of activities
    that are taking place on the system and also forms an essential part of system
    auditing. Monitoring of log files helps in spotting any unusual activity in the
    system. Logging also helps in troubleshooting any application problems. By convention,
    Linux uses the `/var/log/` directory for storing logs in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with CentOS 7, we have two logging services that exist in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: Rsyslog service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systemd-journald service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System time service should be properly configured before configuring log services,
    as time is an important component of log files.
  prefs: []
  type: TYPE_NORMAL
- en: Working with rsyslog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rsyslog service centrally collects the log messages from different applications
    running in the Linux system. It collects the logs based on their type and their
    priorities, and stores them persistently in the `/var/logfollows:/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists some important log files maintained by rsyslog, along
    with their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Log file path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/messages` | Most standard log messages are stored here, except
    authentication logs, email logs, and some application debugging logs. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/secure` | Authentication logs containing errors and other messages
    are stored here. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/maillog` | Mail server logs are stored here. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/boot.log` | Boot/system startup messages are logged here. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/cron` | It stores cron job (scheduler) logs. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/wtmp` | Login activity logs are kept here. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/dmesg` | Kernel messages are stored here. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/cups` | Printing service logs are stored here. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/samba` | Samba service logs are kept here, not managed by rsyslog.
    The Samba service directly writes logs here. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/httpd` | This directory contains Apache web server logs, not managed
    by rsyslog. Apache directly writes logs in these files. |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/audit/` | Contains the `auditd` service logs and SELinux log files.
    |'
  prefs: []
  type: TYPE_TB
- en: Rsyslogd is an application in Linux systems, based on the syslog project that started
    in 1980\. It uses syslog protocol to log events in the system with certain extended
    features, such as the RELP protocol and buffered operation support. Sometimes,
    syslog is also used in the context of rsyslog in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring rsyslogd sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rsyslogd service is used by most of the applications running in Linux for
    logging events. The rsyslogd service uses three main components for handling the
    log messages of various applications in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Facility**: It represents the type of process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority or severity**: It represents the severity of the message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination/location**: It describes the location where the log messages
    are sent to or logged'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration file for the rsyslogd service is stored in two locations:'
  prefs: []
  type: TYPE_NORMAL
- en: In the main configuration file, `/etc/rsyslog.conf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the files stored with `.conf` extensions inside the `/etc/rsyslog.d/` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main configuration file, `/etc/rsyslog.conf`, contains the information
    on what is to be logged and where it should be stored. It is divided into three
    different sections displayed in capital letters, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#### MODULES ####`:The modules section is used to configure advanced features
    of rsyslogd.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#### GLOBAL DIRECTIVES ####`: The global directives section is used to specify
    globally configurable parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#### RULES ####`:It is the most important section, and contains the rules
    to specify what is to be logged and where it is to be logged. We will discuss
    this more in the *Rsyslogd* *rules* section of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation for rsyslog can be accessed from the `man` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Rsyslogd facilities and priorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facilitiesrepresent the fixed list of internal system processes that produce
    the log messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the common facilities keywords that are available
    in CentOS 7 and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Facility** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `auth` or `authpriv` | It represents authentication-related subsystem messages
    such as login |'
  prefs: []
  type: TYPE_TB
- en: '| `cron` | It represents the crond service and any scheduled application messages
    |'
  prefs: []
  type: TYPE_TB
- en: '| `daemon` | Generic name used to represent the various daemon subsystem messages
    |'
  prefs: []
  type: TYPE_TB
- en: '| `kern` | It represents kernel messages |'
  prefs: []
  type: TYPE_TB
- en: '| `lpr` | It represents legacy print service messages |'
  prefs: []
  type: TYPE_TB
- en: '| `mail` | It represents all mail program messages |'
  prefs: []
  type: TYPE_TB
- en: '| `mark` | It is for internal use and not to be used with any application |'
  prefs: []
  type: TYPE_TB
- en: '| `news` | It represents the messages generated by NNTP |'
  prefs: []
  type: TYPE_TB
- en: '| `security` | Same as `authpriv` and not used anymore |'
  prefs: []
  type: TYPE_TB
- en: '| `syslog` | It represents the messages of the syslog daemon |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | It represents the messages generated by the user space |'
  prefs: []
  type: TYPE_TB
- en: '| `uucp` | It represents the messages generated by the UUCP subsystem |'
  prefs: []
  type: TYPE_TB
- en: '| `local0-local7` | It represents the custom unused facilities provided by
    the system to the user for sending messages generated by user defined services
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | It matches all the facilities |'
  prefs: []
  type: TYPE_TB
- en: Priorities represent the severity or priority of messages that are logged for
    any service. There are different priority levels that can be used to determine
    the type of event that can be logged, such as `debug`, `info`, `emerg`, `alert`, and
    so on, for the specified service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the severity/priority levels with their description
    and assigned number for priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Assigned number** | **Priority** | **Severity description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | `emerg` | Generates message when system is unusable |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `alert` | Action must be taken immediately, available service is about
    to be discontinued |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `crit` | Generates message when critical condition occurs |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `err` | Non-critical error condition |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `warning` | Warning condition |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `notice` | Informational message for event that needs attention to prevent
    future issues |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `info` | Generates informational messages for normal service operation
    |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `debug` | Debugging-level messages for service operation |'
  prefs: []
  type: TYPE_TB
- en: 'If the wild card `*`is specified in the priority field, then it represents
    all types of severity (messages). If `none` is written in the severity field,
    then it means none of the messages of the corresponding facility will be added
    in the specified log files. The `none` is used to prevent logging of same message
    in different log files, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07c7bee9-4bf6-4253-95cd-32eba971994c.png)'
  prefs: []
  type: TYPE_IMG
- en: Rsyslogd rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `####RULES####` section of `/etc/rsyslog.conf` contains directives to define
    the logging of messages. The syntax of the directive used in `/etc/rsyslog.conf`
    file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/02d03b21-ee66-46d8-a6cf-d307b5503013.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The following are examples that illustrate the usage of directives defined
    in the /etc/rsyslog.conf file for logging of messages:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To log all information messages of the kernel, we can specify a different log
    file as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `debug.log` file in the `/var/log/` directory to collect debugging
    priority messages from all services as shown in the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After making the required changes in the `/etc/rsyslog.conf` file, restart
    the rsyslog service to bring changes into effect as shown in the following command
    line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After making the preceding changes, the debugging messages will not appear in
    the `/var/log/messages` file.
  prefs: []
  type: TYPE_NORMAL
- en: Log file rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log rotation prevents the filling up of the `/var/log` directory. Old log files
    are renamed with `filename-datestamp` on rotation. The `datestamp` indicates the date
    on which it was rotated (archived) as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Existing log** | **Archived log** |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/messages` | `/var/log/messages-20180530` (rotated on May 30, 2018)
    |'
  prefs: []
  type: TYPE_TB
- en: '**Logrotate** is the utility that takes care of rotating the log files periodically.
    A cron job is run nightly with the script named `/etc/cron.daily/logrotate` for
    log rotation. The rotation of log files is carried out as per the configuration
    of log rotation program stored in the following two locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/logrotate.conf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/logrotate.d/*` (any file inside this directory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most log files are rotated weekly; however, the `logrotate` command rotates
    some logs faster or slower or on certain conditions, such as on reaching a certain
    size.
  prefs: []
  type: TYPE_NORMAL
- en: After rotation of logs, the log watch program discards the old archive of log
    files to conserve disk space (typically 4 weeks or after a certain number of rotations).
    A new log file is created during rotation and the service is notified. On installation
    of a new application, the application adds its log file to `logrotate` management
    by dropping its logging configuration file inside the `/etc/logrotate.d/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of creating a custom log file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the important commands used in the `log rotation` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rotate 3`: Keeps the last three versions of the file and deletes the oldest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size 2M`: Rotates the log file on reaching 2 MB in size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monthly`: It is another alternative to size; if size has not reached 2 MB,
    then rotate the file on a monthly basis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing syslog entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The system logs generated by the rsyslogd service are stored in the `/var/log/`
    directory in various files. The oldest message is kept at the top of the log and
    new log entries are appended at the bottom of the log file in a standard format,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0fa6d55-8257-44dd-9566-63759a253adc.png)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring live log file traffic using the tail command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While performing troubleshooting, it is required to view the logs being generated
    by an application when it is being run. Using the `tail` command with the `-f`
    option does this. In one Terminal, we will execute the application we want to
    troubleshoot, and in another Terminal, we will execute the `tail` command as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It displays the 10 lines from the bottom of the filename specified, and keeps
    the file open to view the new lines that are being written to it. Once we are
    done viewing logs, we can close the log file by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to monitor the failed login attempts on the system, on one Terminal,
    open `/var/log/secure`, and in another Terminal, execute the `ssh` command on
    the same system as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d054892-adfc-4444-b4a0-f1d7a6968767.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the logger command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although most applications are configured to write logs in the log file automatically,
    we can use the `logger` command to write messages to rsyslogd also. The `logger`
    command writes the log messages in the log file as per the facility and priority
    specified with the `logger` command. By default, it sends the logs to the facility
    named as user with priority named as notice (`user.notice`). The `logger` command
    can be used inside a shell script to create logs, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we send a log message of information priority to the `rsyslog` program,
    then it will get stored in the `/var/log/boot.log` file as shown in the following
    command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can send any log message to the default log file, `/var/log/messages`, by
    using `logger` command as shown in the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For more information on logging, refer to the man pages of the `logger`, `tail`,
    `rsyslog.conf`, and `logrotate` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Working with systemd-journald
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This daemon provides a non-persistent method of advanced log management for
    collecting and displaying messages from the kernel, boot programs, and other services
    running in CentOS 7\. The journald stores these messages in a journal maintained
    in binary format, which can be accessed using the `journalctl` command. The default
    behavior of the journal is non-persistent across reboot. It forwards the messages
    to rsyslogd for permanent central storage and processing.
  prefs: []
  type: TYPE_NORMAL
- en: Finding events with the journalctl command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In CentOS 7, the `systemd-journal` is stored in the `/run/log/journal/` directory,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e065ee12-3fc6-45ff-b866-bcf33f8b9070.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we execute the `journalctl` command as root without any options, then
    it shows the full system journal, from the oldest log entry to the latest as shown
    in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `journalctl` command uses color coding to highlight the severity of messages,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Priority** | **Description of text highlighting used in logs** |'
  prefs: []
  type: TYPE_TB
- en: '| `Error`, `crit`, `alert` or `emerg` | Text is red |'
  prefs: []
  type: TYPE_TB
- en: '| `Notice` or `warning` | Text is bold |'
  prefs: []
  type: TYPE_TB
- en: '| `Info` or `debug` | Regular text |'
  prefs: []
  type: TYPE_TB
- en: 'Different options are used with the `journalctl` command to limit the searches
    of the journal to the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Journalctl -n`: By default, using the `-n` option with `journalctl` will display
    the last 10 log entries. We can also specify the number of log entries to be displayed
    in the output as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ca2fe7b1-1868-4897-97b8-4269d03a9c8e.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Journalctl -p`: We can filter the output of the journal by specifying the priority
    of the log entries using the `-p` option. We can specify either name or number
    of the priority level to display the log entries of the specified or higher-level
    priority, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8323e099-37cd-4c35-b200-9c97c029cb5e.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Journalctl -f`: The `-f` option is similar to the `-f` option used with the `tail`
    command; it displays the last 10 lines of the journal and keeps it open to display
    the new entries as they are written in the journal, until you press *Ctrl* + *C*
    as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e0e227c1-2d70-48b5-bea6-8a43ead2a391.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Limiting journalctl output to a specific time**: The `journalctl` command
    can be used to with two more options, `--since` and `--untill`, to specify a time
    range and display the log messages of that duration. The following `journalctl`
    query shows all logs recorded between `18:05:00` and `18:10:00`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `journalctl` command to display today''s journal entries only
    as shown in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `journalctl` command to display extra fields attached to
    the log entries by enabling the verbose output on the journal as shown in the
    following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table lists some of the important fields of the` journalctl`
    command that are used to filter the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `_COMM` | It filters the journal based on the name of the command |'
  prefs: []
  type: TYPE_TB
- en: '| `_EXE` | It is used to filter the query based on the path of the executable
    for the process |'
  prefs: []
  type: TYPE_TB
- en: '| `_PID` | It filters the journal based on the PID of the process |'
  prefs: []
  type: TYPE_TB
- en: '| `_UID` | It filters the journal based on the UID of the user running the
    process |'
  prefs: []
  type: TYPE_TB
- en: '| `_SYSTEMD_UNIT` | It filters the journal based on the systemd unit that started
    the process |'
  prefs: []
  type: TYPE_TB
- en: 'For example, for listing the journal messages that originated from a systemd
    process with PID 1 can be filtered using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `journalctl` command can also be used to list all the journal messages
    send by the `sshd` service, as shown in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `journalctl` command can also be used to view the journal log messages
    since last boot as shown in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Configuring systemd-journald to store logs persistently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`systemd-journal` is stored in the `/run/log/journal` directory, which is cleared
    on system reboot. Its configuration file is `/etc/systemd/journald.conf`, which
    can be used to fine-tune journal parameters such as the amount of filesystem to
    be used for storing the journal (default value is 10%).'
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd-journal` is configured in such a way that if the `/var/log/journal/` directory exists
    in the system, then it logs journal entries in that directory instead of `/run/log/journal/`.
    The same concept is used to made `systemd-journal` storage persistent across reboot.
    The following steps are to be taken to make `systemd-journal` persistent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `/var/log/journal/` directory as root user as shown in the following
    command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the owner of the directory created as root and group as `systemd-journal`
    with permissions `2755` as shown in the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Reboot your system or send the `USR1` signal to `systemd-journald` as shown
    in the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure `systemd-journal` is persistent after reboot by listing a new directory
    containing journal log files inside the `/var/log/journal` directory as shown
    in following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Understanding how to control the system and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a user or system administrator point of view, it is essential to understand
    how to manage various services installed on your system. A user should be able
    to enable a service at boot time and start or stop it when required.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, the Linux system and services were managed by SysV init or BSD init.
    Later on, their management was further improvised by adding utilities such as
    service and chkconfig, in addition to shell scripts. More recently, starting with
    CentOS 7, system and service management is now done with systemd. Systemd has
    replaced initd as the first process of CentOS 7.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to manage services running on your system.
    You will learn how to use systemd and its components, responsible for switching
    the system from the kernel space to the user space and managing system processes
    thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: Defining essential terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section we will define the essential terms related to system and services
    management.
  prefs: []
  type: TYPE_NORMAL
- en: What is a daemon?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A daemon is a process that waits or runs in the background, executing several
    tasks. It listens for connections using a network socket.
  prefs: []
  type: TYPE_NORMAL
- en: What is a socket?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a client connection is established, a socket is created and passed by systemd
    to a daemon or it creates a daemon for itself. In Linux, sockets are used mainly
    to establish client communication with the daemon.
  prefs: []
  type: TYPE_NORMAL
- en: What is systemd?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From CentOS 7 onward, systemd has replaced the init process as the first process
    (PID=1) that is started by the kernel when Linux boots up. It manages the system
    and services in the system for the Linux kernel by providing an interface between
    applications and the kernel. After starting systemd, it starts logging activities,
    mounting the filesystem and devices, starts other services, and finally provides
    the user with a login shell. These tasks are carried out by systemd with the help
    of different libraries and utilities such as `systemctl`, `journalctl`, `hostenamectl`,
    `localectl`, `timedatectl`, `systemd-cgls`, and so on, which it installs with
    itself. It manages the various system resources through objects known as units.
  prefs: []
  type: TYPE_NORMAL
- en: What are units?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In systemd, units are objects that systemd knows how to manage and operate.
    They represent different system resources and they are defined using configuration
    files called unit files. These unit files are are kept in the `/usr/lib/systemd/system/`
    directory by default. Only those units whose unit files are stored in the `/lib/systemd/system`
    directory can be started or stopped during a session. These files are installed
    in the system by the application's RPM files. Units are the replacement of old
    init scripts that were used before CentOS 7.
  prefs: []
  type: TYPE_NORMAL
- en: What is systemctl?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a replacement for the service and `chkconfig` command in CentOS 7\. The `systemctl`
    command is used to manage the different types of systemd objects (units). Systemd
    has 12 unit types, which can be listed with the command shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20cb22de-f428-4e6d-bcaf-4cdf4f7dc5fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table lists some popular units and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Unit types** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Service | These types of units have a `.service` extension and represent
    the system services. This unit is used to start daemons such as the web server.
    If no unit name is specified with `systemctl`, then the service is assumed as
    the default unit. |'
  prefs: []
  type: TYPE_TB
- en: '| Socket | These types of units have a `.socket` extension and represent **inter-process
    communication** (**IPC**) sockets. |'
  prefs: []
  type: TYPE_TB
- en: '| Path | These type of units have a `.path` extension and are used to delay
    the activation of a service until a specific filesystem change occurs. |'
  prefs: []
  type: TYPE_TB
- en: '| Target | These types of units have a `.target` extension and represent a
    group of units. |'
  prefs: []
  type: TYPE_TB
- en: '| Slice | These types of units have a `.slice` extension and they represent
    a management unit of processes. |'
  prefs: []
  type: TYPE_TB
- en: Working with systemd and systemctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes how systemd and systemctl are organized and how important
    objects (units) are managed using systemd.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing states of service with systemctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The service unit is one of the most important units of `systemd`, which is
    managed using `systemctl`. If no unit type is specified, `systemctl` shows the
    status of the service unit, if it exists. The following is the syntax to view
    any unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, name is the service name and type is the unit type, such as service,
    socket, path, and so on. The example in the following screenshot illustrates the
    usage of the `systemctl` command for viewing the status of a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b9859fb-55b6-4c45-8d1d-94ed85b16b13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table lists the various statuses of services, along with their
    descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Loaded` | Unit configuration file is processed successfully |'
  prefs: []
  type: TYPE_TB
- en: '| `Active (running)` | Running with one or more active processes |'
  prefs: []
  type: TYPE_TB
- en: '| `Active (exited)` | Successfully completed a one-time configuration |'
  prefs: []
  type: TYPE_TB
- en: '| `Active (waiting)` | Running and waiting for an event to take place |'
  prefs: []
  type: TYPE_TB
- en: '| `Inactive` | Not running currently |'
  prefs: []
  type: TYPE_TB
- en: '| `Enabled` | Will get started at boot time |'
  prefs: []
  type: TYPE_TB
- en: '| `Disabled` | Will not get started at boot time |'
  prefs: []
  type: TYPE_TB
- en: '| `Static` | Cannot be enabled directly, but may be started by another enabled
    unit automatically |'
  prefs: []
  type: TYPE_TB
- en: Viewing unit files with systemctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a system administrator or user, sometimes it is necessary to find out the
    current status of systemd unit files. This helps in fine-tuning of system. We
    can configure services to be in active and loaded state or in an inactive state
    after booting of system, using the `systemctl` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the commands used to view the unit files and their
    descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl` | Displays the state of all the different units that are active
    and loaded on startup |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl --type=service` or`# systemctl list-units --type=service` |
    Displays the state of only service units that are active |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl --type=service –all` or`# systemctl list-units --type=service
    --all` | Displays the state of all service units loaded, whether active or inactive
    |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl --failed --type=service` | Displays all services that failed
    |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl is-active sshd` | Displays whether the particular service is
    currently active or not |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl is-enabled sshd` | Displays whether the particular service in
    enabled to start at boot time or not |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl list-unit-files --type=service` | Displays the enabled, disabled,
    or static settings of all units of the specified type |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl status sshd.servisystemctlce -l` | Displays detailed status
    information about the specified service |'
  prefs: []
  type: TYPE_TB
- en: Unit dependencies and unit file structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Services are started as standalone, or sometimes as dependencies of other services.
    For example, let''s assume a socket unit is enabled, but the service unit with
    the same socket name is not, then the service will automatically get started when
    a request is made on the network socket. Similarly, the service can also be triggered
    by the path unit when a filesystem path condition is met. The following command
    is used to list the dependency tree of the specified unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with CentOS 7, `systemd` provides a uniform interface to start unit
    files from their storage loaction. The locations of the unit file stored in the
    system are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/usr/lib/systemd/system/`: It contains system default unit files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/systemd/system`: It contains system-specific parameters to modify the
    default behavior of systemd'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/run/systemd/system/`: It contains the runtime configuration of unit files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The structure of a unit file is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be642904-0aaa-4b69-9f3a-62dc2d13515f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding unit file can be broken down into following three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit**: This section describe the unit type and its dependencies, if any.
    It also contains the `After` statement and the `Before` statement. These statements
    define the dependencies of the unit. The `Before` statement says that this unit
    should be started before the specified unit. The `After` statement says that this
    unit should be started after starting the specified units.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**: This section contains a description of how to start and stop the
    service. The line beginning with the `ExecStart` parameter describes how to start
    the unit and the line beginning with the `ExecStop` parameter describes how to
    stop the unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Install**: This section contains a line beginning with the `WantedBy` parameter,
    which states the target of this application. Target units are the equivalent of
    runlevels, which we had in CentOS 6 and earlier versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing daemons using systemctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Services can be started at boot time by creating a link to the unit files in
    the systemd configuration directory using the `systemctl` command. Earlier enabling
    of a service to start it automatically at boot time was managed using `chkconfig`.
    An example to illustrate the usage of `systemctl` command to disable or enable
    a unit file is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8f40384-7822-44a8-bf15-d6930d7b35b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Masking services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To prevent conflict between similar types of services that perform a certain
    function, masking is used. For example, for a firewall, CentOS 7 has both `iptables`
    and `firewalld` services; however, it is recommended to use only one at a time.
    Hence, one of the two firewall services is masked to prevent conflict between
    the two services. Masks prevent the accidental startup of a service by creating
    a `symlink` of the service file to `/dev/null` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fad155a8-ac99-4fc7-8405-d91b54d155cb.png)'
  prefs: []
  type: TYPE_IMG
- en: If a service is disabled, it will not get started automatically at boot even
    by other unit files; however, a user can still start that service manually. A
    mask service has the advantage here, as it cannot be started manually or automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the different `systemctl` commands used to manage
    a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl status <unit>` | Displays detailed information of unit state
    |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl stop <unit>` | Stops the running service |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl start <unit>` | Starts the stopped service |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl restart <unit>` | Restarts (stop and then start) a service |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl reload <unit>` | Reloads configuration of a running service
    by rereading its config file |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl mask <unit>` | Completely disables a service from starting at
    boot time automatically, or manually any time |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl unmask <unit>` | Unmasks a masked service, making it available
    for the user to enable it or start manually |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl enable <unit>` | Sets the service to start automatically at
    boot time |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl disable <unit>` | Disables a service from starting automatically
    at boot time |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl poweroff` | Shuts down the system |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl reboot` | Restarts the system |'
  prefs: []
  type: TYPE_TB
- en: Controlling the boot process using systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During the boot process, when the kernel image and initramfs image get loaded,
    initramfs starts the first process on the system, which is systemd with the process
    ID 1\. This systemd process further takes over control in the final stages of
    system booting and performs the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads the configuration files from the `/etc/systemd/` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads the files linked by `/etc/systemd/system/default.target`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executes the `/etc/rc.local file`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systemd target units are responsible for determining and starting the services
    automatically on the system after booting up. In this section, we will learn how
    to control the execution of a set of services on startup. These services will
    collectively define the state of our system such as it is in single user mode
    or multi-user mode with networking enabled, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What are systemd targets?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Target units are used for grouping and ordering other units. `systemd` manages
    starting several related process at the same time with the help of target units.
    Some targets, such as `multi-user.target`, define a specific state of the system
    and can be considered as more robust and flexible equivalents of SysV runlevels.
    At the same time, other targets do not offer any additional functionality except
    grouping units to manage dependencies effectively. The target unit configuration
    files are stored in the `/usr/lib/systemd/system` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists important targets, along with their equivalent runlevels
    and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Equivalent runlevel** | **Target unit** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | `poweroff.target` | Shuts down and powers off the system |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `rescue.target` | Sulogin prompt with basic system initialization |'
  prefs: []
  type: TYPE_TB
- en: '| 2, 3, 4 | `multi-user.target` | Non-graphical multi-user text-based login
    only |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `Graphical.target` | Graphical multi-user and text-based login |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `Reboot.target` | Shuts down and reboots system |'
  prefs: []
  type: TYPE_TB
- en: 'Some targets are part of another target: `graphical.target` includes `multi-user.target`,
    which in its turn depends on `basic.target` and others. We can view these dependencies
    from the command line by executing the command line shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eb870ed-a995-4c28-942f-2f97c25d8b06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can view the available targets that are currently loaded on the running
    system by using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can view all the targets that are installed on the system by using the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Switching your targets at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In CentOS 7, an administrator can switch to different target (runlevel) at
    runtime by using the `systemctl isolate` command, which was done using the `telinit`
    command in CentOS 6\. We can only isolate to those targets that have `AllowIsolate=yes` set
    in their unit files. For example, we can switch to `multi-user.target` from `graphical.target`
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will bring the user to runlevel 3\. To switch back to
    runlevel 5, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Changing the default target of the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the booting up of the system, systemd activates `default.target`, which
    is generally a symbolic link in the `/etc/systemd/system/` directory to either
    `graphical.target` or `multi-user.target`. It is equivalent to the default runlevel,
    which the system administrator used to set in the `/etc/inittab` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the `systemctl` commands that are used to manage
    default targets along with their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl get-default` | Views the existing default target |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl set-default graphical.target` | Sets the default target to `graphical.target`
    (graphical shell) |'
  prefs: []
  type: TYPE_TB
- en: '| `# systemctl set-default multi-user.target` | Sets the default target to
    `multi-user.target` (text-based shell) |'
  prefs: []
  type: TYPE_TB
- en: 'An example to change the default target by using the `systemctl` command is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11935dc5-4958-4cc5-b269-8ffd3372baa8.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding SELinux concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux is an additional layer of security to protect the system. The permission
    set by users manually is a kind of security control that works at the user's discretion,
    while SELinux is a mandatory access control for securing the system. Its main
    role is to protect data when a system service is compromised. SELinux consists
    of a set of security rules that determine which process can access which files,
    directories, or ports.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When SELinux is enforced in the system, it check for rules on which process
    can access which files, directories, and ports. Every file, process, directory,
    and port has a special security label known as an SELinux context, which is a
    name used to determine whether a process can access a file, directory, or port.
    By default, the policy does not allow any interaction unless an explicit rule
    grants access.
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux labels have different contexts: user, role, type, and sensitivity.
    The targeted policy is the default policy enabled in CentOS 7, which defines its
    rules based on the third context, which is the type context. Type context names
    generally end with `_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing SELinux context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the Linux commands have the `-Z` option to display SELinux contexts.
    For example, `ps`, `ls`, `cp`, and `mkdir` all use the `-Z` option to display
    or set SELinux contexts of a file, directory, process, or port.
  prefs: []
  type: TYPE_NORMAL
- en: '**The following are examples that illustrate the usage of -Z option with several
    commands for displaying the SELinux context:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ps` command can be used to view processes along with their SELinux contexts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ps` command can also be used with option `-ZC`, to view the SELinux context
    of a process specified as an argument as shown in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ls` command can be used with `-Z` option to view the SELinux context of
    files in a directory as shown in the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cp` command can be used with the `-A` option to preserve the SELinux context
    of a file or directory while performing the copy operation as shown in the following
    command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Generally, the context of the parent directory is assigned to the child, when
    we create a new file with the `vim`, `cp`, or `touch` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a clearer and deeper insight into SELinux concepts, let''s consider
    the workings of an Apache web server in the absence and presence of SELinux controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In the absence of SELinux**: In this case, the web server is running on port
    `80`, which is opened in the firewall to allow access for service web pages. Let''s
    assume the attacker has compromised the Apache service due to a vulnerability
    in it. After compromising it, the attacker will gain access to the document root
    with the permissions of the Apache user and Apache group. Hence, an attacker can
    create and write files in the `/var/www/html/`, `/tmp`, and `/var/tmp` directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the presence of SELinux enforcing mode**: In this case, SELinux checks
    for the rules given in the targeted policy, which are based on type context. The
    SELinux context type for Apache web server process is `httpd_t` and SELinux context
    type of files and directories in `/var/www/html` is `httpd_sys_content_t`**.**
    The SELinux context type of files and directories in `/tmp` and `/var/tmp` is
    `tmp_t`in enforcing mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The targeted policy rule permits the process running as `httpd_t` to access
    files and directories with the context `httpd_sys_content_t`, so access to files
    or directories in `/tmp/` and `/var/tmp/` is not permitted. Thus, even if a malicious
    user compromises the web server, they cannot create or write a file in the `/tmp/`
    or `/var/tmp` directories. The damage caused by the user will remain restricted
    to the `/var/www/html` folder as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35807258-cc5d-48b5-bb38-8e098a93ba4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with SELinux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section deals with various commands used to manage the SELinux context
    and enforced policies applied on files, directories, processes, and ports.
  prefs: []
  type: TYPE_NORMAL
- en: Changing SELinux modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SELinux has three modes of operation, mentioned in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SELinux mode** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Enforcing | In this mode, rules are available and applied. SELinux logs the
    activities and protects the system. |'
  prefs: []
  type: TYPE_TB
- en: '| Permissive | In this mode, rules are available but not applied. This mode
    is mainly used for troubleshooting. This mode is used to temporarily allow access
    to content that SELinux was restricting in enforcing mode. In this mode, SELinux
    logs the denied actions. System reboot is not required to switch from enforcing
    to permissive mode and vice versa. |'
  prefs: []
  type: TYPE_TB
- en: '| Disabled | In this mode, rules are not available. It completely disables
    SELinux. A system reboot is required to disable or switch from enforcing or permissive
    mode to disabled mode, as it completely relabels the files. |'
  prefs: []
  type: TYPE_TB
- en: Using setenforce for runtime changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can change the SELinux modes from enforcing to permissive and vice versa
    during runtime by using the `setenforce` command. Before and after changing the
    SELinux mode, we must ensure the current mode by using the `getenforce` command.
  prefs: []
  type: TYPE_NORMAL
- en: '**The following are examples that illustrate the usage of the setenforce and
    getenforce commands:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the current SELinux mode, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the current SELinux mode from enforcing to permissive, use either
    of the following commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the current SELinux mode from permissive to enforcing, use either
    of the following commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To view detailed SELinux information, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Another way to temporarily change the SELinux mode is by passing a parameter
    to the kernel at boot time. Passing a kernel argument of `enforcing=0` will boot
    the system in permissive mode for that instance and `selinux=1` will boot the
    system in enforcing mode.
  prefs: []
  type: TYPE_NORMAL
- en: Setting default modes of SELinux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The configuration file of SELinux is `/etc/selinux/config`. It determines the
    mode and policy of SELinux at boot time. We can modify the `/etc/selinux/config`
    file and set the `SELINUX=permissive` parameter to change the default mode of
    SELinux, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6ca328a-276e-4e4a-b43c-74542b11ce5e.png)'
  prefs: []
  type: TYPE_IMG
- en: In previous releases of CentOS, the SELinux configuration file was stored at
    `/etc/sysconfig/selinux`. Now, in CentOS 7, this file is a `symlink` of `/etc/selinux/confg`.
  prefs: []
  type: TYPE_NORMAL
- en: If any kernel argument of `enforcing=0` for permissive mode or `selinux=0` for
    disabling SELinux is passed at boot, then it will override the current configuration
    set in `/etc/selinux/config`.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying file context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, generally, the parent directory SELinux context is assigned
    to the newly created file, if it is created using the `vim`, `cp`, or `touch` command.
  prefs: []
  type: TYPE_NORMAL
- en: If a file is moved using the `mv` command, or copied using the `cp -a` command,
    the original SELinux context will remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we need to modify the file context as per the destination directory,
    so that a process can access the file object when required. In the following sections,
    we discuss the different utilities that can be used to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Using restorecon for restoring the default context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `restorecon` command is the most popular and preferred way of modifying
    the SELinux context of a file or directory. As is visible from the name of the `restorecon`
    command, it is used to restore the default context of a file or directory by reading
    the default rules set in the SELinux policy. If the wrong context is applied,
    `restorecon` automatically corrects it from the policy of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we simulate a problem scenario, in which a file has
    incorrect syntax and we correct it using the `restorecon` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/050bd30d-9268-49b6-bd13-0d28dada3106.png)'
  prefs: []
  type: TYPE_IMG
- en: The `restorecon` command is a part of the `policycoreutil` package, so in order
    to use this command, this package should be installed on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Using chon for context management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chcon` command can also be used with the `_t` option to change the context
    of the file. This method of modifying the context of the file is not recommended,
    as errors can happen while using it. The `chcon` command, when used, writes the
    new context to the filesystem, but the policy remains unchanged. Hence, changes
    made using this command get overwritten on relabeling the SELinux context on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of `chcon` command usage is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cffee1d0-5d92-47b7-bf04-bdbeea07255f.png)'
  prefs: []
  type: TYPE_IMG
- en: Using semanage for context management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `semanage` command writes the new context to the SELinux policy, which is
    used to apply the file context at the relabeling of the file labels or while setting
    the default file context using `restorecon`. It uses an extended regular expression
    to specify the path and filenames for applying those rules (new file context).
    The most commonly used extended regular expression with `semanage fcontext` is
    `(/.*)?`. This expression matches the directory listed before the expression and
    everything in that directory recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of `semanage` command usage is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43e888d3-696f-4e23-90dc-93becf4b59fe.png)'
  prefs: []
  type: TYPE_IMG
- en: The `semange` command is a part of the `policycoreutil-python` package. In order
    to use the `semanage` command, make sure this package is installed in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying port context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SELinux does much more than just restricting the access of processes to files
    based on SELinux labels. It can also control the network traffic by restricting
    access to unauthorized ports for a service. By default, the SELinux policy allows
    the `ssh` service to access port, `22`/TCP . In the following example, we allow
    `ssh` to run on another port `2525`/TCP, in addition to its default port, as shown
    in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `semanage` command can be used with the `port` sub-command to list the
    current port assigned to a service as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e12d5039-89dd-49c8-b19d-71e6aece8808.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the `semanage` command for granting access to any custom port
    for a particular service. In the following screenshot, the `semanage` command
    is used to add the selected port to the access list of a particular service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ef47cc4b-d00a-41dc-a45b-4c8aedf0225c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `semanage` command can also be used to remove an association of a port
    to a particular service as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6b06f18a-b18e-4e41-9b8e-7ca0b0998741.png)'
  prefs: []
  type: TYPE_IMG
- en: Managing SELinux Booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux Booleans are switches that contains a set of rules to make a selective
    adjustment in behavior to an SELinux policy. SELinux Booleans provide an easy
    interface to change the behavior of an SELinux policy rule.
  prefs: []
  type: TYPE_NORMAL
- en: '**The following are examples that illustrate the usage of the getsebool and
    setsebool commands for managing SELinux Booleans:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getsebool` command can be used with the `-a` option to display the list
    of all SELinux Booleans and their current values as shown in the following command
    line. The output of this command is passed to a grep filter to narrow down the
    results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `getsebool -a` command can be filtered down using `grep`
    as shown in the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setsebool` command can be used to modify (switch on or off) the value
    of a SELinux Boolean at runtime as shown in following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify runtime value as well as the default values of the SELinux Boolean simultaneously
    by using the `setsebool` command with the `-P` option as shown in the following
    command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Managing SELinux troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux provides an essential layer of security beyond the discretionary access
    control set by the user. It prevents any unauthorized attempt to access a resource
    such as a file by a running process. Here, the process that attempt to access
    a resource could be a genuine process or it could be a compromised process. Disabling
    SELinux is not considered good practice. Sometimes, when a binary or application
    is installed from a third party, it does not contain any appropriate SELinux context,
    which may lead to restrictions in running that service properly. In those circumstances,
    SELinux is run in permissive mode and new rules are created based on the denial
    of service messages captured in log files. In most cases of SELinux troubleshooting,
    it has been observed that access control restrictions are applied by SELinux due
    to incorrect type context on a file. This issue can be easily resolved using the `restorecon` command,
    which sets the default context on files from SELinux rules given in a policy.
    Using this method, we can keep our SELinux in enforcing mode and the security
    of our systems intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying the mode of SELinux Booleans by turning their values on and off is
    also used sometimes to relax or harden the SELinux controls for running a service.
    For making an appropriate change in SELinux rules or policies, the primary requirement
    is to understand the problem correctly. In this, the monitoring of SELinux violations
    by going through logs plays an important role. For logging SELinux messages to
    `/var/log/messages` and `/var/log/audit/audit.log` in an easily understandable
    format, the `setroubleshoot-server` package should be installed on the system
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using sealert for troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each SELinux violation is assigned a **unique** **identifier** (**UUID**). This
    UUID is used with the `sealert` command to produce a summary of a report for a
    specific incident.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a file in root''s home directory and move this file
    into `/var/www/html/`. Now, try to access that file through the web browser or
    from the command line using `curl` as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f16bb7d-acef-41bb-bbc5-23312d367c8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The error report of the SELinux violation can be viewed now, using the UUID
    and `sealert` command, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82906200-6c23-483f-a6c0-49ba61183f76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On applying the suggestions of the SELinux violation given in the `sealert`
    report, it will remove the error and allow access to the file using the `curl` command
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e16bbda-1112-4f07-bf12-b40e9ad60dbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding firewall concepts in CentOS 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operating system security generally follows a defense in depth model, where
    security is implemented at different layers in the system. Starting from policies
    and procedure, physical controls, network perimeter security, host security, application
    security, and so on, several elements are secured to harden the security of a
    system. In this, a firewall helps in securing the system, as well as applications,
    by limiting access to the system. Firewall rules filter packets based on specific
    criteria, such as IP addresses, port and protocol, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, firewall rules are managed by the network filtering subsystem available
    in the kernel and known as **netfilter.** The netfilter framework enables the
    system to inspect, modify, drop, or reject any incoming, outgoing, or forwarded
    network packet programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: The `iptables` command is the most popular tool used to interact with netfilter
    and manage the firewall. The `iptables` command only manages the IPv4 rules in
    the firewall. For management of IPv6 rules, the `ip6tables` command is used, and
    for software bridges, the `ebtables` utility is used. However, managing the firewall
    using the `iptables` utility is not user friendly and requires a good understanding
    of both the firewall and `iptables` command. Thus, to overcome the complexity
    of `iptables` and incorporate some advanced features, a new utility, `firewalld`, was
    designed.
  prefs: []
  type: TYPE_NORMAL
- en: Firewalld concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In CentOS 7, a new utility called **firewalld** has been introduced to interact
    with netfilter. It can be used to configure and monitor the firewall rules for
    IPv4, IPv6, and for software bridges. Furthermore, applications can interact with
    `firewalld` to add or change firewall rules, such as a requesting for a port opening
    with the help of the D-bus messaging system. firewalld supports both runtime configuration
    and persistence configuration. It is installed by default in the CentOS Base installation,
    but if it is not available, then user can install it is using the following command
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: firewalld is not compatible with the `iptables` service, so it is strongly recommended
    to not use them simultaneously on the same system. Either use `firewalld` and
    disable `iptables` (`iptables`, `ip6tables`, and `ebtables`), or use `iptables`
    and disable `firewalld`.
  prefs: []
  type: TYPE_NORMAL
- en: Firewalld zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The firewalld segregates incoming traffic into zones. Each zone is a collection
    of rules. To select which zone is to be used for an incoming connection, firewalld
    uses the following three rules to match in the given order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The source address** on the incoming packet is matched with the source address
    rule configured for the zone. If the source address matches, the packet is routed
    through that zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the source address does not match, then the **incoming interface** for a
    packet is matched with the interface set up for the zone and that zone is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If neither the incoming interface of the packet nor the source address of a
    packet matches, then the rules given in the **default zone** are applied on that
    packet. The default zone is one of the other zones defined by the system or user.
    By default, the public zone is set as the default zone. The example of `firewall-cmd`
    to list the available zones and default zone is shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b0ac9f56-60a9-4da7-82aa-6f91c115f2d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table lists the predefined zones available in `firewalld` and
    their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Zone** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `trusted` | Allows all incoming traffic. |'
  prefs: []
  type: TYPE_TB
- en: '| `home` | This zone is used for home networks. In this zone, incoming traffic
    is rejected unless it is related to outgoing traffic or it matches the predefined
    services of zone, such as `ssh`, `mdns`, `ipp-client`, `samba-client`, or `dhcpv6-client`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `internal` | This zone has the same rules as defined in the home zone. It
    is generally used for internal networks. |'
  prefs: []
  type: TYPE_TB
- en: '| `work` | In this zone, all incoming traffic is rejected, unless it is related
    to outgoing traffic or it matches some predefined services of the zone, such as,
    `ssh`, `mdns`, `ipp-client`, or `dhcpv6-client`: |'
  prefs: []
  type: TYPE_TB
- en: '| `public` | In this zone, all incoming traffic is rejected, unless it is related
    to outgoing traffic or it matches some predefined services of the zone, such as `ssh`
    or `dhcpv6-client`. |'
  prefs: []
  type: TYPE_TB
- en: '| `external` | In this zone, all incoming traffic is rejected, unless it is
    related to outgoing traffic or it matches some predefined services of zone, such
    as `ssh`. Outgoing IPv4 traffic forwarded from this zone is masqueraded (NAT)
    to make it originate from the outgoing network interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `dmz` | `dmz` is the demilitarized zone. Only selected incoming connections
    with limited access to the internal network are allowed. All other traffic is
    rejected. |'
  prefs: []
  type: TYPE_TB
- en: '| `block` | Reject all incoming traffic with an `icmp-host-prohibited` message.
    Only incoming traffic related to connections originating from the outgoing traffic
    of the system is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| `drop` | In this zone, all incoming traffic is dropped (without any ICMP
    errors) unless it is related to outgoing traffic. |'
  prefs: []
  type: TYPE_TB
- en: Firewalld services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other main component of firewalld is services. There are certain default
    services that are used to allow or deny access to traffic on specific ports, for
    a particular network service in the firewall. Each service has got a configuration
    file that describes its requirements, such as what TCP or UDP ports are required
    for service operation. Users can list all the available services in firewalld
    with the command shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35287e48-5931-432c-bc54-8bce532880b3.png)'
  prefs: []
  type: TYPE_IMG
- en: For the secure configuration of firewalld, each service should be allowed access
    in the correct zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The services configuration file is stored in the following two directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/usr/lib/firewalld/services`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/firewalld/services`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These services files are configured in XML format. An example of the `ftp.xml`
    file is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e707c6af-6c80-40bd-8733-5e5c2ae33d2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Managing firewalld
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firewalld can be managed in the following two ways.
  prefs: []
  type: TYPE_NORMAL
- en: Using the firewalld-cmd command-line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most common method of managing firewalld configurations (both running
    as well as permanent). In this section, we have described the management of firewalld
    with this tool. It can perform all the jobs that are performed using the firewalld-config GUI
    tool. This tool is a part of the `firewalld` package.
  prefs: []
  type: TYPE_NORMAL
- en: Using the firewalld-config graphical tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firewall-config is a graphical tool that is used to modify and view the running
    (in-memory) configuration of firewalld, as well as permanent (on hard disk) configuration.
    This tool is a part of the firewall-config package. It is invoked from the command
    line by typing `firewall-config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration files of firewalld are stored inside the `/etc/firewalld/`
    directory. Firewalld supports two types of configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime or in-memory configurations**:The in-memory configurations of firewalld
    are lost on reloading firewalld or after rebooting of system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permanent or on-disk configurations**: This configuration remains after reboot
    and is applied on reloading firewalld.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with firewalld
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting firewalld, we need to ensure that `iptables`, `ip6tables`, and
    `ebtables` are not running, as they conflict with firewalld.
  prefs: []
  type: TYPE_NORMAL
- en: '**The following are examples that illustrate the usage of firewalld-cmd command:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the conflicting service of `iptables`, `ip6tables`, and `ebtables` using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command is used to `start` and enable `firewalld` in CentOS 7:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the first step in configuring `firewalld` should be to check the existing
    zones and services that are configured by default and the zones and services that
    the user has not configured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'List all the zones in `firewalld` by using the following command line:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'List only active zones of `firewalld` by using the following command line:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'List the current default zone by using the following command line:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'List the services available for configuration with `firewalld` by using the
    following command line:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After making any changes in the `firewalld` configuration, it is mandatory
    to reload it to bring the applied changes into effect. By default, all changes
    made are runtime changes only. We can make them permanent by using the `--`permanent
    option. It will preserve the configuration changes across reboot. Now, let''s
    change the default zone using the `firewalld-cmd` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the default zone, we should confirm the setting of the current
    default zone by using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a port to the public zone using `firewall-cmd` permanently
    by using the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, if we don''t add the `--permanent` option, then changes
    will get lost after reloading the `firewalld` configuration. We can reload the
    `firewalld` configuration by using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, see the status of recently added TCP port `80` in `firewalld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `firewall-cmd` command to view the complete configuration
    for a zone. In the following example, we list the complete configuration of the
    internal zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we use the `firewall-cmd` command to remove TCP port
    `80` from the internal zone as shown in the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a service to a zone in `firewalld`. The following example shows how to
    add an `ftp` service in the `firewalld` internal zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'List the services in a zone by using the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove a service from a zone in `firewalld` by using the following command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The user can drop all incoming and outgoing packets of an active connection
    when there is a breach in the network by using the panic options of `firewall-cmd`
    as shown in the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'On execution of the preceding command, any ping, `ssh`, or web-related activity
    on the system will be blocked. To turn off this feature, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Besides the `firewall-cmd` configuration rules that we have discussed in this
    section, firewalld has two more options for adding firewall rules, direct rules
    and rich rules.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began by learning what the different types of logging in
    the Linux system are, and how to use them effectively for debugging and troubleshooting
    Linux systems. Then, we learned about managing system services to optimize system
    performance. This was followed by understanding SELinux concepts to harden the
    security of applications and the system. Finally, we looked at how to filter the
    incoming and outgoing packets in the system using the firewalld framework.
  prefs: []
  type: TYPE_NORMAL
- en: Linux is all about learning by doing. If you have practiced the commands given
    in each chapter, together with the theoretical part, you will feel more comfortable
    while working on Linux. This book is written for novice Linux users, yet a seasoned
    Linux user will also have something to take away from each chapter. With this,
    our fascinating journey of kick-starting Linux with the CentOS 7 operating system
    comes to an end. If you have any queries, I would like to hear it from you. You
    can reach me at `shiwangkalkhanda@outlook.com`.
  prefs: []
  type: TYPE_NORMAL
