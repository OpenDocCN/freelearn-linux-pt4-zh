<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Crash Course in Bash</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">The primary purpose of this chapter is to give you enough knowledge about the Linux shell/Bash to get you up and running, as that the remainder of the book will just fall into place.</span></p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Getting started with Bash and CLI fundamentals</li>
<li class="calibre14">Creating and using basic variables</li>
<li class="calibre14">Hidden Bash variables and reserved words</li>
<li class="calibre14">Conditional logic using if, else, and elseif</li>
<li class="calibre14">Case/switch statements and loop constructs</li>
<li class="calibre14">Using functions and parameters</li>
<li class="calibre14">Including source files</li>
<li class="calibre14">Parsing program input parameters</li>
<li class="calibre14">Standard in, standard out, and standard error</li>
<li class="calibre14">Linking commands using pipes</li>
<li class="calibre14">Finding more information about the commands used within Bash</li>
</ul>
<div class="packt_infobox">This chapter will set you up with the basic knowledge needed to complete the recipes in the remaining chapters of the book.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started with Bash and CLI fundamentals</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">First, we need to open a Linux terminal or shell. Depending on your flavor (distribution) of Linux, this will be done in one of several ways, but in Ubuntu, the easiest way is to navigate to the <span class="calibre16">Applications</span> menu and find one labeled terminal. The terminal or shell is the place where commands are entered by a user and executed in the same shell. Simply put, results (if any) are displayed, and the terminal will remain open, waiting for new commands to be entered. Once a shell has been opened, a <em class="calibre18">prompt</em> will appear, looking similar to the following:</span></p>
<pre class="calibre22"><strong class="calibre3"><span class="calibre11">rbrash@moon:~$</span></strong></pre>
<p class="mce-root">The prompt will be in the format of your<span class="calibre16"> </span><kbd class="calibre17">username@YourComputersHostName</kbd><span class="calibre16"> </span>followed by a delimiter. Throughout this cookbook, you will see commands with the user <kbd class="calibre17">rbrash</kbd>; this is short for the author's name (Ron Brash) and in you case, it will match your username.</p>
<p class="mce-root">It may also look similar to:</p>
<pre class="calibre22"><strong class="calibre3"><span class="calibre11">root@hostname #</span></strong></pre>
<p class="mce-root"><span class="calibre16">The <kbd class="calibre17">$</kbd> refers to a regular user and the <kbd class="calibre17">#</kbd> refers to root. In the Linux and Unix worlds, root refers to the <em class="calibre18">root user</em>, which is similar to the Windows Administrator user. It can be used to perform any manner of tasks, so caution should be used when using a user with root privileges. For example, the root user can access all files on the OS, and can also be used to delete any or all critical files used by the OS, which could render the system unusable or broken.</span></p>
<p class="mce-root"><span class="calibre16">When a terminal or shell is run, the Bash shell is executed with a set of parameters and commands specific to the user's bash profile. This profile is often called the <kbd class="calibre17">.bashrc</kbd> and can be used to contain command aliases, shortcuts, environment variables, and other user enhancements, such as prompt colors. It is located at <kbd class="calibre17">~/.bashrc or ~/.bash_profile</kbd>.</span></p>
<div class="packt_tip"><kbd class="calibre23">~ or ~/</kbd> is a shortcut for your user’s home directory. It is synonymous with <kbd class="calibre23">/home/yourUserName/</kbd> , and for root, it is <kbd class="calibre23">/root</kbd>.</div>
<p class="mce-root"><span class="calibre16">Your user's Bash shell also contains a history of all of the commands run by the user (located in <kbd class="calibre17">~/.bash_history</kbd>), which can be accessed using the <kbd class="calibre17">history</kbd> command, shown as follows:</span></p>
<pre class="calibre22"><strong class="calibre3"><span class="calibre11">rbrash@moon:~$ history<br class="calibre2"/></span><span class="calibre11">1002 ls<br class="calibre2"/></span><span class="calibre11">1003 cd ../<br class="calibre2"/></span><span class="calibre11">1004 pwd<br class="calibre2"/></span><span class="calibre11">1005 whoami<br class="calibre2"/></span><span class="calibre11">1006 history</span></strong></pre>
<p class="mce-root"><span class="calibre16">For example, your first command might be to use <kbd class="calibre17">ls</kbd> to determine the contents of the directory. The command <kbd class="calibre17">cd</kbd> is used to change the directory, to one directory in above the parent directory. The <kbd class="calibre17">pwd</kbd> command is used to return the complete path to the working directory (for example, where the terminal is currently navigated to).</span></p>
<p class="mce-root"><span class="calibre16">Another command you may execute on the shell might be the <kbd class="calibre17">whoami </kbd>command, which will return the user currently logged in to the shell:</span></p>
<pre class="calibre22"><strong class="calibre3"><span class="calibre11">rbrash@moon:/$ whoami<br class="calibre2"/></span><span class="calibre11">rbrash<br class="calibre2"/></span><span class="calibre11">rbrash@moon:/$</span></strong></pre>
<p class="mce-root"><span class="calibre16">Using the concept of entering commands, we can put those (or any) commands into a <em class="calibre18">shell script</em>. In its most simplistic representation, a shell script looks like the following:</span></p>
<pre class="calibre22"><strong class="calibre3"><span class="calibre11">#!/bin/bash<br class="calibre2"/></span><span class="calibre11"># Pound or hash sign signifies a comment (a line that is not executed)<br class="calibre2"/></span><span class="calibre11">whoami      #Command returning the current username<br class="calibre2"/></span><span class="calibre11">pwd         #Command returning the current working directory on the filesystem<br class="calibre2"/></span><span class="calibre11">ls          # Command returning the results (file listing) of the current working directory<br class="calibre2"/></span><span class="calibre11">echo “Echo one 1”; echo “Echo two 2” # Notice the semicolon used to delimit multiple commands in the same execution.</span></strong></pre>
<p class="mce-root"><span class="calibre16">The first line contains the path to the interpreter and tells the shell which interpreter to use when interpreting this script. The first line will <em class="calibre18">always</em> contain the shebang (<kbd class="calibre17">#!</kbd>) and the prefix to the path appended without a space:</span></p>
<pre class="calibre22"><strong class="calibre3"><span class="calibre11">#!/bin/bash</span></strong></pre>
<p class="mce-root"><span class="calibre16">A script cannot execute by itself; it needs to be executed by a user or to be <em class="calibre18">called</em> by another program, the system, or another script. The execution of a script also requires it to have <em class="calibre18">executable</em> permissions, which can be granted by a user so that it can become executable; this can be done with the <kbd class="calibre17">chmod</kbd> command.</span></p>
<p class="mce-root"><span class="calibre16">To add or <em class="calibre18">grant</em> basic executable permissions, use the following command:</span></p>
<pre class="calibre22"><strong class="calibre3"><span class="calibre11">$ chmod a+x script.sh</span></strong></pre>
<p class="mce-root"><span class="calibre16">To execute the script, one of the following methods can be used:</span></p>
<pre class="calibre22"><strong class="calibre3"><span class="calibre11">$ bash script.sh          # if the user is currently in the same directory as the script<br class="calibre2"/></span><span class="calibre11">$ bash /path/to/script.sh # Full path</span></strong></pre>
<p class="mce-root"><span class="calibre16">If the correct permissions are applied, and the shebang and Bash interpreter path is correct, you may alternatively use the following two commands to execute <kbd class="calibre17">script.sh</kbd>:</span></p>
<pre class="calibre22"><strong class="calibre3">$ ./script.sh # if the user is currently in the same directory as the script</strong><br class="calibre2"/><strong class="calibre3">$ /path/to/script.sh # Full path</strong></pre>
<p class="mce-root">From the preceding command snippets, you might notice a few things regarding paths. The path to a script, file, or executable can be referred to using a <em class="calibre18">relative</em> address and a<span class="calibre16"> </span><kbd class="calibre17">full path</kbd>. Relative addressing effectively tells the interpreter to execute whatever may exist in the current directory or using the user's global shell <kbd class="calibre17">$PATH</kbd> variables. For example, the system knows that binaries or executable binaries are stored in <kbd class="calibre17">/usr/bin, /bin/ and /sbin</kbd> and will look there first. The full path is more concrete and <em class="calibre18">hardcoded;</em> the interpreter will try to use the complete path. For example, <kbd class="calibre17">/bin/ls or /usr/local/bin/myBinary</kbd>.</p>
<p class="mce-root">When you are looking to run a binary in the directory you are currently working in, you can use either <kbd class="calibre17">./script.sh</kbd>, bash <kbd class="calibre17">script.sh</kbd>, or even the full path. Obviously, there are advantages and disadvantages to each approach.</p>
<div class="packt_tip">Hardcoded or full paths can be useful when you know exactly where a binary may reside on a specific system and you cannot rely on <kbd class="calibre23">$PATH</kbd> variables for potential security or system configuration reasons.<br class="calibre2"/>
Relative paths are useful when flexibility is required. For example, program <kbd class="calibre23">ABC</kbd> could be in location <kbd class="calibre23">/usr/bin</kbd> or in <kbd class="calibre23">/bin</kbd>, but it could be called simply with ABC instead of <kbd class="calibre23">/pathTo/ABC</kbd>.</div>
<p class="mce-root">So far, we have covered what a basic Bash script looks like, and briefly introduced a few very basic, but essential commands and paths. However, to create a script—you need an editor! In Ubuntu, usually by default, <span class="calibre16">you have a few editors available to you for the creation of</span> a Bash script: vi/vim, nano, and gedit. There are a number of other text editors or <strong class="calibre6">integrated development editors</strong> (<strong class="calibre6">IDEs</strong>) available, but this is a personal choice and up to the reader to find one they  like. All of the examples and recipes in this book can be followed regardless of the text editor chosen.</p>
<div class="packt_tip">Without using a full-blown editor such as the popular Eclipse, Emacs or Geany may also be useful<span class="calibre11"> as flexible IDEs within resource-constrained environments, for example, a Raspberry Pi.<br class="calibre2"/>
<br class="calibre2"/></span> <span class="calibre11">Knowledge of vi/vim and nano is very handy when you want to create or modify a script remotely over SSH and on the console. Vi/vim may seem a bit archaic, but it saves the day when your favorite editor is not installed or cannot be accessed.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Your first Bash script with Vim</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's start by creating a script using improved version of vi (called <kbd class="calibre17">vim</kbd>). If Vim (VI-enhanced) is not installed, it can be installed with <kbd class="calibre17">sudo</kbd> or <kbd class="calibre17">root</kbd> using the following command (<kbd class="calibre17">-y</kbd> is short for yes):</p>
<pre class="calibre22"><strong class="calibre3"><span class="calibre11">For Ubuntu or Debian based distributions</span><span class="calibre11"><br class="calibre2"/>$ </span>sudo apt-get -y install vim</strong><br class="calibre2"/><strong class="calibre3">For CentOS or RHEL</strong><br class="calibre2"/><strong class="calibre3">$ s<span class="calibre11">udo yum install -y vim<br class="calibre2"/>For Fedora<br class="calibre2"/></span>$ <span class="calibre11">sudo dnf install -y vim</span></strong></pre>
<p class="mce-root">Open a terminal and enter the following commands to first see where your terminal is currently navigated to, and to create the script using <kbd class="calibre17">vim</kbd>:</p>
<pre class="calibre22"><span class="calibre11"><strong class="calibre3">$ pwd</strong><br class="calibre2"/><strong class="calibre3">/home/yourUserName</strong><br class="calibre2"/><strong class="calibre3">$ vim my_first_script.sh</strong></span></pre>
<p class="mce-root">The terminal window will transform into the Vim application (similar to the following screenshot) and you will be just about ready to program your first script. Simultaneously press the <em class="calibre18">Esc</em>+ <em class="calibre18">I</em> keys to enter Insert mode; there will be an indicator in the bottom left and the cursor block will begin to flash:</p>
<div class="cdpaligncenter"><img src="Images/532afbdf-f9cf-433c-8975-2119517e937d.png" width="570" height="137" class="calibre24"/></div>
<p class="mce-root">To navigate Vim, you may use any number of keyboard shortcuts, but the arrow keys are the simplest to move the cursor up, down, left, and right. Move the cursor to the beginning of the first line and type the following:</p>
<pre class="calibre22"><strong class="calibre3">#!/bin/bash</strong><br class="calibre2"/><strong class="calibre3"># Echo this is my first comment</strong><br class="calibre2"/><strong class="calibre3">echo "Hello world! This is my first Bash script!"</strong><br class="calibre2"/><strong class="calibre3">echo -n "I am executing the script with user: "</strong><br class="calibre2"/><strong class="calibre3">whoami</strong><br class="calibre2"/><strong class="calibre3">echo -n "I am currently running in the directory: "</strong><br class="calibre2"/><strong class="calibre3">pwd</strong><br class="calibre2"/><strong class="calibre3">exit 0</strong></pre>
<p class="mce-root">We have already introduced the concept of a comment and a few basic commands, but we have yet to introduce the flexible <kbd class="calibre17">echo</kbd><strong class="calibre6"> </strong>command. The <kbd class="calibre17">echo</kbd> command can be used to print text to the console or into files, and the <kbd class="calibre17">-n</kbd> flag prints text without the end line character (end line has the same effect as pressing <em class="calibre18">Enter</em> on the keyboard)—this allows the output from the <kbd class="calibre17">whoami</kbd> and <kbd class="calibre17">pwd</kbd> commands to appear on the same line. </p>
<p class="mce-root">The program also exits with a status of <kbd class="calibre17">0</kbd>, which means that it exited with a normal status. This will be covered later as we move toward searching or checking command exit statuses for errors and other conditions.</p>
<p class="mce-root"/>
<p class="mce-root">When you've finished, press <em class="calibre18">Esc</em> to exit insert mode; going back to command mode and typing <kbd class="calibre17">:</kbd> will allow you to write the vim command <em class="calibre18">w</em> + <em class="calibre18">q</em>. In summary, type the following key sequence: <em class="calibre18">Esc</em> and then <em class="calibre18">:wq</em>. This will exit Vim by writing to disk (w) and quitting (q), and will return you to the console.</p>
<div class="packt_infobox"><span class="calibre11">More information about Vim can be obtained by reviewing its documentation using the Linux manual pages or by referring to a sibling book available from Packt (<a href="https://www.packtpub.com/application-development/hacking-vim-72" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://www.packtpub.com/application-development/hacking-vim-72</a>).</span></div>
<p class="mce-root">To execute your first script, enter the <kbd class="calibre17">bash my_first_script.sh</kbd><strong class="calibre6"> </strong>command and the console will return a similar output:</p>
<pre class="calibre22"><strong class="calibre3">$ bash my_first_script.sh </strong><br class="calibre2"/><strong class="calibre3">Hello world! This is my first Bash script!</strong><br class="calibre2"/><strong class="calibre3">I am executing the script with user: rbrash</strong><br class="calibre2"/><strong class="calibre3">I am currently running in the directory: /home/rbrash</strong><br class="calibre2"/><strong class="calibre3">$</strong> </pre>
<p class="mce-root">Congratulations—you have created and executed your first Bash script. With these skills, you can begin creating more complex scripts to automate and simplify just about any daily CLI routines.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating and using basic variables</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The best way to think of variables is as placeholders for values. They can be permanent (static) or transient (dynamic), and they will have a concept called <strong class="calibre6">scope</strong><span class="calibre16"> </span>(more on this later). To get ready to use variables, we need to think about the script you just wrote: <kbd class="calibre17">my_first_script.sh</kbd>. In the script, we could have easily used variables to contain values that are static (there every time) or dynamic ones created by running commands every time the script is run. For example, if we would like to use a value such as the value of <kbd class="calibre17">PI</kbd> (<kbd class="calibre17">3.14</kbd>), then we could use a variable like this short script snippet:</p>
<pre class="calibre22">PI=3.14<br class="calibre2"/>echo "The value of PI is $PI"</pre>
<p class="mce-root">If included in a full script, t<span class="calibre16">he script snippet</span> would output:</p>
<pre class="calibre22">The value of Pi is 3.14</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Notice that the idea of setting a value (<kbd class="calibre17">3.14</kbd>) to a variable is called assignment. We <em class="calibre18">assigned</em> the value of <kbd class="calibre17">3.14</kbd> to a variable with the name <kbd class="calibre17">PI</kbd>. We also referred to the <kbd class="calibre17">PI</kbd> variable using <kbd class="calibre17">$PI</kbd>. This can be achieved in a number of ways:</p>
<pre class="calibre22">echo "1. The value of PI is $PI"<br class="calibre2"/>echo "2. The value of PI is ${PI}"<br class="calibre2"/>echo "3. The value of PI is" $PI</pre>
<p class="mce-root">This will output the following:</p>
<pre class="calibre22">1. The value of PI is 3.14<br class="calibre2"/>2. The value of PI is 3.14<br class="calibre2"/>3. The value of PI is 3.14</pre>
<p class="mce-root">While the output is identical, the mechanisms are slightly different. In version 1, we refer to the <kbd class="calibre17">PI</kbd> <span class="calibre16">variable </span>within double quotes, which indicates a <strong class="calibre6">string (an array of characters)</strong>. We could also use single quotes, but this would make this a <strong class="calibre6">literal string</strong>. In version 2, we refer to the variable inside of <kbd class="calibre17">{ }</kbd> or <em class="calibre18">squiggly</em> brackets; this is useful for protecting the variable in cases where this would break the script. The following is an example:</p>
<pre class="calibre22">echo "1. The value of PI is $PIabc" # Since PIabc is not declared, it will be empty string<br class="calibre2"/>echo "2. The value of PI is ${PI}"  # Still works because we correctly referred to PI</pre>
<p class="mce-root">If any variable is not declared and then we try to use it, that variable will be initialized to an empty string.</p>
<p class="mce-root">The following command will convert a numeric value to a string representation. In our example, <kbd class="calibre17">$PI</kbd> is still a variable containing a number, but we could have created the <kbd class="calibre17">PI</kbd> variable like this as well:</p>
<pre class="calibre22">PI="3.14" # Notice the double quotes ""</pre>
<p class="mce-root">This would contain within the variable a string and not a numeric value such as <strong class="calibre6">an integer or float</strong>.</p>
<div class="packt_infobox">The concept of data types is not explored to its fullest in this cookbook. It is best left as a topic for the reader to explore, as it is a fundamental concept of programming and computer usage.</div>
<p class="mce-root">Wait! You say there is a difference between a number and a string? Absolutely, because without conversion (or being set correctly in the first place), this may limit the things you can do with it. For example, 3.14 is not the same as 3.14 (the number). 3.14 is made up of four characters: 3 + . + 1 +4. If we wanted to perform multiplication on our PI value in string form, either the calculation/script would break or we would get a nonsensical answer.</p>
<div class="packt_infobox">We will talk more about conversion later, in Chapter 2, <em class="calibre26">Acting like a Typewriter and File Explorer.</em></div>
<p class="mce-root">Let's say we want to assign one variable to another. We would do this like so:</p>
<pre class="calibre22">VAR_A=10<br class="calibre2"/>VAR_B=$VAR_A<br class="calibre2"/>VAR_C=${VAR_B}</pre>
<p class="mce-root">If the preceding snippet were within a functioning Bash script, we would get the value 10 for each variable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Hands-on variable assignment</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Open a new blank file and add the following to it:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/><br class="calibre2"/>PI=3.14<br class="calibre2"/>VAR_A=10<br class="calibre2"/>VAR_B=$VAR_A<br class="calibre2"/>VAR_C=${VAR_B}<br class="calibre2"/><br class="calibre2"/>echo "Let's print 3 variables:"<br class="calibre2"/>echo $VAR_A<br class="calibre2"/>echo $VAR_B<br class="calibre2"/>echo $VAR_C<br class="calibre2"/><br class="calibre2"/>echo "We know this will break:"<br class="calibre2"/>echo "0. The value of PI is $PIabc"     # since <span class="calibre11">PIabc is not declared, it will be empty string</span><br class="calibre2"/><br class="calibre2"/>echo "And these will work:"<br class="calibre2"/>echo "1. The value of PI is $PI"<br class="calibre2"/>echo "2. The value of PI is ${PI}"<br class="calibre2"/>echo "3. The value of PI is" $PI<br class="calibre2"/><br class="calibre2"/>echo "And we can make a new string"<br class="calibre2"/>STR_A="Bob"<br class="calibre2"/>STR_B="Jane"<br class="calibre2"/>echo "${STR_A} + ${STR_B} equals Bob + Jane"<br class="calibre2"/>STR_C=${STR_A}" + "${STR_B}<br class="calibre2"/>echo "${STR_C} is the same as Bob + Jane too!"<br class="calibre2"/>echo "${STR_C} + ${PI}"<br class="calibre2"/><br class="calibre2"/>exit 0</pre>
<div class="packt_tip">Notice the nomenclature. It is great to use a standardized mechanism to name variables, but to use <kbd class="calibre23">STR_A</kbd> and <kbd class="calibre23">VAR_B</kbd> is clearly not descriptive enough if used multiple times. In the future, we will use more descriptive names, such as <kbd class="calibre23">VAL_PI</kbd> to mean the value of PI or <kbd class="calibre23">STR_BOBNAME</kbd> to mean the string representing Bob's name. In Bash, capitalization is often used to describe variables, as it adds clarity.</div>
<p class="mce-root">Press <span class="calibre16">Save</span> and exit to a terminal (open one if one isn't already open). Execute your script after applying the appropriate permissions, and you should see the following output:</p>
<pre class="calibre22">Lets print 3 variables:<br class="calibre2"/>10<br class="calibre2"/>10<br class="calibre2"/>10<br class="calibre2"/>We know this will break:<br class="calibre2"/>0. The value of PI is <br class="calibre2"/>And these will work:<br class="calibre2"/>1. The value of PI is 3.14<br class="calibre2"/>2. The value of PI is 3.14<br class="calibre2"/>3. The value of PI is 3.14<br class="calibre2"/>And we can make a new string<br class="calibre2"/>Bob + Jane equals Bob + Jane<br class="calibre2"/>Bob + Jane is the same as Bob + Jane too!<br class="calibre2"/>Bob + Jane + 3.14</pre>
<p class="mce-root">First, we saw how we can use three variables, assign values to each of then, and print them. Secondly, we saw through a demonstration that the interpreter can break when concatenating strings (let's keep this in mind). Thirdly, we printed out our <kbd class="calibre17">PI</kbd> variable and concatenated it to a string using <kbd class="calibre17">echo</kbd>. Finally, we performed a few more types of concatenation, including a final version, which converts a numeric value and appends it to a string.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Hidden Bash variables and reserved words</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Wait—there are hidden variables and reserved words? Yes! There are words you can't use in your script unless properly contained in a construct such as a string. Global variables are available in a <strong class="calibre6">global context</strong>, which means that they are visible to all scripts in the current shell or open shell consoles. In a later chapter, we will explore global shell variables more, but just so you're aware, know that there are useful variables available for you to reuse, such as <kbd class="calibre17">$USER</kbd>, <kbd class="calibre17">$PWD</kbd>, <kbd class="calibre17">$OLDPWD</kbd>, and <kbd class="calibre17">$PATH</kbd>.</p>
<p class="mce-root">To see a list of all shell environment variables, you can use the <kbd class="calibre17">env</kbd><strong class="calibre6"> </strong>command (the output has been cut short):</p>
<pre class="calibre22">$ env<br class="calibre2"/>XDG_VTNR=7<br class="calibre2"/>XDG_SESSION_ID=c2<br class="calibre2"/>CLUTTER_IM_MODULE=xim<br class="calibre2"/>XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/rbrash<br class="calibre2"/>SESSION=ubuntu<br class="calibre2"/>SHELL=/bin/bash<br class="calibre2"/>TERM=xterm-256color<br class="calibre2"/>XDG_MENU_PREFIX=gnome-<br class="calibre2"/>VTE_VERSION=4205<br class="calibre2"/>QT_LINUX_ACCESSIBILITY_ALWAYS_ON=1<br class="calibre2"/>WINDOWID=81788934<br class="calibre2"/>UPSTART_SESSION=unix:abstract=/com/ubuntu/upstart-session/1000/1598<br class="calibre2"/>GNOME_KEYRING_CONTROL=<br class="calibre2"/>GTK_MODULES=gail:atk-bridge:unity-gtk-module<br class="calibre2"/>USER=rbrash<br class="calibre2"/>....</pre>
<div class="packt_infobox">Modifying the <kbd class="calibre23">PATH</kbd> environment variable can be very useful. It can also be frustrating, because it contains the filesystem path to binaries. For example, you have binaries in <kbd class="calibre23">/bin</kbd> or <kbd class="calibre23">/sbin</kbd> or <kbd class="calibre23">/usr/bin</kbd>, but when you run a single command, the command is run without you specifying the path.</div>
<p class="mce-root">Alright, so we have acknowledged the existence of pre-existing variables and that there could be new global variables created by the user or other programs. When using variables that have a high probability of being similarly named, be careful to make them specific to your application.</p>
<p class="mce-root">In addition to hidden variables, there are also words that are reserved for use within a script or shell. For example, if and else are words that are used to provide conditional logic to scripts. Imagine if you created a command, variable, or function (more later on this) with the same name as one that already exists? The script would likely break or run an erroneous operation.</p>
<div class="packt_tip">When trying to avoid any naming collisions (or namespace collisions), try to make your variables more likely to be used by your application by appending or prefixing an identifier that is likely to be unique.</div>
<p class="mce-root">The following list contains some of the more common reserved words that you will encounter. Some of which are likely to look very familiar because they tell the Bash interpreter to interpret any text in a specific way, redirect output, run an application in the background, or are even used in other programming/scripting languages.</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre17">if</kbd>, <kbd class="calibre17">elif</kbd>, <kbd class="calibre17">else</kbd>, <kbd class="calibre17">fi</kbd></li>
<li class="calibre14"><kbd class="calibre17">while</kbd>, <kbd class="calibre17">do</kbd>, <kbd class="calibre17">for</kbd>, <kbd class="calibre17">done</kbd>, <kbd class="calibre17">continue</kbd>, <kbd class="calibre17">break</kbd></li>
<li class="calibre14"><kbd class="calibre17">case</kbd>, <kbd class="calibre17">select</kbd>, <kbd class="calibre17">time</kbd></li>
<li class="calibre14"><kbd class="calibre17">function</kbd></li>
<li class="calibre14"><kbd class="calibre17">&amp;</kbd>, <kbd class="calibre17">|</kbd>, <kbd class="calibre17">&gt;</kbd>, <kbd class="calibre17">&lt;</kbd>, <kbd class="calibre17">!</kbd>, <kbd class="calibre17">=</kbd></li>
<li class="calibre14"><kbd class="calibre17">#</kbd>, <kbd class="calibre17">$</kbd>, <kbd class="calibre17">(, )</kbd>, <kbd class="calibre17">;</kbd>, <kbd class="calibre17">{, }</kbd>, <kbd class="calibre17">[, ]</kbd>, <kbd class="calibre17">\</kbd></li>
</ul>
<div class="packt_infobox">For the full reference, go to: <a href="https://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html</a>.</div>
<p class="mce-root">The last element in the list contains an array of specific characters that tell Bash to perform specific functionalities. The pound sign signifies a comment for example. However, the backslash <kbd class="calibre17">\</kbd><strong class="calibre6"> </strong>is very special because it is an <strong class="calibre6">escape character</strong>. Escape characters are used to <em class="calibre18">escape</em> or <em class="calibre18">stop</em> the interpreter from executing specific functionality when it sees those particular characters. For example:</p>
<pre class="calibre22">$ echo # Comment<br class="calibre2"/><br class="calibre2"/>$ echo \# Comment<br class="calibre2"/># Comment</pre>
<p class="mce-root">Escaping characters will become very useful in <a href="b71b7795-5b29-4a02-90a0-294283079dc8.xhtml" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 2</a>, <em class="calibre18">Acting like a Typewriter and File Explorer</em>, when working with strings and single/double quotes.</p>
<div class="packt_infobox">The escape character prevents the execution of the next character after the forward slash. However, this is not necessarily consistent when working with carriage returns (<kbd class="calibre23">\n</kbd>, <kbd class="calibre23">\r\n</kbd>) and null bytes (<kbd class="calibre23">\0</kbd>).</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Conditional logic using if, else, and elseif</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The previous section introduced the concept that there are several reserved words and a number of characters that have an effect on the operation of Bash. The most basic, and probably most widely used conditional logic is with <kbd class="calibre17">if</kbd> and <kbd class="calibre17">else</kbd> statements. Let's use an example code snippet:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>AGE=17<br class="calibre2"/>if [ ${AGE} -lt 18 ]; then<br class="calibre2"/> echo "You must be 18 or older to see this movie"<br class="calibre2"/>fi</pre>
<div class="packt_tip">Notice the space after or before the square brackets in the <kbd class="calibre23">if</kbd> statement. Bash is particularly picky about the syntax of bracketing.</div>
<p class="mce-root">If we are evaluating the variable <kbd class="calibre17">age</kbd> using less than (<kbd class="calibre17">&lt;</kbd>) or <kbd class="calibre17">-lt</kbd><span class="calibre16"> </span>(Bash offers a number of syntactical constructs for evaluating variables), we need to use an <kbd class="calibre17">if</kbd> statement. In our <kbd class="calibre17">if</kbd> statement, if <kbd class="calibre17">$AGE</kbd> is less than <kbd class="calibre17">18</kbd>, we echo the message <kbd class="calibre17">You must be 18 or older to see this movie</kbd>. Otherwise, the script will not execute the <kbd class="calibre17">echo</kbd> statement and will continue execution. Notice that the <kbd class="calibre17">if</kbd> statement ends with the reserved word <kbd class="calibre17">fi</kbd>. This is not a mistake and is required by Bash syntax.</p>
<p class="mce-root">Let's say we want to add a catchall using <kbd class="calibre17">else</kbd>. If the <kbd class="calibre17">then</kbd> command block of the <kbd class="calibre17">if</kbd> statement is not satisfied, then the <kbd class="calibre17">else</kbd> will be executed:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>AGE=40<br class="calibre2"/>if [ ${AGE} -lt 18 ]<br class="calibre2"/>then<br class="calibre2"/>    echo "You must be 18 or older to see this movie"<br class="calibre2"/>else<br class="calibre2"/>    echo "You may see the movie!"<br class="calibre2"/>    exit 1<br class="calibre2"/>fi</pre>
<p class="mce-root">With <kbd class="calibre17">AGE</kbd> set to the integer value <kbd class="calibre17">40</kbd>, the <kbd class="calibre17">then</kbd> command block inside the <kbd class="calibre17">if</kbd> statement will not be satisfied and the <kbd class="calibre17">else</kbd> command block will be executed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Evaluating binary numbers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's say we want to introduce another <kbd class="calibre17">if</kbd> condition and use <kbd class="calibre17">elif</kbd> (short for <em class="calibre18">else if</em>):</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>AGE=21<br class="calibre2"/>if [ ${AGE} -lt 18 ]; then<br class="calibre2"/> echo "You must be 18 or older to see this movie"<br class="calibre2"/>elif [ ${AGE} -eq 21 ]; then<br class="calibre2"/> echo "You may see the movie and get popcorn"<br class="calibre2"/>else<br class="calibre2"/> echo "You may see the movie!"<br class="calibre2"/> exit 1<br class="calibre2"/>fi<br class="calibre2"/><br class="calibre2"/>echo "This line might not get executed"</pre>
<p class="mce-root">If <kbd class="calibre17">AGE</kbd> is set and equals <kbd class="calibre17">21</kbd>, then the snippet will <kbd class="calibre17">echo</kbd>:</p>
<pre class="calibre22">You may see the movie and get popcorn<br class="calibre2"/>This line might not get executed</pre>
<p class="mce-root">Using <kbd class="calibre17">if</kbd>, <kbd class="calibre17">elif</kbd>, and <kbd class="calibre17">else</kbd>, combined with other evaluations, we can execute specific branches of logic and functions or even exit our script. To evaluate raw binary variables, use the following <strong class="calibre6">operators</strong>:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre17">-gt</kbd> (greater than &gt;)</li>
<li class="calibre14"><kbd class="calibre17">-ge</kbd> (greater or equal to &gt;=)</li>
<li class="calibre14"><kbd class="calibre17">-lt</kbd> (less than &lt;)</li>
<li class="calibre14"><kbd class="calibre17">-le</kbd> (less than or equal to &lt;=)</li>
<li class="calibre14"><kbd class="calibre17">-eq</kbd> (equal to)</li>
<li class="calibre14"><kbd class="calibre17">-nq</kbd> (not equal to)</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Evaluating strings</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As mentioned in the variables subsection, numeric values are different from strings. Strings are typically evaluated like this:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>MY_NAME="John"<br class="calibre2"/>NAME_1="Bob"<br class="calibre2"/>NAME_2="Jane"<br class="calibre2"/>NAME_3="Sue"<br class="calibre2"/>Name_4="Kate"<br class="calibre2"/><br class="calibre2"/>if [ "${MY_NAME}" == "Ron" ]; then<br class="calibre2"/>    echo "Ron is home from vacation"<br class="calibre2"/>elif [ "${MY_NAME}" != ${NAME_1}" &amp;&amp; "${MY_NAME}" != ${NAME_2}" &amp;&amp; "${MY_NAME}" == "John" ]; then<br class="calibre2"/>    echo "John is home after some unnecessary AND logic"<br class="calibre2"/>elif [ "${MY_NAME}" == ${NAME_3}" || "${MY_NAME}" == ${NAME_4}" ]; then<br class="calibre2"/>    echo "Looks like one of the ladies are home"<br class="calibre2"/>else<br class="calibre2"/>    echo "Who is this stranger?"<br class="calibre2"/>fi</pre>
<p class="mce-root">In the preceding snippet, you might notice that the <kbd class="calibre17">MY_NAME</kbd> variable will be executed and the string <kbd class="calibre17">John is home after some unnecessary AND logic</kbd> will be echoed to the console. In the snippet, the logic flows like this:</p>
<ol class="calibre20">
<li class="chapter">If <kbd class="calibre17">MY_NAME</kbd> is equal to <kbd class="calibre17">Ron</kbd>, then <kbd class="calibre17">echo "Ron is home from vacation"</kbd></li>
<li class="chapter">Else if <kbd class="calibre17">MY_NAME</kbd> is not equal to <kbd class="calibre17">NAME_1</kbd> <strong class="calibre3">AND</strong> <kbd class="calibre17">MY_NAME</kbd> is not equal to <kbd class="calibre17">NAME_2</kbd> <strong class="calibre3">AND</strong> <kbd class="calibre17">MY_NAME</kbd> is equal to <kbd class="calibre17">John</kbd>, then <kbd class="calibre17">echo "John is home after some unnecessary AND logic"</kbd></li>
<li class="chapter">Else if <kbd class="calibre17">MY_NAME</kbd> is equal to <kbd class="calibre17">NAME_3</kbd> <strong class="calibre3">OR</strong> <kbd class="calibre17">MY_NAME</kbd> is equal to <kbd class="calibre17">NAME_4</kbd>, then <kbd class="calibre17">echo "Looks like one of the ladies"</kbd></li>
<li class="chapter">Else <kbd class="calibre17">echo "Who is this stranger?"</kbd></li>
</ol>
<p class="mce-root">Notice the operators: <kbd class="calibre17">&amp;&amp;</kbd>, <kbd class="calibre17">||</kbd>, <kbd class="calibre17">==</kbd>, and <kbd class="calibre17">!=</kbd> </p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre17">&amp;&amp;</kbd> (means and)</li>
<li class="calibre14"><kbd class="calibre17">||</kbd> (means or)</li>
<li class="calibre14"><kbd class="calibre17">==</kbd> (is equal to)</li>
<li class="calibre14"><kbd class="calibre17">!=</kbd> (not equal to)</li>
<li class="calibre14"><kbd class="calibre17">-n</kbd> (is not null or is not set)</li>
<li class="calibre14"><kbd class="calibre17">-z</kbd> (is null and zero length)</li>
</ul>
<div class="packt_infobox">Null means not set or empty in the world of computing. There are many different types of operators or tests that can be used in your scripts. For more information, check out:<a href="http://tldp.org/LDP/abs/html/comparison-ops.html" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1"> http://tldp.org/LDP/abs/html/comparison-ops.html</a> and <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic</a></div>
<div class="packt_tip">You can also evaluate numbers as if they are strings using <kbd class="calibre23">(("$a" &gt; "$b"))</kbd> or <kbd class="calibre23">[[ "$a" &gt; "$b" ]]</kbd>. Notice the usage of double parentheses and square brackets.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Nested if statements</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If a single level of <kbd class="calibre17">if</kbd> statements is not enough and you would like to have additional logic within an <kbd class="calibre17">if</kbd> statement, you can create <strong class="calibre6">nested conditional statements</strong>. This can be done in the following way:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>USER_AGE=18<br class="calibre2"/>AGE_LIMIT=18<br class="calibre2"/>NAME="Bob" # Change to your username if you want to execute the nested logic<br class="calibre2"/>HAS_NIGHTMARES="true"<br class="calibre2"/><br class="calibre2"/>if [ "${USER}" == "${NAME}" ]; then<br class="calibre2"/>    if [ ${USER_AGE} -ge ${AGE_LIMIT} ]; then<br class="calibre2"/>        if [ "${HAS_NIGHTMARES}" == "true" ]; then<br class="calibre2"/>            echo "${USER} gets nightmares, and should not see the movie"<br class="calibre2"/>        fi<br class="calibre2"/>    fi<br class="calibre2"/>else<br class="calibre2"/>    echo "Who is this?"<br class="calibre2"/>fi</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Case/switch statements and loop constructs</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Besides <kbd class="calibre17">if</kbd> and <kbd class="calibre17">else</kbd> statements, Bash offers case or switch statements and loop constructs that can be used to simplify logic so that it is more readable and sustainable. Imagine creating an <kbd class="calibre17">if</kbd> statement with many <kbd class="calibre17">elif</kbd> evaluations. It would become cumbersome!</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>VAR=10<br class="calibre2"/><br class="calibre2"/># Multiple IF statements<br class="calibre2"/>if [ $VAR -eq 1 ]; then<br class="calibre2"/>    echo "$VAR"<br class="calibre2"/>elif [ $VAR -eq 2]; then<br class="calibre2"/>    echo "$VAR"<br class="calibre2"/>elif [ $VAR -eq 3]; then<br class="calibre2"/>    echo "$VAR"<br class="calibre2"/># .... to 10<br class="calibre2"/>else<br class="calibre2"/>    echo "I am not looking to match this value"<br class="calibre2"/>fi</pre>
<div class="packt_tip">In a large number of blocks of conditional logic of <kbd class="calibre23">if</kbd> and <kbd class="calibre23">elifs</kbd>, each <kbd class="calibre23">if</kbd> and <kbd class="calibre23">elif</kbd> needs to be evaluated before executing a specific branch of code. It can be faster to use a case/switch statement, because the first match will be executed (and it looks prettier).</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Basic case statement</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Instead of <kbd class="calibre17">if</kbd>/<kbd class="calibre17">else</kbd> statements, you can use <strong class="calibre6">case statements</strong><span class="calibre16"> </span>to evaluate a variable. Notice that <kbd class="calibre17">esac</kbd> is case backwards and is used to exit the case statement similar to <kbd class="calibre17">fi</kbd> for <kbd class="calibre17">if</kbd> statements.</p>
<p class="mce-root">Case statements follow this flow:</p>
<pre class="calibre22">case $THING_I_AM_TO_EVALUATE in
  1) # Condition to evaluate is number 1 (could be "a" for a string too!)<br class="calibre2"/>    echo "THING_I_AM_TO_EVALUATE equals 1"<br class="calibre2"/>    ;; # Notice that this is used to close this evaluation<br class="calibre2"/>  *) # * Signified the catchall (when THING_I_AM_TO_EVALUATE does not equal values in the switch)<br class="calibre2"/>    echo "FALLTHOUGH or default condition"<br class="calibre2"/>esac # Close case statement</pre>
<p class="mce-root">The following is a working example:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>VAR=10 # Edit to 1 or 2 and re-run, after running the script as is.<br class="calibre2"/>case $VAR in
  1)<br class="calibre2"/>    echo "1"<br class="calibre2"/>    ;;<br class="calibre2"/>  2)<br class="calibre2"/>    echo "2"<br class="calibre2"/>    ;;<br class="calibre2"/>  *)<br class="calibre2"/>    echo "What is this var?"<br class="calibre2"/>    exit 1
esac</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Basic loops</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Can you imagine iterating through a list of files or a dynamic array and monotonously evaluating each and every one? Or waiting until a condition was true? For these types of scenarios, you may want to use a <strong class="calibre6">for loop, a do while loop, or an until loop </strong>to improve your script and make things easy. For loops, do while loops, and until loops may seem similar, but there are subtle differences between them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">For loop</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre17">for</kbd> loop is usually used when you have multiple tasks or commands to execute for each of the entries in an array or <em class="calibre18">want to execute a given command on a finite number of items</em>. In this example, we have an array (or list) containing three elements: <kbd class="calibre17">file1</kbd>, <kbd class="calibre17">file2</kbd>, and <kbd class="calibre17">file3</kbd>. The <kbd class="calibre17">for</kbd> loop will <kbd class="calibre17">echo</kbd> each element within <kbd class="calibre17">FILES</kbd> and exit the script:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/><br class="calibre2"/>FILES=( "file1" "file2" "file3" )<br class="calibre2"/>for ELEMENT in ${FILES[@]}<br class="calibre2"/>do<br class="calibre2"/>        echo "${ELEMENT}"<br class="calibre2"/>done<br class="calibre2"/><br class="calibre2"/>echo "Echo\'d all the files" </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Do while loop</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">As an alternative, we have included the <kbd class="calibre17">do while</kbd> loop. It is similar to a <kbd class="calibre17">for</kbd> loop, but better suited to <em class="calibre18">dynamic conditions</em>, such as when you do not know when a value will be returned or performing a task until a condition is met. The condition within the square brackets is the same as an <em class="calibre18">if</em> statement:</span></p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>CTR=1<br class="calibre2"/>while [ ${CTR} -lt 9 ]<br class="calibre2"/>do<br class="calibre2"/>    echo "CTR var: ${CTR}"<br class="calibre2"/>    ((CTR++)) # Increment the CTR variable by 1<br class="calibre2"/>done<br class="calibre2"/>echo "Finished"</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Until loop</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For completeness, we have included the <kbd class="calibre17">until</kbd> loop. It is not used very often and is almost the same as a <kbd class="calibre17">do while</kbd> loop. Notice that its condition and operation is consistent with incrementing a counter <kbd class="calibre17">until</kbd> a value is reached:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>CTR=1<br class="calibre2"/>until [ ${CTR} -gt 9 ]<br class="calibre2"/>do<br class="calibre2"/>    echo "CTR var: ${CTR}"<br class="calibre2"/>    ((CTR++)) # Increment the CTR variable by 1<br class="calibre2"/>done<br class="calibre2"/>echo "Finished"</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using functions and parameters</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">So far in the book, we have mentioned that function is a reserved word and only used in Bash scripts that are in a single procedure, but what is a function?</p>
<p class="mce-root">To illustrate what a function is, first we need to define what a function is—a<strong class="calibre6"> function</strong> is a self-contained section of code that performs a single task. However, a function performing a task may also execute many subtasks in order to complete its main task.</p>
<p class="mce-root">For example, you could have a function called <kbd class="calibre17">file_creator</kbd> that performs the following tasks:</p>
<ol class="calibre20">
<li class="chapter">Check to see whether a file exists.</li>
<li class="chapter">If the file exists, truncate it. Otherwise, create a new one.</li>
<li class="chapter">Apply the correct permissions. </li>
</ol>
<p class="mce-root">A function can also be passed parameters. <strong class="calibre6">Parameters</strong> are like variables that can be set outside of a function and then used within the function itself. This is really useful because we can create segments of code that perform generic tasks that are reusable by other scripts or even within loops themselves. You may also have <strong class="calibre6">local </strong>variables that are not accessible outside of a function and for usage only within the function itself. So what does a function look like?</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>function my_function() {<br class="calibre2"/>    local PARAM_1="$1"<br class="calibre2"/>    <span class="calibre11">local PARAM_2="$2"<br class="calibre2"/></span><span class="calibre11">    local PARAM_3="$3"<br class="calibre2"/></span>    echo "${<span class="calibre11">PARAM_1} ${PARAM_2} ${PARAM_3}"<br class="calibre2"/></span>}<br class="calibre2"/>my_function "a" "b" "c"</pre>
<p class="mce-root">As we can see in the simple script, there is a function declared as <kbd class="calibre17">my_function</kbd> using the <kbd class="calibre17">function</kbd><strong class="calibre6"> </strong>reserved word. The content of the function is contained within the squiggly brackets <kbd class="calibre17">{}</kbd> and introduces three new concepts:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Parameters</strong> are referred to systematically like this: <kbd class="calibre17">$1</kbd> for parameter 1, <kbd class="calibre17">$2</kbd> for parameter 2, <kbd class="calibre17">$3</kbd> for parameter 3, and so on</li>
<li class="calibre14">The <kbd class="calibre17">local</kbd> keyword refers to the fact that variables <em class="calibre26">declared</em><strong class="calibre3"> </strong>with this keyword remain accessible only within this function</li>
<li class="calibre14">We can call functions merely by name and use parameters simply by adding them, as in the preceding example</li>
</ul>
<p class="mce-root">In the next section, we'll dive into a more realistic example that should drive the point home a bit more: functions are helpful everyday and make functionality from any section easily reusable where appropriate.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using a function with parameters within a for loop</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this short example, we have a function called <kbd class="calibre17">create_file</kbd>, which is called within a loop for each file in the <kbd class="calibre17">FILES</kbd> array. The function creates a file, modifies its permissions, and then passively checks for its existence using the <kbd class="calibre17">ls</kbd> command:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>FILES=( "file1" "file2" "file3" ) # This is a global variable<br class="calibre2"/><br class="calibre2"/>function create_file() {<br class="calibre2"/>    local FNAME="${1}" # First parameter<br class="calibre2"/>    local PERMISSIONS="${2}" # Second parameter<br class="calibre2"/>    touch "${FNAME}"<br class="calibre2"/>    chmod "${PERMISSIONS}" "${FNAME}"<br class="calibre2"/>    ls -l "${FNAME}"<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>for ELEMENT in ${FILES[@]}<br class="calibre2"/>do<br class="calibre2"/>        create_file "${ELEMENT}" "a+x"<br class="calibre2"/>done<br class="calibre2"/><br class="calibre2"/>echo "Created all the files with a function!"<br class="calibre2"/>exit 0</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Including source files</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In addition to functions, we can also create multiple scripts and include them such that we can utilize any shared variables of functions.</p>
<p class="mce-root">Let's say we have a library or utility script that contains a number of functions useful for creating files. This script by itself could be useful or <strong class="calibre6">reusable </strong>for a number of scripting tasks, so we make it program neutral. Then, we have another script, but this one is dedicated to a single task: performing useless file system operations (IO). In this case, we would have two files:</p>
<ol class="calibre20">
<li class="chapter"><kbd class="calibre17">io_maker.sh</kbd> (which includes <kbd class="calibre17">library.sh</kbd> and uses <kbd class="calibre17">library.sh</kbd> functions)</li>
<li class="chapter"><kbd class="calibre17">library.sh</kbd> (which contains declared functions, but does not execute them)</li>
</ol>
<p class="mce-root">The <kbd class="calibre17">io_maker.sh</kbd> script simply imports or includes the <kbd class="calibre17">library.sh</kbd> script and inherits knowledge of any global variables, functions, and other inclusions. In this manner, <kbd class="calibre17">io_maker.sh</kbd> effectively thinks that these other available functions are its own and can execute them as if they were contained within it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Including/importing a library script and using external functions</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To prepare for this example, create the following two files and open both:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre17">io_maker.sh</kbd></li>
<li class="calibre14"><kbd class="calibre17">library.sh</kbd></li>
</ul>
<p class="mce-root">Inside <kbd class="calibre17">library.sh</kbd>, add the following:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/><br class="calibre2"/>function create_file() {<br class="calibre2"/>    local FNAME=$1<br class="calibre2"/>    touch "${FNAME}"<br class="calibre2"/>    ls "${FNAME}" # If output doesn't return a value - file is missing<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>function delete_file() {<br class="calibre2"/>    local FNAME=$1<br class="calibre2"/>    rm "${FNAME}"<br class="calibre2"/>    ls "${FNAME}" # If output doesn't return a value - file is missing<br class="calibre2"/>}</pre>
<p class="mce-root">Inside <kbd class="calibre17">io_maker.sh</kbd>, add the following:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/><br class="calibre2"/>source library.sh # You may need to include the path as it is relative<br class="calibre2"/>FNAME="my_test_file.txt"<br class="calibre2"/>create_file "${FNAME}"<br class="calibre2"/>delete_file "${FNAME}"<br class="calibre2"/><br class="calibre2"/>exit 0</pre>
<p class="mce-root">When you run the script, you should get the same output:</p>
<pre class="calibre22">$ bash io_maker.sh<br class="calibre2"/>my_test_file.txt<br class="calibre2"/>ls: cannot access 'my_test_file.txt': No such file or directory</pre>
<p class="mce-root">Although not obvious, we can see that both functions are executed. The first line of output is the <kbd class="calibre17">ls</kbd><strong class="calibre6"> </strong>command, successfully finding <kbd class="calibre17">my_test_file.txt</kbd> after creating the file in <kbd class="calibre17">create_file()</kbd>. In the second line, we can see that ls returns an error when we delete the file passed in as a parameter. </p>
<p class="mce-root">Unfortunately, up until now, we have only been able to create and call functions, and execute commands. The next step, discussed in the next section, is to retrieve commands and function return codes or strings.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Retrieving return codes and output</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Up until now, we have been using a command called <kbd class="calibre17">exit</kbd> intermittently to exit scripts. For those of you who are curious, you may have already scoured the web to find out what this command does, but the key concept to remember is that <em class="calibre18">every</em> script, command, or binary exits with a <em class="calibre18">return code</em>. Return codes are numeric and are limited to being between<strong class="calibre6"> </strong>0-255 because an unsigned 8-bit integer is used. If you use a value of <kbd class="calibre17">-1</kbd>, it will return <kbd class="calibre17">255</kbd>.</p>
<p class="mce-root">Okay, so return codes are useful in which ways? Return codes are useful when you want to know whether you found a match when performing a match (for example), and whether the command was completely successfully or there was an error. Let's dig into a real example using the <kbd class="calibre17">ls</kbd> command on the console:</p>
<pre class="calibre22">$ ls ~/this.file.no.exist<br class="calibre2"/>ls: cannot access '/home/rbrash/this.file.no.exist': No such file or directory<br class="calibre2"/>$ echo $?<br class="calibre2"/>2<br class="calibre2"/>$ ls ~/.bashrc <br class="calibre2"/>/home/rbrash/.bashrc<br class="calibre2"/>$ echo $?<br class="calibre2"/>0</pre>
<p class="mce-root">Notice the return values? <kbd class="calibre17">0</kbd> or <kbd class="calibre17">2</kbd> in this example mean either success (0) or that there are errors (1 and 2). These are obtained by retrieving the <kbd class="calibre17">$?</kbd> variable and we could even set it to a variable like this:</p>
<pre class="calibre22">$ ls ~/this.file.no.exist<br class="calibre2"/>ls: cannot access '/home/rbrash/this.file.no.exist': No such file or directory<br class="calibre2"/>$ TEST=$?<br class="calibre2"/>$ echo $TEST<br class="calibre2"/>2</pre>
<p class="mce-root">From this example, we now know what return codes are, and how we can use them to utilize results returned from functions, scripts, and commands.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Return code 101</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Dig into your terminal and create the following Bash script:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/>GLOBAL_RET=255<br class="calibre2"/><br class="calibre2"/>function my_function_global() {<br class="calibre2"/>    ls /home/${USER}/.bashrc<br class="calibre2"/>    GLOBAL_RET=$?<br class="calibre2"/>}<br class="calibre2"/>function my_function_return() {<br class="calibre2"/>    ls /home/${USER}/.bashrc<br class="calibre2"/>    return $?<br class="calibre2"/>}<br class="calibre2"/>function my_function_str() {<br class="calibre2"/>    local UNAME=$1<br class="calibre2"/>    local OUTPUT=""<br class="calibre2"/>    if [ -e /home/${UNAME}/.bashrc ]; then<br class="calibre2"/>        OUTPUT='FOUND IT'<br class="calibre2"/>    else<br class="calibre2"/>        OUTPUT='NOT FOUND'<br class="calibre2"/>    fi<br class="calibre2"/>    echo ${OUTPUT}<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>echo "Current ret: ${GLOBAL_RET}"<br class="calibre2"/>my_function_global "${USER}"<br class="calibre2"/>echo "Current ret after: ${GLOBAL_RET}"<br class="calibre2"/>GLOBAL_RET=255<br class="calibre2"/>echo "Current ret: ${GLOBAL_RET}"<br class="calibre2"/>my_function_return "${USER}"<br class="calibre2"/>GLOBAL_RET=$?<br class="calibre2"/>echo "Current ret after: ${GLOBAL_RET}"<br class="calibre2"/><br class="calibre2"/># And for giggles, we can pass back output too!<br class="calibre2"/>GLOBAL_RET=""<br class="calibre2"/>echo "Current ret: ${GLOBAL_RET}"<br class="calibre2"/>GLOBAL_RET=$(my_function_str ${USER})<br class="calibre2"/># You could also use GLOBAL_RET=`my_function_str ${USER}`<br class="calibre2"/># Notice the back ticks "`"<br class="calibre2"/>echo "Current ret after: $GLOBAL_RET"<br class="calibre2"/>exit 0</pre>
<p class="mce-root">The script will output the following before exiting with a return code of <kbd class="calibre17">0</kbd> (remember that ls returns <kbd class="calibre17">0</kbd> if run successfully):</p>
<pre class="calibre22">rbrash@moon:~$ bash test.sh<br class="calibre2"/>Current ret: 255<br class="calibre2"/>/home/rbrash/.bashrc<br class="calibre2"/>Current ret after: 0<br class="calibre2"/>Current ret: 255<br class="calibre2"/>/home/rbrash/.bashrc<br class="calibre2"/>Current ret after: 0<br class="calibre2"/>Current ret: <br class="calibre2"/>Current ret after: FOUND IT<br class="calibre2"/>$</pre>
<p class="mce-root">In this section, there are three functions that leverage three concepts:</p>
<ol class="calibre20">
<li class="chapter"><kbd class="calibre17">my_function_global</kbd> uses a <kbd class="calibre17">global</kbd><strong class="calibre3"> </strong>variable to return the command's return code</li>
<li class="chapter"><kbd class="calibre17">my_function_return</kbd> uses the reserved word, <kbd class="calibre17">return</kbd><strong class="calibre3">, </strong>and a value (the command's return code)</li>
<li class="chapter"><kbd class="calibre17">my_function_str</kbd> uses a<span class="calibre11"> </span><kbd class="calibre17">fork</kbd><span class="calibre11"> </span>(a special operation) to execute a command and get the output (our string, which is echoed)</li>
</ol>
<div class="packt_tip">For option 3, there are several ways to get a string back from a function, including using the <kbd class="calibre23">eval</kbd><strong class="calibre3"> </strong>keyword. However, when using fork, it is best to be aware of the resources it may consume when running the same command many times just to get the output.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Linking commands, pipes, and input/output</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This section is probably one of the most important in the book because it describes a fundamental and powerful feature on Linux and Unix: the ability to use pipes and redirect input or output. By themselves, pipes are a fairly trivial feature - commands and scripts can redirect their output to files or commands. So what? This could be considered a massive understatement in the Bash scripting world, because pipes and redirection allow you to enhance commands with the functionality of other commands or features. </p>
<p class="mce-root">Let's look into this with an example using commands called <kbd class="calibre17">tail</kbd> and <kbd class="calibre17">grep</kbd>. In this example, the user, Bob, wants to look at his logs in real time (live), but he only wants to find the entries related to the wireless interface. The name of Bob's wireless device can be found using the <kbd class="calibre17">iwconfig</kbd><strong class="calibre6"> </strong>command:</p>
<pre class="calibre22">$ iwconfig<br class="calibre2"/><strong class="calibre3">wlp3s0</strong> IEEE 802.11abgn ESSID:"127.0.0.1-2.4ghz" <br class="calibre2"/>          Mode:Managed Frequency:2.412 GHz Access Point: 18:D6:C7:FA:26:B1 <br class="calibre2"/>          Bit Rate=144.4 Mb/s Tx-Power=22 dBm <br class="calibre2"/>          Retry short limit:7 RTS thr:off Fragment thr:off<br class="calibre2"/>          Power Management:on<br class="calibre2"/>          Link Quality=58/70 Signal level=-52 dBm <br class="calibre2"/>          Rx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0<br class="calibre2"/>          Tx excessive retries:0 Invalid misc:90 Missed beacon:0<br class="calibre2"/><br class="calibre2"/></pre>
<p class="mce-root">The <kbd class="calibre17">iwconfig</kbd> command is deprecated now. The following commands also will give you wireless interface information:</p>
<pre class="calibre22">$ iw dev                # This will give list of wireless interfaces<br class="calibre2"/>$ iw dev wlp3s0 link    # This will give detailed information about particular wireless interface</pre>
<p class="mce-root">Now that Bob knows his wireless card's identifying name (<kbd class="calibre17">wlp3s0</kbd>), Bob can search his system's logs. It is usually found within <kbd class="calibre17">/var/log/messages</kbd>. Using the <kbd class="calibre17">tail</kbd><strong class="calibre6"> </strong>command and the <kbd class="calibre17">-F</kbd> flag, which allows continuously outputting the logs to the console, Bob can now see <em class="calibre18">all</em> the logs for his system. Unfortunately, he would like to filter the logs using <kbd class="calibre17">grep</kbd>, such that only logs with the keyword <kbd class="calibre17">wlp3s0</kbd><strong class="calibre6"> </strong>are visible.</p>
<p class="mce-root"/>
<p class="mce-root">Bob is faced with a choice: does he search the file continuously, or can he combine <kbd class="calibre17">tail</kbd> and <kbd class="calibre17">grep</kbd> together to get the results he desires? The answer is yes—using <em class="calibre18">pipes</em>!</p>
<pre class="calibre22">$ tail -F /var/log/messages | grep wlp3s0<br class="calibre2"/>Nov 10 11:57:13 moon kernel: <strong class="calibre3">wlp3s0</strong>: authenticate with 18:d6:c7:fa:26:b1<br class="calibre2"/>Nov 10 11:57:13 moon kernel: <strong class="calibre3">wlp3s0</strong>: send auth to 18:d6:c7:fa:26:b1 (try 1/3)<br class="calibre2"/>Nov 10 11:57:13 moon kernel: <strong class="calibre3">wlp3s0</strong>: send auth to 18:d6:c7:fa:26:b1 (try 2/3)<br class="calibre2"/>...</pre>
<p class="mce-root">As new logs come in, Bob can now monitor them in real time and can stop the console output using <em class="calibre18">Ctrl</em>+<em class="calibre18">C</em>.</p>
<div class="packt_tip">Using pipes, we can combine commands into powerful hybrid commands, extending the best features of each command into one single line. Remember pipes!</div>
<p class="mce-root">The usage and flexibility of pipes should be relatively straightforward, but what about directing the input and output of commands? This requires the introduction of three commands to get information from one place to another:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre17">stdin</kbd> (standard in)</li>
<li class="calibre14"><kbd class="calibre17">stdout</kbd> (standard out)</li>
<li class="calibre14"><kbd class="calibre17">stderr</kbd> (standard error)</li>
</ul>
<p class="mce-root">If we are thinking about a <em class="calibre18">single</em> program, <kbd class="calibre17">stdin</kbd> is anything that can be provided to it, usually either as a parameter or a user input, <strong class="calibre6">using read </strong>for example. <kbd class="calibre17">Stdout</kbd> and <kbd class="calibre17">stderr</kbd> are two <strong class="calibre6">streams</strong> where output can be sent. Usually, output for both is sent to the console for display, but what if you only want the errors within the <kbd class="calibre17">stderr</kbd> stream to go to a file?</p>
<pre class="calibre22">$ ls /filethatdoesntexist.txt 2&gt; err.txt<br class="calibre2"/>$ ls ~/ &gt; stdout.txt<br class="calibre2"/>$ ls ~/<span class="calibre11"> </span><span class="calibre11">&gt; everything.txt </span><span class="calibre11">2&gt;&amp;1 # Gets stderr and stdout<br class="calibre2"/></span>$ ls ~/<span class="calibre11"> </span><span class="calibre11">&gt;&gt; everything.txt </span><span class="calibre11">2&gt;&amp;1 # Gets stderr and stdout</span><br class="calibre2"/>$ cat err.txt<br class="calibre2"/>ls: cannot access '/filethatdoesntexist.txt': No such file or directory<br class="calibre2"/>$ cat stdout.txt<br class="calibre2"/>.... # A whole bunch of files in your home directory</pre>
<p class="mce-root"/>
<p class="mce-root">When we <kbd class="calibre17">cat err.txt</kbd>, we can see the error output from the stderr stream. This is useful when you only want to record errors and not everything being output to the console. The key feature to observe from the snippet is the usage of <strong class="calibre6">&gt;, </strong><strong class="calibre6">2&gt;,</strong> and <strong class="calibre6">2&gt;&amp;1</strong>. With the arrows we can redirect the output to any file or even to other programs!</p>
<div class="packt_infobox">Take note of the difference between a single <kbd class="calibre23">&gt;</kbd> and double <kbd class="calibre23">&gt;&gt;</kbd>. A single <kbd class="calibre23">&gt;</kbd> <strong class="calibre3">will truncate</strong> any file that will have output directed to it, while <kbd class="calibre23">&gt;&gt;</kbd> <strong class="calibre3">will append</strong> any file.</div>
<div class="packt_tip">There is a common error when redirecting both <kbd class="calibre23">stderr</kbd> and <kbd class="calibre23">stdout</kbd> to the same file. Bash should pick up the output to a file first, and then the duplication of the output file descriptors. For more information on file descriptors, see: <a href="https://en.wikipedia.org/wiki/File_descriptor" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://en.wikipedia.org/wiki/File_descriptor<br class="calibre2"/></a><kbd class="calibre23"># This is correct</kbd><br class="calibre2"/>
<kbd class="calibre23">ls ~/ &gt; everything.txt 2&gt;&amp;1</kbd><br class="calibre2"/>
<kbd class="calibre23"># This is erronous</kbd><br class="calibre2"/>
<kbd class="calibre23">ls ~/ 2&gt;&amp;1&gt; everything.txt</kbd><span class="calibre11"><br class="calibre2"/>
<br class="calibre2"/></span></div>
<p class="mce-root">Now that we know the basics of one of the most powerful features available in Bash, let's try an example—redirection and pipes bonzanza.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Redirection and pipe bonzanza</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Open a shell and create a new bash file in your favorite editor:</p>
<pre class="calibre22">#!/bin/sh<br class="calibre2"/><br class="calibre2"/># Let's run a command and send all of the output to /dev/null<br class="calibre2"/>echo "No output?"<br class="calibre2"/>ls ~/fakefile.txt &gt; /dev/null 2&gt;&amp;1<br class="calibre2"/><br class="calibre2"/># Retrieve output from a piped command <br class="calibre2"/>echo "part 1"<br class="calibre2"/>HISTORY_TEXT=`cat ~/.bashrc | grep HIST`<br class="calibre2"/>echo "${HISTORY_TEXT}"<br class="calibre2"/><br class="calibre2"/># Output the results to history.config<br class="calibre2"/>echo "part 2"<br class="calibre2"/>echo "${HISTORY_TEXT}" &gt; "history.config"<br class="calibre2"/><br class="calibre2"/># Re-direct history.config as input to the cat command<br class="calibre2"/>cat &lt; history.config<br class="calibre2"/><br class="calibre2"/># Append a string to history.config<br class="calibre2"/>echo "MY_VAR=1" &gt;&gt; history.config<br class="calibre2"/><br class="calibre2"/>echo "part 3 - using Tee"<br class="calibre2"/># Neato.txt will contain the same information as the console<br class="calibre2"/>ls -la ~/fakefile.txt ~/ 2&gt;&amp;1 | tee neato.txt</pre>
<p class="mce-root">First, <kbd class="calibre17">ls</kbd> is a way of producing an error and, instead of pushing erroneous output to the console, it is instead redirected to a special device in Linux called <kbd class="calibre17">/dev/null</kbd>. <kbd class="calibre17">/dev/null</kbd> is particularly useful as it is a dump for any input that will not be used again. Then, we combine the <kbd class="calibre17">cat</kbd><strong class="calibre6"> </strong>command with <kbd class="calibre17">grep</kbd><strong class="calibre6"> </strong>to find any lines of text with a pipe and use a fork to capture the output to a variable (<kbd class="calibre17">HISTORY_TEXT</kbd>).</p>
<p class="mce-root">Then, we echo the contents of <span class="calibre16"><kbd class="calibre17">HISTORY_TEXT</kbd> to a file (</span><kbd class="calibre17">history.config</kbd>) <span class="calibre16">using a <kbd class="calibre17">stdout</kbd> redirect. Using the <kbd class="calibre17">history.config</kbd>file, we redirect cat to use the raw file—this will be displayed on the console.</span></p>
<p class="mce-root">Using a double <kbd class="calibre17">&gt;&gt;</kbd>, we append an arbitrary string to the <kbd class="calibre17">history.config</kbd> file.</p>
<p class="mce-root">Finally, we end the script with redirection for both <kbd class="calibre17">stdout</kbd> and <kbd class="calibre17">stderr,</kbd> a <kbd class="calibre17">pipe,</kbd>, and the <kbd class="calibre17">tee</kbd><strong class="calibre6"> </strong>command. The <kbd class="calibre17">tee</kbd><strong class="calibre6"> </strong>command is useful because it can be used to display content even if it has been redirected to a file (as we just demonstrated).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting program input parameters </h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Retrieving program input parameters or arguments is very similar to function parameters at the most basic level. They can be accessed in the same fashion as <kbd class="calibre17">$1 (arg1)</kbd>, <kbd class="calibre17">$2 (arg2)</kbd>, <kbd class="calibre17">$3 (arg3)</kbd>, and so on. However, so far, we have seen a concept called <strong class="calibre6">flags</strong>, which allows you to perform neat things such as<kbd class="calibre17">-l</kbd>, <kbd class="calibre17">--long-version</kbd>, <kbd class="calibre17">-v 10</kbd>, <kbd class="calibre17">--verbosity=10</kbd>. <strong class="calibre6">Flags</strong> are effectively a user-friendly way to pass parameters or arguments to a program at runtime. For example:</p>
<pre class="calibre22">bash myProgram.sh -v 99 --name=Ron -l Brash</pre>
<p class="mce-root">Now that you know what flags are and how they can be helpful to improve your script, use the following section as a template.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Passing your program flags</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">After going into your shell and opening a new file in your favorite editor, let's get started by creating a Bash script that does the following:</p>
<ul class="calibre13">
<li class="calibre14">When no flags or arguments are specified, prints out a help message</li>
<li class="calibre14">When either the <kbd class="calibre17">-h</kbd> or <kbd class="calibre17">--help</kbd> flags are set, it prints out a help message</li>
<li class="calibre14">When the <kbd class="calibre17">-f</kbd> or <kbd class="calibre17">--firstname</kbd> flags are set, it sets the the first name variable</li>
<li class="calibre14">When the <kbd class="calibre17">-l</kbd> or <kbd class="calibre17">--lastname</kbd> flags are set, it sets the the last name variable</li>
<li class="calibre14">When <em class="calibre26">both</em> the <kbd class="calibre17">firstname</kbd> and <kbd class="calibre17">lastname</kbd> flags are set, it prints a welcome message and returns without error</li>
</ul>
<p class="mce-root">In addition to the basic logic, we can see that the code leverages a piece of functionality called <kbd class="calibre17">getopts</kbd>.<strong class="calibre6"> </strong>Getopts allows us to grab the program parameter flags for use within our program. There are also primitives, which we have learned as well—conditional logic, while loop, and case/switch statements. Once a script develops into more than a simple utility or provides more than a single function, the more basic Bash constructs will become commonplace.</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/><br class="calibre2"/>HELP_STR="usage: $0 [-h] [-f] [-l] [--firstname[=]&lt;value&gt;] [--lastname[=]&lt;value] [--help]"<br class="calibre2"/><br class="calibre2"/># Notice hidden variables and other built-in Bash functionality<br class="calibre2"/>optspec=":flh-:"<br class="calibre2"/>while getopts "$optspec" optchar; do<br class="calibre2"/>    case "${optchar}" in<br class="calibre2"/>        -)<br class="calibre2"/>            case "${OPTARG}" in<br class="calibre2"/>                firstname)<br class="calibre2"/>                    val="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))<br class="calibre2"/>                    FIRSTNAME="${val}"<br class="calibre2"/>                    ;;<br class="calibre2"/>                lastname)<br class="calibre2"/>                    val="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))<br class="calibre2"/>                        LASTNAME="${val}"<br class="calibre2"/>                    ;;<br class="calibre2"/>                help)<br class="calibre2"/>                    val="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))<br class="calibre2"/>                    ;;<br class="calibre2"/>                *)<br class="calibre2"/>                    if [ "$OPTERR" = 1 ] &amp;&amp; [ "${optspec:0:1}" != ":" ]; then<br class="calibre2"/>                        echo "Found an unknown option --${OPTARG}" &gt;&amp;2<br class="calibre2"/>                    fi<br class="calibre2"/>                    ;;<br class="calibre2"/>            esac;;<br class="calibre2"/>        f)<br class="calibre2"/>                val="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))<br class="calibre2"/>                FIRSTNAME="${val}"<br class="calibre2"/>                ;;<br class="calibre2"/>        l)<br class="calibre2"/>                val="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))<br class="calibre2"/>                LASTNAME="${val}"<br class="calibre2"/>                ;;<br class="calibre2"/>        h)<br class="calibre2"/>            echo "${HELP_STR}" &gt;&amp;2<br class="calibre2"/>            exit 2<br class="calibre2"/>            ;;<br class="calibre2"/>        *)<br class="calibre2"/>            if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" = ":" ]; then<br class="calibre2"/>                echo "Error parsing short flag: '-${OPTARG}'" &gt;&amp;2<br class="calibre2"/>                exit 1<br class="calibre2"/>            fi<br class="calibre2"/><br class="calibre2"/>            ;;<br class="calibre2"/>    esac<br class="calibre2"/>done<br class="calibre2"/><br class="calibre2"/># Do we have even one argument?<br class="calibre2"/>if [ -z "$1" ]; then<br class="calibre2"/>  echo "${HELP_STR}" &gt;&amp;2<br class="calibre2"/>  exit 2<br class="calibre2"/>fi<br class="calibre2"/><br class="calibre2"/># Sanity check for both Firstname and Lastname<br class="calibre2"/>if [ -z "${FIRSTNAME}" ] || [ -z "${LASTNAME}" ]; then<br class="calibre2"/>  echo "Both firstname and lastname are required!"<br class="calibre2"/>  exit 3<br class="calibre2"/>fi<br class="calibre2"/><br class="calibre2"/>echo "Welcome ${FIRSTNAME} ${LASTNAME}!"<br class="calibre2"/><br class="calibre2"/>exit 0</pre>
<p class="mce-root">When we execute the preceding program, we should expect responses similar to the following:</p>
<pre class="calibre22">$ bash flags.sh <br class="calibre2"/>usage: flags.sh [-h] [-f] [-l] [--firstname[=]&lt;value&gt;] [--lastname[=]&lt;value] [--help]<br class="calibre2"/>$ bash flags.sh -h<br class="calibre2"/>usage: flags.sh [-h] [-f] [-l] [--firstname[=]&lt;value&gt;] [--lastname[=]&lt;value] [--help]<br class="calibre2"/>$ bash flags.sh --fname Bob<br class="calibre2"/>Both firstname and lastname are required!<br class="calibre2"/>rbrash@moon:~$ bash flags.sh --firstname To -l Mater<br class="calibre2"/>Welcome To Mater!</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting additional information about commands</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As we progress, you may see this book use many commands extensively and without exhaustive explanations. Without polluting this entire book with an introduction to Linux and useful commands, there are a couple of commands available that are really handy: <kbd class="calibre17">man</kbd><strong class="calibre6"> </strong>and <kbd class="calibre17">info</kbd>.</p>
<p class="mce-root">The <kbd class="calibre17">man</kbd> command, or manual command, is quite extensive and even has multiple sections when the same entry exists in different categories. For the purposes of investigating <span class="calibre16">executable programs or shell commands, category 1 is sufficient. Let's look at the entry for the mount command:</span></p>
<pre class="calibre22">$ man mount<br class="calibre2"/>... <br class="calibre2"/>MOUNT(8) System Administration MOUNT(8)<br class="calibre2"/>NAME<br class="calibre2"/> mount - mount a filesystem<br class="calibre2"/>SYNOPSIS<br class="calibre2"/> mount [-l|-h|-V]<br class="calibre2"/> mount -a [-fFnrsvw] [-t fstype] [-O optlist]<br class="calibre2"/> mount [-fnrsvw] [-o options] device|dir<br class="calibre2"/> mount [-fnrsvw] [-t fstype] [-o options] device dir<br class="calibre2"/>DESCRIPTION<br class="calibre2"/> All files accessible in a Unix system are arranged in one big tree, the<br class="calibre2"/> file hierarchy, rooted at /. These files can be spread out over sev‐<br class="calibre2"/> eral devices. The mount command serves to attach the filesystem found<br class="calibre2"/> on some device to the big file tree. Conversely, the umount(8) command<br class="calibre2"/> will detach it again.<br class="calibre2"/>...<br class="calibre2"/>(Press 'q' to Quit)<br class="calibre2"/>$</pre>
<p class="mce-root"/>
<p class="mce-root">Alternatively, there is the <kbd class="calibre17">info</kbd> command, which will give you information should info pages exist for the item you are looking for.</p>
<div class="packt_tip">Getting used to the style of the man and info pages can easily save you time by allowing you to access information quickly, especially if you don't have the internet.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we introduced the concept of variables, types, and assignments. We also covered some basic Bash programming primitives for for loops, while, and switch statements. Later on, we learned what functions are, how they are used, and how to pass<br class="calibre8"/>
parameters.</p>
<p class="mce-root">In the next chapter, we will learn about several bolt-on technologies to make Bash even more extensive.</p>


            </article>

            
        </section>
    </div>



  </body></html>