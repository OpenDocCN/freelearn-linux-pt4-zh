- en: Monitoring and Backup of KVM Virtual Machines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KVM 虚拟机的监控与备份
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: Resource usage collection with libvirt
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 libvirt 收集资源使用情况
- en: Monitoring KVM instances with Sensu
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sensu 监控 KVM 实例
- en: Simple KVM backups with tar and rsync
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 tar 和 rsync 进行简单的 KVM 备份
- en: Creating snapshots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建快照
- en: Listing snapshots
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出快照
- en: Inspecting snapshots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查快照
- en: Editing snapshots
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑快照
- en: Reverting snapshots
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复快照
- en: Deleting snapshots
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除快照
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: It goes without saying that monitoring and backing up of production KVM instances
    is important in order to meet uptime **Service-Level Agreements** (**SLAs**) and
    to satisfy high-availability and performance requirements. Monitoring and backing
    up of virtual machines is not very different from monitoring and backing up of
    physical servers. In some cases, it's even more convenient to back up a single
    image file for VM or create a snapshot, rather than the filesystem of an OS running
    on a physical server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，监控和备份生产环境中的 KVM 实例对于满足正常运行 **服务级别协议**（**SLA**）以及满足高可用性和性能要求至关重要。虚拟机的监控和备份与物理服务器的监控和备份并没有太大不同。在某些情况下，备份虚拟机的单个镜像文件或创建快照比备份运行在物理服务器上的操作系统文件系统更为方便。
- en: In this chapter, we are going to see examples on how to gather resource usage
    metrics for live KVM instances and how to monitor the resource usage and alert
    on predefined thresholds with tools such as Sensu. Following this, we are going
    to focus on different ways of backing up KVM guests using tools such as `rsync`,
    and creating and managing snapshots with the help of the `virsh` command.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示如何收集实时 KVM 实例的资源使用指标，并使用像 Sensu 这样的工具监控资源使用情况并在预定义的阈值上进行告警。随后，我们将专注于使用像
    `rsync` 这样的工具备份 KVM 客户机的不同方法，以及使用 `virsh` 命令创建和管理快照。
- en: Resource usage collection with libvirt
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 libvirt 收集资源使用情况
- en: The first step in monitoring virtual machines is to get familiar with the tools
    to collect metrics on the subsystems we would like to later alert on. In this
    recipe, we are going to focus on CPU, memory, and block device utilization of
    the KVM guests. We are also going to learn how to use the QEMU monitoring socket
    and the QEMU guest agent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 监控虚拟机的第一步是熟悉用于收集我们希望后续告警的子系统指标的工具。在本配方中，我们将专注于 KVM 客户机的 CPU、内存和块设备使用情况。我们还将学习如何使用
    QEMU 监控套接字和 QEMU 客户机代理。
- en: Libvirt exposes a set of calls that the `virsh` command leverages to gather resource
    usage information on the specified guest/domain. We are going to monitor and alert
    on the information collected here in the *Monitoring KVM instances with Sensu* recipe
    later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt 提供了一组调用，`virsh` 命令利用这些调用来收集指定客户机/域的资源使用信息。我们将在本章稍后的 *使用 Sensu 监控 KVM
    实例* 配方中监控并告警这些收集到的信息。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中，我们需要以下内容：
- en: A server with libvirt installed and configured
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装并配置 libvirt 的服务器
- en: A running KVM instance
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在运行的 KVM 实例
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To collect various resource usage information for a running instance or the
    hypervisor host, perform the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要收集运行中的实例或虚拟化主机的各种资源使用信息，请执行以下操作：
- en: 'Obtain information on the hypervisor CPU utilization:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取虚拟化主机 CPU 使用情况的信息：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Collect information on the hypervisor memory utilization:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集虚拟化主机内存使用情况的信息：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Check the state of a KVM instance:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 KVM 实例的状态：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Get a number of assigned virtual CPUs (vCPU) for a KVM instance:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 KVM 实例分配的虚拟 CPU（vCPU）数量：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Collect detailed information about the virtual CPU for a guest:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集虚拟机虚拟 CPU 的详细信息：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Gather information about the vCPU timers for the guest VM:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集关于客户机虚拟 CPU 定时器的信息：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Collect general information about the VM:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集虚拟机的一般信息：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Collect the memory utilization for the VM:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集虚拟机的内存使用情况：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Get information about the block devices associated with the KVM instance:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与 KVM 实例相关的块设备信息：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Obtain size information on the block device for the VM:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取虚拟机块设备的大小信息：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Get any block device errors for the KVM instance:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 KVM 实例的任何块设备错误：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Print block device statistic for a KVM guest:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 KVM 客户机的块设备统计信息：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we collect various hypervisor and guest resource utilization
    information from the host OS. In later recipes, we will use that information in
    a monitoring system to alert and trigger actions based on set criteria and thresholds.
    Let's go through the steps we performed earlier in more detail.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们从主机操作系统收集各种虚拟化主机和来宾资源利用率信息。在以后的教程中，我们将利用这些信息在监控系统中设置警报，并根据设定的标准和阈值触发相应操作。让我们更详细地回顾一下我们之前执行的步骤。
- en: We start by collecting information about the CPU utilization on the hypervisor/host
    OS in step 1\. We then proceed to gather the memory utilization on the physical
    host in step 2\. Note that we can also use other Linux commands to do this instead
    of `virsh`, but it helps demonstrate the concept.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第1步开始收集关于虚拟化主机/主机操作系统的CPU利用率信息。接着，在第2步收集物理主机的内存利用率信息。请注意，我们也可以使用其他Linux命令来完成这项工作，而不是使用`virsh`，但它有助于展示这个概念。
- en: Monitoring the state of a KVM instance is important in case the VM terminates
    unexpectedly or does not start automatically after a server reboot. In step 3,
    we obtain the current state of the virtual machine.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 监控KVM实例的状态非常重要，以防虚拟机意外终止或在服务器重启后没有自动启动。在第3步中，我们获取虚拟机的当前状态。
- en: In steps 4, 5, and 6, we collect information about the virtual CPU of the guest.
    We can see the number of assigned CPUs along with other useful information, such
    as the time the CPU spends running kernel and userspace code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4、5和6步中，我们收集了关于虚拟机来宾的虚拟CPU的信息。我们可以看到分配的CPU数量以及其他有用的信息，例如CPU花费在内核和用户空间代码上的时间。
- en: In step 7, we collect more general information about the virtual machine; of
    notable interest is the total and used amount of memory that we can set alerting
    thresholds on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，我们收集了有关虚拟机的更多一般信息；特别值得关注的是我们可以设置警报阈值的总内存和已用内存量。
- en: In step 8, we get information about the memory utilization of the KVM instance.
    We can see the total, swap, and resident memory usage in the output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们获取关于KVM实例的内存利用率的信息。我们可以在输出中看到总内存、交换内存和常驻内存的使用情况。
- en: In step 9, we list the block devices attached to the virtual machine, and we
    use that in step 10 to get information about its capacity. If there are any errors
    associated with the block device, the output of the command in step 11 will show
    that, which we can use to trigger monitoring alerts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步中，我们列出了附加到虚拟机的块设备，并在第10步中使用这些信息获取设备容量。如果块设备存在任何错误，第11步的命令输出会显示出来，我们可以利用这些信息触发监控警报。
- en: Monitoring the performance of a block device attached to a KVM instance can
    be done using the output of the command in step 12.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 监控附加到KVM实例的块设备的性能，可以使用第12步命令的输出。
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: When we create a virtual machine with libvirt, the QEMU process that is started
    exposes a monitoring socket that we can connect to and collect information about
    the guest.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用libvirt创建虚拟机时，启动的QEMU进程会暴露一个监控套接字，我们可以连接到该套接字并收集关于来宾的信息。
- en: 'Let''s see how that looks for the KVM instance we''ve been using:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们一直在使用的KVM实例的情况：
- en: 'Get the process information for the guest instance:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取来宾实例的进程信息：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice from the preceding output the `*-*chardev socket,id=charmonitor,path=/var/lib/libvirt/qemu/kvm1.monitor` and
    the `-mon chardev=charmonitor,id=monitor,mode=control` parameters passed to the
    QEMU process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中注意到传递给QEMU进程的`*-*chardev socket,id=charmonitor,path=/var/lib/libvirt/qemu/kvm1.monitor`和`-mon
    chardev=charmonitor,id=monitor,mode=control`参数。
- en: 'We can access this socket in two ways, either by connecting to it using tools such
    as `nc` and `socat` or with the `virsh` command, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式访问这个套接字，一种是使用`nc`和`socat`等工具连接，另一种是通过`virsh`命令，具体如下：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To obtain information about the network interface of the KVM instance, we can
    run the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取关于KVM实例网络接口的信息，我们可以运行以下代码：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: QEMU provides a guest agent daemon that can be started inside the KVM instance
    and then can be connected to from the host OS. We can collect additional data
    or update certain settings for the virtual machine directly from the host.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU提供了一个来宾代理守护进程，可以在KVM实例内启动，然后从主机操作系统连接。我们可以从主机直接收集额外的数据或更新虚拟机的某些设置。
- en: 'Let''s see an example of installing and using the QEMU guest agent:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下安装和使用QEMU来宾代理的示例：
- en: 'Create the required directory that will contain the communication socket between
    libvirt on the host and the guest agent running inside the KVM guest:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需目录，该目录将包含libvirt主机和运行在KVM来宾内的来宾代理之间的通信套接字：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Edit the configuration for the running VM and add the following definition
    under the `<devices>` section:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑运行中的虚拟机配置，并在 `<devices>` 部分下添加以下定义：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Restart the KVM instance:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启 KVM 实例：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Connect to the VM and install and start the QEMU guest agent, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到虚拟机并安装和启动 QEMU 客户机代理，如下所示：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Back on the host, we can see the new socket file:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到主机，我们可以看到新的套接字文件：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s connect to the guest agent from the host and list the available commands
    that the guest agent accepts:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从主机连接到客户机代理并列出客户机代理接受的可用命令：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Get information about the guest vCPU by running the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下代码获取关于客户机 vCPU 的信息：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the monitoring and guest agent sockets provides an additional way of collecting
    more information about the running virtual machines on the libvirt host that we
    can later add as monitoring checks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用监控和客户端代理套接字提供了一种额外的方式，可以收集关于在 libvirt 主机上运行的虚拟机的更多信息，之后我们可以将这些信息添加为监控检查。
- en: Monitoring KVM instances with Sensu
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sensu 监控 KVM 实例
- en: Sensu is a complete monitoring solution that uses the client-server model; the
    server publishes checks in a message queue provided by the Rabbitmq service. The
    clients/agents subscribe to topics in the queue and execute the specified checks
    on the host they run on. State and historical data is stored in a Redis server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Sensu 是一个完整的监控解决方案，采用客户端-服务器模型；服务器在 Rabbitmq 服务提供的消息队列中发布检查。客户端/代理订阅队列中的主题，并在它们运行的主机上执行指定的检查。状态和历史数据存储在
    Redis 服务器中。
- en: In this recipe, we are going to install the Sensu server, Rabbitmq message queue,
    and the Redis server on one host, write a simple monitoring check using the information
    we obtained from the *Resource usage collection with libvirt* recipe earlier,
    and install the Sensu agent inside the KVM guest.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇教程中，我们将把 Sensu 服务器、Rabbitmq 消息队列和 Redis 服务器安装在同一主机上，编写一个简单的监控检查，使用我们从*使用
    libvirt 收集资源使用情况*教程中获取的信息，并在 KVM 客户机中安装 Sensu 代理。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本篇教程，我们需要以下内容：
- en: A Linux host with libvirt installed and running
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行 libvirt 的 Linux 主机
- en: A KVM instance running on the libvirt host
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 libvirt 主机上运行的 KVM 实例
- en: Network connectivity between the KVM instance and the libvirt host
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KVM 实例与 libvirt 主机之间的网络连接
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To set up a new Sensu deployment and define various monitoring checks, perform
    the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置新的 Sensu 部署并定义各种监控检查，请执行以下步骤：
- en: 'Install the Redis server and ensure that it is responding to requests:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Redis 服务器并确保它响应请求：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Install the Rabbitmq server:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Rabbitmq 服务器：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the virtual host the Sensu agents will subscribe to and the credentials
    and permissions for the Rabbitmq clients:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Sensu 代理将订阅的虚拟主机，以及 Rabbitmq 客户端的凭证和权限：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the Sensu upstream repository and its key and then install the Sensu package:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Sensu 上游仓库及其密钥，然后安装 Sensu 包：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sensu uses JSON-based configuration files for its configuration. Create the
    Sensu API configuration file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sensu 使用基于 JSON 的配置文件进行配置。创建 Sensu API 配置文件：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Configure the transport type for Sensu; we are using Rabbitmq for this deployment:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Sensu 的传输类型；我们在此部署中使用 Rabbitmq：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Configure where the Rabbitmq service is accepting connections, the virtual
    host, and credentials:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Rabbitmq 服务接受连接的位置、虚拟主机和凭证：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Specify the host and port the Redis service is listening on:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定 Redis 服务监听的主机和端口：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Configure the Sensu client:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Sensu 客户端：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For more information on Sensu, please refer to [https://sensuapp.org/docs/](https://sensuapp.org/docs/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Sensu 的更多信息，请参见 [https://sensuapp.org/docs/](https://sensuapp.org/docs/)。
- en: 'Install the web frontend for Sensu, named **Uchiwa**:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Sensu 的 Web 前端，名为 **Uchiwa**：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Configure the Uchiwa frontend:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Uchiwa 前端：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Start the Sensu server, API, client, and frontend components:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Sensu 服务器、API、客户端和前端组件：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Connect to the KVM instance console; install and configure the Sensu client:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到 KVM 实例控制台；安装并配置 Sensu 客户端：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Replace the IP address of the client with the IP address configured inside the
    KVM instance. Update the IP address of the Rabbitmq server with the IP address
    configured on the host bridge. Ensure that the KVM guest can ping the bridge IP
    on the host OS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将客户端的 IP 地址替换为 KVM 实例中配置的 IP 地址。更新 Rabbitmq 服务器的 IP 地址为主机桥接上配置的 IP 地址。确保 KVM
    客户机能够 ping 通主机操作系统上的桥接 IP。
- en: 'Start the Sensu client:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Sensu 客户端：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Connect to the Uchiwa interface and ensure that the host Sensu client and the
    KVM guest Sensu client are listed in the CLIENTS section:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到 Uchiwa 界面，确保主机 Sensu 客户端和 KVM 客户端 Sensu 客户端都列在 CLIENTS 部分：
- en: '![](img/00008.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: The Uchiwa frontend showing the connected clients
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 显示已连接客户端的 Uchiwa 前端
- en: 'While still connected to the KVM guest, install a memory check from the gem
    repository and test it:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然连接到 KVM 客户端时，从 gem 仓库安装内存检查并进行测试：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Back on the host OS, define the new memory check for the KVM guest:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回主机操作系统，定义 KVM 客户端的新内存检查：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Restart the Sensu components:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启 Sensu 组件：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The memory_check for the KVM instance is now showing in the Uchiwa dashboard:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: KVM 实例的 memory_check 现在显示在 Uchiwa 仪表板中：
- en: '![](img/00009.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: The Uchiwa frontend showing the memory check for the KVM guest
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 KVM 客户端内存检查的 Uchiwa 前端
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous section, we installed a Sensu server and all the required infrastructure
    components for it to run on the hypervisor host. Then we installed the client
    inside a KVM instance, installed the memory ruby check, and defined it on the
    host. Let's examine all the steps in more detail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们安装了 Sensu 服务器及其运行所需的所有基础组件，并将其部署在虚拟化主机上。然后我们在 KVM 实例内安装了客户端，安装了内存 ruby
    检查，并在主机上定义了它。现在让我们更详细地审视这些步骤。
- en: In step 1, we install the Redis server and ensure that it is accepting connections.
    Redis is a key-value store service that Sensu uses to store the historical information
    about the checks, current state, and connected clients.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们安装 Redis 服务器并确保它接受连接。Redis 是一个键值存储服务，Sensu 用它来存储有关检查、当前状态和连接客户端的历史信息。
- en: With the Redis server in place, we proceed to install and configure Rabbitmq
    in steps 2 through 9\. Rabbitmq is a message bus conforming to the **Advanced
    Message Queuing Protocol** (**AMQP**) standard. The Sensu server and clients produce
    and consume messages from the queue to trigger monitoring actions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好 Redis 服务器后，我们继续在步骤 2 到 9 中安装并配置 Rabbitmq。Rabbitmq 是一个符合 **高级消息队列协议**（**AMQP**）标准的消息总线。Sensu
    服务器和客户端从队列中生成和消费消息，以触发监控操作。
- en: Although not required, in steps 10 and 11, we install and configure a web frontend
    for the Sensu server named Uchiwa. We can use the web interface to check on the
    status of different checks for the KVM guests we monitor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不是必须的，但在步骤 10 和 11 中，我们安装并配置了名为 Uchiwa 的 Sensu 服务器的 Web 前端。我们可以使用 Web 界面检查我们监控的
    KVM 客户端的不同检查状态。
- en: In step 13, we install the Sensu client inside the KVM guest instance and proceed
    to install a memory monitoring script from a gem in step 16\. A monitoring script
    can be written in any language (RUBY in this case) as long as it returns the expected
    error codes that Sensu expects. In the next section, we are going to write a new
    check from scratch using Bash.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 13 中，我们在 KVM 客户端实例内安装了 Sensu 客户端，并在步骤 16 中安装了来自 gem 的内存监控脚本。监控脚本可以使用任何语言编写（此处使用
    RUBY），只要它返回 Sensu 所期望的错误代码。在下一节中，我们将从头开始使用 Bash 编写一个新的检查。
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In the previous section, we saw an example of how to use a ruby check inside
    the KVM instance and monitor the memory utilization. Sensu provides standalone
    checks that can be triggered from the Sensu client, independently from the Sensu
    server scheduling mechanism. Let''s use that feature and write a simple check
    in Bash that will run from the host OS, instead of the KVM guest, and use the
    `virsh` command to check the status of a KVM instance:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何在 KVM 实例中使用 ruby 检查并监控内存使用情况的示例。Sensu 提供了独立的检查，可以从 Sensu 客户端触发，独立于
    Sensu 服务器的调度机制。让我们使用这个功能，编写一个简单的 Bash 检查脚本，该脚本将从主机操作系统运行，而不是从 KVM 客户端运行，并使用 `virsh`
    命令检查 KVM 实例的状态：
- en: 'Write a standalone check definition with the custom script that `sensu-client`
    will execute to perform the check:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sensu-client` 执行检查的自定义脚本编写独立检查定义：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the Sensu `plugins` directory, write this simple Bash script:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Sensu 的 `plugins` 目录中，编写这个简单的 Bash 脚本：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Make the script executable, add the Sensu user in a `sudoers` file, and test
    the check by executing it:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使脚本可执行，在 `sudoers` 文件中添加 Sensu 用户，并通过执行它来测试检查：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Restart the Sensu client on the host; check the logs and the Uchiwa dashboard
    for the new standalone check:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启主机上的 Sensu 客户端；检查日志和 Uchiwa 仪表板，查看新的独立检查：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![](img/00010.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: The Uchiwa frontend showing the standalone instance check
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 显示独立实例检查的 Uchiwa 前端
- en: Using the examples from the* Resource usage collection with libvirt* recipe,
    you should now be able to write a variety of Sensu monitoring checks executed
    from the hypervisor or inside the KVM guests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自*libvirt资源使用集合*的示例，你现在应该能够编写多种由监控系统Sensu执行的检查，这些检查可以在虚拟化主机或KVM客户机内运行。
- en: For more information on how Sensu can execute scripts when an alert is triggered,
    please refer to the *handlers* section of the official documentation at [https://sensuapp.org/docs/latest/reference/handlers.html](https://sensuapp.org/docs/latest/reference/handlers.html).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Sensu如何在触发警报时执行脚本的更多信息，请参考官方文档中的*handlers*部分：[https://sensuapp.org/docs/latest/reference/handlers.html](https://sensuapp.org/docs/latest/reference/handlers.html)。
- en: Simple KVM backups with tar and rsync
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tar和rsync进行简单的KVM备份
- en: In this recipe, we are going to create a backup of a KVM instance using `tar`
    and `rsync` and store it on a remote server. This is the easiest way to backup
    a KVM instance. In the next few recipes, we are going to create snapshots and
    use them as a cold backup.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将使用`tar`和`rsync`创建KVM实例的备份并将其存储在远程服务器上。这是备份KVM实例的最简单方法。在接下来的几个步骤中，我们将创建快照并将其作为冷备份使用。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this extremely simple recipe, we are going to need:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个极其简单的步骤，我们需要：
- en: A libvirt host with a running KVM instance, using an image file as its backing
    store
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个运行中的libvirt主机，使用镜像文件作为其后备存储
- en: The `tar` and `rsync` Linux utilities
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar`和`rsync` Linux工具'
- en: A remote server to transfer the backup
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于传输备份的远程服务器
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To back up a virtual machine using `tar` and `rsync`, perform the following
    steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`tar`和`rsync`备份虚拟机，请执行以下步骤：
- en: 'Create the backup directory and change to it:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建备份目录并切换到该目录：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Find the location of the image file of the KVM guest:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找KVM客户机镜像文件的位置：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save the current instance configuration to disk:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前实例配置保存到磁盘：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Stop the KVM guest and copy the image file to the backup directory:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止KVM客户机并将镜像文件复制到备份目录：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a single archive for the VM''s configuration and image files:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为虚拟机的配置和镜像文件创建一个单独的存档：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Transfer the backup archive to a remote server:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将备份存档传输到远程服务器：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To restore from the backup, log in to the remote server and extract the archive:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从备份中恢复，请登录远程服务器并提取存档：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Copy the image file to the configured location and define the instance:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像文件复制到配置的位置并定义实例：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: After creating the backup directory in step 1, we save the current guest definition
    to disk in step 3\. In step 4, after stopping the virtual machine, we copy its
    image file to the backup directory. In step 5, we create a bzip2 compressed data
    file which we transfer to a remote server in step 6.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步创建备份目录后，我们在第3步将当前的客户机定义保存到磁盘。在第4步，停止虚拟机后，我们将其镜像文件复制到备份目录。在第5步，我们创建一个bzip2压缩的数据文件，并在第6步将其传输到远程服务器。
- en: On the remote server, we extract the archive in step 7 and copy the raw image
    file to where the XML definition of the instance is expecting it, then define
    the instance in step 8.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程服务器上，我们在第7步解压存档，并将原始镜像文件复制到实例的XML定义所期望的位置，然后在第8步定义实例。
- en: Note that in order to preserve the consistency and integrity of the data while
    copying the image file to the backup directory, we had to first stop the KVM guest.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了在将镜像文件复制到备份目录时保持数据的一致性和完整性，我们必须先停止KVM客户机。
- en: Creating snapshots
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建快照
- en: A virtual machine snapshot preserves the current state of a running or stopped instance
    at a specific point in time. It can later be used to restore the instance from
    that point. Snapshots can be used as backups or as templates for building new
    virtual machines that will be copies of the original instance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机快照在特定时间点保留正在运行或已停止实例的当前状态。以后可以用来从该点恢复实例。快照可以作为备份或作为构建新虚拟机的模板，新虚拟机将是原始实例的副本。
- en: To take advantage of snapshots, the backing store must first support it. If
    you recall from the *Managing Disk images with qemu-img* recipe in [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM*, we created a raw image type for the KVM guest.
    In this recipe, we are going to use the **QEMU Copy-On-Write** (**QCOW2**) image
    format as the backing store for the KVM instance, because the raw image format
    does not support snapshots.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用快照，支持存储必须首先支持它。如果你还记得在[第 1 章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*，QEMU
    和 KVM 入门*中的*使用 qemu-img 管理磁盘镜像*配方，我们为 KVM 客户机创建了一个原始镜像类型。在这个配方中，我们将使用 **QEMU Copy-On-Write**
    (**QCOW2**) 镜像格式作为 KVM 实例的支持存储，因为原始镜像格式不支持快照。
- en: Using the QCOW2 image format, we can create a base image containing the guest
    OS and everything else we need for the virtual machine, and then create several
    copy-on-write overlay disk images on top of the original base image. These new
    overlay images can be used in new virtual machines right away, by creating new
    XML definition files pointing to the new image.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 QCOW2 镜像格式，我们可以创建一个包含客户操作系统以及虚拟机所需一切的基础镜像，然后在原始基础镜像之上创建几个写时复制叠加磁盘镜像。这些新的叠加镜像可以立即在新的虚拟机中使用，通过创建指向新镜像的
    XML 定义文件。
- en: 'Let''s see an example of using QEMU to create image overlays before we proceed
    with making libvirt snapshots:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行 libvirt 快照操作之前，让我们看一个使用 QEMU 创建镜像叠加的示例：
- en: 'To collect information about a QCOW2 image, we can use the `qemu-img` utility:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要收集 QCOW2 镜像的信息，我们可以使用 `qemu-img` 工具：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To convert an existing raw image to QCOW2, run:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要将现有的原始镜像转换为 QCOW2，运行：
- en: '`root@kvm:~# qemu-img convert -f raw -O qcow2 /var/lib/libvirt/images/kvm1.img
    /var/lib/libvirt/images/kvm1.qcow2`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`root@kvm:~# qemu-img convert -f raw -O qcow2 /var/lib/libvirt/images/kvm1.img
    /var/lib/libvirt/images/kvm1.qcow2`'
- en: 'Let''s create a new overlay image based on the qcow2 preceding image:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们基于前面的 qcow2 镜像创建一个新的叠加镜像：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Getting information about the new overlay image now shows the backing file
    it''s based on:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取新叠加镜像的信息，现在显示它所基于的支持文件：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can create a new overlay file from the previous overlay file:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从前一个叠加文件创建一个新的叠加文件：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s list the entire image chain for the last overlay file:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出最后一个叠加文件的整个镜像链：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Libvirt uses the ability of the QCOW2 image format to create a chain of overlay
    snapshots that can be used as backups or as templates for new virtual machines.
    Once an overlay is created, the original base image is treated as read-only. Modifications
    to the base images (in this example, `kvm1.qcow2` and `kvm1_copy.qcow2` because both
    are base images for the `kvm1_copy_2.qcow2` image) are not recommended. Here''s
    a diagrammatic representation of the chain of overlay image files we created earlier:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt 使用 QCOW2 镜像格式的能力创建叠加快照链，这些快照可以用作备份或新虚拟机的模板。一旦创建了叠加，原始基础镜像将被视为只读。对基础镜像的修改（在此示例中，`kvm1.qcow2`
    和 `kvm1_copy.qcow2`，因为它们都是 `kvm1_copy_2.qcow2` 镜像的基础镜像）是不推荐的。以下是我们之前创建的叠加镜像文件链的示意图：
- en: '![](img/00011.gif)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.gif)'
- en: The chain of overlay QCOW2 images, each one serving as a base image for the
    next
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 叠加的 QCOW2 镜像链，每一个都作为下一个的基础镜像
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要以下内容：
- en: A libvirt host with an existing QCOW2 image, with no snapshots attached
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个没有附加快照的现有 QCOW2 镜像的 libvirt 主机
- en: A running KVM instance
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行的 KVM 实例
- en: The QEMU toolset
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QEMU 工具集
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a new KVM snapshot, follow these steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 KVM 快照，请按以下步骤操作：
- en: 'Create an internal snapshot of the running instance:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建正在运行实例的内部快照：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Examine the location of the new snapshot configuration:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新快照配置的位置：
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Examine the snapshot XML definition:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查快照的 XML 定义：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Collect information about the base image:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集基础镜像的信息：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Obtain information about the disk device on the virtual machine:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取虚拟机上磁盘设备的信息：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create an external, disk-only snapshot:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个外部的，仅磁盘的快照：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Get information about the external snapshot:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取外部快照的信息：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'There are two main types of snapshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要类型的快照：
- en: '**An internal snapshot**: The base image file itself contains the saved state
    and all subsequent changes to the virtual machine'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部快照**：基础镜像文件本身包含保存的状态以及虚拟机的所有后续更改'
- en: '**An external snapshot**: The base image will contain the saved state of the
    virtual machine thus becoming a read-only base image, and a new overlay image
    is created to track any future changes'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部快照**：基础镜像将包含虚拟机的保存状态，从而成为一个只读的基础镜像，并创建一个新的叠加镜像来跟踪未来的任何更改。'
- en: Both types of snapshots can be performed on just the disk or the memory of the
    virtual machine, either on a live or stopped instance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的快照可以仅在虚拟机的磁盘或内存上执行，无论虚拟机是在线还是已停止。
- en: 'In the preceding step 1, we create an internal snapshot of the virtual machine.
    After the snapshot, there''s only one image file: the original image, now containing
    the snapshot. We can see that the image is a snapshot in step 4, under the *Snapshot
    list* section of the output.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的步骤 1 中，我们创建了虚拟机的一个内部快照。快照完成后，只有一个镜像文件：原始镜像，现在包含了快照。我们可以在步骤 4 的 *快照列表* 部分看到这个镜像是一个快照。
- en: In step 6, we perform an external, disk-only snapshot, by specifying the virtual
    machine disk, name, and location for the snapshot. Note that after the snapshot,
    a new image file has been created to track any further changes. We examine that
    file in step 7\. Note how the backing file is the original qcow2 image.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 6 中，我们执行一个外部的仅磁盘快照，通过指定虚拟机磁盘、名称和快照的存储位置来完成。请注意，快照后，会创建一个新镜像文件来跟踪任何后续的更改。我们将在步骤
    7 中检查该文件。请注意，基础文件是原始的 qcow2 镜像。
- en: To perform the disk snapshots, libvirt leverages the QEMU functionality, like
    the `qemu-img` command we saw earlier when creating the overlay images.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行磁盘快照，libvirt 利用 QEMU 功能，就像我们在创建叠加镜像时看到的 `qemu-img` 命令一样。
- en: We can now save the snapshots as backups or use them to start new virtual machines.
    In the following recipes, we are going to see examples on how to use and manipulate the
    snapshots.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将快照保存为备份，或者使用它们启动新的虚拟机。在接下来的示例中，我们将看到如何使用和操作这些快照。
- en: Listing snapshots
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出快照
- en: 'In the previous recipe, we create two snapshots of the same KVM instance: one
    internal and one disk-only, external snapshot. In this recipe, we are going to
    learn how to list existing snapshots.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们为同一个 KVM 实例创建了两个快照：一个内部快照和一个仅磁盘的外部快照。在这个示例中，我们将学习如何列出现有的快照。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们需要：
- en: A libvirt host with the QEMU toolset
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配有 QEMU 工具集的 libvirt 主机
- en: A running KVM instance
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行的 KVM 实例
- en: The snapshots we created in the *Creating snapshots* recipe
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 *创建快照* 示例中创建的快照
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'To list all existing snapshots, follow the next steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有现有的快照，请按照以下步骤操作：
- en: 'List all snapshots for the specified KVM instance:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出指定 KVM 实例的所有快照：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'List only the disk-based snapshots:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅列出基于磁盘的快照：
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'List only the internal snapshots:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅列出内部快照：
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'List the external snapshots only:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅列出外部快照：
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'List all images in a hierarchical tree format:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以层次树格式列出所有镜像：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We used the versatile `virsh snapshot-list` command to list all internal and
    external snapshots for the specified virtual machine. Note how we can get similar
    information using the `qemu-img` command directly on the image files, as we saw
    earlier in this chapter. However, the API calls that libvirt provides for listing
    snapshots are much more convenient. In the next chapter, we are going to see examples
    on how to use the libvirt Python bindings to manipulate KVM instances and their
    snapshots.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了多功能的 `virsh snapshot-list` 命令来列出指定虚拟机的所有内部和外部快照。请注意，我们如何可以通过直接在镜像文件上使用
    `qemu-img` 命令获取类似的信息，就像我们在本章之前看到的那样。然而，libvirt 提供的列出快照的 API 调用要方便得多。在下一章中，我们将看到如何使用
    libvirt 的 Python 绑定来操作 KVM 实例及其快照。
- en: Inspecting snapshots
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查快照
- en: In this short recipe, we are going to see examples on how to obtain more information
    on existing virtual machine snapshots.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的示例中，我们将看到如何获取现有虚拟机快照的更多信息。
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们需要以下内容：
- en: A libvirt host with the QEMU toolset
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配有 QEMU 工具集的 libvirt 主机
- en: The snapshots we created in the *Creating snapshots* recipe
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 *创建快照* 示例中创建的快照
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'To inspect a snapshot, run the following commands:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个快照，请运行以下命令：
- en: 'List all available snapshots for the specified KVM instance:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出指定 KVM 实例的所有可用快照：
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Get information about the running snapshot:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取正在运行的快照的信息：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Get information about the disk snapshot:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取磁盘快照的信息：
- en: '[PRE70]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Dump the XML configuration for the disk snapshot:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出磁盘快照的 XML 配置：
- en: '[PRE71]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In step 1, we list all the available snapshots for the kvm1 virtual machine.
    In steps 2 and 3, we obtain information about the snapshots. Of particular interest
    is the `Parent` and `Children` fields, showing us the hierarchy of the snapshots.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们列出kvm1虚拟机的所有可用快照。在第2步和第3步中，我们获取有关这些快照的信息。特别需要注意的是`Parent`和`Children`字段，它们显示了快照的层级关系。
- en: In step 4, we examine the XML definition of the KVM guest and the disk-only,
    external snapshot. We can observe the `snapshot='external'` type and the base
    image location specified with the `<source file='/var/lib/libvirt/images/kvm1_disk_external.qcow2'/>`
    stanza.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们检查KVM来宾的XML定义以及仅包含磁盘的外部快照。我们可以观察到`snapshot='external'`类型和使用`<source
    file='/var/lib/libvirt/images/kvm1_disk_external.qcow2'/>`标记指定的基础镜像位置。
- en: Editing snapshots
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑快照
- en: In this recipe, we are going to edit the XML definition of an existing snapshot
    and examine the changes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将编辑现有快照的XML定义并检查更改。
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程中，我们将需要以下内容：
- en: A libvirt host with the QEMU toolset
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备QEMU工具集的libvirt主机
- en: The snapshots we created in the *Creating snapshots* recipe
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在*创建快照*章节中创建的快照
- en: How to do it...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'To edit a snapshot, run the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑快照，请运行以下命令：
- en: 'List all available snapshots for the specified KVM instance:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出指定KVM实例的所有可用快照：
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Edit the disk snapshot and change its name and description:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑磁盘快照并更改其名称和描述：
- en: '[PRE73]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'List the snapshots after the update:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后的快照列表：
- en: '[PRE74]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Libvirt provides a way to edit the snapshot definition for a virtual machine.
    We can change various XML attributes, such as the snapshot name, description,
    or the location of the backing image file. In step 1, we list all available snapshots
    for the specified KVM instance, then proceed to update the name and description
    of the disk image. Finally, in step 3, we can see the changed name for the external
    snapshot.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt提供了一种编辑虚拟机快照定义的方法。我们可以更改各种XML属性，如快照名称、描述或镜像文件的位置。在第1步中，我们列出指定KVM实例的所有可用快照，然后继续更新磁盘镜像的名称和描述。最后，在第3步中，我们可以看到更改后的外部快照名称。
- en: Reverting snapshots
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复快照
- en: In this recipe, we are going to create an internal snapshot of a running instance,
    introduce a change, then restore back to the original instance state using the
    snapshot.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个正在运行的实例的内部快照，进行一次更改，然后使用该快照恢复回原始实例状态。
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程中，我们将需要以下内容：
- en: A libvirt host with an existing QCOW2 image
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有现有QCOW2镜像的libvirt主机
- en: A running KVM instance, using the QCOW2 image
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QCOW2镜像的正在运行的KVM实例
- en: The QEMU toolset
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QEMU工具集
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'To revert the state of a KVM instance to an older state, from an existing snapshot,
    run the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要将KVM实例的状态恢复到旧状态，请从现有快照中运行以下命令：
- en: 'Connect to the KVM instance and create a new file:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到KVM实例并创建一个新文件：
- en: '[PRE75]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create an internal snapshot of the virtual machine:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建虚拟机的内部快照：
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Get information about the snapshot:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取关于快照的信息：
- en: '[PRE77]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Connect back to the virtual machine and delete the file we created in step
    1:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新连接到虚拟机并删除第1步中创建的文件：
- en: '[PRE78]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Restore the instance from the latest snapshot:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从最新的快照恢复实例：
- en: '[PRE79]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Connect to the virtual machine and confirm that file we deleted in the previous
    step exists again:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到虚拟机并确认我们在上一步删除的文件是否已重新存在：
- en: '[PRE80]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In step 1, we connect to the KVM instance using the console and create an empty
    file. We are going to use the file to track changes on the virtual machine. In
    step 2, we create an internal snapshot and obtain more information about it in
    step 3\. In step 4, we connect to the KVM guest again and delete the file. In
    step 5, we restore from the snapshot, confirming that the state of the instance
    has been indeed reverted to before the snapshot, as shown by the presence of the
    original file we created earlier.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们通过控制台连接到KVM实例并创建一个空文件。我们将使用该文件跟踪虚拟机上的更改。在第2步中，我们创建一个内部快照，并在第3步中获取更多信息。在第4步中，我们再次连接到KVM来宾并删除该文件。在第5步中，我们从快照恢复，确认实例的状态确实已恢复到快照之前，如我们之前创建的原始文件所示。
- en: Deleting snapshots
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除快照
- en: In this quick recipe, we are going to delete the snapshots we created earlier
    in the *Creating snapshots* recipe, using libvirt.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个快速指南中，我们将使用libvirt删除之前在*创建快照*章节中创建的快照。
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are only going to need the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们只需要以下内容：
- en: A libvirt host with the QEMU toolset
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备QEMU工具集的libvirt主机
- en: The snapshots we created in the *Creating snapshots* recipe
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在*创建快照*教程中创建的快照
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行……
- en: 'To delete a snapshot, follow these steps:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除快照，请按照以下步骤操作：
- en: 'List all snapshots present on the host:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出主机上所有的快照：
- en: '[PRE81]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Delete the latest snapshot based on the creation time:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于创建时间删除最新的快照：
- en: '[PRE82]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'List the remaining snapshots:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出剩余的快照：
- en: '[PRE83]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Delete the latest snapshot:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除最新的快照：
- en: '[PRE84]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In step 1, we list all snapshots on the host OS. We then delete the latest snapshot,
    specifying its name, in step 2\. In step 3, we verify that the snapshot has been
    indeed deleted. Finally, in step 4, we delete the latest image by specifying the
    *--*current flag.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们列出主机操作系统上的所有快照。然后，在第2步中，我们删除最新的快照，指定其名称。在第3步中，我们验证该快照确实已被删除。最后，在第4步中，我们通过指定*--*current标志删除最新的镜像。
- en: Please note that in order to delete or restore an external snapshot a libvirt
    version newer than 1.2.2 is required. If your Linux distribution does not provide
    a newer version in its repositories, you will have to compile libvirt from source.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了删除或恢复外部快照，您需要一个版本高于1.2.2的libvirt。如果您的Linux发行版在其软件库中没有提供更新的版本，您将需要从源代码编译libvirt。
