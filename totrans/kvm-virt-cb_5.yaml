- en: Monitoring and Backup of KVM Virtual Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource usage collection with libvirt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring KVM instances with Sensu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple KVM backups with tar and rsync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverting snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It goes without saying that monitoring and backing up of production KVM instances
    is important in order to meet uptime **Service-Level Agreements** (**SLAs**) and
    to satisfy high-availability and performance requirements. Monitoring and backing
    up of virtual machines is not very different from monitoring and backing up of
    physical servers. In some cases, it's even more convenient to back up a single
    image file for VM or create a snapshot, rather than the filesystem of an OS running
    on a physical server.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to see examples on how to gather resource usage
    metrics for live KVM instances and how to monitor the resource usage and alert
    on predefined thresholds with tools such as Sensu. Following this, we are going
    to focus on different ways of backing up KVM guests using tools such as `rsync`,
    and creating and managing snapshots with the help of the `virsh` command.
  prefs: []
  type: TYPE_NORMAL
- en: Resource usage collection with libvirt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in monitoring virtual machines is to get familiar with the tools
    to collect metrics on the subsystems we would like to later alert on. In this
    recipe, we are going to focus on CPU, memory, and block device utilization of
    the KVM guests. We are also going to learn how to use the QEMU monitoring socket
    and the QEMU guest agent.
  prefs: []
  type: TYPE_NORMAL
- en: Libvirt exposes a set of calls that the `virsh` command leverages to gather resource
    usage information on the specified guest/domain. We are going to monitor and alert
    on the information collected here in the *Monitoring KVM instances with Sensu* recipe
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A server with libvirt installed and configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running KVM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To collect various resource usage information for a running instance or the
    hypervisor host, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtain information on the hypervisor CPU utilization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Collect information on the hypervisor memory utilization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the state of a KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a number of assigned virtual CPUs (vCPU) for a KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Collect detailed information about the virtual CPU for a guest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Gather information about the vCPU timers for the guest VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Collect general information about the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Collect the memory utilization for the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Get information about the block devices associated with the KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain size information on the block device for the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Get any block device errors for the KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Print block device statistic for a KVM guest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we collect various hypervisor and guest resource utilization
    information from the host OS. In later recipes, we will use that information in
    a monitoring system to alert and trigger actions based on set criteria and thresholds.
    Let's go through the steps we performed earlier in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: We start by collecting information about the CPU utilization on the hypervisor/host
    OS in step 1\. We then proceed to gather the memory utilization on the physical
    host in step 2\. Note that we can also use other Linux commands to do this instead
    of `virsh`, but it helps demonstrate the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the state of a KVM instance is important in case the VM terminates
    unexpectedly or does not start automatically after a server reboot. In step 3,
    we obtain the current state of the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 4, 5, and 6, we collect information about the virtual CPU of the guest.
    We can see the number of assigned CPUs along with other useful information, such
    as the time the CPU spends running kernel and userspace code.
  prefs: []
  type: TYPE_NORMAL
- en: In step 7, we collect more general information about the virtual machine; of
    notable interest is the total and used amount of memory that we can set alerting
    thresholds on.
  prefs: []
  type: TYPE_NORMAL
- en: In step 8, we get information about the memory utilization of the KVM instance.
    We can see the total, swap, and resident memory usage in the output.
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, we list the block devices attached to the virtual machine, and we
    use that in step 10 to get information about its capacity. If there are any errors
    associated with the block device, the output of the command in step 11 will show
    that, which we can use to trigger monitoring alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the performance of a block device attached to a KVM instance can
    be done using the output of the command in step 12.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a virtual machine with libvirt, the QEMU process that is started
    exposes a monitoring socket that we can connect to and collect information about
    the guest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how that looks for the KVM instance we''ve been using:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the process information for the guest instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice from the preceding output the `*-*chardev socket,id=charmonitor,path=/var/lib/libvirt/qemu/kvm1.monitor` and
    the `-mon chardev=charmonitor,id=monitor,mode=control` parameters passed to the
    QEMU process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access this socket in two ways, either by connecting to it using tools such
    as `nc` and `socat` or with the `virsh` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain information about the network interface of the KVM instance, we can
    run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: QEMU provides a guest agent daemon that can be started inside the KVM instance
    and then can be connected to from the host OS. We can collect additional data
    or update certain settings for the virtual machine directly from the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of installing and using the QEMU guest agent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the required directory that will contain the communication socket between
    libvirt on the host and the guest agent running inside the KVM guest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the configuration for the running VM and add the following definition
    under the `<devices>` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the VM and install and start the QEMU guest agent, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Back on the host, we can see the new socket file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s connect to the guest agent from the host and list the available commands
    that the guest agent accepts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Get information about the guest vCPU by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using the monitoring and guest agent sockets provides an additional way of collecting
    more information about the running virtual machines on the libvirt host that we
    can later add as monitoring checks.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring KVM instances with Sensu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sensu is a complete monitoring solution that uses the client-server model; the
    server publishes checks in a message queue provided by the Rabbitmq service. The
    clients/agents subscribe to topics in the queue and execute the specified checks
    on the host they run on. State and historical data is stored in a Redis server.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to install the Sensu server, Rabbitmq message queue,
    and the Redis server on one host, write a simple monitoring check using the information
    we obtained from the *Resource usage collection with libvirt* recipe earlier,
    and install the Sensu agent inside the KVM guest.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux host with libvirt installed and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A KVM instance running on the libvirt host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network connectivity between the KVM instance and the libvirt host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up a new Sensu deployment and define various monitoring checks, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Redis server and ensure that it is responding to requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the Rabbitmq server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the virtual host the Sensu agents will subscribe to and the credentials
    and permissions for the Rabbitmq clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the Sensu upstream repository and its key and then install the Sensu package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sensu uses JSON-based configuration files for its configuration. Create the
    Sensu API configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the transport type for Sensu; we are using Rabbitmq for this deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure where the Rabbitmq service is accepting connections, the virtual
    host, and credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the host and port the Redis service is listening on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the Sensu client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For more information on Sensu, please refer to [https://sensuapp.org/docs/](https://sensuapp.org/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the web frontend for Sensu, named **Uchiwa**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the Uchiwa frontend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Sensu server, API, client, and frontend components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the KVM instance console; install and configure the Sensu client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Replace the IP address of the client with the IP address configured inside the
    KVM instance. Update the IP address of the Rabbitmq server with the IP address
    configured on the host bridge. Ensure that the KVM guest can ping the bridge IP
    on the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Sensu client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the Uchiwa interface and ensure that the host Sensu client and the
    KVM guest Sensu client are listed in the CLIENTS section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Uchiwa frontend showing the connected clients
  prefs: []
  type: TYPE_NORMAL
- en: 'While still connected to the KVM guest, install a memory check from the gem
    repository and test it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Back on the host OS, define the new memory check for the KVM guest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the Sensu components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The memory_check for the KVM instance is now showing in the Uchiwa dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Uchiwa frontend showing the memory check for the KVM guest
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we installed a Sensu server and all the required infrastructure
    components for it to run on the hypervisor host. Then we installed the client
    inside a KVM instance, installed the memory ruby check, and defined it on the
    host. Let's examine all the steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1, we install the Redis server and ensure that it is accepting connections.
    Redis is a key-value store service that Sensu uses to store the historical information
    about the checks, current state, and connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: With the Redis server in place, we proceed to install and configure Rabbitmq
    in steps 2 through 9\. Rabbitmq is a message bus conforming to the **Advanced
    Message Queuing Protocol** (**AMQP**) standard. The Sensu server and clients produce
    and consume messages from the queue to trigger monitoring actions.
  prefs: []
  type: TYPE_NORMAL
- en: Although not required, in steps 10 and 11, we install and configure a web frontend
    for the Sensu server named Uchiwa. We can use the web interface to check on the
    status of different checks for the KVM guests we monitor.
  prefs: []
  type: TYPE_NORMAL
- en: In step 13, we install the Sensu client inside the KVM guest instance and proceed
    to install a memory monitoring script from a gem in step 16\. A monitoring script
    can be written in any language (RUBY in this case) as long as it returns the expected
    error codes that Sensu expects. In the next section, we are going to write a new
    check from scratch using Bash.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw an example of how to use a ruby check inside
    the KVM instance and monitor the memory utilization. Sensu provides standalone
    checks that can be triggered from the Sensu client, independently from the Sensu
    server scheduling mechanism. Let''s use that feature and write a simple check
    in Bash that will run from the host OS, instead of the KVM guest, and use the
    `virsh` command to check the status of a KVM instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a standalone check definition with the custom script that `sensu-client`
    will execute to perform the check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Sensu `plugins` directory, write this simple Bash script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the script executable, add the Sensu user in a `sudoers` file, and test
    the check by executing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the Sensu client on the host; check the logs and the Uchiwa dashboard
    for the new standalone check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Uchiwa frontend showing the standalone instance check
  prefs: []
  type: TYPE_NORMAL
- en: Using the examples from the* Resource usage collection with libvirt* recipe,
    you should now be able to write a variety of Sensu monitoring checks executed
    from the hypervisor or inside the KVM guests.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how Sensu can execute scripts when an alert is triggered,
    please refer to the *handlers* section of the official documentation at [https://sensuapp.org/docs/latest/reference/handlers.html](https://sensuapp.org/docs/latest/reference/handlers.html).
  prefs: []
  type: TYPE_NORMAL
- en: Simple KVM backups with tar and rsync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a backup of a KVM instance using `tar`
    and `rsync` and store it on a remote server. This is the easiest way to backup
    a KVM instance. In the next few recipes, we are going to create snapshots and
    use them as a cold backup.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this extremely simple recipe, we are going to need:'
  prefs: []
  type: TYPE_NORMAL
- en: A libvirt host with a running KVM instance, using an image file as its backing
    store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tar` and `rsync` Linux utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A remote server to transfer the backup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To back up a virtual machine using `tar` and `rsync`, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the backup directory and change to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the location of the image file of the KVM guest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the current instance configuration to disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop the KVM guest and copy the image file to the backup directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a single archive for the VM''s configuration and image files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Transfer the backup archive to a remote server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To restore from the backup, log in to the remote server and extract the archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the image file to the configured location and define the instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating the backup directory in step 1, we save the current guest definition
    to disk in step 3\. In step 4, after stopping the virtual machine, we copy its
    image file to the backup directory. In step 5, we create a bzip2 compressed data
    file which we transfer to a remote server in step 6.
  prefs: []
  type: TYPE_NORMAL
- en: On the remote server, we extract the archive in step 7 and copy the raw image
    file to where the XML definition of the instance is expecting it, then define
    the instance in step 8.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in order to preserve the consistency and integrity of the data while
    copying the image file to the backup directory, we had to first stop the KVM guest.
  prefs: []
  type: TYPE_NORMAL
- en: Creating snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A virtual machine snapshot preserves the current state of a running or stopped instance
    at a specific point in time. It can later be used to restore the instance from
    that point. Snapshots can be used as backups or as templates for building new
    virtual machines that will be copies of the original instance.
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of snapshots, the backing store must first support it. If
    you recall from the *Managing Disk images with qemu-img* recipe in [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM*, we created a raw image type for the KVM guest.
    In this recipe, we are going to use the **QEMU Copy-On-Write** (**QCOW2**) image
    format as the backing store for the KVM instance, because the raw image format
    does not support snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Using the QCOW2 image format, we can create a base image containing the guest
    OS and everything else we need for the virtual machine, and then create several
    copy-on-write overlay disk images on top of the original base image. These new
    overlay images can be used in new virtual machines right away, by creating new
    XML definition files pointing to the new image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of using QEMU to create image overlays before we proceed
    with making libvirt snapshots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To collect information about a QCOW2 image, we can use the `qemu-img` utility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert an existing raw image to QCOW2, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root@kvm:~# qemu-img convert -f raw -O qcow2 /var/lib/libvirt/images/kvm1.img
    /var/lib/libvirt/images/kvm1.qcow2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new overlay image based on the qcow2 preceding image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting information about the new overlay image now shows the backing file
    it''s based on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a new overlay file from the previous overlay file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s list the entire image chain for the last overlay file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Libvirt uses the ability of the QCOW2 image format to create a chain of overlay
    snapshots that can be used as backups or as templates for new virtual machines.
    Once an overlay is created, the original base image is treated as read-only. Modifications
    to the base images (in this example, `kvm1.qcow2` and `kvm1_copy.qcow2` because both
    are base images for the `kvm1_copy_2.qcow2` image) are not recommended. Here''s
    a diagrammatic representation of the chain of overlay image files we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.gif)'
  prefs: []
  type: TYPE_IMG
- en: The chain of overlay QCOW2 images, each one serving as a base image for the
    next
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A libvirt host with an existing QCOW2 image, with no snapshots attached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running KVM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QEMU toolset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new KVM snapshot, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an internal snapshot of the running instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Examine the location of the new snapshot configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Examine the snapshot XML definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Collect information about the base image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain information about the disk device on the virtual machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an external, disk-only snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Get information about the external snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two main types of snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An internal snapshot**: The base image file itself contains the saved state
    and all subsequent changes to the virtual machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An external snapshot**: The base image will contain the saved state of the
    virtual machine thus becoming a read-only base image, and a new overlay image
    is created to track any future changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both types of snapshots can be performed on just the disk or the memory of the
    virtual machine, either on a live or stopped instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding step 1, we create an internal snapshot of the virtual machine.
    After the snapshot, there''s only one image file: the original image, now containing
    the snapshot. We can see that the image is a snapshot in step 4, under the *Snapshot
    list* section of the output.'
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we perform an external, disk-only snapshot, by specifying the virtual
    machine disk, name, and location for the snapshot. Note that after the snapshot,
    a new image file has been created to track any further changes. We examine that
    file in step 7\. Note how the backing file is the original qcow2 image.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the disk snapshots, libvirt leverages the QEMU functionality, like
    the `qemu-img` command we saw earlier when creating the overlay images.
  prefs: []
  type: TYPE_NORMAL
- en: We can now save the snapshots as backups or use them to start new virtual machines.
    In the following recipes, we are going to see examples on how to use and manipulate the
    snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Listing snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we create two snapshots of the same KVM instance: one
    internal and one disk-only, external snapshot. In this recipe, we are going to
    learn how to list existing snapshots.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need:'
  prefs: []
  type: TYPE_NORMAL
- en: A libvirt host with the QEMU toolset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running KVM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The snapshots we created in the *Creating snapshots* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To list all existing snapshots, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List all snapshots for the specified KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'List only the disk-based snapshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'List only the internal snapshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'List the external snapshots only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'List all images in a hierarchical tree format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used the versatile `virsh snapshot-list` command to list all internal and
    external snapshots for the specified virtual machine. Note how we can get similar
    information using the `qemu-img` command directly on the image files, as we saw
    earlier in this chapter. However, the API calls that libvirt provides for listing
    snapshots are much more convenient. In the next chapter, we are going to see examples
    on how to use the libvirt Python bindings to manipulate KVM instances and their
    snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short recipe, we are going to see examples on how to obtain more information
    on existing virtual machine snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A libvirt host with the QEMU toolset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The snapshots we created in the *Creating snapshots* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To inspect a snapshot, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List all available snapshots for the specified KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Get information about the running snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Get information about the disk snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Dump the XML configuration for the disk snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 1, we list all the available snapshots for the kvm1 virtual machine.
    In steps 2 and 3, we obtain information about the snapshots. Of particular interest
    is the `Parent` and `Children` fields, showing us the hierarchy of the snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we examine the XML definition of the KVM guest and the disk-only,
    external snapshot. We can observe the `snapshot='external'` type and the base
    image location specified with the `<source file='/var/lib/libvirt/images/kvm1_disk_external.qcow2'/>`
    stanza.
  prefs: []
  type: TYPE_NORMAL
- en: Editing snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to edit the XML definition of an existing snapshot
    and examine the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A libvirt host with the QEMU toolset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The snapshots we created in the *Creating snapshots* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To edit a snapshot, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List all available snapshots for the specified KVM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the disk snapshot and change its name and description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'List the snapshots after the update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libvirt provides a way to edit the snapshot definition for a virtual machine.
    We can change various XML attributes, such as the snapshot name, description,
    or the location of the backing image file. In step 1, we list all available snapshots
    for the specified KVM instance, then proceed to update the name and description
    of the disk image. Finally, in step 3, we can see the changed name for the external
    snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Reverting snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to create an internal snapshot of a running instance,
    introduce a change, then restore back to the original instance state using the
    snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A libvirt host with an existing QCOW2 image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running KVM instance, using the QCOW2 image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QEMU toolset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To revert the state of a KVM instance to an older state, from an existing snapshot,
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to the KVM instance and create a new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an internal snapshot of the virtual machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Get information about the snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect back to the virtual machine and delete the file we created in step
    1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Restore the instance from the latest snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the virtual machine and confirm that file we deleted in the previous
    step exists again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 1, we connect to the KVM instance using the console and create an empty
    file. We are going to use the file to track changes on the virtual machine. In
    step 2, we create an internal snapshot and obtain more information about it in
    step 3\. In step 4, we connect to the KVM guest again and delete the file. In
    step 5, we restore from the snapshot, confirming that the state of the instance
    has been indeed reverted to before the snapshot, as shown by the presence of the
    original file we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this quick recipe, we are going to delete the snapshots we created earlier
    in the *Creating snapshots* recipe, using libvirt.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are only going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A libvirt host with the QEMU toolset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The snapshots we created in the *Creating snapshots* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To delete a snapshot, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List all snapshots present on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the latest snapshot based on the creation time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'List the remaining snapshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the latest snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 1, we list all snapshots on the host OS. We then delete the latest snapshot,
    specifying its name, in step 2\. In step 3, we verify that the snapshot has been
    indeed deleted. Finally, in step 4, we delete the latest image by specifying the
    *--*current flag.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in order to delete or restore an external snapshot a libvirt
    version newer than 1.2.2 is required. If your Linux distribution does not provide
    a newer version in its repositories, you will have to compile libvirt from source.
  prefs: []
  type: TYPE_NORMAL
