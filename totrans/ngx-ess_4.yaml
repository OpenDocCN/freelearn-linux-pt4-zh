- en: Chapter 4. Rewrite Engine and Access Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 重写引擎与访问控制
- en: The World Wide Web and HTTP as its building block operate in URLs. Since URLs
    are so fundamental, the ability of a server to manipulate URLs is essential.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网及其构建模块HTTP操作基于URL。由于URL如此基础，服务器操作URL的能力至关重要。
- en: Nginx allows you to manipulate URLs using a built-in rewrite engine. The Nginx
    rewrite engine has a broad functionality and is very easy to configure, which
    makes it a very powerful tool. We'll walk through the entire rewrite engine in
    this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx允许你使用内置的重写引擎来操作URL。Nginx的重写引擎功能广泛，配置非常简便，使其成为一个非常强大的工具。在本章中，我们将深入讲解整个重写引擎。
- en: Another topic that we are going to explore in this chapter is access control.
    This is, obviously, an essential function of every software system that keeps
    the system secure and reliable. We'll walk through access control methods available
    in Nginx and explore their subtleties, and you'll learn how to combine them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们还将探讨另一个主题——访问控制。显然，这是每个软件系统中至关重要的功能，它确保系统的安全性和可靠性。我们将逐步介绍Nginx中可用的访问控制方法，并探讨其细节，你将学习如何将它们结合使用。
- en: The basics of the rewrite engine
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写引擎基础
- en: The rewrite engine allows you to manipulate the request URI of inbound requests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 重写引擎允许你操作传入请求的请求URI。
- en: The rewrite engine is configured using rewrite rules. Rewrite rules are used
    when the request URI needs to undergo transformation before further processing.
    Rewrite rules instruct Nginx to match the request URI with a regular expression
    and substitute the request URI with a specified pattern whenever a match has been
    scored.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 重写引擎通过重写规则进行配置。重写规则在请求URI需要进行转换后再进行处理时使用。重写规则指示Nginx使用正则表达式匹配请求URI，并在找到匹配项时将请求URI替换为指定的模式。
- en: Rewrite rules can be specified inside `server`, `location`, and `if` sections
    of the configuration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 重写规则可以在`server`、`location`和`if`配置段中指定。
- en: 'Let''s study some examples of rewrite rules in action. Consider a simple case
    when one resource needs to be substituted by another:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究一些重写规则的应用示例。考虑一个简单的情况，当一个资源需要被另一个资源替代时：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the preceding configuration, every request to `/css/default.css` will have
    its URI rewritten to `/css/styles.css` and will fetch this resource instead. The
    `rewrite` directive specifies a pattern that has to match the request URI in order
    to fire the rule and a substitution string that says how the request URI must
    look after transformation. The third argument, `break`, is a flag that instructs
    Nginx to stop processing rewrite rules once a match for this rule has been scored.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的配置，对`/css/default.css`的每个请求，其URI将被重写为`/css/styles.css`，并改为获取该资源。`rewrite`指令指定一个模式，要求请求URI匹配该模式才能触发规则，并指定一个替换字符串，说明请求URI在转换后应该是什么样子。第三个参数`break`是一个标志，它指示Nginx在找到该规则的匹配项后停止处理重写规则。
- en: 'The preceding configuration can be extended to work with multiple resources
    as well. For that, you need to use captures (round brackets in the first argument)
    and positional parameters (variables with numbers that refer to captures):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置也可以扩展以处理多个资源。为此，你需要使用捕获（第一个参数中的圆括号）和位置参数（指向捕获的带数字的变量）。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the preceding configuration, every request to any CSS file in `/styles/`
    will have its URI rewritten to the corresponding resource in `/css/`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的配置，所有对`/styles/`中任何CSS文件的请求，其URI将被重写为`/css/`中的相应资源。
- en: 'In the last two examples, we used the `break` flag in order to stop rewrite
    rules from processing as soon as a match is found (assuming more rules can be
    added to those configurations). If we want to combine those two examples, we need
    to drop the `break` flag and allow the cascading application of rewrite rules:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个示例中，我们使用了`break`标志，以便在找到匹配项后立即停止重写规则的处理（假设可以向这些配置添加更多规则）。如果我们想将这两个示例结合起来，我们需要去掉`break`标志，并允许重写规则的级联应用：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, every request to style sheets in `/styles/` will be redirected to the corresponding
    resource in `/css/`, and `/css/default.css` will be rewritten to `/css/styles.css`.
    A request to `/styles/default.css` will undergo two rewrites, as it sequentially
    matches both rules.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有对`/styles/`中样式表的请求将被重定向到`/css/`中的相应资源，并且`/css/default.css`将被重写为`/css/styles.css`。对`/styles/default.css`的请求将经历两次重写，因为它依次匹配这两条规则。
- en: Notice that all URI transformations are performed by Nginx internally. This
    means that for an external client, the original URIs return ordinary resources,
    thus the previous configurations will externally look like a series of documents
    with identical content (that is, `/css/default.css` will be identical to `/css/styles.css`).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有的URI转换都是由Nginx内部执行的。这意味着对于外部客户端，原始的URI返回普通资源，因此，之前的配置外部看起来像是一系列内容相同的文档（即，`/css/default.css`将与`/css/styles.css`相同）。
- en: This is not a desirable effect in the case of ordinary web pages, as search
    engines might penalize your website for duplicate content.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通网页来说，这并不是一个理想的效果，因为搜索引擎可能会因重复内容而惩罚你的网站。
- en: 'To avoid this problem, it is necessary to replace copies of a resource with
    permanent redirects to the master resource, as shown in the following configuration:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，必须用永久重定向替换资源的副本，指向主资源，如以下配置所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This works well for whole sections of a website:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于整个网站的部分内容非常有效：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It also works for an entire virtual host:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它也适用于整个虚拟主机：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding configuration for any URL requested performs a permanent redirect
    from a top-level domain `example.com` to the `www` sub domain, making it the primary
    entry point of the website.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配置对于任何请求的URL都执行一个永久重定向，从顶级域名`example.com`重定向到`www`子域名，使其成为网站的主要入口点。
- en: The next powerful application of rewrite rules is translating a semantic URL
    into a URL with a query (section of a URL after the *?* character). This functionality
    has its primary application in **Search Engine Optimization** (**SEO**) and website
    usability, and it is driven by a need to obtain semantic URLs for each and every
    resource and to deduplicate the content.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重写规则的下一个强大应用是将语义化URL转换为带有查询的URL（URL中`?`字符后面的部分）。这种功能在**搜索引擎优化**（**SEO**）和网站可用性方面有重要应用，它源于对每个资源获取语义化URL并去重内容的需求。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information about semantic URLs at [https://en.wikipedia.org/wiki/Semantic_URL](https://en.wikipedia.org/wiki/Semantic_URL).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://en.wikipedia.org/wiki/Semantic_URL](https://en.wikipedia.org/wiki/Semantic_URL)找到更多关于语义化URL的信息。
- en: 'Consider the following configuration:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下配置：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding configuration transforms URLs consisting of a number of path sections
    starting with `/products` into a URL starting with `/products.php` and arguments.
    In this way, it is possible to hide implementation details from users and search
    engines, and generate semantic URLs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配置将由多个路径部分组成的URL（以`/products`开头）转换为以`/products.php`和参数开头的URL。通过这种方式，可以将实现细节对用户和搜索引擎隐藏，并生成语义化URL。
- en: Note that the flags of the rewrite directives are now set to `last`. This makes
    Nginx seek a new location for a rewritten URL and process request with a newly-found
    location.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重写指令的标志现在被设置为`last`。这使得Nginx为重写的URL寻找新的位置，并用新找到的位置处理请求。
- en: Now that you have studied some examples of rewrite rules in action, you can
    learn more about the nitty-gritty details in order to master the rewrite rule.
    The following sections take a deeper look at its syntax and functionality.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了一些重写规则的应用示例，你可以了解更多细节，以掌握重写规则。以下部分将更深入地探讨其语法和功能。
- en: More about rewrite rules
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于重写规则的内容
- en: 'Now, let''s discuss some of interesting details of the rewrite rules. Here''s
    the complete syntax of the `rewrite` directive:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一些关于重写规则的有趣细节。以下是`rewrite`指令的完整语法：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first argument of this directive, `<pattern>`, is a regular expression
    that needs to match the request URI in order to activate the substitution. The
    `<substitution>` argument is a script that is evaluated once a match has been
    scored and the value produced by evaluation replaces the request URI. Special
    variables `$1`...`$9` can be used to cross-reference a pattern and its substitution
    by referring to a capture with the specified position. The `<flag>` argument affects
    the behavior of the `rewrite` directive. The following table lists all possible
    flags of the `rewrite` directive and their functions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令的第一个参数`<pattern>`是一个正则表达式，需要匹配请求的URI才能激活替换。`<substitution>`参数是一个脚本，一旦匹配成功，脚本计算的结果将替换请求URI。可以使用特殊变量`$1`...`$9`通过引用捕获的指定位置来交叉引用模式及其替换。`<flag>`参数会影响`rewrite`指令的行为。下表列出了`rewrite`指令的所有可能标志及其功能：
- en: '| Flag | Function |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 功能 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `break` | Interrupts processing of rewrite rules |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `break` | 中断重写规则的处理 |'
- en: '| `last` | Interrupts processing of rewrite rules and looks up a location for
    the new request URI |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `last` | 中断重写规则的处理，并查找新请求 URI 的位置 |'
- en: '| `redirect` | Returns a temporary redirect (HTTP status `302`) to the new
    request URI |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `redirect` | 返回一个临时重定向（HTTP 状态码 `302`）到新的请求 URI |'
- en: '| `permanent` | Returns a permanent redirect (HTTP status `301`) to the new
    request URI |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `permanent` | 返回一个永久重定向（HTTP 状态码 `301`）到新的请求 URI |'
- en: The rewrite engine makes multiple passes before a location for the request is
    found, and then in the request location and subsequent locations that the request
    is redirected to (such as those that are invoked by the `error_page` directive).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重写引擎会多次处理请求，直到找到请求的位置，然后在请求位置及后续重定向的各个位置进行处理（例如通过 `error_page` 指令调用的那些位置）。
- en: 'Rewrite rules specified directly in the `server` section are processed in the
    first pass, while rewrite rules in the `location`, `if`, and other sections within
    the `server` section are processed at subsequent passes. Consider the following
    example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server` 部分直接指定的重写规则会在第一次处理时处理，而在 `server` 部分内的 `location`、`if` 等其他部分的重写规则将在后续处理时处理。考虑以下示例：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After the first pass is complete, Nginx searches for a location that matches
    the rewritten request URI if a rewrite was performed, or a location that matches
    the original request URI (if no rewrite took place). The subsequent passes alter
    the request URI without changing the location.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次处理完成后，如果进行了重写，Nginx 会搜索与重写请求 URI 匹配的位置，或者搜索与原始请求 URI 匹配的位置（如果没有进行重写）。后续的处理将修改请求
    URI，而不改变位置。
- en: Rewrite rules at each pass are processed in order of appearance. Once a match
    is scored, the substitution is applied and processing resumes with subsequent
    rewrite rules—unless a flag is specified to interrupt processing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每次处理的重写规则按出现的顺序处理。一旦匹配成功，应用替换，并继续处理后续的重写规则——除非指定了中断处理的标志。
- en: If the resulting request URI starts with http:// or https://, it is treated
    as absolute and Nginx returns a temporary (`302` "Found") or a permanent (`301`
    "Moved Permanently") redirect to the resulting location.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果请求 URI 以 http:// 或 https:// 开头，则将其视为绝对路径，Nginx 会返回一个临时（`302` "Found"）或永久（`301`
    "Moved Permanently"）重定向到结果位置。
- en: Patterns
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式
- en: 'Now, let''s go back to the `<pattern>` argument and see how a match pattern
    can be specified. The following table gives a brief overview of regular expression
    syntax used in rewrite rules:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `<pattern>` 参数，看看如何指定匹配模式。下表简要概述了在重写规则中使用的正则表达式语法：
- en: '| Pattern | Examples | Description |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| Pattern | Examples | Description |'
- en: '| --- | --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `<pattern A> <pattern B>` | `Ab, (aa)(bb)` | Following |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `<pattern A> <pattern B>` | `Ab, (aa)(bb)` | 后续 |'
- en: '| `<pattern A> &#124; <pattern B>` | `a&#124;b, (aa)&#124;(bb)` | Alternative
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `<pattern A> &#124; <pattern B>` | `a&#124;b, (aa)&#124;(bb)` | 或者 |'
- en: '| `<pattern>?` | `(\.gz)?` | Option |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `<pattern>?` | `(\.gz)?` | 可选项 |'
- en: '| `<pattern>*` | `A*, (aa)*` | Repetition of `<pattern>` from *0* to *infinity*
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `<pattern>*` | `A*, (aa)*` | `<pattern>`重复从*0*到*无限*次 |'
- en: '| `<pattern>+` | `a+, (aa)+` | Repetition of `<pattern>` from *1* to *infinity*
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `<pattern>+` | `a+, (aa)+` | `<pattern>`重复从*1*到*无限*次 |'
- en: '| `<pattern>{n}` | `a{5}, (aa){6}` | Repetition of `<pattern>` *n* times |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `<pattern>{n}` | `a{5}, (aa){6}` | `<pattern>`重复*n*次 |'
- en: '| `<pattern>{n,}` | `a{3,}, (aa){7,}` | Repetition of `<pattern>` from *n*
    to *infinity* |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `<pattern>{n,}` | `a{3,}, (aa){7,}` | `<pattern>`重复从*n*到*无限*次 |'
- en: '| `<pattern>{,m}` | `a{,6}, (aa){,3}` | Repetition of `<pattern>` from *0*
    to *m* |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `<pattern>{,m}` | `a{,6}, (aa){,3}` | `<pattern>`重复从*0*到*m*次 |'
- en: '| `<pattern>{n,m}` | `a{5,6}, (aa){1,3}` | Repetition of `<pattern>` from *n*
    to *m* |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `<pattern>{n,m}` | `a{5,6}, (aa){1,3}` | `<pattern>`重复从*n*到*m*次 |'
- en: '| `( <pattern> )` | `(aa)` | Grouping or parameter capture |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `( <pattern> )` | `(aa)` | 分组或参数捕获 |'
- en: '| `.` | `.+` | Any character |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `.` | `.+` | 任意字符 |'
- en: '| `^` | `^/index` | Start of line |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `^` | `^/index` | 行的开始 |'
- en: '| `$` | `\.php$` | End of line |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `$` | `\.php$` | 行的结束 |'
- en: '| `[<characters>]` | `[A-Za-z]` | Any character from the specified set |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `[<characters>]` | `[A-Za-z]` | 来自指定集合的任意字符 |'
- en: '| `[^<characters>]` | `[^0-9]` | Any character outside of the specified set
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `[^<characters>]` | `[^0-9]` | 来自指定集合之外的任意字符 |'
- en: The patterns are listed in increasing priority order. That is, the pattern `aa|bb`
    will be interpreted as `a(a|b)b`, while the pattern `a{5}aa{6}` will be interpreted
    as `(a{5})(a)(a{6})` and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式按优先级递增的顺序列出。也就是说，模式 `aa|bb` 将被解释为 `a(a|b)b`，而模式 `a{5}aa{6}` 将被解释为 `(a{5})(a)(a{6})`，以此类推。
- en: To specify characters that are themselves part of regular expression syntax,
    you can use the backslash character `\`, for example `\*` will match an asterisk
    `*`, `\.` will match a dot character `.`, `\\` will match the backslash character
    itself and `\{` will match an opening curly bracket `{`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定正则表达式语法本身的字符，可以使用反斜杠字符 `\`，例如 `\*` 会匹配星号 `*`，`\.` 会匹配点字符 `.`，`\\` 会匹配反斜杠字符本身，`\{`
    会匹配左花括号 `{`。
- en: More information about regular expression syntax in rewrite rules can be found
    on the PCRE website [www.pcre.org](http://www.pcre.org).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于重写规则中的正则表达式语法信息可以在 PCRE 网站 [www.pcre.org](http://www.pcre.org) 找到。
- en: Captures and positional parameters
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获和位置参数
- en: 'Captures are designated with round brackets and mark sections of matched URLs
    that need to be extracted. Positional parameters refer to substrings of the matched
    URLs extracted by corresponding capture, that is, if the pattern is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获使用圆括号标记，并标记需要提取的匹配 URL 部分。位置参数指的是由相应捕获提取的匹配 URL 的子字符串，也就是说，如果模式如下：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, if the request URL is like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果请求 URL 如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The positional parameters `$1` and `$2` will evaluate to `id` and `23850`, respectively.
    Positional parameters can be used in any order within the substitution string
    and this is how you connect it with the match pattern.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数 `$1` 和 `$2` 将分别评估为 `id` 和 `23850`。位置参数可以在替换字符串中按任意顺序使用，这就是如何将其与匹配模式连接起来的。
- en: Other functionalities of the rewrite engine
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写引擎的其他功能
- en: 'The rewrite engine can also be used to perform other tasks:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重写引擎还可以用于执行其他任务：
- en: Assigning variables
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值变量
- en: Evaluating predicates using the `if` directive
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `if` 指令评估谓词
- en: Replying with specified HTTP status code
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指定的 HTTP 状态码回复
- en: A combination of these operations and rewrite rules can be performed at every
    pass of the rewrite engine. Note that `if` sections are separate locations, so
    it is still possible that the location will change at the location rewrite pass.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作和重写规则的组合可以在每次重写引擎处理时执行。请注意，`if` 部分是独立的位置，因此在位置重写处理时，位置仍然可能发生变化。
- en: Assigning variables
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值变量
- en: 'Variables can be assigned using the `set` directive:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以使用 `set` 指令进行赋值：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Variable values can be scripts with text and other variables:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 变量值可以是包含文本和其他变量的脚本：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once set on the rewrite phase, variables can be used in any directive in the
    rest of the configuration file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在重写阶段设置，变量可以在配置文件的其他指令中使用。
- en: Evaluating predicates using if sections
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 if 部分评估谓词
- en: 'You have probably figured out from the title that `if` sections are part of
    the rewrite engine. This is true. The `if` sections can be used to conditionally
    apply selected rewrite rules:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从标题中已经知道，`if` 部分是重写引擎的一部分。确实如此。`if` 部分可以用于有条件地应用选定的重写规则：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding configuration, any attempt to make a POST request to the URL
    `/media/` will result in rewriting it to the URL `/upload`, while requests with
    other methods to the same URL will result in no rewrites. Multiple conditions
    can also be combined. Let''s look at the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述配置中，任何尝试向 URL `/media/` 发送 POST 请求的操作都会将其重写为 URL `/upload`，而对相同 URL 发送其他方法的请求则不会发生重写。多个条件也可以组合在一起。让我们来看一下以下代码：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding configuration applies the rewrite only when both `if` conditions
    are fulfilled, that is, when the request method is `POST` and the request URL
    scheme is `https`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前述配置仅在满足 `if` 条件时才会应用重写，即请求方法为 `POST` 且请求 URL 协议为 `https` 时。
- en: 'Now that you know how you can use the `if` section, let''s talk about its side
    effects. Remember that conditions in the `if` directives are evaluated in the
    course of the `rewrite` directive processing. What it means is that when the `if`
    section contains directives that are not part of the rewrite engine, the behavior
    of the `if` section becomes non-intuitive. This was discussed in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Nginx"), *Getting Started with Nginx*. Consider
    the following configuration:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用 `if` 部分，我们来谈谈它的副作用。记住，`if` 指令中的条件在处理 `rewrite` 指令时会被评估。这意味着当 `if`
    部分包含不属于重写引擎的指令时，`if` 部分的行为变得不直观。这个问题在 [第1章](ch01.html "第1章. Nginx入门")，*Nginx入门*
    中进行了讨论。请考虑以下配置：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each individual `if` section contains an atomic set of configuration settings.
    Assume Nginx receives a `POST` request with the `https` URL scheme such that both
    conditions evaluate to true. All `set` directives will be correctly processed
    by the rewrite engine and will be assigned to proper values. However, Nginx cannot
    merge other configuration settings and cannot have multiple configurations active
    at once. When rewrite processing is finished, Nginx simply switches configuration
    to the last `if` section with its conditions evaluated to true. Because of that,
    in the preceding configuration, compression will be switched on but the request
    will not be proxied according to `proxy_pass` directive. This is not something
    you might expect.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的`if`部分包含一组原子配置设置。假设 Nginx 收到一个使用`https` URL 方案的`POST`请求，并且两个条件都评估为真。所有的`set`指令都会被重写引擎正确处理，并且会被赋予正确的值。然而，Nginx
    无法合并其他配置设置，也不能同时启用多个配置。当重写处理完成后，Nginx 会简单地将配置切换到最后一个条件评估为真的`if`部分。因此，在前面的配置中，压缩会被启用，但请求不会按照`proxy_pass`指令进行代理。这是一个你可能没有预料到的情况。
- en: 'To avoid this non-intuitive behavior, stick to the following best practices:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种不直观的行为，请遵循以下最佳实践：
- en: Minimize the usage of the `if` directive
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化使用`if`指令
- en: Combine the `if` evaluations using the `set` directive
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`set`指令结合`if`评估
- en: Take actions only in the last `if` section.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在最后一个`if`部分采取行动。
- en: Replying with a specified HTTP status code
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指定的 HTTP 状态码进行回复
- en: 'If a definite reply with a specified HTTP status code is required in a certain
    location, you can use the `return` directive to enable this behavior and specify
    the status code, a reply body, or a redirect URL. Let''s look at the following
    code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个位置需要明确回复指定的 HTTP 状态码，可以使用`return`指令来启用这种行为，并指定状态码、回复体或重定向 URI。我们来看以下代码：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding configuration will execute a permanent redirect (301) to the secure
    part of domain `www.example.com` and the URI path identical to the URI path in
    the original request. Thus, the second argument of the `return` directive will
    be treated as a redirect URI. The other status codes that treat the second argument
    of the `return` directive as a redirect URI are `302`, `303` and `307`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置将执行一个永久重定向（301），将域名`www.example.com`重定向到安全部分，URI 路径与原请求中的 URI 路径相同。因此，`return`指令的第二个参数会被当作重定向
    URI。其他将第二个参数视为重定向 URI 的状态码包括`302`、`303`和`307`。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Performing a redirect with the `return` directive is much faster than doing
    so with the `rewrite` directive, because it does not run any regular expressions.
    Use the `return` directive in your configuration instead of the `rewrite` directive
    whenever possible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`return`指令进行重定向比使用`rewrite`指令更快，因为它不需要运行任何正则表达式。在配置中尽可能使用`return`指令，而不是`rewrite`指令。
- en: 'The status code 302 is quite common, so the `return` directive has a simplified
    syntax for temporary redirects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码 302 是相当常见的，因此`return`指令对于临时重定向有简化的语法：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, if the `return` directive has a single argument, it is treated
    as redirect URI and makes Nginx perform a temporary redirect. This argument must
    start from `http`:// or `https://` to trigger such behavior.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果`return`指令只有一个参数，它会被当作重定向 URI，且会让 Nginx 执行一个临时重定向。这个参数必须以`http`://或`https`://开头，才能触发这种行为。
- en: 'The `return` directive can be used to return a reply with a specified body.
    To trigger such behavior, the status code must simply be other than `301`, `302`,
    `303` or `307`. The second argument of the `return` directive specified the content
    of the response body:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`指令可以用来返回带有指定主体的回复。要触发这种行为，状态码必须是`301`、`302`、`303`或`307`以外的其他值。`return`指令的第二个参数指定响应体的内容：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding configuration will return HTTP status 200 (OK) with the specified
    response body. To assert correct processing of the body content, we set response
    content type to `text/plain` using the `default_type` directive.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置会返回 HTTP 状态 200（OK）并带有指定的响应体。为了确保响应体内容被正确处理，我们通过`default_type`指令将响应内容类型设置为`text/plain`。
- en: Access control
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制
- en: Access control restrictions are essential to day-to-day operation. Nginx includes
    a group of modules that let you allow or deny access depending on various conditions.
    Nginx denies access to a resource by returning a `403` (Forbidden HTTP) status
    or 401 (Unauthorized) if accessing the resource requires authentication. This
    403 (Forbidden) status code can be intercepted and customized using the `error_page`
    directive.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制限制对日常运营至关重要。Nginx 包含一组模块，让您根据各种条件允许或拒绝访问。如果访问资源需要认证，则 Nginx 通过返回 `403`（禁止
    HTTP）状态或者需要认证的情况下返回 `401`（未经授权）来拒绝访问。可以使用 `error_page` 指令拦截和自定义这个 `403`（禁止）状态码。
- en: Restricting access by IP address
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 IP 地址限制访问
- en: 'Nginx allows you to permit or deny access to a virtual host or a location by
    IP address. For that, you can use the directives `allow` and `deny`. They have
    the following format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 允许您通过 IP 地址允许或拒绝对虚拟主机或位置的访问。为此，您可以使用 `allow` 和 `deny` 指令。它们的格式如下：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Specifying an IP address allows or denies access to a single IP address within
    a location, while specifying an IP address with a prefix size (for example 192.168.0.0/24
    or 200.1:980::/32) allows or denies access to a range of IP addresses.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一个 IP 地址允许或拒绝在位置内访问单个 IP 地址，而指定一个带有前缀大小的 IP 地址（例如 192.168.0.0/24 或 200.1:980::/32）允许或拒绝访问一个范围的
    IP 地址。
- en: The `allow` and `deny` directives are processed in order of appearance within
    a location. The remote IP address of a requesting client is matched against the
    argument of each directive. Once an `allow` directive with a matching address
    is found, access is immediately allowed. Once a `deny` directive with a matching
    address is found, access is immediately denied. Once Nginx reaches the `allow`
    or `deny` directive with the `all` argument, access is immediately allowed or
    denied, regardless of client's IP address.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`allow` 和 `deny` 指令按照它们在一个位置中出现的顺序进行处理。请求客户端的远程 IP 地址将与每个指令的参数进行匹配。一旦找到一个匹配地址的
    `allow` 指令，访问将立即被允许。一旦找到一个匹配地址的 `deny` 指令，访问将立即被拒绝。一旦 Nginx 到达具有 `all` 参数的 `allow`
    或 `deny` 指令，访问将立即被允许或拒绝，不论客户端的 IP 地址如何。'
- en: 'This, obviously, allows some variation. Here are some simple examples:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然允许一些变化。以下是一些简单的例子：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding configuration makes Nginx deny access to IP addresses 192.168.1.0
    to 192.168.1.255, while allowing access to everyone else. This happens because
    the `deny` directive is processed first and if matched, is immediately applied.
    The entire server will be forbidden for specified IP addresses.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置使得 Nginx 拒绝对 IP 地址 192.168.1.0 到 192.168.1.255 的访问，同时允许其他所有人的访问。这是因为 `deny`
    指令首先被处理，如果匹配，则立即应用。整个服务器将对指定的 IP 地址禁止访问。
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding configuration makes Nginx allow access to `location /admin` only
    to IP addresses in the range 10.132.3.0 to 10.132.3.255\. Assuming this range
    of IP addresses corresponds to some privileged group of users, this configuration
    makes perfect sense, as only they can access the administrative area of this web
    application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置使得 Nginx 仅允许访问`location /admin`的 IP 地址位于 10.132.3.0 到 10.132.3.255 的范围内。假设这些
    IP 地址对应于某些特权用户组，这种配置完全合理，因为只有他们可以访问这个 Web 应用的管理区域。
- en: 'Now, we can improve on that and make the configuration more complicated. Assume
    that more networks need access to this web application''s administrative interface,
    while the IP address 10.132.3.55 needs to be denied access due to technical or
    administrative reasons. Then, we can extend the preceding configuration as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以改进这个配置，使得配置更加复杂。假设更多网络需要访问这个 Web 应用的管理界面，而 IP 地址 10.132.3.55 因技术或行政原因需要被拒绝访问。那么，我们可以扩展前面的配置如下：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the directives `allow` and `deny` are quite intuitive to use.
    Use them as long as the list of IP addresses to match is not too long. Nginx processes
    these directives in sequential order, so the time taken to check the client's
    IP address against the list is on average proportional to the length of the list
    no matter which directive the address is matched against.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`allow` 和 `deny` 指令使用起来非常直观。只要匹配的 IP 地址列表不太长，就可以使用它们。Nginx 按顺序处理这些指令，因此检查客户端
    IP 地址与列表匹配的时间平均与列表的长度成正比，不论地址匹配哪个指令。
- en: If you need to match client's IP address against a larger list of addresses,
    consider using the `geo` directive.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将客户端的 IP 地址与更大的地址列表进行匹配，考虑使用 `geo` 指令。
- en: Using the geo directive to restrict access by IP address
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 geo 指令限制 IP 地址访问
- en: With the `geo` directive, you can transform an IP address into a literal or
    numerical value that can later be used to trigger some actions while processing
    a request.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`geo`指令，你可以将IP地址转换为一个字面量或数字值，随后在处理请求时触发一些操作。
- en: 'The `geo` directive has the following format:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`geo`指令的格式如下：'
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the source variable is omitted, the `$remote_addr` variable is used instead.
    The address mapping is a list of key/value pairs, separated by whitespace. A key
    is usually an IP address or an IP address with a prefix size specifying a subnet.
    A value is an arbitrary string of character or a number. Let''s look at the following
    code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略源变量，则使用`$remote_addr`变量。地址映射是一个由空格分隔的键值对列表。键通常是一个IP地址或带前缀大小的IP地址，表示子网。值可以是任意的字符串或数字。让我们看看以下代码：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The value of the source variable is used as a key to look up an entry in the
    address mapping. Once found, the target variable is assigned to the looked-up
    value. Otherwise, the default value is used.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 源变量的值作为关键字在地址映射中查找条目。如果找到对应的条目，则将目标变量赋值为查找到的值；否则，使用默认值。
- en: With the preceding configuration, the variable `$admin_access` will be assigned
    the value `allow` if the remote client's IP address originates from the subnet
    10.129.1.0/24, 10.144.25.0/24 or 10.132.3.0/24, and `deny` otherwise.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述配置下，如果远程客户端的IP地址来自子网10.129.1.0/24、10.144.25.0/24或10.132.3.0/24，则变量`$admin_access`将被赋值为`allow`，否则赋值为`deny`。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `geo` directive builds an efficient succinct data structure to look up the
    values by IP address in memory. It can handle hundreds of thousands of IP addresses
    and subnets. To accelerate the startup time, specify IP addresses to the `geo`
    directive in ascending order, for example, 1.x.x.x to 10.x.x.x, 1.10.x.x to 1.30.x.x.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`geo`指令构建了一个高效、简洁的数据结构，通过IP地址在内存中查找值。它能够处理成千上万的IP地址和子网。为了加速启动时间，可以按升序指定IP地址，例如，1.x.x.x到10.x.x.x，1.10.x.x到1.30.x.x。'
- en: 'The address mapping section can contain directives that affect the behavior
    of `geo` address mapping. The following table lists those directives along with
    their functions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 地址映射部分可以包含影响`geo`地址映射行为的指令。下表列出了这些指令及其功能：
- en: '| Directive | Function |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 功能 |'
- en: '| --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `default` | Specifies a value that is returned when no match is found in
    the IP address mapping. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `default` | 指定当在IP地址映射中未找到匹配项时返回的值。|'
- en: '| `proxy` | Specifies the address of a proxy server. If a request originates
    from an address specified by one of the `proxy` directives, `geo` will use the
    last address from the "X-Forwarded-For" header and not from the source variable.
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `proxy` | 指定代理服务器的地址。如果请求来自某个`proxy`指令指定的地址，`geo`将使用"X-Forwarded-For"头中的最后一个地址，而不是来源变量中的地址。|'
- en: '| `proxy_recursive` | If a request originates from an address specified by
    one of `proxy` directives, `geo` will process addresses in the "X-Forwarded-For"
    header from right-to-left in search of an address outside of the list specified
    by the `proxy` directive. In other words, this directive makes `geo` make a better
    effort in the search for a real IP address. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_recursive` | 如果请求来自某个`proxy`指令指定的地址，`geo`将从右到左处理"X-Forwarded-For"头中的地址，寻找一个位于`proxy`指令指定的地址列表之外的地址。换句话说，这个指令让`geo`更努力地寻找真实IP地址。|'
- en: '| `ranges` | Enables IP address ranges in the mapping list. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `ranges` | 在映射列表中启用IP地址范围。|'
- en: '| `delete` | Removes the specified sub network from the mapping. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `delete` | 从映射中移除指定的子网。|'
- en: Let's take a look at some examples.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些示例。
- en: 'Consider Nginx receives HTTP traffic from an application-level load balancer
    or an inbound proxy located at IP 10.200.0.1\. Since all requests will originate
    from this IP, we need to examine the "X-Forwarded-For" header in order to obtain
    the real IP address of the client. We then need to change the preceding configuration
    as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Nginx接收来自应用级负载均衡器或位于IP 10.200.0.1的入站代理的HTTP流量。由于所有请求都将来自此IP，我们需要检查"X-Forwarded-For"头，以便获得客户端的真实IP地址。然后，我们需要将前述配置修改如下：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the server is behind a chain of proxies, the real IP address can be obtained
    by specifying the `proxy_recursive` directive and listing all proxies in the chain:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器位于多个代理链之后，可以通过指定`proxy_recursive`指令并列出链中的所有代理来获得真实的IP地址：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, proxies have IP addresses 10.200.0.1, 10.200.1.1 and
    10.200.2.1\. The order the addresses are listed in is not important, as Nginx
    simply iterates over the addresses specified in the "X-Forwarded-For" header from
    right-to-left and checks their presence in the `geo` block. The first address
    outside of the proxy list becomes the real IP address of the client.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，代理的IP地址是10.200.0.1、10.200.1.1和10.200.2.1。地址的顺序并不重要，因为Nginx会从右到左遍历"X-Forwarded-For"头部中指定的地址，并检查它们是否存在于`geo`块中。第一个不在代理列表中的地址将成为客户端的真实IP地址。
- en: 'If IP addresses need to be specified as ranges instead or in addition to subnets,
    you can enable this by specifying the `ranges` directive:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要指定IP地址作为范围而非子网，或者在子网之外，你可以通过指定`ranges`指令来启用此功能：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, with the help of the `delete` directive, we can define the IP address
    mapping that allows us to implement an access control procedure analogous to allow
    and deny directives on a larger scale:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`delete`指令的帮助下，我们可以定义允许我们实现类似于`allow`和`deny`指令的大规模访问控制过程的IP地址映射：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To put this configuration in action, we need to use the `if` section to forbid
    request those client''s IP address do not fall in the `allow` range of the `geo`
    directive:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个配置生效，我们需要使用`if`部分来禁止那些客户端IP地址不在`geo`指令`allow`范围内的请求：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the `geo` directive is a powerful and very scalable tool, and
    access restriction is one of many applications that it can be put to.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`geo`指令是一个强大且高度可扩展的工具，而访问限制是它可以应用的众多用途之一。
- en: Using basic authentication for access restriction
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基本认证进行访问限制
- en: 'You can configure Nginx to allow access only to those users who can provide
    the correct combination of a username and a password. Username/password verification
    is enabled using the `auth_basic` directive:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置Nginx只允许那些能够提供正确的用户名和密码组合的用户访问。用户名/密码验证可以通过`auth_basic`指令启用：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Realm name specifies the name of a realm (an authenticated area). This argument
    is usually set to a string that helps users to identify the area they are trying
    to access (for example *Administrative area*, *Web mail*, and so on). This string
    will be passed to the browser and displayed in the username/password entry dialog.
    In addition to the realm name, you need to specify a file containing a user database
    using the `auth_basic_user_file` directive:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Realm名称指定了一个领域的名称（即认证区域）。这个参数通常设置为一个帮助用户识别他们正在尝试访问的区域的字符串（例如 *行政区*, *Web 邮件*
    等）。这个字符串会传递到浏览器，并在用户名/密码输入对话框中显示。除了Realm名称外，你还需要使用`auth_basic_user_file`指令指定一个包含用户数据库的文件：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This file must contain authentication information with a username and a password
    in each line:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件必须包含每行一个用户名和密码的认证信息：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This file presumably must be placed outside of document root of any website
    you are hosting. The access rights must be set up such that Nginx can only read
    this file, never write or execute.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件应该放置在你托管的任何网站的文档根目录之外。访问权限必须设置为使得Nginx只能读取该文件，而不能写入或执行它。
- en: 'Passwords must be encrypted using one of the following algorithms:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 密码必须使用以下算法之一进行加密：
- en: '| Algorithms | Comments |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 备注 |'
- en: '| --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| CRYPT | Unix DES-based password encryption algorithm |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| CRYPT | Unix DES加密密码算法 |'
- en: '| SSHA | Salted Secure Hash Algorithm 1 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| SSHA | 加盐安全哈希算法 1 |'
- en: '| *Deprecated: Do not use* |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| *已废弃：请勿使用* |'
- en: '| MD5 | Message Digest 5 algorithm |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| MD5 | 消息摘要算法 5 |'
- en: '| SHA | Unsalted Secure Hash Algorithm 1 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| SHA | 无盐安全哈希算法 1 |'
- en: 'The password file can be managed using the `htpasswd` utility from Apache web
    server. Here are some examples:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 密码文件可以使用来自Apache web服务器的`htpasswd`工具进行管理。以下是一些示例：
- en: '| Instruction | Command |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 命令 |'
- en: '| --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create a password file and add user `john` to the password file | `$ htpasswd
    -b -d -c /etc/nginx/auth.d/auth.pwd john test` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个密码文件并将用户`john`添加到密码文件中 | `$ htpasswd -b -d -c /etc/nginx/auth.d/auth.pwd
    john test` |'
- en: '| Add user `thomas` to the password file | `$ htpasswd -b -d /etc/nginx/auth.d/auth.pwd
    thomas test` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 将用户`thomas`添加到密码文件中 | `$ htpasswd -b -d /etc/nginx/auth.d/auth.pwd thomas
    test` |'
- en: '| Replace John''s password | `$ htpasswd -b -d /etc/nginx/auth.d/auth.pwd john
    test` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 替换John的密码 | `$ htpasswd -b -d /etc/nginx/auth.d/auth.pwd john test` |'
- en: '| Remove user `john` from the password file | `$ htpasswd -D /etc/nginx/auth.d/auth.pwd
    john` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 从密码文件中删除用户`john` | `$ htpasswd -D /etc/nginx/auth.d/auth.pwd john` |'
- en: 'The option `-d` forces encryption of passwords using the CRYPT algorithm, which
    is relatively less secure than SSHA (Salted SHA). To encrypt passwords using SSHA
    and achieve higher security of your passwords you can use the `slappasswd` utility
    from the `slapd` package:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 `-d` 强制使用 CRYPT 算法加密密码，这比 SSHA（盐化 SHA）算法相对不安全。要使用 SSHA 加密密码并提高密码的安全性，你可以使用
    `slappasswd` 工具，它来自 `slapd` 包：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Copy the output of `slappasswd` into the password file. The password file now
    looks like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `slappasswd` 的输出复制到密码文件中。密码文件现在看起来像这样：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This can be further automated using the `echo` command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 `echo` 命令进一步自动化：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the password file is ready, we can configure password authentication:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦密码文件准备好，我们可以配置密码认证：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Password authentication is now enabled; you can navigate to `location /admin`
    and see the password prompt:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 密码认证现在已启用；你可以导航到 `location /admin` 并看到密码提示：
- en: '![Using basic authentication for access restriction](img/B04282_04_01.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![使用基本认证进行访问限制](img/B04282_04_01.jpg)'
- en: Access to the protected resource will be granted only when a valid combination
    of username and password is entered into the password prompt.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在输入有效的用户名和密码组合时，才能访问受保护的资源。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Nginx reads and parses the password file every time a request to protected resources
    is made. This is scalable only when the number of entries in the password file
    does not exceed a few hundred.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 每次请求受保护资源时都会读取并解析密码文件。只有当密码文件中的条目数不超过几百时，这种方式才具有可扩展性。
- en: Authenticating users with a subrequest
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子请求进行用户认证
- en: 'User authentication can be delegated to another web server using the auth request
    module. This module must first be enabled at the source code configuration stage
    using the `–with-http_auth_request_module` command-line switch:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 用户认证可以通过使用认证请求模块委托给另一个 Web 服务器。此模块必须首先在源代码配置阶段启用，使用命令行选项 `–with-http_auth_request_module`：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now the `auth_request` module is ready to be used. The delegation can be configured
    as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `auth_request` 模块已准备好使用。委托可以按以下方式配置：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With the preceding configuration, Nginx will execute a subrequest to `location
    /auth`. This location will pass the subrequest to an external web application
    (using the `proxy_pass` directive). As the original request might have a request
    body that the authentication application does not expect, we discard it by specifying
    `proxy_pass_request_body off` and nullifying the "Content-Length" header using
    `proxy_set_header`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，Nginx 将执行一个子请求到 `location /auth`。这个位置会将子请求传递给外部 Web 应用程序（使用 `proxy_pass`
    指令）。由于原始请求可能包含认证应用程序不期望的请求体，因此我们通过指定 `proxy_pass_request_body off` 并使用 `proxy_set_header`
    来清除 "Content-Length" 头部，从而丢弃它。
- en: 'In order to reply to a subrequest issued by auth request module, you need to
    create an application that analyzes data from the original request and replies
    with HTTP status 401 (Unauthorized) or 403 (Forbidden) in order to block access,
    and with a successful HTTP status 200 to 299 in order to allow access. Here is
    an example of such an application in `node.js`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回应由认证请求模块发出的子请求，你需要创建一个应用程序，该应用程序分析原始请求中的数据，并通过 HTTP 状态 401（未授权）或 403（禁止）来阻止访问，通过成功的
    HTTP 状态 200 到 299 来允许访问。以下是一个用 `node.js` 编写的示例应用程序：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This application allows access as long a cookie names `uid` is present, and
    forbids access otherwise.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序只要存在名为 `uid` 的 cookie 就允许访问，否则禁止访问。
- en: 'To run this application, create a directory, create a file named `auth.js`
    in this directory, and put the preceding source code into this file. After that,
    install the required modules `express` and `cookie-parser` using `npm`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此应用程序，创建一个目录，在该目录中创建一个名为 `auth.js` 的文件，并将前面的源代码放入此文件中。然后，使用 `npm` 安装所需的模块
    `express` 和 `cookie-parser`：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, you can run the application:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以运行应用程序：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The application will start listening on port 3000\. The following Nginx configuration
    can be used in order to try the application:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将开始监听 3000 端口。以下 Nginx 配置可以用来尝试该应用程序：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The subrequest will be delegated to port 3000 of the host, where Nginx is running,
    and the application will reply to that request.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 子请求将被委派到运行 Nginx 的主机的 3000 端口，应用程序会对此请求做出回应。
- en: 'If the application needs to examine the original request URI, it can be passed
    using the `proxy_set_header` directive:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序需要检查原始请求 URI，可以通过 `proxy_set_header` 指令传递：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The original IP address and other original request parameters can be passed
    to the authenticating application in the same way.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 IP 地址和其他原始请求参数可以以相同的方式传递给认证应用程序。
- en: This is how more sophisticated authentication logic can be implemented in Nginx.
    If you make the application always reply with HTTP status 200, it can be used
    for purposes other than authentication, such as logging or data injection.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何在 Nginx 中实现更复杂的认证逻辑。如果你让应用程序始终以 HTTP 状态 200 响应，它可以用于认证以外的其他目的，例如日志记录或数据注入。
- en: Combining multiple access restriction methods
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合多种访问限制方法
- en: Multiple access restriction methods can be combined together. For that, they
    must be both configured and enabled. By default, all configured access restriction
    methods must be satisfied in order to allow the request. If any of the access
    restriction methods are not satisfied, Nginx rejects the request with 403 Forbidden
    HTTP status.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将多种访问限制方法组合在一起。为此，必须同时配置并启用它们。默认情况下，必须满足所有配置的访问限制方法才能允许请求。如果任何访问限制方法未满足，Nginx
    会以 403 Forbidden HTTP 状态拒绝请求。
- en: 'This behavior can be changed using the `satisfy` directive:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`satisfy`指令来更改此行为：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Specifying `satisfy any` in a location makes Nginx accept the request if any
    of the enabled access restriction methods are satisfied, while specifying `satisfy
    all` (the default) makes Nginx accept the request only if all enabled access restriction
    methods are satisfied. To demonstrate how it works, let''s extend the preceding
    example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个位置中指定`satisfy any`，会使 Nginx 在满足任何启用的访问限制方法时接受请求，而指定`satisfy all`（默认设置）则会使
    Nginx 仅在所有启用的访问限制方法都满足时才接受请求。为了演示其工作原理，让我们扩展前面的示例：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This configuration enables and configures both password authentication and IP
    address restriction. With `satisfy` set to `any`, a user needs to either enter
    a correct username/password combination or originate from IP address range 10.132.3.0
    to 10.132.3.255\. This makes users from this network somehow more trusted, as
    they are not required to enter their username and password in order to access
    the administrative area.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置启用并配置了密码认证和 IP 地址限制。将`satisfy`设置为`any`时，用户只需要输入正确的用户名/密码组合，或来源于 IP 地址范围 10.132.3.0
    至 10.132.3.255。这样，来自该网络的用户被视为更为可信，因为他们不需要输入用户名和密码即可访问管理区域。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use the rewrite engine and access control
    functions. These are essential tools of every web master and site reliability
    engineer. Excelling in configuring and using these features will help you to solve
    day-to-day problems more efficiently.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了如何使用重写引擎和访问控制功能。这些是每个网站管理员和站点可靠性工程师的必备工具。精通这些功能的配置和使用，将帮助你更高效地解决日常问题。
- en: In the next chapter, we will talk about managing inbound and outbound traffic.
    You will learn how to set various limitations on inbound traffic, how to configure
    upstream, and how to apply various options to outbound traffic.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论如何管理进出流量。你将学习如何设置进站流量的各种限制，如何配置上游，以及如何为出站流量应用各种选项。
