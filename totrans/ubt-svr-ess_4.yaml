- en: Chapter 4. Security with Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the field of computer servers, security is a very hot key. That''s why,
    Ubuntu Server gives it a lot of importance. In this chapter, we will take a look
    at how to activate, configure, and enhance a lot of security aspects. This chapter
    will be divided into the following three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a basic security level for Ubuntu Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going in depth to see how to configure advanced security settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a backup/restore procedure for the whole Ubuntu Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic security settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, let's have a look at how to set up a basic security level for
    Ubuntu Server. There is a saying in security circles that *security is a process,
    not a product*. What this means is that despite what your vendor might tell you,
    you can't solve all your security problems with some application or software.
    Instead, you will find real security when you start to follow good security principles
    and develop good security procedures. This is what we will mainly see in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Managing users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you will discover best practices in terms of user management,
    which covers not only user creation, modification, and deletion, but also group
    attribution, permissions, and a lot of other details.
  prefs: []
  type: TYPE_NORMAL
- en: User account administration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the most useful commands that are required to set up and
    manage user accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useradd`: This command adds the user that was passed in as a parameter to
    the local authentication system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usermod`: This command modifies the properties of the user passed in as a
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userdel`: This command properly deletes from a system the user passed in as
    a parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`passwd`: This command modifies the passwords for a user passed in as a parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add some options to those commands, those options are listed and detailed
    using -for example for the case of `useradd-` either `man useradd` or `useradd
    --help`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There exists the `adduser` command that also allows you to create new users.
    The difference between `useradd` and `adduser` depends on the Linux distribution.
    For example, for Fedora/Centos/Gentoo, `adduser` is just a symbolic link to `useradd`.
    But in our case, on Debian or Ubuntu systems, `useradd` is the command itself,
    and you can create users and define options for these users by using it. On the
    other hand, `adduser` is a Perl script that uses `useradd` to create an account
    and asks you for a password, your full name, phone number, and other information.
    We can say that in this case, it simplifies things for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the most important options that you need to take into account
    when creating a new user, especially for security reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-m`: Use this option during the creation of a home directory for the user
    that needs to be created. Without it, you''d have to create a new directory, change
    its ownership and permissions that fit the needs of the user, put within it the
    default files and directories that should exist under a home directory, and then
    assign the default directories and files to the home directory by using the `usermod`
    command with the `-d` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e date`: This is used to set an expiration date for the user. After this
    date, the system will automatically disable the user''s account. Use this in case
    you need to create temporary users for your server. So, even if you forget to
    delete them, the system will at least lock their accounts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-G groups`: This sets the group membership of users. It is good security practice
    to classify server users by groups and set specific parameters and permissions
    for each group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every user has a unique ID, which is the UID variable. In Ubuntu, this variable
    starts from *1,000* for regular users, and values under *500* are reserved for
    system accounts with a specification value; the UID variable *0* is reserved for
    root users. Normally, this UID is unique, but there is only one case where you
    may want to give the same UID to more than one user—when you want to create a
    backup root user. To do this, you need to use either the `-o` option, or the `-u
    0` option with the `useradd` command when creating a user.
  prefs: []
  type: TYPE_NORMAL
- en: Password administration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Passwords are one of the security keys for an **operating system** (**OS**).
    In Ubuntu Server, passwords are managed by using the `passwd` command. A simple
    user can use it to change their password, and an administrator can use it to change
    the password of another regular user. Not only that, the `passwd` command has
    other important features, such as the following ones, which are useful in the
    maintenance of system security:'
  prefs: []
  type: TYPE_NORMAL
- en: By using the `-l` option, an administrator can lock a user account temporarily.
    It can be unlocked later by using the `-u` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of the password for a given user account can be reported by using
    the `-S` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can be forced to change their password during the next login by using
    the `-e` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a minimum number of days to use a password before the possibility of
    changing it again is done via the `-n min_days_number` option. This is useful
    when you wish to prevent users from changing their password after expiration and
    then changing it back to the old one immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set a maximum period of days to use a password. After completing this
    period, users are obliged to change their password. This is done by using the
    `-x max_days_number` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can notify a user about the expiration of their password; the period in
    days is specified in the argument of the `-c notif` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also set an automatic expiration of a user account in case there is
    no activity for a given period. This period is set in days and passed as an argument
    of the `-i exper` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some additional security features that are specifically related to password
    management and user login in general can be located and modified in the `/etc/login.defs`
    file. The following are the most important of these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FAIL_DELAY`: This sets the amount of time (in seconds) that is taken by a
    system after a failed login before a user is prompted again to re-enter their
    password. By default, it is *3* seconds. By setting a suitable value here, we
    can block a **brute force attack**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LASTLOG_ENAB`: This is a Boolean value. When it is set to *1*, it means that
    this feature is enabled. By enabling this feature, the system will log all the
    successful logins in the `/var/log/lastlog` file. The `lastlog` file should exist
    to have this feature working. In case it doesn''t, you can create it by using
    the touch `/var/log/lastlog` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PASS_MIN_LEN`: This parameter contains the minimum number of characters that
    must be used for new passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permission settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Permissions are the second security barrier after the login process in an OS.
    Ubuntu, like other Linux servers, has a strong and well-made permission structure.
    In this section, we will cover two main concepts—file ownership and operation
    permissions (read/write/execute).
  prefs: []
  type: TYPE_NORMAL
- en: File ownership
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each file on Ubuntu Server has its owner (user) and group owner (the user's
    primary group in general). In some cases, an administrator needs to change a file
    ownership for some reason (general security reasons). To do this, we have to call
    either the `chown` or `chgrp` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `chown`, the command has the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple of examples of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chown one_user some_file`: This command changes the owner of `some_file` to
    `one_user`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chown one_user:one_group some_file`: This command not only does what the preceding
    command did, but also changes its group to `one_group`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use `chown` to change only the group ownership. An example of this
    is `chown .one_group some_file`. Don't forget the (.) character just before the
    group name, which is `one_group` in this case. Note that we recently started using
    the colon character (`:`); both `.` and `:` are doing the job.
  prefs: []
  type: TYPE_NORMAL
- en: For group ownership, there is another alternative, namely the `chgrp` command.
    An example of its usage is `chgrp one_group some_file`. Note that we don't need
    the `.` character before the group name, which is `one_group` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the scope of the `chown` and `chgrp` commands applies only to the
    file or directory on which they are used. If you want to use these commands in
    a recursive way, you just have to add the `-R` option. For example, `chown -R
    one_user some_dir` makes the `one_user` user the owner of all the files in `some_dir`
    and all of its subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring permissions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Operation permissions are of three types, namely **read** (the **r** symbol
    or a value of **4**), **write** (the **w** symbol or a value of **2**), and **execute**
    (the **x** symbol or a value of **1**). Each one of these three types can be applied
    on a file or directory for the **owner user** (**u**), its **primary user group**
    (**g**) members, and **other users** (**o**). We can apply permissions on **all
    users** (**a**). To set these permissions, you can use the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specific use**: This is used to configure specific permissions for a specific
    file. This is done by using the `chmod` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**General use**: This is used to configure default permissions attribution
    for new created files. This is done by using the `umask` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some additional specific permissions called **special permissions**,
    namely **SUID**, SGID, and Sticky bit. This is beyond the scope of this book.
    You can explore them in an advanced Linux administration guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `chmod` tool, you can use the following two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The relative mode: This can be used in the same way as we use the absolute
    mode, which is detailed in the next section, to set huge changes at a time in
    terms of permissions, but it is even more useful when you need to add or remove
    just one permission at a time in an easy and convenient manner. When using `chmod`
    in this mode, you need to specify the entity (u, g, o, a) to which we will grant
    permissions, which is followed by the granting symbol (`+` for adding, `-` for
    removing, and `=` for setting the permissions) and the permissions that you wish
    to apply (r, w, x). For example, the `chmod g+w some_file` command will add write
    permissions on the `some_file` file to the entity group. Let''s take a look at
    another example where we set more than one permission at the same time by using
    the `chmod u+rwx,g+rx-w,o+r-wx another_file` mode, where we added all the rights
    to a user, added `read` and `execute` to the group and removed `write` from it,
    and added only `read` to others and removed `write` and `execute`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The absolute mode: This mode offers a short and convenient way to set permissions,
    especially when you need to change more than one permission at a time. In this
    mode, we use numeric values to define permissions. The permission value is composed
    of four digits. The first one refers to the special permissions (not covered in
    this book, as explained in a previous note). This digit can be omitted, unless
    you want to use it (be careful because it is dangerous). The other values refer
    in the order from left to right to the permissions related to a user, group, and
    others. Values are counted for each entity by adding values related to each permission
    (r=4, w=2, x=1). For example, the equivalent of `chmod u+rwx,g+rx-w,o+r-wx another_file`
    should be `chmod 754 another_file`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `umask` tool, it is the **user file creation mode mask**. It determines
    the default permissions that are set when creating a new file. The `umask` parameter
    is expressed in a numeric value, and this value is subtracted from the maximum
    permissions that can be set automatically; which is *666* for files and *777*
    for directories. The order of digits used in `umask` is the same as that for `chmod`;
    the first one from the left is for a user, the second digit is for a group, and
    the third digit is for others. By default, `umask` is set to *022*, which gives
    *644* permissions to all the newly created files and the *755* permissions to
    all the newly created directories.
  prefs: []
  type: TYPE_NORMAL
- en: The `umask` setting can be changed either for all users or for individual ones.
    If you want to set the `umask` value for all users, you must make sure that the
    `umask` setting is entered in the `/etc/login.defs` configuration file (before,
    it was entered in the `/etc/profile` file, but now it is changed to `/etc/login.defs`).
    On the other hand, if you would like to apply specific `umask` settings to only
    a specific user, you have to edit the profile file that exists under this user's
    home directory and set the desired `umask` value there.
  prefs: []
  type: TYPE_NORMAL
- en: Applying quota to user accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User quota is another security barrier for servers. They allow administrators
    to apply a quota restriction to the file and directory creation for users and
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this feature, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, install the `quota` software. This is done by using the `sudo
    apt-get install quota` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Secondly, prepare the filesystem to support quota. To do this, you need to
    add the `usrquota` option (if you want to apply quota to users) or the `grpquota`
    option (for groups) in the options column in the `/etc/fstab` file for every filesystem
    in which you want to use quota. Then, remount all the partitions in which quota
    has been applied by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, initialize the quota software. The best way to initialize the quota system
    is by running the `sudo quotacheck -augmv` command, which will create the `aquota.user`
    and `aquota.group` files to list all the quota information for actual users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the real work involves setting up quota for users and groups. This
    is done via the `edquota` command. For example, the `sudo edquota -u <username>`
    command will open a temporary file for quota for that user in a text editor. This
    file contains six numbers that specify the quota for all the filesystems on your
    server. The first one represents the block's number, which is currently being
    used by the user that you're setting the quota for. The second number is the soft
    limit for the block's number, while the third number is the hard limit. The fifth
    and sixth numbers are the equivalents for inodes, which are almost equal to the
    number of files that this user can create on the filesystem. The first and fourth
    numbers are just used to record the number of blocks and inodes that are currently
    being used for this user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After setting up the quota, you need to use the `sudo edquota -t` command to
    set the grace time that you want to use either in hours, or in days. The grace
    time is set per filesystem. Therefore, there's no option to specify different
    grace time settings for different users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The initialization step is mandatory in the setting up of quota for a new user;
    it makes sure that new users are known to the quota system.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up quota, it is useful to monitor it. To do that, you can use
    the `repquota` command. With the `-aug` options, this command shows the current
    quota settings for all the users and groups on all the volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after setting up quotas, don't forget to start the quota service by
    running the `/etc/init.d/quota start` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have set quotas for one user, you may want to apply them to other users.
    Instead of following the same procedure for all the users on the system, you can
    use the `edquota -p` command. For example, `sudo edquota -p user1 user2` copies
    the quotas currently applied for `user1 user` to `user user2`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `edquota` command works only with blocks and not bytes, kilobytes, or anything
    else. So, to set quota properly, you need to know the block size that's currently
    being used. To find this block size, use the `sudo dumpe2fs <device> | grep "Block
    size"` command.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring administration tasks with sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ubuntu implements a number of practices out of the box to make the default installation
    more secure. One of these practices is the disabling of the root account and the
    use of `sudo` for superuser privileges. The `sudo` program provides a much more
    robust set of features to increase user privileges as compared to the traditional
    su program.
  prefs: []
  type: TYPE_NORMAL
- en: The `sudo` command's configuration file can be found at `/etc/sudoers`. By default,
    Ubuntu provides a basic file that allows root users to do anything as any other
    user, and allows members of the admin group to become root users (the user that
    you create at the time of installation is automatically added to this group).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sudo` package provides a tool called `visudo` that you should use whenever
    you want to make changes to the file. Therefore, to view and edit the `/etc/sudoers`
    file, type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The reason you want to use `visudo` is that it automatically checks your `sudoers`
    file for mistakes. Since a mistake in the `sudoers` file could potentially lock
    you out of root access, this syntax check is pretty important. In case you do
    make a mistake, `visudo` will tell you about it after you save your settings and
    exit the page. So, you will have the option of going back and fixing your mistake,
    exiting without saving, or ignoring its warnings and saving anyway (which is not
    recommended).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To edit the file and manage the `sudo` program in the best possible way, the
    easiest thing to do is to read and follow the examples in the manual pages. You
    can access it via the man `sudoers` command.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AppArmor tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The AppArmor system that is installed by default in Ubuntu Server adds access
    control to specific system services with an aim to enhance the server security
    level. AppArmor is based on the security principle of least privileges. For every
    program, it assigns a series of rules that define a set of files and directories
    that this program is allowed to handle and explains how to handle them (`read
    only` or `read write`). When an application that is being managed by AppArmor
    violates these access controls, AppArmor intervenes, prevents it from doing so,
    and logs the event. There is a huge number of services that include AppArmor profiles
    by default, and more are being added in every Ubuntu release. In addition to the
    default profiles, the universe repository has an `apparmor-profiles` package that
    you can install to add more profiles for other services. Once you learn the syntax
    for the AppArmor rules, you can even add your own profiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to see how AppArmor works is by using an example program. The
    MySQL database server is one program that is automatically managed by AppArmor
    under Ubuntu. So, once the MySQL package is installed, you can use the `aa-status`
    program to see that AppArmor is already managing it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that the `/usr/sbin/mysqld profile` is loaded and is in the
    enforce mode and that the currently running `/usr/sbin/ mysqld process` (PID *6288*)
    is being managed by AppArmor.
  prefs: []
  type: TYPE_NORMAL
- en: 'AppArmor stores its profiles under the `/etc/apparmor.d/ directory`, and each
    filename is derived from the binary file that they manage. For instance, the profile
    for `/usr/sbin/mysqld` is located at `/etc/apparmor.d/usr.sbin.mysqld`. If you
    look at the contents of the file, you will get an idea of how the AppArmor profiles
    work and what sort of protection they provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is pretty straightforward for these files. First, there is a file
    or a directory path, which is followed by the permissions that are allowed. Globs
    are also allowed. So for instance, `/etc/mysql/**` recursively applies the files
    to all the files in the `/etc/mysql` directory. A single `*` will apply files
    only to files within the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'After modifying an AppArmor profile, you should reload the AppArmor daemon
    so that the changes take effect. You can do this by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In AppArmor, there are two modes, namely **enforce** and **complain**. In the
    **enforce** mode, AppArmor actively blocks all the attempts by a program to violate
    its profile. In the **complain** mode, AppArmor simply logs the attempt but allows
    it to happen. You can easily change a profile so that it is in the enforce or
    complain mode by using the `aa-enforce` and `aa-complain` programs respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in case you would like to change the MySQL AppArmor profile from
    the enforce to complain mode, this profile can perform read and write without
    restrictions in the profile file, but just those actions will be logged. All that
    we need to do is run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the AppArmor status after this change, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To be able to use the `aa-complain` and `aa-enforce` programs, you should first
    of all install the `apparmor-utils` package by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to temporary disable AppArmor (for instance, for some debugging
    purposes, in case some processes are not working as expected and you are trying
    to check whether the `apparmor` profiles are the reason behind it or if it''s
    something else), you just have to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that running the preceding command will only clear the profile''s cache.
    In case you need to unload the profile, you need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Advanced security configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discover some advanced security settings that are needed
    for most Ubuntu servers that are in a production environment, especially when
    they contain critical services. This advanced configuration is important because
    it will directly touch the behavior of services besides Ubuntu Server itself.
  prefs: []
  type: TYPE_NORMAL
- en: SSH security enhancement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By definition, SSH is a secure communication protocol, but there are some additional
    enhancements that we can apply to take this security a step ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the default Ubuntu SSH configuration. The `/etc/ssh/sshd_config`
    file, which is very secure as it allows authentication keys to be used, uses privilege
    separation and allows only SSH protocol 2\. The only questionable setting is **PermitRootLogin**
    `yes`, which defines the option that allows root users to log in via SSH. In our
    case (Ubuntu Server with the default installation), this setting is useless since
    the root account is disabled, but in case you would like to enable the root account,
    you might want to set this option to no and run `sudo service ssh reload` to save
    the settings. By following these steps, you force users to log in with their regular
    accounts and they can perform `sudo up` command to root in case they need root
    privileges. This also allows you to prevent a user from being able to guess the
    root password and gain access.
  prefs: []
  type: TYPE_NORMAL
- en: Another important security enhancement with SSH is the use of key-based authentication
    instead of passwords. This feature allows you to keep your server safe from brute
    force attacks. The working of key-based authentication is really simple. It is
    based on a couple of keys (one public and one private) generated by users. Then,
    the public key is placed in a special file on the remote server, and the private
    one must be kept with the user and mustn't be shared with others. When a user
    logs in, these keys are used to authenticate the user instead of a password. With
    this approach, and, users can also work more comfortably since they are able to
    log in to their machines without typing in the password every time. However, in
    case you want an extra layer of security, you can set a passphrase on your keys
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is relatively simple to set up key-based authentication. In this example,
    we have a user named `abdel` on a computer named **abdelmonam2** who wants to
    set up key authentication on a server named `abdelmonam1`. The first step is to
    use the `ssh-keygen` program to create an RSA public and private key on `abdelmonam2`.
    At each prompt, you can press the *Enter* key to accept the defaults, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SSH security enhancement](img/B04800_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The script creates the keys in the `.ssh` directory under your home directory,
    which is `/home/abdel/.ssh` in this case. The private key and the public key are
    named `id_rsa` and `id_rsa.pub` respectively. It's very important (especially
    if you chose an empty passphrase) to keep the private key (`id_rsa`) safe! If
    anyone else gets access to this file, they can copy it and will be able to log
    in to a machine that you have set up with this key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the keys, the next step is to copy the `id_rsa.pub` key
    to the server and then append it to the `~/.ssh/authorized_keys` file. There are
    a number of ways to do this. The automatic one involves using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: One of the manual ways is to SSH into the remote machine, open `~/.ssh/authorized_keys`
    with a text editor, and paste in the contents of `id_rsa.pub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the keys set up on a machine, you should be able to log in without
    a password prompt unless you set a passphrase for your key. If the latter is the
    case, you will need to type it. After your keys work, you might want to disable
    SSH password authentication altogether. Just make sure that your SSH keys work
    first, or you could lock yourself out! To disable password authentication, edit
    `/etc/ssh/sshd_config` and locate the line that says `#PasswordAuthentication
    yes`. Uncomment this line and set it to no, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, run `sudo service sshd reload` to load the new change.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default is a *2048 bit* key. You can increase this to *4096 bits* with
    the `-b` flag (increasing the bits makes it harder to crack the key by brute force
    methods), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Another method that allows you to prevent SSH brute force attacks, especially
    when you can not disable password authentication for one reason or another, is
    the use of the `denyhosts` package. This package monitors for failed SSH logins.
    When a host attempts to log in either as a user that doesn't exist, or too many
    times, that host is added to `/etc/hosts.deny` and blocked from future SSH access.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring firewalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common ways of protecting machines on a network is with a firewall.
    Essentially, a firewall gives you the ability to restrict access to services over
    the network. With a firewall, you can limit access to SSH, for instance, to hosts
    only within your internal network, while allowing HTTP access to everyone.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the firewall rules in Linux need to be set with a long and complicated
    set of `iptables` commands (also known as the `iptables` rules). This complexity
    is a weakness because one of the main security principles is to do things in a
    simple way. Luckily for Ubuntu administrators, there is now a simpler tool named
    `ufw`, which aims to simplify firewall administration by providing a frontend
    to the `iptables` commands.
  prefs: []
  type: TYPE_NORMAL
- en: The `ufw` program is installed by default on Ubuntu Server, but it is disabled;
    you need to enable it before you start adding rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic set of `ufw` commands is pretty straightforward. If you run `ufw
    -h`, you will get a help page that describes the main `ufw` commands, but if you
    want the entire syntax information, type in `man ufw` to read the entire manual
    page. First of all, let''s identify the main commands and then see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: You can enable and disable `ufw` by using `sudo ufw enable` and `sudo ufw disable`
    respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the `ufw` status by using `sudo ufw status`; the same command will list
    all the rules in case `ufw` is enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also set the default policy of your firewall. A very important command
    that you need to consider is the `default` command. This command defines the default
    policy of your firewall, as in whether all the packets are allowed or denied by
    default. The general consensus is that a firewall is more secure if you deny all
    packets by default and then enable services as needed. That way, in case you start
    a new service (or worse, a user starts a service) and you forget to set firewall
    rules for it, it will be blocked by default. So, to deny all packets by default,
    type in `sudo ufw default deny`. To allow all packets by default, type in `sudo
    ufw default allow`. Note that `ufw` will deny all packets by default unless you
    change the settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can configure the logging function to trace anything that it blocks, along
    with anything against your default policy. To enable logging, type in `sudo ufw
    logging on`, and to disable it, type in `sudo ufw logging off`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic `ufw` rule takes a port or service as an argument. To open port 53 (used
    for DNS servers), you would run `sudo ufw allow 53`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ufw` command also accepts service names that are defined in the `/etc/services`
    file instead of specific ports. If you look in the `/etc/services` file, you will
    see that port 53 TCP and UDP is set to the domain service. So, another way of
    stating this rule is `sudo ufw allow domain`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also specify the transport protocol. An example of this is `sudo ufw
    allow 53/udp`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also set a specific subnet that is allowed to access the server. Here''s
    an example command that is used to limit web access (port 80) to just the *192.168.1.0*
    network:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Even if you deny all packets by default, there may be circumstances in which
    you may also add a deny rule. For instance, let''s say that you are running an
    external SMTP (e-mail) server and you see that a host inside your network at *192.168.1.111*
    appears to be infected with a virus and is flooding your e-mail server with invalid
    messages. To block just that IP address, you will execute the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In case you want to block all the packets from that host and not just the SMTP,
    you wouldn''t need to define the proto and to arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Later on, once the virus has been removed and the host is back to normal, you
    can remove the rule with the help of the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, in case you dropped all the packets from the host, the following
    command will remove it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Be careful when using `ufw` while you are connected via SSH because enabling
    `ufw` with its default action of denying all packets will close your SSH connection
    and isolate your server. The best thing to do when you start configuring `ufw`
    and before enabling it or adding any other rules is to add the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a DNS server, we need to allow DNS packets and deny the others, of course
    after allowing SSH, and at the end, enable `ufw` and check its status. The following
    is a sequence of commands. Take care of the order; it matters a lot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is another example where we have more than one service. This
    is the web server, where in general, we should allow `http (80)` and `https (443)`
    access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Backuping and restoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tools and procedures that we saw in this chapter until now allow us to raise
    the server security level and enhance the ability to block attacks, but what if
    we are being attacked? In some cases, we can investigate and clean up the system,
    but in most cases, neither the time nor the means allow us to do that, and the
    best solution is to restore a healthy backed up image of the system. The backup
    and restore procedures solve not only problems related to attacks, but also problems
    related to data loss that are caused by human mistakes or physical accidents such
    as a server room fire.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will discover how to perform a backup/restore
    of Ubuntu Server in more than one way with more than one tool.
  prefs: []
  type: TYPE_NORMAL
- en: The principles of backup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of principles that should guide you when you choose your
    backup strategy. Most of these are common sense but bear repeating:'
  prefs: []
  type: TYPE_NORMAL
- en: Back up your data to a separate system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your backups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAID is not a substitute for backups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create full and incremental backup schedules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide how often you need to back up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archive your backups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drive imaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An image is a complete bit-for-bit copy of a drive. So, once you image a drive,
    you will get an identical image of the original drive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When imaging a drive, it's important that the drive is not in use. In case the
    drive changes when imaging it, you will not be able to guarantee that the image
    is consistent. So, be sure that the filesystems on a drive are unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu Server uses the classic UNIX imaging tool named dd. Its working process
    is simple—it reads an input file bit by bit and copies it to an output file bit
    by bit. If you had two drives of identical size, say `/dev/sda and /dev/sdb`,
    use the following command to image `sda` to `sdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `dd` tool also works with files as input and output arguments instead of
    drivers. So it's better to image our target in a file instead of a driver so that
    we can copy it easily in a transportable device such as a USB driver or send it
    to a remote file server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to back up the `sda` partition in an image file under
    a USB driver mounted under `/media/myUSB/`, all you need to do is execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To restore this image, just reverse the two arguments. Here are the commands
    to restore the two previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also image individual partitions. This can be useful because you can
    easily mount the image loopback and read through them. First, let''s image a partition
    on `/dev/sda`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can create a directory named `/mnt/temp` and use the loop mount option
    to mount this image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is handy when you need to recover only a few files from an image. You can
    browse `/mnt/temp` like any other filesystem and copy individual files or entire
    directories from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can directly back up an image of a given driver to a remote server by using
    SSH. For example, to transfer `/dev/sda` from the local machine over the network
    to *192.168.1.200* and dump the image at `/media/MyBackupData/sda-image.img`,
    you would type in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To restore this image, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Database backups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the most part, backing up a system is as easy as creating a copy of its
    files. However, on a database system, things aren't quite that simple. A database
    often won't commit changes to disk immediately. So, if you simply make a copy
    of the database files, the database itself might be in an inconsistent state.
    When you restore it, you can't necessarily guarantee that it is an uncorrupted
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to use tools included with the database to provide
    a consistent dump of the complete database to a file that you can back up. In
    the following section, you will learn how to use the tools provided for the MySQL
    databases in Ubuntu. A similar procedure is applied to other databases, depending
    on their own dumping tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool that MySQL uses to create a backup of its database is called **mysqldump**.
    This tool dumps an entire database or databases to the screen. Most people then
    redirect the output to a file or pipe it to a tool such as gzip to compress it
    first. For instance, if your user had a database called `mySite`, here is how
    should will back it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to compress the database as it was dumped, put a pipe to `gzip`
    in the middle, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you want to back up more than one database, there are two main ways
    to do it. The first way is to use the `--databases` argument, followed by a space-separated
    list of databases that you need to back up. The other method is to use the `--all-databases`
    argument, which backs up everything, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you set passwords for the MySQL users, you should provide them by using
    the `-u` and `-p` options to get this command working. For example, for the root
    user with a `mySecret` password, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will back up all the databases as the root user is using
    an insecure password. I gave this example only to say that while this option works,
    it is insecure. The reason is that the full list of arguments, including the password,
    will be visible to all the users on the system who run the `ps` command. A better
    method is to use `-p` without specifying a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When you specify `-p` without a password, `mysqldump` behaves like the `mysql`
    command and prompts you to enter a password. This provides good security, but
    it of course also means that you have to enter the password manually. Most people
    who back up their MySQL databases set up a `cron` job to do it at night. The way
    that MySQL recommends to solve this problem is to add the password to the client
    section in the `~/.my.cnf` file for the user performing the backups. If you already
    don''t have a `~/.my.cnf` file, create a new one and add the following text in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `mypassword` with the password that your user will use to log in. Once
    you set up this file, you don''t need to specify the `-p` option anymore, because
    `mysqldump` will pick up the password from this file. The downside here is that
    this password is in a plain-text file on the system. So, you will want to set
    its permissions so that only your user can see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To restore a backup on MySQL, use the `mysql` command-line tool and point it
    at your backup. For instance, to back up the `mySite` database to `mySite_backup.sql`,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, in case you are backing up a number of databases, just execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To restore all the databases, you need to log in as the root user. In case
    you set a root password, you must use the `-p` option (unless you set up a `.my.cnf`
    file; in that case, you can leave out `-p`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Backup tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of backup tools that we can use to backup and easily restore
    Ubuntu Server. Some of them use CLI and others use GUI; some are free, while others
    come with a paid license. They also differ according to the backup mode, which
    can be **full** (the tool backs up all the files in the backup target), **incremental**
    (the tool backs up all the files that have been changed since the last backup),
    or **differential** (the tool backs up all the files that have been changed since
    the last full backup).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a comparison of some of the well-known tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tool name | Interface | Remarks |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Areca Backup** | GUI | This is a great backup software that works locally
    or with FTP, is written in Java, has a very intuitive GTK graphical interface,
    and provides possibilities of complete restorations and file search. |'
  prefs: []
  type: TYPE_TB
- en: '| **Bacula** | GUI | This is a professional open source backup software. It
    saves the contents of a PC or a PC with multiple networks. Bacula has a lot of
    features. But it requires you to have advanced knowledge in terms of backups.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **BackInTime** | GUI | This is a very simple backup tool that is available
    for Linux. The backup is done by taking "snapshots" of a set of directories. Currently,
    there are two available GUIs, namely Gnome and KDE.This solution is one of the
    few tools that let you save the file on a remote server via SSH and store it in
    an encrypted form. It is possible to save the file on a dedicated server without
    concern for the security of its data once it''s stored. |'
  prefs: []
  type: TYPE_TB
- en: '| **BackupPC** | GUI | This is a very powerful tool that can be used to back
    up multiple clients (Linux or Windows).BackupPC is used to save a set of machines.
    It has a web interface to configure and initiate backups or restore files. It
    is also possible to back up databases.BackupPC can automatically save the directories
    on networked computers at regular time intervals.It can also do much more. |'
  prefs: []
  type: TYPE_TB
- en: '| **Déjà Dup** | GUI | This is a simple backup utility and a GUI tool for duplicity.
    It allows you to create backups in a local directory, on servers (SSH/FTP/HTTP),
    or on the Cloud. It also allows you to encrypt the saved files and schedule automatic
    backups. |'
  prefs: []
  type: TYPE_TB
- en: '| **LuckyBackup** | GUI | This is a simple tool with the power of rsync in
    a friendly interface. It offers features such as simple or advanced mode, restore,
    simulation, the remote operation, superuser mode, profiles, and planning. |'
  prefs: []
  type: TYPE_TB
- en: '| **SBackup** | GUI | This is a simple tool that you can use easily, and it
    is powerful. It allows you to perform an incremental backup but not a differential
    backup. |'
  prefs: []
  type: TYPE_TB
- en: '| **Backup-Manager** | CLI | With this tool, backup files are stored locally
    in archives and can be exported on a server (FTP, SSH, rsync, and so on) or burned
    on a CD/DVD. |'
  prefs: []
  type: TYPE_TB
- en: '| **Duplicity** | CLI | This tool performs backups by creating TAR archives
    that are encrypted with GnuPG. These archives are then sent to a local or remote
    backup directory. The supported remote protocols are FTP, SSH/SCP, Rsync, WebDAV/
    WebDAVs, and Amazon S3. |'
  prefs: []
  type: TYPE_TB
- en: '| **Rsync** | CLI | Rsync (for remote synchronization) is a file synchronization
    software. It is frequently used to implement remote backup systems.Rsync works
    unidirectionally, which means that it synchronizes, copies, or updates source
    data (local or remote) to a destination (local or remote) by transferring the
    bytes of the files that have been modified. |'
  prefs: []
  type: TYPE_TB
- en: '| **Unison** | CLI | Unison is a synchronization software. Unlike Rsync, it
    displays bidirectional synchronization. |'
  prefs: []
  type: TYPE_TB
- en: 'There are also some specific backup tools that are dedicated to partition cloning.
    The following are two such famous tools for Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tool name | Interface | Remarks |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Clonezilla** | GUI | This is a free equivalent of Norton Ghost or Acronis
    True Image. It allows you to create an image backup of a hard disk or partition
    and then restore it. |'
  prefs: []
  type: TYPE_TB
- en: '| **Partclone** | CLI | It is used to backup a partition. It is somehow the
    equivalent of Norton Ghost. It can be installed on a `live usb` to save your system.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let''s take as an example the powerful backup tool named **BackupPC**.
    To install it, you need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be asked for some information related to the mail server (postfix)
    and the web server that you wish to use (in our case, it is Apache), as shown
    in the following screenshot. In the end, you will get a message indicating the
    URL needed to manage BackupPC and the needed credentials to log in to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Backup tools](img/B04800_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To activate the new configuration, you need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can start using BackupPC via a web browser by using either the URL
    given in the message, or the server IP address followed by `/backuppc/`. You will
    be asked for login credentials, as shown in the following screenshot. After entering
    them, you will get a a good interface that is easy to use with a very rich documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Backup tools](img/B04800_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find out more information on how to use BackupPC in both GUI and CLI
    modes at [https://help.ubuntu.com/community/BackupPC](https://help.ubuntu.com/community/BackupPC).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on a very important subject related to Ubuntu Server,
    namely security management. We covered the basic and advanced security features
    inside Ubuntu Server and explored how to use them to enhance a system's security
    level. Then, we got an overview of the backup/restore operations for Ubuntu Server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will concentrate on one of the hottest IT subjects nowadays,
    which is virtualization and Cloud computing based on Ubuntu Server.
  prefs: []
  type: TYPE_NORMAL
