- en: Chapter 6. Adding Vision to Your Biped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that your biped is up and mobile, is able to find barriers, and knows how
    to plan its path, you can now start to have it move around autonomously. However,
    you may want your robot to follow a color or motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will be learning:'
  prefs: []
  type: TYPE_NORMAL
- en: How to add a webcam to your biped robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add RaspiCam to your biped robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install and use OpenCV, an open source vision package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to follow motion with your biped robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a camera on your biped robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having vision capability is a real advantage for your biped robot; you'll use
    this functionality in lots of different applications. Fortunately, adding hardware
    and software for vision is both easy and inexpensive. There are two choices as
    far as vision hardware is concerned. You can add a USB webcam to your system,
    or you can add RaspiCam, a camera designed specifically for Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a USB camera on Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Connecting a USB camera is very easy. Just plug it into the USB slot. To make
    sure that your device is connected, type `lsusb`. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing a USB camera on Raspberry Pi](img/B04591_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This shows a Creative Webcam located at Bus 001 Device 004: ID 041e:4095\.
    To make sure that the system sees this as a video device, type `ls /dev/v*` command
    and you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing a USB camera on Raspberry Pi](img/B04591_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `/dev/video0` is the webcam device. Now that your device is connected, let's
    actually see if you can capture images and video. There are several tools that
    can allow you to access the webcam, but a simple program with video controls is
    called luvcview. To install this, type `sudo apt-get install luvcview`. Once the
    application is installed, you'll want to run it. To do this, you'll either need
    to be connected directly to a display or able to access Raspberry Pi via a remote
    VNC connection, such as vncserver, as displaying images will require a graphical
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are connected in this manner, open a terminal window on Raspberry
    Pi and run `luvcview`. You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing a USB camera on Raspberry Pi](img/B04591_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Don't worry about the quality of the image, you'll be capturing and processing
    your images inside of OpenCV, a vision framework.
  prefs: []
  type: TYPE_NORMAL
- en: Installing RaspiCam on Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other choice for seeing the outside world on Raspberry Pi is to use the
    RaspiCam. Installing this camera is a bit more involved; you are going to connect
    it to a special connector on the Raspberry Pi. The following is a picture of the
    camera with its special connector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing RaspiCam on Raspberry Pi](img/B04591_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may also want to add the protective cover for the camera; assembling it
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing RaspiCam on Raspberry Pi](img/B04591_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you are ready to connect the camera to Raspberry Pi. The camera connects
    to the Raspberry Pi by installing it into the connector marked Camera on the Raspberry
    Pi. To see how this is done, see the video at [http://www.raspberrypi.org/help/camera-module-setup/](http://www.raspberrypi.org/help/camera-module-setup/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the camera is connected, you''ll want to enable the camera using the
    `raspi-config` utility. Type `sudo raspi-config`, then select the **Enable Camera**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing RaspiCam on Raspberry Pi](img/B04591_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now reboot Raspberry Pi. If you are developing from a remote computer and want
    to see your images, you will want to open a vncserver connection between your
    computer and the Raspberry Pi. For details, see [Chapter 1](ch01.html "Chapter 1. Configuring
    and Programming Raspberry Pi"), *Configuring and Programming Raspberry Pi*. To
    take a picture with the camera, simply type `raspistill -o image.jpg`. This will
    take a picture with the camera, and then store the image in the `image.jpg` file.
    Once you have the picture, you can view it by opening the Raspberry Pi image viewer
    by selecting the lower left icon for **Menu**, then **Accessories**, and then
    **Image Viewer**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing RaspiCam on Raspberry Pi](img/B04591_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the **image.jpg** file, and you should see the results of your picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing RaspiCam on Raspberry Pi](img/B04591_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before you can access OpenCV with the Raspberry Pi camera, you'll need to do
    two things. First, you'll need to add a Python library; it is called `picamera`.
    To get this, and the required libraries, type `sudo apt-get install python-picamera
    python3-picamera python-rpi.gpio`. Second, you'll need to type `sudo modprobe
    bcm2835-v4l2`. The Raspberry Pi camera can now be used in the OpenCV examples
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing OpenCV – a fully featured vision library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have your camera connected, you can begin to access some amazing
    capabilities that have been provided by the open source community. Open a terminal
    window and type the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo apt-get update`: You''re going to download a number of new software packages,
    so it is good to make sure that everything is up to date.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install build-essential`: Although you may have done this earlier,
    this library is essential to build OpenCV.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install libavformat-dev`: This library provides a way to code
    and decode audio and video streams.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install ffmpeg`: This library provides a way to transcode audio
    and video streams.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install libcv2.4 libcvaux2.4 libhighgui2.4`: This command shows
    the basic OpenCV libraries. Note the number in the command. This will almost certainly
    change as new versions of OpenCV become available. If 2.4 does not work, either
    try 3.0 or search on Google for the latest version of OpenCV.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install python-opencv`: This is the Python development kit needed
    for OpenCV, as you are going to use Python.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install opencv-doc`: This command will show the documentation
    for OpenCV just in case you need it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install libcv-dev`: This command shows the header file and static
    libraries to compile OpenCV.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install libcvaux-dev`: This command shows more development tools
    for compiling OpenCV.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install libhighgui-dev`: This is another package that provides
    header files and static libraries to compile OpenCV.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now type `cp -r /usr/share/doc/opencv-doc/examples /home/pi/`. This will copy
    all the examples to your home directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that OpenCV is installed, you can try one of the examples. Go to the `/home/pi/examples/python`
    directory. If you do an `ls`, you''ll see a file named `camera.py`. This file
    has the most basic code for capturing and displaying a stream of picture images.
    Before you run the code, make a copy of it using `cp camera.py myCamera.py`. Then,
    edit the file to look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Downloading and installing OpenCV – a fully featured vision library](img/B04591_06_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The two lines that you''ll add are the two with the `cv.SetCaptureProperty`;
    they will set the resolution of the image to 360 by 240\. To run this program,
    you''ll need to either have a display and keyboard connected to Raspberry Pi or
    use vncviewer. When you run the code, you should see the window displayed, as
    shown in the following image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Downloading and installing OpenCV – a fully featured vision library](img/B04591_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If you are using RaspiCam and don't see an image, you will need to run the `sudo
    modprobe bcm2835-v4l2` command. Now you can see the outside world!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may want to play with the resolution to find the optimum settings for your
    application. Bigger images are great—they give you a more detailed view on the
    world—but they also take up significantly more processing power. You'll play with
    this more as you actually ask your system to do some real image processing. Be
    careful if you are going to use vncserver to understand your system performance,
    as this will significantly slow down the update rate. An image that is twice the
    size (width/height) will involve four times more processing. You can now use this
    capability to do a number of impressive tasks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Edge Detection and OpenCv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately, one of the examples in the OpenCV Python set is a program named
    `edge.py`. The following is that file (with blank lines removed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Edge Detection and OpenCv](img/B04591_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This program uses the Canny image detection algorithm implemented by OpenCV
    to find the edges in any image. For more on the Canny edge algorithm, refer to
    [http://dasl.mem.drexel.edu/alumni/bGreen/www.pages.drexel.edu/_weg22/can_tut.html](http://dasl.mem.drexel.edu/alumni/bGreen/www.pages.drexel.edu/_weg22/can_tut.html)
    or [http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html](http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html).
    You captured an image earlier; you can use this program to look at the edges and
    to also see how setting a different threshold can show more/less edges. Run the
    program with the image captured earlier and you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Edge Detection and OpenCv](img/B04591_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will notice that there is a threshold slide bar setting at the top. If
    you adjust this threshold up, it will find fewer edges—the edges that have a larger
    threshold. The picture for a setting of 30 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Edge Detection and OpenCv](img/B04591_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can see how this process could be translated to an image of a blank
    floor and a barrier. The following is such an image with a possible barrier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Edge Detection and OpenCv](img/B04591_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can calibrate the distance to the object based on the pixels and the position
    of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Color and motion finding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV and your webcam can also track colored objects. This will be useful
    if you want your biped to follow a colored object. OpenCV makes this amazingly
    simple by providing some high-level libraries that can help us with this task.
    To accomplish this, you''ll edit a file to look something like what is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color and motion finding](img/B04591_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look specifically at the code that makes it possible to isolate the
    colored ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hue_img = cv.CvtColor(frame, cv.CV_BGR2HSV):` This line creates a new image
    that stores the image as per the values of **hue** (color), **saturation**, and
    **value** (**HSV**), instead of the **red**, **green**, and **blue** (**RGB**)
    pixel values of the original image. Converting to HSV focuses our processing more
    on the color, as opposed to the amount of light hitting it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threshold_img = cv.InRangeS(hue_img, low_range, high_range`): The `low_range,
    high_range` parameters determine the color range. In this case, it is an orange
    ball, so you want to detect the color orange. For a good tutorial on using hue
    to specify color, refer to [http://www.tomjewett.com/colors/hsb.html](http://www.tomjewett.com/colors/hsb.html).
    Also, [http://www.shervinemami.info/colorConversion.html](http://www.shervinemami.info/colorConversion.html)
    includes a program that you can use to determine your values by selecting a specific
    color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the program. If you see a single black image, move this window, and you
    will expose the original image window as well. Now, take your target (in this
    case, an orange ping-pong ball) and move it into the frame. You should see something
    like what is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Color and motion finding](img/B04591_06_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Notice the white pixels in our threshold image showing where the ball is located.
    You can add more OpenCV code that gives the actual location of the ball. In our
    original image file of the ball''s location, you can actually draw a rectangle
    around the ball as an indicator. Edit the file to look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Color and motion finding](img/B04591_06_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The added lines look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hue_image = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV):` This line creates a hue
    image out of the RGB image that was captured. Hue is easier to deal with when
    trying to capture real world images; for details, refer to [http://www.bogotobogo.com/python/OpenCV_Python/python_opencv3_Changing_ColorSpaces_RGB_HSV_HLS.php](http://www.bogotobogo.com/python/OpenCV_Python/python_opencv3_Changing_ColorSpaces_RGB_HSV_HLS.php).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threshold_img = cv2.inRange(hue_image, low_range, high_range):` This creates
    a new image that contains only those pixels that occur between the `low_range`
    and `high_range` n-tuples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contour, hierarchy = cv2.findContours(threshold_img, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE):`
    This finds the contours, or groups of like pixels, in the `threshold_img` image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center = contour[0]:` This identifies the first contour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moment = cv2.moments(center):` This finds the moment of this group of pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(x,y),radius = cv2.minEnclosingCircle(center):` This gives the *x* and *y*
    locations and the radius of the minimum circle that will enclose this group of
    pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center = (int(x),int(y)):` Find the center of the *x* and *y* locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radius = int(radius):` The integer radius of the circle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`img = cv2.circle(frame,center,radius,(0,255,0),2):` Draw a circle on the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that the code is ready, you can run it. You should see something that looks
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color and motion finding](img/B04591_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can now track your object. You can modify the color by changing the low_range
    and high_range n-tuples. You also have the location of your object, so you can
    use the location to do path planning for your robot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your biped robot can walk, use sensors to avoid barriers, plans its path, and
    even see barriers or target. In the final chapter, you'll learn to connect your
    biped robot remotely so that you can control it and monitor it, without the wires.
  prefs: []
  type: TYPE_NORMAL
