- en: Chapter 3. Aquarium Monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll see how to realize an aquarium monitor where we'll be
    able to record all the environment data and then control the life of our loved
    fish from a web panel.
  prefs: []
  type: TYPE_NORMAL
- en: By using specific sensors, you'll learn how to monitor your aquarium with the
    possibility to set alarms, log the aquarium data (water temperature), and to perform
    actions such as cooling the water and feeding the fish.
  prefs: []
  type: TYPE_NORMAL
- en: Simply speaking, we're going to implement a simple aquarium web monitor with
    a real-time live video, some alarms in case of malfunctioning, and a simple temperature
    data logging that allows us to monitor the system from a standard PC as well as
    from a smartphone or tablet, without using any specifying mobile app, but just
    using the on-board standard browser only.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of functioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This aquarium monitor is a good (even if very simple) example about how a web
    monitoring system should be implemented, giving to the reader some basic ideas
    about how a mid-complex system works and how we can interact with it in order
    to modify some system settings, displaying some alarms in case of malfunctioning,
    and plotting a data logging on a PC, smartphone, or tablet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite these aspects, the basic functioning of this project is similar to
    what we''ve already done in previous chapters: we have a periodic task that collects
    the data and then decides what to do. However, this time, we have a user interface
    (the web panel) to manage, and a video streaming to be redirected into a web page.'
  prefs: []
  type: TYPE_NORMAL
- en: Note also that in this project, we need an additional power supply in order
    to power and manage 12V devices (such as a water pump, a lamp, and a cooler) with
    the BeagleBone Black, which is powered at 5V instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that I'm not going to test this prototype on a real aquarium (since I don't
    have one), but by using a normal tea cup filled with water! So you should consider
    this project for educational purpose only, even if, with some enhancements, it
    could be used on a real aquarium too!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'About the hardware, there are at least two major issues to be pointed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Power supply**: We have two different voltages to use due to the fact the
    water pump, the lamp, and the cooler are 12V powered, while the other devices
    are 5V/3.3V powered. So, we have to use a dual output power source (or two different
    power sources) to power up our prototype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface**: The second issue is about using a proper interface circuitry
    between the 12V world and the 5V one in such a way that it doesn''t damage the
    BeagleBone Black or other devices. Let me point out that a single GPIO of the
    BeagleBone Black can manage a voltage of 3.3V, so we need a proper circuitry to
    manage a 12V device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the 12V devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As just stated, these devices need special attention and a dedicated 12V power
    line which, of course, cannot be the one we wish to use to supply the BeagleBone
    Black. On my prototype, I used a 12V power supplier that can supply a current
    till 1A. These characteristics should be enough to manage a single water pump,
    a lamp, and a cooler.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you get a proper power supplier, we can pass to show the circuitry to
    use to manage the 12V devices. Since all of them are simple on/off devices, we
    can use a relay to control them. I used the device shown in the following image
    where we have 8 relays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the 12V devices](img/B00255_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The devices can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/5v-relays-array](http://www.cosino.io/product/5v-relays-array)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the schematic to connect a single 12V device is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the 12V devices](img/B00255_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simply speaking, for each device, we can turn the power supply on and off simply
    by moving a specific GPIO of our BeagleBone Black. Note that each relays of the
    array board can be managed in direct or inverse logic by simply choosing the right
    connections accordingly as reported on the board itself, that is, we can decide
    that, by putting the GPIO into a logic `0` state, we can activate the relay, and
    then, turning on the attached device, while putting the GPIO into a logic `1`
    state, we can deactivate the relay, and then turn off the attached device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By using the following logic, when the LED of a relay is turned on, the corresponding
    device is powered on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BeagleBone Black''s GPIOs and the pins of the relays array I used with
    12V devices are reported in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | Relays Array pin | 12V Device |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P8.10 - GPIO66 | 3 | Lamp |'
  prefs: []
  type: TYPE_TB
- en: '| P8.9 - GPIO69 | 2 | Cooler |'
  prefs: []
  type: TYPE_TB
- en: '| P8.12 - GPIO68 | 1 | Pump |'
  prefs: []
  type: TYPE_TB
- en: '| P9.1 - GND | GND |   |'
  prefs: []
  type: TYPE_TB
- en: '| P9.5 - 5V | Vcc |   |'
  prefs: []
  type: TYPE_TB
- en: 'To test the functionality of each GPIO line, we can use the following command
    to set up the GPIO as an output line at high state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the *off* state of the relay is `1`, while the *on* state is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can turn the relay on and off by just writing `0` and `1` into `/sys/class/gpio/gpio68/value`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the webcam
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The webcam I'm using in my prototype is a normal UVC-based webcam, but you can
    safely use another one that is supported by the **mjpg-streamer** tool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See the mjpg-streamer project's home site for further information at [http://sourceforge.net/projects/mjpg-streamer/](http://sourceforge.net/projects/mjpg-streamer/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once connected to the BeagleBone Black USB host port, I get the following kernel
    activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a new driver called `uvcvideo` is loaded into the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now, to have a streaming server, we need to download the mjpg-streamer
    source code and compile it. We can do everything within the BeagleBone Black itself
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `svn` command is part of the `subversion` package and can be installed
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the download is finished, we can compile and install the code by using
    the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find a compressed archive copy of this program in the `chapter_03/mjpg-streamer-code.tgz`
    file in the book's example code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no errors are reported, you should now be able to execute the new command
    as follows, where we ask for the help message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you get an error like the following it means that your system misses the
    `convert` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install it by using the usual `aptitude` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now we are ready to test the webcam. Just run the following command line
    and then point a web browser to the address `http://192.168.32.46:8080/?action=stream`
    (where you should replace my IP address `192.168.32.46` with your BeagleBone Black''s
    one) in order to get the live video from your webcam:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you can use the USB Ethernet address `192.168.7.2` too if you're not
    using the BeagleBone Black's Ethernet port.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything works well, you should get something similar to what is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the webcam](img/B00255_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you get an error, as follows it means that some other process is holding
    the `8080` port, and most probably it''s occupied by the `Bone101` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable it, you can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can simply use another port, maybe port `8090`, with the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Connecting the temperature sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The temperature sensor used in my prototype is the one shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the temperature sensor](img/B00255_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The devices can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/waterproof-temperature-sensor](http://www.cosino.io/product/waterproof-temperature-sensor).'
  prefs: []
  type: TYPE_NORMAL
- en: The datasheet of this device is available at [http://datasheets.maximintegrated.com/en/ds/DS18B20.pdf](http://datasheets.maximintegrated.com/en/ds/DS18B20.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it's a waterproof device, so we can safely put it into the water
    to get its temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'This device is a **1-Wire** device and we can get access to it by using the
    `w1-gpio` driver, which emulates a 1-Wire controller by using a standard BeagleBone
    Black GPIO pin. The electrical connection must be done according to the following
    table, keeping in mind that the sensor has three colored connection cables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | Cable color |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P9.4 - Vcc | Red |'
  prefs: []
  type: TYPE_TB
- en: '| P8.11 - GPIO1_13 | White |'
  prefs: []
  type: TYPE_TB
- en: '| P9.2 - GND | Black |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interested readers can follow this URL for more information about how 1-Wire
    works: [http://en.wikipedia.org/wiki/1-Wire](http://en.wikipedia.org/wiki/1-Wire)'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, since our 1-Wire controller is implemented in software, we
    have to add a pull-up resistor of 4.7KΩ between the red and white cable in order
    to make it work!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all connections are in place, we can use the `chapter_03/BB-W1-GPIO-00A0.dts`
    file in the book''s example code repository to enable the 1-Wire controller on
    the *P8.11* pin of the BeagleBone Black''s expansion connector. The following
    snippet shows the relevant code where we enable the `w1-gpio` driver and assign
    to it the proper GPIO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable it, we must use the `dtc` program to compile it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to load it into the kernel with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything works well, we should see a new 1-Wire device under the `/sys/bus/w1/devices/`
    directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The new temperature sensor is represented by the directory named `28-000004b541e9`.
    To read the current temperature, we can use the `cat` command on the `w1_slave`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that your sensors have a different ID, so in your system you'll get a different
    path name in the `/sys/bus/w1/devices/28-NNNNNNNNNNNN/w1_slave` form.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the current temperature is `t=29500`, which is expressed
    in **millicelsius degree** (**m°C**), so it's equivalent to 29.5°C.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reader can take a look at the book *BeagleBone Essentials*, *Packt Publishing*,
    written by the author of this book, in order to have more information regarding
    the management of the 1-Wire devices on the BeagleBone Black.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the feeder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fish feeder is a device that can release some feed by moving a motor. Its
    functioning is represented in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the feeder](img/B00255_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the closed position, the motor is at horizontal position, so the feed cannot
    fall down, while in the **Open** position, the motor is at vertical position,
    so that the feed can fall down. I have no real fish feeder, but looking at the
    preceding functioning, we can simulate it by using the servo motor shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the feeder](img/B00255_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The device can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/nano-servo-motor](http://www.cosino.io/product/nano-servo-motor).'
  prefs: []
  type: TYPE_NORMAL
- en: The datasheet of this device is available at [http://hitecrcd.com/files/Servomanual.pdf.](http://hitecrcd.com/files/Servomanual.pdf.)
  prefs: []
  type: TYPE_NORMAL
- en: This device can be controlled in position, and it can rotate by 90 degrees with
    a proper **PWM** signal in input. In fact, reading into the datasheet, we discover
    that the servo can be managed by using a periodic square waveform with a **period**
    (**T**) of 20ms and with a **high state time** (**t[high]**) between 0.9ms and
    2.1ms with 1.5ms as (more or less) center. So, we can consider the motor in the
    **Open** position when *t[high] =1ms* and in the **Close** position when *t[high]=2ms*
    (of course, these values should be carefully calibrated once the feeder is really
    built up!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect the servo as described by the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | Cable color |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P9.3 - Vcc | Red |'
  prefs: []
  type: TYPE_TB
- en: '| P9.22 - PWM | Yellow |'
  prefs: []
  type: TYPE_TB
- en: '| P9.1 - GND | Black |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interested readers can find more details about the PWM at [https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation).
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the connections, we have to enable one PWM generator of the BeagleBone
    Black. So, to respect the preceding connections, we need the one which has its
    output line on pin `P9.22` of the expansion connectors. To do it, we can use the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `/sys/devices/ocp.3` directory, we should find a new entry related
    to the new enabled PWM device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the `/sys/devices/ocp.3/pwm_test_P9_22.12` directory, we see the
    files we can use to manage our new PWM device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can deduce from the preceding file names, we have to properly set up
    the values into the files named as `polarity`, `period`, and `duty`. So, for instance,
    the center position of the servo can be achieved by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The polarity is set to `0` to invert it, while the values written in the other
    files are time values expressed in nanoseconds, set at a period of 20ms and a
    duty cycle of 1.5ms, as requested by the datasheet (time values are all in nanoseconds.)
    Now, to move the gear totally clockwise, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following command is to move it totally anticlockwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So, by using the following command sequence, we can open and then close (with
    a delay of `1` second) the gate of the feeder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that by simply modifying the delay, we can control how much feed should
    fall down when the feeder is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script that implements the feeder controlling mechanism can be found in
    the `chapter_03/feeder.sh` file in the book's example code repository.
  prefs: []
  type: TYPE_NORMAL
- en: The water sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The water sensor I used is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The water sensor](img/B00255_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The device can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/water_sensor](http://www.cosino.io/product/water_sensor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a really simple device that implements what is shown in the following
    screenshot, where the **resistor** (**R**) has been added to limit the current
    when the water closes the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The water sensor](img/B00255_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a single drop of water *touches* two or more teeth of the comb in the schematic,
    the circuit is closed and the **output voltage** (**Vout**) drops from **Vcc**
    to 0V.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we wish to check the water level in our aquarium, that is, if we wish
    to check for a water leakage, we can imagine to put the aquarium into some sort
    of saucer, and then this device into it, so, if a water leakage occurs, the water
    is collected by the saucer, and the output voltage from the sensor should move
    from **Vcc** to GND.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GPIO used for this device are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | Cable color |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P9.3 - 3.3V | Red |'
  prefs: []
  type: TYPE_TB
- en: '| P8.16 - GPIO67 | Yellow |'
  prefs: []
  type: TYPE_TB
- en: '| P9.1 - GND | Black |'
  prefs: []
  type: TYPE_TB
- en: 'To test the connections, we have to define GPIO 67 as an input line with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can try to read the GPIO status while the sensor is in the water and
    when it is not, by using the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The final picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot shows the prototype I realized to implement this project
    and to test the software. As you can see, the aquarium has been replaced by a
    cup of water:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The final picture](img/B00255_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we have two external power suppliers: the usual one at 5V for the
    BeagleBone Black, and the other one with an output voltage of 12V for the other
    devices (you can see its connector in the upper-right corner on the right of the
    webcam.)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regarding the software, this time the major part is covered by the web interface,
    which is the real core of the project, and the acquisition and controlling process
    to get the aquarium data and managing the actuators. Then, a dedicated monitor
    script will be used to implement the communication between the web interface and
    the internal database.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the system status and configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To manage the status of all devices and to do the data logging, we can use
    a database again to store all the relevant data, as we did in [Chapter 1](ch01.html
    "Chapter 1. Dangerous Gas Sensors"), *Dangerous Gas Sensors*. So, we can use the
    `chapter_03/my_init.sh` file in the book''s example code repository to set up
    the database. The following snippet shows the relevant code where we define the
    tables used in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `status` table holds the system status variables with the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `alarm_sys` | Generic system alarm (I/O and communication errors, and so
    on). |'
  prefs: []
  type: TYPE_TB
- en: '| `alarm_level` | A water leakage has been detected. |'
  prefs: []
  type: TYPE_TB
- en: '| `alarm_temp` | Water temperature is over the `water_temp_max_alarm` value
    or under the `water_temp_min_alarm` value (in °C). |'
  prefs: []
  type: TYPE_TB
- en: '| `Water` | Current water temperature (in °C). |'
  prefs: []
  type: TYPE_TB
- en: '| `Cooler` | Current cooler status (0 = off, 1 = on). |'
  prefs: []
  type: TYPE_TB
- en: '| `Pump` | Current pump status (0 = off, 1 = on). |'
  prefs: []
  type: TYPE_TB
- en: '| `Lamp` | Current lamp status (0 = off, 1 = on). |'
  prefs: []
  type: TYPE_TB
- en: '| `force_cooler` | The user asks to turn on the cooler. |'
  prefs: []
  type: TYPE_TB
- en: '| `force_pump` | The user asks to turn on the pump. |'
  prefs: []
  type: TYPE_TB
- en: '| `force_lamp` | The user asks to turn on the lamp. |'
  prefs: []
  type: TYPE_TB
- en: '| `force_feeder` | The user asks to enable the feeder. |'
  prefs: []
  type: TYPE_TB
- en: Note that the feeder has no current status variable due to the fact that it
    cannot stay opened or closed, but just has an *impulse-on* functioning; that is,
    when enabled, it opens and then closes it's internal gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, in the `config` table, there are system configuration variables
    with the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pump_t_on` | Time in seconds when the pump must be on. |'
  prefs: []
  type: TYPE_TB
- en: '| `pump_t_off` | Time in seconds when the pump must be off. |'
  prefs: []
  type: TYPE_TB
- en: '| `feeder_interval` | Time in seconds between two consecutive "lunch time".
    |'
  prefs: []
  type: TYPE_TB
- en: '| `water_temp_max` | Turn the cooler on if the water temperature is over this
    value (in °C). |'
  prefs: []
  type: TYPE_TB
- en: '| `water_temp_min_alarm` | Turn the water alarm on if the water temperature
    is under this value (in °C). |'
  prefs: []
  type: TYPE_TB
- en: '| `water_temp_max_alarm` | Turn the water alarm on if the water temperature
    is over this value (in °C). |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that my project misses the `water_temp_min` configuration variable due
    to the fact that I have no heater available to increase the water temperature
    in case it is too cold. However, the reader should have all needed information
    to fill this gap by reading this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the `temp_log` table is used to store all water temperature measurements
    useful to show a little graph into the user's control panel (see the following
    section).
  prefs: []
  type: TYPE_NORMAL
- en: Building up the web control panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The web control panel is written in **PHP** and **JavaScript**. PHP is used
    to implement the acquisition and controlling processes plus the main page, while
    the JavaScript is used to implement the graphical widgets. In particular, this
    last part has been realized by using an interesting toolkit named **Drinks** ([http://www.goincompany.com/drinks.php](http://www.goincompany.com/drinks.php)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the widgets implemented by this toolkit is trivial. In order to install
    it, we just need to download the zip archive from the project''s home site, unzip
    it, and then move the files with the `.js` extension into the web server''s root
    directory. On my BeagleBone Black, I''m running the Apache web server, which has
    its root directory in the `/var/www` directory. So, to install the `Drinks` toolkit,
    I moved the files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have to add the code to build up our web control panel and manage it
    in this directory. The main script can be found in the `chapter_03/aquarium.php`
    file in the book's example code repository. I'm going to report all its relevant
    code into several snippets now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following first snippet, there is the PHP code to get the initial statuses
    of the input widgets, that is, those widgets that the user directly manages to
    send commands to the system. During the first loading of this page, the user will
    get the current status of this widgets as they are stored into the internal database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then follows the header of the **HTML** page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: By using this code, we instruct the Drinks toolkit to generate two managers—one
    to manage the input widgets (`man_in`), and the other to manage all other output
    widgets (`man_out`). The output widgets, as opposed to the input ones, are all
    the widgets that are not under the direct control of the user and then are updated
    by the system to show the system status to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Both managers will refresh their internal status each second (`refresh=1`),
    and both will use the external handler named `handler.php` to do it. The code
    of this handler (which will be presented in the next section) are executed periodically,
    and it's used to get the input widget's statuses and to set the output widgets
    statuses into the control panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the control panel is divided into three main subsections. The first one
    is where the live video and the alarms are placed. This can be achieved with the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the following line is used to enable the live video from the webcam:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, the following three lines are used to define the alarm LEDs related
    to the corresponding alarm variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The second subsection holds the control widgets, that is, the water thermometer
    and the lamp, cooler, pump, and feeder LEDs and switches. Since all the input
    widgets are here, the code uses a big HTML form where these items are placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line is used to display a thermometer that reports the water
    temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two lines are used to display the lamp, cooler, and pump switches
    with the relative LED that indicates the device status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When an LED is turned on, the corresponding device is turned on, while when
    it is turned off, the device is turned off. On the other hand, by moving one of
    the preceding switches, the user can force the system to turn on the corresponding
    device during the *next cycle*. (I'm going to explain what the *next cycle* term
    means in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: A special notice must be applied for the feeder. As already stated, it can be
    enabled with an impulse, and not simply turned on or off. To highlight this fact,
    this time I used a different kind of switch widget. So, the LED is used to notify
    the user that the feeder will be enabled in the next cycle, while the LED will
    remain on and it will be turned off once the feeder has been really enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to display the feeder controls is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, the type of the switch is `toggle` instead of `circle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last subsection is the temperature log graphic, which can be used to show
    to the user how the water temperature has been changed during the last 20 cycles.
    The code to implement this part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this case, we need a special handler to generate the graphical
    points representing the water temperature. This handler is called `log_temp.php`
    and it's specified in the `href` parameter of the `channel` entry, while the other
    parameters define the refresh time in seconds (`refresh="60"`) and the scaling
    of the graph (`sweep` and `frequency`). See the `Drinks` documentation pages for
    further information about these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'At each refreshing time, the `log_temp.php` script is called, and it will return
    the points sequence to be displayed to the display widget. To discover how it
    happens, we have to move to the next section. But before doing it, let me show
    you how the web control panel we just presented is displayed on my PC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building up the web control panel](img/B00255_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling the control panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we discovered that the web control panel needs some
    handlers to send/receive data from the underlying system. In particular, we said
    that the input/output managers talk with the `handler.php` script, while the temperature
    log needs the `log_temp.php` script to get graph data. Let's see how these scripts
    are written.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the `handler.php` script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script can be found in the `chapter_03/handler.php` file in the book's example
    code repository.
  prefs: []
  type: TYPE_NORMAL
- en: This script has an input section to manage the input widgets and an output section
    to manage the output ones. In the input section, we simply get the status of each
    input widget and then store it in the `status` table. The only exception is for
    the `force_feeder` variable, which is recorded only if its status is `1` due to
    the the fact that it will be cleared when the feeder is actually enabled in the
    next cycle (again, the meaning of *next cycle* will be explained soon).
  prefs: []
  type: TYPE_NORMAL
- en: In the output section, we simply get the status of each status variable from
    the database and then store it into an array that will be returned to the `Drinks`
    toolkit by using the `json_encode()`function. The only note to be highlighted
    here is the fact that once the `force_feeder` switch is moved to the high state,
    its status is recorded, and then is cleared again, just to simulate the fact that
    this is not a normal on/off switch but just an *impulse-on* switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, as said just now, the `log_temp.php` script just has to
    return a list of points. The following is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script can be found in the `chapter_03/log_temp.php` file in the book's
    example code repository.
  prefs: []
  type: TYPE_NORMAL
- en: The script simply selects the last 20 recorded points from the `temp_log` table
    and then stores them into the `data[]` array, adding some zeros at the beginning
    just in case there exists less then 20 stored temperature values. The `array_unshift()`
    function is used to put each new extracted value at the beginning of the array
    due to the fact that the `SELECT` statement returns the data in a reversed order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the last step is to put all these scripts together into the web browser
    root directory. The `/var/www` directory on my BeagleBone Black looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CSS can be found in the `chapter_03/aquarium.css` file in the book's example
    code repository. The code is not presented here since it's very trivial and not
    strictly needed for the understanding of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the internal state-machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the control panel has been correctly set up, we have to take a look
    at the internal *state-machine*, that is, the procedure that at each cycle collects
    all the environment data and then decides what to do according to its internal
    state and the new environment status.
  prefs: []
  type: TYPE_NORMAL
- en: Our machine is implemented in the `chapter_03/aquarium_mon.php` file in the
    book's example code repository. The following are several code snippets of its
    `daemon_body()` function (the real core of the program.)
  prefs: []
  type: TYPE_NORMAL
- en: 'At its beginning, the function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: At its beginning, the function initializes some variables and then starts its
    main loop where the first step is to get the water temperature, since, according
    to this value, many jobs need to be carried out!
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the `while()` statement executes each time the `sleep($loop_time)`
    function, that is, each `loop_time` seconds starts a new *machine cycle*, and
    all the variables are modified according to the environment data read and the
    user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code continues reading the temperature as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `temp_get()` function reads the water temperature by reading the corresponding
    `w1_slave` file. It stores this value in the `temp` variable, and then some alarms
    are checked against this new value. Note also that in this case, the `alarm_sys`
    variable can be set to `1` to signal whether an I/O error has occurred or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_water_level()` function is used to read the GPIO connected with the
    water sensor, and its body looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, as the preceding code shows, the water sensor has an inversed logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s the lamp''s turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we see that the lamp is turned on and off according
    to the user input, without any automatic mechanism from the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not true for the cooler. Its management code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The cooler status is set according to the `temp` value and the `water_temp_max`
    setting and, as last case, it can be forced on by the user if the `force_cooler`
    variable is set to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar functioning applies for the pump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This time, the state on or off is set by a timeout and, again, the device can
    be forced on by the user input, that is, if the `force_pump` variable is set to
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the preceding three snippets call a proper function to set on or off the
    relative GPIO; for instance, the last one calls the `set_pump()` function to set
    the pump status. The function''s body is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The other two functions are similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last notice is for the feeder. This time the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The feeder can be activated according to a timeout or by a user input; but,
    instead of the preceding example, the code calls the `do_feeder()` function to
    call the `feeder.sh` script presented, as shown in the preceding code, and then
    it must clear the `force_feeder` status variable to signal to the user that the
    feeder has been activated. The body of the `do_feeder()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The character `&` in the `system()` function is needed in order to create a
    dedicated process to execute the `feeder.sh` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to execute the script. On my system, I used the following command
    line to execute it in debugging mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that on your system, the **PHP** support may not be installed. In this
    case, you can solve it by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Every 15 seconds, the script wakes up and executes all the preceding steps in
    a new *cycle* of the *state-machine*. Note that to work you must set up all the
    hardware as presented in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Final test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the prototype, I turned on the board, and after the login, I set up
    the system by using the commands discussed before, or by using the `chapter_03/SYSINIT.sh`
    script in the book''s example code repository, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I executed the `aquarium_mon.php` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, I executed the video streamer with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Then, I pointed my browser to the `aquarium.php` file on the BeagleBone Black's
    IP address (that is, the URL `http://192.168.7.2/aquarium.php`) and the game is
    done!
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that at this point, we can try to force some settings or try to change
    some configuration variables by using the `chapter_03/my_dump.sh` and `chapter_03/my_set.sh`
    scripts in the book''s example code repository, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding setting, I changed the `water_temp_max_alarm` limit value just
    as an example, and you can do all the changes that you wish on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ending this chapter, let me show you how this control panel looks on
    my smartphone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final test](img/B00255_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reader should notice that on the temperature log, there are three spikes
    due to the fact that during the temperature reading, the sensor returned an error.
    This issue can be fixed by repeating the reading two or three times before returning
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered how to interface our BeagleBone Black to several
    devices with a different power supply voltage, and how to manage a 1-Wire device
    and a PWM one. Also, we presented the `Drinks` toolkit to realize a web control
    panel that can be used equally from a PC, smartphone, or tablet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll see how to realize a weather station that can store
    its collected data locally, which can not only show them in a nice manner on a
    web browser, but also can send its data to a Google Docs document!
  prefs: []
  type: TYPE_NORMAL
- en: Simply speaking, we're going to realize a simple **Internet-of-Things** (**IoT**)
    machine.
  prefs: []
  type: TYPE_NORMAL
