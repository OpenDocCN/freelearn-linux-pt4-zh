<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performing Calculations</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we discuss the following topics:</p>
<ol>
<li>Performing arithmetic operations</li>
<li>Performing calculations on the output</li>
<li>Working with the administrative constants</li>
<li>Working with calculated properties</li>
<li>Working with binary numbers</li>
<li>Performing base conversions</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical Requirements</h1>
                </header>
            
            <article>
                
<p>Here are the technical requirements to work with this chapter.</p>
<ol>
<li>PowerShell installed on the computer. Refer <em>Installation, Reference and Help</em> for steps.</li>
<li>Visual Studio Code (recommended). Refer the recipe, <em>Installing Visual Studio Code</em> in the chapter, <em>Preparing for Administration using PowerShell</em>.</li>
<li>Some throw-away files for the recipes. Use the script, <kbd>Initialize-PacktPs6CoreLinuxLab.ps1</kbd><span> from within the </span><kbd>ch05</kbd><span> directory of the book's GitHub repository.</span></li>
</ol>
<p><span>The scripts used in this chapter are available at: <a href="https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook/tree/master/ch09">https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook/tree/master/ch09</a>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Performing calculations is an integral part of automation. Of course PowerShell allows for this; it also takes things up a level by providing administrators with what is called Administrative Constants, which help ease calculations. We will look into these concepts in the following recipes. We will first look at common arithmetic operations, and then, move towards using the concepts on outputs using Calculated Properties like we saw in <em>Passing Objects Through the Pipeline</em>.</p>
<p>We will also look at cases where we could ease automation using binary numbers to identify flags, perform base conversion, and finally, use some of .NET Accelerators/cast operators to simplify scripting.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performing arithmetic operations</h1>
                </header>
            
            <article>
                
<p>As administrators, we do not use much of arithmetic operations like the sin, cos, log and exp operations. However, it is possible to do all of them on PowerShell, since PowerShell can leverage .NET. In general, we may use these operations as administrators: <kbd>Abs</kbd> (as in absolute), <kbd>Ceiling</kbd>, <kbd>Floor</kbd>, <kbd>Round</kbd> and <kbd>Truncate</kbd>. In this recipe, we will use three of these methods, based on the scenario we have. Use of the other methods is very similar. Here is the scenario:</p>
<p>You have an application that creates logs throughout the day. These logs consume a lot of space. You would like to clean up logs that are between 30 and 31 days old. You are not allowed to use a dual condition for comparison.</p>
<p>Create a function that looks for files of 30 days of age. Your script should also say how much of the log space was cleared, rounded off to the nearest megabyte.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Run the script, <kbd>Initialize-PacktPs6CoreLinuxLab.ps1</kbd> from within the <kbd>ch05</kbd> directory of the book's GitHub repository. This is just so we have some files to work on. Next, run the script, <kbd>Set-LastWriteTime.ps1</kbd> from within the <kbd>ch09</kbd> directory of the repository.</p>
<p>If you would like to specify a path other than <kbd>~/random</kbd> for the content, add <kbd>-Path '//your/custom/path'</kbd> to the last line of the script. Ensure you do this in both the scripts.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Navigate to the directory that contains your lab files; here is where all the action happens. If you did not specify a custom -Path when running the scripts, it should be <kbd>~/random</kbd>.</p>
<ol>
<li>Open the terminal and, using a code editor (<kbd>vi</kbd>, <kbd>nano</kbd> or VS Code), create a new file called <kbd>Clear-LogFiles.ps1</kbd>. Remember, CamelCase is just a convention.</li>
<li>Enter the following content. I suggest typing it by yourself rather than copy-pasting it.</li>
</ol>
<pre style="padding-left: 90px">$Today = Get-Date
$TotalFileSize = 0

$FilesToDelete = Get-ChildItem . -Recurse -File | Where-Object {[math]::Floor(($Today - $_.LastWriteTime).TotalDays) -eq 30}


Write-Host "The following files will be deleted:"
Write-Host $FilesToDelete.FullName

foreach ($File in $FilesToDelete) {
    $TotalFileSize += $File.Length
    Remove-Item -Path $File -WhatIf
}

Write-Host "Total space cleared: $([math]::Round($TotalFileSize/[math]::Pow(1024, 2))) MB"</pre>
<p>There is no need to actually delete the files. If you would like to anyway, remove the <kbd>-WhatIf</kbd> switch from line 12.</p>
<div class="packt_tip">It is recommended to use Visual Studio Code to write this script since its IntelliSense auto-completion is very helpful. You could write this script at the terminal itself, in which case, use shorter versions of parameters and tab-completions as necessary.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>[math]::</kbd> accelerator allows us to use the methods of the <kbd>System.Math</kbd> class. The <kbd>Round()</kbd> method accepts one or two arguments; in case of a single argument, the rounding happens to the nearest integer. The optional second parameter specifies the number of digits after the decimal point.</p>
<p>The <kbd>Pow()</kbd> method is almost self-explanatory: 1024<sup>2</sup> in our case. The <kbd>Floor()</kbd> method brought down numbers from 30.00 to less than 31, down to 30.</p>
<p>This is what we did:</p>
<ol>
<li>Listed out the files to delete: we subtracted the <kbd>LastWriteTime</kbd> from today, and performed a Floor operation on it since we were not allowed to use the <kbd>-and</kbd> operator.</li>
<li>Displayed the files.</li>
<li>We performed a remove operation on each of the files, while also adding the size of each of the files to <kbd>$TotalFileSize</kbd>.</li>
<li>In the end, we divided <kbd>$TotalFileSize</kbd> by 1024<sup>2</sup> and rounded it off to the nearest MB.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="https://msdn.microsoft.com/en-us/library/system.math_methods(v=vs.110).aspx">System.Math Methods</a> (Microsoft documentation)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performing calculations on the output</h1>
                </header>
            
            <article>
                
<p>In the last recipe, we performed some nifty calculations on the objects themselves, and listed out files that were 30 days old. In the process, we also output the total amount of space to be cleared. In this recipe, we will output this information as a PowerShell object, and also, perform a small calculation during output. Here is the scenario:</p>
<p>Modify the script you created in Performing Arithmetic Operations to output a structured PSCustomObject. The output should have the total number of files in the directory, files that are 30 days old, and the total amount of space cleared (without any calculations). Also, separately, show the amount of space cleared by the cleanup, in MB.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>If you don't have the lab files or you deleted the files in the previous recipe, <span>run the script, </span><kbd>Initialize-PacktPs6CoreLinuxLab.ps1</kbd><span> from within the </span><kbd>ch05</kbd><span> directory of the book's GitHub repository. </span><span>Next, run the script, </span><kbd>Set-LastWriteTime.ps1</kbd><span> from within the </span><kbd>ch09</kbd><span> directory of the repository.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it</h1>
                </header>
            
            <article>
                
<p>We will simply build on the previous recipe to save ourselves some time and effort. The changes from the script in the previous recipe have been emboldened.</p>
<ol>
<li>Open your favourite code editor, enter the following in the file and save the file as a <kbd>ps1</kbd> file.</li>
</ol>
<pre style="padding-left: 90px">$Today = Get-Date
$TotalFileSize = 0

<strong>$AllFiles = Get-ChildItem . -Recurse -File</strong>
$FilesToDelete = <strong>$AllFiles</strong> | Where-Object {[math]::Floor(($Today - $_.LastWriteTime).TotalDays) -eq 30}

foreach ($File in $FilesToDelete) {
    $TotalFileSize += $File.Length
    Remove-Item -Path $File -WhatIf
}

<strong>New-Object -TypeName psobject -Property @{
    TotalFiles = $AllFiles.Count
    FilesToDelete = $FilesToDelete.Count
    SpaceCleared = $TotalFileSize
}</strong></pre>
<ol start="2">
<li>Call the PowerShell script.</li>
</ol>
<pre style="padding-left: 90px">&amp; $HOME/Documents/code/github/powershell/ch09/02-Clear-LogFiles.ps1</pre>
<p>Here is a glimpse of what that outputs.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-799 image-border" src="Images/23e66bdf-6918-40c5-a598-2fcce9dc03f6.png" style="width:151.00em;height:53.08em;" width="1812" height="637"/></p>
<ol start="3">
<li>Now, pick just the <kbd>SpaceCleared</kbd> parameter.</li>
</ol>
<pre style="padding-left: 90px">(&amp; $HOME/Documents/code/github/powershell/ch09/02-Clear-LogFiles.ps1).SpaceCleared</pre>
<p style="padding-left: 60px">Notice the reference to the <kbd>SpaceCleared</kbd> property, and the output just before the prompt.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-800 image-border" src="Images/f40eaf52-ba68-4227-8ced-94c8e9a8dfdf.png" style="width:151.00em;height:36.33em;" width="1812" height="436"/></p>
<ol start="4">
<li>Divide the output by 1024<sup>2</sup> to get the value in MB.</li>
</ol>
<pre style="padding-left: 90px">(&amp; $HOME/Documents/code/github/powershell/ch09/02-Clear-LogFiles.ps1).SpaceCleared/[math]::Pow(1024, 2)</pre>
<p>Similar to the one above; the total space cleared in MB.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-801 image-border" src="Images/82f3680a-fbf5-46d3-9d2e-614f73356e49.png" style="width:150.67em;height:39.58em;" width="1808" height="475"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works</h1>
                </header>
            
            <article>
                
<p>Not only cmdlets and functions, but scripts also output objects. In the previous recipe, this was a string object; in this, it was a <kbd>PSCustomObject</kbd>. This way, even though the information gathered from both the recipes was the same, we were able to process the output further by running calculations on the fly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<ol>
<li>Perform a <kbd>Round()</kbd> operations on <kbd>SpaceCleared</kbd> to get the output in MB, with two digits after the decimal point.</li>
<li>Show the number of files that were omitted from deletion.</li>
</ol>
<div class="packt_tip">Assign the output object of the script to a variable: <kbd>$FileCleanupInfo = (&amp; //path/to/02-Clear-LogFiles.ps1)</kbd> in order to make things easier.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Administrative Constants</h1>
                </header>
            
            <article>
                
<p>The one thing that may have irked a few of us was how difficult it was to convert the <kbd>Length</kbd> property to MB. We had to go <kbd>[math]::Pow(1024, 2)</kbd>. Simplify the output of the previous recipe.</p>
<p>Also, imagine that you have these files loaded on a 250 GB SSD, and you would like to see what percent of space was cleared.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>If you don't have the lab files or you deleted the files in the previous recipe, </span><span>run the script, </span><kbd>Initialize-PacktPs6CoreLinuxLab.ps1</kbd><span> from within the </span><kbd>ch05</kbd><span> directory of the book's GitHub repository. </span><span>Next, run the script, </span><kbd>Set-LastWriteTime.ps1</kbd><span> from within the </span><kbd>ch09</kbd><span> directory of the repository.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it</h1>
                </header>
            
            <article>
                
<p>We will use the same script as the previous recipe.</p>
<ol>
<li>Assign the object returned by the previous recipe to a variable.</li>
</ol>
<pre style="padding-left: 90px"><span>$FileCleanupInfo = (&amp; //path/to/02-Clear-LogFiles.ps1)</span></pre>
<ol start="2">
<li>Call the <kbd>SpaceCleared</kbd> property and divide it by Administrative Constants.</li>
</ol>
<pre style="padding-left: 90px">$FileCleanupInfo.SpaceCleared/1KB<br/><span>$FileCleanupInfo.SpaceCleared/1MB<br/></span><span>$FileCleanupInfo.SpaceCleared/1GB</span></pre>
<p>Notice how the results are not just the numbers divided by powers of 1000.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-802 image-border" src="Images/d156b713-9b47-4582-b8d7-5a9526c42753.png" style="width:150.92em;height:29.67em;" width="1811" height="356"/></p>
<ol start="3">
<li>To show how much of space got cleared from a 250 GB SSD:</li>
</ol>
<pre style="padding-left: 90px">($FileCleanupInfo.SpaceCleared)/(250*<strong>1e9</strong>)*100</pre>
<p>An almost negligible number in our case, but here it is.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-804 image-border" src="Images/5e03aa51-3d22-4c06-81fd-6b2eb4acd117.png" style="width:151.00em;height:16.58em;" width="1812" height="199"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works</h1>
                </header>
            
            <article>
                
<p>PowerShell has been created with administrators in mind. Given that we rely on a myriad of file operations on a regular basis, PowerShell contains administrative constants. These constants represent powers of 1024 (1024<sup>1</sup>, 1024<sup>2</sup>, 1024<sup>3</sup>...).</p>
<p>Hard drive and flash drive manufacturers usually use powers of 1000 to represent drive sizes. In our recipe, we use the scientific notation to convert the size of the drive into bytes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with calculated properties</h1>
                </header>
            
            <article>
                
<p>If you read through the recipe, <em>Selecting columns from the output</em> in <em>Passing Data through the Pipeline</em>, you may skip this recipe. This recipe has been created in the interest of context as well as those who have skipped the said chapter/recipe.</p>
<p>Calculated properties is another form of performing calculations on the fly. Here is the scenario:</p>
<p>You need a report of all the files present in a certain directory, with the names of the files, the last modified date, the full paths and the sizes in MB.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>If you don't have the lab files or you deleted the files in the previous recipe, </span><span>run the script, </span><kbd>Initialize-PacktPs6CoreLinuxLab.ps1</kbd><span> from within the </span><kbd>ch05</kbd><span> directory of the book's GitHub repository. </span><span>Next, run the script, </span><kbd>Set-LastWriteTime.ps1</kbd><span> from within the </span><kbd>ch09</kbd><span> directory of the repository.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it</h1>
                </header>
            
            <article>
                
<p>This is going to be a one-liner.</p>
<p>At the terminal, type the following and press Enter.</p>
<pre>Get-ChildItem -file -rec | Select-Object name, lastwritetime, @{n = 'Size'; e = {[math]::Round($_.Length/1MB, 3)}}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works</h1>
                </header>
            
            <article>
                
<p>A calculated property takes in two things: the name of the property and the expression that would produce the desired result. Technically, this is a hashtable with <kbd>n</kbd> (or <kbd>Name</kbd>) and <kbd>e</kbd> (or <kbd>Expression</kbd>) being the two name-value pairs. The <kbd>Expression</kbd> in itself is a script block. When broken down into lines, the query looks like this:</p>
<pre>Get-ChildItem -File -Recurse | Select-Object Name, LastWriteTime, <strong>@{
    Name = "Size"
    Expression = {
        [math]::Round($PSItem.Length/1MB, 3)
    }
}</strong></pre>
<p>Since we separated the <kbd>Name</kbd> and the <kbd>Expression</kbd> by a line, we don't need the semicolon anymore.</p>
<p>Calculated properties come in handy in situation where you don't really want to create a new script, but instead, want some information at the terminal itself, as though running a query. The value of Name is the name of the property, and the values in the column are determined by the expression.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with binary numbers</h1>
                </header>
            
            <article>
                
<p>In the interest of specificity, we are going to use the hexadecimal notification for this recipe. If you have worked with colours on your computer, chances are that you are aware of RGB. The levels of these primary colours are commonly represented as numbers ranging from 0 to 255 (24-bit colours). You may have also come across the hexadecimal representation of these colours, especially if you worked with HTML/CSS.</p>
<p>The scenario here is to write a simple script that converts any given hexadecimal code into decimal RGB.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it</h1>
                </header>
            
            <article>
                
<p>We will assume that the input is going to be with or without the <kbd>#</kbd> (as in, <kbd>55bc9a</kbd> or <kbd>#55bc9a</kbd>).</p>
<ol>
<li>Open a new PowerShell file and type the following:</li>
</ol>
<pre style="padding-left: 90px">$Rgb = Read-Host "Enter the hexadecimal RGB value"
$TrimmedRgb = $Rgb.Substring($Rgb.Length - 6)

$R = $TrimmedRgb.Substring(0, 2)
$G = $TrimmedRgb.Substring(2, 2)
$B = $TrimmedRgb.Substring(4, 2)

"Here are the R, G and B levels for the supplied hex value:"
$R, $G, $B | ForEach-Object { [int]("0x" + $PSItem) }</pre>
<ol start="2">
<li>Run the script.</li>
<li>Enter any valid hexadecimal RGB value, with or without the preceding <kbd>#</kbd><span>. Press Enter.</span></li>
</ol>
<p>Here is an example.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-805 image-border" src="Images/94d666b2-56dd-468c-8133-e16db174148d.png" style="width:151.00em;height:30.00em;" width="1812" height="360"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works</h1>
                </header>
            
            <article>
                
<p>First, how the script works to separate the R, G and B values. We first trim the hexadecimal string to exclude the <kbd>#</kbd> in case there is one. We need the last 6 characters of the string. Therefore, we PowerShell to begin the substring at 1 in case there is a <kbd>#</kbd> and 0 in case the string is 6 characters long. We then pick two characters at a time, starting at 0 (of the trimmed string), 2 and 4.</p>
<p>The conversion happens at the last line. First, we instruct PowerShell that we would like an integer output using the cast operator. Then, we tell PowerShell that the string is a hexadecimal string by adding <kbd>0x</kbd> to its beginning.</p>
<p>This is a simple way of converting hexadecimal into integer. Next, we will look at a few other conversions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performing base conversion</h1>
                </header>
            
            <article>
                
<p>The last recipe was a simple conversion using a cast operator and string addition. Next, we will look at converting an integer into multiple bases such as octal, hexadecimal and binary strings.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it</h1>
                </header>
            
            <article>
                
<p>The input will be taken as a string. The output would also be string, but the octal, hexadecimal and binary representations. We will use a .NET accelerator for this.</p>
<ol>
<li><span>Open a new PowerShell file and type the following:</span></li>
</ol>
<pre style="padding-left: 90px">$InputString = Read-Host "Enter an integer"

Write-Host "Octal representation: " -NoNewline
Write-Host "$([Convert]::ToString($InputString, 8))"

Write-Host "Hexadecimal representation: " -NoNewline
Write-Host "$([Convert]::ToString($InputString, 16))"

Write-Host "Binary representation: " -NoNewline
Write-Host "$([Convert]::ToString($InputString, 2))"</pre>
<ol start="2">
<li>Run the script and enter an integer to get the octal, hexadecimal and binary representations of it.</li>
</ol>
<p>Do not forget to try negative numbers as well.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-806 image-border" src="Images/fc10c26b-d796-43b9-ac9b-15eba90fa9af.png" style="width:151.00em;height:26.08em;" width="1812" height="313"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works</h1>
                </header>
            
            <article>
                
<p>This recipe leverages the <kbd>[System.Convert]</kbd> .NET accelerator. The input and the output of the script are strings.</p>
<p>The <kbd>ToString()</kbd> method accepts input in the form of int64. When only one argument is passed, the integer is output as it is, except the object type is no more <kbd>int</kbd>, but <kbd>string</kbd>. The optional second argument passed to the method is the base: <kbd>2</kbd> stands for decimal, <kbd>8</kbd> stands for octal and <kbd>16</kbd> stands for hexadecimal.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>When I was learning PowerShell, I came across this recipe by Lee Holmes, where he showed how file attribute flags worked in PowerShell. To see what attributes are available in PowerShell for files and directories, and see their decimal and binary representations, enter the following at the PowerShell prompt.</p>
<pre>PS&gt; [Enum]::GetValues([System.IO.FileAttributes]) | Select-Object `<br/>@{ n = 'Property'; e = { $_ } }, <br/>@{ n = 'Decimal'; e = { [int]$_ } },<br/>@{ n = 'Binary'; e = { [Convert]::ToString([int]$_, 2) } }</pre>
<p>This is what the command gives you.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-807 image-border" src="Images/7dcf63f7-fa21-48b0-8d58-cb8e3480c39e.png" style="width:151.00em;height:99.58em;" width="1812" height="1195"/></p>
<p>That brings us to the end of this chapter. Basic arithmetic calculations have been omitted since they are no different from any of the most common languages.</p>


            </article>

            
        </section>
    </div>



  </body></html>