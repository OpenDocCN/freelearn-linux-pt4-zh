<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Menus, Arrays, and Functions</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Writing a script often means having to deal with user interaction. You want to know what the user expects from your script, and you want to let the user know what options they have to decide from. So, we give the user some choices, they give us their answers, we evaluate them against some preset values, and decide what to do next. This implies a method to expose some data to the user, gather their answer, cycle between options, and react accordingly. There are different ways to do this, and we will see how to accomplish the task using some standard constructs. At the end of this chapter, we will be able to offer, gather, store, and process data efficiently.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The case statement</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>When you are given more alternatives, you can process them with a sequence of if else statements:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">if [condition];<br class="title-page-name"/>then<br class="title-page-name"/>command<br class="title-page-name"/>else<br class="title-page-name"/>command<br class="title-page-name"/>fi</strong>
</pre>
<p class="calibre1"><span><span>The <kbd class="calibre9">if</kbd> clauses can be nested if needed, but in the long run, having more than a few choices messes up the code, making it less readable. One of the basic mantras of coding is exactly keeping the code readable, making it <em class="calibre20">elegant</em> since elegance here does not simply mean beautiful, but also consistent over time. Always keep a meaningful indentation so that the clauses will outstand. Try to use as little code as you can, adopt the same notation all through your script, and make it all compact and lean. So, having a cascade of <em class="calibre20">if/then/else/fi</em> with a lot of indentation cannot show up as the optimal decision for your script, but there is an alternative available and it is widely adopted to create user menus and process the data provided and it is the <kbd class="calibre9">case</kbd> statement in the following form:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">case expression in <br class="title-page-name"/></strong><strong class="calibre2">condition_1)<br class="title-page-name"/></strong><strong class="calibre2">command_1<br class="title-page-name"/></strong><strong class="calibre2">command_n<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">condition_2)<br class="title-page-name"/></strong><strong class="calibre2">command_1<br class="title-page-name"/></strong><strong class="calibre2">command_n<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">condition_n | z)<br class="title-page-name"/></strong><strong class="calibre2">command_1<br class="title-page-name"/></strong><strong class="calibre2">command_n<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">esac</strong>
</pre>
<p class="calibre1"><span><span>The expression is actually a condition that must match the pattern given in <kbd class="calibre9">condition x)</kbd>. Once the match is true, the corresponding block of commands are executed:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">condition_x)<br class="title-page-name"/>command_1<br class="title-page-name"/>command_n<br class="title-page-name"/>;;</strong>
</pre>
<p class="calibre1"><span><span>Each of these block of commands is called a <strong class="calibre2">clause</strong> and is terminated by the <kbd class="calibre9">;;</kbd> double semicolon. All the case statements are enclosed in </span></span><span><span><kbd class="calibre9">case</kbd> and </span></span><kbd class="calibre9"><span><span>esac </span></span></kbd><span><span>and each condition can be expressed either as</span></span> <span><span><kbd class="calibre9">condition_1)</kbd> </span></span><span><span>or </span></span><kbd class="calibre9"><span><span>condition_1 | condition_2 | condition_n)</span></span></kbd><span><span>.</span></span></p>
<p class="calibre1"><span><span>Each condition can be an alternative match for triggering the execution of the commands inside the clause.</span></span></p>
<p class="calibre1"><span><span>Let's see two examples of how to deal with the same options using the <em class="calibre20">if/then/else/fi</em> and <em class="calibre20">case/esac</em> constructs:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>echo "Please, give me some input"<br class="title-page-name"/>read input<br class="title-page-name"/>if [[ $input =~ ^[[:digit:]]+$ ]]; <br class="title-page-name"/>then<br class="title-page-name"/>echo "These are digits"<br class="title-page-name"/>exit 0<br class="title-page-name"/>elif [[ $input =~ ^[[:alpha:]]+$ ]]; <br class="title-page-name"/>then<br class="title-page-name"/>echo "These are chars"<br class="title-page-name"/>exit 0<br class="title-page-name"/>else<br class="title-page-name"/>echo "Dunno…"<br class="title-page-name"/>exit 1<br class="title-page-name"/>fi
</pre>
<p class="calibre1"><span><span>Now, let's look at some tests:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./if-statement.sh <br class="title-page-name"/></strong><strong class="calibre2">Please, give me some input<br class="title-page-name"/></strong><strong class="calibre2">123<br class="title-page-name"/></strong><strong class="calibre2">These are digits<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ./if-statement.sh <br class="title-page-name"/></strong><strong class="calibre2">Please, give me some input<br class="title-page-name"/></strong><strong class="calibre2">abc<br class="title-page-name"/></strong><strong class="calibre2">These are chars<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ./if-statement.sh <br class="title-page-name"/></strong><strong class="calibre2">Please, give me some input<br class="title-page-name"/></strong><strong class="calibre2">12a<br class="title-page-name"/></strong><strong class="calibre2">Dunno...<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ./if-statement.sh <br class="title-page-name"/></strong><strong class="calibre2">Please, give me some input<br class="title-page-name"/></strong><strong class="calibre2">!der<br class="title-page-name"/></strong><strong class="calibre2">Dunno...</strong>
</pre>
<p class="calibre1"><span><span>This is not complex code. We are asking for some input, and then we will check for a couple of conditions whether the text entered is all made of digits or characters; otherwise we have <kbd class="calibre9">dunno</kbd> as the default answer. We used a slightly more complicated version of <em class="calibre20">if/then/else/fi.</em> We adopted <kbd class="calibre9">elif</kbd> to check an alternative option to match for our condition. We could have gone further with a series of <kbd class="calibre9">elif</kbd> to check if the user input some alphanumerics or other kinds of characters, but as you can see from this tiny example, the code is still becoming a bit difficult to read; it is not so clear. Now, let's try something slightly different using the case statement:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>echo "Please, give me some input"<br class="title-page-name"/>read input<br class="title-page-name"/>case ${input//[[:alpha:]]} in<br class="title-page-name"/>"") <br class="title-page-name"/>echo "There were alphabetic chars only" <br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>*[[:alnum:]]*) <br class="title-page-name"/>echo "There were digits in the string"<br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>*) <br class="title-page-name"/>echo "There were non alphanumeric chars" <br class="title-page-name"/>exit 1<br class="title-page-name"/>;;<br class="title-page-name"/>esac
</pre>
<p class="calibre1"><span><span>What we do here is create a condition, so that we can strip all the alphabetic characters from the input variable value . What's left is checked against <kbd class="calibre9">""</kbd>. What does it mean? It simply means that if after stripping the string of all alpha characters what's left is an empty string. If the condition is not met we check against a second condition: if in what is left of the original strings there are some alphanumeric characters, it means that in the original string there were numeric characters. If even this second condition is met it means that in the stripped string there are chars other than numbers or alphabetic characters.</span></span></p>
<p class="calibre1"><span><span>Did you ever see or use a <kbd class="calibre9">case</kbd> statement before ? Yes, probably more often than you think. Let's do something interesting now; we will see later why it is so interesting. Go to the </span></span><span><kbd class="calibre9">/et/init.d/</kbd> </span><span><span>directory for Linux distribution, still <strong class="calibre2">SystemV</strong> compatible, and take a look at any of the scripts you find there. These are the scripts that deal with the startup/shutdown of system services such as cron or dbus along with all the additional services that can be offered such as ssh, Apache, and so forth. Looking at these scripts something pops out immediately, they have the following structure:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>case "$1" in<br class="title-page-name"/>start)<br class="title-page-name"/>:<br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>stop)<br class="title-page-name"/>:<br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>status)<br class="title-page-name"/>:<br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>restart)<br class="title-page-name"/>:<br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>condrestart)<br class="title-page-name"/>if $condition<br class="title-page-name"/>then<br class="title-page-name"/>exit 0<br class="title-page-name"/>fi<br class="title-page-name"/>exit 1<br class="title-page-name"/>;;<br class="title-page-name"/>*)<br class="title-page-name"/>echo $"Usage: $0 {start|stop|restart|condrestart|status}"<br class="title-page-name"/>exit 1<br class="title-page-name"/>;;<br class="title-page-name"/>esac<br class="title-page-name"/>exit 0
</pre>
<p class="calibre1"><span><span>This can be used as a base for our interactive scripts, since it provides a bare bones structure to deal with user interaction. As you can see, each clause has <kbd class="calibre9">:</kbd>, as being a base script, nothing gets executed; and for each clause, we graciously exit with a success code except for the conditional restart and the default options. The conditional restart is really optional, but it lets you restart your service based on a condition you will impose, so it is up to you to leave or delete this section. As we saw earlier in this book, the <kbd class="calibre9">case</kbd> construct is somewhat similar to the <em class="calibre20">if/then/else/fi</em> construct with a condition to match against different strings given as options. The construct is enclosed between the </span></span><span><span><kbd class="calibre9">case</kbd> and </span></span><kbd class="calibre9"><span><span>esac </span></span></kbd><span><span>markers; notice that <kbd class="calibre9">esac</kbd> is <kbd class="calibre9">case</kbd> read backwards. Consider the following clause: </span></span></p>
<pre class="codepackt">
<strong class="calibre2">string1 | string2 | stringn)<br class="title-page-name"/></strong><strong class="calibre2">do_something<br class="title-page-name"/></strong><strong class="calibre2">do_somethingn<br class="title-page-name"/></strong><strong class="calibre2">;;</strong>
</pre>
<p class="calibre1"><span><span>It starts with one or more strings to be matched; each possible match is separated by a <kbd class="calibre9">|</kbd> and ends with  <kbd class="calibre9">;;</kbd>. If more than one match is true, only the first is taken into account. The last option is usually an asterisk, and this can be considered as a catchall default since <kbd class="calibre9">*</kbd> </span></span><span><span>matches whatever strings the user inputs. So, if no previous matches trigger a clause, this last one will be matched anyway and is a good place to write help or some command-line utilization messages, since it will always be displayed if the user did not enter the right options.</span></span></p>
<p class="calibre1"><span><span>The string of patterns to match can be optionally preceded by <kbd class="calibre9">(</kbd>, for example, </span></span><span><span><kbd class="calibre9">(string1 | string2 | stringn)</kbd>. </span></span><span><span>Remember that the last <kbd class="calibre9">;;</kbd> before <kbd class="calibre9">esac</kbd> can be omitted without causing any issues.</span></span></p>
<p class="calibre1"><span><span>Each string starting the clause is an optional match for </span></span><span><span>case condition in. This</span></span><span><span> is usually a string of text that must be checked for a match against each option string starting a clause. If the condition is a variable, it is expanded using the parameter expansion, variable expansion (tilde), command substitution, process substitution, and quote removal, but no pathname expansion, brace expansion, or word splitting is performed. Given that, you do not need to quote the variable for safe processing.</span></span></p>
<p class="calibre1"><span><span>From Bash 4 a couple of clause terminators were introduced, and we already saw them in the previous chapter:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">;&amp;</kbd> makes the execution continue with the commands associated with the next condition</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">;;&amp;</kbd> makes the shell check the option and execute the associated commands if the condition is matched</span></span></li>
</ul>
<p class="calibre1"><span><span>If no matches are found, the exit status is 0, otherwise the exit status is the one from the last command executed.</span></span></p>
<p class="calibre1"><span><span>Let's see how they word and proceed to modify the base script:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>case "$1" in<br class="title-page-name"/>start)<br class="title-page-name"/>echo "We are starting..."<br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>stop)<br class="title-page-name"/>echo "We are stopping..."<br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>status)<br class="title-page-name"/>echo "We are checking the status..."<br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>restart)<br class="title-page-name"/>echo "We are restarting..."<br class="title-page-name"/>exit 0<br class="title-page-name"/>;;<br class="title-page-name"/>*)<br class="title-page-name"/>echo $"Usage: $0 {start|stop|restart|status}"<br class="title-page-name"/>exit 1<br class="title-page-name"/>;;<br class="title-page-name"/>esac<br class="title-page-name"/>exit 0
</pre>
<p class="calibre1"><span><span>Now, let's try it out:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./terminators.sh <br class="title-page-name"/></strong><strong class="calibre2">Usage: ./terminators.sh {start|stop|restart|status}</strong>
</pre>
<p class="calibre1"><span><span>Without any arguments, there cannot be any matches on a given option, so the catchall asterisk comes into play and executes the echo printing the usage message on <kbd class="calibre9">stdout</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./terminators.sh start<br class="title-page-name"/></strong><strong class="calibre2">We are starting...<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ./terminators.sh stop<br class="title-page-name"/></strong><strong class="calibre2">We are stopping...<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ./terminators.sh restart<br class="title-page-name"/></strong><strong class="calibre2">We are restarting...<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ./terminators.sh status<br class="title-page-name"/></strong><strong class="calibre2">We are checking the status...</strong>
</pre>
<p class="calibre1"><span><span>All the other options are straightforward; we deleted the <kbd class="calibre9">condrestart</kbd> option just to make the script more compact and easy to read.</span></span></p>
<p class="calibre1"><span><span>Now, let's use the <kbd class="calibre9">;&amp;</kbd> terminator on the last clause:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">restart)<br class="title-page-name"/></strong><strong class="calibre2">echo "We are checking the status..."<br class="title-page-name"/></strong><strong class="calibre2">exit 0<br class="title-page-name"/></strong><strong class="calibre2">;&amp;</strong>
</pre>
<p class="calibre1"><span><span>Now, execute the script with status as the argument:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:$ ./terminators.sh status<br class="title-page-name"/></strong><strong class="calibre2">We are checking the status...</strong>
</pre>
<p class="calibre1"><span><span>Ahem, embarrassing, nothing changed. Why? Have a closer look at the clause: the <kbd class="calibre9">;&amp;</kbd> terminator is preceded by <kbd class="calibre9">exit 0</kbd>, so the execution of the script stops before hitting the terminator. Well, let's delete <kbd class="calibre9">exit 0</kbd> and invoke the script again with the status argument:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./terminators-last.sh status<br class="title-page-name"/></strong><strong class="calibre2">We are checking the status...<br class="title-page-name"/></strong><strong class="calibre2">We are restarting...</strong>
</pre>
<p class="calibre1"><span><span>Interesting, isn't it? We cascaded from one block to the other, so we had the status block commands executed right after the restart block commands got executed. And this is exactly what we expected from the <kbd class="calibre9">;&amp;</kbd> operator, since the execution had to proceed to the next block where once the first condition was met. But now, let's do something else and modify the restart clause as well:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">restart)<br class="title-page-name"/></strong><strong class="calibre2">echo "We are restarting..."<br class="title-page-name"/></strong><strong class="calibre2">;;&amp;</strong>
</pre>
<p class="calibre1"><span><span>Let's execute the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./terminators-last.sh status<br class="title-page-name"/></strong><strong class="calibre2">We are checking the status...<br class="title-page-name"/></strong><strong class="calibre2">We are restarting...<br class="title-page-name"/></strong><strong class="calibre2">Usage: ./terminators-last.sh {start|stop|restart|status}</strong>
</pre>
<p class="calibre1"><span><span>What happened? Simply put, once the <kbd class="calibre9">status</kbd> string was matched, the first <kbd class="calibre9">echo</kbd> command got executed and the <kbd class="calibre9">;&amp;</kbd> operator caused the command associated to the restart clause to be invoked  without any other string check. In the restart clause, the <kbd class="calibre9">;;&amp;</kbd> operator caused a string check on the following clause, but this being a string match against a wildcard, it matched anyway so the <kbd class="calibre9">echo</kbd> command of the <kbd class="calibre9">usage</kbd> string was executed. But what happens if we invert the operators between the status and restart clauses:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./terminators-last.sh status<br class="title-page-name"/></strong><strong class="calibre2">We are checking the status...<br class="title-page-name"/></strong><strong class="calibre2">Usage: ./terminators-last.sh {start|stop|restart|status}</strong>
</pre>
<p class="calibre1"><span><span>We entered the <kbd class="calibre9">status</kbd> clause, executed the code, and then proceeded to the <kbd class="calibre9">restart</kbd> code. Here, the command was not executed since <kbd class="calibre9">;;&amp;</kbd> triggers the command execution only if the string matches, but our <kbd class="calibre9">status</kbd> argument does not match the <kbd class="calibre9">restart</kbd> option. In the next line, we have  <kbd class="calibre9">;&amp;</kbd>, which cascades us to the next clause, whose code is executed regardless of any matches. If you want to cause the commands in the <kbd class="calibre9">restart</kbd> clause to be executed anyway, just modify the matching options:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">restart | status)<br class="title-page-name"/></strong><strong class="calibre2">echo "We are restarting..."<br class="title-page-name"/></strong><strong class="calibre2">;&amp;</strong>
</pre>
<p class="calibre1"><span><span>And now, let's try this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./terminators-last.sh status<br class="title-page-name"/></strong><strong class="calibre2">We are checking the status...<br class="title-page-name"/></strong><strong class="calibre2">We are restarting...<br class="title-page-name"/></strong><strong class="calibre2">Usage: ./terminators-last.sh {start|stop|restart|status}</strong>
</pre>
<p class="calibre1"><span><span>In this case, we gave two possible matches for the restart clause, <kbd class="calibre9">restart</kbd>  or <kbd class="calibre9">status</kbd>. The first failed, but the second matched, and the command got executed, and then the next clause command got executed as well.</span></span></p>
<p class="calibre1"><span><span>We saw the <kbd class="calibre9">case</kbd> construct used in a startup script with minimal interaction with the user, but now, let's start working on this construct to make something more interesting out of it:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>clear<br class="title-page-name"/>echo -n "May I create an archive out of the current directory files? [yes or no]: "<br class="title-page-name"/>read input<br class="title-page-name"/>case $input in<br class="title-page-name"/>[yY] | [yY][eE][sS] )<br class="title-page-name"/>echo -e<br class="title-page-name"/>echo "Yes, of course...I am proceeding"<br class="title-page-name"/>echo -e "Archiving the following files\n"<br class="title-page-name"/>now=$(date +%Y.%m.%d.%H.%M.%S)<br class="title-page-name"/>filename=${PWD##*/}<br class="title-page-name"/>tar cvzf ${now}.${filename}.tgz *<br class="title-page-name"/>echo -e<br class="title-page-name"/>echo "Archive $now.${filename}.tgz created!"<br class="title-page-name"/>;;<br class="title-page-name"/>[nN] | [nN][oO] )<br class="title-page-name"/>echo -e<br class="title-page-name"/>echo "No, so have a lovely day".;<br class="title-page-name"/>echo -e<br class="title-page-name"/>exit 1<br class="title-page-name"/>;;<br class="title-page-name"/>*)<br class="title-page-name"/>echo -e<br class="title-page-name"/>echo "Please just answer yes or no, y, n, in lower or capital."<br class="title-page-name"/>echo -e<br class="title-page-name"/>;;<br class="title-page-name"/>esac
</pre>
<p class="calibre1"><span><span>This simple script can be used to archive the content of a directory. It asks the user for the content and checks the answer against the lower and upper case</span></span> <kbd class="calibre9">y</kbd> <span><span>, </span></span><kbd class="calibre9">yes</kbd><span><span>,</span></span> <kbd class="calibre9">n</kbd> <span><span>, and</span></span> <kbd class="calibre9">no</kbd><span><span>. Nothing too difficult here; we are just putting together things we already saw in the previous chapters. We start off with a clear instruction to clean the screen from any previous content, and then we ask the user for <kbd class="calibre9">yes</kbd> or <kbd class="calibre9">no</kbd> using an <kbd class="calibre9">echo -n</kbd>. So, we do not output any new lines, and the user answer will be on the same line after the double colon. The next step is to check against a list of characters.</span></span></p>
<p class="calibre1"><span><span><kbd class="calibre9">[yY] | [yY][Ee][Ss] )</kbd></span></span><span><span> will match both the lower and capital <kbd class="calibre9">y</kbd> but also against <kbd class="calibre9">yes</kbd> and <kbd class="calibre9">YES</kbd> and all the mix between lower and capital characters in this string. If this matches, we inform the user that we are proceeding to archive the file. Notice <kbd class="calibre9">echo -e</kbd> that we used; this enables the interpretation of backslash escapes, so we can use </span></span><span><span><kbd class="calibre9">\n</kbd> </span></span><span><span>to enter a new line and go to the next line on the terminal. The next instruction is a command substitution, so we get the output of the <kbd class="calibre9">date</kbd> command assigned to the now variable. What we are doing is creating the bits that will later concatenate to obtain a unique filename for our archive. In this case, we get a date composed by </span></span><span><span><kbd class="calibre9">year.month.day.hour.minute.second</kbd>. </span></span><span><span>We will use this string to prefix our archive, so we will be able to obtain a unique filename every second. But this is also a limit, because if we create two archives at the same moment, the latter will overwrite the former, having both the names the same.</span></span></p>
<p class="calibre1"><span><span>Keep in mind your goals and limits and stick to them. When creating some variables or conditions, you have to think at the scope of your effort and not overthink about what you are doing. An example here is the prefix for the archive name. Giving us a name that is unique in the time range of a second allows us to have a new filename every single second, but it exposes us to the risk of having the archive overwritten if the same script is invoked twice at the same time, for instance, from two different terminals. To avoid this, we could create a function to forge random strings as prefix and avoid this issue or, at least, highly reduce the probability of a name collision. We will see later in this book how to create a random string, but is it worthy now? We are creating an example to show the use of case to process the user input and create an archive, so it is not likely that this script will be run twice at the same time. It could be great to catch this condition, but since it is not in the scope of this project, we will not do so, since the time spent will not be justified by the result and the likeliness of the event that it would prevent. On the opposite side, when writing a script, take your time to clarify to yourself what this script should do, what could be the pitfalls, which errors could occur, and the possible remedies you could code into the script itself.</span></span></p>
<p class="calibre1"><span><span>Professional programming is not just coding, it is planning, trying to understand what could happen, what you want, and how to reach the goal. First, ask yourself what goal you want to accomplish, how to reach it, if you can realistically get to it with your knowledge, means, time, resources, and so on. Then, plan and develop accordingly. This applies to you as well as your clients since most of the time the hardest part is to understand what your customer really wants, being aware or not of it, how much time and resources it takes to code, and if the customer is willing to give you the time required and the resources needed. Finally, ask yourself if you can work on it given all these requisites. Let's say that if you were asked to code a simple calculator in assembly, you probably could do so after learning it, practicing a bit, and then trying a few times. But could you do it if you were given three days, starting from scratch? So, define the goal, its limits and resources, plan the execution, think of the pitfalls your code could face and then, well, take into account a fair contingency: your computer could stop working, you can get a cold, anything can happen so keep a fair amount of time as a contingency because your client has a delivery date in mind, and you have to deliver your code on time, cold, flu, computer gone crazy given. Finally, stick to a routine. Let's say you have four hours a day for coding and you know that in this amount of time, you can code 50 lines; but with exceptional effort, you could code 65 file lines. Do not take 65 lines into account and stick to an average amount. You are confident with this since you are going to code on a daily basis for quite a few days, and you cannot allow yourself to sprint every single day. Create your routine on an effort you know you can carry for a large amount of time so that you and your client do not incur an unpleasant situation.</span></span></p>
<p class="calibre1"><span><span>So, after this digression, let's go on and check the last couple of interesting commands in the <kbd class="calibre9">yes</kbd> clause:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">filename=${PWD##*/}<br class="title-page-name"/></strong><strong class="calibre2">tar cvzf ${now}.${filename}.tgz *</strong>
</pre>
<p class="calibre1"><span><span>The first line helps us to find the name of the current directory using parameter expansions: we get the content of the <kbd class="calibre9">$PWD</kbd> environment variable and delete the longest matching for the pattern, in our case all the path up until the last forward slash, and assign the result to the variable called filename. The second instruction creates an archive from all the files contained in the local directory called <kbd class="calibre9">*</kbd> and create the archive name out of the different bits that we prepared beforehand. Note<kbd class="calibre9">${}</kbd>, which allows us to preserve the variable during the concatenation. So, now is the time to execute the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">May I create an archive out of the current directory files? [yes or no]: yEs<br class="title-page-name"/></strong><strong class="calibre2">Yes, of course...I am proceeding<br class="title-page-name"/></strong><strong class="calibre2">Archiving the following files...<br class="title-page-name"/></strong><strong class="calibre2">base.sh<br class="title-page-name"/></strong><strong class="calibre2">case-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">if-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators-last.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators.sh<br class="title-page-name"/></strong><strong class="calibre2">user-case.sh<br class="title-page-name"/></strong><strong class="calibre2">Archive 2017.02.26.12.24.55.Scripts.tgz created!<br class="title-page-name"/></strong><strong class="calibre2">And check if the archive has been really created:<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ tar -tf 2017.02.26.12.24.55.Scripts.tgz <br class="title-page-name"/></strong><strong class="calibre2">base.sh<br class="title-page-name"/></strong><strong class="calibre2">case-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">if-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators-last.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators.sh<br class="title-page-name"/></strong><strong class="calibre2">user-case.sh</strong>
</pre>
<p class="calibre1"><span><span>We were able to list the files held into the archive and a simple <kbd class="calibre9">ls</kbd> will double-check the outcome:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -A1<br class="title-page-name"/></strong><strong class="calibre2">2017.02.26.12.24.55.Scripts.tgz<br class="title-page-name"/></strong><strong class="calibre2">base.sh<br class="title-page-name"/></strong><strong class="calibre2">case-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">if-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators-last.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators.sh<br class="title-page-name"/></strong><strong class="calibre2">user-case.sh</strong>
</pre>
<p class="calibre1"><span><span>All the files are in place and we can also see the newly created archive. But are we sure that everything is fine? Let's create a <kbd class="calibre9">test</kbd> directory and copy all our files in it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ mkdir test<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ cp * test<br class="title-page-name"/></strong><strong class="calibre2">cp: -r not specified; omitting directory 'test'<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ chmod -R 0550 test</strong>
</pre>
<p class="calibre1"><span><span>We copied the files in the <kbd class="calibre9">test</kbd> directory and set the directory permissions so that no one will be able to write into it. Now, let's enter the directory and run our script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">May I create an archive out of the current directory files? [yes or no]: yes<br class="title-page-name"/></strong><strong class="calibre2">Yes, of course...I am proceeding<br class="title-page-name"/></strong><strong class="calibre2">Archiving the following files...<br class="title-page-name"/></strong><strong class="calibre2">base.sh<br class="title-page-name"/></strong><strong class="calibre2">case-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">if-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators-last.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators.sh<br class="title-page-name"/></strong><strong class="calibre2">user-case.sh<br class="title-page-name"/></strong><strong class="calibre2">tar (child): 2017.02.27.08.40.03.test.tgz: Cannot open: Permission denied<br class="title-page-name"/></strong><strong class="calibre2">tar (child): Error is not recoverable: exiting now<br class="title-page-name"/></strong><strong class="calibre2">tar: Child returned status 2<br class="title-page-name"/></strong><strong class="calibre2">tar: Error is not recoverable: exiting now<br class="title-page-name"/></strong><strong class="calibre2">Archive 2017.02.27.08.40.03.test.tgz created!</strong>
</pre>
<p class="calibre1"><span><span>Interesting, we see some error messages, but the script still says we have an archive file, let's check it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -A1<br class="title-page-name"/></strong><strong class="calibre2">base.sh<br class="title-page-name"/></strong><strong class="calibre2">case-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">if-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators-last.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators.sh<br class="title-page-name"/></strong><strong class="calibre2">user-case.sh</strong>
</pre>
<p class="calibre1"><span><span>No, we do not have any new archive, and this is exactly what we'd expect since our user cannot write anything in the test directory. So, it can happen; sometimes, our script faces an issue, such as it cannot write or read from a directory or some files, and this is what we have to plan now: a contingency method to deal with this possible issue. What we can do is test to check the exit code of the <kbd class="calibre9">tar</kbd> command: if it is different from <kbd class="calibre9">0</kbd>, it means that the archive creation failed somehow, otherwise everything went fine. So, let's rewrite the <kbd class="calibre9">yes</kbd> clause adding a test after the <kbd class="calibre9">tar</kbd> command:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">tar cvzf $now.${filename}.tgz *<br class="title-page-name"/></strong><strong class="calibre2">if [ $? -ne 0 ]<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "Sorry there was an issue creating the archive..."<br class="title-page-name"/></strong><strong class="calibre2">exit 1<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo -e<br class="title-page-name"/></strong><strong class="calibre2">echo "Archive ${now}.${filename}.tgz created!"<br class="title-page-name"/></strong><strong class="calibre2">exit 0<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">;;</strong>
</pre>
<p class="calibre1"><span><span>Be careful not to write any command between <kbd class="calibre9">tar</kbd> and the <kbd class="calibre9">test</kbd>, since the <kbd class="calibre9">$?</kbd> traps the exit code of the last command executed. Now, let's check the outcome:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">May I create an archive out of the current directory files? [yes or no]: yes<br class="title-page-name"/></strong><strong class="calibre2">Yes, of course...I am proceeding<br class="title-page-name"/></strong><strong class="calibre2">Archiving the following files...<br class="title-page-name"/></strong><strong class="calibre2">tar (child): 2017.02.27.09.20.17.test.tgz: Cannot open: Permission denied<br class="title-page-name"/></strong><strong class="calibre2">tar (child): Error is not recoverable: exiting now<br class="title-page-name"/></strong><strong class="calibre2">base.sh<br class="title-page-name"/></strong><strong class="calibre2">case-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">if-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators-last.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators.sh<br class="title-page-name"/></strong><strong class="calibre2">user-case.sh<br class="title-page-name"/></strong><strong class="calibre2">tar: 2017.02.27.09.20.17.test.tgz: Cannot write: Broken pipe<br class="title-page-name"/></strong><strong class="calibre2">tar: Child returned status 2<br class="title-page-name"/></strong><strong class="calibre2">tar: Error is not recoverable: exiting now<br class="title-page-name"/></strong><strong class="calibre2">Sorry there was an issue creating the archive…</strong>
</pre>
<p class="calibre1"><span><span>Not bad! Now, our script is telling us that something has gone wild, and it stopped telling us that the archive was successfully created even though the <kbd class="calibre9">tar</kbd> command was failing. Anyway, the output is a bit messy. We already know from our error message that there was an error, so let's clean the output by modifying </span></span><span><span><kbd class="calibre9">tar cvzf $now.${filename}.tgz * 2&gt;/dev/null</kbd>.</span></span></p>
<p class="calibre1"><span><span>We just redirected the standard error to <kbd class="calibre9">/dev/null</kbd>, so no errors will be displayed to <kbd class="calibre9">stdout</kbd>.</span></span></p>
<p class="calibre1"><span>Most of the time, it is preferable to mask the system or application errors and provide the customer with a more meaningful error message crafted by you. Bear in mind that not all users are system administrators or programmers and familiar with the operating system, application error messages, or codes.</span></p>
<p class="calibre1"><span><span>Let's have a look at the output:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">May I create an archive out of the current directory files? [yes or no]: yes<br class="title-page-name"/></strong><strong class="calibre2">Yes, of course...I am proceeding<br class="title-page-name"/></strong><strong class="calibre2">Archiving the following files...<br class="title-page-name"/></strong><strong class="calibre2">base.sh<br class="title-page-name"/></strong><strong class="calibre2">case-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">if-statement.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators-last.sh<br class="title-page-name"/></strong><strong class="calibre2">terminators.sh<br class="title-page-name"/></strong><strong class="calibre2">user-case.sh<br class="title-page-name"/></strong><strong class="calibre2">Sorry there was an issue creating the archive.</strong>
</pre>
<p class="calibre1"><span><span>It is actually cleaner, and we could even go further and rip out the list of files. Do you know how to do it? A tip, the <kbd class="calibre9">stdout</kbd>…</span></span></p>
<p class="calibre1"><span><span>But then, look at the following clause:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">[yY] | [yY][eE][sS] )<br class="title-page-name"/></strong><strong class="calibre2">echo -e<br class="title-page-name"/></strong><strong class="calibre2">echo "Yes, of course...I am proceeding"<br class="title-page-name"/></strong><strong class="calibre2">echo -e "Archiving the following files...\n"<br class="title-page-name"/></strong><strong class="calibre2">now=$(date +%Y.%m.%d.%H.%M.%S)<br class="title-page-name"/></strong><strong class="calibre2">filename=${PWD##*/}<br class="title-page-name"/></strong><strong class="calibre2">if tar cvzf $now.${filename}.tgz * 2&gt;/dev/null<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo -e<br class="title-page-name"/></strong><strong class="calibre2">echo "Archive ${now}.${filename}.tgz created!"<br class="title-page-name"/></strong><strong class="calibre2">exit 0<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "Sorry there was an issue creating the archive..."<br class="title-page-name"/></strong><strong class="calibre2">exit 1<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">;;</strong>
</pre>
<p class="calibre1"><span><span>The results are the same, but we used <kbd class="calibre9">if</kbd> in a more idiomatic way, since its purpose is to test if a condition is true or not, so in this case if the command succeeded or failed. But then, you have many ways to accomplish the same result; take a look here:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ rm base.sh &amp;&amp; echo "File deleted" || echo "File not deleted"<br class="title-page-name"/></strong><strong class="calibre2">rm: cannot remove 'base.sh': Permission denied<br class="title-page-name"/></strong><strong class="calibre2">File not deleted</strong>
</pre>
<p class="calibre1"><span><span>The <kbd class="calibre9">remove</kbd> command, given inside the test directory, fails due to the lack of permissions, but let's go up one directory and create a test file:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ touch test1<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ rm test1 &amp;&amp; echo "File deleted" || echo "File not deleted"<br class="title-page-name"/></strong><strong class="calibre2">File deleted</strong>
</pre>
<p class="calibre1">I used the logical AND/OR operators to take advantage of what I usually called short circuit. Read the previous examples with the following grammar:</p>
<p class="calibre1"><em class="calibre20">If [command1] is true than we evaluate also command2 [but if the first clause is not true execute command3]</em></p>
<p class="calibre1"><span><span>Using the logical AND, both the commands called <kbd class="calibre9">rm test1</kbd> and <kbd class="calibre9">echo "file deleted"</kbd> must be true for the overall expression on the left of the OR (||). If the first command does not evaluate to true, the second is not even taken into account (short circuiting).</span></span></p>
<p class="calibre1"><span><span>If</span></span><span><span> the first part called <kbd class="calibre9">left_command &amp;&amp; right_command</kbd> evaluates to be false, the OR comes into play and triggers the execution of the last command. But just in case that the first part, before <kbd class="calibre9">||</kbd> is true, then the second part will not be triggered. This is because, for the overall expression </span></span><span><span><kbd class="calibre9">left_command || right_command</kbd> </span></span>to be true, it is enough for one of the two to be true and the first being true, the second command is not even evaluated (short circuiting).</p>
<p class="calibre1">This kind of error handling does not cause a script to exit in case of issues, and this can be desirable behavior most of the time, but sometimes, we could resort to a trick that would throw us out in case of errors:</p>
<pre class="codepackt">
#!/bin/bash -e
</pre>
<p class="calibre1">This will cause the exit from the script if any command, in subshell or braces, exits with a non-zero code. This does not apply if the failing command is part of a command list right after a while or until command, a part of the  <em class="calibre20">fi/elif</em> test in a <em class="calibre20">if/then/else/fi</em> statement, or is part of a set of commands executed following <kbd class="calibre9">&amp;&amp;</kbd> or <kbd class="calibre9">||</kbd>.</p>
<p class="calibre1">We will see more examples on how to use the case construct later on, as of now we are going to see something interesting that will affect the way you will collect, store, and process data. So, get ready for the arrays.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Arrays</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Think of an array as a structure that can hold more than a single object, something like a variable with one or many values. Imagine you have a few friends and you want to write down their names:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">friend_1=Anthony<br class="title-page-name"/></strong><strong class="calibre2">friend_2=Mike<br class="title-page-name"/></strong><strong class="calibre2">friend_3=Noel<br class="title-page-name"/></strong><strong class="calibre2">friend_4=Tarek<br class="title-page-name"/></strong><strong class="calibre2">friend_5=Dionysios</strong>
</pre>
<p class="calibre1"><span><span>Once you have the variables instanced, you can then deference them, deferencing being the act of retrieving a value. This is OK, but it somehow cages you into some limitations, such as you must call the exact variable name to access its value, you cannot easily cycle between them, you cannot tell the number of values so quickly, and more. For such operations, there is an appropriate structure, which comes at hand and allows us to work on the values as a single entity--this is the array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">friends=(Anthony Mike Noel Tarek Dionysios)</strong>
</pre>
<p class="calibre1"><span><span>The elements inside an array are indexed, and its position is assigned during the assignment, so <kbd class="calibre9">Anthony</kbd> will be at the first position and <kbd class="calibre9">Dionysios</kbd> at the fifth. But once declared and instanced, we can add elements to the array in a specific position:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">friends[6]=Claudia</strong>
</pre>
<p class="calibre1"><span><span>How do you check if what is said so far is correct? A good way to do this would be accessing the different elements printing the values at the different positions:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ friends=(Anthony Mike Noel Tarek Dionysios) ; echo ${friends[0]} ; echo ${friends[4]} ; echo ${friends[5]} ; friends[5]=Claudia ; echo ${friends[5]}<br class="title-page-name"/></strong><strong class="calibre2">Anthony<br class="title-page-name"/></strong><strong class="calibre2">Dionysios<br class="title-page-name"/></strong><strong class="calibre2">Claudia</strong>
</pre>
<p class="calibre1"><span><span>From the previous example, we can see a couple of interesting things:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span>The first position of an array has an index of 0</span></span></li>
<li class="calibre13"><span><span>A value is accessed in the form of <kbd class="calibre9">${array_name[index]}</kbd></span></span></li>
<li class="calibre13"><span><span>If not assigned, a position does not hold any value</span></span></li>
<li class="calibre13"><span><span>We can assign a value to any position using an index</span></span></li>
</ul>
<p class="calibre1"><span><span>Let's add another person to the list now:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">friends[-2]=Ilaria</strong>
</pre>
<p class="calibre1"><span><span>Now, it would be fine to have a way to print the whole content of the array at once, since the number of elements is growing, and it is taking a bit of time to echo all the indexed values. So, we can either use </span></span><span><span><kbd class="calibre9">array_name[@]</kbd> </span></span><span><span>or </span></span><span><span><kbd class="calibre9">array_name[*]</kbd> </span></span><span><span>to access the whole content of the array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo ${friends[@]}<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">Anthony Mike Noel Tarek Ilaria Claudia</strong>
</pre>
<p class="calibre1"><span><span>What is interesting here is the position of <kbd class="calibre9">Ilaria</kbd> into the array. We inserted this name at position -2, so using a negative index provides a new feature introduced in Bash 4.2 that allows us to locate a position in the array starting from the end of it. So, -2 means two slots starting from the end of the array. But now, let's go back to the array declaration. We just saw one way to create an array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">array_name=(element_1 element_2 element_n)</strong>
</pre>
<p class="calibre1"><span><span>There are other ways to create an array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">array_name[index]</strong>
</pre>
<p class="calibre1"><span><span>In this case, the index must be a positive integer, since we do not have any slots to count backward:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ test[2]="Here I am!" ; for i in {0..5} ; do echo $i ${test[$i]} ; done<br class="title-page-name"/></strong><strong class="calibre2">0<br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2 Here I am!<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">4<br class="title-page-name"/></strong><strong class="calibre2">5<br class="title-page-name"/></strong><strong class="calibre2">declare -a array_name</strong>
</pre>
<p class="calibre1"><span><span>No index needed here, even if given, it will be ignored. This way of declaring an array can be useful in cases when you do not yet know which values will be stored into it:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -a friends<br class="title-page-name"/>clear<br class="title-page-name"/>echo -n "Can you please tell me the name of some of your friends: "<br class="title-page-name"/>read -a friends<br class="title-page-name"/>echo "So, your friends are: ${friends[@]}"
</pre>
<p class="calibre1"><span>Even if you instance an array using another form, placing <kbd class="calibre9">declare -a array_name</kbd> before the instantiation can speed up subsequent operations on the array itself.</span></p>
<p class="calibre1"><span><span>We just declared an array named <kbd class="calibre9">friends</kbd> and used the read built-in, but this time, we gave the <kbd class="calibre9">-a</kbd> option ,which force read to get any words from the user and assigned to the named array indexes in a sequential order. Bear in mind that<kbd class="calibre9">-a</kbd> forces the unsetting of the array before the first assignment. Now, let's try this wee script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Can you please tell me the name of some of your friends: Ilaria Max Ron<br class="title-page-name"/></strong><strong class="calibre2">So, your friends are: Ilaria Max Ron</strong>
</pre>
<p class="calibre1"><span><span>From Bash 4 on, there is a new type of array called an <strong class="calibre2">associative array</strong>. These are a bit different from the indexed arrays that we have seen so far: think of it as a set of two linked arrays:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -A friends<br class="title-page-name"/>clear<br class="title-page-name"/>echo -n "Can you please tell me the name of one of your friends: "<br class="title-page-name"/>read name<br class="title-page-name"/>echo -n "And now his email address: "<br class="title-page-name"/>read address<br class="title-page-name"/>friends[$name]=${address}<br class="title-page-name"/>echo -e "So, your friend name is: ${!friends[@]}\nHis email address is: ${friends[@]}"
</pre>
<p class="calibre1"><span><span>We just declared an associative array called <kbd class="calibre9">friends</kbd> and asked the user for two values, one a name and the other an email, but we stored them in two different variables instead of inserting them directly in an array. Inserting in the array was the next action. Use the name value as index and the address value as the linked content:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Can you please tell me the name of one of your friends: Giorgio Zarrelli<br class="title-page-name"/></strong><strong class="calibre2">And now his email address: giorgio@whatever.net<br class="title-page-name"/></strong><strong class="calibre2">So, your friend name is: Giorgio Zarrelli<br class="title-page-name"/></strong><strong class="calibre2">His email address is: giorgio@whatever.net</strong>
</pre>
<p class="calibre1"><span><span>For our demonstration purposes, we did not check the input, but have a look at this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Can you please tell me the name of one of your friends: <br class="title-page-name"/></strong><strong class="calibre2">And now his email address: <br class="title-page-name"/></strong><strong class="calibre2">./declare-array-associative.sh: line 9: friends[$name]: bad array subscript<br class="title-page-name"/></strong><strong class="calibre2">So, your friend name is: <br class="title-page-name"/></strong><strong class="calibre2">His email address is: </strong>
</pre>
<p class="calibre1"><span><span>An associative array index cannot be made entirely blank, so we can modify the previous script to add a check on the name value:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">read name<br class="title-page-name"/></strong><strong class="calibre2">if [[ -z "$name" ]]<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "The name value cannot be blank"<br class="title-page-name"/></strong><strong class="calibre2">exit 1<br class="title-page-name"/></strong><strong class="calibre2">fi</strong>
</pre>
<p class="calibre1"><span><span>We just checked for the <kbd class="calibre9">name</kbd> variable not to be unset or empty, and this saved us a lot of trouble.</span></span></p>
<p class="calibre1"><span><span>The standard argument separator on the command line is the space, but you can alter the way your script will read the single word that you give as an argument using the IFS environment variable:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>IFS=","<br class="title-page-name"/>declare friends<br class="title-page-name"/>clear<br class="title-page-name"/>echo -n "Can you please tell me the name of some of your friends: "<br class="title-page-name"/>read -a friends<br class="title-page-name"/>echo "So, your friends are: "<br class="title-page-name"/>for i in ${!friends[*]}<br class="title-page-name"/>do <br class="title-page-name"/>echo "$i - ${friends[$i]}"<br class="title-page-name"/>done
</pre>
<p class="calibre1"><span><span>Now, let's execute it and give arguments as </span></span><span><span><kbd class="calibre9">Anthony Mike</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Can you please tell me the name of some of your friends: Anthony Mike<br class="title-page-name"/></strong><strong class="calibre2">So, your friends are: <br class="title-page-name"/></strong><strong class="calibre2">0 - Anthony Mike</strong>
</pre>
<p class="calibre1"><span><span>Both the names are at the same index, so they are not treated as two different friends. So, let's now use a comma to separate the names:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Can you please tell me the name of some of your friends: Noel,Tarek<br class="title-page-name"/></strong><strong class="calibre2">So, your friends are: <br class="title-page-name"/></strong><strong class="calibre2">0 - Noel<br class="title-page-name"/></strong><strong class="calibre2">1 – Tarek</strong>
</pre>
<p class="calibre1"><span><span>Here, <kbd class="calibre9">Noel</kbd> is at index 0 and <kbd class="calibre9">Tarek</kbd> is at index 1, so they are actually distinct names stored in different positions of the array. But what if the user does not answer to it in a timely manner? Well, another environment variable can help us with this:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>IFS=","<br class="title-page-name"/>TMOUT=3<br class="title-page-name"/>declare friends<br class="title-page-name"/>clear<br class="title-page-name"/>echo -n "Can you please tell me the name of some of your friends: "<br class="title-page-name"/>read -a friends<br class="title-page-name"/>if [ ${#friends[@]} -eq 0 ]<br class="title-page-name"/>then<br class="title-page-name"/>echo "You did not provide me with any names"<br class="title-page-name"/>exit 1<br class="title-page-name"/>else<br class="title-page-name"/>echo "So, your friends are: "<br class="title-page-name"/>for i in ${!friends[*]}<br class="title-page-name"/>do <br class="title-page-name"/>echo "$i - ${friends[$i]}"<br class="title-page-name"/>done<br class="title-page-name"/>fi<br class="title-page-name"/>exit 0
</pre>
<p class="calibre1"><span><span>We just assigned a value of three seconds to the <kbd class="calibre9">TMOUT</kbd> environment variable, which defines the standard timeout period for both the shell and the read built-in. Used in the interactive shell, it causes the shell itself to exit if no input comes to the terminal before the timeout expires. Used with the read built-in, it defines the timeout period after which the commands terminates if no input is given. In our case, when the timeout is hit, we check the number of elements stored into the array: if it is equal to 0, we print a warning message and exit with 1:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Can you please tell me the name of some of your friends: You did not provide me with any names</strong>
</pre>
<p class="calibre1"><span><span>In case we find something in the array, we cycle it and print all the values and associated indexes.</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Can you please tell me the name of some of your friends: Anthony,Mike,Tarek<br class="title-page-name"/></strong><strong class="calibre2">So, your friends are: <br class="title-page-name"/></strong><strong class="calibre2">0 - Anthony<br class="title-page-name"/></strong><strong class="calibre2">1 - Mike<br class="title-page-name"/></strong><strong class="calibre2">2 - Tarek</strong>
</pre>
<p class="calibre1"><span><span>Bash 4 introduced a new built-in mapfile, which is used to read lines from the standard input (the file descriptor if a <kbd class="calibre9">-u</kbd> option is provided) and load them into an indexed array. What can this be used for? Well, have a look at this--we start off creating a <kbd class="calibre9">file.txt</kbd> file with a list of our friends:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat friends.txt <br class="title-page-name"/></strong><strong class="calibre2">Anthony<br class="title-page-name"/></strong><strong class="calibre2">Dionysios<br class="title-page-name"/></strong><strong class="calibre2">Ilaria<br class="title-page-name"/></strong><strong class="calibre2">Mike<br class="title-page-name"/></strong><strong class="calibre2">Noel<br class="title-page-name"/></strong><strong class="calibre2">Tarek</strong>
</pre>
<p class="calibre1"><span><span>Now, let's create a script that takes advantage of the mapfile built-in:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -a friends<br class="title-page-name"/>echo -e<br class="title-page-name"/>echo -e "Reading friends list from friends.txt file..."<br class="title-page-name"/>mapfile friends &lt; friends.txt<br class="title-page-name"/>echo -e "File content loaded!"<br class="title-page-name"/>echo -e "So, your friends are: \n${friends[@]}"
</pre>
<p class="calibre1"><span><span>Finally, let's run the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./mapfile-array.sh <br class="title-page-name"/></strong><strong class="calibre2">Reading friends list from friends.txt file...<br class="title-page-name"/></strong><strong class="calibre2">File content loaded!<br class="title-page-name"/></strong><strong class="calibre2">So, your friends are: <br class="title-page-name"/></strong><strong class="calibre2">Anthony<br class="title-page-name"/></strong><strong class="calibre2">Dionysios<br class="title-page-name"/></strong><strong class="calibre2">Ilaria<br class="title-page-name"/></strong><strong class="calibre2">Mike<br class="title-page-name"/></strong><strong class="calibre2">Noel<br class="title-page-name"/></strong><strong class="calibre2">Tarek</strong>
</pre>
<p class="calibre1"><span><span>It's easy to see why <kbd class="calibre9">mapfile</kbd> is handy: we loaded all the lines from the file without using any loop or having to deal with each single line. In fact, using the built-in <kbd class="calibre9">read -a</kbd> would have loaded only the first line into the array, and we had to deal with the rest of the text file using some sort of loop. With <kbd class="calibre9">mapfile</kbd>, you just load everything and that is all.</span></span></p>
<p class="calibre1"><span><span>So, let's recap the different ways we have to store values in an array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">array_name[i]=value</strong>
</pre>
<p class="calibre1"><span><span>It is quite straightforward. Select the position in the array using an index and assign the value. I can be any integer out of an arithmetic expression. If it is negative then the <kbd class="calibre9">i</kbd> positions from the last value are available in the array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array[$((3*2))]=my_value ; echo ${my_array[6]}<br class="title-page-name"/></strong><strong class="calibre2">my_value</strong>
</pre>
<p class="calibre1"><span><span>We can also omit the index, in this case, the value will be assigned to the index 0 slot:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">my_array=my_other_value ; for i in {0..6} ; do echo $i ${my_array[$i]} ; done<br class="title-page-name"/></strong><strong class="calibre2">0 my_other_value<br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">4<br class="title-page-name"/></strong><strong class="calibre2">5<br class="title-page-name"/></strong><strong class="calibre2">6 my_value</strong>
</pre>
<p class="calibre1"><span><span>This is true for the associative array as well:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_associative=my_value ; for i in {0..5} ; do echo $i ${my_associative[$i]} ; done<br class="title-page-name"/></strong><strong class="calibre2">0 my_value<br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">4<br class="title-page-name"/></strong><strong class="calibre2">5</strong>
</pre>
<p class="calibre1"><span><span>In this case, <kbd class="calibre9">0</kbd> is actually a string used as a string, as it should be for an associative array.</span></span></p>
<p class="calibre1"><span><span>Another method to store data in an array is the compound assignment of values, as we saw before, but it works for indexed arrays only:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ friends=(Anthony Mike Noel Tarek Dionysios) ; echo ${friends[0]} ; echo ${friends[4]} ; echo ${friends[5]} ; friends[5]=Claudia ; echo ${friends[5]}<br class="title-page-name"/></strong><strong class="calibre2">Anthony<br class="title-page-name"/></strong><strong class="calibre2">Dionysios</strong>
</pre>
<p class="calibre1"><span><span>With this method, we have to be careful since the array is unset before the assignment, so all the previous values get lost:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~/$ friends=(Anthony Mike Noel Tarek Dionysios) ; echo -n "Old array values: ${friends[@]}" ; friends=(Ilaria) ; echo -e ; echo -n "New array values: ${friends[@]}" ; echo -e<br class="title-page-name"/></strong><strong class="calibre2">Old array values: Anthony Mike Noel Tarek Dionysios<br class="title-page-name"/></strong><strong class="calibre2">New array values: Ilaria</strong>
</pre>
<p class="calibre1"><span><span>We can preserve the old content of the array using the <kbd class="calibre9">+=</kbd> operator:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ friends=(Anthony Mike Noel Tarek Dionysios) ; echo -n "Old array values:${friends[@]}" ; friends+=(Ilaria) ; echo -e ; echo -n "New array values: ${friends[@]}" ; echo -e<br class="title-page-name"/></strong><strong class="calibre2">Old array values:Anthony Mike Noel Tarek Dionysios<br class="title-page-name"/></strong><strong class="calibre2">New array values: echo Anthony Mike Noel Tarek Dionysios Ilaria</strong>
</pre>
<p class="calibre1"><span><span>Then, we have a compound assignment using keys:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=([2]=first_value [4]=second_value) ; for i in {0..5} ; do echo $i ${my_array[$i]} ; done<br class="title-page-name"/></strong><strong class="calibre2">0<br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2 first_value<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">4 second_value<br class="title-page-name"/></strong><strong class="calibre2">5</strong>
</pre>
<p class="calibre1"><span><span>This holds true for associative arrays as well:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -A friends<br class="title-page-name"/>friends=([Mike]="is a friend" [Anthony]="is another friend")<br class="title-page-name"/>for i in Mike Anthony<br class="title-page-name"/>do <br class="title-page-name"/>echo "$i - ${friends[$i]}"<br class="title-page-name"/>done<br class="title-page-name"/>And now let's try it:<br class="title-page-name"/>zarrelli:~$ ./associative.sh <br class="title-page-name"/>Mike - is a friend<br class="title-page-name"/>Anthony - is another friend
</pre>
<p class="calibre1"><span><span>Notice that an associative array does not imply a specific order in keys; as you can see from the previous example, they are unsorted.</span></span></p>
<p class="calibre1"><span><span>Finally, we see the mapfile method:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ mapfile &lt; friends.txt ; echo ${MAPFILE[@]}<br class="title-page-name"/></strong><strong class="calibre2">Anthony Dionisios Ilaria Mike Noel Tarek</strong>
</pre>
<p class="calibre1"><span><span>We used a slightly more compact form of the <kbd class="calibre9">mapfile</kbd> command, since we did not specify the name of the array to read the file content into. In this case, when no array is provided, <kbd class="calibre9">mapfile</kbd> stores the data into the default <kbd class="calibre9">MAPFILE</kbd> array.</span></span></p>
<p class="calibre1"><span><span>Now that we have seen the different methods for storing values, it's time to retrieve them in various ways:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">${my_array[i]} </strong>
</pre>
<p class="calibre1"><span><span>I can be any integer out of an arithmetic expression. If it is negative, then the <kbd class="calibre9">i</kbd> positions from the last value are available in the array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=("first value" "second value" "third value" "fourth value" "fifth value") ; echo "${my_array[-3]}"<br class="title-page-name"/></strong><strong class="calibre2">third value</strong>
</pre>
<p class="calibre1"><span><span>We can notice a couple of interesting things here.</span></span></p>
<p class="calibre1"><span><span>The <kbd class="calibre9">-2</kbd> index points to the last position in the array, which is filled in by <kbd class="calibre9">"fifth value"</kbd> minus the two slots, so we count backwards until we reach the 5-2 slot. The third position in the array index 2 (the index count starts from 0) and holds the string <kbd class="calibre9">"third value"</kbd>.</span></span></p>
<p class="calibre1"><span><span>Second, we used strings with spaces, thanks to the double quotes that preserved them. As a precaution while echoing, we quoted the retrieved value as well.</span></span></p>
<p class="calibre1"><span><span>In a similar way, we can retrieve the value of an element into an associative array using the form called  </span></span><span><span><kbd class="calibre9">$my_associative[string]</kbd>.</span></span></p>
<p class="calibre1"><span><span>Where the string is one of the keys stored into the array related to the values, we want to retrieve this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">my_associative=([George]=first_value [Anthony]=second_value) ; echo ${my_associative[Anthony]}<br class="title-page-name"/></strong><strong class="calibre2">second_value</strong>
</pre>
<p class="calibre1"><span><span>We can also retrieve all the stored values at once using this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">${my_array[@]}<br class="title-page-name"/></strong><strong class="calibre2">${my_array[*]}<br class="title-page-name"/></strong><strong class="calibre2">${my_associative[@]}<br class="title-page-name"/></strong><strong class="calibre2">${my_associative[*]}</strong>
</pre>
<p class="calibre1"><span><span>As we can see from the following examples:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo ${my_array[@]}<br class="title-page-name"/></strong><strong class="calibre2">first value second value third value fourth value fifth value<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ echo ${my_array[*]}<br class="title-page-name"/></strong><strong class="calibre2">first value second value third value fourth value fifth value<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ echo ${my_associative[@]}<br class="title-page-name"/></strong><strong class="calibre2">my_value second_value first_value<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ echo ${my_associative[*]}<br class="title-page-name"/></strong><strong class="calibre2">my_value second_value first_value</strong>
</pre>
<p class="calibre1"><span><span>But if you do not want all the values, we can get them in <em class="calibre20">slices</em> using the following syntax:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">${my_array[@]:S:O}<br class="title-page-name"/></strong><strong class="calibre2">${my_array[*]:S:O}</strong>
</pre>
<p class="calibre1"><span><span>With <kbd class="calibre9">S</kbd> being the index value we are starting from and <kbd class="calibre9">O</kbd> the offset for reading the values:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=("first value" "second value" "third value" "fourth value" "fifth value") ; echo "${my_array[@]:3:2}"<br class="title-page-name"/></strong><strong class="calibre2">fourth value fifth value<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ my_array=("first value" "second value" "third value" "fourth value" "fifth value") ; echo "${my_array[*]:3:2}"<br class="title-page-name"/></strong><strong class="calibre2">fourth value fifth value</strong>
</pre>
<p class="calibre1"><span><span>In both the examples, we started reading from the index position 3 and actually read the two following values. If we omit one of the values, the remaining will be taken in account as an offset from position 0:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=("first value" "second value" "third value" "fourth value" "fifth value") ; echo "${my_array[*]:2}"<br class="title-page-name"/></strong><strong class="calibre2">third value fourth value fifth value</strong>
</pre>
<p class="calibre1"><span><span>We can also play with the substring removal operators that we saw earlier in this book:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=("first value" "second value" "third value" "fourth value" "fifth value") ; echo "${my_array[@]%%fou*}"<br class="title-page-name"/></strong><strong class="calibre2">first value second value third value fifth value</strong><strong class="calibre2"> </strong>
</pre>
<p class="calibre1"><span><span>Or:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=("first value" "second value" "third value" "fourth value" "fifth value") ; echo "${my_array[@]#s?cond}"<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">first value value third value fourth value fifth value</strong>
</pre>
<p class="calibre1"><span><span>Or:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=("first value" "second value" "third value" "fourth value" "fifth value") ; echo "${my_array[@]/third/forth-1}"<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">first value second value forth-1 value fourth value fifth value</strong>
</pre>
<p class="calibre1"><span><span>And so forth.</span></span></p>
<p class="calibre1"><span>Notice that <kbd class="calibre9">${array_name[@]}</kbd> and <kbd class="calibre9">${array_name[*]}</kbd> follow the same rules as <kbd class="calibre9">$@</kbd> and <kbd class="calibre9">$*</kbd> when it comes to the parameters expansion with the first notation seeing the parameters all as a single string and the latter as single words quoted.</span></p>
<p class="calibre1"><span><span>Now that we know how to store and retrieve data from an array, we have to see how to delete them. We can use the following commands:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre9"><span><span>unset array_name</span></span></kbd></li>
<li class="calibre13"><kbd class="calibre9"><span><span>unset array_name[@]</span></span></kbd></li>
<li class="calibre13"><kbd class="calibre9"><span><span>unset array_name[*]</span></span></kbd></li>
</ul>
<p class="calibre1"><span><span>Have a look at the following examples:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=(one two three four five) ; echo "The content of the array is: ${my_array[@]}" ; unset my_array ; echo "Now the content of the array is: ${my_array[@]}"<br class="title-page-name"/></strong><strong class="calibre2">The content of the array is: one two three four five<br class="title-page-name"/></strong><strong class="calibre2">Now the content of the array is: <br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ my_array=(one two three four five) ; echo "The content of the array is: ${my_array[@]}" ; unset my_array[@] ; echo "Now the content of the array is: ${my_array[@]}"<br class="title-page-name"/></strong><strong class="calibre2">The content of the array is: one two three four five<br class="title-page-name"/></strong><strong class="calibre2">Now the content of the array is: <br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ my_array=(one two three four five) ; echo "The content of the array is: ${my_array[@]}" ; unset my_array[*] ; echo "Now the content of the array is: ${my_array[@]}"<br class="title-page-name"/></strong><strong class="calibre2">The content of the array is: one two three four five<br class="title-page-name"/></strong><strong class="calibre2">Now the content of the array is: </strong>
</pre>
<p class="calibre1"><span><span>We can unset a single value at a defined index position:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=(one two three four five) ; echo "The content of the array is: ${my_array[@]}" ; unset my_array[2] ; echo "Now the content of the array is: ${my_array[@]}"<br class="title-page-name"/></strong><strong class="calibre2">The content of the array is: one two three four five<br class="title-page-name"/></strong><strong class="calibre2">Now the content of the array is: one two four five</strong>
</pre>
<p class="calibre1"><span><span>This holds true for the associative arrays as well:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -A friends<br class="title-page-name"/>friends=([Mike]="is a friend" [Anthony]="is another friend")<br class="title-page-name"/>unset friends[Mike]<br class="title-page-name"/>for i in Mike Anthony<br class="title-page-name"/>do <br class="title-page-name"/>echo "$i - ${friends[$i]}"<br class="title-page-name"/>done
</pre>
<p class="calibre1"><span><span>As you can see from the following output:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./associative-remove.sh <br class="title-page-name"/></strong><strong class="calibre2">Mike - <br class="title-page-name"/></strong><strong class="calibre2">Anthony - is another friend</strong>
</pre>
<p class="calibre1"><span><span>You can also assign nothing both to the array and the single values, either for the indexed or associative arrays:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=(one two three four five) ; echo "The content of the array is: ${my_array[@]}" ; my_array[2]="" ; echo "Now the content of the array is: ${my_array[@]}"<br class="title-page-name"/></strong><strong class="calibre2">The content of the array is: one two three four five<br class="title-page-name"/></strong><strong class="calibre2">Now the content of the array is: one two four five</strong>
</pre>
<p class="calibre1"><span><span>Or:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=(one two three four five) ; echo "The content of the array is: ${my_array[@]}" ; my_array=() ; echo "Now the content of the array is: ${my_array[@]}"<br class="title-page-name"/></strong><strong class="calibre2">The content of the array is: one two three four five<br class="title-page-name"/></strong><strong class="calibre2">Now the content of the array is: </strong>
</pre>
<p class="calibre1"><span><span>For the associative array, just change this line in the previous script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">friends=([Mike]="is a friend" [Anthony]="is another friend")<br class="title-page-name"/></strong><strong class="calibre2">friends[Mike]=""<br class="title-page-name"/></strong><strong class="calibre2">for i in Mike Anthony</strong>
</pre>
<p class="calibre1"><span><span>Now, run it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./associative-remove.sh <br class="title-page-name"/></strong><strong class="calibre2">Mike - <br class="title-page-name"/></strong><strong class="calibre2">Anthony - is another friend</strong>
</pre>
<p class="calibre1"><span><span>Otherwise again, change these lines:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">friends=([Mike]="is a friend" [Anthony]="is another friend")<br class="title-page-name"/></strong><strong class="calibre2">friends=()<br class="title-page-name"/></strong><strong class="calibre2">for i in Mike Anthony</strong>
</pre>
<p class="calibre1"><span><span>Now, run the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./associative-remove.sh <br class="title-page-name"/></strong><strong class="calibre2">Mike - <br class="title-page-name"/></strong><strong class="calibre2">Anthony - </strong>
</pre>
<p class="calibre1"><span><span>Some final notes are due for some interesting notations that we can use to deal with arrays:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">${#array_name[index]}</strong>
</pre>
<p class="calibre1">The following code explains the length of the array value pointed out at the index:</p>
<pre class="codepackt">
<strong class="calibre2">my_array=(one two three four five) ; echo "The length of ${my_array[4]} is of ${#my_array[4]} characters" <br class="title-page-name"/></strong><strong class="calibre2">The length of five is of 4 characters</strong>
</pre>
<p class="calibre1"><span><span>Or:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -A friends<br class="title-page-name"/>friends=([Mike]="is a friend" [Anthony]="is another friend")<br class="title-page-name"/>echo "The lenght of \"${friends[Anthony]}"\ is ${#friends[Anthony]}"<br class="title-page-name"/>And executing it gives us:<br class="title-page-name"/>zarrelli:~$ ./associative-count.sh <br class="title-page-name"/>The lenght of "is another friend" is 17
</pre>
<p class="calibre1"><span><span>Another interesting expansion that we can have on arrays is represented by:</span></span></p>
<p class="calibre1"><span><span>#{#array_name[*]} </span></span><span><span>or </span></span><span><span>#{#array_name[@]}</span></span></p>
<p class="calibre1"><span><span>This can expand to the number of elements in the array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ my_array=(one two three four five) ; echo "We have ${#my_array[*]} elements in the array" <br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">We have 5 elements in the array</strong>
</pre>
<p class="calibre1"><span><span>Or:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -A friends<br class="title-page-name"/>friends=([Mike]="is a friend" [Anthony]="is another friend")<br class="title-page-name"/>echo "We have ${#friends[@]} elements in the array"
</pre>
<p class="calibre1"><span><span>This gives us the following:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./associative-elements.sh <br class="title-page-name"/></strong><strong class="calibre2">We have 2 elements in the array</strong>
</pre>
<p class="calibre1"><span><span>We have all the elements now to see how we can loop through the content of an array. We can start with something easy that we have already seen:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -a my_array<br class="title-page-name"/>my_array=("one" "two" "three" "four" "five")<br class="title-page-name"/>for (( i=0 ; i&lt;${#my_array[*]} ; i++ ));<br class="title-page-name"/>do <br class="title-page-name"/>echo "${my_array[i]}" <br class="title-page-name"/>done
</pre>
<p class="calibre1"><span><span>Now, let's execute it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./loop1.sh <br class="title-page-name"/></strong><strong class="calibre2">one<br class="title-page-name"/></strong><strong class="calibre2">two<br class="title-page-name"/></strong><strong class="calibre2">three<br class="title-page-name"/></strong><strong class="calibre2">four<br class="title-page-name"/></strong><strong class="calibre2">five</strong>
</pre>
<p class="calibre1"><span><span>This is a simple method with some restrictions: the index starts from 0 and the progression is expected to be sequential. But we can do something to overcome these limitations:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -a my_array<br class="title-page-name"/>my_array=("one" "two" "three" "four" "five")<br class="title-page-name"/>for i in ${my_array[*]} ; <br class="title-page-name"/>do <br class="title-page-name"/>echo "$i" <br class="title-page-name"/>done
</pre>
<p class="calibre1"><span><span>We modified the <kbd class="calibre9">for</kbd> statement and now <kbd class="calibre9">i</kbd> will be instanced with each of the elements that we got from the <kbd class="calibre9">$(my_array[*]}</kbd> expansion:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./loop2.sh <br class="title-page-name"/></strong><strong class="calibre2">one<br class="title-page-name"/></strong><strong class="calibre2">two<br class="title-page-name"/></strong><strong class="calibre2">three<br class="title-page-name"/></strong><strong class="calibre2">four<br class="title-page-name"/></strong><strong class="calibre2">five</strong>
</pre>
<p class="calibre1"><span><span>So far, so good. We have access to the values, but what about the indexes? Just bear in mind that </span></span><span><span><kbd class="calibre9">${!array_name[@]}</kbd> </span></span><span><span>and </span></span><span><span><kbd class="calibre9">${!array_name[*]}</kbd> </span></span><span><span>expand to the list of indexes of the array. Just notice that using <kbd class="calibre9">@</kbd> in quotes expands each key into a single word. So, knowing this, we can retrieve both the values and the indexes:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -A friends<br class="title-page-name"/>friends=([Mike]="is a friend" [Anthony]="is another friend")<br class="title-page-name"/>for i in ${!friends[*]}<br class="title-page-name"/>do <br class="title-page-name"/>echo "$i - ${friends[$i]}"<br class="title-page-name"/>done
</pre>
<p class="calibre1"><span><span>This will give us the following:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./loop3.sh <br class="title-page-name"/></strong><strong class="calibre2">Mike - is a friend<br class="title-page-name"/></strong><strong class="calibre2">Anthony - is another friend</strong>
</pre>
<p class="calibre1"><span><span>Finally, something a bit more complex:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>declare -A friends<br class="title-page-name"/>friends=([Mike]="is a friend" [Anthony]="is another friend")<br class="title-page-name"/>indexes=(${!friends[*]})<br class="title-page-name"/>for ((i=0 ; i&lt;${#friends[*]} ; i++));<br class="title-page-name"/>do <br class="title-page-name"/>echo "${indexes[i]} - ${friends[${indexes[i]}]}"<br class="title-page-name"/>done
</pre>
<p class="calibre1"><span><span>We stored all the indexes of the friends array in another array called <kbd class="calibre9">indexes</kbd>, and then we used this latter to retrieve the content from the former one:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./loop4.sh <br class="title-page-name"/></strong><strong class="calibre2">Mike - is a friend<br class="title-page-name"/></strong><strong class="calibre2">Anthony - is another friend</strong>
</pre>
<p class="calibre1"><span><span>We will see more on iterations shortly, but what we will focus on next is how to make our code clean, tidy, and reusable by taking advantage of another construct that Bash provides us with: the functions.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Functions</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>At this point of the book, we know enough to write our own code, process variables, interact with the user, and the environment, many things altogether, and so we are ready to make a mess. We know how to write a bunch of lines, but we still do not know how to keep things clean and tidy and, moreover, how to make our code reusable. As we can easily guess from the examples seen so far, a script or a command line is a one way processed flow of code; the characters making up our commands are read from left to right, from top to bottom. So, when you pass a construct or an assignment, it is done and if you want to process something the same way you did before; you have to rewrite the code that carried on the procedure again. So, if you are coding more than a small script you risk to end up with a huge amount of repetitive code, sloppy layout; and inefficiency; but Bash, like any other programming language, provides us with a method to overcome these issues. We are talking of functions. What are functions? An example will clarify what a function is better than many words. Let's create a small fragment of code:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>if (("$1" &lt; "$2"))<br class="title-page-name"/>then<br class="title-page-name"/>echo "Great! The integer $1 is less than $2"<br class="title-page-name"/>else<br class="title-page-name"/>echo "The integer $1 is not less than $2..."<br class="title-page-name"/>fi
</pre>
<p class="calibre1"><span><span>It takes two positional arguments as input to check if the first argument is less than the second assuming that the input is an integer:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./minor-no-function.sh 1 2<br class="title-page-name"/></strong><strong class="calibre2">Great! The integer 1 is less than 2<br class="title-page-name"/></strong><strong class="calibre2">Now, let's move part of the code into a function:<br class="title-page-name"/></strong><strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">minor()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">if (("$1" &lt; "$2"))<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "Great! The integer $1 is less than $2"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "The integer $1 is not less than $2..."<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/></strong><strong class="calibre2">minor "$1" "$2"</strong>
</pre>
<p class="calibre1"><span><span>Time to try our brand new function:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./test.sh 1 2<br class="title-page-name"/></strong><strong class="calibre2">Great! The integer 1 is less than 2<br class="title-page-name"/></strong><strong class="calibre2">What did we do? First, we see that a function declaration has the following structure:<br class="title-page-name"/></strong><strong class="calibre2">function_name()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">instruction_1<br class="title-page-name"/></strong><strong class="calibre2">…<br class="title-page-name"/></strong><strong class="calibre2">instruction_n<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>But it can also have the following structure:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">function _name() {<br class="title-page-name"/></strong><strong class="calibre2">instruction_1<br class="title-page-name"/></strong><strong class="calibre2">…<br class="title-page-name"/></strong><strong class="calibre2">instruction_n<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>It can even have a declared notation using the <kbd class="calibre9">function</kbd> keyword as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">function function_name {<br class="title-page-name"/></strong><strong class="calibre2">instruction_1<br class="title-page-name"/></strong><strong class="calibre2">…<br class="title-page-name"/></strong><strong class="calibre2">instruction_n<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>We can also have a one-line definition:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ print_me() { echo "This is your input:"; echo "$1"; } ; print_me 1<br class="title-page-name"/></strong><strong class="calibre2">This is your input:<br class="title-page-name"/></strong><strong class="calibre2">1</strong>
</pre>
<p class="calibre1"><span>Notice the <kbd class="calibre9">;</kbd> after the last command. We also saw in <a target="_blank" href="part0075.html#27GQ60-8ae483f626fa439a8b6ee1bf9fb955ec" class="calibre4">Chapter 4</a><em class="calibre20">, </em></span><span><em class="calibre20">Quoting and Escaping</em>, </span><span>the use of anonymous functions.</span></p>
<p class="calibre1"><span><span>Whatever kind of declaration you want to use, a function is triggered simply by calling its name and accepting positional parameters such as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">function_name arg1 argn</strong>
</pre>
<p class="calibre1"><span><span>As we saw in the previous chapter, a function can return a value, because bear in mind that the values processed inside a function are available only after the function itself has been triggered:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>minor()<br class="title-page-name"/>{<br class="title-page-name"/>if (("$1" &lt; "$2"))<br class="title-page-name"/>then<br class="title-page-name"/>echo "Great! The integer $1 is less than $2"<br class="title-page-name"/>echo "Assigning \$1 to the variable \"var\"" <br class="title-page-name"/>var="$1"<br class="title-page-name"/>echo "The value of var inside the function is: $var"<br class="title-page-name"/>else<br class="title-page-name"/>echo "The integer $1 is not less than $2..."<br class="title-page-name"/>fi<br class="title-page-name"/>}<br class="title-page-name"/>echo "The value of var outside the function before it is triggered is: $var"<br class="title-page-name"/>minor "$1" "$2"<br class="title-page-name"/>echo "The value of var outside the function after it is triggered is: $var"
</pre>
<p class="calibre1"><span><span>In this example, we assigned the value of the first positional variable to the variable named <kbd class="calibre9">var</kbd>, and then printed this value from inside and outside the function, before it gets triggered and finally after it is triggered:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./minor-function.sh 1 2<br class="title-page-name"/></strong><strong class="calibre2">The value of var outside the function before it is triggered is: <br class="title-page-name"/></strong><strong class="calibre2">Great! The integer 1 is less than 2<br class="title-page-name"/></strong><strong class="calibre2">Assigning S1 to the variable "var"<br class="title-page-name"/></strong><strong class="calibre2">The value of var inside the function is: 1<br class="title-page-name"/></strong><strong class="calibre2">The value of var outside the function after it is triggered is: 1</strong>
</pre>
<p class="calibre1"><span><span>We notice a couple of interesting things.</span></span></p>
<p class="calibre1"><span><span>If we try to print the value of <kbd class="calibre9">var</kbd> before the function is triggered, we do not get anything. This is because even though the code for the function is read before the command, the echo itself </span></span><span><span><kbd class="calibre9">echo "The value of var outside the function before it is triggered is: $var"</kbd> </span></span><span><span>is executed before the function is triggered and has the chance to work on variables and assign a value to <kbd class="calibre9">var</kbd>.</span></span></p>
<p class="calibre1"><span><span>Second, just because </span></span><span><kbd class="calibre9">echo "The value of var outside the function before it is triggered is: $var"</kbd> </span><span><span>is executed before the function itself, it actually is the first message printed on the terminal.</span></span></p>
<p class="calibre1"><span><span>The content assigned or created inside a function is available outside of it, because the function runs in the same shell context of the script, so they share the same environment and variables. But what if I wish to create variables that are available only inside the function itself? Let's alter the assignment instruction by adding the local built-in before the variable:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">local var= "$1"</strong>
</pre>
<p class="calibre1"><span><span>We run the script once again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./minor-function.sh 1 2<br class="title-page-name"/></strong><strong class="calibre2">The value of var outside the function before it is triggered is: <br class="title-page-name"/></strong><strong class="calibre2">Great! The integer 1 is less than 2<br class="title-page-name"/></strong><strong class="calibre2">Assigning S1 to the variable "var"<br class="title-page-name"/></strong><strong class="calibre2">The value of var inside the function is: 1<br class="title-page-name"/></strong><strong class="calibre2">The value of var outside the function after it is triggered is: </strong>
</pre>
<p class="calibre1"><span><span>We can hide variables from the main body of the script, but we can also get the function to return us something:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>OK=10<br class="title-page-name"/>NOT_OK=50<br class="title-page-name"/>minor()<br class="title-page-name"/>{<br class="title-page-name"/>if (("$1" &lt; "$2"))<br class="title-page-name"/>then<br class="title-page-name"/>echo "Returning the value of OK"<br class="title-page-name"/>return "$OK"<br class="title-page-name"/>else<br class="title-page-name"/>echo "Returning the value of NOT_OK"<br class="title-page-name"/>return "$NOT_OK"<br class="title-page-name"/>fi<br class="title-page-name"/>}<br class="title-page-name"/>print_return()<br class="title-page-name"/>{<br class="title-page-name"/>if (("$3" == "$OK")) ; then<br class="title-page-name"/>echo "Great! The integer $1 is less than $2"<br class="title-page-name"/>exit 0<br class="title-page-name"/>elif (("$3" == "$NOT_OK")) ; then<br class="title-page-name"/>echo "The integer $1 is not less than $2..."<br class="title-page-name"/>exit 1<br class="title-page-name"/>else<br class="title-page-name"/>echo "Something gone wild..."<br class="title-page-name"/>echo "The first integer has the value of $1 and the second of $2..."<br class="title-page-name"/>exit 1<br class="title-page-name"/>fi <br class="title-page-name"/>}<br class="title-page-name"/>minor "$1" "$2"<br class="title-page-name"/>print_return "$1" "$2" "$?"
</pre>
<p class="calibre1"><span><span>In this example, we had a bit of fun creating a new function to print the actual messages shown to the user, and we can see on initial benefit of using functions: the code evaluating, if an integer is minor then another is now clean, holds less rows, and it is more readable. On the other hand, the print return takes as input the first two positional variables and takes the third as the return code (<kbd class="calibre9">$?</kbd>) of the minor function. Another benefit of introducing a function focused on printing messages to the user is that we introduced something else with it, a separation between the presentation layer, the <kbd class="calibre9">print_return</kbd> function, the elaboration layer, and the <kbd class="calibre9">minor</kbd> function. So, each time we want to modify how the information is shown to the user, we do not have to tinker with the core function, so we do not risk introducing any error in its code. On the other hand, if we want to work on the core function, we can make any modifications, and we do not have to modify the presentation layer as long as the output from the core remains the same.</span></span></p>
<p class="calibre1"><span>If you have some functions that you think you can use in many of your scripts, it would be a good idea to write all of them in file, and then source the file from within your script and use them from there. This way you will have your own library of functions that you will reuse over time when needed without the burden of having to write them every single time.</span></p>
<p class="calibre1"><span><span>But can we pass to a function variable that references other variables? Let's try this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:$ cat inference.sh <br class="title-page-name"/></strong><strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">FIRST_VALUE=SECOND_VALUE<br class="title-page-name"/></strong><strong class="calibre2">SECOND_VALUE=20<br class="title-page-name"/></strong><strong class="calibre2">print_value()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">echo "The value of \$1 is: $1"<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/></strong><strong class="calibre2">print_value "${FIRST_VALUE}"<br class="title-page-name"/></strong><strong class="calibre2">exit 0</strong>
</pre>
<p class="calibre1"><span><span>So, <kbd class="calibre9">FIRST_VALUE</kbd> references <kbd class="calibre9">SECOND_VALUE</kbd>, which has a value of <kbd class="calibre9">20</kbd>, so we would expect to see <kbd class="calibre9">20</kbd> when we try to print <kbd class="calibre9">$FIRST_VALUE</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./inference.sh <br class="title-page-name"/></strong><strong class="calibre2">The value of $1 is: SECOND_VALUE</strong>
</pre>
<p class="calibre1"><span><span>It is not what we were expecting, was it? This happens because Bash treats the variable name <kbd class="calibre9">SECOND_VALUE</kbd> as a bunch of characters. A mere is a string taken in its literal value and not as a pointer to a value called <kbd class="calibre9">(20)</kbd>. We can overcome this issue anyway; let's just add <kbd class="calibre9">print_value "${!FIRST_VALUE}"</kbd> to the previous script before</span></span> <kbd class="calibre9">exit 0</kbd> , a<span><span>nd now we run it again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./inference.sh <br class="title-page-name"/></strong><strong class="calibre2">The value of $1 is: SECOND_VALUE<br class="title-page-name"/></strong><strong class="calibre2">The value of $1 is: 20</strong>
</pre>
<p class="calibre1"><span><span>We used what is called indirect referencing to actually reference the value of a value. This kind of notation called <kbd class="calibre9">$</kbd></span></span><span><span><kbd class="calibre9">{!variable_name}</kbd> </span></span><span><span>introduced in Bash 2 makes indirect referencing not so difficult to write down, but sometimes, you will find the old version:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ a=b ; b=c ; echo $a ; eval a=\$$a ; echo $a<br class="title-page-name"/></strong><strong class="calibre2">b<br class="title-page-name"/></strong><strong class="calibre2">c</strong>
</pre>
<p class="calibre1"><span><span>What we see as <kbd class="calibre9">$$a</kbd> is actually the value of the value, and then we escape it and with <kbd class="calibre9">eval</kbd> , we force its evaluation and assignment it to <kbd class="calibre9">a</kbd>.</span></span></p>
<p class="calibre1"><span><span>How about dereferencing a variable after it has been passed to a function? Here are some lines of code to play with:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>a10=20<br class="title-page-name"/>print_value()<br class="title-page-name"/>{<br class="title-page-name"/>echo -e<br class="title-page-name"/>echo -e "The name of the variable passed as \$1 to the function is: $1\n"<br class="title-page-name"/>b20=\$"$1"<br class="title-page-name"/>echo -e "b20 holds the reference to the content of the variable passed on the command line: $b20\n"<br class="title-page-name"/>c30=${b20//[[:punct:]][[:alpha:]]}<br class="title-page-name"/>echo -e "But playing with parameter substitution we got an untyped value out of it: $c30\n"<br class="title-page-name"/>eval d40=\$$1<br class="title-page-name"/>e50=$(($d40+$c30))<br class="title-page-name"/>echo "And we used it as in integer to add to the original value we received"<br class="title-page-name"/>echo -e "as input so the integer extracted from the name of the variable added to the variable value is: $e50\n" <br class="title-page-name"/>eval $1=$e50<br class="title-page-name"/>echo -e "Thanks to eval we assign the new value to the original input\n" <br class="title-page-name"/>echo -e "The value of \$1 now is: $e50\n"<br class="title-page-name"/>}<br class="title-page-name"/>echo -e<br class="title-page-name"/>echo "The value of a10 before triggering the function is: $a10"<br class="title-page-name"/>print_value a10<br class="title-page-name"/>echo -e "The value of a10 after triggering the function is: $a10\n"<br class="title-page-name"/>exit 0
</pre>
<p class="calibre1"><span><span>So we started with a variable called <kbd class="calibre9">a10</kbd> holding the value of <kbd class="calibre9">10</kbd>. Then, we printed its value before triggering the function, and right afterwards, we called the function passing the name of the variable. The first step in the <kbd class="calibre9">print_value</kbd> function prints the value of the first positional argument passed to the function itself. Now, you have all the knowledge to read the code and get what has been done. We played a bit with indirect reference, deference, and a parameter substitution, so the simple output of the script should make it all clear:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./dereference.sh <br class="title-page-name"/></strong><strong class="calibre2">The value of a10 before triggering the function is: 20<br class="title-page-name"/></strong><strong class="calibre2">The name of the variable passed as $1 to the function is: a10<br class="title-page-name"/></strong><strong class="calibre2">b20 holds the reference to the content of the variable passed on the command line: $a10<br class="title-page-name"/></strong><strong class="calibre2">But playing with parameter substitution we got an untyped value out of it: 10<br class="title-page-name"/></strong><strong class="calibre2">And we used it as in integer to add to the original value we received as input so the integer extracted from the name of the variable added to the variable value is: 30<br class="title-page-name"/></strong><strong class="calibre2">Thanks to eval we assign the new value to the original input<br class="title-page-name"/></strong><strong class="calibre2">The value of $1 now is: 30<br class="title-page-name"/></strong><strong class="calibre2">The value of a10 after triggering the function is: 30</strong>
</pre>
<p class="calibre1"><span><span>And here we are: the value of <kbd class="calibre9">a10</kbd> changed from the original <kbd class="calibre9">20</kbd> to the new <kbd class="calibre9">30</kbd>, and now we know why and how. Before leaving the functions chapter, just a couple of notes: we already talked about anonymous functions:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=10 ; y=5 ; { z=$(($x*$y)) ; echo "Value of z inside the function: $z" ; } ; echo "Value of z outside the function: $z"<br class="title-page-name"/></strong><strong class="calibre2">Value of z inside the function: 50<br class="title-page-name"/></strong><strong class="calibre2">Value of z outside the function: 50</strong>
</pre>
<p class="calibre1"><span><span>Just remember the last semicolon before the ending brace a</span></span><span><span>nd also see the returned values:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat minor-function-return-message.sh <br class="title-page-name"/></strong><strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">OK=10<br class="title-page-name"/></strong><strong class="calibre2">NOT_OK=50<br class="title-page-name"/></strong><strong class="calibre2">minor()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">if (("$1" &lt; "$2"))<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "Returning the value of OK"<br class="title-page-name"/></strong><strong class="calibre2">return "$OK"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "Returning the value of NOT_OK"<br class="title-page-name"/></strong><strong class="calibre2">return "$NOT_OK"<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/></strong><strong class="calibre2">message=$(minor "$1" "$2")<br class="title-page-name"/></strong><strong class="calibre2">echo "$message"</strong>
</pre>
<p class="calibre1"><span><span>Once invoked, the script outputs a meaningful error message overcoming the limitations of the return built-in, which can only return integers:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli@moveaway:~/Documents/My books/Mastering bash/Chapter 5/Scripts$ ./minor-function-return-message.sh 1 2</strong>
</pre>
<p class="calibre1"><span><span>The previous code returns the value of <kbd class="calibre9">OK</kbd>, and b</span></span><span><span>eing a block of code, a function <kbd class="calibre9">stdin</kbd> and <kbd class="calibre9">stdout</kbd> can be redirected easily:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat redirect.sh <br class="title-page-name"/></strong><strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">file=friends.txt<br class="title-page-name"/></strong><strong class="calibre2">parse()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">while read lineofile<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">echo $lineofile<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">}&lt;$file<br class="title-page-name"/></strong><strong class="calibre2">parse</strong>
</pre>
<p class="calibre1"><span><span>This gives us the following:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./redirect.sh <br class="title-page-name"/></strong><strong class="calibre2">Anthony<br class="title-page-name"/></strong><strong class="calibre2">Dionisios<br class="title-page-name"/></strong><strong class="calibre2">Ilaria<br class="title-page-name"/></strong><strong class="calibre2">Mike<br class="title-page-name"/></strong><strong class="calibre2">Noel<br class="title-page-name"/></strong><strong class="calibre2">Tarek</strong>
</pre>
<p class="calibre1"><span><span>And that's all for now, it's time to move on and add some spice to our scripts.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>You learned how to interact with users, read their input, and store it in appropriate structures, cycle though values, and take advantage of the functions to make our code tidy and reusable. So now it is time to explore some structures that we have already used a bit: we are talking about iterations.</span></span></p>
<p class="calibre1"> </p>


            </article>

            
        </section>
    </body></html>