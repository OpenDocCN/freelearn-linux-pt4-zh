<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;The BSP Layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. The BSP Layer</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a custom BSP layer</li><li class="listitem" style="list-style-type: disc">Introducing system development workflows</li><li class="listitem" style="list-style-type: disc">Adding a custom kernel and bootloader</li><li class="listitem" style="list-style-type: disc">Building the U-Boot bootloader</li><li class="listitem" style="list-style-type: disc">Explaining Yocto's Linux kernel support</li><li class="listitem" style="list-style-type: disc">Describing Linux's build system</li><li class="listitem" style="list-style-type: disc">Configuring the Linux kernel</li><li class="listitem" style="list-style-type: disc">Building the Linux source</li><li class="listitem" style="list-style-type: disc">Building external kernel modules</li><li class="listitem" style="list-style-type: disc">Debugging the Linux kernel and modules</li><li class="listitem" style="list-style-type: disc">Debugging the Linux kernel booting process</li><li class="listitem" style="list-style-type: disc">Using the kernel tracing system</li><li class="listitem" style="list-style-type: disc">Managing the device tree</li><li class="listitem" style="list-style-type: disc">Debugging device tree issues</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Introduction</h1></div></div></div><p>Once we have our build environment ready with the Yocto project, it's time to think about beginning development work on our embedded Linux project.</p><p>Most of the embedded Linux projects require both custom hardware and software. An early task in the development process is to test different hardware reference boards and the selection of one to base our design on. We have chosen the Wandboard, a Freescale i.MX6-based platform, as it is an affordable and open board, which makes it perfect for our needs.</p><p>On an embedded project, it is usually a good idea to start working on the software as soon as possible, probably before the hardware prototypes are ready, so that it is possible to start working directly with the reference design.</p><p>But at some point, the hardware prototypes will be ready and changes will need to be introduced into Yocto to support the new hardware.</p><p>This chapter will explain how to create a BSP layer to contain those hardware-specific changes, as well as show how to work with the U-Boot bootloader and the Linux kernel, components which are likely to take most of the customization work.</p></div></div>
<div class="section" title="Creating a custom BSP layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Creating a custom BSP layer</h1></div></div></div><p>These custom changes are kept on <a id="id146" class="indexterm"/>a separate Yocto layer, called a <span class="strong"><strong>Board Support Package</strong></span> (<span class="strong"><strong>BSP</strong></span>) layer. This separation is best for future updates and patches to the system. A BSP layer<a id="id147" class="indexterm"/> can support any number of new machines and any new software feature that is linked to the hardware itself.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How to do it...</h2></div></div></div><p>By convention, Yocto layer names start with <code class="literal">meta</code>, short for metadata. A BSP layer may then add a <code class="literal">bsp</code> keyword, and finally a unique name. We will call our layer <code class="literal">meta-bsp-custom</code>.</p><p>There are several ways to create a new layer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Manually, once you know what is required</li><li class="listitem" style="list-style-type: disc">By copying the <code class="literal">meta-skeleton</code> layer included in Poky</li><li class="listitem" style="list-style-type: disc">By using the <code class="literal">yocto-layer</code> command-line tool</li></ul></div><p>You can have a look at the <code class="literal">meta-skeleton</code> layer in Poky and see that it includes the following elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">layer.conf</code> file, where the layer configuration variables are set</li><li class="listitem" style="list-style-type: disc">A <code class="literal">COPYING.MIT</code> license file</li><li class="listitem" style="list-style-type: disc">Several directories named with the <code class="literal">recipes</code> prefix with example recipes for BusyBox, the Linux kernel and an example module, an example service recipe, an example user management recipe, and a multilib example.</li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>How it works...</h2></div></div></div><p>We will cover some of the use cases that appear in the available examples in the next few recipes, so for our needs, we will use the <code class="literal">yocto-layer</code> tool, which allows us to create a minimal layer.</p><p>Open a new <a id="id148" class="indexterm"/>terminal and change to the <code class="literal">fsl-community-bsp</code> directory. Then set up the environment as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Note that once the <code class="literal">build</code> directory has been created, the <code class="literal">MACHINE</code> variable has already been configured in the <code class="literal">conf/local.conf</code> file and can be omitted from the command line.</p></div></div><p>Change to the <code class="literal">sources</code> directory and run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ yocto-layer create bsp-custom</strong></span>
</pre></div><p>Note that the <code class="literal">yocto-layer</code> tool will add the <code class="literal">meta</code> prefix to your layer, so you don't need to. It will prompt a few questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The layer priority which is used to decide the layer precedence in cases where the same recipe (with the same name) exists in several layers simultaneously. It is also used to decide in what order <code class="literal">bbappends</code> are applied if several layers append the same recipe. Leave the default value of 6. This will be stored in the layer's <code class="literal">conf/layer.conf</code> file as <code class="literal">BBFILE_PRIORITY</code>.</li><li class="listitem" style="list-style-type: disc">Whether to create example recipes and append files. Let's leave the default <span class="emphasis"><em>no</em></span> for the time being.</li></ul></div><p>Our new layer has the following structure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>meta-bsp-custom/</strong></span>
<span class="strong"><strong>    conf/layer.conf</strong></span>
<span class="strong"><strong>    COPYING.MIT</strong></span>
<span class="strong"><strong>    README</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>There's more...</h2></div></div></div><p>The first thing to do is to add this new layer to your project's <code class="literal">conf/bblayer.conf</code> file. It is a good idea to add it to your template conf directory's <code class="literal">bblayers.conf.sample</code> file too, so that it is correctly appended when creating new projects. The highlighted line in the following code shows the addition of the layer to the <code class="literal">conf/bblayers.conf</code> file:</p><div class="informalexample"><pre class="programlisting">LCONF_VERSION = "6"

BBPATH = "${TOPDIR}"
BSPDIR := "${@os.path.abspath(os.path.dirname(d.getVar('FILE', True)) + '/../..')}"

BBFILES ?= ""
BBLAYERS = " \
  ${BSPDIR}/sources/poky/meta \
  ${BSPDIR}/sources/poky/meta-yocto \
  \
  ${BSPDIR}/sources/meta-openembedded/meta-oe \
  ${BSPDIR}/sources/meta-openembedded/meta-multimedia \
  \
  ${BSPDIR}/sources/meta-fsl-arm \
  ${BSPDIR}/sources/meta-fsl-arm-extra \
  ${BSPDIR}/sources/meta-fsl-demos \
  <span class="strong"><strong>${BSPDIR}/sources/meta-bsp-custom \</strong></span>
"</pre></div><p>Now, BitBake <a id="id149" class="indexterm"/>will parse the <code class="literal">bblayers.conf</code> file and find the <code class="literal">conf/layers.conf</code> file from your layer. In it, we find the following line:</p><div class="informalexample"><pre class="programlisting">BBFILES += "${LAYERDIR}/recipes-*/*/*.bb \
        ${LAYERDIR}/recipes-*/*/*.bbappend"</pre></div><p>It tells BitBake which directories to parse for recipes and append files. You need to make sure your directory and file hierarchy in this new layer matches the given pattern, or you will need to modify it.</p><p>BitBake will also find the following:</p><div class="informalexample"><pre class="programlisting">BBPATH .= ":${LAYERDIR}"</pre></div><p>The <code class="literal">BBPATH</code> variable is used to locate the <code class="literal">bbclass</code> files and the configuration and files included with the <code class="literal">include</code> and <code class="literal">require</code> directives. The search finishes with the first match, so it is best to keep filenames unique.</p><p>Some other variables we might consider defining in our <code class="literal">conf/layer.conf</code> file are:</p><div class="informalexample"><pre class="programlisting">LAYERDEPENDS_bsp-custom = "fsl-arm"
LAYERVERSION_bsp-custom = "1"</pre></div><p>The <code class="literal">LAYERDEPENDS</code> literal is a space-separated list of other layers your layer depends on, and the <code class="literal">LAYERVERSION</code> literal specifies the version of your layer in case other layers want to add a dependency to a specific version.</p><p>The <code class="literal">COPYING.MIT</code> file specifies the license for the metadata contained in the layer. The Yocto project is licensed under the <span class="emphasis"><em>MIT</em></span> license, which is also compatible with the <a id="id150" class="indexterm"/>
<span class="strong"><strong>General Public License</strong></span> (<span class="strong"><strong>GPL</strong></span>). This license applies only to the metadata, as every package included in your build will have its own license.</p><p>The <code class="literal">README</code> file will need to be modified for your specific layer. It is usual to describe the layer and provide any other layer dependencies and usage instructions.</p><div class="section" title="Adding a new machine"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Adding a new machine</h3></div></div></div><p>When customizing your<a id="id151" class="indexterm"/> BSP, it is usually a good idea to introduce a new machine for your hardware. These are kept under the <code class="literal">conf/machine</code> directory in your BSP layer. The usual thing to do is to base it on the reference design. For example, <code class="literal">wandboard-quad</code> has the following machine configuration file:</p><div class="informalexample"><pre class="programlisting">include include/wandboard.inc

SOC_FAMILY = "mx6:mx6q:wandboard"

UBOOT_MACHINE = "wandboard_quad_config"

KERNEL_DEVICETREE = "imx6q-wandboard.dtb"

MACHINE_FEATURES += "bluetooth wifi"

MACHINE_EXTRA_RRECOMMENDS += " \
  bcm4329-nvram-config \
  bcm4330-nvram-config \
"</pre></div><p>A machine based on the Wandboard design could define its own machine configuration file, <code class="literal">wandboard-quad-custom.conf</code>, as follows:</p><div class="informalexample"><pre class="programlisting">include conf/machine/include/wandboard.inc

SOC_FAMILY = "mx6:mx6q:wandboard"

UBOOT_MACHINE = "wandboard_quad_custom_config"

KERNEL_DEVICETREE = "imx6q-wandboard-custom.dtb"

MACHINE_FEATURES += "wifi"</pre></div><p>The <code class="literal">wandboard.inc</code> file now resides on a different layer, so in order for BitBake to find it, we need to specify the full path from the <code class="literal">BBPATH</code> variable in the corresponding layer. This machine defines its own U-Boot configuration file and Linux kernel device tree in addition to defining its own set of machine features.</p></div><div class="section" title="Adding a custom device tree to the Linux kernel"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Adding a custom device tree to the Linux kernel</h3></div></div></div><p>To add this device tree file to the <a id="id152" class="indexterm"/>Linux kernel, we need to<a id="id153" class="indexterm"/> add the device tree file to the <code class="literal">arch/arm/boot/dts</code> directory <a id="id154" class="indexterm"/>under the Linux kernel source and also modify the Linux build system's <code class="literal">arch/arm/boot/dts/Makefile</code> file to build it as follows:</p><div class="informalexample"><pre class="programlisting">dtb-$(CONFIG_ARCH_MXC) += \
+imx6q-wandboard-custom.dtb \</pre></div><p>This code uses diff formatting, where the lines with a minus prefix are removed, the ones with a plus sign are added, and the ones without a prefix are left as reference.</p><p>Once the patch is prepared, it can be added to the <code class="literal">meta-bsp-custom/recipes-kernel/linux/linux-wandboard-3.10.17/</code> directory and the Linux kernel recipe appended adding a <code class="literal">meta-bsp-custom/recipes-kernel/linux/linux-wandboard_3.10.17.bbappend</code> file with the following content:</p><div class="informalexample"><pre class="programlisting">SRC_URI_append = " file://0001-ARM-dts-Add-wandboard-custom-dts- file.patch"</pre></div><p>An example patch that adds a custom device tree to the Linux kernel can be found in the source code that accompanies the book.</p></div><div class="section" title="Adding a custom U-Boot machine"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec15"/>Adding a custom U-Boot machine</h3></div></div></div><p>In the same way, the <a id="id155" class="indexterm"/>U-Boot source may be patched to add a new<a id="id156" class="indexterm"/> custom machine. Bootloader modifications are not as likely to be needed as kernel modifications though, and most custom platforms will leave the bootloader unchanged. The patch would be added to the <code class="literal">meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/</code> directory and the U-Boot recipe appended with a <code class="literal">meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend</code> file with the following content:</p><div class="informalexample"><pre class="programlisting">SRC_URI_append = " file://0001-boards-Add-wandboard-custom.patch"</pre></div><p>An example patch that adds a custom machine to U-Boot can be found in the source code that accompanies the book.</p></div><div class="section" title="Adding a custom formfactor file"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec16"/>Adding a custom formfactor file</h3></div></div></div><p>Custom platforms can also<a id="id157" class="indexterm"/> define their own <code class="literal">formfactor</code> file with <a id="id158" class="indexterm"/>information that the build system cannot obtain from other sources, such as defining whether a touchscreen is available or defining the screen orientation. These are defined in the <code class="literal">recipes-bsp/formfactor/</code> directory in our <code class="literal">meta-bsp-custom</code> layer. For our new machine, we could define a <code class="literal">meta-bsp-custom/recipes-bsp/formfactor/formfactor_0.0.bbappend</code> file to include a <code class="literal">formfactor</code> file as follows:</p><div class="informalexample"><pre class="programlisting">FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"</pre></div><p>And <a id="id159" class="indexterm"/>the <a id="id160" class="indexterm"/>machine-specific <code class="literal">meta-bsp-custom/recipes-bsp/formfactor/formfactor/wandboard-quadcustom/machconfig</code> file would be as follows:</p><div class="informalexample"><pre class="programlisting">HAVE_TOUCHSCREEN=1</pre></div></div></div></div>
<div class="section" title="Introducing system development workflows"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Introducing system development workflows</h1></div></div></div><p>When customizing the <a id="id161" class="indexterm"/>software, there are some system development workflows that are commonly used, and we will introduce them in this recipe.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>How to do it...</h2></div></div></div><p>We will see an overview of the following development workflows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">External development</li><li class="listitem" style="list-style-type: disc">Working directory development</li><li class="listitem" style="list-style-type: disc">External source development</li></ul></div><p>They are all used under different scenarios.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec67"/>How it works...</h2></div></div></div><p>Let's understand what the use of each of these development workflows is individually.</p><div class="section" title="External development"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec17"/>External development</h3></div></div></div><p>In this workflow, we don't <a id="id162" class="indexterm"/>use the Yocto build system to build our packages, just a Yocto toolchain and the package's own build system.</p><p>The resulting source can be integrated into Yocto in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">With a recipe that fetches a released tarball.</li><li class="listitem" style="list-style-type: disc">With a recipe that fetches directly from a source-controlled repository.</li></ul></div><p>External development is usually the preferred method for U-Boot and Linux kernel development, as they can be easily cross-compiled. Third-party packages in Yocto are also developed in this way.</p><p>However, third-party packages can be tricky to cross-compile, and that is just what the Yocto build system makes easy. So, if we are not the main developers of the package and we only want to introduce some fixes or modifications, we can use Yocto to help us. The two workflows explained in <a id="id163" class="indexterm"/>the following sections use the Yocto build system.</p></div><div class="section" title="Working directory development"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec18"/>Working directory development</h3></div></div></div><p>In this workflow, we <a id="id164" class="indexterm"/>use the working directory inside the <code class="literal">build</code> directory, <code class="literal">tmp/work</code>. As we know, when Yocto builds a package, it uses the working directory to extract, patch, configure, build, and package the source. We can directly modify the source in this directory and use the Yocto system to build it.</p><p>This methodology is commonly used when sporadically debugging third-party packages.</p><p>The workflow is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Remove the package's <code class="literal">build</code> directory to start from scratch:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c cleanall &lt;target&gt;</strong></span>
</pre></div></li><li class="listitem">Tell BitBake to fetch, unpack, and patch the package, but stop there:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c patch &lt;target&gt;</strong></span>
</pre></div></li><li class="listitem">Enter the package's source directory and modify the source. Usually, we would create a temporary local Git directory to help us with our development and to extract the patches easily.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c devshell &lt;target&gt;</strong></span>
</pre></div></li><li class="listitem">Build it without losing our changes:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -C compile &lt;target&gt;</strong></span>
</pre></div><p>Note the capital <code class="literal">C</code>. This instructs BitBake to run the compile task and all the tasks that follow it. This is the same as running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c compile &lt;target&gt;</strong></span>
<span class="strong"><strong>$ bitbake &lt;target&gt;</strong></span>
</pre></div></li><li class="listitem">Test it by copying the package to a running system and installing it with the target's package management system. When you run your system from an NFS root filesystem, it's as easy as to copy it there and run the following command (assuming the default RPM package format):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ rpm -i &lt;package&gt;</strong></span>
</pre></div><p>Optionally, you can also use a package feed as we saw in the <span class="emphasis"><em>Setting up a package feed</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. The Build System">Chapter 1</a>, <span class="emphasis"><em>The Build System</em></span>, in which case you would rebuild the index with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake package-index</strong></span>
</pre></div><p>And then use the smart package management utility on the target to install the package as previously shown.</p></li><li class="listitem">Extract the <a id="id165" class="indexterm"/>patches and add them to the recipe's <code class="literal">bbappend</code> file.</li></ol></div></div><div class="section" title="External source development"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec19"/>External source development</h3></div></div></div><p>In this workflow, we <a id="id166" class="indexterm"/>will use the Yocto build system to build an external directory containing the source. This external directory is usually source controlled to help us in our development.</p><p>This is the usual methodology to follow for extensive package development once the source has already been integrated with the Yocto build system.</p><p>The workflow is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We perform our development on this external-version-controlled directory and commit our changes locally.</li><li class="listitem">We configure the Yocto build system to use a directory in our host system to fetch the source from, and optionally also to build in. This guarantees that our changes cannot be lost by any action of the Yocto build system. We will see some examples of this later on.</li><li class="listitem">Build it using Yocto:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake &lt;target&gt;</strong></span>
</pre></div></li><li class="listitem">Test it by copying the package to a running system and installing it with the target's package management system.</li><li class="listitem">Extract the patches and add them to the recipe's <code class="literal">bbappend</code> file.</li></ol></div></div></div></div>
<div class="section" title="Adding a custom kernel and bootloader"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Adding a custom kernel and bootloader</h1></div></div></div><p>Development in U-Boot <a id="id167" class="indexterm"/>and the Linux <a id="id168" class="indexterm"/>kernel is usually done externally to Yocto, as they are easy to build using a toolchain, like the one provided by Yocto.</p><p>The development work is then integrated into Yocto in one of two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">With patches added to the kernel and U-Boot <code class="literal">bbappend</code> files. This method will build the same source as the reference design board we are using as base, and apply our changes over it.</li><li class="listitem" style="list-style-type: disc">Using a different Git repository, forked from the Linux kernel and U-Boot Git repositories being used by the reference design, and using a <code class="literal">bbappend</code> file to point the recipe to it. This way, we can directly commit the changes to the repository and the Yocto build system will build them.</li></ul></div><p>Usually a <a id="id169" class="indexterm"/>forked Git repository is only needed when the hardware <a id="id170" class="indexterm"/>changes are substantial and the work in the Linux kernel and bootloader is going to be extensive. The recommendation is to start with patches, and only use a forked repository when they become difficult to manage.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec68"/>Getting Ready</h2></div></div></div><p>The first question when starting work on the Linux kernel and U-Boot modifications is how do you find which of the several available recipes are being used for your build.</p><div class="section" title="Finding the Linux kernel source"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec20"/>Finding the Linux kernel source</h3></div></div></div><p>To find the Linux kernel source, we might <a id="id171" class="indexterm"/>use several methods. As we are aware we are building for a <code class="literal">wandboard-quad</code> machine, the first thing to do is find a machine configuration file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/sources</strong></span>
<span class="strong"><strong>$ find -name wandboard-quad.conf</strong></span>
<span class="strong"><strong>./meta-fsl-arm-extra/conf/machine/wandboard-quad.conf</strong></span>
</pre></div><p>The machine configuration file above in turn includes a <code class="literal">wandboard.inc</code> file:</p><div class="informalexample"><pre class="programlisting">include conf/machine/include/imx-base.inc
include conf/machine/include/tune-cortexa9.inc

PREFERRED_PROVIDER_virtual/kernel ?= "linux-wandboard"
PREFERRED_VERSION_linux-wandboard ?= "3.10.17"</pre></div><p>Here we find a Linux kernel recipe being specified as the preferred provider for virtual/kernel. Virtual packages like this are used when a feature or element is provided by more than one recipe. It allows us to choose which of all those recipes will finally be used. Virtual packages will be further explained in the <span class="emphasis"><em>Selecting a specific package versions and providers</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. The Software Layer">Chapter 3</a>, <span class="emphasis"><em>The Software Layer</em></span>.</p><p>We could check the actual output from our previous <code class="literal">core-image-minimal</code> build:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ find tmp/work -name "*linux-wandboard*"</strong></span>
<span class="strong"><strong>tmp/work/wandboard_quad-poky-linux-gnueabi/linux-wandboard</strong></span>
</pre></div><p>As the <code class="literal">linux-wanboard</code> directory exists in our <code class="literal">work</code> folder, we can be sure the recipe has been used.</p><p>We can check what the available Linux recipes are with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ find -name "*linux*.bb"</strong></span>
</pre></div><p>We have lots of options, but we can use some of our acquired knowledge to filter them out. Let's exclude the <code class="literal">poky</code> and <code class="literal">meta-openembedded</code> directories, as we know the BSP support is included in the Freescale community BSP layers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ find -path ./poky -prune -o -path ./meta-openembedded -prune -o -name "*linux*.bb"</strong></span>
</pre></div><p>Finally, we can also <a id="id172" class="indexterm"/>use the <code class="literal">bitbake-layers</code> script included in Poky:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake-layers show-recipes 'linux*'</strong></span>
</pre></div><p>Not all those <a id="id173" class="indexterm"/>kernels support the Wandboard machine completely, but<a id="id174" class="indexterm"/> they all support Freescale ARM machines, so they are useful for comparisons.</p></div><div class="section" title="Finding the U-Boot source"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec21"/>Finding the U-Boot source</h3></div></div></div><p>If we continue to pull the<a id="id175" class="indexterm"/> include chain, we have <code class="literal">imx-base.inc</code>, which itself includes <code class="literal">fsl-default-providers.inc</code>, where we find:</p><div class="informalexample"><pre class="programlisting">PREFERRED_PROVIDER_u-boot ??= "u-boot-fslc"
PREFERRED_PROVIDER_virtual/bootloader ??= "u-boot-fslc"</pre></div><p>So <code class="literal">u-boot-fslc</code> is the U-Boot recipe we are looking for.</p></div><div class="section" title="Developing using a Git repository fork"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec22"/>Developing using a Git repository fork</h3></div></div></div><p>We will show how to append a <a id="id176" class="indexterm"/>recipe to use a forked repository to work from it. We will use the Linux kernel as an example, but the concept works just as well for U-Boot or any other package, although the specifics will change.</p><p>We will fork or branch the repository used in the reference design and use it to specify <code class="literal">SRC_URI</code> for the recipe.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec69"/>How to do it...</h2></div></div></div><p>For this example, I have forked the repository to <a class="ulink" href="https://github.com/yoctocookbook/linux">https://github.com/yoctocookbook/linux</a>, so my <code class="literal">recipes-kernel/linux/linux-wandboard_3.10.17.bbappend</code> file would have the following changes:</p><div class="informalexample"><pre class="programlisting"># Copyright Packt Publishing 2015
WANDBOARD_GITHUB_MIRROR = "<span class="strong"><strong>git://github.com/yoctocookbook/linux.git</strong></span>"
SRCBRANCH = "wandboard_imx_3.10.17_1.0.2_ga-dev"
SRCREV = "${AUTOREV}"</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Note how the URL needs to start with <code class="literal">git://</code>. This is so that BitBake can recognize it as a Git source. Now we can clean and build the Linux kernel and the source will be fetched from the forked repository.</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec70"/>How it works...</h2></div></div></div><p>Let's have a<a id="id177" class="indexterm"/> look at<a id="id178" class="indexterm"/> the <code class="literal">linux-wandboard_3.10.17.bb</code> recipe:</p><div class="informalexample"><pre class="programlisting">include linux-wandboard.inc
require recipes-kernel/linux/linux-dtb.inc

DEPENDS += "lzop-native bc-native"

# Wandboard branch - based on 3.10.17_1.0.2_ga from Freescale git
SRCBRANCH = "wandboard_imx_3.10.17_1.0.2_ga"
SRCREV = "be8d6872b5eb4c94c15dac36b028ce7f60472409"
LOCALVERSION = "-1.0.2-wandboard"

COMPATIBLE_MACHINE = "(wandboard)"</pre></div><p>The first interesting thing is the inclusion of both <code class="literal">linux-wandboard.inc</code> and <code class="literal">linux-dtb.inc</code>. We will look at the first later on, and the other is a class that allows us to compile Linux kernel device trees. We will discuss device trees in the <span class="emphasis"><em>Managing the device tree</em></span> recipe later in this chapter.</p><p>Then it declares two package dependencies, <code class="literal">lzop-native</code> and <code class="literal">bc-native</code>. The <code class="literal">native</code> part tells us that these are used in the host system, so they are used during the Linux kernel build process. The <code class="literal">lzop</code> tool is used to create the <code class="literal">cpio</code> compressed files needed in the <code class="literal">initramfs</code> system, which is a system that boots from a memory-based root filesystem, and <code class="literal">bc</code> was introduced to avoid a Perl kernel dependency when generating certain kernel files.</p><p>Then it sets the branch and revision, and finally it sets <code class="literal">COMPATIBLE_MACHINE</code> to <code class="literal">wandboard</code>. We will speak about machine compatibility in the <span class="emphasis"><em>Adding new packages</em></span> recipe of <a class="link" href="ch03.html" title="Chapter 3. The Software Layer">Chapter 3</a>, <span class="emphasis"><em>The Software Layer</em></span>.</p><p>Let's now have a look at the <code class="literal">linux-wandboard.inc</code> include file:</p><div class="informalexample"><pre class="programlisting">SUMMARY = "Linux kernel for Wandboard"
LICENSE = "GPLv2"
LIC_FILES_CHKSUM = "file://COPYING;md5=d7810fab7487fb0aad327b76f1be7cd7"

require recipes-kernel/linux/linux-imx.inc

# Put a local version until we have a true SRCREV to point to
SCMVERSION ?= "y"

SRCBRANCH ??= "master"
LOCALVERSION ?= "-${SRCBRANCH}"

# Allow override of WANDBOARD_GITHUB_MIRROR to make use of
# local repository easier
<span class="strong"><strong>WANDBOARD_GITHUB_MIRROR</strong></span> ?= "git://github.com/wandboard- org/linux.git"

# SRC_URI for wandboard kernel
<span class="strong"><strong>SRC_URI = "${WANDBOARD_GITHUB_MIRROR};branch=${SRCBRANCH} \</strong></span>
<span class="strong"><strong>           file://defconfig \</strong></span>
" </pre></div><p>This is<a id="id179" class="indexterm"/> actually the file we were looking for. Initially, it specifies the license <a id="id180" class="indexterm"/>for the kernel source and points to it, sets a default branch and local version kernel string, and sets up the <code class="literal">SCR_URI</code> variable, which is the place where the source code is fetched from.</p><p>It then offers the <code class="literal">WANDBOARD_GITHUB_MIRROR</code> variable, which we can modify in our <code class="literal">bbappend</code> file.</p><p>So the logical setup would be to create a GitHub account and fork the provided <code class="literal">wandboard-org</code> Linux repository.</p><p>Once the fork is in place, we need to modify the <code class="literal">WANDBOARD_GITHUB_MIRROR</code> variable. But as we saw before, the recipe configures a specific revision and branch. We want to develop here, so we want to change this to a new development branch we have created. Let's call it <code class="literal">wandboard_imx_3.10.17_1.0.2_ga-dev</code> and set the revision to automatically fetch the newest point in the branch.</p></div></div>
<div class="section" title="Building the U-Boot bootloader"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Building the U-Boot bootloader</h1></div></div></div><p>In this recipe, we will go through <a id="id181" class="indexterm"/>the several development workflows described previously using the U-Boot bootloader as an example.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec71"/>How to do it...</h2></div></div></div><p>We will see how the following development workflows are applied to U-Boot:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">External development</li><li class="listitem" style="list-style-type: disc">External source development</li><li class="listitem" style="list-style-type: disc">Working directory development</li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec72"/>How it works...</h2></div></div></div><p>Let's explain the three workflows, previously mentioned, in detail.</p><div class="section" title="External development"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec23"/>External development</h3></div></div></div><p>We will use a Yocto toolchain to build the <a id="id182" class="indexterm"/>U-Boot source externally from the Yocto build system.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download and install a Yocto project cross-compilation toolchain<a id="id183" class="indexterm"/> for your host by going to the following:<p><a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/">http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/</a></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>Choose either the 32- or 64-bit version and execute the installation script, accepting the default installation location. It is recommended not to change the default location to avoid relocation issues.</p></div></div></li><li class="listitem">Find the upstream Git repository:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -e u-boot-fslc | grep ^SRC_URI=</strong></span>
<span class="strong"><strong>SRC_URI="git://github.com/Freescale/u-boot- imx.git;branch=patches-2014.10"</strong></span>
</pre></div></li><li class="listitem">Clone the U-Boot's source from its upstream repository:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/</strong></span>
<span class="strong"><strong>$ git clone git://github.com/Freescale/u-boot-imx.git</strong></span>
<span class="strong"><strong>$ cd u-boot-imx</strong></span>
</pre></div><p>The default branch should be <code class="literal">patches-2014.10</code>, but if it's not, you can change it with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git checkout -b patches-2014.10 origin/patches-2014.10</strong></span>
</pre></div></li><li class="listitem">Set up the environment using the script provided with the toolchain:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source /opt/poky/1.7.1/environment-setup-armv7a-vfp-neon- poky-linux-gnueabi</strong></span>
</pre></div></li><li class="listitem">Configure U-Boot for <code class="literal">wandboard-quad</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make wandboard_quad_config</strong></span>
</pre></div></li><li class="listitem">If you try to build U-Boot, it will fail. This is because the default Yocto environment setup does not cater to U-Boot's needs. A quick look at the U-Boot recipe shows that it clears some flags before building, so let's do that:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ unset LDFLAGS CFLAGS CPPFLAGS</strong></span>
</pre></div></li><li class="listitem">Now<a id="id184" class="indexterm"/> we are ready to build. The U-Boot recipe also passes <code class="literal">CC</code> to the <code class="literal">make</code> utility in the <code class="literal">EXTRA_OEMAKE</code> flags as U-Boot does not read it from the environment, so we also need to run:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make CC="${CC}"</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>You can optionally pass a <code class="literal">-jN</code> argument for multithreaded compilation. Here, <code class="literal">N</code> is the number of CPU cores.</p></div></div></li></ol></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec73"/>How it works…</h2></div></div></div><p>The U-Boot <code class="literal">Makefile</code> looks for <code class="literal">libgcc</code> using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PLATFORM_LIBGCC := -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc- file-name`</strong></span>
<span class="strong"><strong>) -lgcc</strong></span>
</pre></div><p>If we don't define <code class="literal">CC</code>, the expression does not correctly expand to the location of the <code class="literal">libgcc</code> library in the toolchain, as the <code class="literal">sysroot</code> option is not passed to the compiler.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Newer versions of U-Boot have already fixed this issue, but we decided to leave the instruction as the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make CC="${CC}"</strong></span>
</pre></div><p>That works for older versions of U-Boot too.</p></div></div><p>Another way to avoid the problem would be to define the <code class="literal">USE_PRIVATE_LIBGCC</code> U-Boot configuration variable, but that would use an internal <code class="literal">libgcc</code> library to U-Boot, which may not be what we want.</p><p>We would then need to copy the image to the target to test our changes, as we will see soon.</p><div class="section" title="External source development"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec24"/>External source development</h3></div></div></div><p>We will use the Yocto build <a id="id185" class="indexterm"/>system from a local directory by cloning a local copy of the source used in the reference design and configuring our project to use it as an external source. We will then develop from it, extract the patches, and add them to a <code class="literal">bbappend</code> file on our BSP layer.</p><p>We will use the U-Boot source cloned in the example beforehand.</p><p>To configure our <code class="literal">conf/local.conf</code> file to work from the cloned source, modify it as follows:</p><div class="informalexample"><pre class="programlisting">INHERIT += "externalsrc"
EXTERNALSRC_pn-u-boot-fslc = "/opt/yocto/u-boot-imx"
EXTERNALSRC_BUILD_pn-u-boot-fslc = "/opt/yocto/u-boot-imx"</pre></div><p>The <code class="literal">EXTERNALSRC</code> variable defines the source location (<code class="literal">S</code>), while the <code class="literal">EXTERNALSRC_BUILD</code> variable defines the build location (<code class="literal">B</code>). This code will also build on the external source location as the <code class="literal">u-boot-fslc</code> recipe does not currently support the separation of the source and <code class="literal">build</code> directories.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>Remember to remove the aforementioned configuration when trying the working directory development methodology explained next in this recipe.</p></div></div><p>Now we can <a id="id186" class="indexterm"/>build on a new shell with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake u-boot-fslc</strong></span>
</pre></div><p>When building from an external source, the expansion of <code class="literal">SRCPV</code> fails with an error. Recipes need to be temporarily modified to use static versioning while the external source compilation is enabled. In the case of U-Boot, we would make the following change in the <code class="literal">meta-fsl-arm/recipes-bsp/u-boot/u-boot-fslc_2014.10.bb</code> file:</p><div class="informalexample"><pre class="programlisting">- PV = "v2014.10+git${SRCPV}"
+ PV = "v2014.10"</pre></div><p>This uses diff formatting, where the lines with a minus prefix are removed and the ones with a plus sign are added.</p><p>An example patch to U-Boot that allows us to perform external source development can be found in the source code that accompanies the book.</p><p>Development work can now be committed in the local Git repository, and patches can be generated with <code class="literal">git format-patch</code>. For example, we could change the board information for the Wandboard with the <code class="literal">0001-wandboard-Change-board-info.patch</code> file:</p><div class="informalexample"><pre class="programlisting">diff --git a/board/wandboard/wandboard.c b/board/wandboard/wandboard.c
index 3c8b7a5d2d0a..a466d4c74b8f 100644
--- a/board/wandboard/wandboard.c
+++ b/board/wandboard/wandboard.c
@@ -404,7 +404,7 @@ int board_init(void)

 int checkboard(void)
 {
-       puts("Board: Wandboard\n");
+      puts("Board: Wandboard custom\n");

        return 0;
 }</pre></div><p>To add this <a id="id187" class="indexterm"/>patch to Yocto's U-Boot recipe, we create a <code class="literal">meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend</code> file with the following content:</p><div class="informalexample"><pre class="programlisting"># Copyright Packt Publishing 2015
FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}-${PV}:"
SRC_URI_append = " file://0001-wandboard-Change-board-info.patch"</pre></div><p>The patch needs to be placed under <code class="literal">meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/</code>, as specified in the <code class="literal">FILESEXTRAPATHS</code> variable.</p><p>Files added to the <code class="literal">SRC_URI</code> variable that end in the <code class="literal">patch</code> or <code class="literal">diff</code> prefixes will be applied in the order they are found. You can also force a file to be treated as <code class="literal">patch</code> by specifying an <code class="literal">apply=yes</code> property to it in <code class="literal">SRC_URI</code>.</p></div><div class="section" title="Working directory development"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec25"/>Working directory development</h3></div></div></div><p>A typical workflow when working on a small <a id="id188" class="indexterm"/>modification would be:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start the U-Boot package compilation from scratch:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c cleanall virtual/bootloader</strong></span>
</pre></div><p>This will erase the <code class="literal">build</code> folder, shared state cache, and downloaded package source.</p></li><li class="listitem">Start a development shell:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c devshell virtual/bootloader</strong></span>
</pre></div><p>This will fetch, unpack, and patch the U-Boot sources and spawn a new shell with the environment ready for U-Boot compilation. The new shell will change to the U-Boot <code class="literal">build</code> directory, which contains a local Git repository.</p></li><li class="listitem">Perform your modifications on the local Git repository.</li><li class="listitem">Leave the devshell open and use a different terminal to compile the source without erasing our modifications:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -C compile virtual/bootloader</strong></span>
</pre></div><p>Note the capital <code class="literal">C</code>. This invokes the compile task but also all the tasks that follow it.</p><p>The newly compiled U-Boot image is available under <code class="literal">tmp/deploy/images/wandboard-quad</code>.</p></li><li class="listitem">Test your changes. Typically, this means that we need to reprogram the bootloader into the microSD card (as is the case with the Wandboard) or the internal <code class="literal">emmc</code> (if available) at the correct offset. We can do it both from the target or from your host computer.<p>From the <a id="id189" class="indexterm"/>host computer, we would use <code class="literal">dd</code> to copy the new U-Boot image to an offset of 0x400, which is where the i.MX6 bootrom expects to find it.</p><div class="informalexample"><pre class="programlisting">sudo dd if=u-boot.imx of=/dev/sdN bs=512 seek=2 &amp;&amp; sync</pre></div><p>This writes with an offset of 2 blocks, which, given a 512-byte block size, is 0x400 (1024) bytes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>Be careful when running the <code class="literal">dd</code> command, as it could harm your machine. You need to be absolutely sure that the sdN device corresponds to your microSD card and not a drive on your development machine.</p></div></div><p>From the device itself, we can use U-Boot's <code class="literal">mmc</code> command as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Load the U-Boot image to memory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; setenv ipaddr &lt;target_ip&gt;</strong></span>
<span class="strong"><strong>&gt; setenv serverip &lt;host_ip&gt;</strong></span>
<span class="strong"><strong>&gt; tftp ${loadaddr} u-boot.imx</strong></span>
</pre></div></li></ul></div><p>The hexadecimal file size of the TFTP transfer is kept in the filesize environment variable, which we will use later on.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Select the MMC device to operate on. You can use the <code class="literal">mmc</code> part to discover which is the correct device.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; mmc dev 0</strong></span>
<span class="strong"><strong>&gt; mmc part</strong></span>
<span class="strong"><strong>Partition Map for MMC device 0  --   Partition Type: DOS</strong></span>
<span class="strong"><strong>Part    Start Sector    Num Sectors     UUID            Type</strong></span>
<span class="strong"><strong>  1     8192            16384           0003b9dd-01     0c</strong></span>
<span class="strong"><strong>  2     24576           131072          0003b9dd-02     83</strong></span>
</pre></div></li></ul></div><p>We can see that partition <code class="literal">1</code> starts at sector <code class="literal">8192</code>, leaving enough space to program U-Boot.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">With a 512-byte block size, we calculate the number of blocks as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; setexpr filesizeblks $filesize / 0x200</strong></span>
<span class="strong"><strong>&gt; setexpr filesizeblks $filesizeblks + 1</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">We then write to an offset of two blocks with the numbers of blocks occupied by our image.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; mmc write ${loadaddr} 0x2 ${filesizeblks}</strong></span>
</pre></div></li></ul></div></li><li class="listitem">Go back <a id="id190" class="indexterm"/>to the devshell and commit your change to the local Git repository.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git add --all .</strong></span>
<span class="strong"><strong>$ git commit -s -m "Well thought commit message"</strong></span>
</pre></div></li><li class="listitem">Generate a patch into the U-Boot recipe patch directory as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git format-patch -1 -o /opt/yocto/fsl-community- bsp/sources/meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc- v2014.10/</strong></span>
</pre></div></li><li class="listitem">Finally, add the patch to the U-Boot recipe as explained before.</li></ol></div></div></div></div>
<div class="section" title="Explaining Yocto's Linux kernel support"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Explaining Yocto's Linux kernel support</h1></div></div></div><p>The Yocto project offers <a id="id191" class="indexterm"/>a kernel framework that allows us to work with the Linux kernel in different ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Fetching the source from a Git repository and applying patches to it. This is the path taken by the Freescale community BSP-supported kernels, as we saw previously.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">linux-yocto</code> style kernels that generate the kernel source from a set of Git branches and leafs. Specific features are developed in branches, and a leaf is followed for a complete set of features.</li></ul></div><p>In this recipe, we will show how to work with a <code class="literal">linux-yocto</code> style kernel.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec74"/>How to do it...</h2></div></div></div><p>To use a <code class="literal">linux-yocto</code> style kernel, the kernel recipe inherits the <code class="literal">linux-yocto.inc</code> file. A Git repository for a <code class="literal">linux-yocto</code> style kernel contains metadata either in the recipe or inside the kernel Git tree, in branches named with the <code class="literal">meta</code> prefix.</p><p>The <code class="literal">linux-yocto</code> style kernel<a id="id192" class="indexterm"/> recipes are all named <code class="literal">linux-yocto</code> and follow the upstream kernel development, rooted in the <code class="literal">kernel.org</code> repository. Once a new Yocto release cycle starts, a recent upstream kernel version is chosen, and the kernel version from the previous Yocto release is maintained. Older versions are updated inline with the <span class="strong"><strong>Long Term Support Initiative</strong></span> (<span class="strong"><strong>LTSI</strong></span>)<a id="id193" class="indexterm"/> releases. There is also a <code class="literal">linux-yocto-dev</code> package, which always follows the latest upstream kernel development.</p><p>Yocto kernels are maintained separately from the upstream kernel sources, and add features and BSPs to cater to embedded system developers.</p><p>Although the Freescale <a id="id194" class="indexterm"/>community BSP does not include <code class="literal">linux-yocto</code> style kernels, some other BSP layers do.</p><p>Metadata variables that are used to define the build include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">KMACHINE</code>: This is usually the<a id="id195" class="indexterm"/> same as the <code class="literal">MACHINE</code> variable, but not always. It defines the kernel's machine type.</li><li class="listitem" style="list-style-type: disc"><code class="literal">KBRANCH</code>: This <a id="id196" class="indexterm"/>explicitly sets the kernel branch to build. It is optional.</li><li class="listitem" style="list-style-type: disc"><code class="literal">KBRANCH_DEFAULT</code>: This is the <a id="id197" class="indexterm"/>default value for KBRANCH, initially <code class="literal">master</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">KERNEL_FEATURES</code>: This <a id="id198" class="indexterm"/>adds additional metadata that is used to specify configuration and patches. It appears above the defined <code class="literal">KMACHINE</code> and <code class="literal">KBRANCH</code>. It is defined in <span class="strong"><strong>Series Configuration Control</strong></span> (<span class="strong"><strong>SCC</strong></span>)<a id="id199" class="indexterm"/> files as described soon.</li><li class="listitem" style="list-style-type: disc"><code class="literal">LINUX_KERNEL_TYPE</code>: This <a id="id200" class="indexterm"/>defaults to standard, but may also be <code class="literal">tiny</code> or <code class="literal">preempt-rt</code>. It is defined in its own SCC description files, or explicitly defined using the <code class="literal">KTYPE</code> variable in the SCC files.</li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec75"/>How it works...</h2></div></div></div><p>The metadata included in the Linux kernel manages the configuration and source selection to support multiple BSPs and kernel types. The tools that manage this metadata are built in the <code class="literal">kern-tools</code> package.</p><p>The metadata can be set either in recipes, for small changes or if you are using a kernel repository you do not have access to, or most usually inside the kernel Git repository in <code class="literal">meta</code> branches. The <code class="literal">meta</code> branch that is to be used defaults to a <code class="literal">meta</code> directory in the same repository branch as the sources, but can be specified using the <code class="literal">KMETA</code> variable in your kernel recipe. If it does not reside in the same branch as the kernel source, it is kept in an orphan branch; that is, a branch with its own history. To create an orphan branch, use the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git checkout --orphan meta</strong></span>
<span class="strong"><strong>$ git rm -rf .</strong></span>
<span class="strong"><strong>$ git commit --allow-empty -m "Meta branch"</strong></span>
</pre></div><p>Your recipe must <a id="id201" class="indexterm"/>then include <code class="literal">SRCREV_meta</code> to point to the revision of the <code class="literal">meta</code> branch to use.</p><p>The metadata is described in SCC files, which can include a series of commands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">kconf</code>: This<a id="id202" class="indexterm"/> command applies a configuration fragment to the kernel configuration.</li><li class="listitem" style="list-style-type: disc"><code class="literal">patch</code>: This <a id="id203" class="indexterm"/>command applies the specified patch.</li><li class="listitem" style="list-style-type: disc"><code class="literal">define</code>: This <a id="id204" class="indexterm"/>introduces the variable definitions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">include</code>: This <a id="id205" class="indexterm"/>includes another SCC file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">git merge</code>: This <a id="id206" class="indexterm"/>merges the specified branch into the current branch.</li><li class="listitem" style="list-style-type: disc"><code class="literal">branch</code>: This <a id="id207" class="indexterm"/>creates a new branch relative to the current branch, usually <code class="literal">KTYPE</code> or as specified.</li></ul></div><p>SCC files are broadly divided into the following logical groupings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>configuration (</strong></span><code class="literal">cfg</code><span class="strong"><strong>)</strong></span>: This <a id="id208" class="indexterm"/>contains one or more kernel configuration fragments and an SCC file to describe them. For example:<div class="informalexample"><pre class="programlisting">cfg/spidev.scc:
        define KFEATURE_DESCRIPTION "Enable SPI device support"
        kconf hardware spidev.cfg

cfg/spidev.cfg:
        CONFIG_SPI_SPIDEV=y</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>patches</strong></span>: This <a id="id209" class="indexterm"/>contains one or more kernel patches and an SCC file to describe them. For example:<div class="informalexample"><pre class="programlisting">patches/fix.scc:
        patch fix.patch

patches/fix.patch</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>features</strong></span>: This<a id="id210" class="indexterm"/> contains mix configurations and patches to define complex features. It can also include other description files. For example:<div class="informalexample"><pre class="programlisting">features/feature.scc
        define KFEATURE_DESCRIPTION "Enable feature"

        patch 0001-feature.patch
    
        include cfg/feature_dependency.scc
        kconf non-hardware feature.cfg</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>kernel types</strong></span><a id="id211" class="indexterm"/>: This contains features that define a high-level kernel policy. By default, three kernel types are defined in SCC files:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>standard</strong></span>: This is a generic kernel definition policy</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>tiny</strong></span>: This is a bare minimum kernel definition policy and is independent of the standard type</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>preempt-rt</strong></span>: This inherits from the standard type to define a real-time kernel where the <code class="literal">PREEMTP-RT</code> patches are applied</li></ul></div><p>Other kernel types can be defined by using the <code class="literal">KTYPE</code> variable on an SCC file.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Board Support Packages</strong></span> (<span class="strong"><strong>BSP</strong></span>): A <a id="id212" class="indexterm"/>combination of kernel types and hardware <a id="id213" class="indexterm"/>features. BSP types should include KMACHINE for the kernel machine and KARCH for the kernel architecture.</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec76"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Detailed information regarding<a id="id214" class="indexterm"/> <code class="literal">linux-yocto</code> style kernels can be found in the <span class="emphasis"><em>Yocto Project Linux Kernel Development Manual</em></span> at <a class="ulink" href="http://www.yoctoproject.org/docs/1.7.1/kernel-dev/kernel-dev.html">http://www.yoctoproject.org/docs/1.7.1/kernel-dev/kernel-dev.html</a></li></ul></div></div></div>
<div class="section" title="Describing Linux's build system"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Describing Linux's build system</h1></div></div></div><p>The Linux kernel is a monolithic<a id="id215" class="indexterm"/> kernel and as such shares the same address space. Although it has the ability to load modules at runtime, the kernel must contain all the symbols the module uses at compilation time. Once the module is loaded, it will share the kernel's address space.</p><p>The kernel build system, or <a id="id216" class="indexterm"/>
<span class="strong"><strong>kbuild</strong></span>, uses conditional compilation to decide which parts of the kernel are compiled. The kernel build system is independent of the Yocto build system.</p><p>In this recipe, we will explain how the kernel's build system works.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec77"/>How to do it...</h2></div></div></div><p>The kernel configuration is stored in a <code class="literal">.config</code> text file in the kernel root directory. The kbuild system reads this configuration to build the kernel. The <code class="literal">.config</code> file is referred to as the kernel configuration file. There are multiple ways to define a kernel configuration file:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Manually editing the <code class="literal">.config</code> file, although this is not recommended.</li><li class="listitem" style="list-style-type: disc">Using one of the user interfaces the kernel offers (type the make help command for other options):<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">menuconfig</code>: An ncurses menu-based interface (<code class="literal">make menuconfig</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">xconfig</code>: A Qt-based interface (<code class="literal">make xconfig</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">gconfig</code>: A GTK-based interface (<code class="literal">make gconfig</code>)</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Note that to build and use these interfaces, your Linux host needs to have the appropriate dependencies.</p></div></div></li><li class="listitem" style="list-style-type: disc">Automatically via a build system such as Yocto.</li></ul></div><p>Each machine also defines a default configuration in the kernel tree. For ARM platforms, these are stored in the <code class="literal">arch/arm/configs</code> directory. To configure an ARM kernel, that is, to produce a <code class="literal">.config</code> file from a default configuration, you run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make ARCH=arm &lt;platform&gt;_defconfig</strong></span>
</pre></div><p>For example we can build a default configuration for Freescale i.MX6 processors by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make ARCH=arm imx_v6_v7_defconfig</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec78"/>How it works...</h2></div></div></div><p>Kbuild uses <a id="id217" class="indexterm"/>
<code class="literal">Makefile</code> and <code class="literal">Kconfig</code> files to build the kernel source. Kconfig files define configuration symbols and attributes, and <code class="literal">Makefile</code> file match configuration symbols to source files.</p><p>The kbuild system options and targets can be seen by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make ARCH=arm help</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec79"/>There's more...</h2></div></div></div><p>In recent kernels, a default configuration contains all the information needed to expand to a full configuration file. It is a minimal kernel configuration file where all dependencies are removed. To create a default configuration file from a current <code class="literal">.config</code> file, you run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make ARCH=arm savedefconfig</strong></span>
</pre></div><p>This creates a <code class="literal">defconfig</code> file in the current kernel directory. This <code class="literal">make</code> target can be seen as the opposite of the <code class="literal">&lt;platform&gt;_defconfig</code> target explained before. The former creates a configuration file from a minimal configuration, and the other expands the minimal configuration into a full configuration file.</p></div></div>
<div class="section" title="Configuring the Linux kernel"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Configuring the Linux kernel</h1></div></div></div><p>In this recipe, we will explain how to<a id="id218" class="indexterm"/> configure a Linux kernel using the Yocto build system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec80"/>Getting ready</h2></div></div></div><p>Before configuring the kernel, we need to provide a default configuration for our machine, which is the one the Yocto project uses to configure a kernel. When defining a new machine in your BSP layer, you need to provide a <code class="literal">defconfig</code> file.</p><p>The Wandboard's <code class="literal">defconfig</code> file is stored under <code class="literal">sources/meta-fsl-arm-extra/recipes-kernel/linux/linux-wandboard-3.10.17/defconfig</code>.</p><p>This would be the base <code class="literal">defconfig</code> file for our custom hardware, so we copy it to our BSP layer:</p><div class="informalexample"><pre class="programlisting">$ cd /opt/yocto/fsl-community-bsp/sources
$ mkdir -p meta-bsp-custom/recipes-kernel/linux/linux-wandboard- 3.10.17/
$ cp meta-fsl-arm-extra/recipes-kernel/linux/linux-wandboard- 3.10.17/defconfig meta-bsp-custom/recipes-kernel/linux/linux- wandboard-3.10.17/</pre></div><p>We then add it to our kernel using <code class="literal">meta-bsp-custom/recipes-kernel/linux/linux-wandboard_3.10.17.bbappend</code> as follows:</p><div class="informalexample"><pre class="programlisting"># Copyright Packt Publishing 2015
FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}-${PV}:"
SRC_URI_append = " file://defconfig"</pre></div><p>Kernel configuration changes to your platform can be made directly in this <code class="literal">defconfig</code> file.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec81"/>How to do it...</h2></div></div></div><p>To create a <code class="literal">.config</code> file <a id="id219" class="indexterm"/>from the machine <code class="literal">defconfig</code> file, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c configure virtual/kernel</strong></span>
</pre></div><p>This will also run the oldconfig kernel <code class="literal">make</code> target to validate the configuration against the Linux source.</p><p>We can then configure the Linux kernel from the BitBake command line using the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c menuconfig virtual/kernel</strong></span>
</pre></div><p>The menuconfig user interface, as well as other kernel configuration user interfaces, has a search functionality that allows you to locate configuration variables by name. Have a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/5186OS_02_01.jpg" alt="How to do it..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>In the following chapters, we will mention specific kernel configuration variables, like <code class="literal">CONFIG_PRINTK</code>, without specifying the whole path to the configuration variable. The search interface of the different UIs can be used to locate the configuration variable path.</p></div></div><p>When you <a id="id220" class="indexterm"/>save your changes, a new <code class="literal">.config</code> file is created on the kernel's <code class="literal">build</code> directory, which you can find using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -e virtual/kernel | grep ^B=</strong></span>
</pre></div><p>You can also modify the configuration using a graphical UI, but not from the BitBake command line. This is because graphical UIs need host dependencies, which are not natively built by Yocto.</p><p>To make sure your Ubuntu system has the needed dependencies, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install git-core libncurses5 libncurses5-dev libelf- dev asciidoc binutils-dev qt3-dev-tools libqt3-mt-dev libncurses5 libncurses5-dev fakeroot build-essential crash kexec-tools makedumpfile libgtk2.0-dev libglib2.0-dev libglade2-dev</strong></span>
</pre></div><p>Then change to the kernel <code class="literal">build</code> directory, which you found before, with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/wandboard- quad/tmp/work/wandboard_quad-poky-linux-gnueabi/linux- wandboard/3.10.17-r0/git</strong></span>
</pre></div><p>Next, run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make ARCH=arm xconfig</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>If you encounter compilation errors, attempt to run from a new terminal that has not had the environment configured with the <code class="literal">setup-environment</code> script.</p></div></div><p>A new window will open with the graphical configuration user interface shown in the next screenshot:</p><div class="mediaobject"><img src="graphics/5186OS_02_02.jpg" alt="How to do it..."/></div><p>When you save your<a id="id221" class="indexterm"/> changes, the <code class="literal">.config</code> file will be updated.</p><p>To use an updated configuration, you need to take care that BitBake does not revert your changes when building. Refer to the <span class="emphasis"><em>Building the Linux kernel</em></span> recipe in this chapter for additional details.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec82"/>There's more...</h2></div></div></div><p>You can make your kernel changes permanent with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a default configuration from your <code class="literal">.config</code> file from the kernel source directory and a clean environment (not configured with the <code class="literal">setup-environment</code> script) by running:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make ARCH=arm savedefconfig</strong></span>
</pre></div></li><li class="listitem">Copy the <code class="literal">defconfig</code> file from your kernel <code class="literal">build</code> folder to your kernel recipe's <code class="literal">defconfig</code> file as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cp defconfig /opt/yocto/fsl-community-bsp/sources/meta-bsp- custom/recipes-kernel/linux/linux-wandboard-3.10.17</strong></span>
</pre></div></li></ol></div><p>Alternatively, you <a id="id222" class="indexterm"/>may use BitBake from the <code class="literal">build</code> directory as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake -c savedefconfig virtual/kernel</strong></span>
</pre></div><p>This also creates a <code class="literal">defconfig</code> file in the Linux kernel's source directory, which needs to be copied to your recipe.</p><div class="section" title="Using configuration fragments"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec26"/>Using configuration fragments</h3></div></div></div><p>The <code class="literal">linux-yocto</code> style <a id="id223" class="indexterm"/>kernels can also apply isolated kernel configuration changes defined in the kernel configuration fragments; for example:</p><div class="informalexample"><pre class="programlisting">spidev.cfg:
  CONFIG_SPI_SPIDEV=y</pre></div><p>Kernel configuration fragments are appended to <code class="literal">SRC_URI</code> in the same way, and are applied over the <code class="literal">defconfig</code> file.</p><p>The <code class="literal">linux-yocto</code> style kernels (not the one for the Wandboard though) also provide a set of tools to manage kernel configuration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To configure the kernel from the <code class="literal">defconfig</code> file and the supplied configuration fragments, execute:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -f -c kernel_configme linux-yocto</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">To create a configuration fragment with your changes, execute:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c diffconfig linux-yocto</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">To validate the kernel configuration, you may run:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -f -c kernel_configcheck linux-yocto</strong></span>
</pre></div></li></ul></div></div></div></div>
<div class="section" title="Building the Linux kernel"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Building the Linux kernel</h1></div></div></div><p>In this recipe, we will go<a id="id224" class="indexterm"/> through the development workflows described earlier using the Linux kernel as an example.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec83"/>How to do it...</h2></div></div></div><p>We will see how the following development workflows are applied to the Linux kernel:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">External development</li><li class="listitem" style="list-style-type: disc">Working directory development</li><li class="listitem" style="list-style-type: disc">External source development</li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec84"/>How it works...</h2></div></div></div><p>Let's explain the three methodologies listed previously in detail.</p><div class="section" title="External development"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec27"/>External development</h3></div></div></div><p>When compiling outside of the <a id="id225" class="indexterm"/>Yocto build environment, we can still use the Yocto-provided toolchain to build. The process is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will use the Yocto project cross-compilation toolchain already installed in your host.</li><li class="listitem">Clone the <code class="literal">wandboard-org linux-wandboard</code> repository locally:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto</strong></span>
<span class="strong"><strong>$ git clone https://github.com/wandboard-org/linux.git linux-wandboard</strong></span>
<span class="strong"><strong>$ cd linux-wandboard</strong></span>
</pre></div></li><li class="listitem">Go to the branch specified in the <code class="literal">linux-wandboard_3.10.17.bb</code> recipe:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git checkout -b wandboard_imx_3.10.17_1.0.2_ga origin/wandboard_imx_3.10.17_1.0.2_ga</strong></span>
</pre></div></li><li class="listitem">Compile the kernel source as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Prepare the environment as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source /opt/poky/1.7.1/environment-setup-armv7a-vfp-neon- poky-linux-gnueabi</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Configure the kernel with the default machine configuration:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cp /opt/yocto/fsl-community-bsp/sources/meta-bsp-custom/recipes-kernel/linux/linux-wandboard-3.10.17/defconfig arch/arm/configs/wandboard-quad_defconfig</strong></span>
<span class="strong"><strong>$ make wandboard-quad_defconfig</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Compile the kernel image, modules, and the device tree file with:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make</strong></span>
</pre></div><p>You can optionally pass a <code class="literal">-jN</code> argument to make to build multithreaded.</p><p>This will build the kernel's zImage, modules, and device tree files.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Older Yocto environment setup scripts set the <code class="literal">LD</code> variable to use <code class="literal">gcc</code>, but the Linux kernel uses <code class="literal">ld</code> instead. If your compilation is failing, try the following before running <code class="literal">make</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ unset LDFLAGS</strong></span>
</pre></div></div></div><p>To build only modules, you may run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make modules</strong></span>
</pre></div><p>And to build only device tree files, you may run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make dtbs</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Copy the kernel image and device tree file to the TFTP root to test using network booting:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cp arch/arm/boot/zImage arch/arm/boot/dts/imx6q- wandboard.dtb /var/lib/tftpboot</strong></span>
<span class="strong"><strong>$ make LOADADDR=0x10800000 uImage</strong></span>
UBOOT_ENTRYPOINT_mx6  = "0x10008000"</pre></div></li></ul></div><p>Some <a id="id226" class="indexterm"/>other embedded Linux targets might need to compile a uImage if the U-Boot bootloader is not compiled with zImage booting support:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ make LOADADDR=0x10800000 uImage</strong></span></pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>The <code class="literal">mkimage</code> tool<a id="id227" class="indexterm"/> is part of the Yocto toolchain when built with the FSL community BSP. We will see how to build and install an SDK in the <span class="emphasis"><em>Preparing and using an SDK</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Application Development">Chapter 4</a>, <span class="emphasis"><em>Application Development</em></span>.</p><p>If it is not included in your toolchain, you can install the tool in your host using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install u-boot-tools</strong></span>
</pre></div></div></div><p><code class="literal">LOADADDR</code> is the U-Boot entry point; that is, the address where U-Boot will place the kernel in memory. It is defined in the <code class="literal">meta-fsl-arm imx-base.inc</code> file:</p><div class="informalexample"><pre class="programlisting">
UBOOT_ENTRYPOINT_mx6 = "0x10008000"
</pre></div></li></ol></div></div><div class="section" title="External source development"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec28"/>External source development</h3></div></div></div><p>As we did with U-Boot before, we will use <a id="id228" class="indexterm"/>the Yocto build system, pointing it to a local directory with a clone of the Linux source repository. We will use the local Git repository cloned in the earlier section.</p><p>We configure for external development in our <code class="literal">conf/local.conf</code> file using the following code:</p><div class="informalexample"><pre class="programlisting">INHERIT += "externalsrc"
EXTERNALSRC_pn-linux-wandboard = "/opt/yocto/linux-wandboard"
EXTERNALSRC_BUILD_pn-linux-wandboard = "/opt/yocto/linux- wandboard"</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>Remember to remove this configuration when using the working directory development methodology explained next in this recipe.</p></div></div><p>But, just as before, the compilation fails with U-Boot. In this case, the linux-wandboard recipe, not being a <code class="literal">linux-yocto</code> style recipe, is not prepared for external source compilation and it fails in the configuration task.</p><p>Kernel developers prefer to compile the kernel externally as we saw earlier, so this scenario is not likely to be fixed soon.</p></div><div class="section" title="Working directory development"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec29"/>Working directory development</h3></div></div></div><p>Typically we work with patches and <a id="id229" class="indexterm"/>use this development workflow when we have a small amount of changes or we don't own the source repository.</p><p>A typical workflow when working on a modification would be:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start the kernel package compilation from scratch:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake -c cleanall virtual/kernel</strong></span>
</pre></div><p>This will erase the <code class="literal">build</code> folder, shared state cache, and downloaded package source.</p></li><li class="listitem">Configure the kernel as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c configure virtual/kernel</strong></span>
</pre></div><p>This will convert the machine <code class="literal">defconfig</code> file into a <code class="literal">.config</code> file and call <code class="literal">oldconfig</code> to validate the configuration with the kernel source.</p><p>You can optionally add your own configuration changes with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c menuconfig virtual/kernel</strong></span>
</pre></div></li><li class="listitem">Start a development shell on the kernel:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c devshell virtual/kernel</strong></span>
</pre></div><p>This will fetch, unpack, and patch the kernel sources and spawn a new shell with the environment ready for kernel compilation. The new shell will change to the kernel <code class="literal">build</code> directory which contains a local Git repository.</p></li><li class="listitem">Perform our modifications, including kernel configuration changes.</li><li class="listitem">Leave the devshell open and go back to the terminal with the sourced Yocto environment to compile the source without erasing our modifications as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -C compile virtual/kernel</strong></span>
</pre></div><p>Note the capital <code class="literal">C</code>. This invokes the compile task but also all the tasks that follow it.</p><p>The newly compiled kernel image is available under <code class="literal">tmp/deploy/images/wandboard-quad</code>.</p></li><li class="listitem">Test your<a id="id230" class="indexterm"/> changes. Typically, we would work from a network-booted system, so we would copy the kernel image and the device tree file to the TFTP server root and boot the target with them using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tmp/deploy/images/wandboard-quad/</strong></span>
<span class="strong"><strong>$ cp zImage-wandboard-quad.bin zImage-imx6q-wandboard.dtb /var/lib/tftpboot</strong></span>
</pre></div><p>Refer to the <span class="emphasis"><em>Configuring network booting for a development setup</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. The Build System">Chapter 1</a>, <span class="emphasis"><em>The Build System</em></span> for details.</p><p>Alternatively, the U-Boot bootloader can boot a Linux zImage kernel from memory with its corresponding device tree using the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; bootz &lt;kernel_addr&gt; - &lt;dtb_addr&gt;</strong></span>
</pre></div><p>For example, we can fetch images from TFTP and boot the Wandboard images as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; tftp ${loadaddr} ${image}</strong></span>
<span class="strong"><strong>&gt; tftp ${fdt_addr} ${fdt_file}</strong></span>
<span class="strong"><strong>&gt; bootz ${loadaddr} - ${fdt_addr}</strong></span>
</pre></div><p>If we were using an initramdisk, we would pass it as the second argument. Since we aren't, we use a dash instead.</p><p>The command to boot a uImage Linux kernel image from memory would use <code class="literal">bootm</code> instead, as in:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; bootm &lt;kernel_addr&gt; - &lt;dtb_addr&gt;</strong></span>
</pre></div></li><li class="listitem">Go back to the devshell and commit your change to the local Git repository:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git add --all .</strong></span>
<span class="strong"><strong>$ git commit -s -m "Well thought commit message"</strong></span>
</pre></div></li><li class="listitem">Generate <a id="id231" class="indexterm"/>a patch into the kernel recipe patch directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git format-patch -1 -o /opt/yocto/fsl-community- bsp/sources/meta-bsp-custom/recipes-kernel/linux/linux- wandboard-3.10.17</strong></span>
</pre></div></li><li class="listitem">Finally, add the patch to the kernel recipe as previously described.</li></ol></div></div></div></div>
<div class="section" title="Building external kernel modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec34"/>Building external kernel modules</h1></div></div></div><p>The Linux kernel has the <a id="id232" class="indexterm"/>ability to load modules at runtime that extend the kernel functionality. Kernel modules share the kernel's address space and have to be linked against the kernel they are going to be loaded onto. Most device drivers in the Linux kernel can either be compiled into the kernel itself (built-in) or as loadable kernel modules that need to be placed in the root filesystem under the <code class="literal">/lib/modules</code> directory.</p><p>The recommended approach to develop and distribute a kernel module is to do it with the kernel source. A module in the kernel tree uses the kernel's kbuild system to build itself, so as long as it is selected as module in the kernel configuration and the kernel has module support enabled, Yocto will build it.</p><p>However, it is not always possible to develop a module in the kernel. Common examples are hardware manufacturers who provide Linux drivers for a wide variety of kernel versions and have an internal development process separated from the kernel community. The internal development work is usually released first as an external out-of-tree module, although it is common for some or all of these internal developments to finish up in the mainstream kernel eventually. However, upstreaming is a slow process and hardware companies will therefore prefer to develop internally first.</p><p>It's worth remembering that the Linux kernel is covered under a GPLv2 license, so Linux kernel modules should be released with a compatible license. We will cover licenses in more detail in the following chapters.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec85"/>Getting ready</h2></div></div></div><p>To compile an external <a id="id233" class="indexterm"/>kernel module with Yocto, we first need to know how we would link the module source with the kernel itself. An external kernel module is also built using the kbuild system of the Linux kernel it is going to be linked against, so the first thing we need is a <code class="literal">Makefile</code>:</p><div class="informalexample"><pre class="programlisting">obj-m:= hello_world.o

SRC := $(shell pwd)
all:
        $(MAKE) -C $(KERNEL_SRC) M=$(SRC)

modules_install:
        $(MAKE) -C $(KERNEL_SRC) M=$(SRC) modules_install

clean:
        rm -f *.o *~ core .depend .*.cmd *.ko *.mod.c
        rm -f Module.markers Module.symvers modules.order
        rm -rf .tmp_versions Modules.symvers</pre></div><p>The <code class="literal">Makefile</code> file just wraps the <code class="literal">make</code> command used to compile a module on a Linux system:</p><div class="informalexample"><pre class="programlisting">make -C $(KERNEL_SRC) M=$(SRC)</pre></div><p>Here, <code class="literal">make</code> is instructed to build in the location of the kernel source, and the <code class="literal">M</code> argument tells kbuild it is building a module at the specified location.</p><p>And then we code the source of the module itself (<code class="literal">hello_world.c</code>):</p><div class="informalexample"><pre class="programlisting">/ *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &lt;linux/module.h&gt;

static int hello_world_init(void)
{
        printk("Hello world\n");
        return 0;
}

static void hello_world_exit(void)
{
        printk("Bye world\n");
}
module_init(hello_world_init);
module_exit(hello_world_exit);

MODULE_LICENSE("GPL v2");</pre></div><p>It's worth <a id="id234" class="indexterm"/>remembering that we need to compile against a kernel source that has already been built. Use the following steps for compilation:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We prepare the environment using the Yocto toolchain environment setup script:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source /opt/poky/1.7.1/environment-setup-armv7a-vfp-neon- poky-linux-gnueabi</strong></span>
</pre></div></li><li class="listitem">Next we build the module. We execute the following from the module source directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ KERNEL_SRC=/opt/yocto/linux-wandboard make</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec86"/>How to do it...</h2></div></div></div><p>Once we know how to compile the module externally, we are ready to prepare a Linux kernel module Yocto recipe for it.</p><p>We place the module source file and <code class="literal">Makefile</code> in <code class="literal">recipes-kernel/hello-world/files/</code> inside our <code class="literal">meta-bsp-custom</code> layer. We then create a <code class="literal">recipes-kernel/hello-world/hello-world.bb</code> file with the following content:</p><div class="informalexample"><pre class="programlisting"># Copyright (C) 2015 Packt Publishing.

SUMMARY = "Simplest hello world kernel module."
LICENSE = "GPLv2"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/GPL- 2.0;md5=801f80980d171dd6425610833a22dbe6"

inherit module

SRC_URI = " \
    file://hello_world.c \
    file://Makefile \
"

S = "${WORKDIR}"

COMPATIBLE_MACHINE = "(wandboard)"</pre></div><p>The <a id="id235" class="indexterm"/>recipe defines the source directory and the two module files after inheriting the <code class="literal">module</code> class, which takes care of everything. The <code class="literal">KERNEL_SRC</code> argument in our <code class="literal">Makefile</code> is set by the module class to <code class="literal">STAGING_KERNEL_DIR</code>, the location where the kernel class places the Linux kernel headers needed for external module compilation.</p><p>We build it with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake hello-world</strong></span>
</pre></div><p>The resulting module is called <code class="literal">hello_world.ko</code>, with the <code class="literal">kernel-module</code> prefix being added to the package name by the module <code class="literal">bbclass</code> automatically.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec87"/>There's more...</h2></div></div></div><p>The previous instructions will build the module but will not install it in the root filesystem. For that, we need to add a dependency to the root filesystem. This is usually done in machine configuration files using <code class="literal">MACHINE_ESSENTIAL</code> (for modules that are needed to boot) or <code class="literal">MACHINE_EXTRA</code> (if they are not essential for boot but needed otherwise), variables.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The dependencies that are essential to boot are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MACHINE_ESSENTIAL_EXTRA_RDEPENDS</code>: The build will fail if they can't be found</li><li class="listitem" style="list-style-type: disc"><code class="literal">MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS</code>: The build will not fail if they can't be found</li></ul></div></li><li class="listitem" style="list-style-type: disc">The dependencies <a id="id236" class="indexterm"/>that are not essential to boot are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MACHINE_EXTRA_RDEPENDS</code>: The build will fail if they can't be found</li><li class="listitem" style="list-style-type: disc"><code class="literal">MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS</code>: The build will not fail if they can't be found</li></ul></div></li></ul></div></div></div>
<div class="section" title="Debugging the Linux kernel and modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec35"/>Debugging the Linux kernel and modules</h1></div></div></div><p>We will highlight some of the most common methods employed by kernel developers to debug kernel issues.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec88"/>How to do it...</h2></div></div></div><p>Above all, debugging the Linux kernel remains a manual process, and the most important developer tool is the ability to print debug messages.</p><p>The kernel uses the <code class="literal">printk</code> function, which is very similar syntactically to the <code class="literal">printf</code> function call from standard C libraries, with the addition of an optional log level. The allowed formats are documented in the kernel source under <code class="literal">Documentation/printk-formats.txt</code>.</p><p>The <code class="literal">printk</code> functionality needs to be compiled into the kernel with the <code class="literal">CONFIG_PRINTK</code> configuration variable. You can also configure the Linux kernel to prepend a precise timestamp to every message with the <code class="literal">CONFIG_PRINTK_TIME</code> configuration variable, or even better, with the <code class="literal">printk.time</code> kernel command-line argument or through sysfs under <code class="literal">/sys/module/printk/parameters</code>. Usually all kernels contain <code class="literal">printk</code> support, and the Wandboard kernel does too, although it is commonly removed on production kernels for small embedded systems.</p><p>The <code class="literal">printk</code> function can be used in any context, interrupt, <span class="strong"><strong>non-maskable interrupt</strong></span> (<span class="strong"><strong>NMI</strong></span>), or <a id="id237" class="indexterm"/>scheduler. Note that using it inside interrupt context is not recommended.</p><p>A useful debug statement to be used during development could be:</p><div class="informalexample"><pre class="programlisting">printk(KERN_INFO "[%s:%d] %pf -&gt; var1: %d var2: %d\n", __FUNCTION__, __LINE__, __builtin_return_address(0), var1, var2);</pre></div><p>The first thing to note is that there is no comma between the log level macro and the print format. We then print the function and line where the debug statement is placed and then the parent function. Finally, we print the variables we are actually interested in.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec89"/>How it works...</h2></div></div></div><p>The available log levels in <code class="literal">printk</code> are presented in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Symbol</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Emergency</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_EMERG</code></p>
</td><td style="text-align: left" valign="top">
<p>System is unstable and about to crash</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Alert</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_ALERT</code></p>
</td><td style="text-align: left" valign="top">
<p>Immediate action is needed</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Critical</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_CRIT</code></p>
</td><td style="text-align: left" valign="top">
<p>Critical software or hardware failure</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Error</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_ERR</code></p>
</td><td style="text-align: left" valign="top">
<p>Error condition</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Warning</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_WARNING</code></p>
</td><td style="text-align: left" valign="top">
<p>Nothing serious, but might indicate a problem</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Notice</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_NOTICE</code></p>
</td><td style="text-align: left" valign="top">
<p>Nothing serious, but user should take note</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Information</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_INFO</code></p>
</td><td style="text-align: left" valign="top">
<p>System information</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Debug</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_DEBUG</code></p>
</td><td style="text-align: left" valign="top">
<p>Debug messages</p>
</td></tr></tbody></table></div><p>If no log level is specified, the default log message as configured in the kernel configuration is used. By default, this is <code class="literal">KERN_WARNING</code>.</p><p>All <code class="literal">printk</code> statements<a id="id238" class="indexterm"/> go to the kernel log buffer, which may wrap around, except <a id="id239" class="indexterm"/>debug statements, which only appear if the <code class="literal">DEBUG</code> symbol is defined. We will see how to enable kernel debug messages soon. The <code class="literal">printk</code> log buffer must be a power of two, and its size should be set in the <code class="literal">CONFIG_LOG_BUF_SHIFT</code> kernel configuration variable. You may modify it with the <code class="literal">log_buf_len</code> kernel command-line parameter.</p><p>We print the kernel log buffer with the <code class="literal">dmesg</code> command. Also, a Yocto user space will have a kernel log daemon running that will log kernel messages to disk under <code class="literal">/var/log/messages</code>.</p><p>Messages above the current console log level will also appear on the console immediately. The <code class="literal">ignore_loglevel</code> kernel command-line argument, also available under <code class="literal">/sys/module/printk/parameters</code>, may be used to print all kernel messages to the console independently of the log level.</p><p>You can also change the log <a id="id240" class="indexterm"/>level at runtime via the <code class="literal">proc</code> filesystem. The <code class="literal">/proc/sys/kernel/printk</code> file contains the current, default, minimum, and<a id="id241" class="indexterm"/> boot time default log levels. To change the current log level to the maximum, execute:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo 8 &gt; /proc/sys/kernel/printk</strong></span>
</pre></div><p>You can also set the console log level with the <code class="literal">dmesg</code> tool as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ dmesg -n 8</strong></span>
</pre></div><p>To make the change persistent, you can pass a log level command-line parameter to the kernel, or on some Yocto root filesystem images, you could also use a <code class="literal">/etc/sysctl.conf</code> file (those that install the <code class="literal">procps</code> package).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec90"/>There's more...</h2></div></div></div><p>Linux drivers do not use the <code class="literal">printk</code> function directly. They use, in order of preference, subsystem-specific messages (such as <code class="literal">netdev</code> or <code class="literal">v4l)</code> or the <code class="literal">dev_*</code> and <code class="literal">pr_*</code> family of functions. The latter are described in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Device message</p>
</th><th style="text-align: left" valign="bottom">
<p>Generic message</p>
</th><th style="text-align: left" valign="bottom">
<p>Printk symbol</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">dev_emerg</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">pr_emerg</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_EMERG</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dev_alert</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">pr_alert</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_ALERT</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dev_crit</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">pr_crit</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_CRIT</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dev_err</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">pr_err</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_ERR</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dev_warn</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">pr_warn</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_WARNING</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dev_notice</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">pr_notice</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_NOTICE</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dev_info</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">pr_info</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_INFO</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dev_dbg</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">pr_debug</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KERN_DEBUG</code></p>
</td></tr></tbody></table></div><p>To enable the debug messages within a driver, you may do either of these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Define <code class="literal">DEBUG</code> in a macro before any other header file in your driver source, as follows:<div class="informalexample"><pre class="programlisting">#define DEBUG</pre></div></li><li class="listitem" style="list-style-type: disc">Use the dynamic debug kernel feature. You can then enable/disable all <code class="literal">dev_dbg</code> and <code class="literal">pr_debug</code> debug messages with granularity through <code class="literal">debugfs</code>.</li></ul></div><div class="section" title="Using dynamic debug"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec30"/>Using dynamic debug</h3></div></div></div><p>To use the dynamic debug<a id="id242" class="indexterm"/> functionality in the Linux kernel, follow <a id="id243" class="indexterm"/>these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Make sure your kernel is compiled with dynamic debugging (<code class="literal">CONFIG_DYNAMIC_DEBUG</code>).</li><li class="listitem">Mount the debug filesystem if it hasn't already been mounted:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mount -t debugfs nodev /sys/kernel/debug</strong></span>
</pre></div></li><li class="listitem">Configure the debug though the <code class="literal">dynamic_debug/control</code> folder. It accepts a whitespace-separated sequence of words:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func &lt;function name&gt;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">file &lt;filename&gt;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">module &lt;module name&gt;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">format &lt;pattern&gt;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">line &lt;line or line range&gt;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">+ &lt;flag&gt;</code>: This adds the specified flag</li><li class="listitem" style="list-style-type: disc"><code class="literal">- &lt;flag&gt;</code>: This one removes the specified flag</li><li class="listitem" style="list-style-type: disc"><code class="literal">= &lt;flag&gt;</code>: This sets the specified flag</li></ul></div><p>The flags are defined as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">f</code>: This flag includes the function name in the message</li><li class="listitem" style="list-style-type: disc"><code class="literal">l</code>: This flag includes the line number in the message</li><li class="listitem" style="list-style-type: disc"><code class="literal">m</code>: This flag includes the module name in the message</li><li class="listitem" style="list-style-type: disc"><code class="literal">p</code>: This flag enables the debug message</li><li class="listitem" style="list-style-type: disc"><code class="literal">t</code>: This flag includes the thread ID in non-interrupt context messages</li></ul></div></li><li class="listitem">By default all debug messages are disabled. The control file contains all the available debug points, and by default they have no flags enabled (marked as <code class="literal">=</code>_).</li><li class="listitem">Now we will enable the debug as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enable all debug statements in a file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>echo -n 'file &lt;filename&gt; +p' &gt; /sys/kernel/debug/dynamic_debug/control</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Optionally, you could run a specific debug statement:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo -n 'file &lt;filename&gt; line nnnn +p' &gt; /sys/kernel/debug/dynamic_debug/control</strong></span>
</pre></div></li></ul></div></li><li class="listitem">To list <a id="id244" class="indexterm"/>all enabled debug statements, we use<a id="id245" class="indexterm"/> the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ awk '$3 != "=_"' /sys/kernel/debug/dynamic_debug/control</strong></span>
</pre></div></li></ol></div><p>To make the debug changes persistent, we can pass <code class="literal">dyndbg="&lt;query&gt;"</code> or <code class="literal">module.dyndbg="&lt;query&gt;"</code> to the kernel in the command-line arguments.</p><p>Note that the query string needs to be passed surrounded by quotes so that it is correctly parsed. You can concatenate more than one query in the command-line argument by using a semicolon to separate them; for example, <code class="literal">dyndbg="file mxc_v4l2_capture.c +pfl; file ipu_bg_overlay_sdc.c +pfl"</code></p></div><div class="section" title="Rate-limiting debug messages"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec31"/>Rate-limiting debug messages</h3></div></div></div><p>There are rate-limiting and<a id="id246" class="indexterm"/> one-shot extensions to the <code class="literal">dev_*</code>, <code class="literal">pr_*</code>, and <code class="literal">printk</code> family of functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">printk_ratelimited()</code>, <code class="literal">pr_*_ratelimited()</code>, and <code class="literal">dev_*_ratelimited()</code> print no more than 10 times in a 5 * HZ interval</li><li class="listitem" style="list-style-type: disc"><code class="literal">printk_once()</code>, <code class="literal">pr_*_once()</code>, and <code class="literal">dev_*_once()</code> will print only once.</li></ul></div><p>And you also have utility functions to dump a buffer in hexadecimal; for example, <code class="literal">print_hex_dump_bytes()</code>.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec91"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The dynamic debug is documented in the Linux kernel source under <code class="literal">Documentation/dynamic-debug-howto.txt</code></li></ul></div></div></div>
<div class="section" title="Debugging the Linux kernel booting process"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec36"/>Debugging the Linux kernel booting process</h1></div></div></div><p>We have seen the most general<a id="id247" class="indexterm"/> techniques for debugging the Linux kernel. However, some special scenarios require the use of different methods. One of the most common scenarios in embedded Linux development is the debugging of the booting process. This recipe will explain some of the techniques used to debug the kernel's booting process.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec92"/>How to do it...</h2></div></div></div><p>A kernel crashing on boot usually provides no output whatsoever on the console. As daunting as that may seem, there are techniques we can use to extract debug information. Early crashes usually happen before the serial console has been initialized, so even if there were log messages, we would not see them. The first thing we will show is how to enable early log messages that do not need the serial driver.</p><p>In case that is not enough, we will also show techniques to access the log buffer in memory.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec93"/>How it works...</h2></div></div></div><p>Debugging booting problems have two distinctive phases, before and after the serial console is initialized. After the serial is initialized and we can see serial output from the kernel, debugging can use the techniques described earlier.</p><p>Before the serial is initialized, however, there is a basic <span class="strong"><strong>UART</strong></span> support<a id="id248" class="indexterm"/> in ARM kernels that allows you to use the serial from early boot. This support is compiled in with the <code class="literal">CONFIG_DEBUG_LL</code> configuration variable.</p><p>This adds supports<a id="id249" class="indexterm"/> for a debug-only series of assembly functions that allow you to output data to a UART. The low-level support is platform specific, and for the i.MX6, it can be found under <code class="literal">arch/arm/include/debug/imx.S</code>. The code allows for this low-level UART to be configured through the <code class="literal">CONFIG_DEBUG_IMX_UART_PORT</code> configuration variable.</p><p>We can use this support directly by using the <code class="literal">printascii</code> function as follows:</p><div class="informalexample"><pre class="programlisting">extern void printascii(const char *);
printascii("Literal string\n");</pre></div><p>However, much more preferred would be to use the <code class="literal">early_print</code> function, which makes use of the function explained previously and accepts formatted input in <code class="literal">printf</code> style; for example:</p><div class="informalexample"><pre class="programlisting">early_print("%08x\t%s\n", p-&gt;nr, p-&gt;name);</pre></div><div class="section" title="Dumping the kernel's printk buffer from the bootloader"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec32"/>Dumping the kernel's printk buffer from the bootloader</h3></div></div></div><p>Another useful technique to<a id="id250" class="indexterm"/> debug Linux kernel crashes at <a id="id251" class="indexterm"/>boot is to analyze the kernel log after the crash. This is only possible if the RAM memory is persistent across reboots and does not get initialized by the bootloader.</p><p>As U-Boot keeps the memory intact, we can use this method to peek at the kernel login memory in search of clues.</p><p>Looking at the kernel source, we can see how the log ring buffer is set up in <code class="literal">kernel/printk/printk.c</code> and also note that it is stored in <code class="literal">__log_buf</code>.</p><p>To find the location of the kernel buffer, we will use the <code class="literal">System.map</code> file created by the Linux build process, which maps symbols with virtual addresses using the following command:</p><div class="informalexample"><pre class="programlisting">$grep __log_buf System.map
80f450c0 b __log_buf</pre></div><p>To convert the virtual address to physical address, we look at how <code class="literal">__virt_to_phys()</code> is defined for ARM:</p><div class="informalexample"><pre class="programlisting">x - PAGE_OFFSET + PHYS_OFFSET</pre></div><p>The <code class="literal">PAGE_OFFSET</code> variable<a id="id252" class="indexterm"/> is defined in the kernel <a id="id253" class="indexterm"/>configuration as: </p><div class="informalexample"><pre class="programlisting">config PAGE_OFFSET
        hex
        default 0x40000000 if VMSPLIT_1G
        default 0x80000000 if VMSPLIT_2G
        default 0xC0000000</pre></div><p>Some of the ARM platforms, like the i.MX6, will dynamically patch the <code class="literal">__virt_to_phys()</code> translation at runtime, so <code class="literal">PHYS_OFFSET</code> will depend on where the kernel is loaded into memory. As this can vary, the calculation we just saw is platform specific.</p><p>For the Wandboard, the physical address for 0x80f450c0 is 0x10f450c0.</p><p>We can then force a reboot using a magic <span class="emphasis"><em>SysRq</em></span> key, which needs to be enabled in the kernel configuration with <code class="literal">CONFIG_MAGIC_SYSRQ</code>, but is enabled in the Wandboard by default:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo b &gt; /proc/sysrq-trigger</strong></span>
</pre></div><p>We then dump that memory address from U-Boot as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; md.l 0x10f450c0</strong></span>
<span class="strong"><strong>10f450c0: 00000000 00000000 00210038 c6000000    ........8.!.....</strong></span>
<span class="strong"><strong>10f450d0: 746f6f42 20676e69 756e694c 6e6f2078    Booting Linux on</strong></span>
<span class="strong"><strong>10f450e0: 79687020 61636973 5043206c 78302055     physical CPU 0x</strong></span>
<span class="strong"><strong>10f450f0: 00000030 00000000 00000000 00000000    0...............</strong></span>
<span class="strong"><strong>10f45100: 009600a8 a6000000 756e694c 65762078    ........Linux ve</strong></span>
<span class="strong"><strong>10f45110: 6f697372 2e33206e 312e3031 2e312d37    rsion 3.10.17-1.</strong></span>
<span class="strong"><strong>10f45120: 2d322e30 646e6177 72616f62 62672b64    0.2-wandboard+gb</strong></span>
<span class="strong"><strong>10f45130: 36643865 62323738 20626535 656c6128    e8d6872b5eb (ale</strong></span>
<span class="strong"><strong>10f45140: 6f6c4078 696c2d67 2d78756e 612d7068    x@log-linux-hp-a</strong></span>
<span class="strong"><strong>10f45150: 7a6e6f67 20296c61 63636728 72657620    gonzal) (gcc ver</strong></span>
<span class="strong"><strong>10f45160: 6e6f6973 392e3420 2820312e 29434347    sion 4.9.1 (GCC)</strong></span>
<span class="strong"><strong>10f45170: 23202920 4d532031 52502050 504d4545     ) #1 SMP PREEMP</strong></span>
<span class="strong"><strong>10f45180: 75532054 6546206e 35312062 3a323120    T Sun Feb 15 12:</strong></span>
<span class="strong"><strong>10f45190: 333a3733 45432037 30322054 00003531    37:37 CET 2015..</strong></span>
<span class="strong"><strong>10f451a0: 00000000 00000000 00400050 82000000    ........P.@.....</strong></span>
<span class="strong"><strong>10f451b0: 3a555043 4d524120 50203776 65636f72    CPU: ARMv7 Proce</strong></span>
</pre></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec94"/>There's more...</h2></div></div></div><p>Another method is to store the kernel log messages and kernel panics or oops into persistent storage. The Linux kernel's persistent store support (<code class="literal">CONFIG_PSTORE</code>) allows you to log in to the persistent memory kept across reboots.</p><p>To log panic and oops messages into persistent memory, we need to configure the kernel with the <code class="literal">CONFIG_PSTORE_RAM</code> configuration variable, and to log kernel messages, we need to configure the kernel with <code class="literal">CONFIG_PSTORE_CONSOLE</code>.</p><p>We then need to configure the location of the persistent storage on an unused memory location, but keep the last 1 MB of memory free. For example, we could pass the following kernel command-line arguments to reserve a 128 KB region starting at 0x30000000:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ramoops.mem_address=0x30000000 ramoops.mem_size=0x200000</strong></span>
</pre></div><p>We would then mount the persistent storage by adding it to <code class="literal">/etc/fstab</code> so that it is available on the next boot as well:</p><div class="informalexample"><pre class="programlisting">/etc/fstab:
pstore  /pstore  pstore  defaults  0  0</pre></div><p>We then mount it as follows:</p><div class="informalexample"><pre class="programlisting"># mkdir /pstore
# mount /pstore</pre></div><p>Next, we force a reboot with the magic <span class="emphasis"><em>SysRq</em></span> key:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># echo b &gt; /proc/sysrq-trigger</strong></span>
</pre></div><p>On reboot, we will see a file inside <code class="literal">/pstore</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>-r--r--r--  1 root root 4084 Sep 16 16:24 console-ramoops</strong></span>
</pre></div><p>This will have contents such as the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SysRq : Resetting</strong></span>
<span class="strong"><strong>CPU3: stopping</strong></span>
<span class="strong"><strong>CPU: 3 PID: 0 Comm: swapper/3 Not tainted 3.14.0-rc4-1.0.0-wandboard-37774-g1eae</strong></span>
<span class="strong"><strong>[&lt;80014a30&gt;] (unwind_backtrace) from [&lt;800116cc&gt;] (show_stack+0x10/0x14)</strong></span>
<span class="strong"><strong>[&lt;800116cc&gt;] (show_stack) from [&lt;806091f4&gt;] (dump_stack+0x7c/0xbc)</strong></span>
<span class="strong"><strong>[&lt;806091f4&gt;] (dump_stack) from [&lt;80013990&gt;] (handle_IPI+0x144/0x158)</strong></span>
<span class="strong"><strong>[&lt;80013990&gt;] (handle_IPI) from [&lt;800085c4&gt;] (gic_handle_irq+0x58/0x5c)</strong></span>
<span class="strong"><strong>[&lt;800085c4&gt;] (gic_handle_irq) from [&lt;80012200&gt;] (__irq_svc+0x40/0x70)</strong></span>
<span class="strong"><strong>Exception stack(0xee4c1f50 to 0xee4c1f98)</strong></span>
</pre></div><p>We should move it out of <code class="literal">/pstore</code> or remove it completely so that it doesn't occupy memory.</p></div></div>
<div class="section" title="Using the kernel function tracing system"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec37"/>Using the kernel function tracing system</h1></div></div></div><p>Recent versions of the <a id="id254" class="indexterm"/>Linux kernel contain a set of tracers that, by instrumenting the kernel, allow you to analyze different areas like:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Interrupt latency</li><li class="listitem" style="list-style-type: disc">Preemption latency</li><li class="listitem" style="list-style-type: disc">Scheduling latency</li><li class="listitem" style="list-style-type: disc">Process context switches</li><li class="listitem" style="list-style-type: disc">Event tracing</li><li class="listitem" style="list-style-type: disc">Syscalls</li><li class="listitem" style="list-style-type: disc">Maximum stack</li><li class="listitem" style="list-style-type: disc">Block layer</li><li class="listitem" style="list-style-type: disc">Functions</li></ul></div><p>The tracers have no performance overhead when not enabled.</p><div class="section" title="Getting ready..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec95"/>Getting ready...</h2></div></div></div><p>The tracing system can be used in a wide variety of debugging scenarios, but one of the most common tracers used is the function tracer. It instruments every kernel function with a NOP call that is replaced and used to trace the kernel functions when a trace point is enabled.</p><p>To enable the function tracer in the kernel, use the <code class="literal">CONFIG_FUNCTION_TRACER</code> and <code class="literal">CONFIG_FUNCTION_GRAPH_TRACER</code> configuration variables.</p><p>The kernel tracing system is controlled via a <code class="literal">tracing</code> file in the <code class="literal">debug</code> filesystem, which is mounted by default on Yocto's default images. If not, you can mount it with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mount -t debugfs nodev /sys/kernel/debug</strong></span>
</pre></div><p>We can list the available tracers in our kernel by executing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /sys/kernel/debug/tracing/available_tracers</strong></span>
<span class="strong"><strong>function_graph function nop</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec96"/>How to do it...</h2></div></div></div><p>You can enable a tracer by echoing its name to the <code class="literal">current_tracer</code> file. No tracers are enabled by default:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /sys/kernel/debug/tracing/current_tracer</strong></span>
<span class="strong"><strong>nop</strong></span>
</pre></div><p>You can disable all tracers by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo -n nop &gt; /sys/kernel/debug/tracing/current_tracer</strong></span>
</pre></div><p>We use <code class="literal">echo -n</code> to avoid the trailing newline when echoing to files in <code class="literal">sysfs</code>.</p><p>To enable the function tracer, you would execute:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo -n function &gt; /sys/kernel/debug/tracing/current_tracer</strong></span>
</pre></div><p>A prettier graph can be obtained by using the function graph tracer as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo -n function_graph  &gt; /sys/kernel/debug/tracing/current_tracer</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec97"/>How it works...</h2></div></div></div><p>You can look at <a id="id255" class="indexterm"/>the captured trace in human-readable format via the <code class="literal">trace</code> and <code class="literal">trace_pipe</code> files, with the latter blocking on <code class="literal">read</code> and consuming the data.</p><p>The function tracer provides the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat  /sys/kernel/debug/tracing/trace_pipe</strong></span>
<span class="strong"><strong>root@wandboard-quad:~# cat /sys/kernel/debug/tracing/trace_pipe</strong></span>
<span class="strong"><strong>              sh-394   [003] ...1    46.205203: mutex_unlock &lt;- tracing_set_tracer</strong></span>
<span class="strong"><strong>              sh-394   [003] ...1    46.205215: __fsnotify_parent &lt;- </strong></span>
<span class="strong"><strong>  vfs_write</strong></span>
<span class="strong"><strong>              sh-394   [003] ...1    46.205218: fsnotify &lt;-vfs_write</strong></span>
<span class="strong"><strong>              sh-394   [003] ...1    46.205220: __srcu_read_lock &lt;- fsnotify</strong></span>
<span class="strong"><strong>              sh-394   [003] ...1    46.205223: preempt_count_add &lt;- __srcu_read_lock</strong></span>
<span class="strong"><strong>              sh-394   [003] ...2    46.205226: preempt_count_sub &lt;- __srcu_read_lock</strong></span>
<span class="strong"><strong>              sh-394   [003] ...1    46.205229: __srcu_read_unlock &lt;- fsnotify</strong></span>
<span class="strong"><strong>              sh-394   [003] ...1    46.205232: __sb_end_write &lt;- vfs_write</strong></span>
<span class="strong"><strong>              sh-394   [003] ...1    46.205235: preempt_count_add &lt;- __percpu_counter_add</strong></span>
<span class="strong"><strong>              sh-394   [003] ...2    46.205238: preempt_count_sub &lt;- __percpu_counter_add</strong></span>
<span class="strong"><strong>              sh-394   [003] d..1    46.205247: gic_handle_irq &lt;- __irq_usr</strong></span>
<span class="strong"><strong>          &lt;idle&gt;-0     [002] d..2    46.205247: ktime_get &lt;- cpuidle_enter_state</strong></span>
</pre></div><p>The format for the function tracer output is:</p><div class="informalexample"><pre class="programlisting">task-PID [cpu-nr] irqs-off need-resched hard/softirq preempt-depth delay-timestamp function</pre></div><p>The graphical function tracer output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /sys/kernel/debug/tracing/trace_pipe</strong></span>
<span class="strong"><strong> 3)   ==========&gt; |</strong></span>
<span class="strong"><strong> 3)               |  gic_handle_irq() {</strong></span>
<span class="strong"><strong> 2)   ==========&gt; |</strong></span>
<span class="strong"><strong> 2)               |  gic_handle_irq() {</strong></span>
<span class="strong"><strong> 3)   0.637 us    |    irq_find_mapping();</strong></span>
<span class="strong"><strong> 2)   0.712 us    |    irq_find_mapping();</strong></span>
<span class="strong"><strong> 3)               |    handle_IRQ() {</strong></span>
<span class="strong"><strong> 2)               |    handle_IRQ() {</strong></span>
<span class="strong"><strong> 3)               |      irq_enter() {</strong></span>
<span class="strong"><strong> 2)               |      irq_enter() {</strong></span>
<span class="strong"><strong> 3)   0.652 us    |        rcu_irq_enter();</strong></span>
<span class="strong"><strong> 2)   0.666 us    |        rcu_irq_enter();</strong></span>
<span class="strong"><strong> 3)   0.591 us    |        preempt_count_add();</strong></span>
<span class="strong"><strong> 2)   0.606 us    |        preempt_count_add();</strong></span>
</pre></div><p>The format for the grapical function tracer output is:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cpu-nr) timestamp | functions</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec98"/>There's more...</h2></div></div></div><p>The kernel<a id="id256" class="indexterm"/> tracing system allows us to insert traces in the code by using the <code class="literal">trace_printk</code> function call. It has the same syntax as <code class="literal">printk</code> and can be used in the same scenarios, interrupts, NMI, or scheduler contexts.</p><p>Its advantage is that as it prints to the tracing buffer in memory and not to the console, it has much lower delays than <code class="literal">printk</code>, so it is useful to debug scenarios where <code class="literal">printk</code> is affecting the system's behavior; for example, when masking a timing bug.</p><p>Tracing is enabled once a tracer is configured, but whether the trace writes to the ring buffer or not can be controlled. To disable the writing to the buffer, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo 0 &gt; /sys/kernel/debug/tracing/tracing_on</strong></span>
</pre></div><p>And to re-enable it, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</strong></span>
</pre></div><p>You can also enable and disable the tracing from kernel space by using the <code class="literal">tracing_on</code> and <code class="literal">tracing_off</code> functions.</p><p>Inserted traces will <a id="id257" class="indexterm"/>appear in any tracer, including the <code class="literal">function</code> tracer, in which case it will appear as a comment.</p><div class="section" title="Filtering function traces"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec33"/>Filtering function traces</h3></div></div></div><p>You can get finer<a id="id258" class="indexterm"/> granularity in the functions being traced by using the dynamic tracer, which can be enabled with the <code class="literal">CONFIG_DYNAMIC_FTRACE</code> configuration variable. This is enabled with the tracing functionality by default. This adds two more files, <code class="literal">set_ftrace_filter</code> and <code class="literal">set_ftrace_notrace</code>. Adding functions to <code class="literal">set_ftrace_filter</code> will trace only those functions, and adding them to <code class="literal">set_ftrace_notrace</code> will not trace them, even if they are also added to <code class="literal">set_ftrace_filter</code>.</p><p>The set of available function names that can be filtered may be obtained by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /sys/kernel/debug/tracing/available_filter_functions</strong></span>
</pre></div><p>Functions can be added with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo -n &lt;function_name&gt; &gt;&gt;  /sys/kernel/debug/tracing/set_ftrace_filter</strong></span>
</pre></div><p>Note that we use the concatenation operator (<code class="literal">&gt;&gt;</code>) so that the new function is appended to the existing ones.</p><p>And functions can also be removed with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo -n '!&lt;function&gt;' &gt;&gt;  /sys/kernel/debug/tracing/set_ftrace_filter</strong></span>
</pre></div><p>To remove all functions, just echo a blank line into the file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo &gt;  /sys/kernel/debug/tracing/set_ftrace_filter</strong></span>
</pre></div><p>There is a special syntax that adds extra flexibility to the filtering: <code class="literal">&lt;function&gt;:&lt;command&gt;:[&lt;parameter&gt;]</code></p><p>Let's explain each of the <a id="id259" class="indexterm"/>components individually:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">function</code>: This specifies the function name. Wildcards are allowed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">command</code>: This has the following attributes:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mod</code>: This enables the given function name only in the module specified in the parameter</li><li class="listitem" style="list-style-type: disc"><code class="literal">traceon/traceoff</code>: This enables or disables tracing when the specified function is hit the numbers of times given in the parameter, or always if no parameter is given.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dump</code>: Dump the contents of the tracing buffer when the given function is hit.</li></ul></div></li></ul></div><p>Here are some examples:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo -n 'ipu_*:mod:ipu' &gt; /sys/kernel/debug/tracing/set_ftrace_filter</strong></span>
<span class="strong"><strong>$ echo -n 'suspend_enter:dump' &gt; /sys/kernel/debug/tracing/set_ftrace_filter</strong></span>
<span class="strong"><strong>$ echo -n 'suspend_enter:traceon' &gt; /sys/kernel/debug/tracing/set_ftrace_filter</strong></span>
</pre></div></div><div class="section" title="Enabling trace options"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec34"/>Enabling trace options</h3></div></div></div><p>Traces have a set of options that can be <a id="id260" class="indexterm"/>individually enabled in the <code class="literal">/sys/kernel/debug/tracing/options</code> directory. Some of the most useful options include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">print-parent</code>: This option displays the caller function too</li><li class="listitem" style="list-style-type: disc"><code class="literal">trace_printk</code>: This option disables <code class="literal">trace_printk</code> writing</li></ul></div></div><div class="section" title="Using the function tracer on oops"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec35"/>Using the function tracer on oops</h3></div></div></div><p>Another alternative to log the <a id="id261" class="indexterm"/>kernel messages on oops or panic is to configure the function tracer to dump its buffer contents to the console so that the events leading up to the crash can be analyzed. Use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo 1 &gt; /proc/sys/kernel/ftrace_dump_on_oops</strong></span>
</pre></div><p>The <code class="literal">sysrq-z</code> combination will also dump the contents of the tracing buffer to the console, as does calling <code class="literal">ftrace_dump()</code> from the kernel code.</p></div><div class="section" title="Getting a stack trace for a given function"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec36"/>Getting a stack trace for a given function</h3></div></div></div><p>The tracing code can<a id="id262" class="indexterm"/> create a backtrace for every function called. However, this is a dangerous feature and should only be used with a filtered selection of functions. Have a look at the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo -n &lt;function_name&gt; &gt; /sys/kernel/debug/tracing/set_ftrace_filter</strong></span>
<span class="strong"><strong>$ echo -n function &gt; /sys/kernel/debug/tracing/current_tracer</strong></span>
<span class="strong"><strong>$ echo 1 &gt; /sys/kernel/debug/tracing/options/func_stack_trace</strong></span>
<span class="strong"><strong>$ cat /sys/kernel/debug/tracing/trace</strong></span>
<span class="strong"><strong>$ echo 0 &gt; /sys/kernel/debug/tracing/options/func_stack_trace</strong></span>
<span class="strong"><strong>$ echo &gt; /sys/kernel/debug/tracing/set_ftrace_filter</strong></span>
</pre></div></div><div class="section" title="Configuring the function tracer at boot"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec37"/>Configuring the function tracer at boot</h3></div></div></div><p>The function tracer can<a id="id263" class="indexterm"/> be configured in the kernel command-line arguments and started as early as possible in the boot process. For example, to configure the graphic function tracer and filter some functions, we would pass the following arguments from the U-Boot bootloader to the kernel:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ftrace=function_graph ftrace_filter=mxc_hdmi*,fb_show*</strong></span>
</pre></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec99"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More details can be found in the kernel source documentation folder at <code class="literal">Documentation/trace/ftrace.txt</code></li></ul></div></div></div>
<div class="section" title="Managing the device tree"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec38"/>Managing the device tree</h1></div></div></div><p>The device tree is a data structure<a id="id264" class="indexterm"/> that is passed to the Linux kernel to describe the physical devices in a system.</p><p>In this recipe, we will explain how to work with device trees.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec100"/>Getting ready</h2></div></div></div><p>Devices that cannot be discovered by the CPU are handled by the platform devices API on the Linux kernel. The device tree replaces the legacy platform data where hardware characteristics were hardcoded in the kernel source so that platform devices can be instantiated. Before device trees came into use, the bootloader (for example, U-Boot) had to tell the kernel what machine type it was booting. Moreover, it had to pass other information such as memory size and location, kernel command line, and more.</p><p>The device tree should not be confused with the Linux kernel configuration. The device tree specifies what devices are available and how they are accessed, not whether the hardware is used.</p><p>The device tree was first used by the PowerPC architecture and was adopted later on by ARM and all others, except x86. It was defined by the Open Firmware specification, which defined the flattened device tree format in <span class="strong"><strong>Power.org Standard for Embedded Power Architecture Platform Requirements</strong></span> (<span class="strong"><strong>ePAPR</strong></span>), which describes an interface between a boot program and a client.</p><p>Platform customization changes will usually happen in the device tree without the need to modify the kernel source.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec101"/>How to do it...</h2></div></div></div><p>A device tree is defined in a human-readable device tree syntax (<code class="literal">.dts</code>) text file. Every board has one or several DTS files that correspond to different hardware configurations.</p><p>These DTS files are compiled into <span class="strong"><strong>Device Tree Binary</strong></span> (<span class="strong"><strong>DTB</strong></span>)<a id="id265" class="indexterm"/> blobs, which have the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They are relocatable, so pointers are never used internally</li><li class="listitem" style="list-style-type: disc">They allow for dynamic node insertion and removal</li><li class="listitem" style="list-style-type: disc">They are small in size</li></ul></div><p>Device tree blobs can either be attached to the kernel binary (for legacy compatibility) or, as is more commonly done, passed to the kernel by a bootloader like U-Boot.</p><p>To compile them, we use a <a id="id266" class="indexterm"/>
<span class="strong"><strong>Device Tree Compiler</strong></span> (<span class="strong"><strong>DTC</strong></span>), which is included in the kernel source inside <code class="literal">scripts/dtc</code> and is compiled along with the kernel itself, or we could alternatively install it as part of your distribution. It is recommended to use the DTC compiler included in the kernel tree.</p><p>The device trees can be compiled<a id="id267" class="indexterm"/> independently or with the Linux kernel kbuild system, as we saw previously. However, when compiling independently, modern device trees will need to be preprocessed by the C preprocessor first.</p><p>It's important to note that the DTC currently performs syntax checking but no binding checking, so invalid DTS files may be compiled, and the resulting DTB file may result in a non-booting kernel. Invalid DTB files usually hang the Linux kernel very early on so there will be no serial output.</p><p>The bootloader might also modify the device tree before passing it to the kernel.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec102"/>How it works...</h2></div></div></div><p>The DTS file for the <code class="literal">wandboard-quad</code> variant is under <code class="literal">arch/arm/boot/dts/imx6q-wandboard.dts</code> and looks as follows:</p><div class="informalexample"><pre class="programlisting">#include "imx6q.dtsi"
#include "imx6qdl-wandboard.dtsi"

/ {
    model = "Wandboard i.MX6 Quad Board";
    compatible = "wand,imx6q-wandboard", "fsl,imx6q";

    memory {
        reg = &lt;0x10000000 0x80000000&gt;;
    };
};</pre></div><p>What we see here is the device tree root node that has no parents. The rest of the nodes will have a parent. The structure of a node can be represented as follows:</p><div class="informalexample"><pre class="programlisting">node@0{
  an-empty-property;
  a-string-property = "a string";
  a-string-list-property = "first string", "second string";
  a-cell-property = &lt;1&gt;;
  a-cell-property = &lt;0x1 0x2&gt;;
  a-byte-data-property = [0x1 0x2 0x3 0x4];
  a-phandle-property = &lt;&amp;node1&gt;;
}</pre></div><p>The node properties can be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Empty</li><li class="listitem" style="list-style-type: disc">Contain one or more<a id="id268" class="indexterm"/> strings</li><li class="listitem" style="list-style-type: disc">Contain one or more unsigned 32-bit numbers, called<a id="id269" class="indexterm"/> <span class="strong"><strong>cells</strong></span></li><li class="listitem" style="list-style-type: disc">Contain a binary byte stream</li><li class="listitem" style="list-style-type: disc">Be a reference to another node, called a <a id="id270" class="indexterm"/><span class="strong"><strong>phandle</strong></span></li></ul></div><p>The device tree is initially parsed by the C preprocessor and it can include other DTS files. These <code class="literal">include</code> files have the same syntax and are usually appended with the <code class="literal">dtsi</code> suffix. File inclusion can also be performed with the device tree <code class="literal">/include/</code> operator, although <code class="literal">#include</code> is recommended, and they should not be mixed. In this case, both <code class="literal">imx6q.dtsi</code> and <code class="literal">imx6qdl-wandboard.dtsi</code> are overlaid with the contents of <code class="literal">imx6q-wandboard.dts</code>.</p><p>Device tree nodes are documented in bindings contained in the <code class="literal">Documentation/devicetree/bindings/</code> directory of the kernel source. New nodes must include the corresponding bindings, and these must be reviewed and accepted by the device tree maintainers. Theoretically, all bindings need to be maintained, although it is likely this will be relaxed<a id="id271" class="indexterm"/> in the future.</p><div class="section" title="The compatible property"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec38"/>The compatible property</h3></div></div></div><p>The most important property in a<a id="id272" class="indexterm"/> device tree node is the <code class="literal">compatible</code> property. In the root node, it defines the machine types the device tree is compatible with. The DTS file we just saw is compatible in order of precedence with the <code class="literal">wand,imx6q-wandboard</code> and <code class="literal">fsl,imx6q</code> machine types.</p><p>On a non-root node, it will define the driver match for the device tree node, binding a device with the driver. For example, a platform driver that binds with a node that defines a property that is compatible with <code class="literal">fsl,imx6q-tempmon</code> would contain the following excerpt:</p><div class="informalexample"><pre class="programlisting">static const struct of_device_id of_imx_thermal_match[] = {
    { .compatible = "fsl,imx6q-tempmon", },
    { /* end */ }
};
MODULE_DEVICE_TABLE(of, of_imx_thermal_match);

static struct platform_driver imx_thermal = {
    .driver = {
        .name   = "imx_thermal",
        .owner  = THIS_MODULE,
        .of_match_table = of_imx_thermal_match,
    },
    .probe      = imx_thermal_probe,
    .remove   = imx_thermal_remove,
};
module_platform_driver(imx_thermal);</pre></div></div><div class="section" title="The Wandboard device tree file"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec39"/>The Wandboard device tree file</h3></div></div></div><p>Usually, the first DTSI file to <a id="id273" class="indexterm"/>be included is <code class="literal">skeleton.dtsi</code>, which is the minimum device tree needed to boot, once a compatible property is added.</p><div class="informalexample"><pre class="programlisting">/ {
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    chosen { };
    aliases { };
    memory { device_type = "memory"; reg = &lt;0 0&gt;; };
};</pre></div><p>Here are the other common top nodes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>chosen</strong></span>: This node defines fixed parameters set at boot, such as the Linux kernel command line or the <code class="literal">initramfs</code> memory location. It replaces the information traditionally passed in ARM tags (<code class="literal">ATAGS</code>).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>memory</strong></span>: This node is used to define the location and size of RAM. This is usually filled in by the bootloader.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>aliases</strong></span>: This defines shortcuts to other nodes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>address-cells</strong></span> and <span class="strong"><strong>size-cells</strong></span>: These are used for memory addressability and will be discussed later on.</li></ul></div><p>A summary representation of the <code class="literal">imx6q-wandboard.dts</code> file showing only the selected buses and devices follows:</p><div class="informalexample"><pre class="programlisting">#include "skeleton.dtsi"

/ {
    model = "Wandboard i.MX6 Quad Board";
    compatible = "wand,imx6q-wandboard", "fsl,imx6q";

    memory {};

    aliases {};

    intc: interrupt-controller@00a01000 {};

    soc {
        compatible = "simple-bus";

        dma_apbh: dma-apbh@00110000 {};

        timer@00a00600 {};

        L2: l2-cache@00a02000 {};

        pcie: pcie@0x01000000 {};

        aips-bus@02000000 { /* AIPS1 */
            compatible = "fsl,aips-bus", "simple-bus";

            spba-bus@02000000 {
                compatible = "fsl,spba-bus", "simple-bus";
            };

            aipstz@0207c000 {};

            clks: ccm@020c4000 {};

            iomuxc: iomuxc@020e0000 {};
        };

        aips-bus@02100000 {
            compatible = "fsl,aips-bus", "simple-bus";
        };
    };
};</pre></div><p>On this DTS, we can find several nodes defining <span class="strong"><strong>system on chip</strong></span> (<span class="strong"><strong>SoC</strong></span>)<a id="id274" class="indexterm"/> buses and several other nodes defining on-board devices.</p></div><div class="section" title="Defining buses and memory-addressable devices"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec40"/>Defining buses and memory-addressable devices</h3></div></div></div><p>Buses are typically defined <a id="id275" class="indexterm"/>by the <code class="literal">compatible</code> property or the <code class="literal">simple-bus</code> property (to define a memory-mapped bus with no specific driver binding) or both. The <code class="literal">simple-bus</code> property is needed so that children nodes to the bus are registered as platform devices.</p><p>For example, the <code class="literal">soc</code> node is defined as follows:</p><div class="informalexample"><pre class="programlisting">soc {
    compatible = "simple-bus";
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    ranges;

    aips-bus@02000000 { /* AIPS1 */
        compatible = "fsl,aips-bus", "simple-bus";
        reg = &lt;0x02000000 0x100000&gt;;
    }
}</pre></div><p>The properties on the <code class="literal">soc</code> node are used to specify the memory addressability of the children nodes.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">address-cells</code>: This property indicates how many base address cells are needed in the <code class="literal">reg</code> property.</li><li class="listitem" style="list-style-type: disc"><code class="literal">size-cells</code>: This property indicates how many size cells are needed in the <code class="literal">reg</code> property.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ranges</code>: This one describes an address translation between parent and child buses. In here, there is no translation and parent and child addressing is identical.</li></ul></div><p>In this case, any child of <code class="literal">soc</code> needs to define its memory addressing with a <code class="literal">reg</code> property that contains one cell for the address and one cell for the size. The <code class="literal">aips-bus</code> node does that with the <a id="id276" class="indexterm"/>following property:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>reg = &lt;0x02000000 0x100000&gt;;</strong></span>
</pre></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec103"/>There's more...</h2></div></div></div><p>When the device tree binary blob is loaded in memory by the Linux kernel, it is expanded into a flattened device tree that is accessed by offset. The <code class="literal">fdt_*</code> kernel functions are used to access the flattened device tree. This <code class="literal">fdt</code> is then parsed and transformed into a tree memory structure that can be efficiently accessed with the <code class="literal">of_*</code> family of functions (the prefix comes from Open Firmware).</p><div class="section" title="Modifying and compiling the device tree in Yocto"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec41"/>Modifying and compiling the device tree in Yocto</h3></div></div></div><p>To modify the device tree in the <a id="id277" class="indexterm"/>Yocto build system, we execute the following <a id="id278" class="indexterm"/>set of commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake -c devshell virtual/kernel</strong></span>
</pre></div><p>We then edit <code class="literal">arch/arm/boot/dts/imx6q-wandboard.dts</code> and compile the changes with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make dtbs</strong></span>
</pre></div><p>If we want to create a <a id="id279" class="indexterm"/>device tree with extra space, let's say 1024 bytes (for example, to add nodes dynamically as explained in the next recipe), we need to specify it with a DTC flag as follows:</p><div class="informalexample"><pre class="programlisting">DTC_FLAGS="-p 1024" make dtbs</pre></div><p>To deploy it, we exit the devshell and build the kernel from the project's <code class="literal">build</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c deploy -f virtual/kernel</strong></span>
</pre></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec104"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More information <a id="id280" class="indexterm"/>regarding device trees can be found at <a class="ulink" href="http://www.devicetree.org">http://www.devicetree.org</a></li></ul></div></div></div>
<div class="section" title="Debugging device tree issues"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec39"/>Debugging device tree issues</h1></div></div></div><p>This recipe will show some<a id="id281" class="indexterm"/> techniques to debug common problems with the device tree.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec105"/>How to do it...</h2></div></div></div><p>As mentioned before, problems with the syntax of device tree files usually result in the kernel crashing early in the boot process. Other type of problems are more subtle and usually appear once a driver is making use of the information provided by the device tree. For both types of problems, it is helpful to be able to look not only at the device tree syntax file, but also at the device tree blob, as it is read by both U-Boot and the Linux kernel. It may also be helpful to modify the device tree on the fly using the tools that U-Boot offers.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec106"/>How it works...</h2></div></div></div><div class="section" title="Looking at the device tree from U-Boot"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec42"/>Looking at the device tree from U-Boot</h3></div></div></div><p>The U-Boot bootloader offers <a id="id282" class="indexterm"/>the <code class="literal">fdt</code> command to<a id="id283" class="indexterm"/> interact with a device tree blob. On the Wandboard's default environment, there are two variables related to the device tree:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fdt_file</code>: This variable contains the name of the device tree file used</li><li class="listitem" style="list-style-type: disc"><code class="literal">fdt_addr</code>: This variable contains the location in memory to load the device tree</li></ul></div><p>To fetch the Wandboard's device tree from the TFTP server location and place it in memory, we use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; tftp ${fdt_addr} ${fdt_file}</strong></span>
</pre></div><p>Once we have the device tree blob in memory, we tell U-Boot where it is located:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; fdt addr ${fdt_addr}</strong></span>
</pre></div><p>And then we can inspect nodes from the device tree using the full path to them from the root node. To inspect the selected levels, we use the <code class="literal">list</code> command, and to print complete subtrees, we use the <code class="literal">print</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; fdt list /cpus</strong></span>
<span class="strong"><strong>cpus {</strong></span>
<span class="strong"><strong>        #address-cells = &lt;0x00000001&gt;;</strong></span>
<span class="strong"><strong>        #size-cells = &lt;0x00000000&gt;;</strong></span>
<span class="strong"><strong>        cpu@0 {</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>};</strong></span>
<span class="strong"><strong>&gt; fdt print /cpus</strong></span>
<span class="strong"><strong>cpus {</strong></span>
<span class="strong"><strong>        #address-cells = &lt;0x00000001&gt;;</strong></span>
<span class="strong"><strong>        #size-cells = &lt;0x00000000&gt;;</strong></span>
<span class="strong"><strong>        cpu@0 {</strong></span>
<span class="strong"><strong>                compatible = "arm,cortex-a9";</strong></span>
<span class="strong"><strong>                device_type = "cpu";</strong></span>
<span class="strong"><strong>                reg = &lt;0x00000000&gt;;</strong></span>
<span class="strong"><strong>                next-level-cache = &lt;0x0000001d&gt;;</strong></span>
<span class="strong"><strong>                [omitted]</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>};</strong></span>
</pre></div><p>U-Boot can also attach <a id="id284" class="indexterm"/>new nodes to the tree assuming there is extra <a id="id285" class="indexterm"/>space in the device tree:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; fdt mknode / new-node</strong></span>
<span class="strong"><strong>&gt; fdt list /new-node </strong></span>
<span class="strong"><strong>new-node {</strong></span>
<span class="strong"><strong>};</strong></span>
</pre></div><p>It can also create or remove properties:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; fdt set /new-node testprop testvalue</strong></span>
<span class="strong"><strong>&gt; fdt print /new-node                 </strong></span>
<span class="strong"><strong>new-node {</strong></span>
<span class="strong"><strong>        testprop = "testvalue";</strong></span>
<span class="strong"><strong>};</strong></span>
<span class="strong"><strong>&gt; fdt rm /new-node testprop           </strong></span>
<span class="strong"><strong>&gt; fdt print /new-node      </strong></span>
<span class="strong"><strong>new-node {</strong></span>
<span class="strong"><strong>};</strong></span>
</pre></div><p>For example, it can be useful to modify the kernel command line through the chosen node.</p></div><div class="section" title="Looking at the device tree from the Linux kernel"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec43"/>Looking at the device tree from the Linux kernel</h3></div></div></div><p>Once the Linux kernel is <a id="id286" class="indexterm"/>booted, it can be<a id="id287" class="indexterm"/> useful to expose the device tree to user space so that it can be explored. You can do this by configuring the Linux kernel with the <code class="literal">CONFIG_PROC_DEVICETREE</code> configuration variable. The Wandboard Linux kernel comes preconfigured to <a id="id288" class="indexterm"/>expose the device <a id="id289" class="indexterm"/>tree in <code class="literal">/proc/device-tree</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ls /proc/device-tree/cpus/</strong></span>
<span class="strong"><strong>#address-cells  cpu@0           cpu@2           name</strong></span>
<span class="strong"><strong>#size-cells     cpu@1           cpu@3</strong></span>
</pre></div></div></div></div></body></html>