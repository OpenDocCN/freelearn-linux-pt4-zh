<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Lets Make a Process Chat</h1>
                
            
            <article>
                
<p class="calibre1"><span><span><strong class="calibre2">Inter-process Communication</strong> (<strong class="calibre2">IPC</strong>) is a nice way to describe the fact that processes talk to each other, exchange data, and can then react accordingly. This kind of chatting can be held between a parent and a child process, between processes on the same host, and between programs on different hosts. Processes exchange data in a different ways; for instance, if we think about it, when we SSH to a remote server, our client is communicating with the remote host and actually exchanging data back and forth. The same happens when you pipe the output of a command into the standard input of another one; these are ways, sometimes monodirectional, sometimes bidirectional, to put different processes into communicating and enhancing what we can do with our Bash environment.</span></span></p>
<p class="calibre1"><span><span>There are different ways to accomplish IPC, some more familiar, some less, but all are effective to a certain extent, and we already saw some examples during this book. So, now we will go through few pages which will describe a bit more in depth how processes can interact and how can use the IPC to enhance our scripts, focusing on those methods that we can access using Bash, starting with the so-called <strong class="calibre2">pipes</strong>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pipes</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We can describe a pipeline as a sequence of processes tied together by <kbd class="calibre9">stdout</kbd> and <kbd class="calibre9">stdin</kbd> so that the output of one process becomes the input of the following one. This is a simple form of IPC, commonly known as anonymous pipe, and it is a one-way form of communicating: whatever comes from standard output of the preceding process flows into the standard input of the following one; nothing comes back from the latter to the former.</span></span></p>
<p class="calibre1"><span><span>Let's see an example that will clarify the concept of anonymous pipe, staring with a simple <kbd class="calibre9">ps</kbd> command:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ps <br class="title-page-name"/></strong><strong class="calibre2">PID TTY TIME CMD<br class="title-page-name"/></strong><strong class="calibre2">1427 pts/0 00:00:00 bash<br class="title-page-name"/></strong><strong class="calibre2">12112 pts/0 00:00:00 ps</strong>
</pre>
<p class="calibre1"><span><span>We have a simple listing with some commands: <kbd class="calibre9">PID</kbd>, <kbd class="calibre9">TTY</kbd>, and <kbd class="calibre9">CMD</kbd>. Let's say we want to trim down the output to just <kbd class="calibre9">PID</kbd> and <kbd class="calibre9">CMD</kbd>. We could alter the output using some <kbd class="calibre9">ps</kbd> switches, but who remembers them? It's easier to use something that is capable of mangling the text and gives us the result we want, so why not use <kbd class="calibre9">awk</kbd>? The problem here is that <kbd class="calibre9">awk</kbd> works on the text it receives from the input, reading a file for instance. But we can cut corners, linking its standard input to the <kbd class="calibre9">ps</kbd> standard output by means of the pipe character <kbd class="calibre9">|</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ps | awk '{print $1, $4}'<br class="title-page-name"/></strong><strong class="calibre2">PID CMD<br class="title-page-name"/></strong><strong class="calibre2">1427 bash<br class="title-page-name"/></strong><strong class="calibre2">12113 ps<br class="title-page-name"/></strong><strong class="calibre2">12114 awk.</strong>
</pre>
<p class="calibre1"><span><span>Here, <kbd class="calibre9">awk</kbd> accepted the output of <kbd class="calibre9">ps</kbd> as the input and printed to the <kbd class="calibre9">stdout</kbd> the first and fourth field only, being the blank character the standard field separator. As mentioned earlier, we can chain more than two processes:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ps | awk '{print $1, $4}' | tail -n +2 | wc -l<br class="title-page-name"/></strong><strong class="calibre2">5</strong>
</pre>
<p class="calibre1"><span><span>In this case, we piped the output of the previous set of commands through <kbd class="calibre9">tail</kbd>, which actually got the first line (<kbd class="calibre9">PID CMD</kbd>) removed and printed to <kbd class="calibre9">stdout</kbd>. Then, we piped this output through the <kbd class="calibre9">stdin</kbd> of <kbd class="calibre9">wc</kbd>, which then printed the count of the lines we received in <kbd class="calibre9">stdin</kbd>. This is possible because all the processes are in the same environment since each command at the right end of a pipe runs in a subshell of the main shell and shares the same file descriptors. Thus, it is just matter of writing the data to the open descriptor of the parent process; and the child will be able to read them in the same order it was written: with a kernel buffer to hold the bits waiting to be read.</span></span></p>
<p class="calibre1"><span><span>Nice and handy, but there are some serious restrictions:</span></span></p>
<ul class="calibre12">
<li class="calibre13">The processes must reside on the same host</li>
<li class="calibre13">The processes must be active on an overlapping span of time: the preceding process must be producing output while the following one is reading</li>
<li class="calibre13">The communication is one way only: the data descends the chain and never climbs back the ladder</li>
</ul>
<p class="calibre1"><span><span>We can overcome some of these restrictions using pipes, which are often referred to as FIFO pipes due to the way they work. They rely on the creating a file, which then any number of processes can access, and this introduces a huge difference with respect to the anonymous pipe. It lasts as long as the processes involved last, while a named pipe lasts as long as the file exists; and this can last as long as the system is not rebooted or the file itself. We can create a file using either <kbd class="calibre9">mkfifo</kbd> or <kbd class="calibre9">mknode</kbd>, and use the I/O redirection to read or write as shown in the following example:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>pipefile="mypipefile"<br class="title-page-name"/>if [[ ! -p $pipefile ]] <br class="title-page-name"/>then<br class="title-page-name"/>mknod $pipefile p<br class="title-page-name"/>fi<br class="title-page-name"/>while true<br class="title-page-name"/>do<br class="title-page-name"/>read row &lt;$pipefile<br class="title-page-name"/>if [[ "$row" == 'exit' ]]<br class="title-page-name"/>then<br class="title-page-name"/>echo "I read $row so exiting"<br class="title-page-name"/>break<br class="title-page-name"/>fi<br class="title-page-name"/>echo $row<br class="title-page-name"/>done
</pre>
<p class="calibre1"><span><span>Let's follow the flow of the script. The first thing we want to be sure of is that our named pipe is in place, so we test for a particular kind of file called <kbd class="calibre9">-p</kbd>, a pipe. If it does not exist, the script creates it using </span></span><span><span><kbd class="calibre9">mknod $pipefile p</kbd>.</span></span></p>
<p class="calibre1"><span><span>The <kbd class="calibre9">p</kbd> added at the end of the command line ensures the creation of the file as a pipe and not as a regular one. Then, we want the script to keep reading from the file we open so we use an infinite loop: <em class="calibre20">true is always true</em>. Inside the infinite loop, we have the </span></span><span><span><kbd class="calibre9">read row $pipefile</kbd> </span></span><span><span>instruction, which reads from the pipe file line by line and stores the content into the <kbd class="calibre9">row</kbd> variable. So far, so good. If we jump to the end of the script, we can see that it just echoes whatever we input but there is a tiny check in between; if we input <kbd class="calibre9">exit</kbd>,  the program will exit. Let's run in one terminal our new script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./pipe.sh </strong>
</pre>
<p class="calibre1"><span><span>We will see our prompt flashing without giving us the command line back: the script is trapped in an infinite loop reading from the named pipe and will not terminate until we type <kbd class="calibre9">exit</kbd> into its standard input. Now, using the output redirection, let's send some stuff into the pipe file:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo “Hello” &gt; mypipefile<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ echo “Another line” &gt; mypipefile<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ echo “It is time to quit” &gt; mypipefile<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ echo exit &gt; mypipefile</strong>
</pre>
<p class="calibre1"><span><span>Let's see what is on the terminal running our script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./pipe.sh <br class="title-page-name"/></strong><strong class="calibre2">“Hello”<br class="title-page-name"/></strong><strong class="calibre2">“It is time to quit”<br class="title-page-name"/></strong><strong class="calibre2">I read exit so exiting</strong>
</pre>
<p class="calibre1"><span><span>That's it. The script echoed all the text we sent to the <kbd class="calibre9">pipe</kbd> file; and when it encountered the <kbd class="calibre9">quit</kbd> string, it just exited, giving us a nice message. This example is quite easy and can be replicated using simple files, but switch the context and think about multiple processes coordinating their actions writing and reading from a pipe, sending and reading data, keywords, commands from the pipe, and doing something in a graceful order. All without using an intermediary temporary file but a pipe that will disappear upon the system reboot without the need for all processes to run at the same time. Processes can be triggered by cron jobs manually, by other applications, or by running indefinitely in a loop. It does not matter, as everything is async. We have a means to connect processes in an asynchronous way and both ways, since each process can both send and receive data. This means, we instruct other processes and feed them with data, or are instructed and get fed with data when needed. All this is really useful but there is something more barebone than this when it comes to IPC, not really an inter-process communication since we are going to use redirections to plain files.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Redirection to a file</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Well, redirecting the output of a process is not what an IPC means, but it can be used as such in an asynchronous way: have one process redirect its output to a file and have another one read from the same file later on; and this can be a way to exchange information between the two processes:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ myfile=”myfile.txt” ; touch "$myfile" ; echo "$myfile" &gt; controller ; while read -r line; do tar cvzf $line.tgz $line ; done &lt; controller<br class="title-page-name"/></strong><strong class="calibre2">myfile.txt</strong>
</pre>
<p class="calibre1"><span><span>In this example, we just stored a filename into a variable. We created the file with <kbd class="calibre9">touch</kbd>, and then stored the filename into the <kbd class="calibre9">controller</kbd> file. Once we had the filename into the <kbd class="calibre9">controller</kbd> file, we had it read line by line and each line was stored into the <kbd class="calibre9">line</kbd> variable. Finally, the content of the line variable is used to zip the file pointed by the <kbd class="calibre9">myfile</kbd> variable:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -lah<br class="title-page-name"/></strong><strong class="calibre2">total 20K<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Apr 10 09:18 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 4 zarrelli zarrelli 4.0K Apr 10 09:17 ..<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 11 Apr 10 09:18 controller<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Apr 10 09:18 myfile.txt<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 123 Apr 10 09:18 myfile.txt.tgz<br class="title-page-name"/></strong><strong class="calibre2">prw-r--r-- 1 zarrelli zarrelli 0 Apr 9 13:05 mypipefile<br class="title-page-name"/></strong><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 223 Apr 9 12:44 pipe.sh</strong>
</pre>
<p class="calibre1"><span><span>Here, we have all the files in place and <kbd class="calibre9">tar</kbd> just followed the instructions stored by <kbd class="calibre9">echo</kbd> in the <kbd class="calibre9">controller</kbd> file. This is quite a trivial example, and it can be expanded as much as we wish. Notice that in this way, there are no special files needed, and the processes can be unrelated and can be executed any time without any need for concurrency. Probably this kind of IPC is not so surprising, but if we pay enough attention, we can find other interesting ways to make processes talk to each others, for instance, <strong class="calibre2">command substitution</strong>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The command substitution</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We already saw what a command substitution is:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ time=$(date +%H:%M) ; echo $time<br class="title-page-name"/></strong><strong class="calibre2">10:06</strong>
</pre>
<p class="calibre1"><span><span>The output of a command gets stored as a string into a variable, and it is then available to be used in any way we need. So, for instance, we could well do this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ myfile="myfile.txt.tgz" ; content=$(tar -tzf $myfile) ; echo $content<br class="title-page-name"/></strong><strong class="calibre2">myfile.txt</strong>
</pre>
<p class="calibre1"><span><span>In this case, we used the command substitution to perform a test on a <kbd class="calibre9">tar</kbd> file whose name was provided by means of a variable. The output of the command substitution was then fed as an argument to echo, which showed us the outcome of the <kbd class="calibre9">tar</kbd> command. We could use an even more complex command inside the command substitution bit, but beware of some issues with escaping since what happens inside the parentheses is not always what we would expect.</span></span></p>
<p class="calibre1"><span><span>Is this a valid way to make processes communicate with each other? Yes, it is. Is it handy? Not so much. Command substitution can be tricky in a complex task, and we have the same limitations we saw for other methods since it is a one-way flow. That said, it is widely used in Bash scripts to provide a quick access to command paths or just store some information in variables, such as the actual date on the system or whatever small bit of information we need. We have other options to feed the output of a process to the standard input of another, but sometimes we do not take enough time to think at all the ways we have to accomplish this goal. For example, using the process substitution.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The process substitution</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>The <strong class="calibre2">process substitution</strong> is a handy way to feed the output of multiple commands/processes to the input of another process. The standard way to manage a process substitution goes along with the following syntax:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">&gt;(list_of_commands)<br class="title-page-name"/></strong><strong class="calibre2">&lt;(list_of_commands)</strong>
</pre>
<p class="calibre1"><span><span>Mind the space between <kbd class="calibre9">&lt;</kbd>,<kbd class="calibre9">&gt;</kbd>, and the parentheses; there is no space at all:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ wc -l &lt;(ps -fj)<br class="title-page-name"/></strong><strong class="calibre2">5 /dev/fd/63</strong>
</pre>
<p class="calibre1"><span><span>In this example, the output of <kbd class="calibre9">ps -fj</kbd> has been given as an input to <kbd class="calibre9">wc -l</kbd>, which counted <kbd class="calibre9">5</kbd> lines in the output. Notice </span></span><span><span><kbd class="calibre9">/dev/fd/63</kbd>.</span></span></p>
<p class="calibre1"><span><span>This is the file descriptor used by the process substitution to feed the results of the process inside the parentheses to another process. So, file descriptors in <kbd class="calibre9">/dev/fd</kbd> are used to feed data, and this is useful, especially for those commands that cannot take advantage of pipes, because they expect data to be read from a file and not fed from the standard input. A classic example of a multiprocess feed as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ mkdir "test 1"<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ mkdir "test 2"<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ for i in {1..5}; do touch "test 1/$i"; done<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ for i in {1..3}; do touch "test 2/$i"; done<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ diff &lt;(ls "test 1") &lt;(ls "test 2")<br class="title-page-name"/></strong><strong class="calibre2">4,5d3<br class="title-page-name"/></strong><strong class="calibre2">&lt; 4<br class="title-page-name"/></strong><strong class="calibre2">&lt; 5</strong>
</pre>
<p class="calibre1"><span><span>We just created a couple of test directory and in the first directory, we made <kbd class="calibre9">5</kbd> empty files, in the second, <kbd class="calibre9">3</kbd>. Then, we just fed <kbd class="calibre9">diff</kbd> with the output of the <kbd class="calibre9">ls</kbd> command issued on both <kbd class="calibre9">test 1</kbd> and <kbd class="calibre9">test 2</kbd> directories. The utility then just showed us all the files available in <kbd class="calibre9">test 1</kbd> but not in <kbd class="calibre9">test 2</kbd>, as we had issued it on the two real directories. It is handy, but consider its scope carefully since the command substitution remains available in a function until this returns. Talking about scope, process substitution is a good way to avoid a common pitfall when piping command to a loop in a subshell:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>main_variable=10<br class="title-page-name"/>echo "We are outside the loop and the global variable called main_variable has a value of: $main_variable"<br class="title-page-name"/>for i in {1..5}<br class="title-page-name"/>do <br class="title-page-name"/>echo "$i" <br class="title-page-name"/>done |<br class="title-page-name"/>while read j<br class="title-page-name"/>do<br class="title-page-name"/>main_variable="$j"<br class="title-page-name"/>echo "We are inside the loop and main_variable has a value of: $main_variable"<br class="title-page-name"/>done<br class="title-page-name"/>echo "We are now past the loop and main_variable has a value of: $main_variable"<strong class="calibre2"> </strong>
</pre>
<p class="calibre1"><span><span>Piping is actually executing the loop inside a subshell, and this will have all the variables inside the loop being available in the subshell only. The value of <kbd class="calibre9">main_variable</kbd> will be modified in the inner loop but once we exit it, we go back to the main value since each variable value set in the inner loop cannot be sent back to the calling environment:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./looping.sh <br class="title-page-name"/></strong><strong class="calibre2">We are outside the loop and the global variable called main_variable has a value of: 10<br class="title-page-name"/></strong><strong class="calibre2">We are inside the loop and main_variable has a value of: 1<br class="title-page-name"/></strong><strong class="calibre2">We are inside the loop and main_variable has a value of: 2<br class="title-page-name"/></strong><strong class="calibre2">We are inside the loop and main_variable has a value of: 3<br class="title-page-name"/></strong><strong class="calibre2">We are inside the loop and main_variable has a value of: 4<br class="title-page-name"/></strong><strong class="calibre2">We are inside the loop and main_variable has a value of: 5<br class="title-page-name"/></strong><strong class="calibre2">We are now past the loop and main_variable has a value of: 10</strong>
</pre>
<p class="calibre1"><span><span>As we can see, <kbd class="calibre9">main_variable</kbd> changes inside the subshell, where the loop after the pipe is executed; but it is unaffected on the main shell. Subshells can be really tricky, because you may not realize you are spawning them and so be unaware of what the real outcome will be. Even setting some environment variable will not help us in preventing this issue.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Environment variables</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Let's call it a proof of concept more than a real means to have processes communicate with each other. Who would really want to mess with the environment? Anyway, we are exploring some viable means to IPC, so we can take this in account even though we will not use it in the first instance. Let's have a look at <kbd class="calibre9">env</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">env<br class="title-page-name"/></strong><strong class="calibre2">LS_COLORS=REDACTED<br class="title-page-name"/></strong><strong class="calibre2">XDG_MENU_PREFIX=xfce-<br class="title-page-name"/></strong><strong class="calibre2">LANG=en_GB.utf8<br class="title-page-name"/></strong><strong class="calibre2">DISPLAY=:0.0<br class="title-page-name"/></strong><strong class="calibre2">XDG_VTNR=7<br class="title-page-name"/></strong><strong class="calibre2">SSH_AUTH_SOCK=/tmp/ssh-MgHTC62oCYDp/agent.1121<br class="title-page-name"/></strong><strong class="calibre2">GLADE_CATALOG_PATH=:<br class="title-page-name"/></strong><strong class="calibre2">XDG_SESSION_ID=2<br class="title-page-name"/></strong><strong class="calibre2">XDG_GREETER_DATA_DIR=/var/lib/lightdm/data/zarrelli<br class="title-page-name"/></strong><strong class="calibre2">USER=zarrelli<br class="title-page-name"/></strong><strong class="calibre2">GLADE_MODULE_PATH=:<br class="title-page-name"/></strong><strong class="calibre2">DESKTOP_SESSION=xfce<br class="title-page-name"/></strong><strong class="calibre2">PWD=/home/zarrelli<br class="title-page-name"/></strong><strong class="calibre2">HOME=/home/zarrelli<br class="title-page-name"/></strong><strong class="calibre2">GUAKE_TAB_UUID=b07321dd-a221-41bd-8ecc-0ae94b9082b9<br class="title-page-name"/></strong><strong class="calibre2">SSH_AGENT_PID=1159<br class="title-page-name"/></strong><strong class="calibre2">QT_ACCESSIBILITY=1<br class="title-page-name"/></strong><strong class="calibre2">XDG_SESSION_TYPE=x11<br class="title-page-name"/></strong><strong class="calibre2">XDG_DATA_DIRS=/usr/share/xfce4:/usr/local/share/:/usr/share/:/usr/share<br class="title-page-name"/></strong><strong class="calibre2">XDG_SESSION_DESKTOP=xfce<br class="title-page-name"/></strong><strong class="calibre2">GLADE_PIXMAP_PATH=:<br class="title-page-name"/></strong><strong class="calibre2">GTK_MODULES=gail:atk-bridge<br class="title-page-name"/></strong><strong class="calibre2">TERM=xterm<br class="title-page-name"/></strong><strong class="calibre2">SHELL=/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0<br class="title-page-name"/></strong><strong class="calibre2">XDG_CURRENT_DESKTOP=XFCE<br class="title-page-name"/></strong><strong class="calibre2">QT_LINUX_ACCESSIBILITY_ALWAYS_ON=1<br class="title-page-name"/></strong><strong class="calibre2">SHLVL=1<br class="title-page-name"/></strong><strong class="calibre2">XDG_SEAT=seat0<br class="title-page-name"/></strong><strong class="calibre2">LANGUAGE=en_GB:en<br class="title-page-name"/></strong><strong class="calibre2">GDMSESSION=xfce<br class="title-page-name"/></strong><strong class="calibre2">LOGNAME=zarrelli<br class="title-page-name"/></strong><strong class="calibre2">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus<br class="title-page-name"/></strong><strong class="calibre2">XDG_RUNTIME_DIR=/run/user/1000<br class="title-page-name"/></strong><strong class="calibre2">XAUTHORITY=/home/zarrelli/.Xauthority<br class="title-page-name"/></strong><strong class="calibre2">XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session0<br class="title-page-name"/></strong><strong class="calibre2">XDG_CONFIG_DIRS=/etc/xdg<br class="title-page-name"/></strong><strong class="calibre2">PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games<br class="title-page-name"/></strong><strong class="calibre2">SESSION_MANAGER=local/moveaway:@/tmp/.ICE-unix/1169,unix/moveaway:/tmp/.ICE-unix/1169<br class="title-page-name"/></strong><strong class="calibre2">OLDPWD=/home/zarrelli<br class="title-page-name"/></strong><strong class="calibre2">_=/usr/bin/env</strong>
</pre>
<p class="calibre1"><span><span>We trimmed out the content of the <kbd class="calibre9">LS_COLORS</kbd> variable, but even so, one outstanding issue is that the output is a bit crowded and holds a lot of information, most of it vital for our login session. So, first advice, let's be really cautious when tinkering with the <kbd class="calibre9">environment</kbd> variable.</span></span></p>
<p class="calibre1"><span><span>One thing we must keep in mind is that there is a big difference between a <kbd class="calibre9">shell</kbd> variable and an <kbd class="calibre9">environment</kbd> one; let's see an example:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">a=10<br class="title-page-name"/></strong><strong class="calibre2">b=20<br class="title-page-name"/></strong><strong class="calibre2">echo -e "n"<br class="title-page-name"/></strong><strong class="calibre2">echo "This is the value of a in the main subshell: $a"<br class="title-page-name"/></strong><strong class="calibre2">(a=$((a+b)) ; echo "Inside the nested subshell a now has the value of: $a")<br class="title-page-name"/></strong><strong class="calibre2">echo "Back to the main subshell a has a value of: $a"<br class="title-page-name"/></strong><strong class="calibre2">echo -e "n"<br class="title-page-name"/></strong><strong class="calibre2">echo "And now we will tinker with the environment..."<br class="title-page-name"/></strong><strong class="calibre2">echo "This is the value of a in the main subshell: $a"<br class="title-page-name"/></strong><strong class="calibre2">(<br class="title-page-name"/></strong><strong class="calibre2">export a=$((a+b)) <br class="title-page-name"/></strong><strong class="calibre2">b=$((a+b)) <br class="title-page-name"/></strong><strong class="calibre2">echo "Inside the nested subshell a now has the value of: $a" <br class="title-page-name"/></strong><strong class="calibre2">echo "Inside the nested subshell b now has the value of: $b" <br class="title-page-name"/></strong><strong class="calibre2">echo "The value of the environment variable a is:"<br class="title-page-name"/></strong><strong class="calibre2">env | grep ^a<br class="title-page-name"/></strong><strong class="calibre2">echo "Here is the value of a at this level of subshell using process substitution:"<br class="title-page-name"/></strong><strong class="calibre2">grep ^a &lt;(env)<br class="title-page-name"/></strong><strong class="calibre2">echo "And they are the same, since the nested shell share the environment variables of the parent shell"<br class="title-page-name"/></strong><strong class="calibre2">echo "b is inherited as well: $b"<br class="title-page-name"/></strong><strong class="calibre2">)<br class="title-page-name"/></strong><strong class="calibre2">echo "Back to the main subshell the environment variable a has a value of: $a"<br class="title-page-name"/></strong><strong class="calibre2">echo "Back to the main subshell the shell variable b has a value of: $b"</strong>
</pre>
<p class="calibre1">Executing it, we will get this:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./environment.sh </strong><br class="title-page-name"/><strong class="calibre2">This is the value of a in the main subshell: 10</strong><br class="title-page-name"/><strong class="calibre2">Inside the nested subshell a now has the value of: 30</strong><br class="title-page-name"/><strong class="calibre2">Back to the main subshell a has a value of: 10</strong>
</pre>
<p class="calibre1"><span><span>And now we will tinker with the environment:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">This is the value of a in the main subshell: 10<br class="title-page-name"/></strong><strong class="calibre2">Inside the nested subshell a now has the value of: 30<br class="title-page-name"/></strong><strong class="calibre2">Inside the nested subshell b now has the value of: 50<br class="title-page-name"/></strong><strong class="calibre2">The value of the environment variable a is:<br class="title-page-name"/></strong><strong class="calibre2">a=30<br class="title-page-name"/></strong><strong class="calibre2">Here is the value of a at this level of subshell using process substitution:<br class="title-page-name"/></strong><strong class="calibre2">a=30</strong>
</pre>
<p class="calibre1"><span><span>And they are the same, since the nested shell shared the environment variables of the parent shell:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">b is inherited as well: 50<br class="title-page-name"/></strong><strong class="calibre2">Back to the main subshell the environment variable a has a value of: 10<br class="title-page-name"/></strong><strong class="calibre2">Back to the main subshell the shell variable b has a value of: 20</strong>
</pre>
<p class="calibre1"><span><span>What we get from this example concerns the normal use of variables. There is no real difference between shell and environment variables: both are accessible by sub processes/shells and both are unaffected by subshell manipulations. The real difference stands out when we have a subprocess which is executed by an <kbd class="calibre9">execve()</kbd> system call: in this case, the shell variable is not be passed through. We will have to export it to make it available to the subshell. If we want to have fun, there is something even trickier than this. A new keyword introduced with Bash 4.0 can reveal itself as a nice playground for our experiments.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Coprocesses</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Introduced with Bash 4.0, the coproc keyword allow allows the user to run a process in the background in an asyncronous subshell. During the execution of the process, a pipe is established between the calling shell and the coprocess. The best results are obtained with programs which can be run in a CLI and can read from <kbd class="calibre9">stdin</kbd> and write to <kbd class="calibre9">stdout</kbd>, better if with an unbuffered stream. The syntax for coprocess is here:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">coproc (NAME) command (redirections)</strong>
</pre>
<p class="calibre1"><span><span>The bits within parentheses are optional, but if you specify a name, <kbd class="calibre9">coproc</kbd> will create a coprocess with the name. If no name is given, it will be defaulted to <kbd class="calibre9">COPROC</kbd>; and we must not define any name if the following is a simple command, otherwise it will be treated as the first word of the command. The process ID of the shell executing the coprocess is stored in a variable called </span></span><span><span><kbd class="calibre9">NAME_PID</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Let's see an example:<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ coproc { while true ; do ls ; done }<br class="title-page-name"/></strong><strong class="calibre2">[2] 31067</strong>
</pre>
<p class="calibre1"><span><span>We executed an infinite loop and its <kbd class="calibre9">PID</kbd> is shown as <kbd class="calibre9">31067</kbd>; let's check whether we can read it from <kbd class="calibre9">COPROC_PID</kbd>, which is the default name for the variable when no name has been provided:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo $COPROC_PID<br class="title-page-name"/></strong><strong class="calibre2">31067</strong>
</pre>
<p class="calibre1"><span><span>Here, we can easily get the <kbd class="calibre9">PID</kbd> value from the <kbd class="calibre9">COPROC_PID</kbd> variable. When coprocess is executed the shell instances an array variable named after <kbd class="calibre9">NAME</kbd>, which holds two pieces of information:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">NAME[0]</strong>: This holds the output file descriptor for coprocess</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">NAME[1]</strong>: This holds the input file descriptor for coprocess</span></span></li>
</ul>
<p class="calibre1"><span><span>So, we can read and write using the file descriptors, which in our example are here:</span></span></p>
<p class="calibre1"> </p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo ${COPROC[0]}<br class="title-page-name"/></strong><strong class="calibre2">62<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ echo ${COPROC[1]}<br class="title-page-name"/></strong><strong class="calibre2">58</strong>
</pre>
<p class="calibre1"><span><span>Another way to see what files are open for the current process is this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">ls -lah /proc/PID/fd</strong>
</pre>
<p class="calibre1"><span><span>In our case, do this:</span></span></p>
<p class="calibre1"> </p>
<pre class="codepackt">
<strong class="calibre2">ls -la /proc/31067/fd<br class="title-page-name"/></strong><strong class="calibre2">total 0<br class="title-page-name"/></strong><strong class="calibre2">dr-x------ 2 zarrelli zarrelli 0 Apr 11 16:37 .<br class="title-page-name"/></strong><strong class="calibre2">dr-xr-xr-x 9 zarrelli zarrelli 0 Apr 11 15:13 ..<br class="title-page-name"/></strong><strong class="calibre2">lr-x------ 1 zarrelli zarrelli 64 Apr 11 16:37 0 -&gt; pipe:[615372]<br class="title-page-name"/></strong><strong class="calibre2">l-wx------ 1 zarrelli zarrelli 64 Apr 11 16:37 1 -&gt; pipe:[615371]<br class="title-page-name"/></strong><strong class="calibre2">lrwx------ 1 zarrelli zarrelli 64 Apr 11 16:37 2 -&gt; /dev/pts/0<br class="title-page-name"/></strong><strong class="calibre2">lrwx------ 1 zarrelli zarrelli 64 Apr 11 16:37 255 -&gt; /dev/pts/0<br class="title-page-name"/></strong><strong class="calibre2">l-wx------ 1 zarrelli zarrelli 64 Apr 11 16:37 60 -&gt; pipe:[608200]<br class="title-page-name"/></strong><strong class="calibre2">lr-x------ 1 zarrelli zarrelli 64 Apr 11 16:37 63 -&gt; pipe:[608199]</strong>
</pre>
<p class="calibre1">These pipes are in place before any redirection a user could specify on the command line, so the file descriptors can be used as arguments for the commands issued on the command line, and redirections can be used to feed or retrieve data; but beware that the file descriptors do not get inherited by subshells. That said, we can feed data to coprocess simply using the following syntax:</p>
<pre class="codepackt">
<strong class="calibre2">echo data &gt;&amp;"${COPROC[1]}"</strong>
</pre>
<p class="calibre1"><span><span>While we can use <kbd class="calibre9">read</kbd> to retrieve data from coprocess as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">read variable &lt;&amp;"${COPROC[0]}"</strong>
</pre>
<p class="calibre1"><span><span>Before having a look a simple example, we have to keep in mind a few points:</span></span></p>
<ul class="calibre12">
<li class="calibre13">Most of the commands in Linux are buffered when used without a user interaction. And this fools us into reading from the <kbd class="calibre9">coproc</kbd> file descriptors. To make some simple experiments, the <kbd class="calibre9">bc</kbd> util works fine; or use <kbd class="calibre9">awk</kbd> with <kbd class="calibre9">fflush()</kbd> or the <kbd class="calibre9">unbuffer</kbd> command from the <kbd class="calibre9">expect</kbd> package to have unbuffered output.</li>
<li class="calibre13">There can be only one active coproc at time.</li>
<li class="calibre13">We can use the <kbd class="calibre9">wait</kbd> built-in to wait for coprocess to terminate.</li>
</ul>
<p class="calibre1"><span><span>That said, let's see how can we can interact with a process in the background:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">coproc bc_calc { bc; }<br class="title-page-name"/></strong><strong class="calibre2">in=${bc_calc[1]}<br class="title-page-name"/></strong><strong class="calibre2">out=${bc_calc[0]}<br class="title-page-name"/></strong><strong class="calibre2">echo '10*20' &gt;&amp;$in<br class="title-page-name"/></strong><strong class="calibre2">read -u $out myvar<br class="title-page-name"/></strong><strong class="calibre2">echo $myvar</strong>
</pre>
<p class="calibre1"><span><span>To trick <kbd class="calibre9">coproc</kbd> into letting us use a name we created a list with only one command followed by <kbd class="calibre9">;</kbd> then we made it a bit easier to work with file descriptors, storing them in two meaningful variables. So, we will not fiddle with <kbd class="calibre9">0</kbd> and <kbd class="calibre9">1</kbd>. In the next step, we echoed a <kbd class="calibre9">bc</kbd> multiplication to the <kbd class="calibre9">stdin</kbd> of <kbd class="calibre9">bc</kbd> using its file descriptor, and read it with the <kbd class="calibre9">-u</kbd> option, which is exactly the option needed for reading from file descriptors. As the last step, we printed the out variable in which we previously stored the result of the multiplication, printed by <kbd class="calibre9">bc</kbd> on its standard output.</span></span></p>
<p class="calibre1"><span><span>There is actually one last way to make different processes talk to each other; can we recall it? Yes, we already saw it at the very beginning of this book.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">/dev/tcp and /dev/udp</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>If we look inside the <kbd class="calibre9">/dev</kbd> directory, we find lots of files that represent physical devices that can be hardware or not. These device files can represent partitions; loopback is used to access plain files as if they were block devices. ISO files, for example, can be mounted as if they were CD-ROMs. Some of this device files are quite unusual, but we have already heard of them, for instance, </span></span><span><span><kbd class="calibre9">/dev/null</kbd>, </span></span><span><span><kbd class="calibre9">/dev/zero</kbd>, </span></span><span><span><kbd class="calibre9">/dev/urandom</kbd>, </span></span><span><span><kbd class="calibre9">/dev/tcp</kbd>, and </span></span><span><span><kbd class="calibre9">/dev/tcp</kbd>.</span></span></p>
<p class="calibre1"><span><span>These are called pseudo-devices, and they represent and provide access to some <em class="calibre20">facilities</em>. For instance, all this is moved or redirected to the <kbd class="calibre9">/dev/null</kbd> fall in a <em class="calibre20">black hole</em> and disappears, whereas <kbd class="calibre9">/dev/urandom</kbd> is a good way to get a random string when needed:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">cat /dev/urandom | head -c 25 | base64<br class="title-page-name"/></strong><strong class="calibre2">HwUmcXt0zr6a7puLtO1xyKMrAdZrRqIrgw==</strong>
</pre>
<p class="calibre1"><span><span>With <kbd class="calibre9">/dev/tcp</kbd> or <kbd class="calibre9">/dev/udp</kbd>, we get access to a socket through which we can communicate to network services locally or remotely. For our examples, we will focus on TCP sockets, since they are more interesting to use for our experiments.</span></span></p>
<p class="calibre1"><span><span>Then what is a socket? Imagine a socket as a pipe between two multistorey buildings. To put this pipe in place, you have to know the civic number of each building and which floor of one must be connected to which floor of the other. The same is for a network socket which is identified by two tuples:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">origin_ip:origin_port<br class="title-page-name"/></strong><strong class="calibre2">destination_ip:destination_port</strong>
</pre>
<p class="calibre1"><span><span>So, Bash is able to set up a connection to a network service as long as we provide at least the remote end of the communication channel, the IP or hostname, and the port to cling to. Easy, isn't it, but how to do it? The right syntax is the following:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">exec file_descriptor_number &lt;&gt; /dev/tcp/ip/port</strong>
</pre>
<p class="calibre1"><span><span><kbd class="calibre9">&lt;</kbd> means opening the socket for reading, <kbd class="calibre9">&gt;</kbd> for writing, and <kbd class="calibre9">&lt;&gt;</kbd> for both. There isn't a big difference between the IP or hostname, but we must pay attention to which file descriptors we are going to use. We have 10 file descriptors available, from 0 to 9, but since, </span></span><span><span><kbd class="calibre9">0 = stdin</kbd>, </span></span><span><span><kbd class="calibre9">1 = stdout</kbd>, </span></span><span><span><kbd class="calibre9">2 = stderr</kbd> </span></span><span><span>are already bound, we cannot use them. So, we are left with seven file descriptors, from 3 to 9. So, let's try an easy example:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">cat &lt;/dev/tcp/time.ien.it/13<br class="title-page-name"/></strong><strong class="calibre2">11 APR 2017 22:00:46 CEST</strong>
</pre>
<p class="calibre1"><span><span>We just read the time over the internet, connecting to an Italian time server in an easy way, but we can do something even more complicated; let's recall an example we made in the first chapter.</span></span></p>
<p class="calibre1"><span><span>Let's open a socket in read/write mode to a web server and assign a file descriptor called <kbd class="calibre9">9</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ exec 9&lt;&gt; /dev/tcp/172.16.210.128/80 || exit 1</strong>
</pre>
<p class="calibre1"><span><span>Then, we are going to write a request to it using the HTTP/1.1 syntax as if we were a real web browser:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ printf 'GET /index2.html HTTP/1.1nHost: 172.16.210.128nConnection: closenn' &gt;&amp;9</strong>
</pre>
<p class="calibre1"><span><span>We just requested a simple HTML file created for this example; so since we requested it, it is time to read this page through the file descriptor called <kbd class="calibre9">9</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat &lt;&amp;9<br class="title-page-name"/></strong><strong class="calibre2">HTTP/1.1 200 OK<br class="title-page-name"/></strong><strong class="calibre2">Date: Sat, 21 Jan 2017 17:57:33 GMT<br class="title-page-name"/></strong><strong class="calibre2">Server: Apache/2.4.10 (Debian)<br class="title-page-name"/></strong><strong class="calibre2">Last-Modified: Sat, 21 Jan 2017 17:57:12 GMT<br class="title-page-name"/></strong><strong class="calibre2">ETag: "f3-5469e7ef9e35f"<br class="title-page-name"/></strong><strong class="calibre2">Accept-Ranges: bytes<br class="title-page-name"/></strong><strong class="calibre2">Content-Length: 243<br class="title-page-name"/></strong><strong class="calibre2">Vary: Accept-Encoding<br class="title-page-name"/></strong><strong class="calibre2">Connection: close<br class="title-page-name"/></strong><strong class="calibre2">Content-Type: text/html<br class="title-page-name"/></strong><strong class="calibre2">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"<br class="title-page-name"/></strong><strong class="calibre2">"http://www.w3.org/TR/html4/strict.dtd"&gt;<br class="title-page-name"/></strong><strong class="calibre2">&lt;HTML&gt;<br class="title-page-name"/></strong><strong class="calibre2">&lt;HEAD&gt;<br class="title-page-name"/></strong><strong class="calibre2">&lt;TITLE&gt;This is a test file&lt;/TITLE&gt;<br class="title-page-name"/></strong><strong class="calibre2">&lt;/HEAD&gt;<br class="title-page-name"/></strong><strong class="calibre2">&lt;BODY&gt;<br class="title-page-name"/></strong><strong class="calibre2">&lt;P&gt;And we grabbed it through our descriptor!<br class="title-page-name"/></strong><strong class="calibre2">&lt;/BODY&gt;<br class="title-page-name"/></strong><strong class="calibre2">&lt;/HTML&gt;</strong>
</pre>
<p class="calibre1"><span><span>Here, we could interact with a remote server as if it was a local file, using <kbd class="calibre9">print</kbd> and <kbd class="calibre9">cat</kbd> to push and pull content. All locally, but definitely remotely.</span></span></p>
<p class="calibre1"><span><span>There is indeed one last way to have fun when we want to tinker with IPC; even though this is not a proper IPC means, it is so much fun that we cannot avoid talking about Netcat.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Netcat</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We could even never have been using this tool but no one probably can say they never heard about it being called the <em class="calibre20">TCP/IP Swiss army knife</em> and that for its versatility. You can literally have hours of fun just exploring all the possibilities it enables. That said, <kbd class="calibre9">netcat</kbd> is a utility, which reads and writes over the network using either TCP or UDP protocol; and what makes it really handy is its ability to keep up the connection until the remote side of the connection is shut down. This makes it different from most of the applications, which just stop working after the last bit of data has been delivered. <kbd class="calibre9">netcat</kbd> is different; it keeps both ends of the communication channel in touch even if there is nothing passing through, so you can use it for repeated dispatches.</span></span></p>
<p class="calibre1"><span><span>The Netcat can be used either in a server or client mode and from inside scripts too by adding network facilities to them. So many things, but the best way to understand what we can do with it is to run some examples. So, the first step will be opening a connection to a remote server inside a term, which can be split in two panels such as <em class="calibre20">terminator.</em> Last bit, remember that Netcat cannot be installed by default on our system, but distributions have a package for it. So, once the utility is installed, let's open two <kbd class="calibre9">xterm</kbd>, or split terminators into two panels and connect to a remote server. On the remote server, check for an open port, usually something around <kbd class="calibre9">8000</kbd> (<kbd class="calibre9">8080</kbd> being a port widely used for proxies) or <kbd class="calibre9">9000</kbd> would be nice; a command like this executed as root can tell us whether the port we are looking for is available:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# netstat -tapnl | grep 9000</strong>
</pre>
<p class="calibre1"><span><span>Netstat simply lists all the tcp ports in listen mode, showing the numeric port numbers; and then we grep over the port we want to check. If it returns nothing, the port is free. Second step, often forgotten, is that we are sure the port is not blocked by our local firewall. This is because we are mastering Bash and <em class="calibre20">have</em> a firewall in place even on our local desktop. We will talk more about securing our boxes later on, but, for now, let's assume we have a simple but reliable firewall in place such as <kbd class="calibre9">ufw</kbd>. To enable port <kbd class="calibre9">900</kbd> , we can just give the following command:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ufw allow 9000/tcp<br class="title-page-name"/></strong><strong class="calibre2">Rule added<br class="title-page-name"/></strong><strong class="calibre2">Rule added (v6)</strong>
</pre>
<p class="calibre1"><span><span>Rule added, it is the sixth in our chain, but it can have any other number depending on how many other rules you have. Remember that to delete a rule, you just have to run this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# ufw delete 6<br class="title-page-name"/></strong><strong class="calibre2">Deleting:<br class="title-page-name"/></strong><strong class="calibre2">allow 9000/tcp<br class="title-page-name"/></strong><strong class="calibre2">Proceed with operation (y|n)? y<br class="title-page-name"/></strong><strong class="calibre2">Rule deleted</strong>
</pre>
<p class="calibre1"><span><span>We used the rule number; you can use the rule name <kbd class="calibre9">allow 9000/tcp</kbd> as you wish. Now that we have a free port unblocked, we can run <kbd class="calibre9">netcat</kbd> in listening mode on the remote server:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# netcat -lvvp 9000<br class="title-page-name"/></strong><strong class="calibre2">listening on [any] 9000 ...</strong>
</pre>
<p class="calibre1"><span><span>This will start <kbd class="calibre9">netcat</kbd> in listening mode, and <kbd class="calibre9">-l</kbd> will be ready to accept connections on port <kbd class="calibre9">-p 9000</kbd> in a verbose detailed mode <kbd class="calibre9">-vv</kbd>. We will not have our prompt back because <kbd class="calibre9">netcat</kbd> keeps running in the foreground, monopolizing the terminal. Now, on the local system, let's run <kbd class="calibre9">netcat</kbd> in client mode:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ nc -vv 192.168.0.10 9000<br class="title-page-name"/></strong><strong class="calibre2">spoton [192.168.0.10] 9000 (?) open</strong>
</pre>
<p class="calibre1"><span><span>Great, the connection is opened on both sides. Notice that we invoked Netcat both with the <kbd class="calibre9">netcat</kbd> command and <kbd class="calibre9">nc;</kbd> we can choose whatever we prefer. Once the connection is established, we will see a message like this on the listening side:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">192.168.0.5: inverse host lookup failed: Unknown host<br class="title-page-name"/></strong><strong class="calibre2">connect to [192.168.0.10] from (UNKNOWN) [192.168.0.5] 60054</strong>
</pre>
<p class="calibre1"><span><span>The message called <kbd class="calibre9">Unknown host</kbd> must not bother us; Netcat makes a reverse lookup to check the hostname the connection is coming from. Being a test environment we did not set any internal DNS resolution. If you do not want to tinker with DNS, a simple solution is to open the </span></span><span><span><kbd class="calibre9">/etc/hosts</kbd> </span></span><span><span>file on the server side operating system and add a line such as </span></span><span><span><kbd class="calibre9">192.168.0.5 spoton</kbd>.</span></span></p>
<p class="calibre1"><span><span>Being <kbd class="calibre9">192.168.0.t</kbd> the IP address of the client the connection is coming from and <kbd class="calibre9">spoton</kbd> the hostname we want it to be identified and resolved by <kbd class="calibre9">netcat</kbd> on the server side. If you don't want the DNS resolution, add <kbd class="calibre9">-n</kbd> on the server and the client side, and you will work with IP. So now, let's retry the connection:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# netcat -lvvp 9000<br class="title-page-name"/></strong><strong class="calibre2">listening on [any] 9000 ...<br class="title-page-name"/></strong><strong class="calibre2">connect to [192.168.0.10] from spoton [192.168.0.5] 60176</strong>
</pre>
<p class="calibre1"><span><span>This looks better, doesn't it? Let's just type something on the client, and whatever we input will be echoed on the server side. We can pause and type at a later time; meanwhile, the channel will be up and running waiting for our input:</span></span></p>
<div class="packt_figure"><span><span><img class="image-border32" src="../images/00043.jpeg"/><br class="title-page-name"/></span></span></div>
<p class="calibre1"><span><span>The client is on the left panel and gets echoed on the right panel, onto the server side. </span></span><span><span>Now something spooky; on the server side, type this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# netcat -lvvp 9000 -c /bin/date<br class="title-page-name"/></strong><strong class="calibre2">listening on [any] 9000 ...</strong>
</pre>
<p class="calibre1"><span><span>What we just did is use the <kbd class="calibre9">-c</kbd> switch to tell <kbd class="calibre9">netcat</kbd> to execute right after the connection the command specified as argument. The command will be passed to <kbd class="calibre9">/bin/sh -c</kbd> for execution with no further check, and if you do not have the <kbd class="calibre9">sh</kbd> shell installed, just use <kbd class="calibre9">-e</kbd> to have the command executed. Now, on the client side, let's execute this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ nc -vv 192.168.0.10 9000<br class="title-page-name"/></strong><strong class="calibre2">spoton [192.168.0.10] 9000 (?) open<br class="title-page-name"/></strong><strong class="calibre2">Wed 12 Apr 11:14:07 BST 2017<br class="title-page-name"/></strong><strong class="calibre2">sent 0, rcvd 29</strong>
</pre>
<p class="calibre1"><span><span>The connection has been established right after the <kbd class="calibre9">date</kbd> command has been issued; so, in our client, we can see the output of the command and the date and time on the server side. It does not seem spooky, does it? It is just <kbd class="calibre9">date</kbd>, what harm can it do? Okay, let's modify the server argument and be ready to freak out:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:# netcat -lvvp 9000 -c /bin/bash<br class="title-page-name"/></strong><strong class="calibre2">listening on [any] 9000 ...</strong>
</pre>
<p class="calibre1"><span><span>Interesting, at each connection, we will execute a Bash shell. Let's open it on the client side:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ nc -vv 192.168.0.10 9000<br class="title-page-name"/></strong><strong class="calibre2">spoton [192.168.0.10] 9000 (?) open</strong>
</pre>
<p class="calibre1"><span><span>Now, let's give some innocent commands in the client:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">date<br class="title-page-name"/></strong><strong class="calibre2">Wed 12 Apr 11:21:02 BST 2017</strong>
</pre>
<p class="calibre1"><span><span>Okay, this is a date, but where are we?</span></span></p>
<pre class="codepackt">
<strong class="calibre2">pwd<br class="title-page-name"/></strong><strong class="calibre2">/root</strong>
</pre>
<p class="calibre1"><span><span>Nice, but who are we?</span></span></p>
<pre class="codepackt">
<strong class="calibre2">whoami<br class="title-page-name"/></strong><strong class="calibre2">root</strong>
</pre>
<p class="calibre1"><span><span>So, we are <kbd class="calibre9">root</kbd> but on which side?</span></span></p>
<pre class="codepackt">
<strong class="calibre2">hostname -I | awk '{print $1}'<br class="title-page-name"/></strong><strong class="calibre2">192.168.0.10</strong>
</pre>
<p class="calibre1"><span><span>Ouch, we are <kbd class="calibre9">root</kbd> on the server, and we issued commands as a superuser with no authentication required. Since this is really dangerous, use this option with extreme care. Maybe just for fun and testing and nothing else, we just showed it to highlight the potentials and the risks.</span></span></p>
<p class="calibre1"><span><span>What else can we do? Let's create a file on the client side:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo “Here I am, a test file” &gt; testfile.txt</strong>
</pre>
<p class="calibre1"><span><span>On the server side, let's start <kbd class="calibre9">netcat</kbd>, this time with no verbose mode since we do not need it if you do not want to debug the connection and redirect the output to <kbd class="calibre9">testfile.txt</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ netcat -lp 9000 &gt; testfile.txt</strong>
</pre>
<p class="calibre1"><span><span>We used unprivileged users. We do not need to use <kbd class="calibre9">root</kbd> if we do not want to bind the so-called reserved or system ports; the ports below <kbd class="calibre9">1024</kbd> are used for providing service, such as<kbd class="calibre9">22</kbd> for SSH, <kbd class="calibre9">80</kbd> for HTTP, and so forth.</span></span></p>
<p class="calibre1"><span><span>Now, back on the client side, let's feed the client with the content of <kbd class="calibre9">testfile</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat testfile.txt | nc -w2 192.168.0.10 9000</strong>
</pre>
<p class="calibre1"><span><span>We added a timeout of 2 seconds for the connection so that once the file content is dispatched, it will close the connection after 3 seconds. Once on the server side, we see this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">connect to [192.168.0.10] from spoton [192.168.0.5] 32912<br class="title-page-name"/></strong><strong class="calibre2">sent 0, rcvd 29</strong>
</pre>
<p class="calibre1"><span><span>We are done and we just have to interrupt Netcat with a <em class="calibre20">Ctrl </em>+ <em class="calibre20">C </em>and check the content of <kbd class="calibre9">filetest.txt</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat testfile.txt <br class="title-page-name"/></strong><strong class="calibre2">“Here I am, a test file”</strong>
</pre>
<p class="calibre1"><span><span>And that's it, the content of the file has been transferred to the server and saved on <kbd class="calibre9">testfile.txt</kbd>. But what if we wanted to transfer whole directories or bunches of file? We cannot adopt the same strategy because all the output would be redirected to a single file, and this won't work. So, on the server side, let's first create a test <kbd class="calibre9">dir</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ mkdir test<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ cd test</strong>
</pre>
<p class="calibre1"><span><span>Now, let's run Netcat:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ nc -lvvp 9000 | tar -xpzf -</strong>
</pre>
<p class="calibre1"><span><span>This will run <kbd class="calibre9">tar</kbd> on the input with the following:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">x</kbd>: It extracts files from the archive received in input</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">p</kbd>: It preserves permissions on files</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">z</kbd>: It filters the received archive through <kbd class="calibre9">gzp</kbd>, essentially uncrompressing it</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">f</kbd>: File archive to work on. In our case everything goes to the <kbd class="calibre9">stdout</kbd></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">-</kbd>: The last dash means it will work on the data coming from the <kbd class="calibre9">stdin</kbd> instead of looking for a file on the filesystem</span></span></li>
</ul>
<p class="calibre1"><span><span>On the client side, let's enter a directory with some files and subdirectories we want to transfer and have a look at their properties:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -lah<br class="title-page-name"/></strong><strong class="calibre2">total 44K<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 4 zarrelli zarrelli 4.0K Apr 12 11:54 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 4 zarrelli zarrelli 4.0K Apr 12 12:56 ..<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 11 Apr 10 09:20 controller<br class="title-page-name"/></strong><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 121 Apr 11 18:30 coproc.sh<br class="title-page-name"/></strong><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 961 Apr 11 12:19 environment.sh<br class="title-page-name"/></strong><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 382 Apr 11 10:08 looping.sh<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Apr 10 09:20 myfile.txt<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 122 Apr 10 09:20 myfile.txt.tgz<br class="title-page-name"/></strong><strong class="calibre2">prw-r--r-- 1 zarrelli zarrelli 0 Apr 9 13:05 mypipefile<br class="title-page-name"/></strong><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 223 Apr 9 12:44 pipe.sh<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Apr 10 12:20 test 1<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Apr 10 12:20 test 2<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 29 Apr 12 12:06 testfile.txt</strong>
</pre>
<p class="calibre1"><span><span>Now, on the client side, let's run Netcat:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">tar czf - * | nc -vw2 192.168.0.10 9000</strong>
</pre>
<p class="calibre1"><span><span>The <kbd class="calibre9">tar</kbd> command is executed with the following: </span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">c</kbd>: Create an archive.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">z</kbd>: Compress it filtering through <kbd class="calibre9">gzip</kbd>.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">f</kbd>: File archive to work on. In our case, it will get the name from the input.</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">-</kbd>: The last dash means it will work on the data coming from the <kbd class="calibre9">stdin</kbd> instead of looking for a file on the filesystem.</span></span></li>
</ul>
<p class="calibre1"><span><span>We gave all the visible files and directories as input to <kbd class="calibre9">tar</kbd>; we could also use single or multiple files and directory names if we just wanted to copy a few of them. Once the command is given, we should see something like this on the server side:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">connect to [192.168.0.10] from spoton [192.168.0.5] 33022<br class="title-page-name"/></strong><strong class="calibre2">sent 0, rcvd 1352</strong>
</pre>
<p class="calibre1"><span><span>It seems the files and directories have been transferred. Let's exit Netcat and check this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -lah<br class="title-page-name"/></strong><strong class="calibre2">total 44K<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 4 zarrelli zarrelli 4.0K Apr 12 12:35 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 70 zarrelli zarrelli 4.0K Apr 12 12:33 ..<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 11 Apr 10 09:20 controller<br class="title-page-name"/></strong><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 121 Apr 11 18:30 coproc.sh<br class="title-page-name"/></strong><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 961 Apr 11 12:19 environment.sh<br class="title-page-name"/></strong><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 382 Apr 11 10:08 looping.sh<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Apr 10 09:20 myfile.txt<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 122 Apr 10 09:20 myfile.txt.tgz<br class="title-page-name"/></strong><strong class="calibre2">prw-r--r-- 1 zarrelli zarrelli 0 Apr 9 13:05 mypipefile<br class="title-page-name"/></strong><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 223 Apr 9 12:44 pipe.sh<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Apr 10 12:20 test 1<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Apr 10 12:20 test 2<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 29 Apr 12 12:06 testfile.txt</strong>
</pre>
<p class="calibre1"><span><span>That's it, all the files and directories are copied and permissions preserved. There are so many things we can do with Netcat that probably it would deserve a book on its own; we are just scratching the surface and having fun:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ netcat -z -w 1 -vv 192.168.0.10 22<br class="title-page-name"/></strong><strong class="calibre2">spoton [192.168.0.10] 22 (ssh) open<br class="title-page-name"/></strong><strong class="calibre2">sent 0, rcvd 0</strong>
</pre>
<p class="calibre1"><span><span>We can just use it as a simple port scanner with <kbd class="calibre9">-z</kbd>, which will prevent the reception of any data from the remote server and <kbd class="calibre9">-w 1</kbd> to timeout the connection in case the remote port does not provide a reply. You can add <kbd class="calibre9">-n</kbd> to prevent the DNS resolution and specify a port not only by its number but also with its name or specify a range of ports to be checked specifying <em class="calibre20">lower_port_number:higher_port_number</em>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ netcat -z -w 1 -vv 192.168.0.10 https<br class="title-page-name"/></strong><strong class="calibre2">spoton [192.168.0.10] 443 (https) : Connection timed out<br class="title-page-name"/></strong><strong class="calibre2">sent 0, rcvd 0</strong>
</pre>
<p class="calibre1"><span>If we do not know or remember the ports associated to the main services, we can retrieve a list from the <kbd class="calibre9">/etc/services</kbd> file.</span></p>
<p class="calibre1"><span><span>Well, do we need a proxy?</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ncat -l 9999 -c 'nc 192.168.0.10 80'</strong>
</pre>
<p class="calibre1"><span><span>In this case, we used <kbd class="calibre9">ncat</kbd>, a sort of Netcat on steroids, which can overcome a limit in Netcat. It has a one direction pipe, so we can send but not read from the server while proxying. Once <kbd class="calibre9">ncat</kbd> executes Netcat, managing the flow, we can connect to port <kbd class="calibre9">9999</kbd> on localhost and ask for a page:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">telnet localhost 9999<br class="title-page-name"/></strong><strong class="calibre2">Trying ::1...<br class="title-page-name"/></strong><strong class="calibre2">Connected to localhost.<br class="title-page-name"/></strong><strong class="calibre2">Escape character is '^]'.<br class="title-page-name"/></strong><strong class="calibre2">GET / HTTP/1.1<br class="title-page-name"/></strong><strong class="calibre2">Host: 192.168.0.10<br class="title-page-name"/></strong><strong class="calibre2">Connection: close<br class="title-page-name"/></strong><strong class="calibre2">HTTP/1.1 200 OK<br class="title-page-name"/></strong><strong class="calibre2">Date: Wed, 12 Apr 2017 12:41:02 GMT<br class="title-page-name"/></strong><strong class="calibre2">Server: Apache/2.4.10 (Debian)<br class="title-page-name"/></strong><strong class="calibre2">Last-Modified: Thu, 01 Dec 2016 18:52:27 GMT<br class="title-page-name"/></strong><strong class="calibre2">ETag: "29cd-5429d52a85057"<br class="title-page-name"/></strong><strong class="calibre2">Accept-Ranges: bytes<br class="title-page-name"/></strong><strong class="calibre2">Content-Length: 10701<br class="title-page-name"/></strong><strong class="calibre2">Vary: Accept-Encoding<br class="title-page-name"/></strong><strong class="calibre2">Connection: close<br class="title-page-name"/></strong><strong class="calibre2">Content-Type: text/html<br class="title-page-name"/></strong><strong class="calibre2">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;<br class="title-page-name"/></strong><strong class="calibre2">&lt;html &gt;</strong>
</pre>
<p class="calibre1"><span><span>We just cut a part of the output with the whole page and highlighted the commands we gave to retrieve the page. Anyway, instead of <kbd class="calibre9">ncat</kbd>, we could use Netcat with a named pipe:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ mkfifo mypipe</strong>
</pre>
<p class="calibre1"><span><span>Then, simply use the output redirection to have a bidirectional channel:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ nc -l 9999 0&lt;mypipe | nc 192.168.0.10 80 1&gt;mypipe</strong>
</pre>
<p class="calibre1"><span><span>Now, telnet to localhost on port <kbd class="calibre9">9999</kbd> and perform the same get as in the other example or, better, fire up your internet browser and point it to </span></span><kbd class="calibre9"><span><span>http://localhost:9999</span></span></kbd><span><span>.</span></span></p>
<p class="calibre1"><span><span>One more thing before leaving this chapter, did you ever fancy a quick, easy server at your disposal? Let's start creating a small HTML page:</span></span></p>
<pre class="codepackt">
<span><span>&lt;!doctype html&gt;<br class="title-page-name"/></span></span><span><span>&lt;html lang="en"&gt;<br class="title-page-name"/></span></span><span><span>&lt;head&gt;<br class="title-page-name"/></span></span><span><span>&lt;meta charset="utf-8"&gt;<br class="title-page-name"/></span></span><span><span>&lt;title&gt;My Netcat Test Page&lt;/title&gt;<br class="title-page-name"/></span></span><span><span>&lt;meta name="description" content="Test page for Netcat HTTP server"&gt;<br class="title-page-name"/></span></span><span><span>&lt;meta name="author" content="Giorgio Zarrelli"&gt;<br class="title-page-name"/></span></span><span><span>&lt;link rel="stylesheet" href="css/styles.css?v=1.0"&gt;<br class="title-page-name"/></span></span><span><span>&lt;/head&gt;<br class="title-page-name"/></span></span><span><span>&lt;body&gt;<br class="title-page-name"/></span></span><span><span>Hello I am a test page for Netcat used as HTTP server<br class="title-page-name"/></span></span><span><span>&lt;/body&gt;<br class="title-page-name"/></span></span><span><span>&lt;/html&gt;</span></span>
</pre>
<p class="calibre1"><span><span>Now, an infinite loop will help Netcat to serve us the page:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">while true; do nc -lp 9999 &lt; my_index.html; done</strong>
</pre>
<p class="calibre1"><span><span>Last step, let's open <kbd class="calibre9">http://localhost:9999</kbd> in our favorite internet browser.</span></span></p>
<p class="calibre1"><span><span>The page will be served because it was pushed by a web server, as we can see from the following screenshot:</span></span></p>
<div class="packt_figure"><span><span><img class="image-border33" src="../images/00044.jpeg"/><br class="title-page-name"/></span></span></div>
<p class="calibre1"><span><span>The HTML page we just created is being served as if it was pushed by a real web server.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Letting services talk to each other is not so difficult and can be real fun, especially if we know how to redirect the flows and spice things up with the right tools. Did we see everything Bash has to offer regarding IPC? No, and this is one of the best things about the shell: we can accomplish the same task in different ways, and there are so many things to do that a chapter would not be enough. Once again, this is the best thing in shell: we start off with some examples, learn how to work with the commands and utilities, and then expand our knowledge trying new experiments, tinkering with options and arguments, and mastering the tools we have been offered.</span></span></p>
<p class="calibre1"><span><span>We pushed IPC so far that Netcat became a simple web server, pushing a page over the network so that we could actually display it in a browser. This is amazing, and it is quite the limit of what Bash can do, but we will try to stretch these boundaries in the next chapter by taking a look at how we can create simple daemons and offer services with Bash.</span></span></p>


            </article>

            
        </section>
    </body></html>