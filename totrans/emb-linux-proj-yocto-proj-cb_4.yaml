- en: Chapter 4. Application Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：应用程序开发
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下配方：
- en: Introducing toolchains
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍工具链
- en: Preparing and using an SDK
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备和使用 SDK
- en: Using the Application Development Toolkit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序开发工具包
- en: Using the Eclipse IDE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Eclipse IDE
- en: Developing GTK+ applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 GTK+ 应用程序
- en: Using the Qt Creator IDE
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt Creator IDE
- en: Developing Qt applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 Qt 应用程序
- en: Describing workflows for application development
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述应用程序开发的工作流
- en: Working with GNU make
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GNU make
- en: Working with the GNU build system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GNU 构建系统
- en: Working with the CMake build system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake 构建系统
- en: Working with the SCons builder
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SCons 构建工具
- en: Developing with libraries
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库进行开发
- en: Working with the Linux framebuffer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Linux 帧缓冲区
- en: Using the X Windows system
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 X Windows 系统
- en: Using Wayland
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Wayland
- en: Adding Python applications
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 Python 应用程序
- en: Integrating the Oracle Java Runtime Environment
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Oracle Java 运行时环境
- en: Integrating the Open Java Development Kit
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Open Java 开发工具包
- en: Integrating Java applications
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Java 应用程序
- en: Introduction
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Dedicated applications are what define an embedded product, and Yocto offers
    helpful application development tools as well as the functionality to integrate
    with popular **Integrated Development Environments** (**IDE**) like Eclipse and
    Qt Creator. It also provides a wide range of utility classes to help in the integration
    of finished applications into the build system and the target images.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 专用应用程序是定义嵌入式产品的关键，Yocto 提供了有用的应用程序开发工具，以及与流行的 **集成开发环境**（**IDE**）如 Eclipse 和
    Qt Creator 集成的功能。它还提供了广泛的工具类，帮助将完成的应用程序集成到构建系统和目标映像中。
- en: This chapter will introduce the IDEs and show us how they are used to build
    and debug C and C++ applications on real hardware, and will explore application
    development, including graphical frameworks and Yocto integration, not only for
    C and C++ but also Python and Java applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 IDE，并向我们展示如何在真实硬件上使用它们构建和调试 C 和 C++ 应用程序，同时探索应用程序开发，包括图形框架和 Yocto 集成，不仅适用于
    C 和 C++，还包括 Python 和 Java 应用程序。
- en: Introducing toolchains
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍工具链
- en: A toolchain is a set of tools, binaries, and libraries used to build applications
    to run on a computer platform. In Yocto, the toolchains are based on GNU components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是一组用于构建应用程序以在计算机平台上运行的工具、二进制文件和库。在 Yocto 中，工具链基于 GNU 组件。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'A GNU toolchain contains the following components:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 GNU 工具链包含以下组件：
- en: '**Assembler (GNU as)**: This is part of the binutils package'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇编器（GNU as）**：这是 binutils 包的一部分'
- en: '**Linker (GNU ld)**: This is also part of the binutils package'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接器（GNU ld）**：这也是 binutils 包的一部分'
- en: '**Compiler (GNU gcc)**: This has support for C, C++, Java, Ada, Fortran, and
    Objective C'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器（GNU gcc）**：支持 C、C++、Java、Ada、Fortran 和 Objective C'
- en: '**Debugger (GNU gdb)**: This is the GNU debugger'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器（GNU gdb）**：这是 GNU 调试器'
- en: '**Binary file tools (objdump, nm, objcopy, readelf, strip, and so on)**: These
    are part of the binutils package.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制文件工具（objdump、nm、objcopy、readelf、strip 等）**：这些是 binutils 包的一部分。'
- en: These components are enough to build bare metal applications, bootloaders like
    U-Boot, or operating systems like the Linux kernel, as they don't need a C library
    and they implement the C library functions they need. However, for Linux user
    space applications, a POSIX-compliant C library is needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件足以构建裸机应用程序、引导程序（如 U-Boot）或操作系统（如 Linux 内核），因为它们不需要 C 库，并且实现了所需的 C 库函数。然而，对于
    Linux 用户空间应用程序，则需要一个符合 POSIX 标准的 C 库。
- en: The GNU C library, `glibc`, is the default C library used in the Yocto project.
    Yocto is introducing support for musl, a smaller C library, but as we have mentioned
    before, there is still work to be done until it is ready to be used with the hardware
    platforms supported by the FSL community layer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库，`glibc`，是 Yocto 项目中使用的默认 C 库。Yocto 正在引入对 musl（一个较小的 C 库）的支持，但正如我们之前提到的，仍需进行一些工作，才能在
    FSL 社区层支持的硬件平台上使用。
- en: 'But on embedded systems, it is not just a toolchain we need, but a cross-compilation
    toolchain. This is because we build in a host computer but run the resulting binaries
    on the target, which is usually a different architecture. In reality, there are
    several types of toolchains, based on the architecture of the machine building
    the toolchain (build machine), running the toolchain (host machine), and running
    the binaries built by the toolchain (target machine). The most common combinations
    are:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在嵌入式系统中，我们不仅需要一个工具链，还需要一个交叉编译工具链。这是因为我们在主机计算机上构建，但将生成的二进制文件在目标机器上运行，而目标机器通常具有不同的架构。实际上，工具链有几种类型，基于构建工具链的机器架构（构建机器）、运行工具链的机器架构（主机机器）和运行工具链构建的二进制文件的机器架构（目标机器）。最常见的组合有：
- en: '**Native**: An example of this is an x86 machine running a toolchain that has
    also been built on an x86 machine producing binaries to run on an x86 machine.
    This is common in desktop computers.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地**：一个例子是运行在 x86 机器上的工具链，该工具链也是在 x86 机器上构建的，并生成用于在 x86 机器上运行的二进制文件。这在桌面计算机中很常见。'
- en: '**Cross-compilation**: This is the most common on embedded systems; for example,
    an x86 machine running a toolchain that has also been built on an x86 machine
    but producing binaries to run on a different architecture, like ARM.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉编译**：这是嵌入式系统中最常见的情况；例如，一台 x86 机器运行着在 x86 机器上构建的工具链，但生成用于在不同架构上运行的二进制文件，如
    ARM。'
- en: '**Cross-native**: This is typically the toolchain running on targets. An example
    of this is where a toolchain has been built on an x86 machine but runs on ARM
    and produces binaries for ARM.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉本地**：这通常是运行在目标上的工具链。例如，工具链是在 x86 机器上构建的，但它在 ARM 上运行并生成 ARM 用的二进制文件。'
- en: '**Canadian**: Rarely seen, this is where the build, host, and target machines
    are all different.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加拿大**：很少见，这里构建、主机和目标机器都是不同的。'
- en: The process of building a cross-compilation toolchain is complex and fault prone,
    so automated tools for toolchain building have emerged, like **buildroot** and
    **crosstool-NG**. The Yocto build system also compiles its own toolchain on every
    build, and as we will see, you can use this toolchain for application development
    too.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 构建交叉编译工具链的过程复杂且容易出错，因此自动化的工具链构建工具应运而生，如**buildroot**和**crosstool-NG**。Yocto
    构建系统在每次构建时都会编译自己的工具链，正如我们将看到的，你也可以使用这个工具链进行应用程序开发。
- en: But the cross-compilation toolchain and C library are not the only things we
    need in order to build applications; we also need a `sysroot`; that is, a root
    filesystem on the host with the libraries and header files that can be found on
    the target root filesystem.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是交叉编译工具链和 C 库并不是构建应用程序所需的唯一内容；我们还需要一个`sysroot`，即在主机上具有与目标根文件系统相同的库和头文件的根文件系统。
- en: The combination of the cross-compilation toolchain, the `sysroot`, and sometimes
    other development tools such as an IDE is referred to as an SDK, or Software Development
    Kit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译工具链、`sysroot`，以及有时的其他开发工具（如 IDE）的组合被称为 SDK，即软件开发工具包。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'There are several ways to obtain an SDK with the Yocto project:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Yocto 项目获取 SDK 的方式有几种：
- en: Using the **Application Development Toolkit** (**ADT**).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**应用程序开发工具包**（**ADT**）。
- en: If you are using a hardware platform supported by Poky (that is, a virtualized
    QEMU machine or one of the reference boards), the recommendation is to use ADT,
    which will install all the required SDK components for you.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是 Poky 支持的硬件平台（即虚拟化的 QEMU 机器或其中一块参考板），建议使用 ADT，它会为你安装所有所需的 SDK 组件。
- en: Downloading a precompiled toolchain.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载预编译的工具链。
- en: 'The easiest way to obtain a cross-compilation toolchain for a supported platform
    is to download a precompiled one; for example from the Yocto project downloads
    site, [http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/).
    The Yocto project provides prebuilt toolchains for both 32- and 64-bit i686 host
    machines, and prebuilt ARM toolchains both for **armv5** and **armv7** architectures.
    These contain `sysroot` that match the `core-image-sato` target image. However,
    the prebuilt `sysroot` is soft floating point, so it can''t be used with the target
    images built by the FSL community layer for i.MX6-based platforms, which are hard
    floating point. To install the prebuilt armv7 toolchain for an x86_64 host, run
    the following:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取支持平台的交叉编译工具链最简单的方法是下载一个预编译的版本；例如，可以从Yocto项目下载站点获取：[http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/)。Yocto项目为32位和64位i686主机提供预构建的工具链，并为**armv5**和**armv7**架构提供预构建的ARM工具链。这些工具链包含与`core-image-sato`目标映像匹配的`sysroot`。然而，预构建的`sysroot`是软浮点的，因此无法与FSL社区层为基于i.MX6的平台构建的目标映像一起使用，因为它们是硬浮点的。要为x86_64主机安装预构建的armv7工具链，请运行以下命令：
- en: '[PRE0]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Building your own toolchain installer.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你自己的工具链安装程序。
- en: On most embedded Linux projects, your machine will be supported by an external
    layer, and you will have a customized root filesystem that your `sysroot` will
    need to match. So building your own toolchain installer is recommended when you
    have a customized root filesystem. For example, the ideal toolchain to work with
    the Wandboard would be **Cortex-A9**-specific and targeted to produce hard floating
    point binaries.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数嵌入式Linux项目中，你的机器将由外部层支持，并且你将拥有一个定制的根文件系统，你的`sysroot`需要与其匹配。因此，当你有一个定制的根文件系统时，推荐构建你自己的工具链安装程序。例如，适合与Wandboard配合使用的理想工具链应该是**Cortex-A9**特定的，并且针对生成硬浮点二进制文件。
- en: Using the Yocto project build system.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Yocto项目构建系统。
- en: Finally, if you already have a Yocto build system installation on your host,
    you can also use it for application development. Usually, application developers
    do not need the complexity of a Yocto build system installation, so a toolchain
    installer for the target system will be enough.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，如果你的主机上已经安装了Yocto构建系统，你也可以用它来进行应用程序开发。通常，应用程序开发人员不需要Yocto构建系统安装的复杂性，因此一个针对目标系统的工具链安装程序就足够了。
- en: Preparing and using an SDK
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备和使用SDK
- en: The Yocto build system can be used to generate a cross-compilation toolchain
    and matching `sysroot` for a target system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto构建系统可以用来为目标系统生成交叉编译工具链和匹配的`sysroot`。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will use the previously used `wandboard-quad` build directory and source
    the `setup-environment` script as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前使用过的`wandboard-quad`构建目录，并按照以下方式加载`setup-environment`脚本：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are several ways to build an SDK with the Yocto build system:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yocto构建系统构建SDK有几种方式：
- en: The `meta-toolchain` target.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-toolchain`目标。'
- en: 'This method will build a toolchain that matches your target platform, and a
    basic `sysroot` that will not match your target root filesystem. However, this
    toolchain can be used to build bare metal software like the U-Boot bootloader
    or the Linux kernel, which do not need a `sysroot`. The Yocto project offers downloadable
    `sysroot` for the supported hardware platforms. You can also build this toolchain
    yourself with:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法将构建一个与目标平台匹配的工具链，以及一个基本的`sysroot`，但它不会与目标根文件系统匹配。然而，这个工具链可以用来构建裸机软件，比如U-Boot引导加载程序或Linux内核，它们不需要`sysroot`。Yocto项目为支持的硬件平台提供可下载的`sysroot`。你也可以使用以下方法自行构建这个工具链：
- en: '[PRE2]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once built, it can be installed with:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建完成后，可以使用以下命令安装：
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `populate_sdk` task.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`populate_sdk`任务。'
- en: 'This is the recommended way to build a toolchain matching your target platform
    with a `sysroot` matching your target root filesystem. You build it with:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是构建与目标平台匹配的工具链，并且`sysroot`匹配目标根文件系统的推荐方式。你可以使用以下命令进行构建：
- en: '[PRE4]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should replace `core-image-sato` for the target root filesystem image you
    want the `sysroot` to match. The resulting toolchain can be installed with:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该将`core-image-sato`替换为你希望`sysroot`匹配的目标根文件系统映像。构建完成的工具链可以使用以下命令安装：
- en: '[PRE5]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, if you want your toolchain to be able to build static applications, you
    need to add static libraries to it. You can do this by adding specific static
    libraries to your target image, which could also be used for native compilation.
    For example, to add the static `glibc` libraries, add the following to your `conf/local.conf`
    file:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，如果你希望工具链能够构建静态应用程序，则需要向其中添加静态库。你可以通过将特定的静态库添加到目标镜像来实现，静态库也可以用于本地编译。例如，要添加静态的`glibc`库，可以在`conf/local.conf`文件中添加以下内容：
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And then build the toolchain to match your root filesystem as explained previously.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，按照之前的说明构建工具链，以匹配你的根文件系统。
- en: 'You usually won''t want the static libraries added to your image, but do you
    want to be able to cross-compile static applications, so you can also add all
    the static libraries to the toolchain by adding:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，你不会希望将静态库添加到镜像中，但如果你希望能够交叉编译静态应用程序，则可以通过添加以下内容将所有静态库添加到工具链中：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `meta-toolchain-qt` target.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-toolchain-qt`目标。'
- en: 'This method will extend `meta-toolchain` to build Qt applications. We will
    see how to build Qt applications later on. To build this toolchain, execute the
    following command:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法将扩展`meta-toolchain`以构建Qt应用程序。稍后我们将看到如何构建Qt应用程序。要构建此工具链，请执行以下命令：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once built, it can be installed with:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦构建完成，可以使用以下命令进行安装：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The resulting toolchain installers will be located under `tmp/deploy/sdk` for
    all the cases mentioned here.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的工具链安装程序将位于`tmp/deploy/sdk`目录下，适用于此处提到的所有情况。
- en: The `meta-ide-support` target.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-ide-support`目标。'
- en: This method does not generate a toolchain installer, but it prepares the current
    build project to use its own toolchain. It will generate an `environment-setup`
    script inside the tmp directory.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法不会生成工具链安装程序，但它会准备当前的构建项目以使用其自己的工具链。它将在tmp目录中生成一个`environment-setup`脚本。
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To use the bundled toolchain, you can now source that script as follows:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用捆绑的工具链，你现在可以按如下方式引入该脚本：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the Application Development Toolkit
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序开发工具包
- en: 'The ADT is an SDK installation script that installs the following for Poky-supported
    hardware platforms:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ADT是一个SDK安装脚本，用于在Poky支持的硬件平台上安装以下内容：
- en: A prebuilt cross-compilation toolchain, as explained previously
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个预构建的交叉编译工具链，如前所述
- en: A `sysroot` that matches the `core-image-sato` target image
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`core-image-sato`目标镜像匹配的`sysroot`
- en: The QEMU emulator
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QEMU模拟器
- en: Other development user space tools used for system profiling (these will be
    discussed in the following chapters)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于系统分析的其他开发用户空间工具（将在后续章节中讨论）
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To install the ADT, you can choose either of the following options:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装ADT，可以选择以下两种方式之一：
- en: 'Download a precompiled tarball from the Yocto project downloads site with the
    following command:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令从Yocto项目的下载站点下载预编译的tarball：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Build one using your Yocto `build` directory.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你的Yocto`build`目录构建一个。
- en: The ADT installer is an automated script to install precompiled Yocto SDK components,
    so it will be the same whether you download the prebuilt version or you build
    one yourself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ADT安装程序是一个自动化脚本，用于安装预编译的Yocto SDK组件，因此无论你是下载预构建版本还是自己构建，都将是相同的。
- en: You can then configure it before running it to customize the installation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在运行之前配置它，以定制安装。
- en: Note that it only makes sense to use the ADT for the Poky-supported platforms.
    For instance, it is not that useful for external hardware like `wandboard-quad`
    unless you provide your own components.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ADT仅适用于Poky支持的平台。例如，除非提供自己的组件，否则它对于像`wandboard-quad`这样的外部硬件并没有多大用处。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To build the ADT from your Yocto `build` directory, open a new shell and execute
    the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要从你的Yocto`build`目录构建ADT，请打开一个新的shell并执行以下命令：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The ADT tarball will be located in the `tmp/deploy/sdk` directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ADT的tarball将位于`tmp/deploy/sdk`目录下。
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To install it, follow these steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，请按照以下步骤操作：
- en: 'Extract the tarball on a location of your choice:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将tarball提取到你选择的位置：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Configure the installation by editing the `adt_installer.conf` file. Some of
    the options are:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编辑`adt_installer.conf`文件来配置安装。一些选项包括：
- en: '`YOCTOADT_REPO`: This is a repository with the packages and root filesystem
    to be used. By default, it uses the one on the Yocto project web site, [http://adtrepo.yoctoproject.org/1.7.1/](http://adtrepo.yoctoproject.org/1.7.1/),
    but you could set one up yourself with your customized packages and root filesystem.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_REPO`：这是一个包含软件包和根文件系统的仓库。默认情况下，它使用 Yocto 项目网站上的仓库，[http://adtrepo.yoctoproject.org/1.7.1/](http://adtrepo.yoctoproject.org/1.7.1/)，但是你也可以自己设置一个，包含自定义的软件包和根文件系统。'
- en: '`YOCTOADT_TARGETS`: This defines the machine targets the SDK is for. By default,
    this is ARM and x86.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_TARGETS`：定义 SDK 的机器目标。默认情况下，这是 ARM 和 x86。'
- en: '`YOCTOADT_QEMU`: This option controls whether to install the QEMU emulator.
    The default is to install it.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_QEMU`：此选项控制是否安装 QEMU 模拟器。默认情况下会安装它。'
- en: '`YOCTOADT_NFS_UTIL`: This option controls whether to install user mode NFS.
    It is recommended if you are going to use the Eclipse IDE with QEMU-based machines.
    The default is to install it.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_NFS_UTIL`：此选项控制是否安装用户模式 NFS。如果你打算在基于 QEMU 的机器上使用 Eclipse IDE，建议启用此选项。默认情况下会安装它。'
- en: 'And then for the specific target architectures (only shown for ARM):'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后针对特定目标架构（仅针对 ARM 显示）：
- en: '`YOCTOADT_ROOTFS_arm`: This defines the specific root filesystem images to
    download from the ADT repository. By default it installs the `minimal` and `sato-sdk`
    images.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_ROOTFS_arm`：定义从 ADT 仓库下载的特定根文件系统镜像。默认情况下，安装 `minimal` 和 `sato-sdk`
    镜像。'
- en: '`YOCTOADT_TARGET_SYSROOT_IMAGE_arm`: This is the root filesystem used to create
    the `sysroot`. This must also be included in the `YOCTOADT_ROOTFS_arm` selection
    that was explained earlier. By default this is the `sato-sdk` image.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_TARGET_SYSROOT_IMAGE_arm`：这是用于创建 `sysroot` 的根文件系统。此选项必须包含在之前说明过的
    `YOCTOADT_ROOTFS_arm` 选择中。默认情况下，这是 `sato-sdk` 镜像。'
- en: '`YOCTOADT_TARGET_MACHINE_arm`: This is the machine that the images are downloaded
    for. By default this is `qemuarm`.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_TARGET_MACHINE_arm`：这是下载镜像的机器类型。默认情况下，这是 `qemuarm`。'
- en: '`YOCTOADT_TARGET_SYSROOT_LOC_arm`: This is the path on the host to install
    the target''s `sysroot`. By default this is `$HOME/test-yocto/`.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_TARGET_SYSROOT_LOC_arm`：这是主机上安装目标 `sysroot` 的路径。默认情况下是 `$HOME/test-yocto/`。'
- en: 'Run the ADT installer as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式运行 ADT 安装程序：
- en: '[PRE15]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It will ask for an installation location (by default `/opt/poky/1.7.1`) and
    whether you want to run it in interactive or silent mode.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装过程中将提示你选择安装位置（默认是 `/opt/poky/1.7.1`），并询问是否以交互模式或静默模式运行。
- en: Using the Eclipse IDE
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Eclipse IDE
- en: Eclipse is an open source IDE that is written mostly in Java and released under
    the **Eclipse Public License** (**EPL**). It can be extended using plugins, and
    the Yocto project releases a Yocto plugin that allows us to use Eclipse for application
    development.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 是一个开源集成开发环境（IDE），主要使用 Java 编写，并根据 **Eclipse 公共许可证**（**EPL**）发布。它可以通过插件进行扩展，Yocto
    项目发布了一个 Yocto 插件，允许我们使用 Eclipse 进行应用开发。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Yocto 1.7 provides Eclipse Yocto plugins for two different Eclipse versions,
    Juno and Kepler. They can be downloaded at [http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/).
    We will use Kepler 4.3, as it is the newest. We will start with the Eclipse Kepler
    standard edition and install all the required plugins we need.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 1.7 为两个不同版本的 Eclipse 提供了 Yocto 插件，分别是 Juno 和 Kepler。它们可以从 [http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/)
    下载。我们将使用 Kepler 4.3，因为它是最新的。我们将从 Eclipse Kepler 标准版开始，并安装所需的所有插件。
- en: 'It is recommended to run Eclipse under Oracle Java 1.7, although other Java
    providers are supported. You can install Oracle Java 1.7 from Oracle''s web site,
    [https://www.java.com/en/](https://www.java.com/en/), or using a Ubuntu Java Installer
    PPA, [https://launchpad.net/~webupd8team/+archive/ubuntu/java](https://launchpad.net/~webupd8team/+archive/ubuntu/java).
    The latter will integrate Java with your package management system, so it''s preferred.
    To install it, follow these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐在 Oracle Java 1.7 下运行 Eclipse，尽管其他 Java 提供商也受支持。你可以从 Oracle 网站安装 Oracle Java
    1.7，[https://www.java.com/en/](https://www.java.com/en/)，或者使用 Ubuntu Java 安装程序
    PPA，[https://launchpad.net/~webupd8team/+archive/ubuntu/java](https://launchpad.net/~webupd8team/+archive/ubuntu/java)。后者将
    Java 与你的包管理系统集成，因此更为推荐。安装步骤如下：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To download and install Eclipse Kepler standard edition for an x86_64 host,
    follow these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载并安装适用于 x86_64 主机的 Eclipse Kepler 标准版，请按以下步骤操作：
- en: 'Fetch the tarball from the Eclipse download site, [http://eclipse.org/downloads/packages/release/Kepler/SR2](http://eclipse.org/downloads/packages/release/Kepler/SR2).
    For example:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Eclipse 下载站点获取 tar 包，[http://eclipse.org/downloads/packages/release/Kepler/SR2](http://eclipse.org/downloads/packages/release/Kepler/SR2)。例如：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Unpack it on a location of your choice as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其解压到你选择的位置，如下所示：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Start the Eclipse IDE with the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse IDE，使用以下命令：
- en: '[PRE19]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Select **Install New Software** from the **Help** pull-down menu. Then select
    the **Kepler - http://download.eclipse.org/releases/kepler** source.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**帮助**下拉菜单中选择**安装新软件**。然后选择**Kepler - http://download.eclipse.org/releases/kepler**源。
- en: 'Install the following Eclipse components:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装以下 Eclipse 组件：
- en: 'Linux tools:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 工具：
- en: '**LTTng - Linux Tracing Toolkit**'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**LTTng - Linux 跟踪工具包**'
- en: 'Mobile and device development:'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动和设备开发：
- en: '**C/C++ Remote Launch**'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**C/C++ 远程启动**'
- en: '**Remote System Explorer End-user Runtime**'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**远程系统浏览器最终用户运行时**'
- en: '**Remote System Explorer User Actions**'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**远程系统浏览器用户操作**'
- en: '**Target Management Terminal**'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**目标管理终端**'
- en: '**TCF Remote System Explorer add-in**'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**TCF 远程系统浏览器插件**'
- en: '**TCF Target Explorer**'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**TCF 目标浏览器**'
- en: 'Programming languages:'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程语言：
- en: '**C/C++ Autotools Support**'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**C/C++ 自动工具支持**'
- en: '**C/C++ Development Tools**'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**C/C++ 开发工具**'
- en: 'Install the Eclipse Yocto plugin by adding this repository source: [http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler](http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler),
    as shown in the following screenshot:![Getting ready](img/5186OS_04_01.jpg)'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加此仓库源来安装 Eclipse Yocto 插件：[http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler](http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler)，如以下截图所示：![准备就绪](img/5186OS_04_01.jpg)
- en: Choose **Yocto Project ADT plug-in** and ignore the unsigned content warning.
    We won't be covering other plugin extensions.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Yocto 项目 ADT 插件**并忽略未签名的内容警告。我们不会覆盖其他插件扩展。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To configure Eclipse to use a Yocto toolchain, go to **Window** | **Preferences**
    | **Yocto Project ADT**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Eclipse 使用 Yocto 工具链，请转到 **窗口** | **首选项** | **Yocto 项目 ADT**。
- en: 'The ADT configuration offers two cross-compiler options:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ADT 配置提供了两种交叉编译器选项：
- en: '**Standalone pre-built toolchain**: Choose this when you have installed a toolchain
    either from a toolchain installer or the ADT installer.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**独立预构建工具链**：当你通过工具链安装程序或 ADT 安装程序安装了工具链时，请选择此项。'
- en: '**Build system derived toolchain**: Choose this when using a Yocto `build`
    directory prepared with `meta-ide-support` as explained previously.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于构建系统的工具链**：当使用之前提到的通过 `meta-ide-support` 准备的 Yocto `build` 目录时，请选择此项。'
- en: 'It also offers two target options:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了两个目标选项：
- en: '**The QEMU emulator**: Choose this if you are using Poky with a virtualized
    machine and you have used the ADT installer to install a `qemuarm` Linux kernel
    and root filesystem.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**QEMU 模拟器**：如果你使用的是虚拟化机器上的 Poky，并且已经使用 ADT 安装程序安装了 `qemuarm` Linux 内核和根文件系统，请选择此项。'
- en: '**External hardware**: Choose this if you are using real hardware like the
    `wandboard-quad` hardware. This option is the most useful for embedded development.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**外部硬件**：如果你使用的是像 `wandboard-quad` 这样的真实硬件，请选择此选项。此选项对于嵌入式开发最为有用。'
- en: 'An example configuration when using the ADT installer with its default configuration
    would be to choose the standalone prebuilt toolchain option along with the QEMU
    emulator as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ADT 安装程序及其默认配置时的示例配置是选择独立预构建的工具链选项，并配合 QEMU 模拟器，如下所示：
- en: 'Cross-compiler options:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译器选项：
- en: 'Standalone pre-built toolchain:'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立预构建的工具链：
- en: '**Toolchain root location**: `/opt/poky/1.7.1`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**工具链根位置**：`/opt/poky/1.7.1`'
- en: '**Sysroot location**: `${HOME}/test-yocto/qemuarm`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Sysroot 位置**：`${HOME}/test-yocto/qemuarm`'
- en: '**Target architecture**: `armv5te-poky-linux-gnueabi`'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**目标架构**：`armv5te-poky-linux-gnueabi`'
- en: 'Target options:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标选项：
- en: '**QEMU kernel**: `/tmp/adt-installer/download_image/zImage-qemuarm.bin`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**QEMU 内核**：`/tmp/adt-installer/download_image/zImage-qemuarm.bin`'
- en: '![How to do it...](img/5186OS_04_02.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_02.jpg)'
- en: 'And for a build system derived toolchain using the `wandboard-quad` reference
    board, this is what you will need:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 `wandboard-quad` 参考板的基于构建系统的工具链，你将需要以下内容：
- en: 'Cross-compiler options:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译器选项：
- en: 'Build system derived toolchain:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于构建系统的工具链：
- en: '**Toolchain root location**: `/opt/yocto/fsl-community-bsp/wandboard-quad`'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**工具链根位置**：`/opt/yocto/fsl-community-bsp/wandboard-quad`'
- en: '**Sysroot location**: `/opt/yocto/fsl-community-bsp/wandboard-quad/tmp/sysroots/wandboard-quad`'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Sysroot 位置**：`/opt/yocto/fsl-community-bsp/wandboard-quad/tmp/sysroots/wandboard-quad`'
- en: '![How to do it...](img/5186OS_04_03.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_03.jpg)'
- en: There's more...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In order to perform debugging on a remote target, it needs to be running the
    `tcf-agent` daemon. It is included by default on the SDK images, but you can also
    include it in any other image by adding the following to your `conf/local.conf`
    file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在远程目标上进行调试，目标需要运行 `tcf-agent` 守护进程。它默认包含在 SDK 镜像中，但你也可以通过在 `conf/local.conf`
    文件中添加以下内容将其包含到其他镜像中：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information, refer to the *Yocto Project Application Developer's Guide*
    at [http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html](http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多信息，请参阅 *Yocto 项目应用程序开发者指南*，网址：[http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html](http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html)
- en: Developing GTK+ applications
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 GTK+ 应用程序
- en: This recipe will show how to build, run, and debug a graphical GTK+ application
    using the Eclipse IDE.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将展示如何使用 Eclipse IDE 构建、运行和调试图形化 GTK+ 应用程序。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Add the `eclipse-debug` feature to your project''s `conf/local.conf` file as
    follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，将 `eclipse-debug` 功能添加到项目的 `conf/local.conf` 文件中：
- en: '[PRE21]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Build a `core-image-sato` target image as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，构建一个 `core-image-sato` 目标镜像：
- en: '[PRE22]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Build a `core-image-sato` toolchain as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示构建一个 `core-image-sato` 工具链：
- en: '[PRE23]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Install the toolchain as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示安装工具链：
- en: '[PRE24]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before launching the Eclipse IDE, we can check whether we are able to build
    and launch a GTK application manually. We will build the following GTK+ hello
    world application:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Eclipse IDE 之前，我们可以检查是否能够手动构建并启动一个 GTK 应用程序。我们将构建以下 GTK+ Hello World 应用程序：
- en: 'The following is a code for `gtk_hello_world.c`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `gtk_hello_world.c` 的代码：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To build it, we use the `core-image-sato` toolchain installed as described
    previously:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建它，我们使用之前描述的安装好的 `core-image-sato` 工具链：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command uses the `pkg-config` helper tool to read the `.pc` files that
    are installed with the GTK libraries in the `sysroot` to determine which compiler
    switches (`--cflags` for `include` directories and `--libs` for the libraries
    to link with) are needed to compile programs that use GTK.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令使用 `pkg-config` 辅助工具读取与 GTK 库一起安装在 `sysroot` 中的 `.pc` 文件，以确定编译使用 GTK 的程序所需的编译器选项（`--cflags`
    用于 `include` 目录，`--libs` 用于要链接的库）。
- en: 'We can manually copy the resulting binary to our Wandboard while booting `core-image-sato`
    over NFS and run it from the target''s console with:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动将生成的二进制文件复制到 Wandboard，并在通过 NFS 启动 `core-image-sato` 时，从目标控制台运行：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will open a GTK+ window over the SATO desktop.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个 GTK+ 窗口，显示在 SATO 桌面上。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We can now configure the Eclipse ADT plugin using the standalone toolchain as
    described before, or we could decide to use the build system derived toolchain
    instead.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用前面描述的独立工具链配置 Eclipse ADT 插件，或者我们也可以决定使用派生自构建系统的工具链。
- en: '![How to do it...](img/5186OS_04_04.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_04.jpg)'
- en: 'Follow the next steps to build and run an example hello world application:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建并运行一个示例 Hello World 应用程序：
- en: Create a new hello world GTK autotools project. Accept all the defaults in the
    project creation wizard. Browse to **File** | **New** | **Project** | **C/C++**
    | **C Project** | **Yocto Project ADT Autotools Project** | **Hello World GTK
    C Autotools Project**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Hello World GTK Autotools 项目。在项目创建向导中接受所有默认选项。浏览到 **文件** | **新建** | **项目**
    | **C/C++** | **C 项目** | **Yocto 项目 ADT Autotools 项目** | **Hello World GTK C Autotools
    项目**。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When choosing a name for your project, avoid using special characters like dashes,
    as they could cause problems with the build tools.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在为项目命名时，请避免使用破折号等特殊字符，因为它们可能会导致构建工具出现问题。
- en: Build the project by going to **Project** | **Build Project**.![How to do it...](img/5186OS_04_05.jpg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **项目** | **构建项目** 来构建项目。![如何操作...](img/5186OS_04_05.jpg)
- en: Even though the project builds successfully, you may see errors both marked
    in the source and in the **Problems** tab. This is because the Eclipse's code
    analysis feature cannot resolve all the project's symbols. To resolve it, add
    the needed `include` header files to your project's properties by going to **Project**
    | **Properties** | **C/C++ General** | **Paths and Symbols** | **Includes**.![How
    to do it...](img/5186OS_04_06.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使项目成功构建，您也可能会看到源代码和 **问题** 标签中标记的错误。这是因为 Eclipse 的代码分析功能无法解析项目的所有符号。为了解决这个问题，您需要通过以下路径将所需的
    `include` 头文件添加到项目属性中：**项目** | **属性** | **C/C++ 常规** | **路径和符号** | **包含**。![如何操作...](img/5186OS_04_06.jpg)
- en: Under **Run** | **Run Configurations**, you should have **C/C++ Remote Application**
    with a TCF target called `<project_name>_gdb_arm-poky-linux-gnueabi`. If you don't,
    create one.![How to do it...](img/5186OS_04_07.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**运行** | **运行配置**下，你应该有一个名为`<project_name>_gdb_arm-poky-linux-gnueabi`的**C/C++远程应用程序**与TCF目标。如果没有，创建一个。![如何操作...](img/5186OS_04_07.jpg)
- en: Create a new TCF connection to the target's IP address using the **New...**
    button in the **Main** tab.![How to do it...](img/5186OS_04_08.jpg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**新建...**按钮在**主**选项卡中创建一个到目标IP地址的新TCF连接。![如何操作...](img/5186OS_04_08.jpg)
- en: Fill in the **Remote Absolute File Path for C/C++ Application** field with the
    path to the binary and include the binary name; for example, `/gtk_hello_world`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**C/C++应用程序的远程绝对文件路径**字段中填写二进制文件的路径，并包括二进制文件名；例如，`/gtk_hello_world`。
- en: In the **Commands to execute before application** field, enter `export DISPLAY=:0`.![How
    to do it...](img/5186OS_04_09.jpg)
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**应用程序执行前的命令**字段中，输入`export DISPLAY=:0`。![如何操作...](img/5186OS_04_09.jpg)
- en: Run the application and log in as `root` with an empty password. You should
    see the GTK application on your SATO desktop, and the following output in the
    Console tab:![How to do it...](img/5186OS_04_23.jpg)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并以`root`用户登录，密码为空。你应该能够在SATO桌面上看到GTK应用程序，并在控制台标签中看到以下输出：![如何操作...](img/5186OS_04_23.jpg)
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you have problems connecting to the target, verify that it is running `tcf-agent`
    by typing in the following on the target''s console:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在连接目标时遇到问题，可以通过在目标的控制台输入以下命令来验证它是否正在运行` tcf-agent`：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you have login problems, you can use Eclipse's **Remote System Explorer**
    (**RSE)** perspective to clear passwords and debug the connection to the target.
    Once the connection can be established and you are able to browse the target's
    filesystem through RSE, you can come back to the run configuration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到登录问题，可以使用Eclipse的**远程系统资源管理器**（**RSE**）视图来清除密码并调试与目标的连接。一旦能够建立连接，并且通过RSE浏览目标的文件系统，你可以返回到运行配置。
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To debug the application, follow these steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试应用程序，请按照以下步骤进行：
- en: Go to **Run** | **Debug Configuration**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**运行** | **调试配置**。
- en: Under the **Debugger** tab, verify the GDB debugger path is the correct toolchain
    debugger location.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**调试器**标签下，验证GDB调试器路径是否指向正确的工具链调试器位置。
- en: '[PRE29]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If it isn't, point it to the correct location.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有，指向正确的位置。
- en: '![There''s more...](img/5186OS_04_10.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![还有更多...](img/5186OS_04_10.jpg)'
- en: Double-click on the `main` function in the source file to add a breakpoint.
    A blue dot will appear on the side bar.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击源文件中的`main`函数以添加断点。侧边栏将显示一个蓝点。
- en: Click on the **Debug** button. The debug perspective appears with the application
    executing on the remote Wandboard hardware.![There's more...](img/5186OS_04_11.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**调试**按钮，调试视图出现，并且应用程序在远程Wandboard硬件上执行。![还有更多...](img/5186OS_04_11.jpg)
- en: Tip
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you get **Text file busy** error, remember to close the application we ran
    on the previous point.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果遇到**文本文件正忙**错误，请记得关闭我们在前一点运行的应用程序。
- en: Using the Qt Creator IDE
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt Creator IDE
- en: Qt Creator is a multiplatform IDE part of the Qt Application Development Framework
    SDK. It is the IDE of choice for Qt application development and is available with
    multiple licenses, including GPLv3, LGPLv2, and commercial licenses as well.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator是一个多平台的IDE，属于Qt应用程序开发框架SDK的一部分。它是Qt应用程序开发的首选IDE，并提供多种许可证，包括GPLv3、LGPLv2和商业许可证。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Download and install the Qt Creator 3.3.0 for your host from the Qt project
    downloads website. For downloading and installing an x86_64 Linux host, you can
    use the following commands:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Qt项目下载网站下载并安装适合你主机的Qt Creator 3.3.0版本。对于x86_64 Linux主机的下载和安装，你可以使用以下命令：
- en: '[PRE30]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Build a toolchain that is ready to develop Qt applications with the following:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个准备好开发Qt应用程序的工具链，使用以下命令：
- en: '[PRE31]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Install it as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式安装：
- en: '[PRE32]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Before launching Qt Creator, we need to set up the development environment.
    To make this happen automatically when we launch Qt Creator, we can patch its
    initialization script by adding the following line right at the beginning of the
    `bin/qtcreator.sh` file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Qt Creator之前，我们需要设置开发环境。为了在启动Qt Creator时自动完成这一过程，我们可以通过在`bin/qtcreator.sh`文件的开头添加以下行来修补其初始化脚本：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the environment initialization script is placed before the hash bang.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，环境初始化脚本位于哈希标记之前。
- en: 'Now we can run Qt Creator as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式运行Qt Creator：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And configure it by going to **Tools** | **Options** and using the following
    steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过转到**工具** | **选项**并按照以下步骤进行配置：
- en: First we configure a new device for our Wandboard. Under **Devices** | **Add**,
    we select **Generic Linux Device**.![How to do it...](img/5186OS_04_12.jpg)
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们为我们的Wandboard配置一个新设备。在**设备** | **添加**下，选择**通用Linux设备**。![如何操作...](img/5186OS_04_12.jpg)
- en: Set the root password in the target by using the `passwd` command from the target's
    root console and type it in the password field.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在目标的根控制台使用`passwd`命令设置根密码，并将其输入密码字段。
- en: 'Under **Build & Run**, we configure a new compiler pointing to the Yocto `meta-toolchain-qt`
    compiler path we just installed. Here''s the path as shown in the following screenshot:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建与运行**下，我们配置一个新的编译器，指向我们刚刚安装的Yocto `meta-toolchain-qt`编译器路径。下面的截图显示了该路径：
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![How to do it...](img/5186OS_04_13.jpg)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_13.jpg)'
- en: 'Similarly for a cross-debugger, the following is the path which is also mentioned
    in the following screenshot:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于交叉调试器，下面是路径，截图中也提到过：
- en: '[PRE36]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![How to do it...](img/5186OS_04_14.jpg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_14.jpg)'
- en: 'And then we configure Qt by selecting the `qmake` builder from the toolchain.
    Here''s the path which is also mentioned in the following screenshot:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过从工具链中选择`qmake`构建器来配置Qt。以下是该路径，截图中也提到过：
- en: '[PRE37]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![How to do it...](img/5186OS_04_15.jpg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_15.jpg)'
- en: 'Finally we configure a new kit as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们按照以下步骤配置一个新的开发套件：
- en: 'Select **Generic Linux Device** and configure its `sysroot` to:'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**通用Linux设备**并将其`sysroot`配置为：
- en: '[PRE38]'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Select the compiler, debugger, and Qt version we just defined.![How to do it...](img/5186OS_04_16.jpg)
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们刚刚定义的编译器、调试器和Qt版本。![如何操作...](img/5186OS_04_16.jpg)
- en: Tip
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Ubuntu, Qt Creator stores its configuration on the user's home directory
    under `.config/QtProject/`.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Ubuntu中，Qt Creator将其配置存储在用户的主目录下的`.config/QtProject/`目录中。
- en: Developing Qt applications
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发Qt应用程序
- en: This recipe will show how to build, run, and debug a graphical Qt application
    using Qt Creator.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将展示如何使用Qt Creator构建、运行和调试一个图形化的Qt应用程序。
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before launching Qt Creator, we check whether we are able to build and launch
    a Qt application manually. We will build a Qt hello world application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Qt Creator之前，我们检查是否能够手动构建并启动一个Qt应用程序。我们将构建一个Qt hello world应用程序。
- en: 'Here is the code for `qt_hello_world.cpp`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`qt_hello_world.cpp`的代码：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To build it, we use the `meta-toolchain-qt` installed as described previously:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建它，我们使用之前描述的`meta-toolchain-qt`：
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This uses `qmake` to create a project file and a `Makefile` file with all the
    relevant code files in the folder.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`qmake`来创建一个项目文件和一个`Makefile`文件，包含文件夹中的所有相关代码文件。
- en: 'To run it, we first need to build a filesystem with Qt support. We first prepare
    the environment as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行它，我们首先需要构建一个支持Qt的文件系统。我们首先按照以下步骤准备环境：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And configure our project with the `qt4-pkgs` extra feature by adding the following
    to `conf/local.conf`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过在`conf/local.conf`中添加以下内容来配置我们的项目，启用`qt4-pkgs`额外功能：
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And for Qt applications, we also need the **International Component for Unicode**
    (**ICU**) library, as the Qt libraries are compiled with support for it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Qt应用程序，我们还需要**国际化组件Unicode**（**ICU**）库，因为Qt库是以支持该库进行编译的。
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And build it with:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过以下命令构建：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once finished, we can program the microSD card image and boot the Wandboard.
    Copy the `qt_hello_world` binary to the target and run:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以编程microSD卡镜像并启动Wandboard。将`qt_hello_world`二进制文件复制到目标设备并运行：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You should see the Qt hello world window on the X11 desktop.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在X11桌面上看到Qt hello world窗口。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to build and run an example hello world application:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些步骤构建并运行一个示例hello world应用程序：
- en: Create a new empty project by going to **File** | **New File or Project** |
    **Other project** | **Empty qmake project**.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**文件** | **新建文件或项目** | **其他项目** | **空qmake项目**来创建一个新的空项目。
- en: Select only the **wandboard-quad** kit we just created.![How to do it...](img/5186OS_04_17.jpg)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅选择我们刚创建的**wandboard-quad**开发板套件。![如何操作...](img/5186OS_04_17.jpg)
- en: Add a new C++ file, `qt_hello_world.cpp`, by going to **File** | **New File
    or Project** | **C++** | **C++ Source File**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**文件** | **新建文件或项目** | **C++** | **C++源文件**，添加一个新的C++文件，`qt_hello_world.cpp`。
- en: Paste the contents of the `qt_hello_world.cpp` file into Qt Creator, as shown
    in the following screenshot:![How to do it...](img/5186OS_04_18.jpg)
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`qt_hello_world.cpp`文件的内容粘贴到Qt Creator中，如下图所示：![如何操作...](img/5186OS_04_18.jpg)
- en: 'Configure your project with the target installation details by adding the following
    to your `hw.pro` file:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将以下内容添加到 `hw.pro` 文件中，配置你的项目与目标安装的详细信息：
- en: '[PRE46]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Replace `qt_hello_world` with the name of your project.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `qt_hello_world` 替换为你的项目名称。
- en: Build the project. If you have build errors, verify that the Yocto build environment
    has been correctly set up.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。如果遇到构建错误，检查 Yocto 构建环境是否正确设置。
- en: Tip
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can try to manually run the toolchain `environment-setup` script before
    launching Qt Creator.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在启动 Qt Creator 之前，你可以尝试手动运行工具链的 `environment-setup` 脚本。
- en: Go to **Projects** | **Run** and check your project settings.![How to do it...](img/5186OS_04_19.jpg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 **项目** | **运行**，检查你的项目设置。![如何操作...](img/5186OS_04_19.jpg)
- en: As can be seen in this screenshot, Qt Creator will use the SFTP protocol to
    transfer the files to the target. By default, the dropbear SSH server running
    on `core-image-sato` does not have SFTP support. We need to add it to our image
    to allow Qt Creator to work by adding the `openssh-sftp-server` package to the
    project's `conf/local.conf` file.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如屏幕截图所示，Qt Creator 将使用 SFTP 协议将文件传输到目标设备。默认情况下，`core-image-sato` 上运行的 dropbear
    SSH 服务器不支持 SFTP。我们需要通过将 `openssh-sftp-server` 软件包添加到项目的 `conf/local.conf` 文件中，将其添加到镜像中，以使
    Qt Creator 能够正常工作。
- en: '[PRE47]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: However, there are other tools we will need, like the **gdbserver** if we want
    to debug our application, so it's easier to add the `eclipse-debug` feature, which
    will add all of the needed applications to the target image.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我们还需要其他工具，例如 **gdbserver**，如果我们希望调试我们的应用程序，那么添加 `eclipse-debug` 功能会更方便，它将把所有需要的应用程序添加到目标镜像中。
- en: '[PRE48]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can now run the project.![How to do it...](img/5186OS_04_20.jpg)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以运行项目了。![如何操作...](img/5186OS_04_20.jpg)
- en: Tip
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the application fails to be deployed with a login error, verify that you
    have set a root password in the target as explained in the recipe previously,
    or that you are using SSH key authentication.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果应用程序在部署时出现登录错误，检查是否已按照之前的配方在目标设备中设置了 root 密码，或者是否正在使用 SSH 密钥认证。
- en: You should now see the example Qt hello world application running on your SATO
    desktop.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能看到示例 Qt hello world 应用程序在你的 SATO 桌面上运行。
- en: There's more...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To debug the application, toggle a breakpoint on the source and click on the
    **Debug** button.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试应用程序，可以在源代码上设置断点并点击 **调试** 按钮。
- en: '![There''s more...](img/5186OS_04_21.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5186OS_04_21.jpg)'
- en: Describing workflows for application development
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述应用程序开发的工作流
- en: The workflows for application development are similar to the ones we already
    saw for U-Boot and the Linux kernel back in [Chapter 2](ch02.html "Chapter 2. The
    BSP Layer"), *The BSP Layer*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发的工作流类似于我们之前在[第2章](ch02.html "第2章. BSP 层")，*BSP 层*，看到的 U-Boot 和 Linux 内核的工作流。
- en: How to do it...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will see how the following development workflows are applied to application
    development:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下开发工作流是如何应用于应用程序开发的：
- en: External development
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部开发
- en: Working directory development
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: External source development
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部源开发
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: External development
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部开发
- en: This is what we have been using on the recipes we saw before when building from
    the command line using a standalone toolchain, and also when using both the Eclipse
    and Qt Creator IDEs. This workflow produces binaries that have to be individually
    copied to the hardware to run and debug. It can be used in conjunction with the
    other workflows.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在之前通过命令行使用独立工具链构建时，看到的配方中的使用方式，也适用于使用 Eclipse 和 Qt Creator IDE 时的情况。该工作流会生成需要单独复制到硬件上才能运行和调试的二进制文件。它可以与其他工作流结合使用。
- en: Working directory development
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: When the application is being built by the Yocto build system, we use this workflow
    to debug sporadic problems. However, it is not the recommended workflow for long
    developments. Note, though, that it is usually the first step when debugging third-party
    packages.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序通过 Yocto 构建系统构建时，我们使用这个工作流来调试偶发性问题。然而，它并不是长期开发的推荐工作流。但请注意，它通常是调试第三方软件包时的第一步。
- en: We will use the `helloworld_1.0.bb` custom recipe we saw back in the *Adding
    new packages* recipe in [Chapter 3](ch03.html "Chapter 3. The Software Layer"),
    *The Software Layer*, `meta-custom/recipes-example/helloworld/helloworld_1.0.bb`,
    as an example.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在[第3章](ch03.html "第3章. 软件层")，*软件层*，中的 *添加新软件包* 配方中看到的 `helloworld_1.0.bb`
    自定义配方 `meta-custom/recipes-example/helloworld/helloworld_1.0.bb` 作为示例。
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, the `helloworld.c` source file is the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`helloworld.c` 源文件如下：
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The workflow steps are:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流步骤如下：
- en: Start the package compilation from scratch.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从头开始启动软件包编译。
- en: '[PRE51]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will erase the package's build folder, shared state cache, and downloaded
    package source.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将删除软件包的构建文件夹、共享状态缓存和下载的软件包源。
- en: 'Start a development shell:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动开发环境：
- en: '[PRE52]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will fetch, unpack, and patch the `helloworld` sources and spawn a new
    shell with the environment ready for compilation. The new shell will change to
    the package's `build` directory.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将获取、解压并修补`helloworld`源代码，并启动一个新的shell，环境已准备好进行编译。新shell将切换到软件包的`build`目录。
- en: 'Depending on the `SRC_URI` variable, the package''s `build` directory can be
    revision controlled already. If not, as is the case in this example, we will create
    a local Git repository as follows:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`SRC_URI`变量，软件包的`build`目录可能已经受版本控制。如果没有（如本示例所示），我们将按如下方式创建一个本地Git版本库：
- en: '[PRE53]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Perform the modifications we need; for example, change `helloworld.c` to print
    `Howdy world` as follows:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行我们需要的修改；例如，将`helloworld.c`更改为如下内容，以打印`Howdy world`：
- en: '[PRE54]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Exit `devshell` and build the package without erasing our modifications.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`devshell`并构建软件包，而不删除我们的修改。
- en: '[PRE55]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tip
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note the capital `C` (which invokes the compile task) and also all the tasks
    that follow it.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意大写的`C`（它触发编译任务），以及所有跟随它的任务。
- en: 'Test your changes on the hardware by copying the generated package and installing
    it. Because you have only modified one package, the rest of the dependencies should
    be already installed in the running root filesystem. Run the following:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在硬件上测试您的更改，方法是复制生成的软件包并安装它。因为您只修改了一个软件包，其他依赖项应该已经安装在运行中的根文件系统中。运行以下命令：
- en: '[PRE56]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This assumes the target's root filesystem has been built with the `package-management`
    feature and the `helloworld` package is added to the `RM_WORK_EXCLUDE` variable
    when using the `rm_work` class.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这假设目标的根文件系统已通过`package-management`功能构建，并且在使用`rm_work`类时，`helloworld`软件包已添加到`RM_WORK_EXCLUDE`变量中。
- en: 'Go back to `devshell` and commit your change to the local Git repository as
    follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`devshell`并将更改提交到本地Git版本库，如下所示：
- en: '[PRE57]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Generate a patch into the recipe''s patch directory:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成补丁到配方的补丁目录中：
- en: '[PRE58]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, add the patch to the recipe''s `SRC_URI` variable, as shown here:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将补丁添加到配方的`SRC_URI`变量中，如下所示：
- en: '[PRE59]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: External source development
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部源开发
- en: This workflow is recommended for development work once the application has been
    integrated into the Yocto build system. It can be used in conjunction with external
    development using an IDE, for example.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作流建议在将应用程序集成到Yocto构建系统后用于开发工作。例如，可以与使用IDE进行的外部开发结合使用。
- en: In the example recipe we saw earlier, the source file was placed on the `meta-custom`
    layer along with the metadata.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前看到的示例配方中，源文件与元数据一起放置在`meta-custom`层中。
- en: 'It is more common to have the recipe fetch directly from a revision control
    system like Git, so we will change the `meta-custom/recipes-example/helloworld/helloworld_1.0.bb`
    file to source from a Git directory as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是让配方直接从版本控制系统（如Git）中获取，因此我们将修改`meta-custom/recipes-example/helloworld/helloworld_1.0.bb`文件，以从Git目录中获取，如下所示：
- en: '[PRE60]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can then clone it into a local directory as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将其克隆到本地目录，如下所示：
- en: '[PRE61]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'An alternative to using a remote revision controlled repository it to use a
    local one. To do so, follow these steps:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地版本控制库是使用远程版本控制库的替代方法。为此，请按照以下步骤操作：
- en: 'Create a local Git repository that will hold the source:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个本地Git版本库，用于存放源代码：
- en: '[PRE62]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Copy our `helloworld.c` file over here, and add it to the repository:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的`helloworld.c`文件复制到这里，并将其添加到版本库中：
- en: '[PRE63]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, commit it with a signature and a message:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用签名和消息提交：
- en: '[PRE64]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In any case, we have the version-controlled source in a local directory. We
    will then configure our `conf/local.conf` file to work from it as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们都将版本控制的源代码放在本地目录中。然后我们将配置我们的`conf/local.conf`文件以从中工作，如下所示：
- en: '[PRE65]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And build it with:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令进行构建：
- en: '[PRE66]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We can then work directly in the local folder without the risk of accidentally
    having BitBake erase our code. Once development is complete, the modifications
    to `conf/local.conf` are removed and the recipe will fetch the source from its
    original `SRC_URI` location.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以直接在本地文件夹中工作，而无需担心BitBake意外删除我们的代码。开发完成后，`conf/local.conf`的修改将被删除，配方将从其原始`SRC_URI`位置获取源代码。
- en: Working with GNU make
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GNU make工作
- en: GNU make is a make implementation for Linux systems. It is used by a wide variety
    of open source projects, including the Linux kernel. The build is managed by a
    `Makefile`, which tells make how to build the source code.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: GNU make是Linux系统上的一种make实现。它被许多开源项目使用，包括Linux内核。构建由`Makefile`管理，`Makefile`指示make如何构建源代码。
- en: How to do it...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Yocto recipes inherit `base.bbclass` and hence their default behavior is to
    look for a `Makefile`, `makefile`, or `GNU Makefile` and use GNU make to build
    the package.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto配方继承`base.bbclass`，因此它们的默认行为是查找`Makefile`、`makefile`或`GNU Makefile`并使用GNU
    make来构建软件包。
- en: If your package already contains a `Makefile`, then all you need to worry about
    are the arguments that need to be passed to make. Make arguments can be passed
    using the `EXTRA_OEMAKE` variable, and a `do_install` override that calls the
    `oe_runmake` install needs to be provided, otherwise an empty install is run.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的软件包已经包含`Makefile`，那么你只需要关注需要传递给make的参数。make的参数可以通过`EXTRA_OEMAKE`变量传递，且需要提供一个调用`oe_runmake`安装的`do_install`重写，否则将执行空安装。
- en: 'For example, the `logrotate` recipe is based on a `Makefile` and looks as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`logrotate`配方基于一个`Makefile`，如下所示：
- en: '[PRE67]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: See also
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information about GNU make, visit [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于GNU make的信息，请访问[https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)
- en: Working with the GNU build system
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GNU构建系统的合作
- en: A `Makefile` is a good solution when you are always going to build and run your
    software on the same system, and things like `glibc` and `gcc` versions and the
    available library versions are known. However, most software need to be built
    and run in a variety of systems.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当你总是在相同系统上构建和运行软件时，`Makefile`是一个不错的解决方案，前提是已知`glibc`、`gcc`版本以及可用的库版本。然而，大多数软件需要在不同系统上构建和运行。
- en: Getting ready
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The GNU build system, or `autotools`, is a set of tools whose aim is to create
    a `Makefile` for your software in a variety of systems. It''s made up of three
    main tools:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: GNU构建系统或`autotools`是一组工具，旨在为你的软件创建适用于各种系统的`Makefile`。它由三个主要工具组成：
- en: '`autoconf`: This parses the contents of a `configure.ac` file that describes
    the source code to be built and creates a `configure` script. This script will
    then be used to generate the final `Makefile`.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoconf`：解析`configure.ac`文件的内容，该文件描述了要构建的源代码，并生成一个`configure`脚本。然后，这个脚本将用于生成最终的`Makefile`。'
- en: '`automake`: This parses the contents of a `Makefile.am` file and converts it
    into a `Makefile.in` file. This is then used by the `configure` script generated
    earlier to obtain a `config.status` script that gets automatically executed to
    obtain the final `Makefile`.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`automake`：用于解析`Makefile.am`文件的内容，并将其转换为`Makefile.in`文件。然后，早先生成的`configure`脚本将使用该文件来生成`config.status`脚本，自动执行该脚本以获得最终的`Makefile`。'
- en: '`libtools`: This manages the creation of both static and dynamic libraries.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libtools`：用于管理静态和动态库的创建。'
- en: How to do it...
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The Yocto build system contains classes with the required knowledge to build
    `autotools` packages. All your recipe needs to do is to inherit the `autotools`
    class and configure the arguments to be passed to the `configure` script in the
    `EXTRA_OECONF` variable. Usually, the `autotools` system understands how to install
    the software, so you do not need a `do_install` override.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto构建系统包含了构建`autotools`软件包所需的类。你的配方只需要继承`autotools`类，并配置要传递给`configure`脚本的参数，这些参数存储在`EXTRA_OECONF`变量中。通常，`autotools`系统知道如何安装软件，因此你不需要重写`do_install`。
- en: There is a wide variety of open source projects that use `autotools` as the
    build system.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多开源项目使用`autotools`作为构建系统。
- en: 'An example, `meta-custom/recipes-example/hello/hello_2.9.bb`, that does not
    need any extra configure options, follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例，`meta-custom/recipes-example/hello/hello_2.9.bb`，不需要任何额外的配置选项，如下所示：
- en: '[PRE68]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See also
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information about the GNU build system, visit [http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html](http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html)
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于GNU构建系统的信息，请访问[http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html](http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html)
- en: Working with the CMake build system
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与CMake构建系统的合作
- en: The GNU make system is a great tool when you build exclusively for Linux systems.
    However, some packages are multiplatform and need a way to manage `Makefile` files
    on different operating systems. **CMake** is a cross-platform build system that
    can work not only with GNU make, but also Microsoft Visual Studio and Apple's
    Xcode.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: GNU make 系统在你仅为 Linux 系统构建时是一个很棒的工具。然而，一些软件包是跨平台的，需要一种方式来管理不同操作系统上的 `Makefile`
    文件。**CMake** 是一个跨平台的构建系统，它不仅可以与 GNU make 配合使用，还可以与微软 Visual Studio 和苹果的 Xcode
    配合使用。
- en: Getting ready
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The CMake tool parses the `CMakeLists.txt` files in every directory to control
    the build process. An example `CMakeLists.txt` file to compile the hello world
    example follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 工具解析每个目录中的 `CMakeLists.txt` 文件，以控制构建过程。以下是编译 hello world 示例的 `CMakeLists.txt`
    文件示例：
- en: '[PRE69]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How to do it...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The Yocto build system also contains classes with the required knowledge to
    build CMake packages. All your recipe needs to do is to inherit the `cmake` class
    and configure the arguments to be passed to the `configure` script in the `EXTRA_OECMAKE`
    variable. Usually, the CMake system understands how to install the software, so
    you do not need a `do_install` override.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 构建系统还包含了用于构建 CMake 包的必需类。你的配方只需继承 `cmake` 类并配置传递给 `configure` 脚本的参数，这些参数存储在
    `EXTRA_OECMAKE` 变量中。通常，CMake 系统知道如何安装软件，因此你不需要覆盖 `do_install` 任务。
- en: 'A recipe to build the `helloworld.C` example application, `meta-custom/recipes-example/helloworld-cmake/helloworld-cmake_1.0.bb`,
    follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例配方，用于构建 `helloworld.C` 示例应用程序，`meta-custom/recipes-example/helloworld-cmake/helloworld-cmake_1.0.bb`，如下所示：
- en: '[PRE70]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: See also
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information about CMake, visit [http://www.cmake.org/documentation/](http://www.cmake.org/documentation/)
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欲了解更多关于 CMake 的信息，请访问 [http://www.cmake.org/documentation/](http://www.cmake.org/documentation/)
- en: Working with the SCons builder
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SCons 构建器
- en: '**SCons** is also a multiplatform build system written in Python, with its
    configuration files also written in the same language. It also includes support
    for Microsoft Visual Studio among other features.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**SCons** 也是一个跨平台的构建系统，使用 Python 编写，配置文件也是用同样的语言编写。它还支持微软 Visual Studio 等其他功能。'
- en: Getting ready
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: SCons parses the `SConstruct` files, and by default it does not propagate the
    environment into the build system. This is to avoid build issues caused by environment
    differences. This is a complication for Yocto, as it configures the environment
    with the cross-compilation toolchain settings.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: SCons 解析 `SConstruct` 文件，并且默认情况下不会将环境变量传递给构建系统。这是为了避免由于环境差异而引发的构建问题。这对于 Yocto
    来说是一个复杂的地方，因为它使用交叉编译工具链设置来配置环境。
- en: 'SCons does not define a standard way to support cross-compilation, so every
    project will implement it differently. For a simple example as the hello world
    program, we can just initialize the `CC` and `PATH` variables from the external
    environment as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: SCons 没有定义支持交叉编译的标准方式，因此每个项目都会有所不同。以简单的 hello world 程序为例，我们可以像下面这样从外部环境初始化 `CC`
    和 `PATH` 变量：
- en: '[PRE71]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How to do it...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The Yocto build system also contains classes with the required knowledge to
    build SCons packages. All your recipe needs to do is to inherit the `SCons` class
    and configure the arguments to be passed to the configure script in the `EXTRA_OESCONS`
    variable. Although some packages using `SCons` might deal with installation through
    an install alias as required by the `SCons` class, your recipe will mostly need
    to provide a `do_install` task override.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 构建系统还包含了用于构建 SCons 包的必需类。你的配方只需继承 `SCons` 类并配置传递给配置脚本的参数，这些参数存储在 `EXTRA_OESCONS`
    变量中。尽管一些使用 `SCons` 的软件包可能会通过 `SCons` 类要求的安装别名处理安装，但你的配方大多需要提供 `do_install` 任务的覆盖。
- en: 'An example recipe to build the `helloworld.c` example application, `meta-custom/recipes-example/helloworld-scons/helloworld-scons_1.0.bb`,
    follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例配方，用于构建 `helloworld.c` 示例应用程序，`meta-custom/recipes-example/helloworld-scons/helloworld-scons_1.0.bb`，如下所示：
- en: '[PRE72]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: See also
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information about SCons, visit [http://www.scons.org/doc/HTML/scons-user/](http://www.scons.org/doc/HTML/scons-user/)
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欲了解更多关于 SCons 的信息，请访问 [http://www.scons.org/doc/HTML/scons-user/](http://www.scons.org/doc/HTML/scons-user/)
- en: Developing with libraries
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用库开发
- en: Most applications make use of shared libraries, which saves system memory and
    disk space, as they are shared between different applications. Modularizing code
    into libraries also allows for easier versioning and code management.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序使用共享库，这可以节省系统内存和磁盘空间，因为它们在不同的应用程序之间共享。将代码模块化成库还可以更容易地进行版本控制和代码管理。
- en: This recipe will explain how to work with both static and shared libraries in
    Linux and Yocto.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将解释如何在Linux和Yocto中处理静态库和共享库。
- en: Getting ready
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: By convention, library files start with the `lib` prefix.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，库文件以`lib`前缀开头。
- en: 'There are basically two library types:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两种库类型：
- en: '**Static libraries** (`.a`): When the object code is linked and becomes part
    of the application'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态库**（`.a`）：当目标代码被链接并成为应用程序的一部分时'
- en: '**Dynamic libraries** (`.so`): Linked at compile time but not included in the
    application, so they need to be available at runtime. Multiple applications can
    share a dynamic library so they need less disk space.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态库**（`.so`）：在编译时链接，但不包含在应用程序中，因此它们需要在运行时可用。多个应用程序可以共享动态库，从而减少磁盘空间占用。'
- en: 'Libraries are placed in the following standard root filesystem locations:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 库文件放置在以下标准根文件系统位置：
- en: '`/lib`: Libraries required for startup'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：启动时所需的库文件'
- en: '`/usr/lib`: Most system libraries'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/lib`：大多数系统库'
- en: '`/usr/local/lib`: Non-system libraries'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/local/lib`：非系统库'
- en: 'Dynamic libraries follow certain naming conventions on running systems so that
    multiple versions can co-exist, so a library can be referenced by different names.
    Some of them are explained as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 动态库遵循运行系统中的某些命名约定，以便多个版本可以共存，因此库可以通过不同的名称引用。以下是一些解释：
- en: The linker name with the `.so` suffix; for example, `libexample.so`.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接器的名称以`.so`结尾；例如，`libexample.so`。
- en: The fully qualified name or `soname`, a symbolic link to the library name. For
    example, `libexample.so.x`, where `x` is the version number. Increasing the version
    number means the library is not compatible with previous versions.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全限定名或`soname`，是指向库名称的符号链接。例如，`libexample.so.x`，其中`x`是版本号。增加版本号意味着该库与之前的版本不兼容。
- en: The real name. For example, `libexample.so.x.y[.z]`, where `x` is the major
    version number, `y` is the minor version number, and the optional `z` is a release
    number. Increasing minor or release numbers retains compatibility.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正的名称。例如，`libexample.so.x.y[.z]`，其中`x`是主版本号，`y`是次版本号，`z`（可选）是发布号。增加次版本号或发布号将保持兼容性。
- en: 'In GNU `glibc`, starting an ELF binary calls a program loader, `/lib/ld-linux-X`.
    Here, `X` is the version number, which finds all the needed shared libraries.
    This process uses a couple of interesting files:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU `glibc`中，启动ELF二进制文件时会调用程序加载器`/lib/ld-linux-X`。其中，`X`是版本号，加载器会找到所有需要的共享库。这个过程使用了几个有趣的文件：
- en: '`/etc/ld.so.conf`: This stores the directories searched by the loader'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/ld.so.conf`：存储加载器搜索的目录'
- en: '`/etc/ld.so.preload`: This is used to override libraries'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/ld.so.preload`：用于覆盖库文件'
- en: The `ldconfig` tool reads the `ld.so.conf` file and creates a cache file (`/etc/ld.so.cache`)
    to increase access speed.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldconfig`工具读取`ld.so.conf`文件并创建一个缓存文件（`/etc/ld.so.cache`）以提高访问速度。'
- en: 'The following environment variables can also be helpful:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 以下环境变量也可能有帮助：
- en: '`LD_LIBRARY_PATH`: This is a colon-separated directory list to search libraries
    in. It is used when debugging or using non-standard library locations.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LD_LIBRARY_PATH`：这是一个冒号分隔的目录列表，用于搜索库文件。它在调试或使用非标准库位置时非常有用。'
- en: '`LD_PRELOAD`: This is used to override shared libraries.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LD_PRELOAD`：用于覆盖共享库。'
- en: Building a static library
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建静态库
- en: We will build a static library, `libhelloworld`, from two source files, `hello.c`
    and `world.c`, and use it to build a hello world application. The source files
    for the library are presented here.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个源文件`hello.c`和`world.c`构建一个静态库`libhelloworld`，并用它来构建一个Hello World应用程序。库的源文件如下所示。
- en: 'The following is the code for the `hello.c` file:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`hello.c`文件的代码：
- en: '[PRE73]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is the code for `world.c` file:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`world.c`文件的代码：
- en: '[PRE74]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To build the library, follow these steps:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 构建库时，按照以下步骤操作：
- en: 'Configure the build environment:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置构建环境：
- en: '[PRE75]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Compile and link the library:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并链接库：
- en: '[PRE76]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Verify the contents of the library:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证库的内容：
- en: '[PRE77]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The application source code is presented next.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来展示应用程序源代码。
- en: 'For the `helloworld.c` file the following is the code:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`helloworld.c`文件，以下是代码：
- en: '[PRE78]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To build it we run:'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建它，我们运行：
- en: '[PRE79]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can check which libraries it links with using `readelf`:'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`readelf`检查它链接的库：
- en: '[PRE80]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Building a shared dynamic library
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建共享动态库
- en: 'To build a dynamic library from the same sources, we would run:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要从相同的源构建动态库，我们可以运行：
- en: '[PRE81]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can then use it to build our `helloworld C` application, as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来构建我们的`helloworld C`应用程序，具体如下：
- en: '[PRE82]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'And again, we can check the dynamic libraries using `readelf`, as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以使用`readelf`检查动态库，如下所示：
- en: '[PRE83]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How to do it...
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'An example recipe for the static library example we just saw follows, `meta-custom/recipes-example/libhelloworld-static/libhelloworldstatic_1.0.bb`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们刚才看到的静态库示例的配方，`meta-custom/recipes-example/libhelloworld-static/libhelloworldstatic_1.0.bb`：
- en: '[PRE84]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: By default, the configuration in `meta/conf/bitbake.conf` places all static
    libraries in a `-staticdev` package. It is also placed in the `sysroot` so that
    it can be used.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`meta/conf/bitbake.conf`中的配置将所有静态库放入`-staticdev`包中。它也被放置在`sysroot`中，以便可以使用。
- en: 'For a dynamic library, we would use the following recipe, `meta-custom/recipes-example/libhelloworld-dyn/libhelloworlddyn_1.0.bb`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态库，我们将使用以下配方，`meta-custom/recipes-example/libhelloworld-dyn/libhelloworlddyn_1.0.bb`：
- en: '[PRE85]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Usually we would list the library dependencies (if any) in the `RDEPENDS` variable,
    but this is not always needed as the build system performs some automatic dependency
    checking by inspecting both the library file and the `pkg-config` file and adding
    the dependencies it finds to `RDEPENDS` automatically.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会在`RDEPENDS`变量中列出库的依赖项（如果有的话），但这并不总是必要的，因为构建系统会通过检查库文件和`pkg-config`文件自动执行一些依赖检查，并将其发现的依赖项自动添加到`RDEPENDS`中。
- en: Multiple versions of the same library can co-exist on the running system. For
    that, you need to provide different recipes with the same package name but different
    package revision. For example, we would have `libhelloworld-1.0.bb` and `libhelloworld-1.1.bb`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 同一库的多个版本可以在运行系统中共存。为此，您需要提供具有相同包名但不同包修订版的不同配方。例如，我们将有`libhelloworld-1.0.bb`和`libhelloworld-1.1.bb`。
- en: 'And to build an application using the static library, we would create a recipe
    in `meta-custom/recipes-example/helloworld-static/helloworldstatic_1.0.bb`, as
    follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用静态库构建应用程序，我们将创建一个配方`meta-custom/recipes-example/helloworld-static/helloworldstatic_1.0.bb`，如下所示：
- en: '[PRE86]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To build using the dynamic library, we would just need to change the recipe
    in `meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb` to
    `meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 若要使用动态库进行构建，我们只需要在`meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb`中更改配方，改为`meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb`：
- en: '[PRE87]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works...
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'Libraries should provide the information required to use them, such as `include`
    headers and `library` dependencies. The Yocto Project provides two ways for libraries
    to provide build settings:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 库应该提供使用它们所需的信息，如`include`头文件和`library`依赖项。Yocto项目为库提供构建设置提供了两种方式：
- en: The `binconfig` class. This is a legacy class used for libraries that provide
    a `-config` script to provide build settings.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binconfig`类。这是一个遗留类，用于那些提供`-config`脚本来提供构建设置的库。'
- en: The `pkgconfig` class. This is the recommended method for libraries to provide
    build settings.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkgconfig`类。这是库提供构建设置的推荐方法。'
- en: A `pkg-config` build settings file has the `.pc` suffix, is distributed with
    the library, and is installed in a common location known to the `pkg-config` tool.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`pkg-config`构建设置文件具有`.pc`后缀，随库一起分发，并安装在`pkg-config`工具已知的常见位置。
- en: 'The `helloworld.pc` file for the dynamic library looks as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 动态库的`helloworld.pc`文件如下所示：
- en: '[PRE88]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'However, for the static library, we would change the last line to:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于静态库，我们需要将最后一行更改为：
- en: '[PRE89]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: A package wanting to use this `.pc` file would inherit the `pkgconfig` class.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 一个想要使用这个`.pc`文件的包将继承`pkgconfig`类。
- en: There's more...
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's a provision for packages that build both a library and an executable
    but do not want both of them installed together. By inheriting the `lib_package`
    class, the package will create a separate `-bin` package with the executables.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 对于既构建库又构建可执行文件但不希望它们一起安装的包，提供了相应的解决方案。通过继承`lib_package`类，包将创建一个独立的`-bin`包来包含可执行文件。
- en: See also
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: More details regarding `pkg-config` can be found at [http://www.freedesktop.org/wiki/Software/pkg-config/](http://www.freedesktop.org/wiki/Software/pkg-config/)
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于`pkg-config`的详细信息可以在[http://www.freedesktop.org/wiki/Software/pkg-config/](http://www.freedesktop.org/wiki/Software/pkg-config/)找到。
- en: Working with the Linux framebuffer
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Linux帧缓冲区一起工作
- en: The Linux kernel provides an abstraction for the graphical hardware in the form
    of framebuffer devices. These allow applications to access the graphics hardware
    through a well-defined API. The framebuffer is also used to provide a graphical
    console to the Linux kernel, so that it can, for example, display colors and a
    logo.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核提供了一个图形硬件抽象层，以帧缓冲设备的形式呈现。它们允许应用程序通过一个明确定义的API访问图形硬件。帧缓冲区还被用来为Linux内核提供一个图形控制台，例如，它可以显示颜色和徽标。
- en: In this recipe, we will explore how applications can use the Linux framebuffer
    to display graphics and video.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探讨应用程序如何使用Linux帧缓冲区来显示图形和视频。
- en: Getting ready
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some applications, especially in embedded devices, are able to access the framebuffer
    by mapping the memory and accessing it directly. For example, the `gstreamer`
    framework is able to work directly over the framebuffer, as is the Qt graphical
    framework.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序，特别是在嵌入式设备中，能够通过映射内存并直接访问帧缓冲区来访问它。例如，`gstreamer`框架能够直接在帧缓冲区上工作，Qt图形框架也是如此。
- en: Qt is a cross-platform application framework written in C++ and developed both
    by Digia, under the Qt company name, and the open source Qt project community.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个跨平台的应用程序框架，使用C++编写，由Digia公司（以Qt公司名义）和开源Qt项目社区共同开发。
- en: For Qt applications, Poky provides a `qt4e-demo-image` and the FSL community
    BSP provides a `qte-in-use-image`, both of which include support for Qt4 Extended
    over the framebuffer. The provided framework also includes support for hardware
    acceleration – not only video but also 2D and 3D graphical acceleration provided
    through the OpenGL and OpenVG APIs.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Qt应用程序，Poky提供了`qt4e-demo-image`，而FSL社区BSP提供了`qte-in-use-image`，这两个镜像都包括对Qt4扩展在帧缓冲区上的支持。提供的框架还包括硬件加速支持——不仅支持视频，还支持通过OpenGL和OpenVG
    API提供的2D和3D图形加速。
- en: How to do it...
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To compile the Qt hello world application we saw in the *Developing Qt applications*
    recipe earlier, we could use the following `meta-custom/recipes-qt/qt-helloworld/qt-helloworld_1.0.bb`
    Yocto recipe:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译我们之前在*开发Qt应用程序*食谱中看到的Qt Hello World应用程序，我们可以使用以下`meta-custom/recipes-qt/qt-helloworld/qt-helloworld_1.0.bb`
    Yocto食谱：
- en: '[PRE90]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Here the `meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.cpp`
    source file is as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.cpp`源文件：
- en: '[PRE91]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And the `meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.pro`
    project file is as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.pro`项目文件如下：
- en: '[PRE92]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then we add it to the image by using the following in your project''s `conf/local.conf`
    file:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过在项目的`conf/local.conf`文件中使用以下内容将其添加到镜像中：
- en: '[PRE93]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And we build the image with:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用以下命令构建镜像：
- en: '[PRE94]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can then program the SD card image, boot it, log in to the Wandboard, and
    launch the application by running:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将SD卡镜像编程，启动它，登录到Wandboard，并通过运行以下命令启动应用程序：
- en: '[PRE95]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `-qws` command-line option is needed to run the server application.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务器应用程序时需要`-qws`命令行选项。
- en: How it works...
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The framebuffer devices are located under `/dev`. The default framebuffer device
    is `/dev/fb0`, and if the graphics hardware provides more than one, they will
    be sequentially numbered.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲设备位于`/dev`目录下。默认的帧缓冲设备是`/dev/fb0`，如果图形硬件提供多个帧缓冲设备，它们将按顺序编号。
- en: By default, the Wandboard boots with two framebuffer devices, `fb0` and `fb1`.
    The first is the default video display, and the second one is an overlay plane
    that can be used to combine content on the display.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Wandboard启动时会有两个帧缓冲设备，`fb0`和`fb1`。第一个是默认的视频显示，第二个是叠加平面，可用于在显示器上组合内容。
- en: However, the i.MX6 SoC supports up to four displays, so it could have up to
    four framebuffer devices in addition to two overlay framebuffers.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，i.MX6 SoC支持最多四个显示器，因此它除了两个叠加帧缓冲区外，还可以有最多四个帧缓冲设备。
- en: 'You can change the default framebuffer used by applications with the `FRAMEBUFFER`
    environment variable. For example, if your hardware supports several framebuffers,
    you could use the second one by running:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`FRAMEBUFFER`环境变量更改应用程序使用的默认帧缓冲区。例如，如果你的硬件支持多个帧缓冲区，你可以通过运行以下命令使用第二个帧缓冲区：
- en: '[PRE96]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The framebuffer devices are memory mapped and you can perform file operations
    on them. For example, you can clear the contents of the screen by running:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲设备是内存映射的，你可以在它们上执行文件操作。例如，你可以通过运行以下命令清除屏幕内容：
- en: '[PRE97]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Or copy it with:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用以下命令复制它：
- en: '[PRE98]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You may even restore the contents with:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过以下命令恢复内容：
- en: '[PRE99]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: User space programs can also interrogate the framebuffers or modify their configuration
    programmatically using `ioctls`, or from the console by using the `fbset` application,
    which is included in Yocto's core images as a BusyBox applet.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间程序也可以通过 `ioctls` 查询帧缓冲区或以编程方式修改其配置，或者通过控制台使用 `fbset` 应用程序，这个程序包含在 Yocto
    的核心镜像中，作为 BusyBox 小程序。
- en: '[PRE100]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You can configure the framebuffer HDMI device with a specific resolution, bits
    per pixel, and refresh rate by passing the `video` command-line option from the
    U-Boot bootloader to the Linux kernel. The specific format depends on the device
    framebuffer driver, and for the Wandboard it is as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从 U-Boot 引导加载程序传递 `video` 命令行选项到 Linux 内核，来配置帧缓冲 HDMI 设备的特定分辨率、每像素位数和刷新率。具体格式取决于设备的帧缓冲驱动，对于
    Wandboard，格式如下：
- en: '[PRE101]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Where:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '`n` is the framebuffer number'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` 是帧缓冲区的编号'
- en: '`xres` is the horizontal resolution'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xres` 是水平分辨率'
- en: '`yres` is the vertical resolution'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yres` 是垂直分辨率'
- en: '`M` specifies that the timings are to be calculated using the VESA coordinated
    video timings instead of from a look-up table'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M` 表示要使用 VESA 协调视频时序来计算时序，而不是从查找表中获取。'
- en: '`rate` is the refresh rate'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rate` 是刷新率'
- en: 'For example, for the `fb0` framebuffer, you could use:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 `fb0` 帧缓冲区，你可以使用：
- en: '[PRE102]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Tip
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that after some time of inactivity, the virtual console will blank out.
    To unblank the display, use:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在一段时间的不活动后，虚拟控制台将会消失。要恢复显示，可以使用：
- en: '[PRE103]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: There's more...
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The FSL community BSP layer also provides a `fsl-image-multimedia` target image
    that includes the `gstreamer` framework, including plugins that make use of the
    hardware acceleration features within the i.MX6 SoC. A `fsl-image-multimedia-full`
    image is also provided, which extends the supported `gstreamer` plugins.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: FSL 社区 BSP 层还提供了一个 `fsl-image-multimedia` 目标镜像，包含 `gstreamer` 框架和利用 i.MX6 SoC
    内硬件加速特性的插件。此外，还提供了一个 `fsl-image-multimedia-full` 镜像，扩展了对更多 `gstreamer` 插件的支持。
- en: 'To build the `fsl-image-multimedia` image with framebuffer support, you need
    to remove the graphical distribution features by adding the following to your
    `conf/local.conf` file:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建带有帧缓冲区支持的 `fsl-image-multimedia` 镜像，你需要通过将以下内容添加到 `conf/local.conf` 文件来移除图形分发特性：
- en: '[PRE104]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'And build the image with:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用以下命令构建镜像：
- en: '[PRE105]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The resulting `fsl-image-multimedia-wandboard-quad.sdcard` image at `tmp/deploy/images`
    can be programmed into a microSD card and booted.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `fsl-image-multimedia-wandboard-quad.sdcard` 镜像位于 `tmp/deploy/images`，可以将其写入
    microSD 卡并启动。
- en: 'The default Wandboard device tree defines an `mxcfb1` node as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Wandboard 设备树定义了一个 `mxcfb1` 节点，如下所示：
- en: '[PRE106]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: So, connecting a 1920x1080 HDMI monitor should show a virtual terminal with
    the Poky login prompt.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，连接一个 1920x1080 的 HDMI 显示器应该会显示一个带有 Poky 登录提示符的虚拟终端。
- en: 'We can then use the `gstreamer` command-line tool, `gst-launch`, to construct
    `gstreamer` pipelines. For example, to view a hardware-accelerated video over
    the framebuffer, you can download the Big Bunny teaser full HD video file and
    play it over the framebuffer using the `gstreamer` framework''s `gst-launch` command-line
    tool as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `gstreamer` 命令行工具 `gst-launch` 来构建 `gstreamer` 管道。例如，要在帧缓冲区上查看硬件加速的视频，你可以下载
    Big Bunny 预告片的全高清文件，并通过 `gstreamer` 框架的 `gst-launch` 命令行工具播放该视频，命令如下：
- en: '[PRE107]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The video will use Freescale's `h.264` video decoder plugin, `vpudec`, which
    makes use of the hardware video processing unit inside the i.MX6 SoC to decode
    the `h.264` video.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 视频将使用 Freescale 的 `h.264` 视频解码插件 `vpudec`，它利用 i.MX6 SoC 中的硬件视频处理单元来解码 `h.264`
    视频。
- en: 'You can see a list of the available i.MX6-specific plugins by running:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来查看可用的 i.MX6 特定插件列表：
- en: '[PRE108]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: See also
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The framebuffer API is documented in the Linux kernel documentation at [https://www.kernel.org/doc/Documentation/fb/api.txt](https://www.kernel.org/doc/Documentation/fb/api.txt)
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帧缓冲 API 已在 Linux 内核文档中记录，地址为 [https://www.kernel.org/doc/Documentation/fb/api.txt](https://www.kernel.org/doc/Documentation/fb/api.txt)
- en: For more information regarding Qt for Embedded Linux, refer to [http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html](http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html)
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Qt for Embedded Linux 的更多信息，请参见 [http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html](http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html)
- en: Documentation for the gstreamer 0.10 framework can be found at [http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/](http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/)
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 gstreamer 0.10 框架的文档可以在 [http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/](http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/)
    中找到
- en: Using the X Windows system
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用X Windows系统
- en: The X Windows system provides the framework for a GUI environment – things like
    drawing and moving windows on the display and interacting with input devices like
    the mouse, the keyboard, and touchscreens. The protocol version has been X11 for
    over two decades, so it also known as X11.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: X Windows系统为GUI环境提供了框架——例如在显示器上绘制和移动窗口，以及与鼠标、键盘和触摸屏等输入设备进行交互。其协议版本已经有二十多年历史，因此也被称为X11。
- en: Getting ready
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The reference implementation for the X Windows system is the **X.Org** server,
    which is released under permissive licenses such as MIT. It uses a client/server
    model, with the server communicating with several client programs, serving user
    input, and accepting graphical output. The X11 protocol is network transparent
    so that the clients and the server may run on different machines, with different
    architectures and operating systems. However, mostly, they both run on the same
    machine and communicate using local sockets.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: X Windows系统的参考实现是**X.Org**服务器，发布采用MIT等宽松许可协议。它使用客户端/服务器模型，服务器与多个客户端程序进行通信，处理用户输入并接受图形输出。X11协议具有网络透明性，意味着客户端和服务器可以运行在不同的机器上，拥有不同的架构和操作系统。然而，大多数情况下，它们都运行在同一台机器上，并通过本地套接字进行通信。
- en: User interface specifications, such as buttons or menu styles, are not defined
    in X11, which leaves it to other window manager applications that are usually
    part of desktop environments, such as Gnome or KDE.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: X11中未定义用户界面规范（如按钮或菜单样式），这将由其他窗口管理器应用程序定义，这些窗口管理器通常是桌面环境的一部分，如Gnome或KDE。
- en: X11 has input and video drivers to handle the hardware. For example, it has
    a framebuffer driver, `fbdev`, that can output to a non-accelerated Linux framebuffer,
    and `evdev`, a generic Linux input device driver with support for mice, keyboards,
    tablets, and touchscreens.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: X11具有输入和视频驱动程序来处理硬件。例如，它有一个帧缓冲驱动程序`fbdev`，可以输出到非加速的Linux帧缓冲区；还有`evdev`，一个通用的Linux输入设备驱动程序，支持鼠标、键盘、平板和触摸屏。
- en: The design of the X11 Windows systems makes it heavy for embedded devices, and
    although a powerful device like the quad-core i.MX6 has no trouble using it, many
    embedded devices choose other graphical alternatives. However, there are many
    graphical applications, mostly from the desktop environment, that run over the
    X11 Windows system.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: X11 Windows系统的设计使其对嵌入式设备来说较为繁重，尽管像四核i.MX6这样强大的设备使用时没有问题，许多嵌入式设备还是选择其他图形替代方案。然而，许多图形应用程序，主要来自桌面环境，仍然运行在X11
    Windows系统上。
- en: The FSL community BSP layer provides a hardware-accelerated X video driver for
    the i.MX6 SoC, `xf86-video-imxfb-vivante`, which is included in the X11-based
    `core-image-sato` target image and other graphical images.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: FSL社区的BSP层为i.MX6 SoC提供了一个硬件加速的X视频驱动程序`xf86-video-imxfb-vivante`，该驱动程序包含在基于X11的`core-image-sato`目标镜像和其他图形镜像中。
- en: 'The X server is configured by an `/etc/X11/xorg.conf` file that configures
    the accelerated device as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: X服务器通过`/etc/X11/xorg.conf`文件进行配置，该文件将加速设备配置如下：
- en: '[PRE109]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The graphical acceleration is provided by the Vivante GPUs included in the i.MX6
    SoC.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 图形加速由i.MX6 SoC中包含的Vivante GPU提供。
- en: Low-level X11 development is not recommended, and toolkits such as GTK+ and
    Qt are preferred. We will see how to integrate both types of graphical applications
    into our Yocto target image.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议进行低级X11开发，推荐使用GTK+和Qt等工具包。我们将看到如何将这两种类型的图形应用程序集成到我们的Yocto目标镜像中。
- en: How to do it...
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: SATO is the default visual style for the Poky distribution based on **Gnome
    Mobile and Embedded** (**GMAE**). It is a desktop environment based on GTK+ that
    uses the matchbox-window-manager. It has the peculiarity of showing one single
    fullscreen window at a time.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: SATO是基于**Gnome Mobile and Embedded**（**GMAE**）的Poky发行版的默认视觉样式。它是一个基于GTK+的桌面环境，使用matchbox-window-manager。其特点是一次只显示一个全屏窗口。
- en: 'To build the GTK hello world application, `meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld-1.0/gtk_hello_world.c`,
    that we introduced earlier, as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们之前介绍的GTK Hello World应用程序`meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld-1.0/gtk_hello_world.c`，可以按照如下方式进行：
- en: '[PRE110]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We can use the following `meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld_1.0.bb`
    recipe:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下`meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld_1.0.bb`配方：
- en: '[PRE111]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We can then add the package to the `core-image-sato` image by using:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过以下命令将该软件包添加到`core-image-sato`镜像中：
- en: '[PRE112]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And we can build it, program it, and run the application from the serial terminal
    with:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令从串口终端构建、编程并运行应用程序：
- en: '[PRE113]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: There's more...
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Accelerated graphical output is also supported on the Qt framework, either directly
    on the framebuffer (like in the `qt4e-demo-image` target we saw before) or using
    the X11 server available in `core-image-sato`.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架也支持加速图形输出，可以直接在帧缓冲区上实现（就像我们之前看到的`qt4e-demo-image`目标中那样），或者使用`core-image-sato`中提供的X11服务器。
- en: 'To build the Qt hello world source we introduced in the previous recipe but
    over X11, we can use the `meta-custom/recipes-qt/qtx11-helloworld/qtx11-helloworld_1.0.bb`
    Yocto recipe shown as follows::'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 要在前一个示例中介绍的Qt hello world源码上构建X11，我们可以使用以下Yocto配方`meta-custom/recipes-qt/qtx11-helloworld/qtx11-helloworld_1.0.bb`：
- en: '[PRE114]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We then need to add the Qt4 framework to the target image as well as the application.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们还需要将Qt4框架添加到目标图像以及应用程序。
- en: '[PRE115]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We can then build `core-image-sato` using the following command:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用以下命令构建`core-image-sato`：
- en: '[PRE116]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Program and boot our target. Then run the application with:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 程序和启动我们的目标。然后使用以下命令运行应用程序：
- en: '[PRE117]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: See also
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information on the X.Org server can be found at [http://www.x.org](http://www.x.org)
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于X.Org服务器的信息，请访问[http://www.x.org](http://www.x.org)
- en: The Qt application framework documentation can be found at [https://qt-project.org/](https://qt-project.org/)
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt应用程序框架的文档可以在[https://qt-project.org/](https://qt-project.org/)找到
- en: More information and documentation about GTK+ can be found at [http://www.gtk.org/](http://www.gtk.org/)
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于GTK+的信息和文档，请访问[http://www.gtk.org/](http://www.gtk.org/)
- en: Using Wayland
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wayland
- en: Wayland is a display server protocol that is intended to replace the X Window
    system, and it is licensed under the MIT license.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: Wayland是一个显示服务器协议，旨在取代X Window系统，其采用MIT许可证。
- en: This recipe will provide an overview of Wayland, including some key differences
    with the X Window system, and will show how to make use of it in Yocto.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 本篇将概述Wayland，包括与X Window系统的一些关键区别，并展示如何在Yocto中使用它。
- en: Getting ready
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Wayland protocol follows a client/server model in which clients are the
    graphical applications requesting the display of pixel buffers on the screen,
    and the server, or compositor, is the service provider that controls the display
    of these buffers.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: Wayland协议采用客户端/服务器模型，其中客户端是请求在屏幕上显示像素缓冲区的图形应用程序，服务器或合成器是控制这些缓冲区显示的服务提供者。
- en: The Wayland compositor can be a Linux display server, an X application, or a
    special Wayland client. Weston is the reference Wayland compositor in the Wayland
    project. It is written in C and works with the Linux kernel APIs. It relies on
    `evdev` for the handling of input events.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: Wayland合成器可以是Linux显示服务器、X应用程序或特殊的Wayland客户端。Weston是Wayland项目中的参考合成器。它用C语言编写，并与Linux内核API一起工作。它依赖于`evdev`来处理输入事件。
- en: Wayland uses **Direct Rendering Manager (DRM)** in the Linux kernel and does
    not need something like an X server. The client renders the window contents to
    a buffer shared with the compositor by itself, using a rendering library, or an
    engine like Qt or GTK+.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: Wayland在Linux内核中使用**Direct Rendering Manager (DRM)**，不需要像X服务器那样的东西。客户端通过自身的渲染库或类似Qt或GTK+的引擎将窗口内容渲染到与合成器共享的缓冲区中。
- en: Wayland lacks the network transparency features of X, but it is likely that
    similar functionality will be added in the future.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: Wayland缺乏X的网络透明特性，但未来可能会添加类似功能。
- en: It also has better security features than X and is designed to provide confidentiality
    and integrity. Wayland does not allow applications to look at the input of other
    programs, capture other input events, or generate fake input events. It also makes
    a better job out of protecting the Window outputs. However, this also means that
    it currently offers no way to provide some of the features we are used to in desktop
    X systems like screen capturing, or features common in accessibility programs.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 它还比X具有更好的安全功能，并设计为提供保密性和完整性。Wayland不允许应用程序查看其他程序的输入、捕获其他输入事件或生成虚假输入事件。它还更好地保护窗口输出。然而，这也意味着它目前无法提供桌面X系统中我们习惯的某些功能，如屏幕捕获或辅助功能程序中常见的功能。
- en: Being lighter than X.Org and more secure, Wayland is better suited to use with
    embedded systems. If needed, X.Org can run as a client of Wayland for backwards
    compatibility.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 比X.Org更轻量且更安全，Wayland更适合在嵌入式系统中使用。如果需要，X.Org可以作为Wayland的客户端以实现向后兼容性。
- en: However, Wayland is not as established as X11, and the Wayland-based images
    in Poky do not receive as much community attention as the X11-based ones.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Wayland并没有像X11那样成熟，而且Poky中基于Wayland的图像没有像基于X11的那些得到那么多社区关注。
- en: How to do it...
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Poky offers a `core-image-weston` image that includes the Weston compositor.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: Poky提供了一个包含Weston合成器的`core-image-weston`镜像。
- en: Modifying our GTK hello world example from the *Using the X Windows system*
    recipe to use GTK3 and run it with Weston is straightforward.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的GTK Hello World示例从*使用X Windows系统*的配方修改为使用GTK3并用Weston运行是直接的。
- en: '[PRE118]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'To build it, configure your `conf/local.conf` file by removing the `x11` distribution
    feature as follows:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建它，配置您的`conf/local.conf`文件，通过如下方式删除`x11`发行版特性：
- en: '[PRE119]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Note
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to build from scratch by removing both the `tmp` and `sstate-cache`
    directories when changing the `DISTRO_FEATURES` variable.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改`DISTRO_FEATURES`变量时，您需要从头开始构建，删除`tmp`和`sstate-cache`目录。
- en: 'Add the application to the image with:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将应用程序添加到镜像中：
- en: '[PRE120]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'And build the image with:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令构建镜像：
- en: '[PRE121]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Once the build finishes, you will find the microSD card image ready to be programmed
    under `tmp/deploy/images/wandboard-quad`.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，您将在`tmp/deploy/images/wandboard-quad`下找到准备好编程的microSD卡镜像。
- en: 'You can then launch the application by running:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过运行以下命令启动该应用程序：
- en: '[PRE122]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: There's more...
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The FSL community BSP release supports hardware-accelerated graphics in Wayland
    using the Vivante GPU included in the i.MX6 SoC.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: FSL社区的BSP发布版支持在Wayland中使用i.MX6 SoC中包含的Vivante GPU进行硬件加速图形处理。
- en: This means that applications like `gstreamer` will be able to offer hardware-accelerated
    output when running with the Weston compositor.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着像`gstreamer`这样的应用程序在与Weston合成器一起运行时，将能够提供硬件加速的输出。
- en: Wayland support can also be found in graphical toolkits like Clutter and GTK3+.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: Wayland支持也可以在像Clutter和GTK3+这样的图形工具包中找到。
- en: See also
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: You can find more information about Wayland on the project's web page at [http://wayland.freedesktop.org/](http://wayland.freedesktop.org/)
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在项目的网页上找到更多关于Wayland的信息：[http://wayland.freedesktop.org/](http://wayland.freedesktop.org/)
- en: Adding Python applications
  id: totrans-623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Python应用程序
- en: In Yocto 1.7, Poky has support for building both Python 2 and Python 3 applications,
    and includes a small set of Python development tools in the `meta/recipes-devtools/python`
    directory.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yocto 1.7中，Poky支持构建Python 2和Python 3应用程序，并在`meta/recipes-devtools/python`目录中包含了一小套Python开发工具。
- en: A wider variety of Python applications are available in the `meta-python` layer
    included as part of `meta-openembedded`, which you can add to your `conf/bblayers.conf`
    file if you want to.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta-python`层中提供了更多种类的Python应用程序，该层作为`meta-openembedded`的一部分，您可以将其添加到`conf/bblayers.conf`文件中。'
- en: Getting ready
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The standard tool for packaging Python modules is `distutils`, which is included
    for both Python 2 and Python 3\. Poky includes the `distutils` class (`distutils3`
    in Python 3), which is used to build Python packages that use `distutils`. An
    example recipe in `meta-python` that uses the `distutils` class is `meta-python/recipes-devtools/python/python-pyusb_1.0.0a2.bb`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 打包Python模块的标准工具是`distutils`，它同时适用于Python 2和Python 3。Poky包括`distutils`类（Python
    3中的`distutils3`），用于构建使用`distutils`的Python包。`meta-python`中有一个使用`distutils`类的示例配方：`meta-python/recipes-devtools/python/python-pyusb_1.0.0a2.bb`。
- en: '[PRE123]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: However, `distutils` does not install package dependencies, allow package uninstallation,
    or allow us to install several versions of the same package, so it is only recommended
    for simple requirements. Hence, `setuptools` was developed to extend on `distutils`.
    It is not included in the standard Python libraries, but it is available in Poky.
    There is also a `setuptools` class in Poky (`setuptools3` for Python 3) that is
    used to build Python packages distributed with `setuptools`.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`distutils`不安装包依赖项，不允许卸载包，也不允许安装同一包的多个版本，因此仅推荐用于简单需求。因此，`setuptools`被开发出来以扩展`distutils`。它不包含在标准的Python库中，但在Poky中是可用的。Poky中也有一个`setuptools`类（Python
    3中是`setuptools3`），用于构建与`setuptools`一起分发的Python包。
- en: How to do it...
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To build a Python hello world example application with `setuptools`, we would
    use a Yocto `meta-custom/recipes-python/python-helloworld/pythonhelloworld_1.0.bb`
    recipe as follows:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`setuptools`构建Python Hello World示例应用程序，我们可以使用以下Yocto `meta-custom/recipes-python/python-helloworld/pythonhelloworld_1.0.bb`配方：
- en: '[PRE124]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'To create an example hello world package, we create the directory structure
    shown in the following screenshot:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个示例的Hello World包，我们创建如下截图所示的目录结构：
- en: '![How to do it...](img/5186OS_04_22.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_22.jpg)'
- en: 'Here is the code for the same directory structure:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同目录结构的代码：
- en: '[PRE125]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'And create the following `meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/setup.py`
    Python setup file:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建以下`meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/setup.py`
    Python设置文件：
- en: '[PRE126]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'As well as the `meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/helloworld/main.py`
    python file:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/helloworld/main.py`
    Python文件：
- en: '[PRE127]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'And a `meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/python-helloworld.py`
    test script that makes use of the module:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个`meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/python-helloworld.py`测试脚本，利用该模块：
- en: '[PRE128]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'We can then add it to our image with:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过以下命令将其添加到我们的镜像中：
- en: '[PRE129]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'And build it using:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令构建：
- en: '[PRE130]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Once programmed and booted, we can test the module by running the example script:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 编程并启动后，我们可以通过运行示例脚本来测试该模块：
- en: '[PRE131]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: There's more...
  id: totrans-649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: In `meta-python`, you can also find the `python-pip` recipe that will add the
    `pip` utility to your target image. It can be used to install packages from the
    **Python Package Index** (**PyPI**).
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在`meta-python`中，你还可以找到`python-pip`食谱，它会将`pip`工具添加到目标镜像中。`pip`可以用于从**Python包索引**（**PyPI**）安装软件包。
- en: 'You can add it to your image with:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令将其添加到镜像中：
- en: '[PRE132]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'You will need to add the `meta-openembedded/meta-python` layer to your `conf/bblayers.conf`
    file in order to build your image, and also the `python-distribute` dependency,
    which is needed by `python-pip`. Then you can build for the `core-image-minimal`
    image with:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将`meta-openembedded/meta-python`层添加到`conf/bblayers.conf`文件中，以便构建镜像，还需要`python-distribute`依赖项，它是`python-pip`所必需的。然后，你可以使用以下命令为`core-image-minimal`镜像构建：
- en: '[PRE133]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Once installed, you can use it from the target as follows:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以按照以下方式从目标设备使用它：
- en: '[PRE134]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Integrating the Oracle Java Runtime Environment
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Oracle Java运行时环境
- en: 'Oracle provides two specialized Java editions for embedded development:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle提供了两种专门用于嵌入式开发的Java版本：
- en: '**Java SE embedded**: This is a large subset of the desktop version of the
    standard Java SE. It contains optimizations with respect to the standard edition,
    like size and memory usage, to adapt it to the needs of mid-sized embedded devices.'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SE嵌入式**：这是标准Java SE桌面版的一个大型子集。与标准版本相比，它包含了针对大小和内存使用的优化，以适应中型嵌入式设备的需求。'
- en: '**Java Micro Edition** (**ME**): This is targeted at headless low- and mid-range
    devices, and is a subset of Java SE complying with the **Connected Limited Device
    Configuration** (**CLDC**), and including some extra features and tools for the
    embedded market. Oracle offers a couple of reference implementations, but Java
    ME will have to be individually integrated from source into specific platforms.'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java微型版**（**ME**）：该版本面向无头的低端和中端设备，是Java SE的一个子集，符合**连接受限设备配置**（**CLDC**），并为嵌入式市场提供一些额外的功能和工具。Oracle提供了几个参考实现，但Java
    ME必须从源代码中单独集成到特定平台。'
- en: We will focus on Java SE embedded, which can be downloaded in binary format
    from the Oracle download site.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于Java SE嵌入式，它可以从Oracle的下载站点以二进制格式下载。
- en: Java SE embedded is commercially licensed and requires royalty payments for
    embedded deployments.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE嵌入式是商业授权的，并且在嵌入式部署中需要支付版税。
- en: Getting ready
  id: totrans-663
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Yocto has a `meta-oracle-java` layer that is meant to help in the integration
    of the official Oracle **Java Runtime Environment** (**JRE**) Version 7\. However,
    installation without user intervention is not possible, as the Oracle's web page
    requires login and the acceptance of its license.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto有一个`meta-oracle-java`层，旨在帮助集成官方Oracle **Java运行时环境**（**JRE**）版本7。然而，由于Oracle的网页需要登录并接受其许可协议，因此无法实现无人干预的安装。
- en: 'In Java SE embedded Version 7, Oracle offered both soft and hard floating point
    versions of headless and headful JREs for ARMv6/v7, and a headless version JRE
    for soft floating point user spaces for ARMv5\. Java SE embedded version 7 provides
    two different **Java Virtual Machines** (**JVMs**) for ARM Linux:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java SE嵌入式版本7中，Oracle提供了软浮点和硬浮点版本的无头和有头JRE，用于ARMv6/v7，以及为ARMv5提供的软浮点用户空间的无头版本JRE。Java
    SE嵌入式版本7为ARM Linux提供了两种不同的**Java虚拟机**（**JVM**）：
- en: A client JVM optimized for responsiveness
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个针对响应性的客户端JVM
- en: A server JVM identical to the client JVM but optimized for long-running applications
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与客户端JVM相同的服务器JVM，但优化了长时间运行的应用程序
- en: At the time of writing, the `meta-oracle-java` layer only has a recipe for the
    headless hard floating-point version with the client JVM. We will add recipes
    for the latest Java 7 SE embedded, which is update 75, for both headless and headful
    hard floating point JREs, which are appropriate to run on an i.MX6-based board
    like `wandboard-quad`.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，`meta-oracle-java` 层仅有一个针对带客户端 JVM 的无头硬浮动点版本的配方。我们将为最新的 Java 7 SE 嵌入式版本（更新
    75）添加配方，涵盖无头和带头部的硬浮动点 JRE，这些版本适用于像 `wandboard-quad` 这样的基于 i.MX6 的板。
- en: How to do it...
  id: totrans-669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To install the Java SE embedded runtime environment, first we need to clone
    the `meta-oracle-java` layer into our sources directory and add it to our `conf/bblayers.conf`
    file as follows:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Java SE 嵌入式运行时环境，首先需要将 `meta-oracle-java` 层克隆到我们的源目录中，并将其添加到 `conf/bblayers.conf`
    文件中，方法如下：
- en: '[PRE135]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Then we need to explicitly accept the Oracle Java license by adding the following
    to our `conf/local.conf` file:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要通过在 `conf/local.conf` 文件中添加以下内容，明确接受 Oracle Java 许可证：
- en: '[PRE136]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We want to build the newest update available, so we add the following `meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headless_1.7.0.bb`
    recipe to our `meta-custom` layer:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望构建最新的更新，因此我们将以下 `meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headless_1.7.0.bb`
    配方添加到我们的 `meta-custom` 层中：
- en: '[PRE137]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Try to build the recipe with the following:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用以下命令构建配方：
- en: '[PRE138]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You will see that we get a checksum mismatch. This is caused by the license
    acceptance step in Oracle's website. To get around this, we will need to manually
    download the file into the `downloads` directory as specified in our project's
    `DL_DIR` configuration variable.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们遇到了校验和不匹配的错误。这是由于在 Oracle 网站上的许可证接受步骤所致。为了解决这个问题，我们需要手动下载文件到 `downloads`
    目录中，路径由我们项目的 `DL_DIR` 配置变量指定。
- en: 'Then we can add the JRE to our target image:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将 JRE 添加到目标镜像中：
- en: '[PRE139]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'And build it with:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令构建：
- en: '[PRE140]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'We can now log in to the target and run it with:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以登录目标设备并运行它，使用命令：
- en: '[PRE141]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can also build the headful version using the following `meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headful_1.7.0.bb`
    recipe:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下 `meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headful_1.7.0.bb`
    配方构建带头部版本：
- en: '[PRE142]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'And add it to the target image with:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令将其添加到目标镜像中：
- en: '[PRE143]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'And build `core-image-sato` with:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令构建 `core-image-sato`：
- en: '[PRE144]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In this case, the reported Java version is:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，报告的 Java 版本是：
- en: '[PRE145]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: There's more...
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The latest release at the time of this writing is Java SE embedded Version 8
    update 33 (8u33).
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，最新版本是 Java SE 嵌入式版本 8 更新 33（8u33）。
- en: Oracle offers the download of the JDK only, and a host tool, **jrecreate**,
    needs to be used to configure and create an appropriate JRE from the JDK. The
    tool allows us to choose between different JVMs (minimal, client, and server)
    as well as soft or hard floating point ABIs, extensions like JavaFX, locales,
    and several other tweakings to the JVM.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 仅提供 JDK 下载，且需要使用一个主机工具 **jrecreate** 来配置并创建适当的 JRE。该工具允许我们在不同的 JVM（最小版、客户端版和服务器版）以及软硬浮动点
    ABI、JavaFX 扩展、本地化和 JVM 的其他一些调优选项之间进行选择。
- en: Oracle Java SE embedded Version 8 provides support for headful X11 development
    using Swing, AWT, and JavaFX only for ARMv7 hard floating point user spaces, and
    includes support for JavaFX (the graphical framework aimed to replace Swing and
    AWT) on the Freescale i.MX6 processor.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Java SE 嵌入式版本 8 提供对仅适用于 ARMv7 硬浮动点用户空间的 X11 开发的支持，支持使用 Swing、AWT 和 JavaFX，且包括对
    Freescale i.MX6 处理器上 JavaFX（旨在替代 Swing 和 AWT 的图形框架）的支持。
- en: There is no Yocto recipe to integrate Java Version 8 at the time of this writing.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，还没有 Yocto 配方可以集成 Java 版本 8。
- en: Integrating the Open Java Development Kit
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开放 Java 开发工具包
- en: The open source alternative to the Oracle Java SE embedded is the **Open Java
    Development Kit** (**OpenJDK**), an open source implementation of Java SE licensed
    under the GPLv2, with the classpath exception, which means that applications are
    allowed to link without being bound by the GPL license.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Java SE 嵌入式的开源替代品是 **开放 Java 开发工具包**（**OpenJDK**），它是 Java SE 的开源实现，基于
    GPLv2 许可证并附带类路径例外，这意味着应用程序可以链接而不受 GPL 许可证的约束。
- en: This recipe will show how to build OpenJDK with Yocto and integrate the JRE
    into our target images.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示如何使用 Yocto 构建 OpenJDK，并将 JRE 集成到我们的目标镜像中。
- en: Getting ready
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The main components of OpenJDK are:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJDK 的主要组件包括：
- en: The HotSpot Java Virtual Machine
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热点 Java 虚拟机
- en: The **Java Class Library** (**JCL**)
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 类库**（**JCL**）'
- en: The Java compiler, **javac**
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 编译器，**javac**
- en: Initially, OpenJDK needed to be built using a proprietary JDK. However, the
    **IcedTea** project allowed us to build OpenJDK using the GNU classpath, the GNU
    compiler for Java (GCJ), and bootstrap a JDK to build OpenJDK. It also complements
    OpenJDK with some missing components available on Java SE like a web browser plugin
    and web start implementations.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，OpenJDK需要使用专有的JDK进行构建。然而，**IcedTea**项目使我们能够使用GNU类库、GNU的Java编译器（GCJ）来构建OpenJDK，并引导JDK来构建OpenJDK。它还通过补充一些Java
    SE中缺失的组件（如网页浏览器插件和Web Start实现）来完善OpenJDK。
- en: Yocto can build meta-java using the `meta-java` layer, which includes recipes
    for cross-compiling OpenJDK using IcedTea.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto可以使用`meta-java`层构建OpenJDK，其中包括使用IcedTea进行交叉编译OpenJDK的配方。
- en: You can download OpenJDK from its Git repository at [http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/](http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从其Git仓库下载OpenJDK，地址为[http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/](http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/)。
- en: Development discussions can be followed and contributed to by visiting the development
    mailing list at [http://lists.openembedded.org/mailman/listinfo/openembedded-devel](http://lists.openembedded.org/mailman/listinfo/openembedded-devel).
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 开发讨论可以通过访问开发邮件列表[http://lists.openembedded.org/mailman/listinfo/openembedded-devel](http://lists.openembedded.org/mailman/listinfo/openembedded-devel)进行跟踪和参与。
- en: The `meta-java` layer also includes recipes for a wide variety of Java libraries
    and VMs, and tools for application development like **ant** and **fastjar**.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta-java`层还包括多种Java库和虚拟机的配方，以及应用开发工具，如**ant**和**fastjar**。'
- en: How to do it...
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To build OpenJDK 7, you need to clone the `meta-java` layer as follows:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建OpenJDK 7，你需要按如下方式克隆`meta-java`层：
- en: '[PRE146]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: At the time of this writing, there is no 1.7 Dizzy branch yet, so we will work
    directly from the master branch.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这篇文章时，还没有1.7版本的Dizzy分支，所以我们将直接使用主分支。
- en: 'Add the layer to your `conf/bblayers.conf` file:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 将该层添加到你的`conf/bblayers.conf`文件中：
- en: '[PRE147]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'And configure the project by adding the following to your `conf/local.conf`
    file:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过将以下内容添加到你的`conf/local.conf`文件中来配置项目：
- en: '[PRE148]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'You can then add the OpenJDK package to your image with:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以通过以下方式将OpenJDK包添加到你的镜像中：
- en: '[PRE149]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'And build the image of your choice:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 并构建你选择的镜像：
- en: '[PRE150]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'When you run the target image, you will get the following Java version:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行目标镜像时，你将看到以下Java版本：
- en: '[PRE151]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: How it works...
  id: totrans-725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To test the JVM, we can byte-compile a Java class on our host and copy it to
    the target to execute it. For instance, we can use the following simple `HelloWorld.java`
    example:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试JVM，我们可以在主机上字节编译一个Java类并将其复制到目标系统上执行。例如，我们可以使用以下简单的`HelloWorld.java`示例：
- en: '[PRE152]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'To byte-compile it in the host, we need to have a Java SDK installed. To install
    a Java SDK in Ubuntu, just run:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在主机上进行字节编译，我们需要安装Java SDK。在Ubuntu中安装Java SDK，只需运行：
- en: '[PRE153]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'To byte-compile the example, we execute:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 要字节编译示例，我们执行：
- en: '[PRE154]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'To run it, we copy the `HelloWorld.class` to the target, and from the same
    folder we run:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，我们将`HelloWorld.class`复制到目标系统，并在同一文件夹中运行：
- en: '[PRE155]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: There's more...
  id: totrans-734
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When using OpenJDK on a production system, it is recommended to always use the
    latest available release, which contains bug and security fixes. At the time of
    this writing, the latest OpenJDK 7 release is update 71 (jdk7u71b14), buildable
    with IcedTea 2.5.3, so the `meta-java` recipes should be updated.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统上使用OpenJDK时，建议始终使用最新的发布版本，其中包含了错误修复和安全更新。在写这篇文章时，最新的OpenJDK 7发布版本是更新71（jdk7u71b14），可以使用IcedTea
    2.5.3构建，因此`meta-java`配方应进行更新。
- en: See also
  id: totrans-736
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Up-to-date information regarding openJDK can be obtained at [http://openjdk.java.net/](http://openjdk.java.net/)
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关openJDK的最新信息可以通过访问[http://openjdk.java.net/](http://openjdk.java.net/)获得。
- en: Integrating Java applications
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Java应用程序
- en: The `meta-java` layer also offers helper classes to ease the integration of
    Java libraries and applications into Yocto. In this recipe, we will see an example
    of building a Java library using the provided classes.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta-java`层还提供了帮助类，以便简化将Java库和应用程序集成到Yocto中的过程。在本配方中，我们将看到一个使用提供的类构建Java库的示例。'
- en: Getting ready
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `meta-java` layer provides two main classes to help with the integration
    of Java applications and libraries:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta-java`层提供了两个主要的类，帮助集成Java应用程序和库：'
- en: '**The Java bbclass**: This provides the default target directories and some
    auxiliary functions, namely:'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java bbclass**：这提供了默认的目标目录和一些辅助功能，即：'
- en: '`oe_jarinstall`: This installs and symlinks a JAR file'
  id: totrans-743
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oe_jarinstall`：这将安装并创建JAR文件的符号链接'
- en: '`oe_makeclasspath`: This generates a classpath string from JAR filenames'
  id: totrans-744
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oe_makeclasspath`：这是一个根据JAR文件名生成类路径字符串的工具。'
- en: '`oe_java_simple_wrapper`: This wraps your Java application in a shell script'
  id: totrans-745
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oe_java_simple_wrapper`：这是一个将Java应用程序封装在shell脚本中的工具。'
- en: '**The java-library bbclass**: This inherits the Java bbclass and extends it
    to create and install JAR files.'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**java-library bbclass**：该类继承了Java的bbclass，并扩展其功能以创建和安装JAR文件。'
- en: How to do it...
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'We will use the following `meta-custom/recipes-java/java-helloworld/java-helloworld-1.0/HelloWorldSwing.java`
    graphical Swing hello world as an example:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下的`meta-custom/recipes-java/java-helloworld/java-helloworld-1.0/HelloWorldSwing.java`图形化Swing
    Hello World作为示例：
- en: '[PRE156]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'To integrate this `HelloWorldSwing` application, we can use a Yocto `meta-custom/recipes-java/java-helloworld/java-helloworld_1.0.bb`
    recipe as follows:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成这个`HelloWorldSwing`应用程序，我们可以使用一个Yocto `meta-custom/recipes-java/java-helloworld/java-helloworld_1.0.bb`食谱，如下所示：
- en: '[PRE157]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The recipe is also buildable for the host native architecture. We can do this
    either by providing a separate `java-helloworld-native` recipe that inherits the
    `native` class or by using the `BBCLASSEXTEND` variable as we did earlier. In
    both cases, we could then use the `_class-native` and `_class-target` overrides
    to differentiate between native and target functionality.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱也可以为主机本地架构构建。我们可以通过提供一个单独的`java-helloworld-native`食谱，该食谱继承`native`类，或者像之前一样使用`BBCLASSEXTEND`变量来实现。在这两种情况下，我们可以使用`_class-native`和`_class-target`覆盖选项，以区分本地和目标功能。
- en: Even though Java is byte-compiled and the compiled class will be the same for
    both, it still makes sense to add the native support explicitly.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Java是字节编译的，且编译后的类在两者之间是相同的，但显式地添加本地支持仍然是有意义的。
- en: How it works...
  id: totrans-754
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `java-library` class will create a library package with the name `lib<package>-java`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '`java-library`类将创建一个名为`lib<package>-java`的库包。'
- en: 'To add it to a target image, we would use:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其添加到目标镜像中，我们将使用：
- en: '[PRE158]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We can then decide whether we want to run the application with the Oracle JRE
    or OpenJDK. For OpenJDK, we will add the following packages to our image:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以决定是否使用Oracle JRE或OpenJDK运行应用程序。对于OpenJDK，我们将向我们的镜像中添加以下软件包：
- en: '[PRE159]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'And for the Oracle JRE, we will use the following:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Oracle JRE，我们将使用以下内容：
- en: '[PRE160]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The available JREs do not currently run over the framebuffer or Wayland, so
    we will use an X11-based graphical image like `core-image-sato`:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 目前可用的JRE无法在帧缓冲或Wayland上运行，因此我们将使用基于X11的图形镜像，如`core-image-sato`：
- en: '[PRE161]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'We can then boot it, log in to the target, and execute the example with OpenJDK
    by running:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以启动目标系统，登录并通过运行以下命令使用OpenJDK执行示例：
- en: '[PRE162]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: There's more...
  id: totrans-766
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'At the time of this writing, OpenJDK as built from the `meta-java` layer master
    branch is not able to run X11 applications and will fail with this exception:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在写本文时，从`meta-java`层主分支构建的OpenJDK无法运行X11应用程序，并将出现以下异常：
- en: '[PRE163]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'However, the precompiled Oracle JRE runs the application without issues with:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，预编译的Oracle JRE能够无问题地运行该应用程序：
- en: '[PRE164]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Note
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you see build errors when building packages with the Oracle JRE, try using
    a different package format, for example, IPK, by adding the following to your
    `conf/local.conf` configuration file:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用Oracle JRE构建软件包时遇到构建错误，可以尝试使用其他包格式，例如IPK，通过在`conf/local.conf`配置文件中添加以下内容：
- en: '[PRE165]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: This is due to dependency problems in the `meta-oracle-java` layer with the
    RPM package manager, as explained in the layer's README file.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于`meta-oracle-java`层中的RPM包管理器存在依赖问题，具体情况请参见该层的README文件。
