- en: Chapter 4. Application Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：应用程序开发
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下配方：
- en: Introducing toolchains
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍工具链
- en: Preparing and using an SDK
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备和使用 SDK
- en: Using the Application Development Toolkit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序开发工具包
- en: Using the Eclipse IDE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Eclipse IDE
- en: Developing GTK+ applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 GTK+ 应用程序
- en: Using the Qt Creator IDE
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt Creator IDE
- en: Developing Qt applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 Qt 应用程序
- en: Describing workflows for application development
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述应用程序开发的工作流
- en: Working with GNU make
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GNU make
- en: Working with the GNU build system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GNU 构建系统
- en: Working with the CMake build system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake 构建系统
- en: Working with the SCons builder
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SCons 构建工具
- en: Developing with libraries
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库进行开发
- en: Working with the Linux framebuffer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Linux 帧缓冲区
- en: Using the X Windows system
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 X Windows 系统
- en: Using Wayland
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Wayland
- en: Adding Python applications
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 Python 应用程序
- en: Integrating the Oracle Java Runtime Environment
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Oracle Java 运行时环境
- en: Integrating the Open Java Development Kit
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Open Java 开发工具包
- en: Integrating Java applications
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Java 应用程序
- en: Introduction
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Dedicated applications are what define an embedded product, and Yocto offers
    helpful application development tools as well as the functionality to integrate
    with popular **Integrated Development Environments** (**IDE**) like Eclipse and
    Qt Creator. It also provides a wide range of utility classes to help in the integration
    of finished applications into the build system and the target images.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 专用应用程序是定义嵌入式产品的关键，Yocto 提供了有用的应用程序开发工具，以及与流行的 **集成开发环境**（**IDE**）如 Eclipse 和
    Qt Creator 集成的功能。它还提供了广泛的工具类，帮助将完成的应用程序集成到构建系统和目标映像中。
- en: This chapter will introduce the IDEs and show us how they are used to build
    and debug C and C++ applications on real hardware, and will explore application
    development, including graphical frameworks and Yocto integration, not only for
    C and C++ but also Python and Java applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 IDE，并向我们展示如何在真实硬件上使用它们构建和调试 C 和 C++ 应用程序，同时探索应用程序开发，包括图形框架和 Yocto 集成，不仅适用于
    C 和 C++，还包括 Python 和 Java 应用程序。
- en: Introducing toolchains
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍工具链
- en: A toolchain is a set of tools, binaries, and libraries used to build applications
    to run on a computer platform. In Yocto, the toolchains are based on GNU components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是一组用于构建应用程序以在计算机平台上运行的工具、二进制文件和库。在 Yocto 中，工具链基于 GNU 组件。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'A GNU toolchain contains the following components:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 GNU 工具链包含以下组件：
- en: '**Assembler (GNU as)**: This is part of the binutils package'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇编器（GNU as）**：这是 binutils 包的一部分'
- en: '**Linker (GNU ld)**: This is also part of the binutils package'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接器（GNU ld）**：这也是 binutils 包的一部分'
- en: '**Compiler (GNU gcc)**: This has support for C, C++, Java, Ada, Fortran, and
    Objective C'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器（GNU gcc）**：支持 C、C++、Java、Ada、Fortran 和 Objective C'
- en: '**Debugger (GNU gdb)**: This is the GNU debugger'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器（GNU gdb）**：这是 GNU 调试器'
- en: '**Binary file tools (objdump, nm, objcopy, readelf, strip, and so on)**: These
    are part of the binutils package.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制文件工具（objdump、nm、objcopy、readelf、strip 等）**：这些是 binutils 包的一部分。'
- en: These components are enough to build bare metal applications, bootloaders like
    U-Boot, or operating systems like the Linux kernel, as they don't need a C library
    and they implement the C library functions they need. However, for Linux user
    space applications, a POSIX-compliant C library is needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件足以构建裸机应用程序、引导程序（如 U-Boot）或操作系统（如 Linux 内核），因为它们不需要 C 库，并且实现了所需的 C 库函数。然而，对于
    Linux 用户空间应用程序，则需要一个符合 POSIX 标准的 C 库。
- en: The GNU C library, `glibc`, is the default C library used in the Yocto project.
    Yocto is introducing support for musl, a smaller C library, but as we have mentioned
    before, there is still work to be done until it is ready to be used with the hardware
    platforms supported by the FSL community layer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库，`glibc`，是 Yocto 项目中使用的默认 C 库。Yocto 正在引入对 musl（一个较小的 C 库）的支持，但正如我们之前提到的，仍需进行一些工作，才能在
    FSL 社区层支持的硬件平台上使用。
- en: 'But on embedded systems, it is not just a toolchain we need, but a cross-compilation
    toolchain. This is because we build in a host computer but run the resulting binaries
    on the target, which is usually a different architecture. In reality, there are
    several types of toolchains, based on the architecture of the machine building
    the toolchain (build machine), running the toolchain (host machine), and running
    the binaries built by the toolchain (target machine). The most common combinations
    are:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在嵌入式系统中，我们不仅需要一个工具链，还需要一个交叉编译工具链。这是因为我们在主机计算机上构建，但将生成的二进制文件在目标机器上运行，而目标机器通常具有不同的架构。实际上，工具链有几种类型，基于构建工具链的机器架构（构建机器）、运行工具链的机器架构（主机机器）和运行工具链构建的二进制文件的机器架构（目标机器）。最常见的组合有：
- en: '**Native**: An example of this is an x86 machine running a toolchain that has
    also been built on an x86 machine producing binaries to run on an x86 machine.
    This is common in desktop computers.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地**：一个例子是运行在 x86 机器上的工具链，该工具链也是在 x86 机器上构建的，并生成用于在 x86 机器上运行的二进制文件。这在桌面计算机中很常见。'
- en: '**Cross-compilation**: This is the most common on embedded systems; for example,
    an x86 machine running a toolchain that has also been built on an x86 machine
    but producing binaries to run on a different architecture, like ARM.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉编译**：这是嵌入式系统中最常见的情况；例如，一台 x86 机器运行着在 x86 机器上构建的工具链，但生成用于在不同架构上运行的二进制文件，如
    ARM。'
- en: '**Cross-native**: This is typically the toolchain running on targets. An example
    of this is where a toolchain has been built on an x86 machine but runs on ARM
    and produces binaries for ARM.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉本地**：这通常是运行在目标上的工具链。例如，工具链是在 x86 机器上构建的，但它在 ARM 上运行并生成 ARM 用的二进制文件。'
- en: '**Canadian**: Rarely seen, this is where the build, host, and target machines
    are all different.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加拿大**：很少见，这里构建、主机和目标机器都是不同的。'
- en: The process of building a cross-compilation toolchain is complex and fault prone,
    so automated tools for toolchain building have emerged, like **buildroot** and
    **crosstool-NG**. The Yocto build system also compiles its own toolchain on every
    build, and as we will see, you can use this toolchain for application development
    too.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 构建交叉编译工具链的过程复杂且容易出错，因此自动化的工具链构建工具应运而生，如**buildroot**和**crosstool-NG**。Yocto
    构建系统在每次构建时都会编译自己的工具链，正如我们将看到的，你也可以使用这个工具链进行应用程序开发。
- en: But the cross-compilation toolchain and C library are not the only things we
    need in order to build applications; we also need a `sysroot`; that is, a root
    filesystem on the host with the libraries and header files that can be found on
    the target root filesystem.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是交叉编译工具链和 C 库并不是构建应用程序所需的唯一内容；我们还需要一个`sysroot`，即在主机上具有与目标根文件系统相同的库和头文件的根文件系统。
- en: The combination of the cross-compilation toolchain, the `sysroot`, and sometimes
    other development tools such as an IDE is referred to as an SDK, or Software Development
    Kit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译工具链、`sysroot`，以及有时的其他开发工具（如 IDE）的组合被称为 SDK，即软件开发工具包。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'There are several ways to obtain an SDK with the Yocto project:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Yocto 项目获取 SDK 的方式有几种：
- en: Using the **Application Development Toolkit** (**ADT**).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**应用程序开发工具包**（**ADT**）。
- en: If you are using a hardware platform supported by Poky (that is, a virtualized
    QEMU machine or one of the reference boards), the recommendation is to use ADT,
    which will install all the required SDK components for you.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是 Poky 支持的硬件平台（即虚拟化的 QEMU 机器或其中一块参考板），建议使用 ADT，它会为你安装所有所需的 SDK 组件。
- en: Downloading a precompiled toolchain.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载预编译的工具链。
- en: 'The easiest way to obtain a cross-compilation toolchain for a supported platform
    is to download a precompiled one; for example from the Yocto project downloads
    site, [http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/).
    The Yocto project provides prebuilt toolchains for both 32- and 64-bit i686 host
    machines, and prebuilt ARM toolchains both for **armv5** and **armv7** architectures.
    These contain `sysroot` that match the `core-image-sato` target image. However,
    the prebuilt `sysroot` is soft floating point, so it can''t be used with the target
    images built by the FSL community layer for i.MX6-based platforms, which are hard
    floating point. To install the prebuilt armv7 toolchain for an x86_64 host, run
    the following:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取支持平台的交叉编译工具链最简单的方法是下载一个预编译的版本；例如，可以从Yocto项目下载站点获取：[http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/)。Yocto项目为32位和64位i686主机提供预构建的工具链，并为**armv5**和**armv7**架构提供预构建的ARM工具链。这些工具链包含与`core-image-sato`目标映像匹配的`sysroot`。然而，预构建的`sysroot`是软浮点的，因此无法与FSL社区层为基于i.MX6的平台构建的目标映像一起使用，因为它们是硬浮点的。要为x86_64主机安装预构建的armv7工具链，请运行以下命令：
- en: '[PRE0]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Building your own toolchain installer.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你自己的工具链安装程序。
- en: On most embedded Linux projects, your machine will be supported by an external
    layer, and you will have a customized root filesystem that your `sysroot` will
    need to match. So building your own toolchain installer is recommended when you
    have a customized root filesystem. For example, the ideal toolchain to work with
    the Wandboard would be **Cortex-A9**-specific and targeted to produce hard floating
    point binaries.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数嵌入式Linux项目中，你的机器将由外部层支持，并且你将拥有一个定制的根文件系统，你的`sysroot`需要与其匹配。因此，当你有一个定制的根文件系统时，推荐构建你自己的工具链安装程序。例如，适合与Wandboard配合使用的理想工具链应该是**Cortex-A9**特定的，并且针对生成硬浮点二进制文件。
- en: Using the Yocto project build system.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Yocto项目构建系统。
- en: Finally, if you already have a Yocto build system installation on your host,
    you can also use it for application development. Usually, application developers
    do not need the complexity of a Yocto build system installation, so a toolchain
    installer for the target system will be enough.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，如果你的主机上已经安装了Yocto构建系统，你也可以用它来进行应用程序开发。通常，应用程序开发人员不需要Yocto构建系统安装的复杂性，因此一个针对目标系统的工具链安装程序就足够了。
- en: Preparing and using an SDK
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备和使用SDK
- en: The Yocto build system can be used to generate a cross-compilation toolchain
    and matching `sysroot` for a target system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto构建系统可以用来为目标系统生成交叉编译工具链和匹配的`sysroot`。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will use the previously used `wandboard-quad` build directory and source
    the `setup-environment` script as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前使用过的`wandboard-quad`构建目录，并按照以下方式加载`setup-environment`脚本：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are several ways to build an SDK with the Yocto build system:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yocto构建系统构建SDK有几种方式：
- en: The `meta-toolchain` target.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-toolchain`目标。'
- en: 'This method will build a toolchain that matches your target platform, and a
    basic `sysroot` that will not match your target root filesystem. However, this
    toolchain can be used to build bare metal software like the U-Boot bootloader
    or the Linux kernel, which do not need a `sysroot`. The Yocto project offers downloadable
    `sysroot` for the supported hardware platforms. You can also build this toolchain
    yourself with:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法将构建一个与目标平台匹配的工具链，以及一个基本的`sysroot`，但它不会与目标根文件系统匹配。然而，这个工具链可以用来构建裸机软件，比如U-Boot引导加载程序或Linux内核，它们不需要`sysroot`。Yocto项目为支持的硬件平台提供可下载的`sysroot`。你也可以使用以下方法自行构建这个工具链：
- en: '[PRE2]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once built, it can be installed with:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建完成后，可以使用以下命令安装：
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `populate_sdk` task.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`populate_sdk`任务。'
- en: 'This is the recommended way to build a toolchain matching your target platform
    with a `sysroot` matching your target root filesystem. You build it with:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是构建与目标平台匹配的工具链，并且`sysroot`匹配目标根文件系统的推荐方式。你可以使用以下命令进行构建：
- en: '[PRE4]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should replace `core-image-sato` for the target root filesystem image you
    want the `sysroot` to match. The resulting toolchain can be installed with:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该将`core-image-sato`替换为你希望`sysroot`匹配的目标根文件系统映像。构建完成的工具链可以使用以下命令安装：
- en: '[PRE5]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, if you want your toolchain to be able to build static applications, you
    need to add static libraries to it. You can do this by adding specific static
    libraries to your target image, which could also be used for native compilation.
    For example, to add the static `glibc` libraries, add the following to your `conf/local.conf`
    file:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，如果你希望工具链能够构建静态应用程序，则需要向其中添加静态库。你可以通过将特定的静态库添加到目标镜像来实现，静态库也可以用于本地编译。例如，要添加静态的`glibc`库，可以在`conf/local.conf`文件中添加以下内容：
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And then build the toolchain to match your root filesystem as explained previously.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，按照之前的说明构建工具链，以匹配你的根文件系统。
- en: 'You usually won''t want the static libraries added to your image, but do you
    want to be able to cross-compile static applications, so you can also add all
    the static libraries to the toolchain by adding:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，你不会希望将静态库添加到镜像中，但如果你希望能够交叉编译静态应用程序，则可以通过添加以下内容将所有静态库添加到工具链中：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `meta-toolchain-qt` target.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-toolchain-qt`目标。'
- en: 'This method will extend `meta-toolchain` to build Qt applications. We will
    see how to build Qt applications later on. To build this toolchain, execute the
    following command:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法将扩展`meta-toolchain`以构建Qt应用程序。稍后我们将看到如何构建Qt应用程序。要构建此工具链，请执行以下命令：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once built, it can be installed with:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦构建完成，可以使用以下命令进行安装：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The resulting toolchain installers will be located under `tmp/deploy/sdk` for
    all the cases mentioned here.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的工具链安装程序将位于`tmp/deploy/sdk`目录下，适用于此处提到的所有情况。
- en: The `meta-ide-support` target.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-ide-support`目标。'
- en: This method does not generate a toolchain installer, but it prepares the current
    build project to use its own toolchain. It will generate an `environment-setup`
    script inside the tmp directory.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法不会生成工具链安装程序，但它会准备当前的构建项目以使用其自己的工具链。它将在tmp目录中生成一个`environment-setup`脚本。
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To use the bundled toolchain, you can now source that script as follows:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用捆绑的工具链，你现在可以按如下方式引入该脚本：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the Application Development Toolkit
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序开发工具包
- en: 'The ADT is an SDK installation script that installs the following for Poky-supported
    hardware platforms:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ADT是一个SDK安装脚本，用于在Poky支持的硬件平台上安装以下内容：
- en: A prebuilt cross-compilation toolchain, as explained previously
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个预构建的交叉编译工具链，如前所述
- en: A `sysroot` that matches the `core-image-sato` target image
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`core-image-sato`目标镜像匹配的`sysroot`
- en: The QEMU emulator
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QEMU模拟器
- en: Other development user space tools used for system profiling (these will be
    discussed in the following chapters)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于系统分析的其他开发用户空间工具（将在后续章节中讨论）
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To install the ADT, you can choose either of the following options:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装ADT，可以选择以下两种方式之一：
- en: 'Download a precompiled tarball from the Yocto project downloads site with the
    following command:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令从Yocto项目的下载站点下载预编译的tarball：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Build one using your Yocto `build` directory.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你的Yocto`build`目录构建一个。
- en: The ADT installer is an automated script to install precompiled Yocto SDK components,
    so it will be the same whether you download the prebuilt version or you build
    one yourself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ADT安装程序是一个自动化脚本，用于安装预编译的Yocto SDK组件，因此无论你是下载预构建版本还是自己构建，都将是相同的。
- en: You can then configure it before running it to customize the installation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在运行之前配置它，以定制安装。
- en: Note that it only makes sense to use the ADT for the Poky-supported platforms.
    For instance, it is not that useful for external hardware like `wandboard-quad`
    unless you provide your own components.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ADT仅适用于Poky支持的平台。例如，除非提供自己的组件，否则它对于像`wandboard-quad`这样的外部硬件并没有多大用处。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To build the ADT from your Yocto `build` directory, open a new shell and execute
    the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要从你的Yocto`build`目录构建ADT，请打开一个新的shell并执行以下命令：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The ADT tarball will be located in the `tmp/deploy/sdk` directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ADT的tarball将位于`tmp/deploy/sdk`目录下。
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To install it, follow these steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，请按照以下步骤操作：
- en: 'Extract the tarball on a location of your choice:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将tarball提取到你选择的位置：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Configure the installation by editing the `adt_installer.conf` file. Some of
    the options are:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编辑`adt_installer.conf`文件来配置安装。一些选项包括：
- en: '`YOCTOADT_REPO`: This is a repository with the packages and root filesystem
    to be used. By default, it uses the one on the Yocto project web site, [http://adtrepo.yoctoproject.org/1.7.1/](http://adtrepo.yoctoproject.org/1.7.1/),
    but you could set one up yourself with your customized packages and root filesystem.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_REPO`：这是一个包含软件包和根文件系统的仓库。默认情况下，它使用 Yocto 项目网站上的仓库，[http://adtrepo.yoctoproject.org/1.7.1/](http://adtrepo.yoctoproject.org/1.7.1/)，但是你也可以自己设置一个，包含自定义的软件包和根文件系统。'
- en: '`YOCTOADT_TARGETS`: This defines the machine targets the SDK is for. By default,
    this is ARM and x86.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_TARGETS`：定义 SDK 的机器目标。默认情况下，这是 ARM 和 x86。'
- en: '`YOCTOADT_QEMU`: This option controls whether to install the QEMU emulator.
    The default is to install it.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_QEMU`：此选项控制是否安装 QEMU 模拟器。默认情况下会安装它。'
- en: '`YOCTOADT_NFS_UTIL`: This option controls whether to install user mode NFS.
    It is recommended if you are going to use the Eclipse IDE with QEMU-based machines.
    The default is to install it.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_NFS_UTIL`：此选项控制是否安装用户模式 NFS。如果你打算在基于 QEMU 的机器上使用 Eclipse IDE，建议启用此选项。默认情况下会安装它。'
- en: 'And then for the specific target architectures (only shown for ARM):'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后针对特定目标架构（仅针对 ARM 显示）：
- en: '`YOCTOADT_ROOTFS_arm`: This defines the specific root filesystem images to
    download from the ADT repository. By default it installs the `minimal` and `sato-sdk`
    images.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_ROOTFS_arm`：定义从 ADT 仓库下载的特定根文件系统镜像。默认情况下，安装 `minimal` 和 `sato-sdk`
    镜像。'
- en: '`YOCTOADT_TARGET_SYSROOT_IMAGE_arm`: This is the root filesystem used to create
    the `sysroot`. This must also be included in the `YOCTOADT_ROOTFS_arm` selection
    that was explained earlier. By default this is the `sato-sdk` image.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_TARGET_SYSROOT_IMAGE_arm`：这是用于创建 `sysroot` 的根文件系统。此选项必须包含在之前说明过的
    `YOCTOADT_ROOTFS_arm` 选择中。默认情况下，这是 `sato-sdk` 镜像。'
- en: '`YOCTOADT_TARGET_MACHINE_arm`: This is the machine that the images are downloaded
    for. By default this is `qemuarm`.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_TARGET_MACHINE_arm`：这是下载镜像的机器类型。默认情况下，这是 `qemuarm`。'
- en: '`YOCTOADT_TARGET_SYSROOT_LOC_arm`: This is the path on the host to install
    the target''s `sysroot`. By default this is `$HOME/test-yocto/`.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YOCTOADT_TARGET_SYSROOT_LOC_arm`：这是主机上安装目标 `sysroot` 的路径。默认情况下是 `$HOME/test-yocto/`。'
- en: 'Run the ADT installer as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式运行 ADT 安装程序：
- en: '[PRE15]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It will ask for an installation location (by default `/opt/poky/1.7.1`) and
    whether you want to run it in interactive or silent mode.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装过程中将提示你选择安装位置（默认是 `/opt/poky/1.7.1`），并询问是否以交互模式或静默模式运行。
- en: Using the Eclipse IDE
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Eclipse IDE
- en: Eclipse is an open source IDE that is written mostly in Java and released under
    the **Eclipse Public License** (**EPL**). It can be extended using plugins, and
    the Yocto project releases a Yocto plugin that allows us to use Eclipse for application
    development.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 是一个开源集成开发环境（IDE），主要使用 Java 编写，并根据 **Eclipse 公共许可证**（**EPL**）发布。它可以通过插件进行扩展，Yocto
    项目发布了一个 Yocto 插件，允许我们使用 Eclipse 进行应用开发。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Yocto 1.7 provides Eclipse Yocto plugins for two different Eclipse versions,
    Juno and Kepler. They can be downloaded at [http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/).
    We will use Kepler 4.3, as it is the newest. We will start with the Eclipse Kepler
    standard edition and install all the required plugins we need.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 1.7 为两个不同版本的 Eclipse 提供了 Yocto 插件，分别是 Juno 和 Kepler。它们可以从 [http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/)
    下载。我们将使用 Kepler 4.3，因为它是最新的。我们将从 Eclipse Kepler 标准版开始，并安装所需的所有插件。
- en: 'It is recommended to run Eclipse under Oracle Java 1.7, although other Java
    providers are supported. You can install Oracle Java 1.7 from Oracle''s web site,
    [https://www.java.com/en/](https://www.java.com/en/), or using a Ubuntu Java Installer
    PPA, [https://launchpad.net/~webupd8team/+archive/ubuntu/java](https://launchpad.net/~webupd8team/+archive/ubuntu/java).
    The latter will integrate Java with your package management system, so it''s preferred.
    To install it, follow these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐在 Oracle Java 1.7 下运行 Eclipse，尽管其他 Java 提供商也受支持。你可以从 Oracle 网站安装 Oracle Java
    1.7，[https://www.java.com/en/](https://www.java.com/en/)，或者使用 Ubuntu Java 安装程序
    PPA，[https://launchpad.net/~webupd8team/+archive/ubuntu/java](https://launchpad.net/~webupd8team/+archive/ubuntu/java)。后者将
    Java 与你的包管理系统集成，因此更为推荐。安装步骤如下：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To download and install Eclipse Kepler standard edition for an x86_64 host,
    follow these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载并安装适用于 x86_64 主机的 Eclipse Kepler 标准版，请按以下步骤操作：
- en: 'Fetch the tarball from the Eclipse download site, [http://eclipse.org/downloads/packages/release/Kepler/SR2](http://eclipse.org/downloads/packages/release/Kepler/SR2).
    For example:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Eclipse 下载站点获取 tar 包，[http://eclipse.org/downloads/packages/release/Kepler/SR2](http://eclipse.org/downloads/packages/release/Kepler/SR2)。例如：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Unpack it on a location of your choice as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其解压到你选择的位置，如下所示：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Start the Eclipse IDE with the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse IDE，使用以下命令：
- en: '[PRE19]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Select **Install New Software** from the **Help** pull-down menu. Then select
    the **Kepler - http://download.eclipse.org/releases/kepler** source.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**帮助**下拉菜单中选择**安装新软件**。然后选择**Kepler - http://download.eclipse.org/releases/kepler**源。
- en: 'Install the following Eclipse components:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装以下 Eclipse 组件：
- en: 'Linux tools:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 工具：
- en: '**LTTng - Linux Tracing Toolkit**'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**LTTng - Linux 跟踪工具包**'
- en: 'Mobile and device development:'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动和设备开发：
- en: '**C/C++ Remote Launch**'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**C/C++ 远程启动**'
- en: '**Remote System Explorer End-user Runtime**'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**远程系统浏览器最终用户运行时**'
- en: '**Remote System Explorer User Actions**'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**远程系统浏览器用户操作**'
- en: '**Target Management Terminal**'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**目标管理终端**'
- en: '**TCF Remote System Explorer add-in**'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**TCF 远程系统浏览器插件**'
- en: '**TCF Target Explorer**'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**TCF 目标浏览器**'
- en: 'Programming languages:'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程语言：
- en: '**C/C++ Autotools Support**'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**C/C++ 自动工具支持**'
- en: '**C/C++ Development Tools**'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**C/C++ 开发工具**'
- en: 'Install the Eclipse Yocto plugin by adding this repository source: [http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler](http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler),
    as shown in the following screenshot:![Getting ready](img/5186OS_04_01.jpg)'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加此仓库源来安装 Eclipse Yocto 插件：[http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler](http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler)，如以下截图所示：![准备就绪](img/5186OS_04_01.jpg)
- en: Choose **Yocto Project ADT plug-in** and ignore the unsigned content warning.
    We won't be covering other plugin extensions.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Yocto 项目 ADT 插件**并忽略未签名的内容警告。我们不会覆盖其他插件扩展。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To configure Eclipse to use a Yocto toolchain, go to **Window** | **Preferences**
    | **Yocto Project ADT**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Eclipse 使用 Yocto 工具链，请转到 **窗口** | **首选项** | **Yocto 项目 ADT**。
- en: 'The ADT configuration offers two cross-compiler options:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ADT 配置提供了两种交叉编译器选项：
- en: '**Standalone pre-built toolchain**: Choose this when you have installed a toolchain
    either from a toolchain installer or the ADT installer.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**独立预构建工具链**：当你通过工具链安装程序或 ADT 安装程序安装了工具链时，请选择此项。'
- en: '**Build system derived toolchain**: Choose this when using a Yocto `build`
    directory prepared with `meta-ide-support` as explained previously.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于构建系统的工具链**：当使用之前提到的通过 `meta-ide-support` 准备的 Yocto `build` 目录时，请选择此项。'
- en: 'It also offers two target options:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了两个目标选项：
- en: '**The QEMU emulator**: Choose this if you are using Poky with a virtualized
    machine and you have used the ADT installer to install a `qemuarm` Linux kernel
    and root filesystem.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**QEMU 模拟器**：如果你使用的是虚拟化机器上的 Poky，并且已经使用 ADT 安装程序安装了 `qemuarm` Linux 内核和根文件系统，请选择此项。'
- en: '**External hardware**: Choose this if you are using real hardware like the
    `wandboard-quad` hardware. This option is the most useful for embedded development.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**外部硬件**：如果你使用的是像 `wandboard-quad` 这样的真实硬件，请选择此选项。此选项对于嵌入式开发最为有用。'
- en: 'An example configuration when using the ADT installer with its default configuration
    would be to choose the standalone prebuilt toolchain option along with the QEMU
    emulator as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ADT 安装程序及其默认配置时的示例配置是选择独立预构建的工具链选项，并配合 QEMU 模拟器，如下所示：
- en: 'Cross-compiler options:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译器选项：
- en: 'Standalone pre-built toolchain:'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立预构建的工具链：
- en: '**Toolchain root location**: `/opt/poky/1.7.1`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**工具链根位置**：`/opt/poky/1.7.1`'
- en: '**Sysroot location**: `${HOME}/test-yocto/qemuarm`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Sysroot 位置**：`${HOME}/test-yocto/qemuarm`'
- en: '**Target architecture**: `armv5te-poky-linux-gnueabi`'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**目标架构**：`armv5te-poky-linux-gnueabi`'
- en: 'Target options:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标选项：
- en: '**QEMU kernel**: `/tmp/adt-installer/download_image/zImage-qemuarm.bin`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**QEMU 内核**：`/tmp/adt-installer/download_image/zImage-qemuarm.bin`'
- en: '![How to do it...](img/5186OS_04_02.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_02.jpg)'
- en: 'And for a build system derived toolchain using the `wandboard-quad` reference
    board, this is what you will need:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 `wandboard-quad` 参考板的基于构建系统的工具链，你将需要以下内容：
- en: 'Cross-compiler options:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译器选项：
- en: 'Build system derived toolchain:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于构建系统的工具链：
- en: '**Toolchain root location**: `/opt/yocto/fsl-community-bsp/wandboard-quad`'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**工具链根位置**：`/opt/yocto/fsl-community-bsp/wandboard-quad`'
- en: '**Sysroot location**: `/opt/yocto/fsl-community-bsp/wandboard-quad/tmp/sysroots/wandboard-quad`'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Sysroot 位置**：`/opt/yocto/fsl-community-bsp/wandboard-quad/tmp/sysroots/wandboard-quad`'
- en: '![How to do it...](img/5186OS_04_03.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_03.jpg)'
- en: There's more...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In order to perform debugging on a remote target, it needs to be running the
    `tcf-agent` daemon. It is included by default on the SDK images, but you can also
    include it in any other image by adding the following to your `conf/local.conf`
    file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在远程目标上进行调试，目标需要运行 `tcf-agent` 守护进程。它默认包含在 SDK 镜像中，但你也可以通过在 `conf/local.conf`
    文件中添加以下内容将其包含到其他镜像中：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information, refer to the *Yocto Project Application Developer's Guide*
    at [http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html](http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多信息，请参阅 *Yocto 项目应用程序开发者指南*，网址：[http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html](http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html)
- en: Developing GTK+ applications
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 GTK+ 应用程序
- en: This recipe will show how to build, run, and debug a graphical GTK+ application
    using the Eclipse IDE.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将展示如何使用 Eclipse IDE 构建、运行和调试图形化 GTK+ 应用程序。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Add the `eclipse-debug` feature to your project''s `conf/local.conf` file as
    follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，将 `eclipse-debug` 功能添加到项目的 `conf/local.conf` 文件中：
- en: '[PRE21]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Build a `core-image-sato` target image as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，构建一个 `core-image-sato` 目标镜像：
- en: '[PRE22]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Build a `core-image-sato` toolchain as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示构建一个 `core-image-sato` 工具链：
- en: '[PRE23]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Install the toolchain as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示安装工具链：
- en: '[PRE24]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before launching the Eclipse IDE, we can check whether we are able to build
    and launch a GTK application manually. We will build the following GTK+ hello
    world application:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Eclipse IDE 之前，我们可以检查是否能够手动构建并启动一个 GTK 应用程序。我们将构建以下 GTK+ Hello World 应用程序：
- en: 'The following is a code for `gtk_hello_world.c`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `gtk_hello_world.c` 的代码：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To build it, we use the `core-image-sato` toolchain installed as described
    previously:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建它，我们使用之前描述的安装好的 `core-image-sato` 工具链：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command uses the `pkg-config` helper tool to read the `.pc` files that
    are installed with the GTK libraries in the `sysroot` to determine which compiler
    switches (`--cflags` for `include` directories and `--libs` for the libraries
    to link with) are needed to compile programs that use GTK.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令使用 `pkg-config` 辅助工具读取与 GTK 库一起安装在 `sysroot` 中的 `.pc` 文件，以确定编译使用 GTK 的程序所需的编译器选项（`--cflags`
    用于 `include` 目录，`--libs` 用于要链接的库）。
- en: 'We can manually copy the resulting binary to our Wandboard while booting `core-image-sato`
    over NFS and run it from the target''s console with:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动将生成的二进制文件复制到 Wandboard，并在通过 NFS 启动 `core-image-sato` 时，从目标控制台运行：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will open a GTK+ window over the SATO desktop.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个 GTK+ 窗口，显示在 SATO 桌面上。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We can now configure the Eclipse ADT plugin using the standalone toolchain as
    described before, or we could decide to use the build system derived toolchain
    instead.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用前面描述的独立工具链配置 Eclipse ADT 插件，或者我们也可以决定使用派生自构建系统的工具链。
- en: '![How to do it...](img/5186OS_04_04.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_04_04.jpg)'
- en: 'Follow the next steps to build and run an example hello world application:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建并运行一个示例 Hello World 应用程序：
- en: Create a new hello world GTK autotools project. Accept all the defaults in the
    project creation wizard. Browse to **File** | **New** | **Project** | **C/C++**
    | **C Project** | **Yocto Project ADT Autotools Project** | **Hello World GTK
    C Autotools Project**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Hello World GTK Autotools 项目。在项目创建向导中接受所有默认选项。浏览到 **文件** | **新建** | **项目**
    | **C/C++** | **C 项目** | **Yocto 项目 ADT Autotools 项目** | **Hello World GTK C Autotools
    项目**。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When choosing a name for your project, avoid using special characters like dashes,
    as they could cause problems with the build tools.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在为项目命名时，请避免使用破折号等特殊字符，因为它们可能会导致构建工具出现问题。
- en: Build the project by going to **Project** | **Build Project**.![How to do it...](img/5186OS_04_05.jpg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **项目** | **构建项目** 来构建项目。![如何操作...](img/5186OS_04_05.jpg)
- en: Even though the project builds successfully, you may see errors both marked
    in the source and in the **Problems** tab. This is because the Eclipse's code
    analysis feature cannot resolve all the project's symbols. To resolve it, add
    the needed `include` header files to your project's properties by going to **Project**
    | **Properties** | **C/C++ General** | **Paths and Symbols** | **Includes**.![How
    to do it...](img/5186OS_04_06.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使项目成功构建，您也可能会看到源代码和 **问题** 标签中标记的错误。这是因为 Eclipse 的代码分析功能无法解析项目的所有符号。为了解决这个问题，您需要通过以下路径将所需的
    `include` 头文件添加到项目属性中：**项目** | **属性** | **C/C++ 常规** | **路径和符号** | **包含**。![如何操作...](img/5186OS_04_06.jpg)
- en: Under **Run** | **Run Configurations**, you should have **C/C++ Remote Application**
    with a TCF target called `<project_name>_gdb_arm-poky-linux-gnueabi`. If you don't,
    create one.![How to do it...](img/5186OS_04_07.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**运行** | **运行配置**下，你应该有一个名为`<project_name>_gdb_arm-poky-linux-gnueabi`的**C/C++远程应用程序**与TCF目标。如果没有，创建一个。![如何操作...](img/5186OS_04_07.jpg)
- en: Create a new TCF connection to the target's IP address using the **New...**
    button in the **Main** tab.![How to do it...](img/5186OS_04_08.jpg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**新建...**按钮在**主**选项卡中创建一个到目标IP地址的新TCF连接。![如何操作...](img/5186OS_04_08.jpg)
- en: Fill in the **Remote Absolute File Path for C/C++ Application** field with the
    path to the binary and include the binary name; for example, `/gtk_hello_world`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**C/C++应用程序的远程绝对文件路径**字段中填写二进制文件的路径，并包括二进制文件名；例如，`/gtk_hello_world`。
- en: In the **Commands to execute before application** field, enter `export DISPLAY=:0`.![How
    to do it...](img/5186OS_04_09.jpg)
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**应用程序执行前的命令**字段中，输入`export DISPLAY=:0`。![如何操作...](img/5186OS_04_09.jpg)
- en: Run the application and log in as `root` with an empty password. You should
    see the GTK application on your SATO desktop, and the following output in the
    Console tab:![How to do it...](img/5186OS_04_23.jpg)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并以`root`用户登录，密码为空。你应该能够在SATO桌面上看到GTK应用程序，并在控制台标签中看到以下输出：![如何操作...](img/5186OS_04_23.jpg)
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you have problems connecting to the target, verify that it is running `tcf-agent`
    by typing in the following on the target''s console:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在连接目标时遇到问题，可以通过在目标的控制台输入以下命令来验证它是否正在运行` tcf-agent`：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you have login problems, you can use Eclipse's **Remote System Explorer**
    (**RSE)** perspective to clear passwords and debug the connection to the target.
    Once the connection can be established and you are able to browse the target's
    filesystem through RSE, you can come back to the run configuration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到登录问题，可以使用Eclipse的**远程系统资源管理器**（**RSE**）视图来清除密码并调试与目标的连接。一旦能够建立连接，并且通过RSE浏览目标的文件系统，你可以返回到运行配置。
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To debug the application, follow these steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试应用程序，请按照以下步骤进行：
- en: Go to **Run** | **Debug Configuration**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**运行** | **调试配置**。
- en: Under the **Debugger** tab, verify the GDB debugger path is the correct toolchain
    debugger location.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**调试器**标签下，验证GDB调试器路径是否指向正确的工具链调试器位置。
- en: '[PRE29]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If it isn't, point it to the correct location.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有，指向正确的位置。
- en: '![There''s more...](img/5186OS_04_10.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![还有更多...](img/5186OS_04_10.jpg)'
- en: Double-click on the `main` function in the source file to add a breakpoint.
    A blue dot will appear on the side bar.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击源文件中的`main`函数以添加断点。侧边栏将显示一个蓝点。
- en: Click on the **Debug** button. The debug perspective appears with the application
    executing on the remote Wandboard hardware.![There's more...](img/5186OS_04_11.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**调试**按钮，调试视图出现，并且应用程序在远程Wandboard硬件上执行。![还有更多...](img/5186OS_04_11.jpg)
- en: Tip
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you get **Text file busy** error, remember to close the application we ran
    on the previous point.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果遇到**文本文件正忙**错误，请记得关闭我们在前一点运行的应用程序。
- en: Using the Qt Creator IDE
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt Creator IDE
- en: Qt Creator is a multiplatform IDE part of the Qt Application Development Framework
    SDK. It is the IDE of choice for Qt application development and is available with
    multiple licenses, including GPLv3, LGPLv2, and commercial licenses as well.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator是一个多平台的IDE，属于Qt应用程序开发框架SDK的一部分。它是Qt应用程序开发的首选IDE，并提供多种许可证，包括GPLv3、LGPLv2和商业许可证。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Download and install the Qt Creator 3.3.0 for your host from the Qt project
    downloads website. For downloading and installing an x86_64 Linux host, you can
    use the following commands:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Qt项目下载网站下载并安装适合你主机的Qt Creator 3.3.0版本。对于x86_64 Linux主机的下载和安装，你可以使用以下命令：
- en: '[PRE30]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Build a toolchain that is ready to develop Qt applications with the following:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个准备好开发Qt应用程序的工具链，使用以下命令：
- en: '[PRE31]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Install it as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式安装：
- en: '[PRE32]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Before launching Qt Creator, we need to set up the development environment.
    To make this happen automatically when we launch Qt Creator, we can patch its
    initialization script by adding the following line right at the beginning of the
    `bin/qtcreator.sh` file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Qt Creator之前，我们需要设置开发环境。为了在启动Qt Creator时自动完成这一过程，我们可以通过在`bin/qtcreator.sh`文件的开头添加以下行来修补其初始化脚本：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the environment initialization script is placed before the hash bang.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，环境初始化脚本位于哈希标记之前。
- en: 'Now we can run Qt Creator as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式运行Qt Creator：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And configure it by going to **Tools** | **Options** and using the following
    steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: First we configure a new device for our Wandboard. Under **Devices** | **Add**,
    we select **Generic Linux Device**.![How to do it...](img/5186OS_04_12.jpg)
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the root password in the target by using the `passwd` command from the target's
    root console and type it in the password field.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under **Build & Run**, we configure a new compiler pointing to the Yocto `meta-toolchain-qt`
    compiler path we just installed. Here''s the path as shown in the following screenshot:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![How to do it...](img/5186OS_04_13.jpg)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Similarly for a cross-debugger, the following is the path which is also mentioned
    in the following screenshot:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![How to do it...](img/5186OS_04_14.jpg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'And then we configure Qt by selecting the `qmake` builder from the toolchain.
    Here''s the path which is also mentioned in the following screenshot:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![How to do it...](img/5186OS_04_15.jpg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally we configure a new kit as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Generic Linux Device** and configure its `sysroot` to:'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Select the compiler, debugger, and Qt version we just defined.![How to do it...](img/5186OS_04_16.jpg)
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In Ubuntu, Qt Creator stores its configuration on the user's home directory
    under `.config/QtProject/`.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Developing Qt applications
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how to build, run, and debug a graphical Qt application
    using Qt Creator.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before launching Qt Creator, we check whether we are able to build and launch
    a Qt application manually. We will build a Qt hello world application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `qt_hello_world.cpp`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To build it, we use the `meta-toolchain-qt` installed as described previously:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This uses `qmake` to create a project file and a `Makefile` file with all the
    relevant code files in the folder.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'To run it, we first need to build a filesystem with Qt support. We first prepare
    the environment as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And configure our project with the `qt4-pkgs` extra feature by adding the following
    to `conf/local.conf`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And for Qt applications, we also need the **International Component for Unicode**
    (**ICU**) library, as the Qt libraries are compiled with support for it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And build it with:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once finished, we can program the microSD card image and boot the Wandboard.
    Copy the `qt_hello_world` binary to the target and run:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You should see the Qt hello world window on the X11 desktop.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build and run an example hello world application:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty project by going to **File** | **New File or Project** |
    **Other project** | **Empty qmake project**.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select only the **wandboard-quad** kit we just created.![How to do it...](img/5186OS_04_17.jpg)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new C++ file, `qt_hello_world.cpp`, by going to **File** | **New File
    or Project** | **C++** | **C++ Source File**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the contents of the `qt_hello_world.cpp` file into Qt Creator, as shown
    in the following screenshot:![How to do it...](img/5186OS_04_18.jpg)
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure your project with the target installation details by adding the following
    to your `hw.pro` file:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Replace `qt_hello_world` with the name of your project.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build the project. If you have build errors, verify that the Yocto build environment
    has been correctly set up.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can try to manually run the toolchain `environment-setup` script before
    launching Qt Creator.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go to **Projects** | **Run** and check your project settings.![How to do it...](img/5186OS_04_19.jpg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As can be seen in this screenshot, Qt Creator will use the SFTP protocol to
    transfer the files to the target. By default, the dropbear SSH server running
    on `core-image-sato` does not have SFTP support. We need to add it to our image
    to allow Qt Creator to work by adding the `openssh-sftp-server` package to the
    project's `conf/local.conf` file.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: However, there are other tools we will need, like the **gdbserver** if we want
    to debug our application, so it's easier to add the `eclipse-debug` feature, which
    will add all of the needed applications to the target image.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can now run the project.![How to do it...](img/5186OS_04_20.jpg)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If the application fails to be deployed with a login error, verify that you
    have set a root password in the target as explained in the recipe previously,
    or that you are using SSH key authentication.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should now see the example Qt hello world application running on your SATO
    desktop.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To debug the application, toggle a breakpoint on the source and click on the
    **Debug** button.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5186OS_04_21.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: Describing workflows for application development
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workflows for application development are similar to the ones we already
    saw for U-Boot and the Linux kernel back in [Chapter 2](ch02.html "Chapter 2. The
    BSP Layer"), *The BSP Layer*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how the following development workflows are applied to application
    development:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: External development
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working directory development
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External source development
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: External development
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is what we have been using on the recipes we saw before when building from
    the command line using a standalone toolchain, and also when using both the Eclipse
    and Qt Creator IDEs. This workflow produces binaries that have to be individually
    copied to the hardware to run and debug. It can be used in conjunction with the
    other workflows.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Working directory development
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the application is being built by the Yocto build system, we use this workflow
    to debug sporadic problems. However, it is not the recommended workflow for long
    developments. Note, though, that it is usually the first step when debugging third-party
    packages.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `helloworld_1.0.bb` custom recipe we saw back in the *Adding
    new packages* recipe in [Chapter 3](ch03.html "Chapter 3. The Software Layer"),
    *The Software Layer*, `meta-custom/recipes-example/helloworld/helloworld_1.0.bb`,
    as an example.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, the `helloworld.c` source file is the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The workflow steps are:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Start the package compilation from scratch.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will erase the package's build folder, shared state cache, and downloaded
    package source.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start a development shell:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will fetch, unpack, and patch the `helloworld` sources and spawn a new
    shell with the environment ready for compilation. The new shell will change to
    the package's `build` directory.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Depending on the `SRC_URI` variable, the package''s `build` directory can be
    revision controlled already. If not, as is the case in this example, we will create
    a local Git repository as follows:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Perform the modifications we need; for example, change `helloworld.c` to print
    `Howdy world` as follows:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Exit `devshell` and build the package without erasing our modifications.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tip
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the capital `C` (which invokes the compile task) and also all the tasks
    that follow it.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test your changes on the hardware by copying the generated package and installing
    it. Because you have only modified one package, the rest of the dependencies should
    be already installed in the running root filesystem. Run the following:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This assumes the target's root filesystem has been built with the `package-management`
    feature and the `helloworld` package is added to the `RM_WORK_EXCLUDE` variable
    when using the `rm_work` class.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to `devshell` and commit your change to the local Git repository as
    follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Generate a patch into the recipe''s patch directory:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, add the patch to the recipe''s `SRC_URI` variable, as shown here:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: External source development
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This workflow is recommended for development work once the application has been
    integrated into the Yocto build system. It can be used in conjunction with external
    development using an IDE, for example.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: In the example recipe we saw earlier, the source file was placed on the `meta-custom`
    layer along with the metadata.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'It is more common to have the recipe fetch directly from a revision control
    system like Git, so we will change the `meta-custom/recipes-example/helloworld/helloworld_1.0.bb`
    file to source from a Git directory as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can then clone it into a local directory as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'An alternative to using a remote revision controlled repository it to use a
    local one. To do so, follow these steps:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a local Git repository that will hold the source:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Copy our `helloworld.c` file over here, and add it to the repository:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, commit it with a signature and a message:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In any case, we have the version-controlled source in a local directory. We
    will then configure our `conf/local.conf` file to work from it as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And build it with:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We can then work directly in the local folder without the risk of accidentally
    having BitBake erase our code. Once development is complete, the modifications
    to `conf/local.conf` are removed and the recipe will fetch the source from its
    original `SRC_URI` location.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Working with GNU make
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU make is a make implementation for Linux systems. It is used by a wide variety
    of open source projects, including the Linux kernel. The build is managed by a
    `Makefile`, which tells make how to build the source code.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yocto recipes inherit `base.bbclass` and hence their default behavior is to
    look for a `Makefile`, `makefile`, or `GNU Makefile` and use GNU make to build
    the package.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: If your package already contains a `Makefile`, then all you need to worry about
    are the arguments that need to be passed to make. Make arguments can be passed
    using the `EXTRA_OEMAKE` variable, and a `do_install` override that calls the
    `oe_runmake` install needs to be provided, otherwise an empty install is run.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `logrotate` recipe is based on a `Makefile` and looks as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: See also
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about GNU make, visit [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the GNU build system
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Makefile` is a good solution when you are always going to build and run your
    software on the same system, and things like `glibc` and `gcc` versions and the
    available library versions are known. However, most software need to be built
    and run in a variety of systems.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GNU build system, or `autotools`, is a set of tools whose aim is to create
    a `Makefile` for your software in a variety of systems. It''s made up of three
    main tools:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '`autoconf`: This parses the contents of a `configure.ac` file that describes
    the source code to be built and creates a `configure` script. This script will
    then be used to generate the final `Makefile`.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`automake`: This parses the contents of a `Makefile.am` file and converts it
    into a `Makefile.in` file. This is then used by the `configure` script generated
    earlier to obtain a `config.status` script that gets automatically executed to
    obtain the final `Makefile`.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libtools`: This manages the creation of both static and dynamic libraries.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Yocto build system contains classes with the required knowledge to build
    `autotools` packages. All your recipe needs to do is to inherit the `autotools`
    class and configure the arguments to be passed to the `configure` script in the
    `EXTRA_OECONF` variable. Usually, the `autotools` system understands how to install
    the software, so you do not need a `do_install` override.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: There is a wide variety of open source projects that use `autotools` as the
    build system.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'An example, `meta-custom/recipes-example/hello/hello_2.9.bb`, that does not
    need any extra configure options, follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See also
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the GNU build system, visit [http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html](http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html)
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the CMake build system
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GNU make system is a great tool when you build exclusively for Linux systems.
    However, some packages are multiplatform and need a way to manage `Makefile` files
    on different operating systems. **CMake** is a cross-platform build system that
    can work not only with GNU make, but also Microsoft Visual Studio and Apple's
    Xcode.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CMake tool parses the `CMakeLists.txt` files in every directory to control
    the build process. An example `CMakeLists.txt` file to compile the hello world
    example follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How to do it...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Yocto build system also contains classes with the required knowledge to
    build CMake packages. All your recipe needs to do is to inherit the `cmake` class
    and configure the arguments to be passed to the `configure` script in the `EXTRA_OECMAKE`
    variable. Usually, the CMake system understands how to install the software, so
    you do not need a `do_install` override.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'A recipe to build the `helloworld.C` example application, `meta-custom/recipes-example/helloworld-cmake/helloworld-cmake_1.0.bb`,
    follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: See also
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about CMake, visit [http://www.cmake.org/documentation/](http://www.cmake.org/documentation/)
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the SCons builder
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SCons** is also a multiplatform build system written in Python, with its
    configuration files also written in the same language. It also includes support
    for Microsoft Visual Studio among other features.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SCons parses the `SConstruct` files, and by default it does not propagate the
    environment into the build system. This is to avoid build issues caused by environment
    differences. This is a complication for Yocto, as it configures the environment
    with the cross-compilation toolchain settings.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'SCons does not define a standard way to support cross-compilation, so every
    project will implement it differently. For a simple example as the hello world
    program, we can just initialize the `CC` and `PATH` variables from the external
    environment as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How to do it...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Yocto build system also contains classes with the required knowledge to
    build SCons packages. All your recipe needs to do is to inherit the `SCons` class
    and configure the arguments to be passed to the configure script in the `EXTRA_OESCONS`
    variable. Although some packages using `SCons` might deal with installation through
    an install alias as required by the `SCons` class, your recipe will mostly need
    to provide a `do_install` task override.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'An example recipe to build the `helloworld.c` example application, `meta-custom/recipes-example/helloworld-scons/helloworld-scons_1.0.bb`,
    follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: See also
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about SCons, visit [http://www.scons.org/doc/HTML/scons-user/](http://www.scons.org/doc/HTML/scons-user/)
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing with libraries
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications make use of shared libraries, which saves system memory and
    disk space, as they are shared between different applications. Modularizing code
    into libraries also allows for easier versioning and code management.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explain how to work with both static and shared libraries in
    Linux and Yocto.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By convention, library files start with the `lib` prefix.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'There are basically two library types:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '**Static libraries** (`.a`): When the object code is linked and becomes part
    of the application'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic libraries** (`.so`): Linked at compile time but not included in the
    application, so they need to be available at runtime. Multiple applications can
    share a dynamic library so they need less disk space.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Libraries are placed in the following standard root filesystem locations:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '`/lib`: Libraries required for startup'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/lib`: Most system libraries'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/local/lib`: Non-system libraries'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamic libraries follow certain naming conventions on running systems so that
    multiple versions can co-exist, so a library can be referenced by different names.
    Some of them are explained as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The linker name with the `.so` suffix; for example, `libexample.so`.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fully qualified name or `soname`, a symbolic link to the library name. For
    example, `libexample.so.x`, where `x` is the version number. Increasing the version
    number means the library is not compatible with previous versions.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real name. For example, `libexample.so.x.y[.z]`, where `x` is the major
    version number, `y` is the minor version number, and the optional `z` is a release
    number. Increasing minor or release numbers retains compatibility.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In GNU `glibc`, starting an ELF binary calls a program loader, `/lib/ld-linux-X`.
    Here, `X` is the version number, which finds all the needed shared libraries.
    This process uses a couple of interesting files:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/ld.so.conf`: This stores the directories searched by the loader'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/ld.so.preload`: This is used to override libraries'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ldconfig` tool reads the `ld.so.conf` file and creates a cache file (`/etc/ld.so.cache`)
    to increase access speed.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'The following environment variables can also be helpful:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '`LD_LIBRARY_PATH`: This is a colon-separated directory list to search libraries
    in. It is used when debugging or using non-standard library locations.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LD_PRELOAD`: This is used to override shared libraries.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a static library
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will build a static library, `libhelloworld`, from two source files, `hello.c`
    and `world.c`, and use it to build a hello world application. The source files
    for the library are presented here.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `hello.c` file:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is the code for `world.c` file:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To build the library, follow these steps:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the build environment:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Compile and link the library:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Verify the contents of the library:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The application source code is presented next.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `helloworld.c` file the following is the code:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To build it we run:'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can check which libraries it links with using `readelf`:'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Building a shared dynamic library
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build a dynamic library from the same sources, we would run:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can then use it to build our `helloworld C` application, as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'And again, we can check the dynamic libraries using `readelf`, as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How to do it...
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example recipe for the static library example we just saw follows, `meta-custom/recipes-example/libhelloworld-static/libhelloworldstatic_1.0.bb`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: By default, the configuration in `meta/conf/bitbake.conf` places all static
    libraries in a `-staticdev` package. It is also placed in the `sysroot` so that
    it can be used.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'For a dynamic library, we would use the following recipe, `meta-custom/recipes-example/libhelloworld-dyn/libhelloworlddyn_1.0.bb`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Usually we would list the library dependencies (if any) in the `RDEPENDS` variable,
    but this is not always needed as the build system performs some automatic dependency
    checking by inspecting both the library file and the `pkg-config` file and adding
    the dependencies it finds to `RDEPENDS` automatically.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Multiple versions of the same library can co-exist on the running system. For
    that, you need to provide different recipes with the same package name but different
    package revision. For example, we would have `libhelloworld-1.0.bb` and `libhelloworld-1.1.bb`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'And to build an application using the static library, we would create a recipe
    in `meta-custom/recipes-example/helloworld-static/helloworldstatic_1.0.bb`, as
    follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To build using the dynamic library, we would just need to change the recipe
    in `meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb` to
    `meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works...
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Libraries should provide the information required to use them, such as `include`
    headers and `library` dependencies. The Yocto Project provides two ways for libraries
    to provide build settings:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: The `binconfig` class. This is a legacy class used for libraries that provide
    a `-config` script to provide build settings.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pkgconfig` class. This is the recommended method for libraries to provide
    build settings.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `pkg-config` build settings file has the `.pc` suffix, is distributed with
    the library, and is installed in a common location known to the `pkg-config` tool.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helloworld.pc` file for the dynamic library looks as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'However, for the static library, we would change the last line to:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: A package wanting to use this `.pc` file would inherit the `pkgconfig` class.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a provision for packages that build both a library and an executable
    but do not want both of them installed together. By inheriting the `lib_package`
    class, the package will create a separate `-bin` package with the executables.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More details regarding `pkg-config` can be found at [http://www.freedesktop.org/wiki/Software/pkg-config/](http://www.freedesktop.org/wiki/Software/pkg-config/)
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Linux framebuffer
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel provides an abstraction for the graphical hardware in the form
    of framebuffer devices. These allow applications to access the graphics hardware
    through a well-defined API. The framebuffer is also used to provide a graphical
    console to the Linux kernel, so that it can, for example, display colors and a
    logo.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how applications can use the Linux framebuffer
    to display graphics and video.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications, especially in embedded devices, are able to access the framebuffer
    by mapping the memory and accessing it directly. For example, the `gstreamer`
    framework is able to work directly over the framebuffer, as is the Qt graphical
    framework.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Qt is a cross-platform application framework written in C++ and developed both
    by Digia, under the Qt company name, and the open source Qt project community.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: For Qt applications, Poky provides a `qt4e-demo-image` and the FSL community
    BSP provides a `qte-in-use-image`, both of which include support for Qt4 Extended
    over the framebuffer. The provided framework also includes support for hardware
    acceleration – not only video but also 2D and 3D graphical acceleration provided
    through the OpenGL and OpenVG APIs.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compile the Qt hello world application we saw in the *Developing Qt applications*
    recipe earlier, we could use the following `meta-custom/recipes-qt/qt-helloworld/qt-helloworld_1.0.bb`
    Yocto recipe:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Here the `meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.cpp`
    source file is as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And the `meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.pro`
    project file is as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then we add it to the image by using the following in your project''s `conf/local.conf`
    file:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And we build the image with:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can then program the SD card image, boot it, log in to the Wandboard, and
    launch the application by running:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `-qws` command-line option is needed to run the server application.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The framebuffer devices are located under `/dev`. The default framebuffer device
    is `/dev/fb0`, and if the graphics hardware provides more than one, they will
    be sequentially numbered.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Wandboard boots with two framebuffer devices, `fb0` and `fb1`.
    The first is the default video display, and the second one is an overlay plane
    that can be used to combine content on the display.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: However, the i.MX6 SoC supports up to four displays, so it could have up to
    four framebuffer devices in addition to two overlay framebuffers.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the default framebuffer used by applications with the `FRAMEBUFFER`
    environment variable. For example, if your hardware supports several framebuffers,
    you could use the second one by running:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The framebuffer devices are memory mapped and you can perform file operations
    on them. For example, you can clear the contents of the screen by running:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Or copy it with:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You may even restore the contents with:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: User space programs can also interrogate the framebuffers or modify their configuration
    programmatically using `ioctls`, or from the console by using the `fbset` application,
    which is included in Yocto's core images as a BusyBox applet.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You can configure the framebuffer HDMI device with a specific resolution, bits
    per pixel, and refresh rate by passing the `video` command-line option from the
    U-Boot bootloader to the Linux kernel. The specific format depends on the device
    framebuffer driver, and for the Wandboard it is as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Where:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '`n` is the framebuffer number'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xres` is the horizontal resolution'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yres` is the vertical resolution'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M` specifies that the timings are to be calculated using the VESA coordinated
    video timings instead of from a look-up table'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rate` is the refresh rate'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, for the `fb0` framebuffer, you could use:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Tip
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that after some time of inactivity, the virtual console will blank out.
    To unblank the display, use:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: There's more...
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FSL community BSP layer also provides a `fsl-image-multimedia` target image
    that includes the `gstreamer` framework, including plugins that make use of the
    hardware acceleration features within the i.MX6 SoC. A `fsl-image-multimedia-full`
    image is also provided, which extends the supported `gstreamer` plugins.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the `fsl-image-multimedia` image with framebuffer support, you need
    to remove the graphical distribution features by adding the following to your
    `conf/local.conf` file:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'And build the image with:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The resulting `fsl-image-multimedia-wandboard-quad.sdcard` image at `tmp/deploy/images`
    can be programmed into a microSD card and booted.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'The default Wandboard device tree defines an `mxcfb1` node as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: So, connecting a 1920x1080 HDMI monitor should show a virtual terminal with
    the Poky login prompt.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the `gstreamer` command-line tool, `gst-launch`, to construct
    `gstreamer` pipelines. For example, to view a hardware-accelerated video over
    the framebuffer, you can download the Big Bunny teaser full HD video file and
    play it over the framebuffer using the `gstreamer` framework''s `gst-launch` command-line
    tool as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The video will use Freescale's `h.264` video decoder plugin, `vpudec`, which
    makes use of the hardware video processing unit inside the i.MX6 SoC to decode
    the `h.264` video.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see a list of the available i.MX6-specific plugins by running:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: See also
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The framebuffer API is documented in the Linux kernel documentation at [https://www.kernel.org/doc/Documentation/fb/api.txt](https://www.kernel.org/doc/Documentation/fb/api.txt)
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information regarding Qt for Embedded Linux, refer to [http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html](http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html)
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation for the gstreamer 0.10 framework can be found at [http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/](http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/)
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the X Windows system
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The X Windows system provides the framework for a GUI environment – things like
    drawing and moving windows on the display and interacting with input devices like
    the mouse, the keyboard, and touchscreens. The protocol version has been X11 for
    over two decades, so it also known as X11.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reference implementation for the X Windows system is the **X.Org** server,
    which is released under permissive licenses such as MIT. It uses a client/server
    model, with the server communicating with several client programs, serving user
    input, and accepting graphical output. The X11 protocol is network transparent
    so that the clients and the server may run on different machines, with different
    architectures and operating systems. However, mostly, they both run on the same
    machine and communicate using local sockets.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: User interface specifications, such as buttons or menu styles, are not defined
    in X11, which leaves it to other window manager applications that are usually
    part of desktop environments, such as Gnome or KDE.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: X11 has input and video drivers to handle the hardware. For example, it has
    a framebuffer driver, `fbdev`, that can output to a non-accelerated Linux framebuffer,
    and `evdev`, a generic Linux input device driver with support for mice, keyboards,
    tablets, and touchscreens.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: The design of the X11 Windows systems makes it heavy for embedded devices, and
    although a powerful device like the quad-core i.MX6 has no trouble using it, many
    embedded devices choose other graphical alternatives. However, there are many
    graphical applications, mostly from the desktop environment, that run over the
    X11 Windows system.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: The FSL community BSP layer provides a hardware-accelerated X video driver for
    the i.MX6 SoC, `xf86-video-imxfb-vivante`, which is included in the X11-based
    `core-image-sato` target image and other graphical images.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'The X server is configured by an `/etc/X11/xorg.conf` file that configures
    the accelerated device as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The graphical acceleration is provided by the Vivante GPUs included in the i.MX6
    SoC.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Low-level X11 development is not recommended, and toolkits such as GTK+ and
    Qt are preferred. We will see how to integrate both types of graphical applications
    into our Yocto target image.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SATO is the default visual style for the Poky distribution based on **Gnome
    Mobile and Embedded** (**GMAE**). It is a desktop environment based on GTK+ that
    uses the matchbox-window-manager. It has the peculiarity of showing one single
    fullscreen window at a time.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the GTK hello world application, `meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld-1.0/gtk_hello_world.c`,
    that we introduced earlier, as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We can use the following `meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld_1.0.bb`
    recipe:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We can then add the package to the `core-image-sato` image by using:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And we can build it, program it, and run the application from the serial terminal
    with:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: There's more...
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accelerated graphical output is also supported on the Qt framework, either directly
    on the framebuffer (like in the `qt4e-demo-image` target we saw before) or using
    the X11 server available in `core-image-sato`.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the Qt hello world source we introduced in the previous recipe but
    over X11, we can use the `meta-custom/recipes-qt/qtx11-helloworld/qtx11-helloworld_1.0.bb`
    Yocto recipe shown as follows::'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We then need to add the Qt4 framework to the target image as well as the application.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We can then build `core-image-sato` using the following command:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Program and boot our target. Then run the application with:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: See also
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information on the X.Org server can be found at [http://www.x.org](http://www.x.org)
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qt application framework documentation can be found at [https://qt-project.org/](https://qt-project.org/)
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information and documentation about GTK+ can be found at [http://www.gtk.org/](http://www.gtk.org/)
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Wayland
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wayland is a display server protocol that is intended to replace the X Window
    system, and it is licensed under the MIT license.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will provide an overview of Wayland, including some key differences
    with the X Window system, and will show how to make use of it in Yocto.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Wayland protocol follows a client/server model in which clients are the
    graphical applications requesting the display of pixel buffers on the screen,
    and the server, or compositor, is the service provider that controls the display
    of these buffers.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: The Wayland compositor can be a Linux display server, an X application, or a
    special Wayland client. Weston is the reference Wayland compositor in the Wayland
    project. It is written in C and works with the Linux kernel APIs. It relies on
    `evdev` for the handling of input events.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: Wayland uses **Direct Rendering Manager (DRM)** in the Linux kernel and does
    not need something like an X server. The client renders the window contents to
    a buffer shared with the compositor by itself, using a rendering library, or an
    engine like Qt or GTK+.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: Wayland lacks the network transparency features of X, but it is likely that
    similar functionality will be added in the future.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: It also has better security features than X and is designed to provide confidentiality
    and integrity. Wayland does not allow applications to look at the input of other
    programs, capture other input events, or generate fake input events. It also makes
    a better job out of protecting the Window outputs. However, this also means that
    it currently offers no way to provide some of the features we are used to in desktop
    X systems like screen capturing, or features common in accessibility programs.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: Being lighter than X.Org and more secure, Wayland is better suited to use with
    embedded systems. If needed, X.Org can run as a client of Wayland for backwards
    compatibility.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: However, Wayland is not as established as X11, and the Wayland-based images
    in Poky do not receive as much community attention as the X11-based ones.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Poky offers a `core-image-weston` image that includes the Weston compositor.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Modifying our GTK hello world example from the *Using the X Windows system*
    recipe to use GTK3 and run it with Weston is straightforward.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'To build it, configure your `conf/local.conf` file by removing the `x11` distribution
    feature as follows:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Note
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to build from scratch by removing both the `tmp` and `sstate-cache`
    directories when changing the `DISTRO_FEATURES` variable.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the application to the image with:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'And build the image with:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Once the build finishes, you will find the microSD card image ready to be programmed
    under `tmp/deploy/images/wandboard-quad`.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then launch the application by running:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: There's more...
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FSL community BSP release supports hardware-accelerated graphics in Wayland
    using the Vivante GPU included in the i.MX6 SoC.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: This means that applications like `gstreamer` will be able to offer hardware-accelerated
    output when running with the Weston compositor.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: Wayland support can also be found in graphical toolkits like Clutter and GTK3+.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find more information about Wayland on the project's web page at [http://wayland.freedesktop.org/](http://wayland.freedesktop.org/)
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Python applications
  id: totrans-623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Yocto 1.7, Poky has support for building both Python 2 and Python 3 applications,
    and includes a small set of Python development tools in the `meta/recipes-devtools/python`
    directory.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: A wider variety of Python applications are available in the `meta-python` layer
    included as part of `meta-openembedded`, which you can add to your `conf/bblayers.conf`
    file if you want to.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard tool for packaging Python modules is `distutils`, which is included
    for both Python 2 and Python 3\. Poky includes the `distutils` class (`distutils3`
    in Python 3), which is used to build Python packages that use `distutils`. An
    example recipe in `meta-python` that uses the `distutils` class is `meta-python/recipes-devtools/python/python-pyusb_1.0.0a2.bb`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: However, `distutils` does not install package dependencies, allow package uninstallation,
    or allow us to install several versions of the same package, so it is only recommended
    for simple requirements. Hence, `setuptools` was developed to extend on `distutils`.
    It is not included in the standard Python libraries, but it is available in Poky.
    There is also a `setuptools` class in Poky (`setuptools3` for Python 3) that is
    used to build Python packages distributed with `setuptools`.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a Python hello world example application with `setuptools`, we would
    use a Yocto `meta-custom/recipes-python/python-helloworld/pythonhelloworld_1.0.bb`
    recipe as follows:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'To create an example hello world package, we create the directory structure
    shown in the following screenshot:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_04_22.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code for the same directory structure:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'And create the following `meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/setup.py`
    Python setup file:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'As well as the `meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/helloworld/main.py`
    python file:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'And a `meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/python-helloworld.py`
    test script that makes use of the module:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'We can then add it to our image with:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'And build it using:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Once programmed and booted, we can test the module by running the example script:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: There's more...
  id: totrans-649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `meta-python`, you can also find the `python-pip` recipe that will add the
    `pip` utility to your target image. It can be used to install packages from the
    **Python Package Index** (**PyPI**).
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add it to your image with:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'You will need to add the `meta-openembedded/meta-python` layer to your `conf/bblayers.conf`
    file in order to build your image, and also the `python-distribute` dependency,
    which is needed by `python-pip`. Then you can build for the `core-image-minimal`
    image with:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Once installed, you can use it from the target as follows:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Integrating the Oracle Java Runtime Environment
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Oracle provides two specialized Java editions for embedded development:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SE embedded**: This is a large subset of the desktop version of the
    standard Java SE. It contains optimizations with respect to the standard edition,
    like size and memory usage, to adapt it to the needs of mid-sized embedded devices.'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Micro Edition** (**ME**): This is targeted at headless low- and mid-range
    devices, and is a subset of Java SE complying with the **Connected Limited Device
    Configuration** (**CLDC**), and including some extra features and tools for the
    embedded market. Oracle offers a couple of reference implementations, but Java
    ME will have to be individually integrated from source into specific platforms.'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus on Java SE embedded, which can be downloaded in binary format
    from the Oracle download site.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: Java SE embedded is commercially licensed and requires royalty payments for
    embedded deployments.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-663
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yocto has a `meta-oracle-java` layer that is meant to help in the integration
    of the official Oracle **Java Runtime Environment** (**JRE**) Version 7\. However,
    installation without user intervention is not possible, as the Oracle's web page
    requires login and the acceptance of its license.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java SE embedded Version 7, Oracle offered both soft and hard floating point
    versions of headless and headful JREs for ARMv6/v7, and a headless version JRE
    for soft floating point user spaces for ARMv5\. Java SE embedded version 7 provides
    two different **Java Virtual Machines** (**JVMs**) for ARM Linux:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: A client JVM optimized for responsiveness
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server JVM identical to the client JVM but optimized for long-running applications
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing, the `meta-oracle-java` layer only has a recipe for the
    headless hard floating-point version with the client JVM. We will add recipes
    for the latest Java 7 SE embedded, which is update 75, for both headless and headful
    hard floating point JREs, which are appropriate to run on an i.MX6-based board
    like `wandboard-quad`.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the Java SE embedded runtime environment, first we need to clone
    the `meta-oracle-java` layer into our sources directory and add it to our `conf/bblayers.conf`
    file as follows:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Then we need to explicitly accept the Oracle Java license by adding the following
    to our `conf/local.conf` file:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We want to build the newest update available, so we add the following `meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headless_1.7.0.bb`
    recipe to our `meta-custom` layer:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Try to build the recipe with the following:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You will see that we get a checksum mismatch. This is caused by the license
    acceptance step in Oracle's website. To get around this, we will need to manually
    download the file into the `downloads` directory as specified in our project's
    `DL_DIR` configuration variable.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can add the JRE to our target image:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'And build it with:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'We can now log in to the target and run it with:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can also build the headful version using the following `meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headful_1.7.0.bb`
    recipe:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'And add it to the target image with:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'And build `core-image-sato` with:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In this case, the reported Java version is:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: There's more...
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The latest release at the time of this writing is Java SE embedded Version 8
    update 33 (8u33).
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: Oracle offers the download of the JDK only, and a host tool, **jrecreate**,
    needs to be used to configure and create an appropriate JRE from the JDK. The
    tool allows us to choose between different JVMs (minimal, client, and server)
    as well as soft or hard floating point ABIs, extensions like JavaFX, locales,
    and several other tweakings to the JVM.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Java SE embedded Version 8 provides support for headful X11 development
    using Swing, AWT, and JavaFX only for ARMv7 hard floating point user spaces, and
    includes support for JavaFX (the graphical framework aimed to replace Swing and
    AWT) on the Freescale i.MX6 processor.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: There is no Yocto recipe to integrate Java Version 8 at the time of this writing.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Open Java Development Kit
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The open source alternative to the Oracle Java SE embedded is the **Open Java
    Development Kit** (**OpenJDK**), an open source implementation of Java SE licensed
    under the GPLv2, with the classpath exception, which means that applications are
    allowed to link without being bound by the GPL license.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to build OpenJDK with Yocto and integrate the JRE
    into our target images.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main components of OpenJDK are:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: The HotSpot Java Virtual Machine
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Java Class Library** (**JCL**)
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java compiler, **javac**
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initially, OpenJDK needed to be built using a proprietary JDK. However, the
    **IcedTea** project allowed us to build OpenJDK using the GNU classpath, the GNU
    compiler for Java (GCJ), and bootstrap a JDK to build OpenJDK. It also complements
    OpenJDK with some missing components available on Java SE like a web browser plugin
    and web start implementations.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: Yocto can build meta-java using the `meta-java` layer, which includes recipes
    for cross-compiling OpenJDK using IcedTea.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: You can download OpenJDK from its Git repository at [http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/](http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: Development discussions can be followed and contributed to by visiting the development
    mailing list at [http://lists.openembedded.org/mailman/listinfo/openembedded-devel](http://lists.openembedded.org/mailman/listinfo/openembedded-devel).
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: The `meta-java` layer also includes recipes for a wide variety of Java libraries
    and VMs, and tools for application development like **ant** and **fastjar**.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build OpenJDK 7, you need to clone the `meta-java` layer as follows:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: At the time of this writing, there is no 1.7 Dizzy branch yet, so we will work
    directly from the master branch.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the layer to your `conf/bblayers.conf` file:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'And configure the project by adding the following to your `conf/local.conf`
    file:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'You can then add the OpenJDK package to your image with:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'And build the image of your choice:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'When you run the target image, you will get the following Java version:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: How it works...
  id: totrans-725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the JVM, we can byte-compile a Java class on our host and copy it to
    the target to execute it. For instance, we can use the following simple `HelloWorld.java`
    example:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'To byte-compile it in the host, we need to have a Java SDK installed. To install
    a Java SDK in Ubuntu, just run:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'To byte-compile the example, we execute:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'To run it, we copy the `HelloWorld.class` to the target, and from the same
    folder we run:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: There's more...
  id: totrans-734
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using OpenJDK on a production system, it is recommended to always use the
    latest available release, which contains bug and security fixes. At the time of
    this writing, the latest OpenJDK 7 release is update 71 (jdk7u71b14), buildable
    with IcedTea 2.5.3, so the `meta-java` recipes should be updated.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-736
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up-to-date information regarding openJDK can be obtained at [http://openjdk.java.net/](http://openjdk.java.net/)
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Java applications
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `meta-java` layer also offers helper classes to ease the integration of
    Java libraries and applications into Yocto. In this recipe, we will see an example
    of building a Java library using the provided classes.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `meta-java` layer provides two main classes to help with the integration
    of Java applications and libraries:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '**The Java bbclass**: This provides the default target directories and some
    auxiliary functions, namely:'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oe_jarinstall`: This installs and symlinks a JAR file'
  id: totrans-743
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oe_makeclasspath`: This generates a classpath string from JAR filenames'
  id: totrans-744
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oe_java_simple_wrapper`: This wraps your Java application in a shell script'
  id: totrans-745
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The java-library bbclass**: This inherits the Java bbclass and extends it
    to create and install JAR files.'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the following `meta-custom/recipes-java/java-helloworld/java-helloworld-1.0/HelloWorldSwing.java`
    graphical Swing hello world as an example:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'To integrate this `HelloWorldSwing` application, we can use a Yocto `meta-custom/recipes-java/java-helloworld/java-helloworld_1.0.bb`
    recipe as follows:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The recipe is also buildable for the host native architecture. We can do this
    either by providing a separate `java-helloworld-native` recipe that inherits the
    `native` class or by using the `BBCLASSEXTEND` variable as we did earlier. In
    both cases, we could then use the `_class-native` and `_class-target` overrides
    to differentiate between native and target functionality.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: Even though Java is byte-compiled and the compiled class will be the same for
    both, it still makes sense to add the native support explicitly.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-754
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java-library` class will create a library package with the name `lib<package>-java`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: 'To add it to a target image, we would use:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We can then decide whether we want to run the application with the Oracle JRE
    or OpenJDK. For OpenJDK, we will add the following packages to our image:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'And for the Oracle JRE, we will use the following:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The available JREs do not currently run over the framebuffer or Wayland, so
    we will use an X11-based graphical image like `core-image-sato`:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'We can then boot it, log in to the target, and execute the example with OpenJDK
    by running:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: There's more...
  id: totrans-766
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the time of this writing, OpenJDK as built from the `meta-java` layer master
    branch is not able to run X11 applications and will fail with this exception:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'However, the precompiled Oracle JRE runs the application without issues with:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Note
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you see build errors when building packages with the Oracle JRE, try using
    a different package format, for example, IPK, by adding the following to your
    `conf/local.conf` configuration file:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: This is due to dependency problems in the `meta-oracle-java` layer with the
    RPM package manager, as explained in the layer's README file.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
