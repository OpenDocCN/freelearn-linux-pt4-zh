- en: Chapter 4. Application Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing toolchains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing and using an SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Application Development Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Eclipse IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing GTK+ applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Qt Creator IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing Qt applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing workflows for application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with GNU make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the GNU build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the CMake build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the SCons builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing with libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Linux framebuffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the X Windows system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Wayland
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Python applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the Oracle Java Runtime Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the Open Java Development Kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Java applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dedicated applications are what define an embedded product, and Yocto offers
    helpful application development tools as well as the functionality to integrate
    with popular **Integrated Development Environments** (**IDE**) like Eclipse and
    Qt Creator. It also provides a wide range of utility classes to help in the integration
    of finished applications into the build system and the target images.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce the IDEs and show us how they are used to build
    and debug C and C++ applications on real hardware, and will explore application
    development, including graphical frameworks and Yocto integration, not only for
    C and C++ but also Python and Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A toolchain is a set of tools, binaries, and libraries used to build applications
    to run on a computer platform. In Yocto, the toolchains are based on GNU components.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A GNU toolchain contains the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembler (GNU as)**: This is part of the binutils package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linker (GNU ld)**: This is also part of the binutils package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compiler (GNU gcc)**: This has support for C, C++, Java, Ada, Fortran, and
    Objective C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugger (GNU gdb)**: This is the GNU debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binary file tools (objdump, nm, objcopy, readelf, strip, and so on)**: These
    are part of the binutils package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These components are enough to build bare metal applications, bootloaders like
    U-Boot, or operating systems like the Linux kernel, as they don't need a C library
    and they implement the C library functions they need. However, for Linux user
    space applications, a POSIX-compliant C library is needed.
  prefs: []
  type: TYPE_NORMAL
- en: The GNU C library, `glibc`, is the default C library used in the Yocto project.
    Yocto is introducing support for musl, a smaller C library, but as we have mentioned
    before, there is still work to be done until it is ready to be used with the hardware
    platforms supported by the FSL community layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'But on embedded systems, it is not just a toolchain we need, but a cross-compilation
    toolchain. This is because we build in a host computer but run the resulting binaries
    on the target, which is usually a different architecture. In reality, there are
    several types of toolchains, based on the architecture of the machine building
    the toolchain (build machine), running the toolchain (host machine), and running
    the binaries built by the toolchain (target machine). The most common combinations
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Native**: An example of this is an x86 machine running a toolchain that has
    also been built on an x86 machine producing binaries to run on an x86 machine.
    This is common in desktop computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-compilation**: This is the most common on embedded systems; for example,
    an x86 machine running a toolchain that has also been built on an x86 machine
    but producing binaries to run on a different architecture, like ARM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-native**: This is typically the toolchain running on targets. An example
    of this is where a toolchain has been built on an x86 machine but runs on ARM
    and produces binaries for ARM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canadian**: Rarely seen, this is where the build, host, and target machines
    are all different.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of building a cross-compilation toolchain is complex and fault prone,
    so automated tools for toolchain building have emerged, like **buildroot** and
    **crosstool-NG**. The Yocto build system also compiles its own toolchain on every
    build, and as we will see, you can use this toolchain for application development
    too.
  prefs: []
  type: TYPE_NORMAL
- en: But the cross-compilation toolchain and C library are not the only things we
    need in order to build applications; we also need a `sysroot`; that is, a root
    filesystem on the host with the libraries and header files that can be found on
    the target root filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of the cross-compilation toolchain, the `sysroot`, and sometimes
    other development tools such as an IDE is referred to as an SDK, or Software Development
    Kit.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to obtain an SDK with the Yocto project:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Application Development Toolkit** (**ADT**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using a hardware platform supported by Poky (that is, a virtualized
    QEMU machine or one of the reference boards), the recommendation is to use ADT,
    which will install all the required SDK components for you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Downloading a precompiled toolchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The easiest way to obtain a cross-compilation toolchain for a supported platform
    is to download a precompiled one; for example from the Yocto project downloads
    site, [http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/).
    The Yocto project provides prebuilt toolchains for both 32- and 64-bit i686 host
    machines, and prebuilt ARM toolchains both for **armv5** and **armv7** architectures.
    These contain `sysroot` that match the `core-image-sato` target image. However,
    the prebuilt `sysroot` is soft floating point, so it can''t be used with the target
    images built by the FSL community layer for i.MX6-based platforms, which are hard
    floating point. To install the prebuilt armv7 toolchain for an x86_64 host, run
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Building your own toolchain installer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On most embedded Linux projects, your machine will be supported by an external
    layer, and you will have a customized root filesystem that your `sysroot` will
    need to match. So building your own toolchain installer is recommended when you
    have a customized root filesystem. For example, the ideal toolchain to work with
    the Wandboard would be **Cortex-A9**-specific and targeted to produce hard floating
    point binaries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the Yocto project build system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if you already have a Yocto build system installation on your host,
    you can also use it for application development. Usually, application developers
    do not need the complexity of a Yocto build system installation, so a toolchain
    installer for the target system will be enough.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Preparing and using an SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Yocto build system can be used to generate a cross-compilation toolchain
    and matching `sysroot` for a target system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the previously used `wandboard-quad` build directory and source
    the `setup-environment` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to build an SDK with the Yocto build system:'
  prefs: []
  type: TYPE_NORMAL
- en: The `meta-toolchain` target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method will build a toolchain that matches your target platform, and a
    basic `sysroot` that will not match your target root filesystem. However, this
    toolchain can be used to build bare metal software like the U-Boot bootloader
    or the Linux kernel, which do not need a `sysroot`. The Yocto project offers downloadable
    `sysroot` for the supported hardware platforms. You can also build this toolchain
    yourself with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once built, it can be installed with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `populate_sdk` task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the recommended way to build a toolchain matching your target platform
    with a `sysroot` matching your target root filesystem. You build it with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should replace `core-image-sato` for the target root filesystem image you
    want the `sysroot` to match. The resulting toolchain can be installed with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, if you want your toolchain to be able to build static applications, you
    need to add static libraries to it. You can do this by adding specific static
    libraries to your target image, which could also be used for native compilation.
    For example, to add the static `glibc` libraries, add the following to your `conf/local.conf`
    file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And then build the toolchain to match your root filesystem as explained previously.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You usually won''t want the static libraries added to your image, but do you
    want to be able to cross-compile static applications, so you can also add all
    the static libraries to the toolchain by adding:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `meta-toolchain-qt` target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method will extend `meta-toolchain` to build Qt applications. We will
    see how to build Qt applications later on. To build this toolchain, execute the
    following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once built, it can be installed with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting toolchain installers will be located under `tmp/deploy/sdk` for
    all the cases mentioned here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `meta-ide-support` target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method does not generate a toolchain installer, but it prepares the current
    build project to use its own toolchain. It will generate an `environment-setup`
    script inside the tmp directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the bundled toolchain, you can now source that script as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the Application Development Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ADT is an SDK installation script that installs the following for Poky-supported
    hardware platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: A prebuilt cross-compilation toolchain, as explained previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `sysroot` that matches the `core-image-sato` target image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QEMU emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other development user space tools used for system profiling (these will be
    discussed in the following chapters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the ADT, you can choose either of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download a precompiled tarball from the Yocto project downloads site with the
    following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build one using your Yocto `build` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ADT installer is an automated script to install precompiled Yocto SDK components,
    so it will be the same whether you download the prebuilt version or you build
    one yourself.
  prefs: []
  type: TYPE_NORMAL
- en: You can then configure it before running it to customize the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it only makes sense to use the ADT for the Poky-supported platforms.
    For instance, it is not that useful for external hardware like `wandboard-quad`
    unless you provide your own components.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build the ADT from your Yocto `build` directory, open a new shell and execute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The ADT tarball will be located in the `tmp/deploy/sdk` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the tarball on a location of your choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the installation by editing the `adt_installer.conf` file. Some of
    the options are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`YOCTOADT_REPO`: This is a repository with the packages and root filesystem
    to be used. By default, it uses the one on the Yocto project web site, [http://adtrepo.yoctoproject.org/1.7.1/](http://adtrepo.yoctoproject.org/1.7.1/),
    but you could set one up yourself with your customized packages and root filesystem.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YOCTOADT_TARGETS`: This defines the machine targets the SDK is for. By default,
    this is ARM and x86.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YOCTOADT_QEMU`: This option controls whether to install the QEMU emulator.
    The default is to install it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YOCTOADT_NFS_UTIL`: This option controls whether to install user mode NFS.
    It is recommended if you are going to use the Eclipse IDE with QEMU-based machines.
    The default is to install it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And then for the specific target architectures (only shown for ARM):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`YOCTOADT_ROOTFS_arm`: This defines the specific root filesystem images to
    download from the ADT repository. By default it installs the `minimal` and `sato-sdk`
    images.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YOCTOADT_TARGET_SYSROOT_IMAGE_arm`: This is the root filesystem used to create
    the `sysroot`. This must also be included in the `YOCTOADT_ROOTFS_arm` selection
    that was explained earlier. By default this is the `sato-sdk` image.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YOCTOADT_TARGET_MACHINE_arm`: This is the machine that the images are downloaded
    for. By default this is `qemuarm`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YOCTOADT_TARGET_SYSROOT_LOC_arm`: This is the path on the host to install
    the target''s `sysroot`. By default this is `$HOME/test-yocto/`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the ADT installer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will ask for an installation location (by default `/opt/poky/1.7.1`) and
    whether you want to run it in interactive or silent mode.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the Eclipse IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eclipse is an open source IDE that is written mostly in Java and released under
    the **Eclipse Public License** (**EPL**). It can be extended using plugins, and
    the Yocto project releases a Yocto plugin that allows us to use Eclipse for application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yocto 1.7 provides Eclipse Yocto plugins for two different Eclipse versions,
    Juno and Kepler. They can be downloaded at [http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/).
    We will use Kepler 4.3, as it is the newest. We will start with the Eclipse Kepler
    standard edition and install all the required plugins we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended to run Eclipse under Oracle Java 1.7, although other Java
    providers are supported. You can install Oracle Java 1.7 from Oracle''s web site,
    [https://www.java.com/en/](https://www.java.com/en/), or using a Ubuntu Java Installer
    PPA, [https://launchpad.net/~webupd8team/+archive/ubuntu/java](https://launchpad.net/~webupd8team/+archive/ubuntu/java).
    The latter will integrate Java with your package management system, so it''s preferred.
    To install it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To download and install Eclipse Kepler standard edition for an x86_64 host,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetch the tarball from the Eclipse download site, [http://eclipse.org/downloads/packages/release/Kepler/SR2](http://eclipse.org/downloads/packages/release/Kepler/SR2).
    For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unpack it on a location of your choice as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the Eclipse IDE with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select **Install New Software** from the **Help** pull-down menu. Then select
    the **Kepler - http://download.eclipse.org/releases/kepler** source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the following Eclipse components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Linux tools:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LTTng - Linux Tracing Toolkit**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Mobile and device development:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C/C++ Remote Launch**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Remote System Explorer End-user Runtime**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Remote System Explorer User Actions**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Target Management Terminal**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**TCF Remote System Explorer add-in**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**TCF Target Explorer**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Programming languages:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C/C++ Autotools Support**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**C/C++ Development Tools**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install the Eclipse Yocto plugin by adding this repository source: [http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler](http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler),
    as shown in the following screenshot:![Getting ready](img/5186OS_04_01.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Yocto Project ADT plug-in** and ignore the unsigned content warning.
    We won't be covering other plugin extensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To configure Eclipse to use a Yocto toolchain, go to **Window** | **Preferences**
    | **Yocto Project ADT**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ADT configuration offers two cross-compiler options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standalone pre-built toolchain**: Choose this when you have installed a toolchain
    either from a toolchain installer or the ADT installer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build system derived toolchain**: Choose this when using a Yocto `build`
    directory prepared with `meta-ide-support` as explained previously.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It also offers two target options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The QEMU emulator**: Choose this if you are using Poky with a virtualized
    machine and you have used the ADT installer to install a `qemuarm` Linux kernel
    and root filesystem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**External hardware**: Choose this if you are using real hardware like the
    `wandboard-quad` hardware. This option is the most useful for embedded development.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example configuration when using the ADT installer with its default configuration
    would be to choose the standalone prebuilt toolchain option along with the QEMU
    emulator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-compiler options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Standalone pre-built toolchain:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toolchain root location**: `/opt/poky/1.7.1`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Sysroot location**: `${HOME}/test-yocto/qemuarm`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Target architecture**: `armv5te-poky-linux-gnueabi`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Target options:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QEMU kernel**: `/tmp/adt-installer/download_image/zImage-qemuarm.bin`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_04_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'And for a build system derived toolchain using the `wandboard-quad` reference
    board, this is what you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-compiler options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build system derived toolchain:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toolchain root location**: `/opt/yocto/fsl-community-bsp/wandboard-quad`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Sysroot location**: `/opt/yocto/fsl-community-bsp/wandboard-quad/tmp/sysroots/wandboard-quad`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to perform debugging on a remote target, it needs to be running the
    `tcf-agent` daemon. It is included by default on the SDK images, but you can also
    include it in any other image by adding the following to your `conf/local.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information, refer to the *Yocto Project Application Developer's Guide*
    at [http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html](http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing GTK+ applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how to build, run, and debug a graphical GTK+ application
    using the Eclipse IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the `eclipse-debug` feature to your project''s `conf/local.conf` file as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build a `core-image-sato` target image as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build a `core-image-sato` toolchain as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the toolchain as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before launching the Eclipse IDE, we can check whether we are able to build
    and launch a GTK application manually. We will build the following GTK+ hello
    world application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code for `gtk_hello_world.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To build it, we use the `core-image-sato` toolchain installed as described
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command uses the `pkg-config` helper tool to read the `.pc` files that
    are installed with the GTK libraries in the `sysroot` to determine which compiler
    switches (`--cflags` for `include` directories and `--libs` for the libraries
    to link with) are needed to compile programs that use GTK.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can manually copy the resulting binary to our Wandboard while booting `core-image-sato`
    over NFS and run it from the target''s console with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will open a GTK+ window over the SATO desktop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now configure the Eclipse ADT plugin using the standalone toolchain as
    described before, or we could decide to use the build system derived toolchain
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Follow the next steps to build and run an example hello world application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new hello world GTK autotools project. Accept all the defaults in the
    project creation wizard. Browse to **File** | **New** | **Project** | **C/C++**
    | **C Project** | **Yocto Project ADT Autotools Project** | **Hello World GTK
    C Autotools Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When choosing a name for your project, avoid using special characters like dashes,
    as they could cause problems with the build tools.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build the project by going to **Project** | **Build Project**.![How to do it...](img/5186OS_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even though the project builds successfully, you may see errors both marked
    in the source and in the **Problems** tab. This is because the Eclipse's code
    analysis feature cannot resolve all the project's symbols. To resolve it, add
    the needed `include` header files to your project's properties by going to **Project**
    | **Properties** | **C/C++ General** | **Paths and Symbols** | **Includes**.![How
    to do it...](img/5186OS_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Run** | **Run Configurations**, you should have **C/C++ Remote Application**
    with a TCF target called `<project_name>_gdb_arm-poky-linux-gnueabi`. If you don't,
    create one.![How to do it...](img/5186OS_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new TCF connection to the target's IP address using the **New...**
    button in the **Main** tab.![How to do it...](img/5186OS_04_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the **Remote Absolute File Path for C/C++ Application** field with the
    path to the binary and include the binary name; for example, `/gtk_hello_world`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Commands to execute before application** field, enter `export DISPLAY=:0`.![How
    to do it...](img/5186OS_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application and log in as `root` with an empty password. You should
    see the GTK application on your SATO desktop, and the following output in the
    Console tab:![How to do it...](img/5186OS_04_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have problems connecting to the target, verify that it is running `tcf-agent`
    by typing in the following on the target''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you have login problems, you can use Eclipse's **Remote System Explorer**
    (**RSE)** perspective to clear passwords and debug the connection to the target.
    Once the connection can be established and you are able to browse the target's
    filesystem through RSE, you can come back to the run configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To debug the application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Run** | **Debug Configuration**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Debugger** tab, verify the GDB debugger path is the correct toolchain
    debugger location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If it isn't, point it to the correct location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![There''s more...](img/5186OS_04_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Double-click on the `main` function in the source file to add a breakpoint.
    A blue dot will appear on the side bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Debug** button. The debug perspective appears with the application
    executing on the remote Wandboard hardware.![There's more...](img/5186OS_04_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get **Text file busy** error, remember to close the application we ran
    on the previous point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the Qt Creator IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Creator is a multiplatform IDE part of the Qt Application Development Framework
    SDK. It is the IDE of choice for Qt application development and is available with
    multiple licenses, including GPLv3, LGPLv2, and commercial licenses as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Download and install the Qt Creator 3.3.0 for your host from the Qt project
    downloads website. For downloading and installing an x86_64 Linux host, you can
    use the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build a toolchain that is ready to develop Qt applications with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before launching Qt Creator, we need to set up the development environment.
    To make this happen automatically when we launch Qt Creator, we can patch its
    initialization script by adding the following line right at the beginning of the
    `bin/qtcreator.sh` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the environment initialization script is placed before the hash bang.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run Qt Creator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And configure it by going to **Tools** | **Options** and using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First we configure a new device for our Wandboard. Under **Devices** | **Add**,
    we select **Generic Linux Device**.![How to do it...](img/5186OS_04_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the root password in the target by using the `passwd` command from the target's
    root console and type it in the password field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under **Build & Run**, we configure a new compiler pointing to the Yocto `meta-toolchain-qt`
    compiler path we just installed. Here''s the path as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/5186OS_04_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Similarly for a cross-debugger, the following is the path which is also mentioned
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/5186OS_04_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'And then we configure Qt by selecting the `qmake` builder from the toolchain.
    Here''s the path which is also mentioned in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/5186OS_04_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally we configure a new kit as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Generic Linux Device** and configure its `sysroot` to:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Select the compiler, debugger, and Qt version we just defined.![How to do it...](img/5186OS_04_16.jpg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In Ubuntu, Qt Creator stores its configuration on the user's home directory
    under `.config/QtProject/`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Developing Qt applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how to build, run, and debug a graphical Qt application
    using Qt Creator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before launching Qt Creator, we check whether we are able to build and launch
    a Qt application manually. We will build a Qt hello world application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `qt_hello_world.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To build it, we use the `meta-toolchain-qt` installed as described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This uses `qmake` to create a project file and a `Makefile` file with all the
    relevant code files in the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run it, we first need to build a filesystem with Qt support. We first prepare
    the environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And configure our project with the `qt4-pkgs` extra feature by adding the following
    to `conf/local.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And for Qt applications, we also need the **International Component for Unicode**
    (**ICU**) library, as the Qt libraries are compiled with support for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And build it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once finished, we can program the microSD card image and boot the Wandboard.
    Copy the `qt_hello_world` binary to the target and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You should see the Qt hello world window on the X11 desktop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build and run an example hello world application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty project by going to **File** | **New File or Project** |
    **Other project** | **Empty qmake project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select only the **wandboard-quad** kit we just created.![How to do it...](img/5186OS_04_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new C++ file, `qt_hello_world.cpp`, by going to **File** | **New File
    or Project** | **C++** | **C++ Source File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the contents of the `qt_hello_world.cpp` file into Qt Creator, as shown
    in the following screenshot:![How to do it...](img/5186OS_04_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure your project with the target installation details by adding the following
    to your `hw.pro` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `qt_hello_world` with the name of your project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build the project. If you have build errors, verify that the Yocto build environment
    has been correctly set up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can try to manually run the toolchain `environment-setup` script before
    launching Qt Creator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go to **Projects** | **Run** and check your project settings.![How to do it...](img/5186OS_04_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As can be seen in this screenshot, Qt Creator will use the SFTP protocol to
    transfer the files to the target. By default, the dropbear SSH server running
    on `core-image-sato` does not have SFTP support. We need to add it to our image
    to allow Qt Creator to work by adding the `openssh-sftp-server` package to the
    project's `conf/local.conf` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, there are other tools we will need, like the **gdbserver** if we want
    to debug our application, so it's easier to add the `eclipse-debug` feature, which
    will add all of the needed applications to the target image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now run the project.![How to do it...](img/5186OS_04_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If the application fails to be deployed with a login error, verify that you
    have set a root password in the target as explained in the recipe previously,
    or that you are using SSH key authentication.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should now see the example Qt hello world application running on your SATO
    desktop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To debug the application, toggle a breakpoint on the source and click on the
    **Debug** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5186OS_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Describing workflows for application development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workflows for application development are similar to the ones we already
    saw for U-Boot and the Linux kernel back in [Chapter 2](ch02.html "Chapter 2. The
    BSP Layer"), *The BSP Layer*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how the following development workflows are applied to application
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: External development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working directory development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External source development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: External development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is what we have been using on the recipes we saw before when building from
    the command line using a standalone toolchain, and also when using both the Eclipse
    and Qt Creator IDEs. This workflow produces binaries that have to be individually
    copied to the hardware to run and debug. It can be used in conjunction with the
    other workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Working directory development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the application is being built by the Yocto build system, we use this workflow
    to debug sporadic problems. However, it is not the recommended workflow for long
    developments. Note, though, that it is usually the first step when debugging third-party
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `helloworld_1.0.bb` custom recipe we saw back in the *Adding
    new packages* recipe in [Chapter 3](ch03.html "Chapter 3. The Software Layer"),
    *The Software Layer*, `meta-custom/recipes-example/helloworld/helloworld_1.0.bb`,
    as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `helloworld.c` source file is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The workflow steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the package compilation from scratch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will erase the package's build folder, shared state cache, and downloaded
    package source.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start a development shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will fetch, unpack, and patch the `helloworld` sources and spawn a new
    shell with the environment ready for compilation. The new shell will change to
    the package's `build` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Depending on the `SRC_URI` variable, the package''s `build` directory can be
    revision controlled already. If not, as is the case in this example, we will create
    a local Git repository as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform the modifications we need; for example, change `helloworld.c` to print
    `Howdy world` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exit `devshell` and build the package without erasing our modifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the capital `C` (which invokes the compile task) and also all the tasks
    that follow it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test your changes on the hardware by copying the generated package and installing
    it. Because you have only modified one package, the rest of the dependencies should
    be already installed in the running root filesystem. Run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This assumes the target's root filesystem has been built with the `package-management`
    feature and the `helloworld` package is added to the `RM_WORK_EXCLUDE` variable
    when using the `rm_work` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to `devshell` and commit your change to the local Git repository as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a patch into the recipe''s patch directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the patch to the recipe''s `SRC_URI` variable, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: External source development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This workflow is recommended for development work once the application has been
    integrated into the Yocto build system. It can be used in conjunction with external
    development using an IDE, for example.
  prefs: []
  type: TYPE_NORMAL
- en: In the example recipe we saw earlier, the source file was placed on the `meta-custom`
    layer along with the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is more common to have the recipe fetch directly from a revision control
    system like Git, so we will change the `meta-custom/recipes-example/helloworld/helloworld_1.0.bb`
    file to source from a Git directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then clone it into a local directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative to using a remote revision controlled repository it to use a
    local one. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a local Git repository that will hold the source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy our `helloworld.c` file over here, and add it to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, commit it with a signature and a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In any case, we have the version-controlled source in a local directory. We
    will then configure our `conf/local.conf` file to work from it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And build it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We can then work directly in the local folder without the risk of accidentally
    having BitBake erase our code. Once development is complete, the modifications
    to `conf/local.conf` are removed and the recipe will fetch the source from its
    original `SRC_URI` location.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GNU make
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU make is a make implementation for Linux systems. It is used by a wide variety
    of open source projects, including the Linux kernel. The build is managed by a
    `Makefile`, which tells make how to build the source code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yocto recipes inherit `base.bbclass` and hence their default behavior is to
    look for a `Makefile`, `makefile`, or `GNU Makefile` and use GNU make to build
    the package.
  prefs: []
  type: TYPE_NORMAL
- en: If your package already contains a `Makefile`, then all you need to worry about
    are the arguments that need to be passed to make. Make arguments can be passed
    using the `EXTRA_OEMAKE` variable, and a `do_install` override that calls the
    `oe_runmake` install needs to be provided, otherwise an empty install is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `logrotate` recipe is based on a `Makefile` and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about GNU make, visit [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the GNU build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Makefile` is a good solution when you are always going to build and run your
    software on the same system, and things like `glibc` and `gcc` versions and the
    available library versions are known. However, most software need to be built
    and run in a variety of systems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GNU build system, or `autotools`, is a set of tools whose aim is to create
    a `Makefile` for your software in a variety of systems. It''s made up of three
    main tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`autoconf`: This parses the contents of a `configure.ac` file that describes
    the source code to be built and creates a `configure` script. This script will
    then be used to generate the final `Makefile`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`automake`: This parses the contents of a `Makefile.am` file and converts it
    into a `Makefile.in` file. This is then used by the `configure` script generated
    earlier to obtain a `config.status` script that gets automatically executed to
    obtain the final `Makefile`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libtools`: This manages the creation of both static and dynamic libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Yocto build system contains classes with the required knowledge to build
    `autotools` packages. All your recipe needs to do is to inherit the `autotools`
    class and configure the arguments to be passed to the `configure` script in the
    `EXTRA_OECONF` variable. Usually, the `autotools` system understands how to install
    the software, so you do not need a `do_install` override.
  prefs: []
  type: TYPE_NORMAL
- en: There is a wide variety of open source projects that use `autotools` as the
    build system.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example, `meta-custom/recipes-example/hello/hello_2.9.bb`, that does not
    need any extra configure options, follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the GNU build system, visit [http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html](http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the CMake build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GNU make system is a great tool when you build exclusively for Linux systems.
    However, some packages are multiplatform and need a way to manage `Makefile` files
    on different operating systems. **CMake** is a cross-platform build system that
    can work not only with GNU make, but also Microsoft Visual Studio and Apple's
    Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CMake tool parses the `CMakeLists.txt` files in every directory to control
    the build process. An example `CMakeLists.txt` file to compile the hello world
    example follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Yocto build system also contains classes with the required knowledge to
    build CMake packages. All your recipe needs to do is to inherit the `cmake` class
    and configure the arguments to be passed to the `configure` script in the `EXTRA_OECMAKE`
    variable. Usually, the CMake system understands how to install the software, so
    you do not need a `do_install` override.
  prefs: []
  type: TYPE_NORMAL
- en: 'A recipe to build the `helloworld.C` example application, `meta-custom/recipes-example/helloworld-cmake/helloworld-cmake_1.0.bb`,
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about CMake, visit [http://www.cmake.org/documentation/](http://www.cmake.org/documentation/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the SCons builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SCons** is also a multiplatform build system written in Python, with its
    configuration files also written in the same language. It also includes support
    for Microsoft Visual Studio among other features.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SCons parses the `SConstruct` files, and by default it does not propagate the
    environment into the build system. This is to avoid build issues caused by environment
    differences. This is a complication for Yocto, as it configures the environment
    with the cross-compilation toolchain settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'SCons does not define a standard way to support cross-compilation, so every
    project will implement it differently. For a simple example as the hello world
    program, we can just initialize the `CC` and `PATH` variables from the external
    environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Yocto build system also contains classes with the required knowledge to
    build SCons packages. All your recipe needs to do is to inherit the `SCons` class
    and configure the arguments to be passed to the configure script in the `EXTRA_OESCONS`
    variable. Although some packages using `SCons` might deal with installation through
    an install alias as required by the `SCons` class, your recipe will mostly need
    to provide a `do_install` task override.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example recipe to build the `helloworld.c` example application, `meta-custom/recipes-example/helloworld-scons/helloworld-scons_1.0.bb`,
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about SCons, visit [http://www.scons.org/doc/HTML/scons-user/](http://www.scons.org/doc/HTML/scons-user/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing with libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications make use of shared libraries, which saves system memory and
    disk space, as they are shared between different applications. Modularizing code
    into libraries also allows for easier versioning and code management.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explain how to work with both static and shared libraries in
    Linux and Yocto.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By convention, library files start with the `lib` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are basically two library types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static libraries** (`.a`): When the object code is linked and becomes part
    of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic libraries** (`.so`): Linked at compile time but not included in the
    application, so they need to be available at runtime. Multiple applications can
    share a dynamic library so they need less disk space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Libraries are placed in the following standard root filesystem locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/lib`: Libraries required for startup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/lib`: Most system libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/local/lib`: Non-system libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamic libraries follow certain naming conventions on running systems so that
    multiple versions can co-exist, so a library can be referenced by different names.
    Some of them are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The linker name with the `.so` suffix; for example, `libexample.so`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fully qualified name or `soname`, a symbolic link to the library name. For
    example, `libexample.so.x`, where `x` is the version number. Increasing the version
    number means the library is not compatible with previous versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real name. For example, `libexample.so.x.y[.z]`, where `x` is the major
    version number, `y` is the minor version number, and the optional `z` is a release
    number. Increasing minor or release numbers retains compatibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In GNU `glibc`, starting an ELF binary calls a program loader, `/lib/ld-linux-X`.
    Here, `X` is the version number, which finds all the needed shared libraries.
    This process uses a couple of interesting files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/ld.so.conf`: This stores the directories searched by the loader'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/ld.so.preload`: This is used to override libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ldconfig` tool reads the `ld.so.conf` file and creates a cache file (`/etc/ld.so.cache`)
    to increase access speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following environment variables can also be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LD_LIBRARY_PATH`: This is a colon-separated directory list to search libraries
    in. It is used when debugging or using non-standard library locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LD_PRELOAD`: This is used to override shared libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a static library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will build a static library, `libhelloworld`, from two source files, `hello.c`
    and `world.c`, and use it to build a hello world application. The source files
    for the library are presented here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `hello.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for `world.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the library, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the build environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and link the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the contents of the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application source code is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `helloworld.c` file the following is the code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To build it we run:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check which libraries it links with using `readelf`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Building a shared dynamic library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build a dynamic library from the same sources, we would run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use it to build our `helloworld C` application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, we can check the dynamic libraries using `readelf`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example recipe for the static library example we just saw follows, `meta-custom/recipes-example/libhelloworld-static/libhelloworldstatic_1.0.bb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: By default, the configuration in `meta/conf/bitbake.conf` places all static
    libraries in a `-staticdev` package. It is also placed in the `sysroot` so that
    it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a dynamic library, we would use the following recipe, `meta-custom/recipes-example/libhelloworld-dyn/libhelloworlddyn_1.0.bb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Usually we would list the library dependencies (if any) in the `RDEPENDS` variable,
    but this is not always needed as the build system performs some automatic dependency
    checking by inspecting both the library file and the `pkg-config` file and adding
    the dependencies it finds to `RDEPENDS` automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple versions of the same library can co-exist on the running system. For
    that, you need to provide different recipes with the same package name but different
    package revision. For example, we would have `libhelloworld-1.0.bb` and `libhelloworld-1.1.bb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And to build an application using the static library, we would create a recipe
    in `meta-custom/recipes-example/helloworld-static/helloworldstatic_1.0.bb`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To build using the dynamic library, we would just need to change the recipe
    in `meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb` to
    `meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Libraries should provide the information required to use them, such as `include`
    headers and `library` dependencies. The Yocto Project provides two ways for libraries
    to provide build settings:'
  prefs: []
  type: TYPE_NORMAL
- en: The `binconfig` class. This is a legacy class used for libraries that provide
    a `-config` script to provide build settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pkgconfig` class. This is the recommended method for libraries to provide
    build settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `pkg-config` build settings file has the `.pc` suffix, is distributed with
    the library, and is installed in a common location known to the `pkg-config` tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helloworld.pc` file for the dynamic library looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for the static library, we would change the last line to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: A package wanting to use this `.pc` file would inherit the `pkgconfig` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a provision for packages that build both a library and an executable
    but do not want both of them installed together. By inheriting the `lib_package`
    class, the package will create a separate `-bin` package with the executables.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More details regarding `pkg-config` can be found at [http://www.freedesktop.org/wiki/Software/pkg-config/](http://www.freedesktop.org/wiki/Software/pkg-config/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Linux framebuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel provides an abstraction for the graphical hardware in the form
    of framebuffer devices. These allow applications to access the graphics hardware
    through a well-defined API. The framebuffer is also used to provide a graphical
    console to the Linux kernel, so that it can, for example, display colors and a
    logo.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how applications can use the Linux framebuffer
    to display graphics and video.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications, especially in embedded devices, are able to access the framebuffer
    by mapping the memory and accessing it directly. For example, the `gstreamer`
    framework is able to work directly over the framebuffer, as is the Qt graphical
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Qt is a cross-platform application framework written in C++ and developed both
    by Digia, under the Qt company name, and the open source Qt project community.
  prefs: []
  type: TYPE_NORMAL
- en: For Qt applications, Poky provides a `qt4e-demo-image` and the FSL community
    BSP provides a `qte-in-use-image`, both of which include support for Qt4 Extended
    over the framebuffer. The provided framework also includes support for hardware
    acceleration – not only video but also 2D and 3D graphical acceleration provided
    through the OpenGL and OpenVG APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compile the Qt hello world application we saw in the *Developing Qt applications*
    recipe earlier, we could use the following `meta-custom/recipes-qt/qt-helloworld/qt-helloworld_1.0.bb`
    Yocto recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the `meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.cpp`
    source file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.pro`
    project file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add it to the image by using the following in your project''s `conf/local.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'And we build the image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then program the SD card image, boot it, log in to the Wandboard, and
    launch the application by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The `-qws` command-line option is needed to run the server application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The framebuffer devices are located under `/dev`. The default framebuffer device
    is `/dev/fb0`, and if the graphics hardware provides more than one, they will
    be sequentially numbered.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Wandboard boots with two framebuffer devices, `fb0` and `fb1`.
    The first is the default video display, and the second one is an overlay plane
    that can be used to combine content on the display.
  prefs: []
  type: TYPE_NORMAL
- en: However, the i.MX6 SoC supports up to four displays, so it could have up to
    four framebuffer devices in addition to two overlay framebuffers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the default framebuffer used by applications with the `FRAMEBUFFER`
    environment variable. For example, if your hardware supports several framebuffers,
    you could use the second one by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The framebuffer devices are memory mapped and you can perform file operations
    on them. For example, you can clear the contents of the screen by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Or copy it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You may even restore the contents with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: User space programs can also interrogate the framebuffers or modify their configuration
    programmatically using `ioctls`, or from the console by using the `fbset` application,
    which is included in Yocto's core images as a BusyBox applet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'You can configure the framebuffer HDMI device with a specific resolution, bits
    per pixel, and refresh rate by passing the `video` command-line option from the
    U-Boot bootloader to the Linux kernel. The specific format depends on the device
    framebuffer driver, and for the Wandboard it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`n` is the framebuffer number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xres` is the horizontal resolution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yres` is the vertical resolution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M` specifies that the timings are to be calculated using the VESA coordinated
    video timings instead of from a look-up table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rate` is the refresh rate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, for the `fb0` framebuffer, you could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that after some time of inactivity, the virtual console will blank out.
    To unblank the display, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FSL community BSP layer also provides a `fsl-image-multimedia` target image
    that includes the `gstreamer` framework, including plugins that make use of the
    hardware acceleration features within the i.MX6 SoC. A `fsl-image-multimedia-full`
    image is also provided, which extends the supported `gstreamer` plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the `fsl-image-multimedia` image with framebuffer support, you need
    to remove the graphical distribution features by adding the following to your
    `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'And build the image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The resulting `fsl-image-multimedia-wandboard-quad.sdcard` image at `tmp/deploy/images`
    can be programmed into a microSD card and booted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default Wandboard device tree defines an `mxcfb1` node as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: So, connecting a 1920x1080 HDMI monitor should show a virtual terminal with
    the Poky login prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the `gstreamer` command-line tool, `gst-launch`, to construct
    `gstreamer` pipelines. For example, to view a hardware-accelerated video over
    the framebuffer, you can download the Big Bunny teaser full HD video file and
    play it over the framebuffer using the `gstreamer` framework''s `gst-launch` command-line
    tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The video will use Freescale's `h.264` video decoder plugin, `vpudec`, which
    makes use of the hardware video processing unit inside the i.MX6 SoC to decode
    the `h.264` video.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see a list of the available i.MX6-specific plugins by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The framebuffer API is documented in the Linux kernel documentation at [https://www.kernel.org/doc/Documentation/fb/api.txt](https://www.kernel.org/doc/Documentation/fb/api.txt)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information regarding Qt for Embedded Linux, refer to [http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html](http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation for the gstreamer 0.10 framework can be found at [http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/](http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the X Windows system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The X Windows system provides the framework for a GUI environment – things like
    drawing and moving windows on the display and interacting with input devices like
    the mouse, the keyboard, and touchscreens. The protocol version has been X11 for
    over two decades, so it also known as X11.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reference implementation for the X Windows system is the **X.Org** server,
    which is released under permissive licenses such as MIT. It uses a client/server
    model, with the server communicating with several client programs, serving user
    input, and accepting graphical output. The X11 protocol is network transparent
    so that the clients and the server may run on different machines, with different
    architectures and operating systems. However, mostly, they both run on the same
    machine and communicate using local sockets.
  prefs: []
  type: TYPE_NORMAL
- en: User interface specifications, such as buttons or menu styles, are not defined
    in X11, which leaves it to other window manager applications that are usually
    part of desktop environments, such as Gnome or KDE.
  prefs: []
  type: TYPE_NORMAL
- en: X11 has input and video drivers to handle the hardware. For example, it has
    a framebuffer driver, `fbdev`, that can output to a non-accelerated Linux framebuffer,
    and `evdev`, a generic Linux input device driver with support for mice, keyboards,
    tablets, and touchscreens.
  prefs: []
  type: TYPE_NORMAL
- en: The design of the X11 Windows systems makes it heavy for embedded devices, and
    although a powerful device like the quad-core i.MX6 has no trouble using it, many
    embedded devices choose other graphical alternatives. However, there are many
    graphical applications, mostly from the desktop environment, that run over the
    X11 Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: The FSL community BSP layer provides a hardware-accelerated X video driver for
    the i.MX6 SoC, `xf86-video-imxfb-vivante`, which is included in the X11-based
    `core-image-sato` target image and other graphical images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The X server is configured by an `/etc/X11/xorg.conf` file that configures
    the accelerated device as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The graphical acceleration is provided by the Vivante GPUs included in the i.MX6
    SoC.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level X11 development is not recommended, and toolkits such as GTK+ and
    Qt are preferred. We will see how to integrate both types of graphical applications
    into our Yocto target image.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SATO is the default visual style for the Poky distribution based on **Gnome
    Mobile and Embedded** (**GMAE**). It is a desktop environment based on GTK+ that
    uses the matchbox-window-manager. It has the peculiarity of showing one single
    fullscreen window at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the GTK hello world application, `meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld-1.0/gtk_hello_world.c`,
    that we introduced earlier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following `meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld_1.0.bb`
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add the package to the `core-image-sato` image by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can build it, program it, and run the application from the serial terminal
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accelerated graphical output is also supported on the Qt framework, either directly
    on the framebuffer (like in the `qt4e-demo-image` target we saw before) or using
    the X11 server available in `core-image-sato`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the Qt hello world source we introduced in the previous recipe but
    over X11, we can use the `meta-custom/recipes-qt/qtx11-helloworld/qtx11-helloworld_1.0.bb`
    Yocto recipe shown as follows::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We then need to add the Qt4 framework to the target image as well as the application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then build `core-image-sato` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Program and boot our target. Then run the application with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information on the X.Org server can be found at [http://www.x.org](http://www.x.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qt application framework documentation can be found at [https://qt-project.org/](https://qt-project.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information and documentation about GTK+ can be found at [http://www.gtk.org/](http://www.gtk.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Wayland
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wayland is a display server protocol that is intended to replace the X Window
    system, and it is licensed under the MIT license.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will provide an overview of Wayland, including some key differences
    with the X Window system, and will show how to make use of it in Yocto.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Wayland protocol follows a client/server model in which clients are the
    graphical applications requesting the display of pixel buffers on the screen,
    and the server, or compositor, is the service provider that controls the display
    of these buffers.
  prefs: []
  type: TYPE_NORMAL
- en: The Wayland compositor can be a Linux display server, an X application, or a
    special Wayland client. Weston is the reference Wayland compositor in the Wayland
    project. It is written in C and works with the Linux kernel APIs. It relies on
    `evdev` for the handling of input events.
  prefs: []
  type: TYPE_NORMAL
- en: Wayland uses **Direct Rendering Manager (DRM)** in the Linux kernel and does
    not need something like an X server. The client renders the window contents to
    a buffer shared with the compositor by itself, using a rendering library, or an
    engine like Qt or GTK+.
  prefs: []
  type: TYPE_NORMAL
- en: Wayland lacks the network transparency features of X, but it is likely that
    similar functionality will be added in the future.
  prefs: []
  type: TYPE_NORMAL
- en: It also has better security features than X and is designed to provide confidentiality
    and integrity. Wayland does not allow applications to look at the input of other
    programs, capture other input events, or generate fake input events. It also makes
    a better job out of protecting the Window outputs. However, this also means that
    it currently offers no way to provide some of the features we are used to in desktop
    X systems like screen capturing, or features common in accessibility programs.
  prefs: []
  type: TYPE_NORMAL
- en: Being lighter than X.Org and more secure, Wayland is better suited to use with
    embedded systems. If needed, X.Org can run as a client of Wayland for backwards
    compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: However, Wayland is not as established as X11, and the Wayland-based images
    in Poky do not receive as much community attention as the X11-based ones.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Poky offers a `core-image-weston` image that includes the Weston compositor.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying our GTK hello world example from the *Using the X Windows system*
    recipe to use GTK3 and run it with Weston is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'To build it, configure your `conf/local.conf` file by removing the `x11` distribution
    feature as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to build from scratch by removing both the `tmp` and `sstate-cache`
    directories when changing the `DISTRO_FEATURES` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the application to the image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'And build the image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Once the build finishes, you will find the microSD card image ready to be programmed
    under `tmp/deploy/images/wandboard-quad`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then launch the application by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FSL community BSP release supports hardware-accelerated graphics in Wayland
    using the Vivante GPU included in the i.MX6 SoC.
  prefs: []
  type: TYPE_NORMAL
- en: This means that applications like `gstreamer` will be able to offer hardware-accelerated
    output when running with the Weston compositor.
  prefs: []
  type: TYPE_NORMAL
- en: Wayland support can also be found in graphical toolkits like Clutter and GTK3+.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find more information about Wayland on the project's web page at [http://wayland.freedesktop.org/](http://wayland.freedesktop.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Python applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Yocto 1.7, Poky has support for building both Python 2 and Python 3 applications,
    and includes a small set of Python development tools in the `meta/recipes-devtools/python`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: A wider variety of Python applications are available in the `meta-python` layer
    included as part of `meta-openembedded`, which you can add to your `conf/bblayers.conf`
    file if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard tool for packaging Python modules is `distutils`, which is included
    for both Python 2 and Python 3\. Poky includes the `distutils` class (`distutils3`
    in Python 3), which is used to build Python packages that use `distutils`. An
    example recipe in `meta-python` that uses the `distutils` class is `meta-python/recipes-devtools/python/python-pyusb_1.0.0a2.bb`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: However, `distutils` does not install package dependencies, allow package uninstallation,
    or allow us to install several versions of the same package, so it is only recommended
    for simple requirements. Hence, `setuptools` was developed to extend on `distutils`.
    It is not included in the standard Python libraries, but it is available in Poky.
    There is also a `setuptools` class in Poky (`setuptools3` for Python 3) that is
    used to build Python packages distributed with `setuptools`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a Python hello world example application with `setuptools`, we would
    use a Yocto `meta-custom/recipes-python/python-helloworld/pythonhelloworld_1.0.bb`
    recipe as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an example hello world package, we create the directory structure
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code for the same directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'And create the following `meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/setup.py`
    Python setup file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the `meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/helloworld/main.py`
    python file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'And a `meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/python-helloworld.py`
    test script that makes use of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add it to our image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'And build it using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Once programmed and booted, we can test the module by running the example script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `meta-python`, you can also find the `python-pip` recipe that will add the
    `pip` utility to your target image. It can be used to install packages from the
    **Python Package Index** (**PyPI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add it to your image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to add the `meta-openembedded/meta-python` layer to your `conf/bblayers.conf`
    file in order to build your image, and also the `python-distribute` dependency,
    which is needed by `python-pip`. Then you can build for the `core-image-minimal`
    image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can use it from the target as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Integrating the Oracle Java Runtime Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Oracle provides two specialized Java editions for embedded development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SE embedded**: This is a large subset of the desktop version of the
    standard Java SE. It contains optimizations with respect to the standard edition,
    like size and memory usage, to adapt it to the needs of mid-sized embedded devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Micro Edition** (**ME**): This is targeted at headless low- and mid-range
    devices, and is a subset of Java SE complying with the **Connected Limited Device
    Configuration** (**CLDC**), and including some extra features and tools for the
    embedded market. Oracle offers a couple of reference implementations, but Java
    ME will have to be individually integrated from source into specific platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus on Java SE embedded, which can be downloaded in binary format
    from the Oracle download site.
  prefs: []
  type: TYPE_NORMAL
- en: Java SE embedded is commercially licensed and requires royalty payments for
    embedded deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yocto has a `meta-oracle-java` layer that is meant to help in the integration
    of the official Oracle **Java Runtime Environment** (**JRE**) Version 7\. However,
    installation without user intervention is not possible, as the Oracle's web page
    requires login and the acceptance of its license.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java SE embedded Version 7, Oracle offered both soft and hard floating point
    versions of headless and headful JREs for ARMv6/v7, and a headless version JRE
    for soft floating point user spaces for ARMv5\. Java SE embedded version 7 provides
    two different **Java Virtual Machines** (**JVMs**) for ARM Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: A client JVM optimized for responsiveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server JVM identical to the client JVM but optimized for long-running applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing, the `meta-oracle-java` layer only has a recipe for the
    headless hard floating-point version with the client JVM. We will add recipes
    for the latest Java 7 SE embedded, which is update 75, for both headless and headful
    hard floating point JREs, which are appropriate to run on an i.MX6-based board
    like `wandboard-quad`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the Java SE embedded runtime environment, first we need to clone
    the `meta-oracle-java` layer into our sources directory and add it to our `conf/bblayers.conf`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to explicitly accept the Oracle Java license by adding the following
    to our `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to build the newest update available, so we add the following `meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headless_1.7.0.bb`
    recipe to our `meta-custom` layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to build the recipe with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: You will see that we get a checksum mismatch. This is caused by the license
    acceptance step in Oracle's website. To get around this, we will need to manually
    download the file into the `downloads` directory as specified in our project's
    `DL_DIR` configuration variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can add the JRE to our target image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'And build it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now log in to the target and run it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also build the headful version using the following `meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headful_1.7.0.bb`
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'And add it to the target image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'And build `core-image-sato` with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the reported Java version is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The latest release at the time of this writing is Java SE embedded Version 8
    update 33 (8u33).
  prefs: []
  type: TYPE_NORMAL
- en: Oracle offers the download of the JDK only, and a host tool, **jrecreate**,
    needs to be used to configure and create an appropriate JRE from the JDK. The
    tool allows us to choose between different JVMs (minimal, client, and server)
    as well as soft or hard floating point ABIs, extensions like JavaFX, locales,
    and several other tweakings to the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Java SE embedded Version 8 provides support for headful X11 development
    using Swing, AWT, and JavaFX only for ARMv7 hard floating point user spaces, and
    includes support for JavaFX (the graphical framework aimed to replace Swing and
    AWT) on the Freescale i.MX6 processor.
  prefs: []
  type: TYPE_NORMAL
- en: There is no Yocto recipe to integrate Java Version 8 at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Open Java Development Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The open source alternative to the Oracle Java SE embedded is the **Open Java
    Development Kit** (**OpenJDK**), an open source implementation of Java SE licensed
    under the GPLv2, with the classpath exception, which means that applications are
    allowed to link without being bound by the GPL license.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to build OpenJDK with Yocto and integrate the JRE
    into our target images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main components of OpenJDK are:'
  prefs: []
  type: TYPE_NORMAL
- en: The HotSpot Java Virtual Machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Java Class Library** (**JCL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java compiler, **javac**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initially, OpenJDK needed to be built using a proprietary JDK. However, the
    **IcedTea** project allowed us to build OpenJDK using the GNU classpath, the GNU
    compiler for Java (GCJ), and bootstrap a JDK to build OpenJDK. It also complements
    OpenJDK with some missing components available on Java SE like a web browser plugin
    and web start implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Yocto can build meta-java using the `meta-java` layer, which includes recipes
    for cross-compiling OpenJDK using IcedTea.
  prefs: []
  type: TYPE_NORMAL
- en: You can download OpenJDK from its Git repository at [http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/](http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/).
  prefs: []
  type: TYPE_NORMAL
- en: Development discussions can be followed and contributed to by visiting the development
    mailing list at [http://lists.openembedded.org/mailman/listinfo/openembedded-devel](http://lists.openembedded.org/mailman/listinfo/openembedded-devel).
  prefs: []
  type: TYPE_NORMAL
- en: The `meta-java` layer also includes recipes for a wide variety of Java libraries
    and VMs, and tools for application development like **ant** and **fastjar**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build OpenJDK 7, you need to clone the `meta-java` layer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: At the time of this writing, there is no 1.7 Dizzy branch yet, so we will work
    directly from the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the layer to your `conf/bblayers.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'And configure the project by adding the following to your `conf/local.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add the OpenJDK package to your image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'And build the image of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the target image, you will get the following Java version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the JVM, we can byte-compile a Java class on our host and copy it to
    the target to execute it. For instance, we can use the following simple `HelloWorld.java`
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'To byte-compile it in the host, we need to have a Java SDK installed. To install
    a Java SDK in Ubuntu, just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'To byte-compile the example, we execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'To run it, we copy the `HelloWorld.class` to the target, and from the same
    folder we run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using OpenJDK on a production system, it is recommended to always use the
    latest available release, which contains bug and security fixes. At the time of
    this writing, the latest OpenJDK 7 release is update 71 (jdk7u71b14), buildable
    with IcedTea 2.5.3, so the `meta-java` recipes should be updated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up-to-date information regarding openJDK can be obtained at [http://openjdk.java.net/](http://openjdk.java.net/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Java applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `meta-java` layer also offers helper classes to ease the integration of
    Java libraries and applications into Yocto. In this recipe, we will see an example
    of building a Java library using the provided classes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `meta-java` layer provides two main classes to help with the integration
    of Java applications and libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Java bbclass**: This provides the default target directories and some
    auxiliary functions, namely:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oe_jarinstall`: This installs and symlinks a JAR file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oe_makeclasspath`: This generates a classpath string from JAR filenames'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oe_java_simple_wrapper`: This wraps your Java application in a shell script'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The java-library bbclass**: This inherits the Java bbclass and extends it
    to create and install JAR files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the following `meta-custom/recipes-java/java-helloworld/java-helloworld-1.0/HelloWorldSwing.java`
    graphical Swing hello world as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate this `HelloWorldSwing` application, we can use a Yocto `meta-custom/recipes-java/java-helloworld/java-helloworld_1.0.bb`
    recipe as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The recipe is also buildable for the host native architecture. We can do this
    either by providing a separate `java-helloworld-native` recipe that inherits the
    `native` class or by using the `BBCLASSEXTEND` variable as we did earlier. In
    both cases, we could then use the `_class-native` and `_class-target` overrides
    to differentiate between native and target functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Java is byte-compiled and the compiled class will be the same for
    both, it still makes sense to add the native support explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java-library` class will create a library package with the name `lib<package>-java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add it to a target image, we would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then decide whether we want to run the application with the Oracle JRE
    or OpenJDK. For OpenJDK, we will add the following packages to our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the Oracle JRE, we will use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The available JREs do not currently run over the framebuffer or Wayland, so
    we will use an X11-based graphical image like `core-image-sato`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then boot it, log in to the target, and execute the example with OpenJDK
    by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the time of this writing, OpenJDK as built from the `meta-java` layer master
    branch is not able to run X11 applications and will fail with this exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the precompiled Oracle JRE runs the application without issues with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you see build errors when building packages with the Oracle JRE, try using
    a different package format, for example, IPK, by adding the following to your
    `conf/local.conf` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: This is due to dependency problems in the `meta-oracle-java` layer with the
    RPM package manager, as explained in the layer's README file.
  prefs: []
  type: TYPE_NORMAL
