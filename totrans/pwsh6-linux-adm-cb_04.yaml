- en: First Steps in Administration using PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with date properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with date and time functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with currently running process to measure resource consumption
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launching and stopping a process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the owner of a process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoking an application based on the file type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing the CronTab module
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scheduling jobs in PowerShell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing scheduled jobs in PowerShell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per Harvard Business Review, a way to effectively learn is to cycle between
    *information feasting* and *information fasting*. Given that we have familiarised
    ourselves (and perhaps a little overwhelmed by the volume of the last chapter),
    we will take a lighter approach to our first steps to administration using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how to run cmdlets, what their parameters are, how to set
    and use aliases, etc. In this chapter, we would learn how to use some basic utilities,
    work with processes, and call applications.
  prefs: []
  type: TYPE_NORMAL
- en: Also, even though the title of the book says Linux, most of the recipes in the
    book should work on Windows as well (especially PowerShell 6.0 on Windows); minor
    modifications may be required, such as using the backslash in paths.
  prefs: []
  type: TYPE_NORMAL
- en: Working with date properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell is best learnt, starting with simple cmdlets. And `Get-Date` is one
    of the simplest-yet-not-completely-leveraged cmdlets present in PowerShell. In
    this recipe, we shall play with dates and see how they can be used in different
    scenarios. As always, the possibilities with PowerShell are quite more than a
    book can cover. In the interest of brevity, we will look at just enough to enable
    you to launch yourself gracefully into the world of PowerShell automation; the
    rest, you would be able to handle by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you followed along the previous chapters and performed all the exercises
    mentioned in them, you should be good to go. Otherwise, go to the chapter, *Installation,
    Reference and Help*, and get yourself a copy of PowerShell. Come back here to
    continue. This recipe uses only the terminal, so there is no need for anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start working with dates, let us make a simple call for the date.
  prefs: []
  type: TYPE_NORMAL
- en: Display the current date and time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find out what members this returned object has.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2fa6a427-d4fb-4f66-a683-816c5e5d09d4.png)'
  prefs: []
  type: TYPE_IMG
- en: A whole bunch of properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to display the date like 16/06/2018.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5e6589ce-2bd7-48fd-83f3-13864445c379.png)'
  prefs: []
  type: TYPE_IMG
- en: The colours do not look right.
  prefs: []
  type: TYPE_NORMAL
- en: Change the command as follows. The syntax should look better now, based on your
    terminal theme. (Don't worry about why the change works for now; we shall look
    at it when dealing with variables at a later point.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But that was a lot of work. Is there an easier way?
  prefs: []
  type: TYPE_NORMAL
- en: Look in Help to see what parameters you get.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is a `Format` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Type the following to get the short date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Try the following as the values for `Format`: `g`, `U`, `yyyy/MM/dd` and `yyyyMMddhhmmss`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58296173-4b02-41ea-881a-9f97745811eb.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're more comfortable with the UNIX formatting of date, use the `Uformat`
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let us take one more step to pass a custom date to the system and fetch a little
    information from it, leveraging the members of the object that is output by `Get-Date`.
  prefs: []
  type: TYPE_NORMAL
- en: Find what day Halloween falls on, in 2018.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you know how date in your locale works, pass the date as follows and get
    the same information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you remember the concept of Type Accelerators, use it to get the information
    you need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember to use the YMD or MDY format when calling the `DateTime` accelerator,
    in order to avoid errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To avoid ambiguity, spell out the month.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `System.DateTime` class in .NET packs a good-enough amount of properties
    and methods. The `Get-Date` cmdlet leverages these properties and methods by means
    of encapsulation. The `Get-Date` cmdlet, by default, pulls the current date and
    time of the system, and allows you to pick child objects from it, or quickly tie
    them together as *formats*.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these operations, the cmdlet also allows you to pass simple string formed
    like date and time, and converts the input string into the `DateTime` object.
  prefs: []
  type: TYPE_NORMAL
- en: While `Get-Date` takes into account your current locale, the type accelerator,
    `DateTime`, seems to work on YMD- or the MDY-formatted date-time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [DateTimeFormatInfo](https://msdn.microsoft.com/library/system.globalization.datetimeformatinfo.aspx#Remarks)
    Class | Remarks (Microsoft Developer Network)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recipe 2.3: Parsing input from text to object (Type Accelerators)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with date and time functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Working with date properties*, we focused on the properties
    that the `DateTime` object has. The parameters we saw for `Get-Date` also worked
    on these properties. In this recipe, we shall look at methods within the `DateTime`
    object, and learn to use them to our benefit. The main idea behind this recipe,
    though, is to make you comfortable using methods that are part of the output objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us first start with converting local time into UTC.
  prefs: []
  type: TYPE_NORMAL
- en: At the prompt, type in `Get-Date` and list out the members of the output object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There is a method, called `ToUniversalTime`. Call the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reduce keystrokes by using tab-completion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Compare the output to your local time.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us see what day it would be, exactly thirty-five days from today.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to see what time it would be after three hours and eighteen
    minutes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, find out how many days have passed since the World Environment Day, 2016.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f40255e1-1726-409d-ab88-f5eae0366a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object that is returned by `Get-Date` has several methods just like how
    it has properties. In this recipe, we use the methods to manipulate date the way
    we need it. Methods are called with arguments. When you do not want to specify
    any argument, ensure still to call the methods with an empty pair of parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Methods can be chained in the way we did in adding hours as well as minutes.
    As long as the output object does not change, in most cases, you should be able
    to call methods pertaining to the object by chaining them. If, for instance, you
    convert the date object into string at the first method, the second method should
    be a string-input-enabled method. When in doubt, use the `Get-Member` cmdlet on
    the output to see what methods it would support.
  prefs: []
  type: TYPE_NORMAL
- en: When you look at `Get-Member` run against the `DateTime` object, you see that
    the `Subtract` method accepts `DateTime` as its argument. Hence the use of `Get-Date`
    *within* the argument. Passing a cmdlet output as an argument to a method requires
    the cmdlet, along with the parameters that are passed, to be enclosed within an
    additional pair of parentheses–`Subtract((Get-Date '5 June 2016'))` as opposed
    to `Subtract(Get-Date '5 June 2016')`–so that the inner command is executed first
    to get a value, and then, passed to the method.
  prefs: []
  type: TYPE_NORMAL
- en: Working with currently-running processes to measure resource consumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good chunk of administration involves working with processes on a given computer.
    PowerShell contains cmdlets that enable you to work with processes on a computer.
    In this recipe, we will list out all the processes running in the system, and
    fetch the amount of resources the processes are collectively consuming.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, *Passing data through pipelines*, we would look at
    other options such as filtration and so on, using what we learn in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already discussed, our goal here is to work with processes.
  prefs: []
  type: TYPE_NORMAL
- en: List out the cmdlets that help you work with processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Remember that PowerShell uses only singular nouns.
  prefs: []
  type: TYPE_NORMAL
- en: We get five cmdlets. What we initially need is Get-Process.
  prefs: []
  type: TYPE_NORMAL
- en: Run the cmdlet to see what it shows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output is a long table of processes, the memory they are consuming, the
    CPU time they are using, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Get the total count of processes currently running in the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, fetch the average of the pages of memory used by the processes. The term
    for this is Working Set, denoted as WS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are other fields in the hash table as well. Let us get all of that information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Get the average, sum, minimum and maximum for both, the working set, as well
    as the CPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4352fcb8-f849-4aa5-8832-54d1d1d7f056.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cmdlet, Get-Process, gives out an entire table of all the processes running
    in the system. Think of each row as an individual object, and the entire table
    as an array of these rows. Count (or in other words, length) is, logically, a
    property of an array. Therefore, we call the cmdlet, and on the object that is
    output, we run a counting operation. This gives us how many processes are running
    in the system at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next cmdlet we see is an important one, as well: `Measure-Object`. This
    cmdlet is designed to perform measurements on the objects that are output. In
    our case, we pick the property, `WS` to perform measurements on. If no property
    is specified, PowerShell will pick the property based on its definition in the
    output object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Measure-Object` is capable of performing some neat arithmetic calculations
    on the output object. We use this capability of the cmdlet to fetch the average
    first, and then, the sum, the minimum value, and the maximum value as well. The
    `Property` parameter accepts a string array as input (`Get-Help Measure-Object
    -Parameter Property`). Therefore, we specify WS as well as CPU (separated by commas)
    in the cmdlet, and then perform the measurement operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Launching and stopping a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All pro-terminal administrators launch and stop processes from the terminal
    all the time. This usually happens at the terminal prompt on Bash. With PowerShell,
    the process is not very different. This recipe will show you how to work the processes.
    And by the way, this recipe where you go on a full information fast.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open VS Code. If the status bar at the bottom is blue, chances are that a folder
    is open in VS Code. VS Code saves the location it is open at, and so, even if
    you start a session of VS Code after a fresh reboot, you would still see a folder
    open. We need the folder closed. To do this, press Ctrl + Shift + N (or go to
    File > New Window). Close the window where a folder is open.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you listed out the commands in the previous recipe, scroll up to find what
    cmdlets might help you with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: At the prompt, type in the following to start Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that the status bar at the bottom is not blue. If it is blue, read the
    *Getting Ready* section of this recipe. Press Ctrl + Shift + E or click on Explorer
    icon on the left sidebar of VS Code. There should not be any directory open there.
  prefs: []
  type: TYPE_NORMAL
- en: Open VS Code at the directory you created the `hello-world` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Press Ctrl + Shift + E or click on Explorer icon on the left sidebar of VS Code.
    Do you see the directory open?
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us stop the VS Code process.
  prefs: []
  type: TYPE_NORMAL
- en: List out the processes running in the system and see if anything matches `code`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the PowerShell way of doing it, run the following command and note
    the name in the `ProcessName` column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: PowerShell deals with objects; `grep` outputs text. Therefore, now that we know
    that the exact name of the process is `code`, we directly get details on the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That gives us a valid output.
  prefs: []
  type: TYPE_NORMAL
- en: Stop all the `code` processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That would not work; the cmdlet accepts a `System.Diagnostics.Process` object
    as input.
  prefs: []
  type: TYPE_NORMAL
- en: Enclose `Get-Process` within parentheses and pass the input to `Stop-Process`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, see if there is a `code` process running any more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d4e99014-7a79-4f58-9d80-a711853638b3.png)'
  prefs: []
  type: TYPE_IMG
- en: The best way of stopping a process is using its ID.
  prefs: []
  type: TYPE_NORMAL
- en: I am running `dconf-editor` on my PC right now, and would like to close it.
    You may choose any process to stop; play safe, though.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cmdlet, Start-Process, works with paths. In case of `code`, though, Linux
    knows the path where the package is installed. Therefore, simply calling the package
    by "command" is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: The VS Code process accepts directory/file location as an input. Therefore,
    we add the `ArgumentList` parameter and pass the path to the process as an argument.
    This opens that directory in VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping a process requires a .NET object as input by default; `Stop-Process`
    would not accept string as the default input. Therefore, we enclose the `Get-Process`
    cmdlet within parentheses, so that it gets executed first and outputs a `System.Diagnostics.Process`
    object, which is then processed by `Stop-Process`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be exact with respect to which process we would like to stop, we
    use the Process ID, and pass it as the argument to `Stop-Process`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the owner of a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipe, *Working with currently-running processes…*, we listed out the
    processes running in the system. The table did not show us the process owner.
    In this recipe, we look at working with processes started by a certain owner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Get-Process` cmdlet can fetch us this information.
  prefs: []
  type: TYPE_NORMAL
- en: At the prompt, type the following to get all the parameters that the `Get-Process`
    cmdlet accepts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We see a parameter `IncludeUserName` (the name suggests it is a switch parameter).
    Get more information on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c0afced1-67c8-48e2-bb2a-faff5025c2b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Filter out the processes started by you. We will use `grep` for this operation,
    until we learn how to filter in PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Count the number of processes running under your name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you would like to use the `Measure-Object` cmdlet, you can.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let us now see how what amount of working set all of the processes started by
    you consume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ca96880c-e0ef-4261-9578-d0b31a8234e2.png)'
  prefs: []
  type: TYPE_IMG
- en: There is an error.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Get-Process` does not show you the process owner information by default. In
    some situations, it may be necessary to have this information. In this simple
    recipe, we use the help documentation to get all the parameters and use the `IncludeUserName`
    switch parameter to get the process owner information.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we filter out the processes started by a certain user, and
    then, count the number of processes. We do the same using `Measure-Object` as
    well, and notice that the output is the same. `Measure-Object` has "object" in
    its name, but worked on text that was output by `grep`. At the same time, it said
    at the next step that the value of `Property` is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to why `Measure-Object` worked when counting, is in the step that
    precedes it. We know that if an array is output, PowerShell can count the number
    of elements in the array. `Measure-Object` is also capable of the same: measuring
    what can be measured in string arrays—`Count` works on string arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: However, when we tried to fetch the total working set, `Measure-Object` could
    not get us that. The reason is that the output of `grep`, as we have seen before,
    is plain text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something perhaps a few steps ahead, but, what if we wanted to get that working
    set information anyway, from the output of `grep`? Simple challenge, accepted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a7449853-658a-4dc1-bb60-82cb93f4e8f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Do not worry too much about how that works, for now. Once we read and understand
    looping through available elements, we will have a better understanding of how
    we got this to work. For now, understand that we converted each of the returned
    strings into `double` values using the `Double` type accelerator. Then, we did
    a `Measure-Object` and found the sum.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, with only PowerShell, this would be much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe 2.4: Comparing the outputs of Bash and PowerShell.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoking an application based on the file type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to use `Start-Process` to start an application. That
    involves, in many cases, launching the application, and from the application,
    opening a file that you want to work on, using the application. In this recipe,
    we will leverage the concept of file association, and a proper calling cmdlet
    to launch an application. In fact, we will go a little further than that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download a few images from the web to work with this recipe. They could be anything,
    just ensure that all of them are of the same file type.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the location where you saved the image files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, type in the following command to open your image viewer, and
    the files in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a text file in the same location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, invoke all the files in their respective applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipe, *Calling a PowerShell cmdlet from outside of PowerShell*, we
    called a PowerShell script from Bash by first invoking PowerShell and then passing
    the script as an argument to the `pwsh` command. The process is very similar in
    PowerShell as well, as seen in *Launching and stopping a process*.
  prefs: []
  type: TYPE_NORMAL
- en: The `Invoke-Item` cmdlet relies on the internal file association to open the
    files. The real use of `Invoke-Item` is when opening multiple files, whether of
    the same kind, or different kinds of files within the same path using the respective
    applications that handle them.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Crontab PowerShell module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss the installation details of a PowerShell module
    to manage Cron jobs using PowerShell on a Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when there is a need for performing administrative tasks or
    scheduling a script to execute automatically at given time. Linux distros, by
    default, come with a scheduling utility, called, Crontab, which allows any given
    tasks to be run automatically in the background at a given time. Cron is a time-based
    scheduler program. It generates events based on the definition in the `crontab`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PowerShell crontab wrapper module is not available in the PowerShell repository
    as yet. You must download the files manually to install the module. The simplest
    way is to clone the PowerShell repository and install the module from within its
    `demos` directory.
  prefs: []
  type: TYPE_NORMAL
- en: If you would rather only install the CronTab module alone, download the `<repo>/demos/crontab` *directory*
    manually. Then, start PowerShell as super-user, and navigate to `crontab`. Continue
    from step 4.
  prefs: []
  type: TYPE_NORMAL
- en: Clone the PowerShell repository on to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Start `pwsh` as a super-user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `demos/crontab/CronTab` directory within the repository. This is where
    the module manifest is placed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Use the `Import-Module` cmdlet on the module manifest to import the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: To list the components of CronTab module use the `Get-Module` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To list the available command types of `CronTab` module use  the `Get-Command`
    cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you download theCronTab module,  the following files get copied to the
    CronTab folder from the URL mentioned in the recipe, and these files contain the
    module data.
  prefs: []
  type: TYPE_NORMAL
- en: CronTab.ps1xml
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CronTab.psd1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CronTab.psm1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Import-Module` cmdlet registers the cmdlets available in the module into
    the PowerShell session and makes the module ready for use. The Import-Module cmdlet
    is run against the module manifest, which is the `psd1` file.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the `Get-Command` cmdlet, you get a list of all the cmdlets available
    in the module.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling jobs in PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to schedule a job using PowerShell cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log in to the terminal using SU privileges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a PowerShell console using the `pwsh` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the module (refer the recipe: Installation of the Crontab PowerShell
    module).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, check the existence of the command or scripts that you want to schedule
    from a terminal
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To run the script based on a schedule, use the `New-CronJob` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: To get the list of currently scheduled jobs, run the `Get-CronJob` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To view the contents of scheduled jobs in the crontab configuration file, use
    `Get-CronTab`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PowerShell implementation of `crontab` technically a wrapper, which encapsulates
    the `crontab` commands that work in Linux. Why use PowerShell to schedule jobs
    if the underlying functions are that of `crontab`? The reason would be the uniformity
    of usage, the consistency and the object-oriented approach. If you know to use
    PowerShell, that is all you need in order to be able to use `crontab` as well.
    That is the goal.
  prefs: []
  type: TYPE_NORMAL
- en: The New-CronTab cmdlet is used to define new tasks. The parameters available
    define the frequency with which the tasks are to be executed. The Cron jobs are
    executed with the same privileges as with which the `New-CronTab` cmdlet was executed.
    In other words, if you launched PowerShell as a super-user and ran New-CronTab
    to define a schedule, the commands that would be run on the specified schedule
    would be run with super-user privileges.
  prefs: []
  type: TYPE_NORMAL
- en: In the steps, the command to run is listed using `-Command` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us also look in brief how what inputs the New-CronTab accepts. There are
    two ways to run a command every 15 minutes: The first is where each minute is
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively,  you can simplify the same to `*/15`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Range can also be specified for scheduling a job. In our example, the job runs
    at 10 A.M,11 A.M and 12 P.M hours using the range option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the last example, (the Names format), the job is scheduled to run using the
    DayOfweek (Sun, Tue, Fri) and Month (Jan, Mar) parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The Cron Table configuration is read using `Get-CronTab` cmdlet. Each line represents
    a record of metadata about the scheduled job; it specifies the frequency and the
    command/script that should be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The caveat as of now is that if you setup Cron jobs incorrectly they appear
    to silently fail. Cron has an own reserved `syslog` facility, so you should have
    a look at the `/etc/syslog.conf` file (or the equivalent file in your Linux distro)
    to see where messages from `cron` are sent. The common destinations include `/var/log/cron`,
    `/var/log/messages` and `/var/log/syslog`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the jobs in PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we're going to see the steps to remove the entries from the
    CronTab file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That we have created entries into the `cron` configuration file, let us attempt
    to remove those entries.
  prefs: []
  type: TYPE_NORMAL
- en: List the jobs using the `Get-CronJob` cmdlet. This will get you the list of
    jobs that are created by reading the `CronTab` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, apply a conditional logic to segregate the required job entries using `Where-Object`
    clause. You will read more about this in the chapter, *Passing Data Through Pipelines*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Remove the entries using `Remove-CronJob`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we would like to remove cron jobs, we list out the cron jobs and then,
    pass the job objects via the pipeline to the cmdlet, `Remove-CronJob`, to remove
    the jobs from the configuration file.
  prefs: []
  type: TYPE_NORMAL
