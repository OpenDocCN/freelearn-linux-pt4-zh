<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Troubleshooting the Network Environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Troubleshooting the Network Environment</h1></div></div></div><p>From ghost connections to packet errors, stream failures and connectivity errors to missing routes, troubleshooting a <a id="id125" class="indexterm"/>network environment can be a slow and arduous process that typically begins with the physical layer. However, once you have confirmed that the physical nodes are working, the next step is to consider and consult the many tools available to your system.</p><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discover the basic tools that will help you troubleshoot a variety of issues related to the network environment. This discussion will include a round-trip tour of <code class="literal">ping</code>, <code class="literal">dig</code>, <code class="literal">host</code>, <code class="literal">traceroute</code>, and <code class="literal">mtr</code>.</li><li class="listitem" style="list-style-type: disc">Discover how to monitor network connections with the <code class="literal">ss</code> command.</li><li class="listitem" style="list-style-type: disc">Learn how to investigate packet transmissions with <code class="literal">tcpdump</code>.</li></ul></div><div class="section" title="Using ping, dig, host, traceroute, and mtr"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Using ping, dig, host, traceroute, and mtr</h1></div></div></div><p>Some of the most common tools available to a troubleshooter are <code class="literal">ping</code>, <code class="literal">dig</code>, <code class="literal">host</code>, <code class="literal">traceroute</code>, and <code class="literal">mtr</code>. Used collectively, these tools provide the troubleshooter with the evidence they need to make a judgment call with respect to almost any network-based issue. This is the basis of the network toolkit, but having said this, it is important to realize that these commands are used for different purposes, and for this reason, we will approach them individually.</p><div class="section" title="The ping command"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec06"/>The ping command</h2></div></div></div><p>The<a id="id126" class="indexterm"/> <code class="literal">ping</code> command <a id="id127" class="indexterm"/>is a small utility that can be used to ascertain whether or not a specific IP address can be reached. The <code class="literal">ping</code> command is common to most computer systems, and it enables you to query an IP address or a fully qualified domain name in order to check whether there is an available connection.</p><p>The basic syntax of the <code class="literal">ping</code> command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ping &lt;ip_address&gt;</strong></span>
<span class="strong"><strong># ping &lt;domain_name&gt;</strong></span>
</pre></div><p>The <a id="id128" class="indexterm"/>
<code class="literal">ping</code> command <a id="id129" class="indexterm"/>works by issuing an ICMP echo request to a specified destination in order to verify and check network connectivity, and it is the simplicity of this statement that makes this command such a useful tool when diagnosing any network-based connectivity issue.</p><p>For example, if you were to issue a ping request to Google (<code class="literal"># ping google.com</code>), then, depending on your networking environment and conditions, the output will look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PING google.com (216.58.210.14) 56(84) bytes of data.</strong></span>
<span class="strong"><strong>64 bytes from lhr08s06-in-f14.1e100.net (216.58.210.14): icmp_seq=1 ttl=55 time=10.5 ms</strong></span>
<span class="strong"><strong>64 bytes from lhr08s06-in-f14.1e100.net (216.58.210.14): icmp_seq=2 ttl=55 time=10.9 ms</strong></span>
<span class="strong"><strong>64 bytes from lhr08s06-in-f14.1e100.net (216.58.210.14): icmp_seq=3 ttl=55 time=36.2 ms</strong></span>
<span class="strong"><strong>64 bytes from lhr08s06-in-f14.1e100.net (216.58.210.14): icmp_seq=4 ttl=55 time=11.0 ms</strong></span>
<span class="strong"><strong>64 bytes from lhr08s06-in-f14.1e100.net (216.58.210.14): icmp_seq=5 ttl=55 time=10.1 ms</strong></span>
<span class="strong"><strong>64 bytes from lhr08s06-in-f14.1e100.net (216.58.210.14): icmp_seq=6 ttl=55 time=32.0 ms</strong></span>
<span class="strong"><strong>64 bytes from lhr08s06-in-f14.1e100.net (216.58.210.14): icmp_seq=7 ttl=55 time=10.6 ms</strong></span>
</pre></div><p>These results are an illustration of a successful ping, and it can be described as the journey of an echo request issued by a local computer system to <code class="literal">google.com (216.58.210.14)</code>.</p><p>The request begins on the host computer; it is then sent over the local network and finally across the Internet. Once the request is successfully received, the target will then respond and the time taken to complete this process is measured in order to generate an average response or latency time. However, if there is no response, then it is likely that there is either a physical problem on the network itself, a fundamental issue such as the location is incorrect or non-functional, the target machine not honoring a ping request, or that the host routing table is incorrect.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>In online computer games, a ping request (also referred to as a "high ping" or "low ping") is typically associated with the measurement of speed from the local machine to the external game server. For example, a player with a low ping (10 ms for example) will have a better gaming experience than a player with a 180 ms ping.</p><p>Moreover, you should also be aware that, if you have a high ping of over 500ms, then it means that any request is taking over half a second to get to the server and back. This condition is noticeable as you will probably be experiencing "frame jitters" or "frame jumps"—a phenomenon known as "rubber banding" in the world of online gameplay.</p></div></div><p>The <a id="id130" class="indexterm"/>
<code class="literal">ping</code> command<a id="id131" class="indexterm"/> is simple to use, but in its naked form, it will continue to execute until it is cancelled. In certain situations, this may prove useful, but it is generally easier to invoke the <code class="literal">-c</code> option in order to reduce the number of echo requests made and to be provided with a summary of the event.</p><p>For example, if you wanted to restrict the number of echo requests made to 4, you need to type the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ping -c 4 google.com</strong></span>
</pre></div><p>In the preceding example, the <code class="literal">ping</code> command will stop issuing echo requests after 4 cycles, and based on our previous example, the output will look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PING google.com (216.58.208.78) 56(84) bytes of data.</strong></span>
<span class="strong"><strong>64 bytes from lhr14s27-in-f14.1e100.net (216.58.208.78): icmp_seq=1 ttl=55 time=11.9 ms</strong></span>
<span class="strong"><strong>64 bytes from lhr14s27-in-f14.1e100.net (216.58.208.78): icmp_seq=2 ttl=55 time=16.7 ms</strong></span>
<span class="strong"><strong>64 bytes from lhr14s27-in-f14.1e100.net (216.58.208.78): icmp_seq=3 ttl=55 time=35.4 ms</strong></span>
<span class="strong"><strong>64 bytes from lhr14s27-in-f14.1e100.net (216.58.208.78): icmp_seq=4 ttl=55 time=15.1 ms</strong></span>

<span class="strong"><strong>--- google.com ping statistics ---</strong></span>
<span class="strong"><strong>4 packets transmitted, 4 received, 0% packet loss, time 3005ms</strong></span>
<span class="strong"><strong>rtt min/avg/max/mdev = 11.985/19.827/35.462/9.187 ms</strong></span>
</pre></div><p>Now, just before we finish this introduction to the <code class="literal">ping</code> command, there are a few points regarding any ping requests that should be considered. These points may not necessarily represent a problem, but they will influence the results of a ping test:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Distance to the target</strong></span>: Let's say you live in the U.S., and you try to connect to a server in the EU. In this situation you should expect that the ping would be higher than if you tried to connect to an alternative U.S. server that is closer to you geographically. Further to this, you should expect that there could be speed differences across the various geographical locations.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Internet connection speed</strong></span>: If you have a low-bandwidth Internet connection (that is, with a poor upload and download speed rating), the ping will take longer to come back to you than if you have a high-bandwidth broadband connection (that is, with a good upload and download speed rating).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The hop count</strong></span>: The <a id="id132" class="indexterm"/>hop count is a generic term that refers to the route and servers the ping has to take to reach the destination and back. So, just like it is in the real world, if you live far away from the main train line, you will need to make additional "connections" or "hops" in order to reach the final destination.</li></ul></div><p>The <a id="id133" class="indexterm"/>basic principle <a id="id134" class="indexterm"/>always states that a low ping is always desirable as it is critical for time-based instructions. However, when conducting a ping test, you must not only consider the total number of pings that actually made it to the target site, but you should also carefully note the average and standard deviation of the pings in question.</p><p>Look at it this way: if the pings do not arrive, this may indicate that there could be packet loss due to an unreliable Internet connection between your computer and the destination. However, if the ping rate is low but it shows a widening variable rate over a specific time period, then under certain circumstances, this type of environment is not always preferable when compared to a more constant rate during the same time period.</p></div><div class="section" title="The dig and host commands"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec07"/>The dig and host commands</h2></div></div></div><p>The <a id="id135" class="indexterm"/>
<code class="literal">dig</code> command<a id="id136" class="indexterm"/> can be used to verify DNS mappings, Internet connectivity, host addresses, and MX records, and to discover more about any potential reverse DNS issues that can give rise to spam and blacklisting. Made available through the <code class="literal">bind-utils</code> package, the<a id="id137" class="indexterm"/> information supplied by <code class="literal">dig</code> is available in four main parts. This includes a header section (a list of the options used), a question section (the query type), the answer section (the address of the location in question), and the query section (containing statistical information regarding the query time, nameservers, and more). The <code class="literal">dig</code> command was introduced to replace <code class="literal">nslookup</code> and the basic syntax is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dig google.com</strong></span>
</pre></div><p>The results will look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-18.el7_1.1 &lt;&lt;&gt;&gt; google.com</strong></span>
<span class="strong"><strong>;; global options: +cmd</strong></span>
<span class="strong"><strong>;; Got answer:</strong></span>
<span class="strong"><strong>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 18657</strong></span>
<span class="strong"><strong>;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</strong></span>

<span class="strong"><strong>;; OPT PSEUDOSECTION:</strong></span>
<span class="strong"><strong>; EDNS: version: 0, flags:; udp: 512</strong></span>
<span class="strong"><strong>;; QUESTION SECTION:</strong></span>
<span class="strong"><strong>;google.com.                    IN      A</strong></span>

<span class="strong"><strong>;; ANSWER SECTION:</strong></span>
<span class="strong"><strong>google.com.             299     IN      A       216.58.210.78</strong></span>

<span class="strong"><strong>;; Query time: 100 msec </strong></span>
<span class="strong"><strong>;; SERVER: 8.8.8.8#53(8.8.8.8)</strong></span>
<span class="strong"><strong>;; WHEN: Sat Apr 25 13:45:02 EDT 2015</strong></span>
<span class="strong"><strong>;; MSG SIZE  rcvd: 55</strong></span>
</pre></div><p>You <a id="id138" class="indexterm"/>will notice<a id="id139" class="indexterm"/> that there is a lot of information contained within such output, so let's break this down by starting with the global options section:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-18.el7_1.1 &lt;&lt;&gt;&gt; google.com</strong></span>
<span class="strong"><strong>;; global options: +cmd</strong></span>
</pre></div><p>This is then followed by an output that reports on the answer:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>;; Got answer:</strong></span>
<span class="strong"><strong>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 18657</strong></span>
<span class="strong"><strong>;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</strong></span>
<span class="strong"><strong>;; OPT PSEUDOSECTION:</strong></span>
<span class="strong"><strong>; EDNS: version: 0, flags:; udp: 512</strong></span>
</pre></div><p>Following this, <code class="literal">dig</code> then repeats the original question:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>;; QUESTION SECTION:</strong></span>
<span class="strong"><strong>;google.com.                    IN      A</strong></span>
</pre></div><p>The answer is provided as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>;; ANSWER SECTION:</strong></span>
<span class="strong"><strong>google.com.             299     IN      A       216.58.210.78</strong></span>
</pre></div><p>Finally, we<a id="id140" class="indexterm"/> are presented<a id="id141" class="indexterm"/> with some general statistics about the query itself:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>;; Query time: 100 msec</strong></span>
<span class="strong"><strong>;; SERVER: 8.8.8.8#53(8.8.8.8)</strong></span>
<span class="strong"><strong>;; WHEN: Sat Apr 25 13:45:02 EDT 2015</strong></span>
<span class="strong"><strong>;; MSG SIZE  rcvd: 55</strong></span>
</pre></div><p>Also, by replacing <code class="literal">XXX.XXX.XXX.XXX</code> with a relevant IP address, you can query a specific nameserver like so:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dig google.com @XXX.XXX.XXX.XXX</strong></span>
</pre></div><p>So, if you run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dig google.com @8.8.8.8</strong></span>
</pre></div><p>You can expect to see the following results:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-18.el7_1.1 &lt;&lt;&gt;&gt; google.com @8.8.8.8</strong></span>
<span class="strong"><strong>;; global options: +cmd</strong></span>
<span class="strong"><strong>;; Got answer:</strong></span>
<span class="strong"><strong>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 5496</strong></span>
<span class="strong"><strong>;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</strong></span>

<span class="strong"><strong>;; OPT PSEUDOSECTION:</strong></span>
<span class="strong"><strong>; EDNS: version: 0, flags:; udp: 512</strong></span>
<span class="strong"><strong>;; QUESTION SECTION:</strong></span>
<span class="strong"><strong>;google.com.                    IN      A</strong></span>

<span class="strong"><strong>;; ANSWER SECTION:</strong></span>
<span class="strong"><strong>google.com.             299     IN      A       216.58.210.78</strong></span>

<span class="strong"><strong>;; Query time: 92 msec</strong></span>
<span class="strong"><strong>;; SERVER: 8.8.8.8#53(8.8.8.8)</strong></span>
<span class="strong"><strong>;; WHEN: Sat Apr 25 13:46:54 EDT 2015</strong></span>
<span class="strong"><strong>;; MSG SIZE  rcvd: 55</strong></span>
</pre></div><p>Moreover, where the default action of the <code class="literal">dig</code> command is to search for <code class="literal">A</code> records, you can manipulate the <code class="literal">dig</code> syntax in order to obtain information based on a specific record type as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dig google.com MX</strong></span>
<span class="strong"><strong># dig google.com TXT</strong></span>
<span class="strong"><strong># dig google.com NS</strong></span>
<span class="strong"><strong># dig google.com SOA</strong></span>
</pre></div><p>As an <a id="id142" class="indexterm"/>alternative, and<a id="id143" class="indexterm"/> in order to generalize the results, you can implement the <code class="literal">ANY</code> query in order to obtain as much information as possible by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dig google.com ANY</strong></span>
</pre></div><p>Further to this, the <code class="literal">dig</code> command can be used to implement a reverse lookup in order to obtain relevant DNS information based on a specific IP address.</p><p>This can be achieved by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dig -x 8.8.8.8</strong></span>
</pre></div><p>The preceding command will subsequently respond with an answer in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-18.el7_1.1 &lt;&lt;&gt;&gt; -x 8.8.8.8</strong></span>
<span class="strong"><strong>;; global options: +cmd</strong></span>
<span class="strong"><strong>;; Got answer:</strong></span>
<span class="strong"><strong>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 34651</strong></span>
<span class="strong"><strong>;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</strong></span>

<span class="strong"><strong>;; OPT PSEUDOSECTION:</strong></span>
<span class="strong"><strong>; EDNS: version: 0, flags:; udp: 512</strong></span>
<span class="strong"><strong>;; QUESTION SECTION:</strong></span>
<span class="strong"><strong>;8.8.8.8.in-addr.arpa.          IN      PTR</strong></span>

<span class="strong"><strong>;; ANSWER SECTION:</strong></span>
<span class="strong"><strong>8.8.8.8.in-addr.arpa.   21599   IN      PTR     google-public-dns-a.google.com.</strong></span>

<span class="strong"><strong>;; Query time: 35 msec</strong></span>
<span class="strong"><strong>;; SERVER: 8.8.8.8#53(8.8.8.8)</strong></span>
<span class="strong"><strong>;; WHEN: Sat Apr 25 13:49:13 EDT 2015</strong></span>
<span class="strong"><strong>;; MSG SIZE  rcvd: 93</strong></span>
</pre></div><p>So, as you can see, <code class="literal">dig</code> is a flexible command-line tool that will enable you to perform a valid DNS query. Its output is verbose, but it can be encapsulated with the <code class="literal">+short</code> switch to provide a reduced and concise answer like so:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dig -x 209.132.183.81 +short</strong></span>
</pre></div><p>The above command should respond in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>www.redhat.com.</strong></span>
</pre></div><p>The <a id="id144" class="indexterm"/>
<code class="literal">dig</code> command<a id="id145" class="indexterm"/> is an incredibly useful tool for troubleshooting a network, and its success is primarily associated with its ability to return the question, answer, authority, and additional sections.</p><p>However, and having said that, the alternative is to use the <code class="literal">host</code> command in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># host –a google.com</strong></span>
</pre></div><p>The <a id="id146" class="indexterm"/>
<code class="literal">host</code> command <a id="id147" class="indexterm"/>works in a <a id="id148" class="indexterm"/>similar way to the <code class="literal">dig</code> command but its output looks like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Trying "google.com"</strong></span>
<span class="strong"><strong>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 60735</strong></span>
<span class="strong"><strong>;; flags: qr rd ra; QUERY: 1, ANSWER: 14, AUTHORITY: 0, ADDITIONAL: 0</strong></span>

<span class="strong"><strong>;; QUESTION SECTION:</strong></span>
<span class="strong"><strong>;google.com.                    IN      ANY</strong></span>

<span class="strong"><strong>;; ANSWER SECTION:</strong></span>
<span class="strong"><strong>google.com.             299     IN      A       216.58.210.78</strong></span>
<span class="strong"><strong>google.com.             299     IN      AAAA    2a00:1450:4009:801::200e</strong></span>
<span class="strong"><strong>google.com.             21599   IN      NS      ns3.google.com.</strong></span>
<span class="strong"><strong>google.com.             21599   IN      TYPE257 \# 19 0005697373756573796D616E7465632E636F6D</strong></span>
<span class="strong"><strong>google.com.             599     IN      MX      20 alt1.aspmx.l.google.com.</strong></span>
<span class="strong"><strong>google.com.             21599   IN      NS      ns4.google.com.</strong></span>
<span class="strong"><strong>google.com.             21599   IN      SOA     ns1.google.com. dns-admin.google.com. 2015041501 7200 1800 1209600 300</strong></span>
<span class="strong"><strong>google.com.             3599    IN      TXT     "v=spf1 include:_spf.google.com ip4:216.73.93.70/31 ip4:216.73.93.72/31 ~all"</strong></span>
<span class="strong"><strong>google.com.             599     IN      MX      40 alt3.aspmx.l.google.com.</strong></span>
<span class="strong"><strong>google.com.             21599   IN      NS      ns1.google.com.</strong></span>
<span class="strong"><strong>google.com.             599     IN      MX      30 alt2.aspmx.l.google.com.</strong></span>
<span class="strong"><strong>google.com.             599     IN      MX      50 alt4.aspmx.l.google.com.</strong></span>
<span class="strong"><strong>google.com.             21599   IN      NS      ns2.google.com.</strong></span>
<span class="strong"><strong>google.com.             599     IN      MX      10 aspmx.l.google.com.</strong></span>
</pre></div><p>As you <a id="id149" class="indexterm"/>can<a id="id150" class="indexterm"/> see, the <code class="literal">host</code> command serves a similar purpose to <code class="literal">dig</code> and yet it is far more succinct.</p><p>For example, a basic <code class="literal">host</code> query will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># host www.google.com</strong></span>
</pre></div><p>The returned output will look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>www.google.com has address 216.58.210.68</strong></span>
<span class="strong"><strong>www.google.com has IPv6 address 2a00:1450:4009:801::2004</strong></span>
</pre></div><p>Alternatively, you can specify a third-party DNS server in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># host www.redhat.com 8.8.8.8</strong></span>
</pre></div><p>The output of this will report on the use of an alternative DNS server and look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Using domain server:</strong></span>
<span class="strong"><strong>Name: 8.8.8.8</strong></span>
<span class="strong"><strong>Address: 8.8.8.8#53</strong></span>
<span class="strong"><strong>Aliases:</strong></span>

<span class="strong"><strong>www.redhat.com is an alias for wildcard.redhat.com.edgekey.net.</strong></span>
<span class="strong"><strong>wildcard.redhat.com.edgekey.net is an alias for wildcard.redhat.com.edgekey.net.globalredir.akadns.net.</strong></span>
<span class="strong"><strong>wildcard.redhat.com.edgekey.net.globalredir.akadns.net is an alias for e1890.b.akamaiedge.net.</strong></span>
<span class="strong"><strong>e1890.b.akamaiedge.net has address 23.195.127.72</strong></span>
</pre></div><p>Finally, <code class="literal">host</code> can perform reverse lookups like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># host XXX.XXX.XXX.XXX</strong></span>
</pre></div><p>So, let's say you run a reverse lookup against Red Hat's Akamai Edge server with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># host 23.195.127.72</strong></span>
</pre></div><p>The output will look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>72.127.195.23.in-addr.arpa domain name pointer a23-195-127-72.deploy.static.akamaitechnologies.com.</strong></span>
</pre></div><p>So look at it this way: for <a id="id151" class="indexterm"/>the purpose of troubleshooting a network, you can use either <code class="literal">dig</code> or <code class="literal">host</code>. Both of the commands are similar in terms of what they can be used for and what they can achieve, but where <code class="literal">host</code> offers simplicity, <code class="literal">dig</code> serves to provide a more advanced<a id="id152" class="indexterm"/> and script-worthy option.</p></div><div class="section" title="The traceroute command"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec08"/>The traceroute command</h2></div></div></div><p>The <a id="id153" class="indexterm"/>
<code class="literal">traceroute</code> command is<a id="id154" class="indexterm"/> designed to show the pathway to a remote destination and the delays that occur at every stop. Most administrators <a id="id155" class="indexterm"/>are familiar with <code class="literal">traceroute</code> and it maintains three primary objectives<a id="id156" class="indexterm"/> that can be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To provide details of the entire path that a packet will traverse</li><li class="listitem" style="list-style-type: disc">To provide the names and the identity of the devices and routers found on that path</li><li class="listitem" style="list-style-type: disc">To report on network latency as a result of assessing the time taken to send and receive data to each device on a given path</li></ul></div><p>In simple terms, the <code class="literal">traceroute</code> command is a tool that verifies the path your data will take without using any data, and the syntax used is based on the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># traceroute google.com</strong></span>
</pre></div><p>The output will provide the specified host, the IP address for that domain, the maximum number of hops required, and the size of the packet that will be used. The subsequent lines then report the hop number, hostname, IP address, and packet round-trip times. Of course, you can also avoid reverse DNS with the use of the <code class="literal">-n</code> option in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># traceroute -n google.com</strong></span>
</pre></div><p>The <code class="literal">traceroute</code> command sends three packets with each TTL and will display the round-trip time (RTT), which indicates the time difference between the issuing of a probe and the receipt of a response packet. This is useful in discovering network bottlenecks, and if you begin to see asterisks (*), then this suggests that there is a potential problem routing to that host as the asterisks can indicate packet loss or a dropped packet. However, it is also important to realize that interpreting <code class="literal">traceroute</code> can rely on an understanding and appreciation of its inherent quirks.</p><p>The <code class="literal">traceroute</code> command is <a id="id157" class="indexterm"/>recognized to be the cornerstone of TCP/IP troubleshooting. It begins by issuing a UDP-based packet with a TTL value of 1. If the packet reaches the target, then the gateway sends a response packet and reports its findings. However, if the packet does not reach the target, then the recipient gateway will decrease the TTL by the value of 1. If the TTL value reaches 0, then the gateway will drop the packet and report the results after a new packet is issued with an increased value in order to circumvent the same gateway in the next phase. This process is repeated until the target host is reached or the maximum TTL value is reached.</p><p>There are<a id="id158" class="indexterm"/> three different types of <code class="literal">traceroute</code> implementation that cover UDP, TCP, and ICMP.</p><p>For example, if you wanted to use the ICMP variation, you will type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># traceroute –I google.com</strong></span>
</pre></div><p>Again, you can bypass DNS with the <code class="literal">–n</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># traceroute -I -n 8.8.8.8</strong></span>
</pre></div><p>This variation will work in a manner similar to the previous examples that use UDP in which the <code class="literal">traceroute</code> program will send echo requests, and the hops in between will reply. However, unlike the UDP version, the process will use ICMP.</p><p>The final way is to use a TCP variation in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># traceroute -T google.com</strong></span>
</pre></div><p>In many respects, the TCP option is probably the most effective method, as most networks will allow for this traffic. This is particularly so if you are targeting port 80. However, there are no hard and fast rules to determine which version of <code class="literal">traceroute</code> you can or want to use. The rules will be set by the network configuration, as some networks will block UDP requests by default (typically, ports 33434 to 33534). So, based on this, why not try them all and see what provides the best results for your environment.</p><p>Let's look at it this way: knowing how <code class="literal">traceroute</code> works is winning only half the battle. If <code class="literal">traceroute</code> can reach the host, but not the target, then it is likely that the issue is with the target. However, if <code class="literal">traceroute</code> cannot reach the host, then it is likely that the issue lies with the route itself, which not only consists of some routers denying <code class="literal">traceroute</code> packets, but others that show remarkable differences in bandwidth and latency, firewalls, and a whole host of other traps that are filtering <code class="literal">traceroute</code> packets. In this situation, multiple targets should be<a id="id159" class="indexterm"/> selected (you should also consider sending your requests using UDP, ICMP, and TCP to circumvent any network issues), and given that the Internet<a id="id160" class="indexterm"/> is asymmetric by nature, it is generally a good idea to perform a <code class="literal">traceroute</code> action in both directions in order to judge the overall network efficiency.</p><p>On the whole, <code class="literal">traceroute</code> is an excellent tool, but it can be misleading, so be cautious in analyzing the results and always supplement your work with additional investigation.</p></div><div class="section" title="The mtr command"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec09"/>The mtr command</h2></div></div></div><p>As an <a id="id161" class="indexterm"/>alternative to <code class="literal">traceroute</code>, there <a id="id162" class="indexterm"/>is the <code class="literal">mtr</code> command. On some Linux systems, you will need to run this as the root user or in conjunction with <code class="literal">sudo</code>, but whatever method you use, the syntax of this command is very simple and it works in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mtr google.com</strong></span>
</pre></div><p>The output may look <a id="id163" class="indexterm"/>similar to <code class="literal">traceroute</code>, but the display is in real-time, thereby enabling you to monitor trends and averages to reflect how network performance changes over time. So unlike <code class="literal">traceroute</code>, instead of merely taking a snapshot of a single journey, by using <code class="literal">mtr</code> you are able to check for intermittent packet issues by gathering data over a longer period of time. Moreover, as an alternative to real-time updates, <code class="literal">mtr</code> will also provide a reporting option that will issue the results of 10 packets to each hop encountered:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mtr --report google.com</strong></span>
</pre></div><p>So, upon reflection, it can be argued that <code class="literal">mtr</code> is superior to <code class="literal">traceroute</code> at monitoring network connectivity. It certainly has many advantages and it can provide a significant amount of detail, but knowing that you cannot control how the world will work outside your internal network, the seasoned troubleshooter should always remain vigilant and choose to examine every tool at his disposal.</p></div></div></div>
<div class="section" title="Monitoring network connections with the ss command"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Monitoring network connections with the ss command</h1></div></div></div><p>The<a id="id164" class="indexterm"/> socket statistics command (<code class="literal">ss</code>) is the<a id="id165" class="indexterm"/> successor to <code class="literal">netstat</code>; it is not only faster, but it is also able to display more information. However, unlike <code class="literal">netstat</code>, which obtains its information from the various files contained within the <code class="literal">/proc</code> directory, the <code class="literal">ss</code> command obtains its information directly from the kernel space.</p><p>The basic <a id="id166" class="indexterm"/>syntax of the <code class="literal">ss</code> command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ss | less</strong></span>
</pre></div><p>Using this syntax, we have simply called for an output of all TCP, UDP, and Unix socket connections with an optional pipe to <code class="literal">less</code> in order to ensure that the results can be seen on screen. Of course, this command can be combined with either the <code class="literal">-t</code>, <code class="literal">-u</code> or, <code class="literal">-x</code> option to restrict any output to show either TCP, UDP, or Unix socket connections respectively, but in order to make the output more informative, you will probably want to combine one of these additional options with the <code class="literal">-a</code> option in order to report on both connected and listening sockets like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ss -ta</strong></span>
</pre></div><p>As you will <a id="id167" class="indexterm"/>notice, in the preceding instance we are only reporting on the current TCP environment and it can be changed to suit UDP (<code class="literal">ss -ua</code>) or Unix socket connections (<code class="literal">ss -xa</code>) in a similar way. However, if you enjoy a degree of precision, you will be comforted to know that the <code class="literal">ss</code> command can be combined with a query by using the <code class="literal">–A</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ss -a -A tcp</strong></span>
</pre></div><p>Restricting the output does serve to make the information far more concise, but to take this one stage further, additional filters can be applied using the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ss [ OPTIONS ] [ STATE-FILTER ] [ ADDRESS-FILTER ]</strong></span>
</pre></div><p>For example, where all standard TCP states are accounted for, you can display all established IPv4 TCP sockets in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ss -t4 state established</strong></span>
</pre></div><p>You can show all closed TCP states like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ss -t4 state closed</strong></span>
</pre></div><p>Now, it can be argued that using the <code class="literal">ss</code> command will perform in a similar way to using <code class="literal">netstat -a</code>. This in part is true, but (and remember that you can replace <code class="literal">-t</code> with <code class="literal">-u</code> or <code class="literal">-x</code>) given the ability to increase the speed of execution by not resolving hostnames (<code class="literal">ss -nt</code>), show only listening sockets (<code class="literal">ss -ltn</code>), show socket memory usage (<code class="literal">ss -t -m</code>), show processes using particular sockets (<code class="literal">ss -t -p</code>), print the process name (<code class="literal">ss -ltp</code>), display either IPv4 or IPv6 (<code class="literal">ss -tl4</code> or <code class="literal">ss -tl6</code>), and show time information (<code class="literal">ss -tn -o</code>), you will notice that we have merely scratched the surface of the <code class="literal">ss</code> command.</p><p>For example, you<a id="id168" class="indexterm"/> can even run a query to discover who was using port 22 (SSH) by using the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ss -lpn | grep 22</strong></span>
</pre></div><p>Alternatively, you can use the following syntax to show all ports connected from a remote IP address:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ss dst XXX.XXX.XXX.XXX</strong></span>
</pre></div><p>Then filter the query to a specific port with the following variation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ss dst XXX.XXX.XXX.XXX:22</strong></span>
</pre></div><p>Remember, familiarity <a id="id169" class="indexterm"/>with your networking environment will always help, and armed with this command, you should be in a better position to recognize problematic connections before they take hold.</p></div>
<div class="section" title="Packet analysis with tcpdump"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Packet analysis with tcpdump</h1></div></div></div><p>The<a id="id170" class="indexterm"/> <code class="literal">tcpdump</code> command<a id="id171" class="indexterm"/> is a packet analyzer that is able to capture and <a id="id172" class="indexterm"/>provide a description of the traffic being transmitted across a network interface. It is common to most flavors of Linux, and it provides access to a unique view of the network at the packet level that can prove vital when troubleshooting the network environment.</p><p>The basic syntax for using <code class="literal">tcpdump</code> is expressed in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tcpdump -i &lt;device_name&gt;</strong></span>
</pre></div><p>You can also specify a protocol like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tcpdump -i &lt;device_name&gt; tcp</strong></span>
</pre></div><p>While a port value can be used in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tcpdump -i &lt;device_name&gt; port 22</strong></span>
</pre></div><p>Verbosity options can be issued by using <code class="literal">-v</code> or <code class="literal">-vv</code>, while DNS can be avoided with the <code class="literal">-n</code> option. However, because <code class="literal">tcpdump</code> will continue running until the request is cancelled, it is always preferable to use the <code class="literal">-c</code> option in order to capture a pre-determined number of events in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tcpdump -c 10 -i &lt;device_name&gt;</strong></span>
</pre></div><p>Taking this one step further, you can capture <code class="literal">10</code> packets from a specific IP address by calling either the <code class="literal">src</code> option (source) or the <code class="literal">dst</code> option (destination) like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tcpdump -c 10 -i &lt;device_name&gt; src XXX.XXX.XXX.XXX</strong></span>
</pre></div><p>While the device name itself can be obtained by running the following option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tcpdump -D</strong></span>
</pre></div><p>The <code class="literal">tcpdump</code> command<a id="id173" class="indexterm"/> can be run in both the read and write modes. However, where the latter implies the use of the <code class="literal">-w</code> option that will cause <code class="literal">tcpdump</code> to save the packet data to a file for later analysis, the former, signified by the use of the <code class="literal">-r</code> option, will determine that <code class="literal">tcpdump</code> will read from a saved packet file only. As you will come to realize, when in the write mode you should specify the relevant device name (that is <code class="literal">eth0</code>), but in both cases, only packets that match an expression will be matched and displayed.</p><p>For example, in read mode, the basic syntax of this commands looks like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tcpdump -r &lt;file_name&gt;</strong></span>
</pre></div><p>While in write mode, you can send the entire Ethernet frame for further analysis in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tcpdump -w /path/to/file -i &lt;device_name&gt;</strong></span>
</pre></div><p>So as<a id="id174" class="indexterm"/> you can see, the most common application of <code class="literal">tcpdump</code> is to verify whether the process of two-way communication is working. The <code class="literal">tcpdump</code> command can be used to record network segments, and while recognizing this fact, we have merely scratched the surface of its flexibility.</p><p>For this reason, I hope you can already see how this small utility can become an important tool when troubleshooting your networking environment.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Summary</h1></div></div></div><p>The purpose of this chapter was to provide a starting point when attempting to troubleshoot areas of concern across the network environment. Of course, there is always more to learn, and knowing this will take you on a journey that goes far beyond the basic syntax of <code class="literal">dig</code>, <code class="literal">ping</code>, or even <code class="literal">tcpdump</code>. However, having toured a number of commands and utilities, you can now see how becoming an effective troubleshooter is quickly becoming an obtainable goal. To further our cause, we will now set our sights on the need to troubleshoot package management.</p></div>
<div class="section" title="References"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>References</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The TCP Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol">http://en.wikipedia.org/wiki/Transmission_Control_Protocol</a></li><li class="listitem" style="list-style-type: disc">The Ping Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Ping_(networking_utility)">http://en.wikipedia.org/wiki/Ping_(networking_utility)</a></li><li class="listitem" style="list-style-type: disc">The Traceroute Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Traceroute">http://en.wikipedia.org/wiki/Traceroute</a></li><li class="listitem" style="list-style-type: disc">The <code class="literal">ss</code> command official page: <a class="ulink" href="http://www.cyberciti.biz/files/ss.html">http://www.cyberciti.biz/files/ss.html</a></li><li class="listitem" style="list-style-type: disc">The ARP Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Address_Resolution_Protocol">http://en.wikipedia.org/wiki/Address_Resolution_Protocol</a></li><li class="listitem" style="list-style-type: disc">The <code class="literal">dig</code> command Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Dig_(command)">http://en.wikipedia.org/wiki/Dig_(command)</a></li><li class="listitem" style="list-style-type: disc">The <code class="literal">tcpdump</code> Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Tcpdump">http://en.wikipedia.org/wiki/Tcpdump</a></li></ul></div></div></body></html>