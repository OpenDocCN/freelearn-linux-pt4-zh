<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Networking"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Networking</h1></div></div></div><p>This chapter contains the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting a static IP address</li><li class="listitem" style="list-style-type: disc">Binding multiple addresses to a single Ethernet device</li><li class="listitem" style="list-style-type: disc">Bonding two Ethernet devices</li><li class="listitem" style="list-style-type: disc">Configuring the network firewall with FirewallD</li><li class="listitem" style="list-style-type: disc">Configuring the network firewall using iptables</li><li class="listitem" style="list-style-type: disc">Installing a DHCP server</li><li class="listitem" style="list-style-type: disc">Configuring an NFS server to share a filesystem</li><li class="listitem" style="list-style-type: disc">Configuring an NFS client to use a shared filesystem</li><li class="listitem" style="list-style-type: disc">Serving Windows shares with Samba</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Introduction</h1></div></div></div><p>The recipes in this chapter cover various networking tasks that should prove useful to you as a CentOS administrator. You'll learn how to configure a static IP address, bind multiple addresses to a single Ethernet device, and bond two devices together. You'll also see how to configure the system's firewall using FirewallD and iptables, and how to set up a DHCP server to distribute IP addresses, which allows other computers using dynamic networking configurations to access the network. The remaining recipes will teach you how to set up centralized file storage using NFS and Samba.</p></div></div>
<div class="section" title="Setting a static IP address"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Setting a static IP address</h1></div></div></div><p>This recipe shows you how to configure a static IP address. Unless you configured a static address during installation, CentOS uses the Dynamic Host Configuration Protocol (DHCP) to obtain an IP address to communicate across the network. Using a dynamically assigned address is fine for most desktop and laptop systems, but those that host e-mail servers, file sharing and print services, and web servers should have an address that doesn't change. The static address provides a stable, known location on the network where users can access a system's services.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection and administrative privileges provided by logging in with the <code class="literal">root</code> account. It assumes that your primary Ethernet device is named <code class="literal">enp0s3</code> and is currently configured with DHCP. If your device is named differently, substitute its name appropriately in the following commands.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>How to do it...</h2></div></div></div><p>Follow these steps to configure a static IP address:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the Ethernet device's configuration file, found under <code class="literal">/etc/ sysconfig/network-scripts</code>,with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/sysconfig/network-scripts/ifcfg-enp0s3</strong></span>
</pre></li><li class="listitem">Change the value of <code class="literal">BOOTPROTO</code> to none:<pre class="programlisting">
<span class="strong"><strong>BOOTPROTO="none"</strong></span>
</pre></li><li class="listitem">At the end of the file, add the <code class="literal">IPADDR</code>, <code class="literal">NETMASK</code>, and <code class="literal">BROADCAST</code> entries to set the desired IP address. Assign them values that properly reflect your network:<pre class="programlisting">
<span class="strong"><strong>IPADDR="192.168.56.100"</strong></span>
<span class="strong"><strong>NETMASK="255.255.255.0"</strong></span>
<span class="strong"><strong>BROADCAST="192.168.56.255"</strong></span>
</pre><div class="mediaobject"><img alt="How to do it..." src="graphics/image_02_001.jpg"/><div class="caption"><p>The interface is configured with a static IP address</p></div></div></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Open the <code class="literal">/etc/sysconfig/network</code> file using your editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/sysconfig/network</strong></span>
</pre></li><li class="listitem">Add a <code class="literal">GATEWAY</code> entry to identify your network's gateway:<pre class="programlisting">
<span class="strong"><strong>GATEWAY="192.168.56.1"</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Restart the networking service for the configuration changes to take effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart network.service</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>How it works...</h2></div></div></div><p>In this recipe, you learned how to assign a static IP address to an Ethernet device. It assumed the name of your primary Ethernet device to be <code class="literal">enp0s3</code>, thus <code class="literal">ifcfg-enp0s3</code> would be the name of the device's configuration file. If your device is named differently (for example, <code class="literal">eth0</code>, <code class="literal">eno1677</code>, and so on) then you need to adjust the recipe's directions accordingly.</p><p>First, we changed the value for <code class="literal">BOOTPROTO</code> from <code class="literal">dhcp</code>, the protocol used to obtain an IP address dynamically, to <code class="literal">none</code> since we are setting the address ourselves. Then we added the <code class="literal">IPADDR</code>, <code class="literal">NETMASK</code>, and <code class="literal">BROADCAST</code> entries to provide the details of the static IP address. Next, we specified the network's default gateway using <code class="literal">GATEWAY</code> in <code class="literal">/etc/ sysconfig/network</code>. This allows us to route traffic beyond the local subnetwork.</p><p>After you restart the networking service, you can confirm the new address using the <code class="literal">ip</code> command. <code class="literal">ip addr show</code> will display information about the current state of your system's network devices:</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_02_002.jpg"/><div class="caption"><p>ip addr show displays your system's networking information</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>See also</h2></div></div></div><p>For more information on configuring network settings in CentOS, refer to the <span class="emphasis"><em>Configure IP Networking</em></span> chapter in the RHEL 7 Networking Guide (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Networking_Guide/ch-Configure_IP_Networking.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Networking_Guide/ch-Configure_IP_Networking.html</a>).</p></div></div>
<div class="section" title="Binding multiple addresses to a single Ethernet device"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Binding multiple addresses to a single Ethernet device</h1></div></div></div><p>This recipe shows you how to bind multiple IP addresses to a single Ethernet device. The ability to assign more than one address to the same device can be useful-the most obvious benefit is that you don't need to procure multiple Ethernet cards. The cost of hardware has dropped substantially, but IT budgets still run tight. Perhaps a less obvious benefit, but one more valuable, is the greater flexibility it gives when configuring network services. Different services, such as e-mail and websites, can run on the same system but be accessed using different addresses.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. It assumes that your primary Ethernet device is <code class="literal">enp0s3</code> and is configured with a static IP address. You'll also need administrative privileges provided by logging in with the <code class="literal">root</code> account.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>How to do it...</h2></div></div></div><p>Follow these steps to bind multiple addresses to the same Ethernet device:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Make a copy of the device's configuration file:<pre class="programlisting">
<span class="strong"><strong>cp /etc/sysconfig/network-scripts/ifcfg-enp0s3  &#13;
       /etc/sysconfig/network-scripts/ifcfg-enp0s3:1</strong></span>
</pre></li><li class="listitem">Open the new file with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/sysconfig/network-scripts/ifcfg-enp0s3:1</strong></span>
</pre></li><li class="listitem">Delete the <code class="literal">UUID</code> entry entirely. If a <code class="literal">HWADDR</code> entry exists, delete that also.</li><li class="listitem">Update the <code class="literal">NAME</code> and <code class="literal">DEVICE</code> values:<pre class="programlisting">
<span class="strong"><strong>NAME="System enp0s3:1"</strong></span>
<span class="strong"><strong>DEVICE="enp0s3:1"</strong></span>
</pre></li><li class="listitem">Change the value of <code class="literal">IPADDR</code> to the IP address you wish to use:<pre class="programlisting">
<span class="strong"><strong>IPADDR="192.168.56.101"</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Restart the networking service for the configuration changes to take effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart network.service</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>How it works...</h2></div></div></div><p>In this recipe, you learned how to assign multiple IP addresses to the same Ethernet device. We made a copy of one of the original network configuration files, taking care to name it appropriately to create a virtual adapter, and edited its configuration details. Since the name of the first device's configuration is <code class="literal">ifcfg-enp0s3</code>, the new file is named <code class="literal">ifcfg-enp0s3:1</code> to create the first virtual adapter associated with that device. If you want to add more adapters (assign more IP addresses), repeat the steps using incrementing numbers, for example, <code class="literal">enp0s3:2</code>, <code class="literal">enp0s3:3</code>, and so on.</p><p>In the configuration file, we removed the <code class="literal">HWADDR</code> and <code class="literal">UUID</code> entries since they are not needed for a virtual adapter. Then we updated the <code class="literal">DEVICE</code> and <code class="literal">NAME</code> entries to give the adapter its own identify, and, of course, we updated the <code class="literal">IPADDR</code> entry to assign its IP address:</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_02_003.jpg"/><div class="caption"><p>Multiple IP addresses are bound to an Ethernet device via a virtual adapter</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>See also</h2></div></div></div><p>Refer to the following resources for more information on binding multiple addresses to the same Ethernet device:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create Multiple IP Addresses to One Single Network Interface (<a class="ulink" href="http://www.tecmint.com/create-multiple-ip-addresses-to-one-single-network-interface">http://www.tecmint.com/create-multiple-ip-addresses-to-one-single-network-interface</a>)</li><li class="listitem" style="list-style-type: disc">Assign Multiple IP Addresses To Single Network Interface Card On CentOS 7 (<a class="ulink" href="http://www.unixmen.com/linux-basics-assign-multiple-ip-addresses-single-network-interface-card-centos-7">http://www.unixmen.com/linux-basics-assign-multiple-ip-addresses-single-network-interface-card-centos-7</a>)</li><li class="listitem" style="list-style-type: disc">Adding Secondary IP Addresses (<a class="ulink" href="https://dbiers.me/adding-secondary-ip-addresses-centosrhel/">https://dbiers.me/adding-secondary-ip-addresses-centosrhel/</a>)</li></ul></div></div></div>
<div class="section" title="Bonding two Ethernet devices"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Bonding two Ethernet devices</h1></div></div></div><p>In this recipe, you'll learn how to combine multiple Ethernet devices as a single network device in a configuration known as channel bonding. Channel bonding allows us to bind multiple devices together so that they appear as a single interface to servers running on the CentOS system. Its purpose is to improve your system's overall network performance and provide redundancy if one of the network devices fails.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with at least two Ethernet devices. It assumes that your primary Ethernet device is <code class="literal">enp0s3</code>. If your device is named differently, substitute the name appropriately in the recipe's commands. You'll also need administrative privileges provided by logging in with the <code class="literal">root</code> account.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>How to do it...</h2></div></div></div><p>Follow these steps to bond two Ethernet devices:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">bind-utils</code> and <code class="literal">ethtool</code> packages:<pre class="programlisting">
<span class="strong"><strong>yum install bind-utils ethtool</strong></span>
</pre></li><li class="listitem">Create a new configuration file for the bonded interface:<pre class="programlisting">
<span class="strong"><strong>vi /etc/sysconfig/network-scripts/ifcfg-bond0</strong></span>
</pre></li><li class="listitem">Add the following lines to the file, substituting values for <code class="literal">IPADDR</code>, <code class="literal">NETMASK</code>, and <code class="literal">BROADCAST</code> that are appropriate for your network:<pre class="programlisting">
<span class="strong"><strong>BOOTPROTO="none"</strong></span>
<span class="strong"><strong>DEVICE="bond0"</strong></span>
<span class="strong"><strong>USERCTL="no"</strong></span>
<span class="strong"><strong>ONBOOT="yes"</strong></span>
<span class="strong"><strong>IPADDR="192.168.56.100"</strong></span>
<span class="strong"><strong>NETMASK="255.255.255.0"</strong></span>
<span class="strong"><strong>BROADCAST="192.168.56.255"</strong></span>
</pre></li><li class="listitem">Save your changes and close the configuration file.</li><li class="listitem">Open the configuration file of the first device you wish to bond:<pre class="programlisting">
<span class="strong"><strong>vi /etc/sysconfig/network-scripts/ifcfg-enp0s3</strong></span>
</pre></li><li class="listitem">Make sure <code class="literal">BOOTPROTO</code> is set to <code class="literal">none</code> and <code class="literal">ONBOOT</code> is set to <code class="literal">yes</code>. Then remove the <code class="literal">IPADDR</code>, <code class="literal">NETMASK</code>, and <code class="literal">BROADCAST</code> entries if they exist.</li><li class="listitem">Add the <code class="literal">SLAVE</code> and <code class="literal">MASTER</code> entries at the end of the file:<pre class="programlisting">
<span class="strong"><strong>SLAVE=yes</strong></span>
<span class="strong"><strong>MASTER=bond0</strong></span>
</pre></li><li class="listitem">Save your changes and close the configuration file.</li><li class="listitem">Repeat steps 5-8 for each additional device you want to bond.</li><li class="listitem">Create the configuration file used by the kernel to control how the bonding interface should behave:<pre class="programlisting">
<span class="strong"><strong>vi /etc/modprobe.d/bonding.conf</strong></span>
</pre></li><li class="listitem">Add the following lines to the file:<pre class="programlisting">
<span class="strong"><strong>alias bond0 bonding</strong></span>
<span class="strong"><strong>options bond0 mode=5 miimon=100</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Register the bonding module with the system's kernel:<pre class="programlisting">
<span class="strong"><strong>modprobe bonding</strong></span>
</pre></li><li class="listitem">Restart networking services for the changes to take effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart network.service</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How it works...</h2></div></div></div><p>We began by creating a configuration file for the bonding interface at <code class="literal">/etc/sysconfig/ network-scripts/ifcfg-bond0</code>. <code class="literal">BOOTPROTO</code> was set to <code class="literal">none</code> because the IP address is set statically, <code class="literal">DEVICE</code> gives a name to the interface, <code class="literal">USERCTL</code> was set to <code class="literal">no</code> to prohibit nonadministrative users from bringing the interface up and down, and <code class="literal">ONBOOT</code> was set to <code class="literal">yes</code> so that the interface will be automatically activated. We also gave the IP address information with <code class="literal">IPADDR</code>, <code class="literal">NETMASK</code>, and <code class="literal">BROADCAST</code>:</p><pre class="programlisting">
<span class="strong"><strong>BOOTPROTO="none"</strong></span>
<span class="strong"><strong>DEVICE="bond0"</strong></span>
<span class="strong"><strong>USERCTL="no"</strong></span>
<span class="strong"><strong>ONBOOT="yes"</strong></span>
<span class="strong"><strong>IPADDR="192.168.56.100"</strong></span>
<span class="strong"><strong>NETMASK="255.255.255.0"</strong></span>
<span class="strong"><strong>BROADCAST="192.168.56.255"</strong></span>
</pre><p>Then we updated the configuration files for each device we want to bond. We made sure <code class="literal">BOOTPROTO</code> was set to <code class="literal">none</code> and there was no address information since the device will no longer need its own IP address. Adding the <code class="literal">SLAVE</code> and <code class="literal">MASTER</code> entries, we identified the device as being bound to the new <code class="literal">bond0</code> device:</p><pre class="programlisting">
<span class="strong"><strong>SLAVE=yes</strong></span>
<span class="strong"><strong>MASTER=bond0</strong></span>
</pre><p>By performing these steps, we have created a new virtual device known as the bonding master that will use our real Ethernet devices as slaves. If one slave device fails, the other slave will still be active, providing redundancy.</p><p>Next, we created a new configuration file with our preferences for the kernel bonding module. The module is the kernel implementation of the bonding device and is responsible for coordinating the physical devices:</p><pre class="programlisting">
<span class="strong"><strong>alias bond0 bonding</strong></span>
<span class="strong"><strong>options bond0 miimon=100 mode=5</strong></span>
</pre><p><code class="literal">miimon=100</code> specifies that MII link monitoring will occur every <code class="literal">100</code> milliseconds to verify that the physical devices are active. <code class="literal">mode=5</code> represents a basic configuration that doesn't require any specific type of network switch support. It allows outgoing traffic to be distributed according to the current load on each slave device. There are five other modes which give you plenty of options in configuring how the devices work together, although you should be aware that some modes may require specific hardware support. Refer to <a class="ulink" href="http://wiki.centos.org/TipsAndTricks/BondingInterfaces">http://wiki.centos.org/TipsAndTricks/BondingInterfaces</a> for more information.</p><p>After making changes to the device's configuration files, we registered the bonding kernel module using <code class="literal">modprobe</code>:</p><pre class="programlisting">
<span class="strong"><strong>modprobe bonding</strong></span>
</pre><div class="mediaobject"><img alt="How it works..." src="graphics/image_02_004.jpg"/><div class="caption"><p>Two Ethernet devices are bound with the same IP addresses through the bonding adapter</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>See also</h2></div></div></div><p>For more information on bonding Ethernet devices CentOS, refer to the <span class="emphasis"><em>Configure Network Bonding</em></span> chapter in the RHEL 7 Networking Guide (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Networking_Guide/ch-Configure_Network_Bonding.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Networking_Guide/ch-Configure_Network_Bonding.html</a>).</p></div></div>
<div class="section" title="Configuring the network firewall with FirewallD"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Configuring the network firewall with FirewallD</h1></div></div></div><p>Now you'll learn how to configure the networking firewall using FirewallD. Starting with CentOS 7, FirewallD replaces iptables as the default firewall configuration utility (although iptables is still used behind the scenes by FirewallD). Based on which zones and services you configure, you can increase the network security of your server by controlling what traffic is allowed or disallowed to and from the system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. You'll also need administrative privileges provided by logging in with the <code class="literal">root</code> account.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>How to do it...</h2></div></div></div><p>This collection of commands will show you how to perform several basic configuration tasks using FirewallD's command-line client, <code class="literal">firewall-cmd</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To identify the currently active zones and which Ethernet devices are assigned to them, use the <code class="literal">--get-active-zones</code> flag:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --get-active-zones</strong></span>
</pre></li><li class="listitem">To temporarily change which zone a device is assigned to, use the <code class="literal">--zone</code> argument to specify the target zone and <code class="literal">--change-interface</code> to specify the Ethernet device:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --change-interface=enp0s3</strong></span>
</pre></li><li class="listitem">To permanently assign a device to a zone, add a <code class="literal">ZONE</code> entry to the device's configuration file. This change will not take effect until the service has been restarted:<pre class="programlisting">
<span class="strong"><strong>vi /etc/sysconfig/network-scripts/ifcfg-enp0s3</strong></span>
<span class="strong"><strong>ZONE="public"</strong></span>
</pre></li><li class="listitem">To identify the current configuration for a zone, use the <code class="literal">--zone</code> argument to specify the target zone and include <code class="literal">--list-all</code>:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --list-all</strong></span>
</pre></li><li class="listitem">To allow traffic through the firewall, use the <code class="literal">--add-service</code> or <code class="literal">--add-port</code> arguments:<p>Traffic for common services and protocols such as HTTP and SMTP can be allowed by name. The following adds the <code class="literal">http</code> service which opens port <code class="literal">80</code> (the port used by Apache and other HTTP servers):</p><pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-service=http</strong></span>
</pre><p>Traffic can always be allowed directly given the port and network protocol. The following opens port 8080 to TCP traffic, another port commonly used to serve web content:</p><pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-port=8080/tcp</strong></span>
</pre></li><li class="listitem">To disallow traffic that is currently allowed through the firewall, use the <code class="literal">--remove-service</code> or <code class="literal">--remove-port</code> arguments:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --remove-service=http</strong></span>
<span class="strong"><strong>firewall-cmd --zone=public --permanent --remove- port=8080/tcp</strong></span>
</pre></li><li class="listitem">To reload the firewall after making a change, use <code class="literal">--reload  </code>:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --reload</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>How it works...</h2></div></div></div><p>The default installation of FirewallD makes several preconfigured zones available, for example, <code class="literal">public</code>, <code class="literal">dmz</code>, <code class="literal">work</code>, <code class="literal">home</code>, and <code class="literal">trusted</code>. Different interfaces can be assigned to different zones and have different rules applied. To see all of the available zones and their configuration, we can invoke <code class="literal">firewall-cmd</code> with the <code class="literal">--list-all-zones</code> flag:</p><pre class="programlisting">
<span class="strong"><strong>firewall-cmd --list-all-zones</strong></span>
</pre><p>Most updates made to the firewall rules will take effect immediately but are temporary. We saw this earlier when we had to update the device's configuration file and restart the service to make a zone change permanent. This lets us experiment with different settings before finalizing the configuration. When configuring services and ports, the <code class="literal">--permanent</code> flag is used to make the changes permanent. If you don't provide the flag, the changes will take effect immediately but will only be temporary (not persist across a system reboot or restart of the firewall service):</p><pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --remove-service=http</strong></span>
</pre><p>Named services are preconfigured port settings that are common to a specific network service and are available for our convenience. For example, SSH traffic commonly consists of TCP packets destined for port 22, so the <code class="literal">ssh</code> service reflects this. In the examples, we used the <code class="literal">http</code> service, which configured port 80, the standard port used to serve web pages. While assigning the port directly has the same effect, services provide convenient, human-readable names and should be used when possible. To get a list of all available services, use <code class="literal">--get-services</code>:</p><pre class="programlisting">
<span class="strong"><strong>firewall-cmd --get-services</strong></span>
</pre><div class="mediaobject"><img alt="How it works..." src="graphics/image_02_005.jpg"/><div class="caption"><p>firewall-cmd is a command-line client for configuring firewall rules</p></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Named services are defined as XML files under <code class="literal">/usr/lib/firewalld/services</code>. If you want to allow access for some traffic but a service isn't defined, and you would prefer to perform the configuration using a service instead of the port and protocol for the sake of readability, you can create a new service file in this directory. Copy an existing file as your starting point and modify it to suit your needs.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>See also</h2></div></div></div><p>For more information on working with FirewallD, refer to the following resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">RHEL 7 Migration Planning Guide: Security and Access Control (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_%20Linux/7/html/Migration_Planning_Guide/sect-Red_Hat_Enterprise_%20Linux-Migration_Planning_Guide-Security_and_Access_%20Control.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_%20Linux/7/html/Migration_Planning_Guide/sect-Red_Hat_Enterprise_%20Linux-Migration_Planning_Guide-Security_and_Access_%20Control.html</a>)</li><li class="listitem" style="list-style-type: disc">FirewallD (<a class="ulink" href="http://fedoraproject.org/wiki/FirewallD">http://fedoraproject.org/wiki/FirewallD</a>)</li><li class="listitem" style="list-style-type: disc">How To Set Up a Firewall Using FirewallD on CentOS 7 (<a class="ulink" href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7">https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7</a>)</li></ul></div></div></div>
<div class="section" title="Configuring the network firewall using iptables"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Configuring the network firewall using iptables</h1></div></div></div><p>In this recipe, you'll learn how to replace FirewallD with the iptables service and perform basic firewall configurations. iptables was the default method for managing the firewall's settings in CentOS prior to version 7. Some administrators might prefer iptables because it's within their comfort level or maybe they have several older servers running in the data center and they want to maintain similarity as much as possible.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. You'll also need administrative privileges provided by logging in with the <code class="literal">root</code> account.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>How to do it...</h2></div></div></div><p>The following steps will allow you to replace FirewallD with the iptables service:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Stop the FirewallD service and disable it:<pre class="programlisting">
<span class="strong"><strong>systemctl stop firewalld</strong></span>
<span class="strong"><strong>systemctl mask firewalld</strong></span>
</pre></li><li class="listitem">Install the <code class="literal">iptables-services</code> package which contains the service:<pre class="programlisting">
<span class="strong"><strong>yum install iptables-services</strong></span>
</pre></li><li class="listitem">Start the service and register it so that it will start automatically when the system is booted:<pre class="programlisting">
<span class="strong"><strong>systemctl start iptables</strong></span>
<span class="strong"><strong>systemctl enable iptables</strong></span>
</pre></li></ol></div><p>The following collection of commands will show you how to perform several basic configuration tasks using <code class="literal">iptables</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the <code class="literal">-L</code> flag to print the current configuration. Add the <code class="literal">--line-numbers</code> flag to display each rule's ID number alongside it:<pre class="programlisting">
<span class="strong"><strong>iptables -L --line-numbers</strong></span>
</pre></li><li class="listitem" style="list-style-type: disc">Use the following command to allow TCP traffic on port 80 from the <code class="literal">enp0s3</code> interface through the firewall:<pre class="programlisting">
<span class="strong"><strong>iptables -A INPUT -i enp0s3 --dport 80 -p tcp -j ACCEPT</strong></span>
</pre></li><li class="listitem" style="list-style-type: disc">To remove the rule that allows TCP traffic on port 80, execute <code class="literal">iptables -L --line-numbers</code> to find the rule's ID and then use the following (replace <code class="literal">##</code> with the rule's ID):<pre class="programlisting">
<span class="strong"><strong>iptables -D INPUT ##</strong></span>
</pre></li><li class="listitem" style="list-style-type: disc">Reload iptables after making configuration changes for them to be in effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart iptables</strong></span>
</pre></li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>How it works...</h2></div></div></div><p>To replace FirewallD with the iptables service to manage the network firewall, we first stopped and disabled the FirewallD service; we don't want multiple firewall daemons running since it would lead to conflicts. FirewallD uses iptables behind the scenes so iptables is already installed, but the iptables service isn't. So, next we installed the <code class="literal">iptables-services</code> package:</p><pre class="programlisting">
<span class="strong"><strong>yum install iptables-services</strong></span>
</pre><p>We then saw how to perform basic configurations to allow and disallow traffic. For example, the recipe presented the command to add a rule that allows TCP traffic through port <code class="literal">80</code>:</p><pre class="programlisting">
<span class="strong"><strong>iptables -A INPUT -i enp0s3 --dport 80 -p tcp -j ACCEPT</strong></span>
</pre><p>The <code class="literal">-A</code> argument indicates that we wish to add a firewall rule and is followed by the rule type. Possible values are <code class="literal">INPUT</code>, <code class="literal">OUTPUT</code>, and <code class="literal">FORWARD</code>, which apply to incoming traffic, outgoing traffic, and traffic that is routed, respectively (if the system is configured as a router, for example). Since <code class="literal">INPUT</code> is specified, our rule applies to incoming traffic on port <code class="literal">80</code>.</p><p>The <code class="literal">-i</code> argument specifies the network interface that is monitored by the rule. In this case, the rule applies to <code class="literal">enp0s3</code>. Then, <code class="literal">--dport</code> specifies the traffic's destination port, in this case port <code class="literal">80</code>, and <code class="literal">-p</code> specifies the transport protocol, for example, either TCP or UDP.</p><p>The <code class="literal">-j</code> argument is the target action for <span class="strong"><strong>jump to</strong></span>. With iptables, rules are strung together to make chains of filtering logic. Imagine iptables checking traffic against each rule we've specified; if the first rule doesn't match, it goes on to check the next rule, and the next, until a match is found. When the matching rule is found, iptables stops checking and <span class="emphasis"><em>jumps </em></span>to the desired state. Possible states are <code class="literal">ACCEPT</code> to accept the traffic, <code class="literal">REJECT</code> to actively deny the connection, and <code class="literal">DROP</code> to silently ignore it.</p><p>We also saw how to display the rules that are currently defined using the <code class="literal">-L</code> flag and that using <code class="literal">--line-numbers</code> will display an identifier alongside each rule:</p><pre class="programlisting">
<span class="strong"><strong>iptables -L --line-numbers</strong></span>
</pre><div class="mediaobject"><img alt="How it works..." src="graphics/image_02_006.jpg"/><div class="caption"><p>iptables accepts or denies traffic based on the configured rules</p></div></div><p>Knowing a rule's identifier is convenient if we want to delete it. By providing <code class="literal">-D</code>, the rule type (<code class="literal">INPUT</code>, <code class="literal">OUTPUT</code>, or <code class="literal">FORWARD</code>), and the ID, we can succinctly remove a rule from the chain:</p><pre class="programlisting">
<span class="strong"><strong>iptables -D INPUT 6</strong></span>
</pre><p>Alternatively, you can respecify the entire rule while substituting <code class="literal">-A</code> with <code class="literal">-D</code> to delete it:</p><pre class="programlisting">
<span class="strong"><strong>iptables -D INPUT -i enp0s3 --dport 80 -p tcp -j ACCEPT</strong></span>
</pre></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>See also</h2></div></div></div><p>Refer to the following resources for more information on working with iptables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to Migrate from FirewallD to iptables on CentOS 7 (<a class="ulink" href="https://www.digitalocean.com/community/tutorials/how-to-migrate-from-firewalld-to-iptables-on-centos-7">https://www.digitalocean.com/community/tutorials/how-to-migrate-from-firewalld-to-iptables-on-centos-7</a>)</li><li class="listitem" style="list-style-type: disc">How to List and Delete iptables Firewall Rules (<a class="ulink" href="https://www.digitalocean.com/community/tutorials/how-to-list-and-delete-iptables-firewall-rules">https://www.digitalocean.com/community/tutorials/how-to-list-and-delete-iptables-firewall-rules</a>)</li><li class="listitem" style="list-style-type: disc">25 Most Frequently Used Linux iptables Rules (<a class="ulink" href="http://www.thegeekstuff.com/2011/06/iptables-rules-examples">http://www.thegeekstuff.com/2011/06/iptables-rules-examples</a>)</li><li class="listitem" style="list-style-type: disc">Drop versus reject (<a class="ulink" href="http://www.chiark.greenend.org.uk/~peterb/network/drop-vs-reject">http://www.chiark.greenend.org.uk/~peterb/network/drop-vs-reject</a>)</li></ul></div></div></div>
<div class="section" title="Installing a DHCP server"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Installing a DHCP server</h1></div></div></div><p>This recipe will show you how to set up your own DHCP server on CentOS. DHCP is used to assign IP addresses and other network configuration details on demand to a client. While a system configured with a static IP address will already know all the necessary networking details, a system configured to use DHCP broadcasts a request on the network and waits to receive a response from the DHCP server.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. You'll also need administrative privileges provided by logging in with the <code class="literal">root</code> account.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Only one DHCP server should be running on the network to prevent clients from receiving conflicting responses that can result in network instability. Many routers already have a DHCP service running on them, so check for this on your own network before proceeding.</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>How to do it...</h2></div></div></div><p>Follow these steps to set up a DHCP server:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">dhcp</code> package:<pre class="programlisting">
<span class="strong"><strong>yum install dhcp</strong></span>
</pre></li><li class="listitem">Copy the example configuration file provided by the package to serve as the starting point of your server's configuration:<pre class="programlisting">
<span class="strong"><strong>cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example  &#13;
       /etc/dhcp/dhcpd.conf</strong></span>
</pre></li><li class="listitem">Open the configuration file using your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/dhcp/dhcpd.conf</strong></span>
</pre></li><li class="listitem">Modify the configuration with values that make sense for your environment. In particular, you'll want to address the following options: <code class="literal">domain-name</code> and <code class="literal">domain-name-servers</code>, <code class="literal">subnet</code>, the <code class="literal">dynamic-bootp</code> range, <code class="literal">broadcast-address</code>, and <code class="literal">routers</code>. Here is an example configuration for a network of two subnets:<pre class="programlisting">
<span class="strong"><strong># option definitions common to all supported networks</strong></span>
<span class="strong"><strong>option domain-name localdomain;</strong></span>
<span class="strong"><strong>option domain-name-servers ns1.localdomain;</strong></span>
<span class="strong"><strong>default-lease-time 600;</strong></span>
<span class="strong"><strong>max-lease-time 7200;</strong></span>
<span class="strong"><strong># This DHCP server is the official DHCP server for the</strong></span>
<span class="strong"><strong># local network</strong></span>
<span class="strong"><strong>authoritative;</strong></span>
<span class="strong"><strong># No service will be given on this subnet, but declaring</strong></span>
<span class="strong"><strong># it helps the server to understand the network topology.</strong></span>
<span class="strong"><strong>subnet 192.168.56.0 netmask 255.255.255.0 {</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong># This is a basic subnet declaration</strong></span>
<span class="strong"><strong>subnet 192.168.56.0 netmask 255.255.255.128 {</strong></span>
<span class="strong"><strong>  range 192.168.56.110 192.168.56.120;</strong></span>
<span class="strong"><strong>     option domain-name-servers ns1.localdomain;</strong></span>
<span class="strong"><strong>     option domain-name "localdomain";</strong></span>
<span class="strong"><strong>     option routers 192.168.56.1;</strong></span>
<span class="strong"><strong>     option broadcast-address 192.168.56.127;</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong># This is the second subnet</strong></span>
<span class="strong"><strong>subnet 192.168.56.128 netmask 255.255.255.128 {</strong></span>
<span class="strong"><strong>     range 192.168.56.200 192.168.56.210;</strong></span>
<span class="strong"><strong>     option domain-name-servers ns2.sub.localdomain;</strong></span>
<span class="strong"><strong>     option domain-name "sub.localdomain";</strong></span>
<span class="strong"><strong>     option routers 192.168.56.129;</strong></span>
<span class="strong"><strong>     option broadcast-address 192.168.56.255;</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Start the <code class="literal">dhcp</code> service and enable it to start at system boot:<pre class="programlisting">
<span class="strong"><strong>systemctl start dhcpd</strong></span>
<span class="strong"><strong>systemctl enable dhcpd</strong></span>
</pre></li><li class="listitem">Open ports <code class="literal">67</code> and <code class="literal">68</code> in the system's firewall to allow traffic:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-service=dhcp</strong></span>
<span class="strong"><strong>firewall-cmd --reload</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>How it works...</h2></div></div></div><p>A system configured to use DHCP will broadcast a request and wait to receive a response from the DHCP server. The server's response lets the client know which IP address, netmask, gateway information, and so on to use on the network. DHCP-provisioned addresses are usually leased, which means that after a set amount of time they expire and the client needs to send another request. The DHCP server, in addition to handing out connection details, must keep track of the addresses that have already been leased so that a client doesn't receive an address that's already in use by another system.</p><p>We began by installing the <code class="literal">dhcpd</code> package, which contains the server and example configuration files. Copying the example configuration to use as a starting point for our own saves us from having to draft the entire configuration from scratch:</p><pre class="programlisting">
<span class="strong"><strong>cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example  /etc/dhcp/dhcpd.conf</strong></span>
</pre><p>In the configuration file, there are several places where you need to provide values that make sense for your network. The minimal configuration file provided as an illustration in the recipe reflects a network divided into two subnets. The first subnet is <code class="literal">192.168.56.0/25</code> and the second is <code class="literal">192.168.56.128/25</code>. Each subnet has its own declaration.</p><p>Examining the first subnet declaration, the subnet's ID is <code class="literal">192.168.56.0</code> with a netmask of <code class="literal">255.255.255.128</code>. The <code class="literal">range</code> option will restrict the DHCP server in assigning IP addresses in the range of <code class="literal">192.168.56.110</code> to <code class="literal">120</code> (the other addresses are still valid and are available for static assignment). Subsequent <code class="literal">option</code> entries provide the subnet's broadcast-address and gateway, and override the domain name and nameservers defined globally:</p><pre class="programlisting">
<span class="strong"><strong># This is a basic subnet declaration</strong></span>
<span class="strong"><strong>subnet 192.168.56.0 netmask 255.255.255.128 {</strong></span>
<span class="strong"><strong>  range 192.168.56.110 192.168.56.120;</strong></span>
<span class="strong"><strong>  option domain-name-servers ns1.localdomain;</strong></span>
<span class="strong"><strong>  option domain-name "localdomain";</strong></span>
<span class="strong"><strong>  option routers 192.168.56.1;</strong></span>
<span class="strong"><strong>  option broadcast-address 192.168.56.127;</strong></span>
<span class="strong"><strong>}</strong></span>
</pre><p>Configuring a DHCP server properly requires an understanding of computer networking. It is a complex topic and, as such, we can't discuss every option in detail. I advise you to read the manual page for <code class="literal">dhcpd.conf</code> for extra guidance. The page can be accessed using the <code class="literal">man</code> command:</p><pre class="programlisting">
<span class="strong"><strong>man 5 dhcpd.conf</strong></span>
</pre><div class="mediaobject"><img alt="How it works..." src="graphics/image_02_007.jpg"/><div class="caption"><p>The configuration file for dhcpd is documented in a manual page</p></div></div><p>Once the DHCP server was configured and running, we then needed to poke a hole in the firewall to allow requests and responses to flow freely. DHCP requests occur using UDP and ports <code class="literal">57</code> and <code class="literal">58</code> (you can allow them using the service defined for FirewallD):</p><pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-service=dhcp</strong></span>
<span class="strong"><strong>firewall-cmd --reload</strong></span>
</pre></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>See also</h2></div></div></div><p>For more information on setting up a DHCP server, refer to the following resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">dhcpd.conf</code> manual page (<code class="literal">man 5 dhcpd.conf</code>)</li><li class="listitem" style="list-style-type: disc">RHEL 7 Networking Guide: DHCP Servers (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Networking_Guide/ch-DHCP_Servers.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Networking_Guide/ch-DHCP_Servers.html</a>)</li><li class="listitem" style="list-style-type: disc">Quick Start: Setup CentOS 7 as a DHCP Server (<a class="ulink" href="http://www.yoyoclouds.com/2015/01/quick-start-setup-centos-7-as-dhcp.html">www.yoyoclouds.com/2015/01/quick-start-setup-centos-7-as-dhcp.html</a>)</li><li class="listitem" style="list-style-type: disc">Subnet Calculator (<a class="ulink" href="http://www.subnet-calculator.com/">www.subnet-calculator.com</a>)</li></ul></div></div></div>
<div class="section" title="Configuring an NFS server to share a filesystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Configuring an NFS server to share a filesystem</h1></div></div></div><p>Network File System (NFS) is a protocol for a distributed filesystem. That is, we can store files to a directory on a remote server and clients can mount the share. The remote directory will appear to the client as if it were local, although all data saved to it resides on the server. This recipe shows you how to configure NFS on a server and expose the storage as a network share. (The next recipe will show you how to configure NFS on a client.)</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. You'll also need administrative privileges provided by logging in with the <code class="literal">root</code> account.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>How to do it...</h2></div></div></div><p>Follow these steps to set up an NFS server:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">nfs-utils</code> and <code class="literal">libnfsidmap</code> packages:<pre class="programlisting">
<span class="strong"><strong>yum install nfs-utils libnfsidmap</strong></span>
</pre></li><li class="listitem">Create a globally accessible directory which will serve as the root of the file share:<pre class="programlisting">
<span class="strong"><strong>mkdir -m 777 /var/nfsshare</strong></span>
</pre></li><li class="listitem">Open /<code class="literal">etc/exports</code> and add the following entry to mark the directory for export by NFS. When done, save and close the file:<pre class="programlisting">
<span class="strong"><strong>/var/nfsshare 192.168.56.0/24(rw,sync,root_squash)</strong></span>
</pre><p>The <code class="literal">exports</code> file is very picky. Make sure there's no space between the network and the parenthesized options as well as no spaces around the commas that separate the options.</p></li><li class="listitem">Start the necessary services and register them so that they will start when the server boots:<pre class="programlisting">
<span class="strong"><strong>      systemctl start rpcbind nfs-server</strong></span>
<span class="strong"><strong>      systemctl enable rpcbind nfs-server&#13;
</strong></span>
</pre></li><li class="listitem">Open ports <code class="literal">111</code>, <code class="literal">2048</code>, and <code class="literal">2049</code> in the firewall to allow traffic through:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --permanent --zone public --add-service rpc-bind</strong></span>
<span class="strong"><strong>firewall-cmd --permanent --zone public --add-service mountd</strong></span>
<span class="strong"><strong>firewall-cmd --permanent --zone public --add-service nfs</strong></span>
<span class="strong"><strong>firewall-cmd --reload</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How it works...</h2></div></div></div><p>In this recipe, you learned how to set up a shared network directory using NFS. After installing the appropriate packages, we created the shared directory, registered it to be exported, and started the necessary system services.</p><p><code class="literal">/etc/exports</code> is the configuration file that manages which filesystems are exported and how. We added an entry that identified the directory we want to export, followed by which clients they are exported to and the options that govern how the export will be treated:</p><pre class="programlisting">
<span class="strong"><strong>/var/nfsshare 192.168.56.0/24(rw,sync,root_squash)</strong></span>
</pre><p>In the example, we make the share available to <code class="literal">192.168.56.0/24</code>, in other words, any host on the network. Alternatively, you can share the directory a single host or a range of hosts. An entry that shares the directory with a specific host looks like the following:</p><pre class="programlisting">
<span class="strong"><strong>/var/nfsshare 192.168.56.101(rw,sync,root_squash)</strong></span>
</pre><p>The <code class="literal">rw++</code> option allows both read and write access to the share. <code class="literal">sync</code> flushes any changes to a file immediately to disk. While writing to disk might make access to the file slower at times, the delay won't be noticeable unless your system is under high load, and it would seem like a fair trade-off for the safety that immediate flushes provide in the event of a crash.</p><p>NFS will effectively squash the root user's ownership when <code class="literal">root_squash</code> is provided by changing the owner to <code class="literal">nfsnobody</code>. This is a security measure that mitigates the risk of a root user on the client system attempting to write a file to the share with root ownership (otherwise a malicious user could store a file and mark it executable where it might be run with root privileges). If you want to squash the ownership of all files to <code class="literal">nfsnobdy</code>, you can use the <code class="literal">all_squash</code> option.</p><p>NFS relies on a few other services, which is why we also enabled rpcbind and opened firewall ports for rpcbind and mountd. NFS works on top of the Remote Procedure Call (RPC) protocol, and rcpind is responsible for mapping the RPC-based services to their ports. An incoming connection from a client first hits the rpcbind service, providing an RPC identifier. Rpcbind resolves the identifier to a particular service (NFS in this case) and redirects the client to the appropriate port. There, mountd handles the request to determine whether the requested share is exported and whether the client is allowed to access it.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>See also</h2></div></div></div><p>Refer to the following resources for more information about configuring an NFS server:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Network Filesystem (<a class="ulink" href="http://www.tldp.org/LDP/nag/node140.html">http://www.tldp.org/LDP/nag/node140.html</a>)</li><li class="listitem" style="list-style-type: disc">RHEL 7 Storage Administration Guide: NFS Server Configuration (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/nfs-serverconfig.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/nfs-serverconfig.html</a>)</li><li class="listitem" style="list-style-type: disc">How to setup NFS Server on CentOS 7 (<a class="ulink" href="http://www.itzgeek.com/how-tos/linux/centos-how-tos/how-to-setup-nfs-server-on-centos-7-rhel-7-fedora-22.html">http://www.itzgeek.com/how-tos/linux/centos-how-tos/how-to-setup-nfs-server-on-centos-7-rhel-7-fedora-22.html</a>)</li></ul></div></div></div>
<div class="section" title="Configuring an NFS client to use a shared filesystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Configuring an NFS client to use a shared filesystem</h1></div></div></div><p>This recipe continues where the previous recipe left off, showing you how to configure NFS on a client system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. It assumes that an NFS server has been configured as explained in the previous recipe. You'll also need administrative privileges provided by logging in with the <code class="literal">root</code> account.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>How to do it...</h2></div></div></div><p>Follow these steps to configure an NFS client:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">nfs-utils</code> and <code class="literal">libnfsidmap</code> packages:<pre class="programlisting">
<span class="strong"><strong>yum install nfs-utils libnfsidmap</strong></span>
</pre></li><li class="listitem">Create the directory which will serve as the mount point for the remote filesystem:<pre class="programlisting">
<span class="strong"><strong>mkdir /mnt/nfs</strong></span>
</pre></li><li class="listitem">Start the <code class="literal">rpcbind</code> service and register it so that it will start when the server boots:<pre class="programlisting">
<span class="strong"><strong>systemctl start rpcbind</strong></span>
<span class="strong"><strong>systemctl enable rpcbind</strong></span>
</pre></li><li class="listitem">Mount the NFS share to the mount point:<pre class="programlisting">
<span class="strong"><strong>mount -t nfs 192.168.56.100:/var/nfsshare /mnt/nfs</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec67"/>How it works...</h2></div></div></div><p>Like the server side, the client side of NFS relies on RPC. So, we started and enabled the rpcbind service. The <code class="literal">mount</code> command is then used to mount the remote share:</p><pre class="programlisting">
<span class="strong"><strong>mount -t nfs 192.168.56.100:/var/nfsshare /mnt/nfs</strong></span>
</pre><p>The <code class="literal">-t</code> argument indicates the share's filesystem type, which, of course is, <code class="literal">nfs</code>. The location of the remote share is also provided, the IP address of the server and the directory of the shared data separated by a colon. Finally, the mount target is given.</p><p>To manually unmount the share, the <code class="literal">umount</code> command is used with the mount point:</p><pre class="programlisting">
<span class="strong"><strong>umount /mnt/nfs</strong></span>
</pre><p>We can also configure the system to mount the NFS share automatically at boot time. Open <code class="literal">/etc/fstab</code> using your editor and add the following line:</p><pre class="programlisting">
<span class="strong"><strong>192.168.0.100:/var/nfsshare /mnt/nfs/var/nfsshare nfs defaults 0 0</strong></span>
</pre><p>The share will be automatically mounted when the system boots. Since <code class="literal">mount</code> can look up information in <code class="literal">/etc/fstab</code>, the invocation to mount the share manually becomes much simpler once it's registered in this manner. You can now mount the share manually by providing just the <code class="literal">mount</code>:</p><pre class="programlisting">
<span class="strong"><strong>mount /mnt/nfs</strong></span>
</pre></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec68"/>See also</h2></div></div></div><p>Refer to the following resources for more information about configuring an NFS client:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">mount</code> manual page (<code class="literal">man 8 mount</code>)</li><li class="listitem" style="list-style-type: disc">Setting up an NFS Client (<a class="ulink" href="http://www.tldp.org/HOWTO/NFS-HOWTO/client.html">http://www.tldp.org/HOWTO/NFS-HOWTO/client.html</a>)</li><li class="listitem" style="list-style-type: disc">RHEL 7 Storage Administration Guide: NFS Client Configuration (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/nfs-clientconfig.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/nfs-clientconfig.html</a>)</li><li class="listitem" style="list-style-type: disc">How to setup NFS Server on CentOS 7 (<a class="ulink" href="http://www.itzgeek.com/how-tos/linux/centos-how-tos/how-to-setup-nfs-server-on-centos-7-rhel-7-fedora-22.html">http://www.itzgeek.com/how-tos/linux/centos-how-tos/how-to-setup-nfs-server-on-centos-7-rhel-7-fedora-22.html</a>)</li></ul></div></div></div>
<div class="section" title="Serving Windows shares with Samba"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Serving Windows shares with Samba</h1></div></div></div><p>In this recipe, you will learn how to serve a Windows share from a CentOS system using Samba. Like NFS, a Windows share is a directory on a remote server that a client may access to store files. Samba is a server that understands the SMB protocol used by Windows so that it can export directories that a Windows client can mount.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec69"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. You'll also need administrative privileges provided by logging in with the <code class="literal">root</code> account.</p><p>The name of your Windows workgroup is needed to configure Samba properly. Before you begin, on your Windows system in your network, run <code class="literal">net config workstation</code> and record the <code class="literal">Workstation domain</code> value:</p><div class="mediaobject"><img alt="Getting ready" src="graphics/image_02_008.jpg"/><div class="caption"><p>net config workstation displays information about the Windows system's workgroup and domain</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec70"/>How to do it...</h2></div></div></div><p>Follow these steps to set up Samba to share directories with Windows systems:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">samba</code> package:<pre class="programlisting">
<span class="strong"><strong>yum install samba</strong></span>
</pre></li><li class="listitem">Create a dedicated group for Samba users:<pre class="programlisting">
<span class="strong"><strong>groupadd smbgroup</strong></span>
</pre></li><li class="listitem">Create the directory which will serve as the root of the file share. Set its group ownership to the new Samba users group:<pre class="programlisting">
<span class="strong"><strong>mkdir -m 770 /var/sambashare</strong></span>
<span class="strong"><strong>chgrp smbgroup /var/sambashare</strong></span>
</pre></li><li class="listitem">Open Samba's configuration file using your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/samba/smb.conf</strong></span>
</pre></li><li class="listitem">Update the <code class="literal">workgroup</code> parameter in the <code class="literal">[global]</code> section to match the Windows workgroup name. Feel free to review the other parameters in the configuration file as each is clearly documented with helpful comments:<pre class="programlisting">
<span class="strong"><strong>Workgroup = WORKGROUP</strong></span>
</pre></li><li class="listitem">At the end of the configuration file, add the following content:<pre class="programlisting">
<span class="strong"><strong>[share]</strong></span>
<span class="strong"><strong>path = /var/sambashare</strong></span>
<span class="strong"><strong>guest ok = no</strong></span>
<span class="strong"><strong>valid users = @smbgroup</strong></span>
<span class="strong"><strong>writable = yes&#13;
       create mask = 0755&#13;
</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Start the necessary services and register them so that they will start when the server boots:<pre class="programlisting">
<span class="strong"><strong>systemctl start smb nmb</strong></span>
<span class="strong"><strong>systemctl enable smb nmb</strong></span>
</pre></li><li class="listitem">Open ports <code class="literal">137</code>-<code class="literal">139</code> and <code class="literal">445</code> to allow the network traffic:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --permanent --zone public --add-service samba</strong></span>
<span class="strong"><strong>firewall-cmd --reload</strong></span>
</pre></li><li class="listitem">For each user who will connect to the share, assign them to the users group and register the password they will use:<pre class="programlisting">
<span class="strong"><strong>usermod -a -G smbgroup tboronczyk</strong></span>
<span class="strong"><strong>smbpasswd -a tboronczyk</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec71"/>How it works...</h2></div></div></div><p>In this recipe, you learned how to install and configure Samba to share a directory which a Windows client can access.</p><p>We started by doing a bit of research using the <code class="literal">net config</code> command to discover the Windows workgroup that our client belongs to. This is important because two systems on the same network but identifying themselves as part of different workgroups will not be able to communicate with one another. In the example, the workgroup's name was simply <code class="literal">WORKGROUP</code>.</p><p>Next, we installed the <code class="literal">samba</code> package and created a special group named <code class="literal">smbgroup</code>. We'll configure Samba so that any user account on the CentOS system will be able to access the share as long as it's assigned to the <code class="literal">smbgroup</code> group. Then we created the directory we would be sharing and set its group ownership to the new group.</p><p>We then edited Samba's configuration file, specifying the name of the Windows workgroup we looked up earlier for the <code class="literal">workgroup</code> value, and added a section to define the new share. We restricted the share so that only authenticated users belonging to <code class="literal">smbgroup</code> can access it by setting <code class="literal">guest ok</code> to <code class="literal">no</code> and <code class="literal">valid users</code> to <code class="literal">@smbgroup</code>. The <code class="literal">writable</code> entry allows users to create and update files on the share (otherwise the files would be read-only), and the <code class="literal">create mask</code> entry was used to specify the default file permissions that new files will be assigned in the Linux filesystem. The name <code class="literal">share</code> within brackets not only starts that configuration section but also serves as the name the share will be exported as (that is, <code class="literal">\\192.168.56.100\share</code>). You can export multiple shares as long as each name is distinct.</p><p>For each user account that will be used to connect to the share, we made sure it belonged to the <code class="literal">smbgroup</code> and used the <code class="literal">smbpasswd</code> command to specify a password the account would use to authenticate its SMB sessions. This password is maintained separately from the system's credentials and is valid only for authenticating to Samba, so a password different from the account's login password should be chosen.</p><p>Managing Samba users is done using <code class="literal">smbpasswd</code>. The <code class="literal">-a</code> flag adds an entry in Samba's account database, and we can delete a user from the database using the <code class="literal">-x</code> flag:</p><pre class="programlisting">
<span class="strong"><strong>smbpasswd -x tboronczyk</strong></span>
</pre><p>On the Windows system, you can use the <code class="literal">net use</code> command to map the remote share to a drive letter. Once it's mapped, the drive appears in the list of available drives:</p><pre class="programlisting">
<span class="strong"><strong>net use Z: \\192.168.56.100\share /USER:tboronczyk</strong></span>
</pre><p>Alternatively, you can map the drive through the Windows GUI, navigating through <code class="literal">Computer</code> | <code class="literal">Map network drive</code> | <code class="literal">Map network drive</code> in File Explorer while the <span class="strong"><strong>This PC</strong></span> bookmark is selected:</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_02_009.jpg"/><div class="caption"><p>The Samba share is available as a network mapped drive</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec72"/>See also</h2></div></div></div><p>For more information on working with Samba, refer to the following resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">smb.conf</code> manual page (<code class="literal">man 5 smb.conf</code>)</li><li class="listitem" style="list-style-type: disc">Using Samba on CentOS With Windows 7/8 (<a class="ulink" href="https://rcollier.me/2013/07/30/using-samba-on-centos-with-windows-78/">https://rcollier.me/2013/07/30/using-samba-on-centos-with-windows-78/</a>)</li><li class="listitem" style="list-style-type: disc">Install And Configure Samba Server In CentOS 7 (<a class="ulink" href="http://www.unixmen.com/install-configure-samba-server-centos-7">http://www.unixmen.com/install-configure-samba-server-centos-7</a>)</li></ul></div></div></div></body></html>