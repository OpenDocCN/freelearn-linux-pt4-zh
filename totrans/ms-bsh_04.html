<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Quoting and Escaping</h1>
                
            
            <article>
                
<p class="calibre1">Not everything is what it looks like. We must bear in mind that when dealing with operators and variables, sometimes we get unexpected results based on how we use them. A small example will make this advice more clear:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls</strong>
</pre>
<p class="calibre1">The directory has no content, so it is our starting point:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ touch *</strong>
</pre>
<p class="calibre1">We just created a file named star:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls *</strong><br class="title-page-name"/><strong class="calibre2">*</strong>
</pre>
<p class="calibre1">When we do <kbd class="calibre9">ls *</kbd> , we actually see it:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls</strong><br class="title-page-name"/><strong class="calibre2">*</strong>
</pre>
<p class="calibre1">We see this even if we issue a simple <kbd class="calibre9">ls</kbd> without any arguments:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ touch 1 2 3</strong>
</pre>
<p class="calibre1">Now, we created three empty files:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls *</strong><br class="title-page-name"/><strong class="calibre2">* 1 2 3</strong>
</pre>
<p class="calibre1">Well, we tried to list only the star file, but we saw all of them. How to show only the star named file? We can do so as follows:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls "*"</strong><br class="title-page-name"/><strong class="calibre2">*</strong>
</pre>
<p class="calibre1">So, now that we have quoted the star symbol, we can see the file named after it. Why is this? Well, as I said, there are some characters that have a special meaning for the shell, such as the star, which is expanded by the shell into <em class="calibre20">ALL</em> characters. This is why if we issue <kbd class="calibre9">ls *</kbd>, we will see all the files held into the directory, because we are asking to show any file whose name is made up of any characters or numbers (except for filenames starting with a dot). Quoting the star symbol prevents the shell from actually interpreting the special character ,and so take it literally, we want to see the file whose name is simply <kbd class="calibre9">*</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Special characters</h1>
                
            
            <article>
                
<p class="calibre1">We have already used some of these special characters in the previous chapters by giving a hint of what was their meaning. Now, we will be closely looking at each of them and examining their special value for the shell and how they can be used in our scripts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The hash character (#)</h1>
                
            
            <article>
                
<p class="calibre1">This represents a comment. Each line beginning with <kbd class="calibre9">#</kbd> is taken as a comment and not interpreted by the shell. Let's have a look at the following script:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/># I am a comment at the beginning of a line'<br class="title-page-name"/>ls # I am a comment after a command<br class="title-page-name"/>#I am a comment preceeding a command and so it is not interpreted ps
</pre>
<p class="calibre1">The first pound sign is not really a comment, but it is associated to the following exclamation mark and is interpreted as a <em class="calibre20">sha-bang</em>. The second line shows a typical comment line, the third a comment after a command, the fourth line is still a comment, and the <kbd class="calibre9">ps</kbd> command is not interpreted and executed. Let's run it:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./comment.sh</strong><br class="title-page-name"/><strong class="calibre2">* 1 2 3 comment.sh</strong>
</pre>
<p class="calibre1">We see the output of the <kbd class="calibre9">ls</kbd> command, but not of <kbd class="calibre9">ps</kbd> as expected. Also notice that the comments are not printed to <kbd class="calibre9">stdout</kbd>. Since we use it inside the code to comment, it is not something to be shown at runtime. Let's add a couple of lines:</p>
<pre class="codepackt">
<strong class="calibre2">echo # I am a comment but you cannot see me</strong><br class="title-page-name"/><strong class="calibre2">echo \# I am a comment but you can see me</strong>
</pre>
<p class="calibre1">Run the script again:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./comment.sh</strong><br class="title-page-name"/><strong class="calibre2">* 1 2 3 comment.sh</strong><br class="title-page-name"/><strong class="calibre2"># I am a comment but you can see me</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$</strong>
</pre>
<p class="calibre1">As you can see, the first <kbd class="calibre9">echo</kbd> command creates a blank line and the comment is not taken in account; so, it is as if we had no argument to the <kbd class="calibre9">echo</kbd> command. The second comment is even more interesting. We escaped the pound sign placing a back slash in front of it. So, being escaped the pound sign is just a pound sign followed by a bunch of characters, and all together, they get printed to <kbd class="calibre9">stdout</kbd> as the <kbd class="calibre9">echo</kbd> command arguments. So, be careful since you will find the pound sign used with different meaning, as we already saw in the paragraphs dealing with a parameter substitution and a pattern matching on variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The semicolon character (;)</h1>
                
            
            <article>
                
<p class="calibre1">The semicolon is a command separator, and it allows us to chain one command after the other, just as we did for the if construct. For instance, look at this:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo TEST &gt; test.txt ; cat test.txt</strong><br class="title-page-name"/><strong class="calibre2">TEST</strong>
</pre>
<p class="calibre1">We created a <kbd class="calibre9">test.txt</kbd> file, and we cat its content right after it. Be careful with the find <kbd class="calibre9">-exec</kbd> command, as the semicolon must be escaped. The <kbd class="calibre9">-exec</kbd> option allows us to perform a command on the files provided by find:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo TEST &gt; test_1.txt ; ls test_1.txt ; find -name test_1.txt <br class="title-page-name"/>-exec rm {} <br class="title-page-name"/>\; ; ls</strong><br class="title-page-name"/><strong class="calibre2">test_1.txt</strong><br class="title-page-name"/><strong class="calibre2">* 1 2 3 comment.sh test.txt</strong>
</pre>
<p class="calibre1">With the find <kbd class="calibre9">-exec</kbd> object, the semicolon is the command sequence terminator and not a command separator, so it must be escaped in order to avoid the shell to interpret it as a special character. After the first escaped semicolon, we then added a second semicolon to separate the <kbd class="calibre9">find</kbd> command from the subsequent <kbd class="calibre9">ls</kbd>. Notice that<kbd class="calibre9">{}</kbd> in the command is substituted by <kbd class="calibre9">find</kbd> with the full path to the file found.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The double semicolon character (;;)</h1>
                
            
            <article>
                
<p class="calibre1">The double semicolon is a case construct option terminator. We will see the case constructor later in this book, but as of now, just think of it as a sequence of if/then/else, which is widely adopted to create a user menu:</p>
<pre class="codepackt">
#!/bin/sh<br class="title-page-name"/>clear<br class="title-page-name"/>echo "Please choose between these options:"<br class="title-page-name"/>echo "ls for listing files"<br class="title-page-name"/>echo "procs for listing processes"<br class="title-page-name"/>echo "x for exit"<br class="title-page-name"/>read input<br class="title-page-name"/>case "$input" in<br class="title-page-name"/> "ls" | "LS" )<br class="title-page-name"/>   echo "Listing files:"<br class="title-page-name"/>   ls<br class="title-page-name"/>   exit 0<br class="title-page-name"/>   ;;<br class="title-page-name"/>"procs" | "PROCS")<br class="title-page-name"/>   echo "Listing processes:"<br class="title-page-name"/>   ps<br class="title-page-name"/>   exit 0<br class="title-page-name"/>   ;;<br class="title-page-name"/>   "x" | "X" )<br class="title-page-name"/>   echo "exiting"<br class="title-page-name"/>   exit 0<br class="title-page-name"/>   ;;<br class="title-page-name"/>   * )<br class="title-page-name"/>   # Default catchall option<br class="title-page-name"/>   echo "exiting"<br class="title-page-name"/>   exit 0<br class="title-page-name"/>   ;;<br class="title-page-name"/> esac
</pre>
<p class="calibre1">As you can see, the case construct starts with the case keyword and is closed by the reverse of it: <kbd class="calibre9">esac</kbd>. What it does is try to verify each condition into the different options that we defined. Each option is separated from the other by the double colon. The last option is usually a star, which means <em class="calibre20">whatever you type,</em> and it is a catchall option just in case any other option did not trap what the user typed in. Let's have a look:</p>
<pre class="codepackt">
<strong class="calibre2">Please choose between these options:</strong><br class="title-page-name"/><strong class="calibre2">ls for listing files</strong><br class="title-page-name"/><strong class="calibre2">procs for listing processes</strong><br class="title-page-name"/><strong class="calibre2">x for exit</strong><br class="title-page-name"/><strong class="calibre2">ls</strong><br class="title-page-name"/><strong class="calibre2">Listing files:</strong><br class="title-page-name"/><strong class="calibre2">* 1 2 3 comment.sh menu.sh test.txt</strong>
</pre>
<p class="calibre1">Use this for the default option:</p>
<pre class="codepackt">
<strong class="calibre2">Please choose between these options:</strong><br class="title-page-name"/><strong class="calibre2">ls for listing files</strong><br class="title-page-name"/><strong class="calibre2">procs for listing processes</strong><br class="title-page-name"/><strong class="calibre2">x for exit</strong><br class="title-page-name"/><strong class="calibre2">aahadie</strong><br class="title-page-name"/><strong class="calibre2">exiting</strong>
</pre>
<p class="calibre1">Have you noticed that the screen has been cleared out of any content? This is thanks to the <kbd class="calibre9">clear</kbd> command that we wrote at the beginning of the file, as it clears out the screen so that whatever you write to the customer, it will appear at the top of the screen without any other content distracting the user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The case terminator (;;&amp;) and (;&amp;))</h1>
                
            
            <article>
                
<p class="calibre1">These are enhanced case terminators too, but they are only available in Bash from a version higher than 4.0. Here are the differences between the three operators:</p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre9">;;</kbd>: If the condition is matched, the other options will not be tested</li>
<li class="calibre13"><kbd class="calibre9">;&amp;</kbd>: This makes the execution continue with the commands associated to the next condition</li>
<li class="calibre13"><kbd class="calibre9">;;&amp;</kbd>: This makes the shell check the option and execute the associated commands if the condition is matched</li>
</ul>
<p class="calibre1">If no matches are found, the exit status is <kbd class="calibre9">0</kbd>; otherwise, the exit status is the one from the last command executed. We will see more about these terminators and the case constructor in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The dot character (.)</h1>
                
            
            <article>
                
<p class="calibre1">The dot command is a shell builtin, and it has the same function of the source; when executed into the shell, it executes a file. And if it is used inside a script, it loads the referenced file content:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ comment.sh</strong><br class="title-page-name"/><strong class="calibre2">bash: comment.sh: command not found</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ . comment.sh</strong><br class="title-page-name"/><strong class="calibre2">* 1 2 3 comment.sh menu.sh test.txt<br class="title-page-name"/></strong><strong class="calibre2"># I am a comment but you can see me</strong>
</pre>
<p class="calibre1">As we can see from this example, the first try was not successful because <kbd class="calibre9">comment.sh</kbd> is not in the search path; but the second time, we were successful since the dot command executed the script. Now, let's see how to include some code from an external file into a script. Let's start writing the external file that we will source from the following code:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat external-data</strong><br class="title-page-name"/><strong class="calibre2">var1="Hello"</strong><br class="title-page-name"/><strong class="calibre2">var2="Nice to see you"</strong>
</pre>
<p class="calibre1">Now, we have to write the script that will source from this file:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>echo "We now source external-data file and get the variables content"<br class="title-page-name"/>echo ". external-data"<br class="title-page-name"/> . external-data<br class="title-page-name"/>echo "Now that we sourced the external file, we have access to variables content"<br class="title-page-name"/>echo "The content of var1 is: ${var1}"<br class="title-page-name"/>echo "The content of var2 is: ${var2}"
</pre>
<p class="calibre1">Now, it is just a matter of having a look at what happens:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./sourcing.sh<br class="title-page-name"/></strong><strong class="calibre2">We now source external-data file and get the variables content</strong><br class="title-page-name"/><strong class="calibre2">. external-data</strong><br class="title-page-name"/><strong class="calibre2">Now that we sourced the external file, we have access to variables content</strong><br class="title-page-name"/><strong class="calibre2">The content of var1 is: Hello</strong><br class="title-page-name"/><strong class="calibre2">The content of var2 is: Nice to see you</strong>
</pre>
<p class="calibre1">So, as we can see, we actually sourced the variables content from the external-data file. But there is more since if we source an external script, its code gets executed and can also return values to the main script:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>echo "Hello from the inner script, can you give me a number?"<br class="title-page-name"/>read number<br class="title-page-name"/>case "$number" in<br class="title-page-name"/>        [[:digit:]] )<br class="title-page-name"/>          echo "$number is a digit!"<br class="title-page-name"/>          exit 0<br class="title-page-name"/>          ;;<br class="title-page-name"/>          * )<br class="title-page-name"/>          # Default catchall option<br class="title-page-name"/>          echo "Sorry, $number is not a digit"<br class="title-page-name"/>          exit 1<br class="title-page-name"/>          ;;<br class="title-page-name"/>esac
</pre>
<p class="calibre1">This is a simple menu that asks the user for a digit and then checks it; do not worry, as we will see how to match digits and characters later on:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./external-script.sh</strong><br class="title-page-name"/><strong class="calibre2">Hello from the inner script, can you give me a number?</strong><br class="title-page-name"/><strong class="calibre2">1</strong><br class="title-page-name"/><strong class="calibre2">1 is a digit!</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ ./external-script.sh</strong><br class="title-page-name"/><strong class="calibre2">Hello from the inner script, can you give me a number?</strong><br class="title-page-name"/><strong class="calibre2">d</strong><br class="title-page-name"/><strong class="calibre2">Sorry, d is not a digit</strong>
</pre>
<p class="calibre1">There is a quick way to match characters  by using a POSIX character class:</p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre9">[:alnum:]</kbd> matches both alphabetic and numeric characters</li>
<li class="calibre13"><kbd class="calibre9">[:alpha:]</kbd> matches only alphabetic characters</li>
<li class="calibre13"><kbd class="calibre9">[:blank:]</kbd> matches only a tab or a space</li>
<li class="calibre13"><kbd class="calibre9">[:cntrl:]</kbd> matches any control characters</li>
<li class="calibre13"><kbd class="calibre9">[:digit:]</kbd> matches only digits between 0 to 9</li>
<li class="calibre13"><kbd class="calibre9">[:graph:]</kbd> matches any the character that has a value between 33 and 126 in the ASCII table</li>
<li class="calibre13"><kbd class="calibre9">[:lower:]</kbd> matches alphabetic characters in lower case</li>
<li class="calibre13"><kbd class="calibre9">[:print:]</kbd> matches the graph, but also matches the range is from 32 to 126, including the space characters too</li>
<li class="calibre13"><kbd class="calibre9">[:space:]</kbd> matches the space and horizontal tabs</li>
<li class="calibre13"><kbd class="calibre9">[:upper:]</kbd> matches alphabetic characters in upper case</li>
<li class="calibre13"><kbd class="calibre9">[:xdigit:]</kbd> matches digits, but in a hexadecimal notation</li>
</ul>
<p class="calibre1">Now, let's do something nicer and modify the previous external script in the following way:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>echo "Hello from the inner script, can you give me an integer between 0 and 9?"<br class="title-page-name"/>read number<br class="title-page-name"/>case "$number" in<br class="title-page-name"/>        [[:digit:]] )<br class="title-page-name"/>          return 0<br class="title-page-name"/>          ;;<br class="title-page-name"/>          * )<br class="title-page-name"/>          # Default catchall option<br class="title-page-name"/>          return 1<br class="title-page-name"/>          ;;<br class="title-page-name"/>esac
</pre>
<p class="calibre1">Instead of exiting, we are returning a value to the caller script so that the execution once ended on the child script will continue on the main one. Now a new main script is here:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>echo "We now source external-script-return.sh file and ask the customer for a digit between 0 and 9"<br class="title-page-name"/>echo ". external-script-return.sh"<br class="title-page-name"/>. external-script-return.sh<br class="title-page-name"/>return=$?<br class="title-page-name"/>if [ "$return" -eq 0 ]<br class="title-page-name"/>        then<br class="title-page-name"/>        echo "The value returned is a digit between 0 and 9, the exit code was $return"<br class="title-page-name"/>        else<br class="title-page-name"/>        echo "The value returned is not a digit between 0 and 9, the exit code was $return"<br class="title-page-name"/>fi
</pre>
<p class="calibre1">Now let's see a couple of tests:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./sourcing-return.sh</strong>
</pre>
<p class="calibre1">We will now source the <kbd class="calibre9">external-script-return.sh</kbd> file and ask the customer for a digit between <kbd class="calibre9">0</kbd> to <kbd class="calibre9">9</kbd>:</p>
<pre class="codepackt">
<strong class="calibre2">. external-script-return.sh</strong><br class="title-page-name"/><strong class="calibre2"> Hello from the inner script, can you give me an integer between 0 and 9?</strong><br class="title-page-name"/><strong class="calibre2">6</strong><br class="title-page-name"/><strong class="calibre2">The value returned is a digit between 0 and 9, the exit code was 0</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ ./sourcing-return.sh</strong>
</pre>
<p class="calibre1">We will now source the <kbd class="calibre9">external-script-return.sh</kbd> file and ask the customer for a digit between <kbd class="calibre9">0</kbd> to <kbd class="calibre9">9</kbd>:</p>
<pre class="codepackt">
<strong class="calibre2">. external-script-return.sh</strong><br class="title-page-name"/><strong class="calibre2">Hello from the inner script, can you give me an integer between 0 and 9?</strong><br class="title-page-name"/><strong class="calibre2">25</strong><br class="title-page-name"/><strong class="calibre2">The value returned is not a digit between 0 and 9, the exit code was 1</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ ./sourcing-return.sh</strong>
</pre>
<p class="calibre1">We will now source the <kbd class="calibre9">external-script-return.sh</kbd> file and ask the customer for a digit between <kbd class="calibre9">0</kbd> to <kbd class="calibre9">9</kbd>:</p>
<pre class="codepackt">
<strong class="calibre2">. external-script-return.sh</strong><br class="title-page-name"/><strong class="calibre2">Hello from the inner script, can you give me an integer between 0 and 9?</strong><br class="title-page-name"/><strong class="calibre2">asry</strong><br class="title-page-name"/><strong class="calibre2">The value returned is not a digit between 0 and 9, the exit code was 1</strong>
</pre>
<p class="calibre1">We used the builtin command return to stop the execution of the inner script once a condition is met and returned an exit status to the parent script. Usually, we can use return without any exit code, and it will serve back the exit status of the last command executed, or we can use an integer between <kbd class="calibre9">0</kbd> to <kbd class="calibre9">255</kbd>. Would it not be nice to have in return something different from a simple number? Well, you can't. Actually you can with a little trick. Let's modify the previous child script:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>echo "Hello from the inner script, can you give me an integer between 0 and 9?"<br class="title-page-name"/>read number<br class="title-page-name"/>case "$number" in<br class="title-page-name"/>        [[:digit:]] )<br class="title-page-name"/>          echo "This is the integer the user gave us: $number"<br class="title-page-name"/>          exit<br class="title-page-name"/>          ;;<br class="title-page-name"/>          * )<br class="title-page-name"/>          # Default catchall option<br class="title-page-name"/>          echo "The user did not give us an integer between 0 and 9 but this: $number"<br class="title-page-name"/>          exit<br class="title-page-name"/>          ;;<br class="title-page-name"/>esac
</pre>
<p class="calibre1">Now let's call the script:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>echo "We now source external-script-return-whatever.sh file and ask the customer for a digit between 0 and 9"<br class="title-page-name"/>echo ". external-script-return-whatever.sh"<br class="title-page-name"/>returning=$(. external-script-return-whatever.sh)<br class="title-page-name"/>echo "The value of returning is: $returning"
</pre>
<p class="calibre1">What did we do? We got rid of <kbd class="calibre9">return</kbd> and echoed on the standard output of our message. Then, from the calling script, we used a command substitution. What does this do? It simply reassigns the output of a command; in our case, we reassigned the output of the sourced script to the variable returning. You can do a command substitution using <kbd class="calibre9">...</kbd>: the classic backtics, which has been superseded by <kbd class="calibre9">$(...)</kbd>. So, use the latter form, since it is the most actual and also allows you to nest multiple command substitutions. Let's give it a try:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./sourcing-return-whatever.sh</strong><br class="title-page-name"/><strong class="calibre2">We now source external-script-return-whatever.sh file and ask the customer for a digit between 0 and 9</strong><br class="title-page-name"/><strong class="calibre2">. external-script-return-whatever.sh</strong><br class="title-page-name"/><strong class="calibre2">3</strong><br class="title-page-name"/><strong class="calibre2">The value of returning is: Hello from the inner script, can you give me an integer between 0 and 9?</strong><br class="title-page-name"/><strong class="calibre2">This is the integer the user gave us: 3</strong>
</pre>
<p class="calibre1">Oh well, nice! It gave us the echoed string from the first case option, but unfortunately, we also trapped the message printed to the user asking to input a integer. Well, how do you get rid of it? You should already know this; just keep in mind that we are getting everything printed to <kbd class="calibre9">stdout</kbd>, and so we will need a tiny alteration to the inner script:</p>
<pre class="codepackt">
<strong class="calibre2">&gt;&amp;2 echo "Hello from the inner script, can you give me an integer between 0 and 9?"</strong><br class="title-page-name"/><strong class="calibre2">read -s number</strong>
</pre>
<p class="calibre1">We need one modification to the calling script so that the last line will be this:</p>
<pre class="codepackt">
<strong class="calibre2">echo "$returning"</strong>
</pre>
<p class="calibre1">It is time to test our modifications:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./sourcing-return-whatever.sh</strong><br class="title-page-name"/><strong class="calibre2">We now source external-script-return-whatever.sh file and ask the customer for a digit between 0 and 9</strong><br class="title-page-name"/><strong class="calibre2">. external-script-return-whatever.sh</strong><br class="title-page-name"/><strong class="calibre2">Hello from the inner script, can you give me an integer between 0 and 9?</strong><br class="title-page-name"/><strong class="calibre2">This is the integer the user gave us: 4</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ ./sourcing-return-whatever.sh</strong><br class="title-page-name"/><strong class="calibre2">We now source external-script-return-whatever.sh file and ask the customer for a digit between 0 and 9</strong><br class="title-page-name"/><strong class="calibre2">. external-script-return-whatever.sh</strong><br class="title-page-name"/><strong class="calibre2">Hello from the inner script, can you give me an integer between 0 and 9?</strong><br class="title-page-name"/><strong class="calibre2">The user did not give us an integer between 0 and 9 but this: dirthe</strong>
</pre>
<p class="calibre1">What did we do? First, we redirected <kbd class="calibre9">stdout</kbd> to <kbd class="calibre9">stderr</kbd>; and both are attached to the terminal, so the user will still see the question asked by the script, but the sentence will not be caught by the command substitution since this latter works only with <kbd class="calibre9">stdout</kbd>. Then, we silenced the read builtin so that it will not <kbd class="calibre9">echo</kbd> to the <kbd class="calibre9">stdout</kbd> and the value typed by the customer; and at the end, we just printed the returned value without any comments. This gave us a neat output. This trick can be used when you have to return a value from a function to the main script body, and you do not want to be limited by the 0-255 value restriction of the returned builtin. A file can be sourced passing by it positional parameters with the following syntax:</p>
<pre class="codepackt">
<strong class="calibre2">. file arg1 arg2 argn</strong>
</pre>
<p class="calibre1">The sourced script will access the parameters value using <kbd class="calibre9">$1</kbd>, <kbd class="calibre9">$2</kbd>, and <kbd class="calibre9">$n</kbd>. From the 10th parameter, the value must be accessed bracketing the <kbd class="calibre9">${15}</kbd> variable. Before ending the description of the dot character, we should recall what we said in the previous chapter: a single dot is a link to the current directory. It is also widely used in filenames to specifically define file extensions. Finally, in the regular expressions context, the dot matches any single character except for the new line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The double quotes ("...")</h1>
                
            
            <article>
                
<p class="calibre1">Double quotes are also known as partial or weak quoting, which avoid the interpretation of most of the special characters by the shell. We will see more about them in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The single quotes ('...')</h1>
                
            
            <article>
                
<p class="calibre1">The single quote, also known as a full or strong quote, avoids the interpretation of all special characters by the shell. More information on it is mentioned in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The comma character (,)</h1>
                
            
            <article>
                
<p class="calibre1">The comma operator chains together arithmetic operations or strings:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=$((5 + 10)) ; echo $x</strong><br class="title-page-name"/><strong class="calibre2">15</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ x=$((5 + 10, 6-1)) ; echo $x</strong><br class="title-page-name"/><strong class="calibre2">5</strong><br class="title-page-name"/><strong class="calibre2">zarrelli@moveaway:~$ x=$((y=25, 6-1)) ; echo "The value of x is $x and the value of y is $y"</strong><br class="title-page-name"/><strong class="calibre2">The value of x is 5 and the value of y is 25</strong>
</pre>
<p class="calibre1">What we can see here is that even though the operations are concatenated, only the value of the last one is returned. So, <kbd class="calibre9">x</kbd> is instanced with the value of just <kbd class="calibre9">6-1</kbd>. But, as I mentioned before, we can use the comma character to concatenate strings:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli@moveaway:~$ for i in {,1}1 ; do echo $i ; done</strong><br class="title-page-name"/><strong class="calibre2">1</strong><br class="title-page-name"/><strong class="calibre2">11</strong><br class="title-page-name"/><strong class="calibre2">zarrelli@moveaway:~$ for i in {,1}2 ; do echo $i ; done</strong><br class="title-page-name"/><strong class="calibre2">2</strong><br class="title-page-name"/><strong class="calibre2">12</strong><br class="title-page-name"/><strong class="calibre2">zarrelli@moveaway:~$ for i in {,1,}2 ; do echo $i ; done</strong><br class="title-page-name"/><strong class="calibre2">2</strong><br class="title-page-name"/><strong class="calibre2">12</strong><br class="title-page-name"/><strong class="calibre2">2</strong><br class="title-page-name"/><strong class="calibre2">zarrelli@moveaway:~$ for i in {,1,,}2 ; do echo $i ; done</strong><br class="title-page-name"/><strong class="calibre2">2</strong><br class="title-page-name"/><strong class="calibre2">12</strong><br class="title-page-name"/><strong class="calibre2">2</strong><br class="title-page-name"/><strong class="calibre2">2</strong><br class="title-page-name"/><strong class="calibre2">zarrelli@moveaway:~$ for i in {,1,3,}2 ; do echo $i ; done</strong><br class="title-page-name"/><strong class="calibre2">2</strong><br class="title-page-name"/><strong class="calibre2">12</strong><br class="title-page-name"/><strong class="calibre2">32</strong><br class="title-page-name"/><strong class="calibre2">2</strong>
</pre>
<p class="calibre1">As you can see, you can concatenate a list of values to create new strings and do some funny stuff in the process:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ for i in {"Hello ","Maybe hello ","Ok, I decided, hello "}world ; do echo $i ; done</strong><br class="title-page-name"/><strong class="calibre2">Hello world</strong><br class="title-page-name"/><strong class="calibre2">Maybe hello world</strong><br class="title-page-name"/><strong class="calibre2">Ok, I decided, hello world</strong>
</pre>
<p class="calibre1">This is funny, but it is up to you how to use it. You can cycle in a for statement and construct a list of paths to examine; for instance, the applications of a string concatenation is really up to your creativity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The ,, and , () case modificators</h1>
                
            
            <article>
                
<p class="calibre1">This is new in Bash 4.0, and it forces a lower case conversion in the parameter substitution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The ^^ and ^ () case modificators</h1>
                
            
            <article>
                
<p class="calibre1">This is new in bash 4.0, it forces upper case conversion in the parameter substitution:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat parm-sub.sh</strong><br class="title-page-name"/><strong class="calibre2"> #!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">echo "Hello, can you give me a string of characters?"</strong><br class="title-page-name"/><strong class="calibre2">read my_string</strong><br class="title-page-name"/><strong class="calibre2">if [[ "$my_string" =~ ^[[:alpha:]]*$ ]]</strong><br class="title-page-name"/><strong class="calibre2">    then</strong><br class="title-page-name"/><strong class="calibre2">        echo "Printing the variable \$my_string as \${my_string}: ${my_string}" "| No modifications"</strong><br class="title-page-name"/><strong class="calibre2">        echo "Printing the variable \$my_string as \${my_string^}: ${my_string^}" "| The first char is uppercase"</strong><br class="title-page-name"/><strong class="calibre2">        echo "Printing the variable \$my_string as \${my_string^^}: ${my_string^^}" "| All chars are uppercase"</strong><br class="title-page-name"/><strong class="calibre2">        echo "Printing the variable \$my_string as \${my_string,}: ${my_string,}" "| The first char is lowercase"</strong><br class="title-page-name"/><strong class="calibre2">        echo "Printing the variable \$my_string as \${my_string,,}: ${my_string,,}" "| All chars are lowercase"</strong><br class="title-page-name"/><strong class="calibre2">    else</strong><br class="title-page-name"/><strong class="calibre2">        echo "Please, input characters only"</strong><br class="title-page-name"/><strong class="calibre2">fi</strong>
</pre>
<p class="calibre1">Now, we will do a couple of tests, starting with a lowercase string:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./parm-sub.sh</strong><br class="title-page-name"/><strong class="calibre2">Hello, can you give me a string of characters?</strong><br class="title-page-name"/><strong class="calibre2">sdoijweoi</strong><br class="title-page-name"/><strong class="calibre2">Printing the variable $my_string as ${my_string}: sdoijweoi | No modifications</strong><br class="title-page-name"/><strong class="calibre2">Printing the variable $my_string as ${my_string^}: Sdoijweoi | The first char is uppercase</strong><br class="title-page-name"/><strong class="calibre2">Printing the variable $my_string as ${my_string^^}: SDOIJWEOI | All chars are uppercase</strong><br class="title-page-name"/><strong class="calibre2">Printing the variable $my_string as ${my_string,}: sdoijweoi | The first char is lowercase</strong><br class="title-page-name"/><strong class="calibre2">Printing the variable $my_string as ${my_string,,}: sdoijweoi | All chars are lowercase</strong>
</pre>
<p class="calibre1">Now, we will test an upper case string:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./parm-sub.sh</strong><br class="title-page-name"/><strong class="calibre2">Hello, can you give me a string of characters?</strong><br class="title-page-name"/><strong class="calibre2">CSEPTKAS</strong><br class="title-page-name"/><strong class="calibre2">Printing the variable $my_string as ${my_string}: CSEPTKAS | No modifications</strong><br class="title-page-name"/><strong class="calibre2">Printing the variable $my_string as ${my_string^}: CSEPTKAS | The first char is uppercase</strong><br class="title-page-name"/><strong class="calibre2">Printing the variable $my_string as ${my_string^^}: CSEPTKAS | All chars are uppercase</strong><br class="title-page-name"/><strong class="calibre2">Printing the variable $my_string as ${my_string,}: cSEPTKAS | The first char is lowercase<br class="title-page-name"/>Printing the variable $my_string as ${my_string,,}: cseptkas | All chars are lowercase</strong>
</pre>
<p class="calibre1">This comes in handy when you want to <em class="calibre20">normalize</em> a string that you retrieved for a previous operation or from a user input.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The backslash (\)</h1>
                
            
            <article>
                
<p class="calibre1">This escape character is used to prevent the special characters interpretation by the shell. We saw an example of its usage in the previous bunch of code where we escaped <kbd class="calibre9">\${my_input}</kbd> so that the echo was able to print it literally as a string and not trying to output its value. Using <kbd class="calibre9">\</kbd> has the same effect as surrounding a variable with single quotes, so this is a strong quotation useful to literally print the <kbd class="calibre9">"</kbd> and <kbd class="calibre9">'</kbd> characters, which are usually interpreted as quotation characters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The forward slash (/)</h1>
                
            
            <article>
                
<p class="calibre1">The forward slash has two different uses:</p>
<ul class="calibre12">
<li class="calibre13">It is a file name separator in paths, as we can see in the <kbd class="calibre9">/usr/lib/dbus-1.0/dbus-daemon-launch-helper</kbd> example. Every bit between a forward slash is a directory until the last leaf, which is a file.</li>
<li class="calibre13">It is the arithmetic operator for the division.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">'...'</h1>
                
            
            <article>
                
<p class="calibre1">This is the command substitution, and we just used it a few pages ago; it assigns the <kbd class="calibre9">stdout</kbd>  command to a variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The colon character (:)</h1>
                
            
            <article>
                
<p class="calibre1">The colon does actually nothing except expanding arguments and performing redirection. It can be handy in cycles and tests to actually do nothing if a condition is met. It is also interesting to see how it can be used to evaluate a series of variables using the parameter substitution:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>x=32<br class="title-page-name"/>y=5<br class="title-page-name"/>: ${x?} ${y?} ${z?}<br class="title-page-name"/>And now let's execute it:<br class="title-page-name"/>zarrelli:~$ ./test-variable.sh<br class="title-page-name"/>./test-variable.sh: line 5: z: parameter null or not set
</pre>
<p class="calibre1">Here is a bite on redirection:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo "012345679" &gt; test.colon.2</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ ls -lah test.colon.2</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 10 Feb 19 14:18 test.colon.2</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ : &gt; test.colon.2</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ ls -lah test.colon.2</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Feb 19 14:18 test.colon.2</strong>
</pre>
<p class="calibre1">So, what we see here is that the combining of the colon with <kbd class="calibre9">&gt;</kbd> gives us a quick method for truncating a regular file without changing the permission. If the file does not exist, it gets created; but if we use <kbd class="calibre9">&gt;&gt;</kbd>, it only creates a file and does not truncate a preexisting file. You will find more <em class="calibre20">strange</em> uses for a colon, such as a field separator in the <kbd class="calibre9">/etc/passwd</kbd> file or as a legit function name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The exclamation (!)</h1>
                
            
            <article>
                
<p class="calibre1">The exclamation mark is a keyword that negates or reverses a test or an exit status. For instance, take a look at this:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -lah test.colon.2 ; echo $?</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 10 Feb 19 14:22 test.colon.2</strong><br class="title-page-name"/><strong class="calibre2">0</strong>
</pre>
<p class="calibre1">The exit code of ls is <kbd class="calibre9">0</kbd>, true, since it was successful. But let's reverse it:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ! ls -lah test.colon.2 ; echo $?</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 10 Feb 19 14:22 test.colon.2</strong><br class="title-page-name"/><strong class="calibre2">1</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Keywords</h1>
                
            
            <article>
                
<p class="calibre1">A <em class="calibre20">keyword</em> is a reserved word that has a special meaning to the shell and is hardwired in it such as the builtins; but differing from the latter, the keywords are not full-blown commands, but parts of a command construct, and you can have a list of these by just typing this: </p>
<ul class="calibre12">
<li class="calibre13">compgen -k</li>
<li class="calibre13">if</li>
<li class="calibre13">then</li>
<li class="calibre13">else</li>
<li class="calibre13">elif</li>
<li class="calibre13">fi</li>
<li class="calibre13">case</li>
<li class="calibre13">esac</li>
<li class="calibre13">for</li>
<li class="calibre13">select</li>
<li class="calibre13">while</li>
<li class="calibre13">until</li>
<li class="calibre13">do</li>
<li class="calibre13">done</li>
<li class="calibre13">in</li>
<li class="calibre13">function</li>
<li class="calibre13">time</li>
<li class="calibre13">{</li>
<li class="calibre13">}</li>
<li class="calibre13">!</li>
<li class="calibre13">[[</li>
<li class="calibre13">]]</li>
</ul>
<p class="calibre1">From the command line, but not from a script, the exclamation mark triggers the bash history.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The asterisk (*)</h1>
                
            
            <article>
                
<p class="calibre1">The asterisk, also known as a wildcard, when used in a file name expansion, matches all the file names in a directory. The file name expansion is also known as <strong class="calibre2">Globbing</strong>. It takes into account some special characters as <kbd class="calibre9">*</kbd>, which is expanded to all, and <kbd class="calibre9">?</kbd>, which expands to any single character along with some character lists in brackets:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -lah [es]*</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 36 Feb 17 07:50 external-data</strong><br class="title-page-name"/><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 211 Feb 17 17:40 external-script-return.sh</strong><br class="title-page-name"/><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 373 Feb 18 11:58 external-script-return-whatever.sh</strong><br class="title-page-name"/><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 257 Feb 17 08:22 external-script.sh</strong><br class="title-page-name"/><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 391 Feb 17 17:37 sourcing-return.sh</strong><br class="title-page-name"/><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 235 Feb 19 10:40 sourcing-return-whatever.sh</strong><br class="title-page-name"/><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 284 Feb 17 07:53 sourcing.sh</strong>
</pre>
<p class="calibre1">As we can see in the example, we listed all the  <kbd class="calibre9">*</kbd> files whose names started either with <kbd class="calibre9">e</kbd> or <kbd class="calibre9">s</kbd>. But it also interprets the <kbd class="calibre9">^</kbd> character as negation:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli@moveaway:~/Documents/My books/Mastering bash/Chapter 4/Scripts$ ls -lah [^es]*</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Feb 16 08:35 *</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Feb 16 08:35 1</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Feb 16 08:35 2</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Feb 16 08:35 3</strong><br class="title-page-name"/><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 249 Feb 16 13:24 comment.sh</strong><br class="title-page-name"/><strong class="calibre2">-rwxr-xr-x 1 zarrelli zarrelli 409 Feb 16 14:59 menu.sh</strong><br class="title-page-name"/><strong class="calibre2">-rwxr--r-- 1 zarrelli zarrelli 700 Feb 19 11:22 parm-sub.sh</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Feb 19 14:16 test.colon</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 10 Feb 19 14:22 test.colon.2</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 5 Feb 16 14:07 test.txt</strong><br class="title-page-name"/><strong class="calibre2">-rwxr-xr-x 1 zarrelli zarrelli 42 Feb 19 14:14 test-variable.sh</strong>
</pre>
<p class="calibre1">In this case, we listed all the files in the current directory whose names did not start with either <kbd class="calibre9">e</kbd> or <kbd class="calibre9">s</kbd>. Be careful as the <kbd class="calibre9">*</kbd> in file globbing does not trap file names starting with a dot:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ mkdir test</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ cd test/</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ touch file</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ touch .another_file</strong><br class="title-page-name"/><strong class="calibre2">zarrelli:~$ ls -l *</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Feb 19 15:08 file</strong>
</pre>
<p class="calibre1">Something is clearly missing, so let's try this:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -lah</strong><br class="title-page-name"/><strong class="calibre2">total 8.0K</strong><br class="title-page-name"/><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 19 15:08 .</strong><br class="title-page-name"/><strong class="calibre2">drwxr-xr-x 3 zarrelli zarrelli 4.0K Feb 19 15:08 ..</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Feb 19 15:08 .another_file</strong><br class="title-page-name"/><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 0 Feb 19 15:08 file</strong>
</pre>
<p class="calibre1">You could also try this for some nice effects:</p>
<pre class="codepackt">
<strong class="calibre2">ls -l .*</strong>
</pre>
<p class="calibre1">Final remarks, you will find the asterisk used as a wild card in regular expressions as well with the same meaning and also as a multiplication operator in arithmetic operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The double asterisk (**)</h1>
                
            
            <article>
                
<p class="calibre1">The double asterisk is being used in two different contexts:</p>
<ul class="calibre12">
<li class="calibre13">It is used as a exponentiation operator in an arithmetic context</li>
<li class="calibre13"><span>It is used as</span> an extended file match globbing operator from Bash 4, meaning it matches filenames and directories recursively</li>
</ul>
<p class="calibre1">So, we have this:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ for i in * ; do echo "$i" ; done</strong><br class="title-page-name"/><strong class="calibre2">file</strong><br class="title-page-name"/><strong class="calibre2">test2</strong>
</pre>
<p class="calibre1">This is different from the following:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ for i in ** ; do echo "$i" ; done</strong><br class="title-page-name"/><strong class="calibre2">file</strong><br class="title-page-name"/><strong class="calibre2">test2</strong><br class="title-page-name"/><strong class="calibre2">test2/file2</strong>
</pre>
<p class="calibre1">The double star matched all files and directories globally. If the double star does not work for you, enable the globstar shell options with <kbd class="calibre9">zarrelli:~$ shopt -s globstar ; for i in ** ; do echo "$i" ; done</kbd>. The <kbd class="calibre9">globstar</kbd> value changes the way the shell interprets the double star, which, in a file name expansion, matches all files and any subdirectories. If the pattern is followed by a <kbd class="calibre9">/</kbd>, only the directories and subdirectories will be matched:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ for i in **/ ; do echo "$i" ; done</strong><br class="title-page-name"/><strong class="calibre2">test2/</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Test operators (?)</h1>
                
            
            <article>
                
<p class="calibre1">The test operator can be used in a few different scenarios. We already saw in the parameter substitution that it is used to check whether a variable has a value or not. In arithmetic operations, it can be used to implement the trinary or ternary operator in a C-style notation:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>x=20<br class="title-page-name"/>y=30<br class="title-page-name"/>w=40<br class="title-page-name"/>z=50<br class="title-page-name"/>k=100<br class="title-page-name"/>echo 'Usually you would write a control loop in the following way:'<br class="title-page-name"/>echo 'if [[ $x -gt $y ]]'<br class="title-page-name"/>echo '     then'<br class="title-page-name"/>echo '       z="$w"'<br class="title-page-name"/>echo '       echo "The value for z is: $z"'<br class="title-page-name"/>echo '     else'<br class="title-page-name"/>echo '       z="$k"'<br class="title-page-name"/>echo ' echo "The value for z is: $z"'<br class="title-page-name"/>echo 'fi'<br class="title-page-name"/>if [[ $x -gt $y ]]<br class="title-page-name"/>   then<br class="title-page-name"/>      z="$w"<br class="title-page-name"/>      echo "The value for z is: $z"<br class="title-page-name"/>   else<br class="title-page-name"/>      z="$k"<br class="title-page-name"/>      echo "The value for z is: $z"<br class="title-page-name"/>fi<br class="title-page-name"/>echo 'But you can also use the C-style trinary operator to achieve the same result:'<br class="title-page-name"/>echo '(( z = x&gt;y?w:k ))'<br class="title-page-name"/>echo 'echo "The value for z is: $z"'<br class="title-page-name"/>(( z = x&gt;y?w:k ))<br class="title-page-name"/>echo "The value for z is: $z"
</pre>
<p class="calibre1">As you can see, the C-style notation is more compact even though it is not as readable as a standard loop notation. Let's try it here:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./c-style.sh</strong>
</pre>
<p class="calibre1">Usually, you would write a control loop in the following way:</p>
<pre class="codepackt">
if [[ $x -gt $y ]]<br class="title-page-name"/>   then<br class="title-page-name"/>      z="$w"<br class="title-page-name"/>      echo "The value for z is: "$z""<br class="title-page-name"/>   else<br class="title-page-name"/>      z="$k"<br class="title-page-name"/>      echo "The value for z is: "$z""<br class="title-page-name"/>fi<br class="title-page-name"/>The value for z is: 100
</pre>
<p class="calibre1">But you can also use the C-style trinary operator to achieve the same result:</p>
<pre class="codepackt">
<strong class="calibre2">(( z = x&gt;y?w:k ))</strong><br class="title-page-name"/><strong class="calibre2">echo "The value for z is: $z"</strong><br class="title-page-name"/><strong class="calibre2">The value for z is: 100</strong>
</pre>
<p class="calibre1">As you can see, we reached the same result but with a more compact code. Essentially, we give a condition that ends with the <kbd class="calibre9">?</kbd> character and then, alternative results follow, which are separated by a <kbd class="calibre9">:</kbd> character.</p>
<p class="calibre1">We see that the C-style is widely used in loops and can be defined as a compound command used to evaluate mathematical expressions in a loop, and as seen in the previous example, assign a variable. It is made of three blocks: the first initializes a variable before the first iteration, the second checks for a condition that exits the look, and the third modifies the initial condition. Sounds strange? Look at this, it will look really familiar:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>for ((i = 0 ; i &lt; 3 ; i++)); do<br class="title-page-name"/>  echo "Counting loop number $i"<br class="title-page-name"/>done
</pre>
<p class="calibre1">Now, let's execute it:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./c-style-counter.sh</strong><br class="title-page-name"/><strong class="calibre2">Counting loop number 0</strong><br class="title-page-name"/><strong class="calibre2">Counting loop number 1</strong><br class="title-page-name"/><strong class="calibre2">Counting loop number 2</strong>
</pre>
<p class="calibre1">Finally, you can find the quotation mark used for file name expansion in globbing as a wild card matching any one characters; in regular expressions, use it as a single character match.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The substitution ($)</h1>
                
            
            <article>
                
<p class="calibre1">We already know this and have used it for the variable substitution that allows us to access the content of a variable:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=10 ; echo $x</strong><br class="title-page-name"/><strong class="calibre2">10</strong>
</pre>
<p class="calibre1">But it is also used in a regular expression to match at the end of a line:</p>
<pre class="codepackt">
<strong class="calibre2">ls | grep [[:digit:]]$</strong><br class="title-page-name"/><strong class="calibre2">1</strong><br class="title-page-name"/><strong class="calibre2">2</strong><br class="title-page-name"/><strong class="calibre2">3</strong><br class="title-page-name"/><strong class="calibre2">test.colon.2</strong>
</pre>
<p class="calibre1">In this example, the output of <kbd class="calibre9">ls</kbd> is filtered on that file whose name ends with a single integer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The parameter substitution (${})</h1>
                
            
            <article>
                
<p class="calibre1">This gives us a parameter substitution, which we have already seen earlier in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The quoted string expansion ($'...')</h1>
                
            
            <article>
                
<p class="calibre1">This is a quoted string expansion, and it is used to expand escaped octal or hex values in Unicode or ASCII:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=$'\110\145\154\154\157' ; echo "$x"</strong><br class="title-page-name"/><strong class="calibre2">Hello</strong>
</pre>
<p class="calibre1">We just concatenated some escaped octal values to get a nice and welcoming ASCII string assigned to the variable <kbd class="calibre9">x</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The positional parameters ($* and $")</h1>
                
            
            <article>
                
<p class="calibre1">The first (<kbd class="calibre9">$*</kbd>) represents all the positional parameters as a single string and the second (<kbd class="calibre9">$"</kbd>) represents all the positional parameters as follows:</p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>counter=0<br class="title-page-name"/>echo "First trying the \$*"<br class="title-page-name"/>for i in "$*"<br class="title-page-name"/>do<br class="title-page-name"/>(( counter+=1 ))<br class="title-page-name"/>echo $counter<br class="title-page-name"/>done<br class="title-page-name"/>counter=0<br class="title-page-name"/>echo "And now \$@"<br class="title-page-name"/>for i in "$@"<br class="title-page-name"/>do<br class="title-page-name"/>(( counter+=1 ))<br class="title-page-name"/>echo $counter<br class="title-page-name"/>done
</pre>
<p class="calibre1">Now, let's test it:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli$ ./positional-single.sh 1 2 3 4 5</strong><br class="title-page-name"/><strong class="calibre2">First trying the $*</strong><br class="title-page-name"/><strong class="calibre2">1</strong><br class="title-page-name"/><strong class="calibre2">And now $@</strong><br class="title-page-name"/><strong class="calibre2">1</strong><br class="title-page-name"/><strong class="calibre2">2</strong><br class="title-page-name"/><strong class="calibre2">3</strong><br class="title-page-name"/><strong class="calibre2">4</strong><br class="title-page-name"/><strong class="calibre2">5</strong>
</pre>
<p class="calibre1">As we can see in the first case, the parameters are passed as single words, but beware, <kbd class="calibre9">$*</kbd> must be quoted to avoid weird side effects of the expansion. <kbd class="calibre9">$@</kbd> passes each parameter as a quoted string without any interpretation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The exit status ($?)</h1>
                
            
            <article>
                
<p class="calibre1">We already saw this representing the exit status of a command, function, and script:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls 2&amp;&gt;1 ; echo $?</strong><br class="title-page-name"/><strong class="calibre2">0</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The process ID ($$)</h1>
                
            
            <article>
                
<p class="calibre1">This holds the <strong class="calibre2">Process ID</strong> (<strong class="calibre2">PID</strong>) of the script that appears in the following:</p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash</strong><br class="title-page-name"/><strong class="calibre2">echo $$</strong>
</pre>
<p class="calibre1">Let's execute it:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./pid.sh</strong><br class="title-page-name"/><strong class="calibre2">4772</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0"> Grouping the command (command1 ; command2 ; commandn)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Grouping the commands into parenthesis have them executed in a subshell, and this has a subtle but outstanding implication: whatever you do in the subshell will not be reachable from the calling shell, so if you execute a subshell from a script with commands inside, what you will do in the subshell will not be available to the calling script:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>x=10<br class="title-page-name"/>echo "The initial value of x is: $x"<br class="title-page-name"/>(x=$(( x*x )) ; echo "The value of x is: $x")<br class="title-page-name"/>echo "But outside the subshell the value of x is untouched: $x" 
</pre>
<p class="calibre1"><span><span>Now, let's execute the code:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./subshell.sh<br class="title-page-name"/></strong><strong class="calibre2">The initial value of x is: 10<br class="title-page-name"/></strong><strong class="calibre2">The value of x is: 100<br class="title-page-name"/></strong><strong class="calibre2">But outside the subshell the value of x is untouched: 10</strong>
</pre>
<p class="calibre1"><span><span>It comes quite straightforward if we recall what we read in the first chapters: the subshell inherits the environment of the calling shell from the script, and so, it can access the value of the <kbd class="calibre9">x</kbd> variable, but it cannot inject back anything. So, after having multiplied the value of <kbd class="calibre9">x</kbd> for itself and reassigning it to the variable, we could print the result, <kbd class="calibre9">100</kbd>, in the subshell. But once we exited it, we were left with the original value of <kbd class="calibre9">x </kbd>and <kbd class="calibre9">10</kbd>. The value of <kbd class="calibre9">x</kbd> never changed in the main script; it changed only into the subshell. </span></span><span><span>As we will see later in this book, <kbd class="calibre9">()</kbd> is also used to initialize an array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">array= (element1 element2 elementn)<br class="title-page-name"/></strong><strong class="calibre2">{a,b,c}</strong>
</pre>
<p class="calibre1"><span><span>The brace expansion can come handy to address multiple items at once:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls *.{[[:digit:]],txt}<br class="title-page-name"/></strong><strong class="calibre2">test.colon.2 test.txt</strong>
</pre>
<p class="calibre1"><span><span>In this case, we expanded <kbd class="calibre9">*</kbd> in files starting with whatever characters, and then ending with a dot, followed either by a single integer or a <kbd class="calibre9">txt</kbd> postfix. But we can actually apply a command to a list of files having the globbing taking effect:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ wc -l {test.txt,test.colon.2,*-data}<br class="title-page-name"/></strong><strong class="calibre2">1 test.txt<br class="title-page-name"/></strong><strong class="calibre2">1 test.colon.2<br class="title-page-name"/></strong><strong class="calibre2">2 external-data<br class="title-page-name"/></strong><strong class="calibre2">4 total </strong>
</pre>
<p class="calibre1"><span><span>Or simply, we can do as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo {1,2,3}<br class="title-page-name"/></strong><strong class="calibre2">1 2 3</strong>
</pre>
<p class="calibre1"><span><span>But be careful; use no spaces inside the braces unless you escape or quote them; otherwise you could face weird issues:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">{element1..elementn}</strong>
</pre>
<p class="calibre1"><span><span>The extended brace expansion, available from Bash 3, is an easy way to create iterators:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ for i in {0..5} ; do echo $i ; done<br class="title-page-name"/></strong><strong class="calibre2">0<br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">4<br class="title-page-name"/></strong><strong class="calibre2">5</strong>
</pre>
<p class="calibre1"><span><span>Or create something fancier, as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ for i in {1..3} ; do for k in {a..c} ; do echo $i,$k ; done ; done<br class="title-page-name"/></strong><strong class="calibre2">1,a<br class="title-page-name"/></strong><strong class="calibre2">1,b<br class="title-page-name"/></strong><strong class="calibre2">1,c<br class="title-page-name"/></strong><strong class="calibre2">2,a<br class="title-page-name"/></strong><strong class="calibre2">2,b<br class="title-page-name"/></strong><strong class="calibre2">2,c<br class="title-page-name"/></strong><strong class="calibre2">3,a<br class="title-page-name"/></strong><strong class="calibre2">3,b<br class="title-page-name"/></strong><strong class="calibre2">3,c<br class="title-page-name"/></strong><strong class="calibre2">{ command1 ; command2 ; commandn ;}</strong>
</pre>
<p class="calibre1"><span><span>The curly brackets are widely used to create the so-called anonymous functions, which have an interesting property: the code inside these kinds of functions are visible to the rest of the script. There is another way of grouping commands, but with some interesting differences:</span></span></p>
<ul class="calibre12">
<li class="calibre13">The commands are executed in the same shell, no subshell spawned</li>
<li class="calibre13">Because of this, all the variables instanced inside the brackets are available from the calling shell, that is, from the calling script</li>
<li class="calibre13">Braces are reserved words and must be separated from the elements enclosed using spaces or a metacharacter</li>
<li class="calibre13">A newline or <kbd class="calibre9">;</kbd> is required at the end of the commands list</li>
</ul>
<p class="calibre1"><span><span>Here is an example of how to use the curly brackets:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>x=10<br class="title-page-name"/>echo "The initial value of x is: $x"<br class="title-page-name"/>multiplier () {<br class="title-page-name"/>local y=$(( x*x ))<br class="title-page-name"/>echo "The value of y in the function is: $y"<br class="title-page-name"/>}<br class="title-page-name"/>echo "We now trigger the function..."<br class="title-page-name"/>multiplier<br class="title-page-name"/>echo "The value of y right after the function execution is: $y"<br class="title-page-name"/>{ z=$(( x*x )) ;<br class="title-page-name"/>echo "The value of z in the function is: $z" ; }<br class="title-page-name"/>echo "The value of z right after the function execution is: $z"
</pre>
<p class="calibre1"><span><span>Now, let's run it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./curly.sh<br class="title-page-name"/></strong><strong class="calibre2">The initial value of x is: 10<br class="title-page-name"/></strong><strong class="calibre2">We now trigger the function...<br class="title-page-name"/></strong><strong class="calibre2">The value of y in the function is: 100<br class="title-page-name"/></strong><strong class="calibre2">The value of y right after the function execution is: <br class="title-page-name"/></strong><strong class="calibre2">The value of z in the function is: 100<br class="title-page-name"/></strong><strong class="calibre2">The value of z right after the function execution is: 100</strong>
</pre>
<p class="calibre1"><span><span>As you can see, we did not have to call the anonymous function to execute it differently from a normal function. We did not use the local scope for the variable since it is not allowed, and it will throw an error. We will see more about functions and scopes in a while.</span></span></p>
<p class="calibre1"><span><span>Braces support I/O redirection for the code enclosed into it.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Braces ({})</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Again, braces have another meaning: using braces with <kbd class="calibre9">xargs -i</kbd> (replace string) can be a placeholder for names:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls *.{[[:digit:]],txt} | xargs -i echo "Found file: {}"<br class="title-page-name"/></strong><strong class="calibre2">Found file: test.colon.2<br class="title-page-name"/></strong><strong class="calibre2">Found file: test.txt</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The full path ({} \;)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Used with <kbd class="calibre9">find -exec</kbd>, this holds the full path to the file located by find. It is not a shell builtin, and the semicolon at the end of the command sequence must be escaped to avoid shell interpretation:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">find . -name *.txt -exec cp {} copy.txt \;<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ls -lah test.txt copy.txt <br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 5 Feb 21 16:12 copy.txt<br class="title-page-name"/></strong><strong class="calibre2">-rw-r--r-- 1 zarrelli zarrelli 5 Feb 16 14:07 test.txt</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Expression ([])</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This tests the expression between brackets. It is the shell builtin test and not the command called <kbd class="calibre9">/usr/bin/[</kbd>.</span></span></p>
<p class="calibre1">[[ -f copy.txt ]] &amp;&amp; echo "file found</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Expression ([[]])</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Again, this tests expressions between brackets, but in a more flexible way. We have already seen this in the previous chapters.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The array index ([])</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This points us to the object located into the array at the index specified between the brackets:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">fruit=(apple banana lemon) ; echo ${fruit[1]}<br class="title-page-name"/></strong><strong class="calibre2">banana</strong>
</pre>
<p class="calibre1"><span><span>We will see what an array is later on, as of now, just bear in mind that an array index starts from <kbd class="calibre9">0</kbd>, so <kbd class="calibre9">1</kbd> is the second element into it.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Characters range ([])</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This defines a range of characters matched in regular expressions:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls | grep ^[c-m]<br class="title-page-name"/></strong><strong class="calibre2">comment.sh<br class="title-page-name"/></strong><strong class="calibre2">copy.txt<br class="title-page-name"/></strong><strong class="calibre2">c-style-counter.sh<br class="title-page-name"/></strong><strong class="calibre2">c-style.sh<br class="title-page-name"/></strong><strong class="calibre2">curly.sh<br class="title-page-name"/></strong><strong class="calibre2">external-data<br class="title-page-name"/></strong><strong class="calibre2">external-script-return.sh<br class="title-page-name"/></strong><strong class="calibre2">external-script-return-whatever.sh<br class="title-page-name"/></strong><strong class="calibre2">external-script.sh<br class="title-page-name"/></strong><strong class="calibre2">menu.sh</strong>
</pre>
<p class="calibre1"><span><span>In this case, we matched all the filenames starting with a character in the range between <kbd class="calibre9">c</kbd> and <kbd class="calibre9">m</kbd>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integer expansion ($[…])</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This is an integer expansion, deprecated and substituted by <kbd class="calibre9">((…))</kbd>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integer expansion (((..)))</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This is an integer expansion. We have already seen in the previous chapters how to use it.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">DEMO</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We saw this at the beginning of this book, and we know they are used for redirections. You will find more details on how to use it in the examples provided.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The here document (&lt;&lt;)</h1>
                
            
            <article>
                
<p class="calibre1"><span>A here document is a form of redirection that forces the shell to read the input from the subsequent block of characters up to a user-defined delimiter, and then it uses this bunch of characters as a standard input for a command or a file descriptor. As we can see in the next example, the argument for the <kbd class="calibre9">cat</kbd> command is not provided on the command line or asked to the user, but it is written into the script between the two <kbd class="calibre9">DELIMITER</kbd> words:</span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>cat &lt;&lt; DELIMITER<br class="title-page-name"/>This is a string<br class="title-page-name"/>followed by another<br class="title-page-name"/>date $(date +%Y.%m.%d)<br class="title-page-name"/>until the <br class="title-page-name"/>DELIMITER
</pre>
<p class="calibre1"><span><span>Now, let's run it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./here-date.sh <br class="title-page-name"/></strong><strong class="calibre2">This is a string<br class="title-page-name"/></strong><strong class="calibre2">followed by another<br class="title-page-name"/></strong><strong class="calibre2">date 2017.02.21<br class="title-page-name"/></strong><strong class="calibre2">until the </strong>
</pre>
<p class="calibre1"><span><span>The delimiter at the right of <kbd class="calibre9">&lt;&lt;</kbd> can be whatever string you want as long as it matches with the last line: everything between the two delimiters will be used as standard input for, in our example, <kbd class="calibre9">cat</kbd>. Be aware that the delimiter is not subject to any command substitution, arithmetical, or pathname expansion. But if the delimiter is not quoted, then the lines between the delimiters are subject to the arithmetic and file expansions and the command substitution.</span></span></p>
<p class="calibre1"><span><span>A nice touch is to add <kbd class="calibre9">–</kbd> at the right side of</span></span> <kbd class="calibre9">&lt;&lt;</kbd><span><span>so that the trailing tab characters get stripped from the input, and this makes it possible to create indented here documents:</span></span></p>
<pre class="codepackt">
#!/bin/bash<br class="title-page-name"/>cat &lt;&lt; DELIMITER<br class="title-page-name"/>This is a string<br class="title-page-name"/>        followed by an indented one<br class="title-page-name"/>            with an indented date: $(date +%Y.%m.%d)<br class="title-page-name"/>until the<br class="title-page-name"/>DELIMITER
</pre>
<p class="calibre1"><span><span>You will now get this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./here-date-indented.sh <br class="title-page-name"/></strong><strong class="calibre2">This is a string<br class="title-page-name"/></strong><strong class="calibre2">        followed by an indented one<br class="title-page-name"/></strong><strong class="calibre2">            with an indented date: 2017.02.21<br class="title-page-name"/></strong><strong class="calibre2">until the </strong>
</pre>
<p class="calibre1"><span><span>If you swap <kbd class="calibre9">&lt;&lt;</kbd> with <kbd class="calibre9">&lt;</kbd>, you will get an unindented input:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./here-date-indented.sh <br class="title-page-name"/></strong><strong class="calibre2">This is a string<br class="title-page-name"/></strong><strong class="calibre2">followed by an indented one <br class="title-page-name"/></strong><strong class="calibre2">with an indented date: 2017.02.21<br class="title-page-name"/></strong><strong class="calibre2">until the </strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The here string (&lt;&lt;&lt;)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>The <em class="calibre20">here</em> string is a simple version of the <em class="calibre20">here</em> document, and it consists of a single line where the delimiter is expanded to feed the command:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash</strong><br class="title-page-name"/><strong class="calibre2">today=$(date +%Y.%m.%d)</strong><br class="title-page-name"/><strong class="calibre2">cat &lt;&lt;&lt; $today</strong>
</pre>
<p class="calibre1"><span><span>The output is here:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./here-date-string.sh <br class="title-page-name"/></strong><strong class="calibre2">2017.02.21</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The ASCII comparison operators (&lt;) and (&gt;)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This is an ASCII comparison between strings. We already saw how to use these in the previous chapter.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Delimiters (\&lt; and \&gt;)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Are delimiters are used to identify a word in a regular expression. Let's create a file:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo "barnaby went to the bar to see the barnum musical" &gt; text.file </strong>
</pre>
<p class="calibre1"><span><span>Now, we will <kbd class="calibre9">grep</kbd> with the word delimiter set to <kbd class="calibre9">bar</kbd> with the <kbd class="calibre9">-o</kbd> option, which will output only the fragment that matched and not all the lines containing it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">grep -o '\&lt;bar\&gt;' text.file <br class="title-page-name"/></strong><strong class="calibre2">bar</strong>
</pre>
<p class="calibre1"><span><span>This is correct. There is only one single word called <kbd class="calibre9">bar</kbd>; the others are composite words, and we can double check this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ grep -o bar text.file <br class="title-page-name"/></strong><strong class="calibre2">bar<br class="title-page-name"/></strong><strong class="calibre2">bar<br class="title-page-name"/></strong><strong class="calibre2">bar</strong>
</pre>
<p class="calibre1"><span><span>If we do not look for the word named </span></span><kbd class="calibre9">bar</kbd>, <span><span>but only for the matches of a three character string bar, we see that we can match it three times in the file.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The pipe character (|)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>The pipe is a classic example of inter process communication: it passes the <kbd class="calibre9">stdout</kbd> of a process to the <kbd class="calibre9">stdin</kbd> of another process:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -lah | wc -l<br class="title-page-name"/></strong><strong class="calibre2">35</strong>
</pre>
<p class="calibre1"><span><span>In this example, we just listed the content of the current directory and fed the output as the <kbd class="calibre9">stdin</kbd> of the <kbd class="calibre9">wc</kbd> utility, which counted how many lines there were in data just fed in. The command after the pipe runs in a subshell, so it will not be able to return any modified value to the parent process; and if one of the commands in the pipe aborts somehow, this leads to the so-called broken pipe and the execution of the pipe stops.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The force redirection (&gt;|)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This forces redirection even if a <kbd class="calibre9">noclobber</kbd> option is set for the shell. Clobbering means the act of overwriting the content of a file, and this is something we have already seen with the redirection, but let's have a look at this example:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo "123" &gt; override.txt<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ cat override.txt <br class="title-page-name"/></strong><strong class="calibre2">123<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ echo "456" &gt; override.txt<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ cat override.txt <br class="title-page-name"/></strong><strong class="calibre2">456</strong>
</pre>
<p class="calibre1"><span><span>Everything goes as expected. We redirected the output of the echo, and on the second run, we overwrote the content of the file. But let's now set the <kbd class="calibre9">noclobber</kbd> option for the shell:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ set -o noclobber</strong>
</pre>
<p class="calibre1"><span><span>We will try to overwrite the content of the file:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo "789" &gt; override.txt<br class="title-page-name"/></strong><strong class="calibre2">bash: override.txt: cannot overwrite existing file</strong>
</pre>
<p class="calibre1"><span><span>No way, we are prevented from the accidental overwriting by the <kbd class="calibre9">noclobber</kbd> option set for the shell:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat override.txt <br class="title-page-name"/></strong><strong class="calibre2">456</strong>
</pre>
<p class="calibre1"><span><span>In fact, the content of the file is still the same, but now, it is this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo "789" &gt;| override.txt<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~/$ cat override.txt <br class="title-page-name"/></strong><strong class="calibre2">789</strong>
</pre>
<p class="calibre1"><span><span>We forced the redirection and now the content of the file has changed:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ set +o noclobber</strong>
</pre>
<p class="calibre1"><span><span>Let's revert the <kbd class="calibre9">noclobber</kbd> option.</span></span></p>
<p class="calibre1"><span>Have a look at </span><kbd class="calibre9">man bash</kbd> <span>for some interesting options that you can set with the </span><kbd class="calibre9">set -o</kbd> <span>option </span><span>to alter the Bash behavior. For instance, take a look at this:</span></p>
<ul class="calibre12">
<li class="calibre13"><span><kbd class="calibre9">+B</kbd> disables the brace expansion</span></li>
<li class="calibre13"><span><kbd class="calibre9">-f</kbd> disables the file name expansion, also known as globbing.</span></li>
<li class="calibre13"><span><kbd class="calibre9">-i</kbd> runs a script in the interactive mode</span></li>
<li class="calibre13"><span><kbd class="calibre9">-n</kbd> reads the commands in a script but does not execute them; it is a classical dry run mode for syntax check</span></li>
<li class="calibre13"><span>The <kbd class="calibre9">-o</kbd> posix makes everything a POSIX compliant</span></li>
<li class="calibre13"><span>The <kbd class="calibre9">-p</kbd> script runs as SUID</span></li>
<li class="calibre13"><span>The <kbd class="calibre9">-r</kbd> script runs with a restricted shell</span></li>
<li class="calibre13"><span><kbd class="calibre9">-s</kbd> the commands are read from the</span> <kbd class="calibre9">stdin</kbd></li>
<li class="calibre13"><span>The <kbd class="calibre9">-v</kbd> commands are printed to <kbd class="calibre9">stdout</kbd> before their execution</span></li>
<li class="calibre13"><span><kbd class="calibre9">-x</kbd> is similar to <kbd class="calibre9">-v</kbd>, but the commands get expanded</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The logical OR (||)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We have already understood them, so have a look at the previous pages.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">DEMO</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This sends a process into the background. Look at this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo "Hello, see you in 5 seconds" ; sleep 5 <br class="title-page-name"/></strong><strong class="calibre2">Hello, see you in 5 seconds</strong>
</pre>
<p class="calibre1"><span><span>It will hold the prompt for 5 seconds only if you put sleep in the background:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo "Hello, see you in 5 seconds" ; sleep 5 &amp;<br class="title-page-name"/></strong><strong class="calibre2">Hello, see you in 5 seconds<br class="title-page-name"/></strong><strong class="calibre2">[1] 8163</strong>
</pre>
<p class="calibre1"><span><span>The shell will give you back control immediately, since the sleep process will not get any more input from the terminal, leaving the command line available to the user. One of the benefits of this is that while you are limited to a single foreground process at time. Since during its execution, you will not be able to enter any other commands with background processes, you can spawn as many as you wish, given the system resources.</span></span></p>
<p class="calibre1"><span>You can manually force a foreground process to go to the background by pressing </span><span><em class="calibre20">Ctrl</em> + <em class="calibre20">Z </em></span><span>and then </span><span><kbd class="calibre9">fg</kbd>:</span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo "Hello, see you in 50 seconds" ; sleep 50 <br class="title-page-name"/></strong><strong class="calibre2">Hello, see you in 50 seconds<br class="title-page-name"/></strong><strong class="calibre2">^Z<br class="title-page-name"/></strong><strong class="calibre2">[6]+ Stopped sleep 50<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ fg<br class="title-page-name"/></strong><strong class="calibre2">sleep 50</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Logical AND</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This is the logical AND, and it returns <kbd class="calibre9">true</kbd> in a test if both the conditions are true.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The dash character (-)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>The dash is the option character, and usually, it denotes an optional parameter on a command line:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">ps -ax</strong>
</pre>
<p class="calibre1"><span><span>It is also used in parameter substitution as the prefix for the default parameter, a</span></span><span><span>nd it is also used to redirect from/to stdin/stdout:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat -<br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">^C </strong>
</pre>
<p class="calibre1"><span><span>Or, it can do this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ tar cvzf - $(ls text.file) &gt; zipped.tgz<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ tar -tf zipped.tgz <br class="title-page-name"/></strong><strong class="calibre2">text.file</strong>
</pre>
<p class="calibre1"><span><span>What we did is get the file name on the <kbd class="calibre9">stdout</kbd> using the command substitution, have it read from the <kbd class="calibre9">stdin</kbd> with the <kbd class="calibre9">-</kbd>, then the result of the <kbd class="calibre9">tar</kbd> operation redirected to the <kbd class="calibre9">stdout</kbd> to create the zipped file.</span></span></p>
<p class="calibre1"><span><span>We can also use the dash to go back to our previous directory as held in the environmental <kbd class="calibre9">$OLDPWD</kbd> variable:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ mkdir -p dir1/dir2<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ cd dir1/<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ cd dir2/<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ cd -<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ pwd<br class="title-page-name"/></strong><strong class="calibre2">dir1</strong>
</pre>
<p class="calibre1"><span><span>Finally, in an arithmetic operations context, the dash means minus, so we can subtract a number from another.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The double dash (--)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>The double dash usually stands for long options for a command. For instance, in the next example, we use the short option called <kbd class="calibre9">-a</kbd> and the long option called <kbd class="calibre9">--all</kbd> to enable the same behavior for ls; the long option being usually a more human readable form of the shorter one. While the short option starts with a single dash, the long option starts with a double dash:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -a<br class="title-page-name"/></strong><strong class="calibre2">. .. dir2<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ls --all<br class="title-page-name"/></strong><strong class="calibre2">. .. dir2</strong>
</pre>
<p class="calibre1"><span><span>It is also used, as we saw a few pages ago, with the set command to set Bash options.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operator = </h1>
                
            
            <article>
                
<p class="calibre1"><span><span>It can be an assignment operator:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=10 ; echo $x<br class="title-page-name"/></strong><strong class="calibre2">10</strong>
</pre>
<p class="calibre1"><span><span>It can also be a string comparison operator:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=10 ; y=10 ; if [[ "$x" = "$y" ]] ; then echo "Success" ; fi<br class="title-page-name"/></strong><strong class="calibre2">Success 
</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operator +</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This can be used as an operator in an arithmetic context to add a number to another one. In a regular expression scenario, it matches one or more of the previous regular expressions:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo "Hello" | grep 'Hel\+o'<br class="title-page-name"/></strong><strong class="calibre2">Hello</strong>
</pre>
<p class="calibre1"><span><span>The plus character is also used by some built-ins to enable some options in the parameter substitution context to mark the alternate value that a variable expands to:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=10 ; y=${x+20} ; echo $y<br class="title-page-name"/></strong><strong class="calibre2">20</strong>
</pre>
<p class="calibre1"><span><span>If <kbd class="calibre9">x</kbd> is set, it will be use the value of <kbd class="calibre9">20</kbd> otherwise a null string.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The modulo operator (%)</h1>
                
            
            <article>
                
<p class="calibre1">It is the arithmetic operator for modulo, the remainder of a division. The modulo operator is also used as the operator for pattern matching in a parameter substitution context:</p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x="highland" ; y=${x%land} ; echo $y<br class="title-page-name"/></strong><strong class="calibre2">high</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operator ~</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This holds the same value of the environment variable called <kbd class="calibre9">$HOME</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ echo ~<br class="title-page-name"/></strong><strong class="calibre2">/home/zarrelli<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ls /home/zarrelli/<br class="title-page-name"/></strong><strong class="calibre2">Desktop Documents Downloads Music Pictures Public Templates test.file test.sh tmp Videos<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ls ~/tmp/<br class="title-page-name"/></strong><strong class="calibre2">setting.sh<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ cd ~<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ pwd<br class="title-page-name"/></strong><strong class="calibre2">/home/zarrelli</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operator ~+</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This is the current working directory whose value is held by the env variable named  <kbd class="calibre9">$PWD</kbd>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operator ~-</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This is the previous working directory whose value is held by the env variable named <kbd class="calibre9">$OLDPWD</kbd>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operator ~=</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This is the matching operator for regular expressions inside double brackets. It has been introduced in Bash 3.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operator ^</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>In regular expressions it matches the given pattern starting from the beginning of the line. We saw some examples in the previous pages.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The control characters (^ and ^^) </h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Introduced in Bash 4, they deal with the uppercase conversion in a parameter substitution context.</span></span></p>
<p class="calibre1"><span><span>Apart from the special characters that we saw so far, there is a combination of keys. They are usually called control characters that are not actually used in a script, but ease your interaction with the terminal. They are a combination of two characters, <em class="calibre20">Ctrl </em>and another one, pressed together; but they can also be written in escaped hexadecimal or octal notation:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">A</em>:  This m</span><span><span>oves the cursor at the beginning of a string of characters on the command line.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+B: This i</span><span><span>s a backspace, but it does not erase anything.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+C: This b</span><span><span>reaks out of a foreground job, terminating it.</span></span></li>
</ul>
<div class="packt_figure"><img class="image-border1" src="../images/00006.jpeg"/></div>
<ul class="calibre12">
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">D</em>: This e</span><span><span>xits on a shell. If the user is in a terminal window and typing, it erases the character the cursor is on. If there is nothing in the window, it gets closed.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">E</em>: This moves the cursor at the end of a string of characters on the command line.</span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">F</em>: This m</span><span><span>oves the cursor forward of one position on the command line.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">G</em>: </span><span><span>In a terminal window, this could raise a beep.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">H</em>: This b</span><span>ackspaces and deletes the character under the cursor while<span>  backspacing, also known as <strong class="calibre2">rubout</strong>.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">I</em>: This is </span><span><span>a horizontal tab.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">J</em>: This</span> <span><span>is the newline and it can also be expressed as the <kbd class="calibre9">\012</kbd> octal and the <kbd class="calibre9">\x0a</kbd> hexadecimal.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">K</em>: </span><span><span>This is a vertical tab. In a terminal window, it deletes all the characters from under the cursor to the end of the line.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">L</em>: This</span> <span><span>is the formfeed, and it clears the screen from all the content.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">M</em>: </span><span><span>This is the carriage return.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">N</em>: This  d</span><span><span>eletes a line called back from the history on the command line.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">O</em>: </span><span><span>Given on the command line, it brings you to a new line executing the current command on CLI .</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">P</em>: This  r</span><span><span>estores the last command from the history on the command line.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">Q</em>: This  r</span><span><span>esumes <kbd class="calibre9">stdin</kbd> in a terminal window.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">R</em>: This s</span><span><span>earches for text in the history, backwards.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">S</em>: This s</span><span><span>uspends <kbd class="calibre9">stdin</kbd> in a terminal window, resumed by <em class="calibre20">Ctrl</em>+<em class="calibre20">Q.</em></span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">T</em>: This s</span><span><span>waps the character under the cursor with the preceding one on the command line.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">U</em>: This d</span><span><span>eletes all characters between the cursor position and at the beginning of the command line. In some configurations, it deletes all the characters on the command line.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">V</em>: This is u</span><span><span>sed mostly in editors, and it allows to enter control characters while inserting text.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">W</em>: </span><span><span>In a terminal or X term, it deletes characters backwards from under the cursor to the first whitespace; in some configurations, it deletes until the first non alphanumeric character is reached.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">X</em>: </span><span><span>You will find it in quite a number of word processors, as a way to cut and paste text from the editor to the clipboard.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">Y</em>: This p</span><span><span>astes the text erased with <em class="calibre20">Ctrl</em>+<em class="calibre20">U </em>or <em class="calibre20">Ctrl</em>+<em class="calibre20">W </em>back.</span></span></li>
<li class="calibre13"><span><em class="calibre20">Ctrl</em>+<em class="calibre20">Z</em>: This p</span><span><span>auses a job that is in the foreground.</span></span></li>
<li class="calibre13"><span><span>Whitespace: This is o</span></span><span><span>ften used as a field separator. It is sometimes required in some context and forbidden in others, as we saw in some of the examples available in the previous chapters.</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Quoting and escaping</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We've already seen how important quoting and escaping is in Bash, and this is due to the fact that some characters are not just what they look like, but they hold some special meaning for the shell, which interprets them whenever it meets them. But sometimes, we want these characters for just what they are; we want to keep whitespaces in a string and not split it up in words, or we just want to see if there is a <kbd class="calibre9">*</kbd> file name. Or we want to <kbd class="calibre9">echo</kbd> a double quote and not start a quote. So, we quote and escape to preserve what we see from what the shell could think it is.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The backslash (\)</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>The backslash is the character we use to escape all the others. Great. What does it mean? Simply put, each character preceded by a backslash keeps its literal value or meaning. The backslash does not apply to an entire string, but just to its following character, and it is widely used to escape spaces in file names:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ mkdir this is a directory with spaces in the name<br class="title-page-name"/></strong><strong class="calibre2">total 44K<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 11 zarrelli zarrelli 4.0K Feb 23 09:50 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 3 zarrelli zarrelli 4.0K Feb 23 09:44 ..<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 a<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 directory<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 in<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 is<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 name<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 spaces<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 the<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 this<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 with</strong>
</pre>
<p class="calibre1"><span><span>Well, not exactly the result we wanted, but it is what we should have expected: the whitespace has been interpreted by the shell as a separator, so <kbd class="calibre9">mkdir</kbd> created as many directories as the words given as arguments. We need to have <kbd class="calibre9">mkdir</kbd> to parse a string complete with whitespaces and not a series of words split by spaces:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ mkdir this\ is\ a\ directory\ with\ spaces\ in\ the\ name<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ls -lah<br class="title-page-name"/></strong><strong class="calibre2">total 48K<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 12 zarrelli zarrelli 4.0K Feb 23 09:52 .<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 3 zarrelli zarrelli 4.0K Feb 23 09:44 ..<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 a<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 directory<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 in<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 is<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 name<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 spaces<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 the<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 this<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:52 this is a directory with spaces in the name<br class="title-page-name"/></strong><strong class="calibre2">drwxr-xr-x 2 zarrelli zarrelli 4.0K Feb 23 09:48 with</strong>
</pre>
<p class="calibre1"><span><span>Here we go, we finally have a directory whose name is filled with spaces.</span></span></p>
<p class="calibre1"><span><span>You can also see the backslash used in scripts or on the command line when your instructions are becoming a bit too long. You can see them when you want to go on a new line without triggering a carriage return, which would execute your incomplete command line:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli@moveaway:~$ var="This can become a bit too long \<br class="title-page-name"/></strong><strong class="calibre2">&gt; so better to go on a new line and print on the next" ;\<br class="title-page-name"/></strong><strong class="calibre2">&gt; echo \<br class="title-page-name"/></strong><strong class="calibre2">&gt; $var<br class="title-page-name"/></strong><strong class="calibre2">This can become a bit too long so better to go on a new line and print on the next</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Double quotes ("")</h1>
                
            
            <article>
                
<p class="calibre1"><span><span><strong class="calibre2">Double quotes</strong> are the so-called weak quoting, since they prevent the interpretation by the shell of all metacharacters except for <kbd class="calibre9">$</kbd>, <kbd class="calibre9">"</kbd>, <kbd class="calibre9">'</kbd>, and <kbd class="calibre9">\</kbd>. This means a few things; the most important is that you can reference a variable value even if it is quoted:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=10 ; echo "$x"<br class="title-page-name"/></strong><strong class="calibre2">10</strong>
</pre>
<p class="calibre1"><span><span>This also means that you can use backslash to escape <kbd class="calibre9">$</kbd> to print the literal <kbd class="calibre9">$a</kbd> string:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=10 ; echo "\$x"<br class="title-page-name"/></strong><strong class="calibre2">$x</strong>
</pre>
<p class="calibre1"><span><span>So, to use one of the preceding interpreted characters, you have to escape it with a backslash.</span></span></p>
<p class="calibre1"><span><span>Also, double quotes preserve whitespaces, so we can rewrite the command we saw earlier:</span></span></p>
<p class="calibre1"><span><span><kbd class="calibre9">mkdir this\ is\ a\ directory\ with\ spaces\ in\ the\ name</kbd> </span></span><span><span>as </span></span><kbd class="calibre9"><span><span>mkdir "this is a directory with spaces in the name".</span></span></kbd></p>
<p class="calibre1"><span><span>So, what if you want to prevent any interpretations at all? You have to rely on a strong quoting.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Single quotes (')</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Single quotes enable a strong quoting so that none of the metacharacters we saw before, such as <kbd class="calibre9">$</kbd>, <kbd class="calibre9">"</kbd>, <kbd class="calibre9">'</kbd>, and <kbd class="calibre9">\</kbd> , are interpreted; and everything quoted this way is taken literally except for the single quote itself, which keeps its function of the metacharacter. This means that you cannot use it at all since the usual way of taking the literal value of a character. Using a backslash does not work since inside the single quote, as the backslash itself loses its meta effect. One notable effect of strong quoting is that you cannot reference the value of a variable any longer:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ x=10 ; echo '$x'<br class="title-page-name"/></strong><strong class="calibre2">$x</strong>
</pre>
<p class="calibre1"><span><span>That being said, we still have some characters with special meanings even after being escaped; here are some of them:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">\a</kbd> is the alert</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">\b</kbd> is the backspace</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">\n</kbd> is the newline</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">\r</kbd> is the return</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">\t</kbd> is the tab</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">\v</kbd> is the vertical tab</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Now that we understand how to deal safely with variables and special characters, it is time to move toward something more useful in our everyday programming. In the next chapter, we will have a close look at the case construct, arrays, and functions; and this will allow us to create our first fully-fledged command-line parser.</span></span></p>


            </article>

            
        </section>
    </body></html>