- en: Chapter 5. Managing Filesystems and Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the size of files and available storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting storage limits for users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RAM disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RAID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a device in a RAID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new LVM volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing an existing LVM volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding storage and growing an LVM volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with LVM snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes in this chapter focus on leveraging your CentOS system's storage
    to maintain availability, increase reliability, and to keep your data safe against
    inevitable disk failures. You'll learn how to determine how much space your files
    take up and how much storage is still available. Then, you'll see how to put limits
    in place to ensure that users use the system's storage resources equitably. We'll
    also create a RAM disk, a memory-based low latency storage for frequently accessed
    data. Then you'll learn how to create and manage RAID arrays to provide reliable
    storage, and how to work with LVM volumes to allocate logical drives from storage
    pools to better utilize your system's total storage capacity.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the size of files and available storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs and services can behave unexpectedly or stop working entirely when
    storage space runs tight, so it's important to know how much space is available
    on our system. This recipe introduces a handful of commands used to determine
    how large your files and directories are and how much storage is used and is available.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a working CentOS system. Administrative privileges may
    be needed depending on the permissions of the directories and files you want to
    inspect.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display the storage capacity of a mounted filesystem, use the `df` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To view the size of a file, use the `ls` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To determine the size of a directory (the sum of sizes of all of its files),
    use the `du` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `df` command returns information about how much free space is available
    on a mounted filesystem. The preceding example asked for details about the root
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `-h` argument formats the information in a human-readable format, listing
    the values as megabytes, gigabytes, and so on, as opposed to block counts. When
    invoked without any arguments, `df` displays its information in 512-byte block
    counts for all mounted filesystems. We can specify one or more mount points with
    this command, in which case `df` reports only on those filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Values presented as megabytes and gigabytes are more informative than when given
    in block counts
  prefs: []
  type: TYPE_NORMAL
- en: The output's first column, labeled `Filesystem`, and the last, labeled `Mounted
    on`, identifies the filesystem and mount point it's been made available on, respectively.
    The `Size` column shows the total amount of space the filesystem provides. The
    `Used` column shows how much of that space is occupied and the `Avail` column
    shows how much is still available. `Use%` shows how much space is occupied as
    a percentage.
  prefs: []
  type: TYPE_NORMAL
- en: While `df` gives us a high-level view of our overall storage usage, to view
    the size of individual files we can use `ls`. The command supports a large number
    of arguments that show meta information for files and directories, such as their
    ownership details, create time, and size.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe used the `-s` argument to return the file''s size and `-h` to again
    display the value in a human-readable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you use `ls` to show the size of a directory, it will likely report 4.0 K
    regardless of which directory you choose. This is because directories aren't really
    containers holding files like we usually imagine; a directory is really a special
    file that contains an index listing the files that are within it. This index occupies
    a block's worth of storage. `ls` reports the amount of space the directory occupies
    as a file, not the sum of the sizes of its files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the total size of all of the files in a directory, which is usually
    what we want when talking about directory size, we need to use the `du` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-s` argument prints only the value for the current directory and `-h`
    formats the value in a human-readable format. Without any arguments, `du` also
    displays 512-byte block counts for all files and directories within the current
    directory. However, directories are treated as containers so the values reflect
    the block count of all of their contained files. We can also list one or more
    files or directories, in which case `du` reports back only on those targets. By
    targeting all of the files/directories within a directory and piping the output
    through `sort`, we can use `du` to identify targets that consume the most storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'sort''s `-h` argument organizes the human-readable numbers correctly (for example,
    `4.0K` is less than `3M` even though 3 is less than 4 in a numerical sort) and
    `-r` reverses the order to display the largest entries first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sorting can help identify what consumes the most storage
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on the commands mentioned in this recipe, refer to their
    respective man pages:'
  prefs: []
  type: TYPE_NORMAL
- en: The `df` manual page (`man 1 df`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `du` manual page (`man 1 du`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ls` manual page (`man 1 ls`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting storage limits for users and groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imposing limits on the amount of storage a user can consume is an effective
    way to manage resources and ensure they are made available to everyone fairly,
    especially in a multiuser environment. This recipe shows you how to enable quotas
    and set limits by users and groups.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a CentOS system with administrative privileges provided
    by logging in with the `root` account or using `sudo`. It assumes `/home` mounts
    its own filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to set up quotas and specify storage limits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `/etc/fstab` file for editing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable user quotas, which enforce usage limits based on user accounts, add
    `uquota` to the mount options for `/home`. For group quotas, add `gquota`. Both
    `uquota` and `gquota` can be given together to enable both:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your changes and close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reboot the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the system reboots, launch the `xfs_quota` shell in expert mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set limits for a user account using the `limit` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `quota` command to verify that the user''s limits have been set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set limits for a group using `limit -g`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `quota -g` to verify that the group''s limits have been set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type `quit` or press ***Ctrl*** + ***D*** to exit the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quotas are not enabled by default and must be enabled explicitly in the filesystem''s
    mount options; so, we updated `/etc/fstab` and added the `uquota` and/or `gquota`
    option for `/home`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We should never unmount a filesystem that''s in use because we don''t want
    to risk corrupting or losing data. So, it''s important that no one else is logged
    in when we remount `/home`. If you''re logged in as `root` and you''re certain
    you''re the only user logged in, you can remount the filesystem with `umount`
    immediately followed by `mount`. But if others are logged on, it''s best to perform
    a reboot as the recipe suggests. When the system reboots, it will have automatically
    mounted `/home` and the quota options will be in effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we ran `xfs_quota` as an interactive shell to enter commands to manage
    our quotas. We used the `-x` argument to start the shell in expert mode (the commands
    we need to manage quotas are only available in expert mode) and gave the filesystem''s
    mount point on which we''re going to set quotas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The traditional quota utilities can be used to manage basic quotas, but `xfs_quota`
    lets us take advantage of the additional quota functionality unique to XFS. For
    example, using `xfs_quota` we can also manage project quotas.
  prefs: []
  type: TYPE_NORMAL
- en: The two commands with the most interest for us are `limit` and `quota`. `limit`
    is used to set the quota limits and `quota` is used to report the quota information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set four limits with `limit`. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isoft`: This sets a soft limit on the number of inodes used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ihard`: This sets a hard limit on the number of inodes used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bsoft`: This sets a soft limit on the number of blocks used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bhard`: This sets a hard limit on the number of blocks used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An inode is a data structure used by filesystems to track files and directories.
    Each file and directory are represented by an inode, so setting a limit on the
    number of inodes a user can have essentially limits the number of files/directories
    they can have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blocks represent the physical storage, and setting a quota on the number of
    blocks for a user limits the amount of storage space their files can consume.
    The typical block size is 512 bytes, meaning two blocks are used to store 1 KB
    of data. The recipe''s examples set a soft block limit of 5 GB for the user account
    and a hard limit of 6 GB. The suffixes `k`, `m`, and `g` are used to specify values
    as kilobytes, megabytes, and gigabytes, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Commands can be run in `xfs_quota` without entering the interactive shell by
    using `-c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**xfs_quota -x -c ''limit -u bsoft=5g tboronczyk'' /home**`'
  prefs: []
  type: TYPE_NORMAL
- en: A hard limit specifies a value that the user absolutely cannot surpass. For
    example, a user with a hard limit of 100 inodes and having 99 files will only
    be able to create one more file. An attempt to create a file beyond that will
    be met with an error.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a soft limit defines a limit a user can surpass for a small
    amount of time. Once the limit is exceeded, the user enters a grace period. A
    user with a soft block limit of 5 GB will be able to consume more than 5 GB of
    storage, but only for a certain amount of time. If they're still violating the
    limit by the end of the grace period, the soft limit will be treated as a hard
    limit and they won't be able to save any more data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The grace period is 7 days by default. We can change this with the `timer`
    command, using `-i` to change the inodes timer and `-b` to change the block timer:
    `**timer -b 3d tboronczyk**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To review the current quotas, the `quota` command is used. `-h` presents the
    values in human-readable values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The default output shows the filesystem and its mount point and the user''s
    block quota details: the number of blocks consumed (under the **Blocks** header),
    soft limit (**Quota**), hard limit (**Limit**), and the elapsed time of a soft-limit
    violation''s grace period (**Warn/Time**). `-i` will retrieve the same information
    for inode quotas, and `-b` and `-i` can be used together to display both sets
    of information at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Block and inode quotas can be displayed at the same time
  prefs: []
  type: TYPE_NORMAL
- en: 'The `limit` and `quota` commands all default to working with a user''s quota,
    although we can explicitly manage a user''s quota using the `-u` argument. To
    manage a group''s quota, we use `-g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, `xfs_quota` also allows us to manage project quotas.
    These are essentially limits placed on specific directories that are enforced
    regardless of user or group ownership. To use project quotas, use the `pquota`
    mount option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Project quotas and group quotas cannot be used together; `mount` will fail to
    mount the filesystem if both `pquota` and `gquota` are given. Depending on the
    filesystem, this may prevent your system from booting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the file `/etc/projid`. Each line is an entry made up of an arbitrary
    project name and a unique ID number separated by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the file `/etc/projects`. Its entries are made up of the project
    ID, a separating colon, and the project''s directory. Together, the `projects`
    and `projid` files define the relationship between the project''s name and its
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the two configuration files in place, the final step is to initialize
    the project''s quota tracking in `xfs_quota` using `project -c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the initial setup steps complete, you can use the `limit` and `quota`
    commands to manage the project''s quotas using the `-p` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following resources for more information on working with quotas:'
  prefs: []
  type: TYPE_NORMAL
- en: The `xfs_quota` manual page (`man 8 xfs_quota`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable User and Group Disk Quota on CentOS 7 ([http://www.linuxtechi.com/enable-user-group-disk-quota-on-centos-7-rhel-7/](http://www.linuxtechi.com/enable-user-group-disk-quota-on-centos-7-rhel-7/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RAM disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe teaches you how to take advantage of RAM's low latency using a RAM
    disk, a section of memory made available as if it were a standard storage device.
    RAM disks often store volatile data that is constantly read and updated in memory.
    For example, on desktop systems they're used for storing a browser's cache to
    speed up web surfing. In server environments, RAM disks can store cache data for
    high-load proxy services to reduce latency.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a CentOS system with administrative privileges provided
    by logging in with the `root` account or using `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create and use a RAM disk:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether there is sufficient memory available for the RAM disk using `free`
    command (a practical RAM disk will need to be smaller than the amount of free
    memory):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `mount` to mount a `tmpfs` filesystem at the desired mount point, giving
    the target size as a mount option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the RAM disk is no longer needed, unmount the filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever we access data on a hard drive, its motors must first spin up the storage
    platters and position the magnetic head at the correct location. These mechanical
    actions make access painfully slow compared to accessing data already resident
    in system memory (RAM). Exact measurements depend on the individual system and
    its hardware, but disk access takes somewhere in the neighborhood of 10 milliseconds
    or 10,000,000 nanoseconds. Memory access only takes about 200 nanoseconds, so
    it's safe to say accessing RAM is at least 10,000 times faster than disk even
    as a low estimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the RAM disk, you should first review the amount of free memory
    available on your system using the `free` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`free` command responds with how much memory is available and how much memory
    is in use. The `-h` argument formats the output in a human-readable format (listing
    the values in megabytes and gigabytes instead of bytes). We can see numbers for
    RAM, swap disks, and any special buffers used by the kernel, but we''re really
    interested in the amount of used and free memory listed by the `Mem` and `Swap`
    entries. A low amount of free memory and a high amount of used swap is an indication
    that we probably won''t have sufficient memory for a practical RAM disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With only 1 GB of RAM, this system has resources to support only a relatively
    small RAM disk
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we used `mount` to make the desired amount of memory available at the
    given mount point. The recipe used `/mnt`, but you''re free to use whatever mount
    point you see fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The invocation specifies `tmpfs` as the mount device and `/mnt` as the mount
    point. `-t` specifies the underlying filesystem, in this case, `tmpfs` and `-o`
    specifies our mount options for the filesystem. A list of possible options for
    the `tmpfs` filesystem can be found in the `mount` man page, but the most important
    option is `size`, which sets the desired size of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's possible to specify a value for `size` that's greater than the amount of
    available RAM but most of the time this isn't desirable. The extra data is marshaled
    to swap once RAM is exhausted and this will increase latency, negating the benefits
    of using a RAM disk in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, RAM disks serve as low latency temporary storage for volatile data.
    Because its data is stored in memory, the contents of the disk are lost when either
    the system shuts down or the disk is unmounted. Never store persistent data to
    your RAM disk.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following resources for more information about RAM disks:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mount` manual page (`man 8 mount`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a RAM disk in Linux ([http://www.jamescoyle.net/how-to/943-create-a-ram-disk-in-linux](http://www.jamescoyle.net/how-to/943-create-a-ram-disk-in-linux))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is `/dev/shm` and its practical usage? ([http://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html](http://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RAID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you'll learn how to configure a redundant array of disks (RAID).
    Configuring an array of disks to provide redundant storage is an excellent way
    to protect your data from drive failures. For example, if your data resides on
    a single disk and that drive fails, then the data is lost. You'll have to replace
    the drive and restore the data from your latest backup. But if two disks are in
    a RAID-1 configuration, your data is mirrored and can still be accessed from the
    working drive when the other fails. The failure doesn't impact access to the data
    and you can replace the faulty drive at a more convenient time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a working CentOS system and elevated privileges. It assumes
    that at least two new disks have been installed (identified as `/dev/sdb` and
    `/dev/sdc`) and we will partition and configure them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a RAID:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `lsblk` to identify the new storage devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Launch `cfdisk` to partition the first drive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/image_05_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: cfdisk presents a user-friendly interface for partitioning storage devices
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To create a single partition that occupies the entire disk, use the left and
    right arrow keys to select `New` and press *Enter.* Then select `Primary` and
    accept the default size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Write` and confirm the action by typing `yes` when prompted. Select
    `Quit` to exit `cfdisk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 to 4 to partition the second drive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the `mdadm` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `mdadm -C` to create a new array using the two partitions. The following
    example creates a RAID-1 (mirroring) configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `-D` option to examine the RAID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Format the RAID using the XFS filesystem with `mkfs.xfs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mount the RAID for use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to configure disks to work together, especially when it
    comes to things like data mirroring, striping, and parity checking. Some configurations
    are implemented at the hardware level and others can be implemented using software.
    This recipe used `mdadm` to set up multiple disks in a RAID configuration, specifically
    RAID-1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Storage Networking Industry Association has standardized several different
    RAID configurations. Some of the more common configurations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RAID-0**: Data is distributed evenly across two or more disks. This configuration
    offers no redundancy, and the failure of a single disk in the array will result
    in data loss. However, it offers increased performance since data can be read
    and written to different disks simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAID-1**: Data is duplicated between disks. Write activity is slower because
    the same data must be written to each disk, but this configuration offers excellent
    redundancy; the data remains accessible as long as there is at least one functioning
    disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAID-5**: Blocks of data and parity information are split between two or
    more disks. If a member of the array fails, parity information on another disk
    can be used to reconstruct the missing data. Write performance is slower, but
    read performance is increased since data can be read simultaneously from different
    disks. This configuration can withstand the failure of a single disk, although
    the failure of a second disk will result in data loss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAID-6**: This configuration is similar to RAID-5, but maintains an extra
    parity block. The array can withstand two disk failures before data is lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other standard configurations as well (RAID-2, RAID-3, and so on),
    and even non-standard configurations, but these are rarely used in practice. As
    with everything in life, there are trade-offs between the different RAID configurations,
    and selecting the right configuration for you will depend on how you want to balance
    redundancy, fault-tolerance, and latency.
  prefs: []
  type: TYPE_NORMAL
- en: '`lsblk` prints information for the block devices (storage disks) attached to
    our CentOS system, and it should be relatively easy to identify the names of the
    new devices simply by looking at the drive sizes and lack of partitions. This
    recipe assumes that the new devices are `/dev/sdb` and `/dev/sdc`; you''ll need
    to use whatever is appropriate for your system when invoking the `cfdisk` and
    `mdadm` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Several unconfigured drives are installed on the system
  prefs: []
  type: TYPE_NORMAL
- en: A new primary partition is created on each disk that occupies its entire capacity.
    The recipe uses `cfdisk`, a program that offers a console-based graphical interface
    to manipulate partitions. However, there are other partitioning utilities installed
    in CentOS that you can use instead if you're comfortable with them, such as `fdisk`,
    `sfdisk`, and `parted`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the disks are partitioned, we''re ready to configure the RAID. The `mdadm`
    program used to set up and administer RAIDs is installed using `yum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`mdadm -C` creates a new RAID configuration and requires a name to identify
    it. `md0` is used in the recipe which results in creating the device `/dev/md/md0`.
    The other arguments describe the desired configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `-l` (a lower-case L) option specifies the standard RAID level, in this
    case 1 (the number `1`) represents RAID-1\. If you wanted to set up RAID-5 instead,
    you'd use `-l 5`. The `-n` option specifies the number of partitions the RAID
    will use, and then we list the partitions. The recipe configures two partitions,
    `/dev/sdb1` and `/dev/sdc1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mdadm -D` displays information for a given array that''s useful in examining
    the configuration and verifying its health. The output lists details such as the
    RAID level, available storage size, which partitions make up the array, whether
    any partitions/devices are failing, resync status, and other useful information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/image_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: mdadm displays the status of the new RAID configuration
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`mdadm -E` retrieves information for one or more partitions that make up the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**mdadm -E /dev/sdb1 /dev/sdc1**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the storage space is formatted with an XFS filesystem using the `mkfs.xfs`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the RAID-backed storage space is ready for use. The recipe demonstrates
    mounting it manually with the `mount` command, although you can also add an entry
    to `/etc/fstab` for the filesystem to be mounted automatically whenever the system
    boots up.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on setting up RAIDs, refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: The `cfdisk` manual page (`man 8 cfdisk`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mdadm` manual page (`man 8 mdadm`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mkfs.xfs` manual page (`man 8 mkfs.xfs`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux RAID Wiki: Linux RAID ([https://raid.wiki.kernel.org/index.php/Linux_Raid](https://raid.wiki.kernel.org/index.php/Linux_Raid))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mdadm Cheat Sheet ([http://www.ducea.com/2009/03/08/mdadm-cheat-sheet/](http://www.ducea.com/2009/03/08/mdadm-cheat-sheet/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to RAID ([http://www.tecmint.com/understanding-raid-setup-in-linux/](http://www.tecmint.com/understanding-raid-setup-in-linux/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard RAID levels ([https://en.wikipedia.org/wiki/Standard_RAID_levels](https://en.wikipedia.org/wiki/Standard_RAID_levels))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a device in a RAID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an array member fails, it's important to replace it as soon as possible
    because the failure of additional drives increases the chance of data loss. This
    recipe teaches you how to properly replace a bad drive and rebuild the array.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a CentOS system with administrative privileges provided
    by logging in with the `root` account or using `sudo`. It assumes that a RAID-1
    configuration has been set up as described in the previous recipe and the drive
    that will be replaced is `/dev/sdb`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to replace a failed disk in a RAID:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark the failed partition as faulty with `mdadm` using the `-f` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the partition from the RAID''s configuration with `-r`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Physically replace the faulty disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Partition the new drive with `cfdisk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `-a` option to add the partition to the RAID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's important to replace bad members as soon you become aware of the failure
    because, depending on the fault tolerance of your configuration, the failure of
    a second device may result in full data loss.
  prefs: []
  type: TYPE_NORMAL
- en: 'A member must be marked faulty before we can safely remove it, so the first
    step is to fail the partition. To do this, we used `mdadm`. The `-f` argument
    specifies the partition we want failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to remove the partition from the RAID, we used the `-r` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that the device is no longer in use, we can replace the physical drive.
    Whether the drive can be hot-swapped while the system is running or if a system
    shutdown is necessary depends on your hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the replacement partition was ready, we added it to the RAID with the
    `-a` argument. The RAID will begin to rebuild itself, distributing data and parity
    information to the new partition, as soon as the partition is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The last recipe showed how the `-D` (and `-E`) argument of `mdadm` is used
    to retrieve status information about the RAID. You can review the output to monitor
    the rebuild''s progress, but a more concise report is available via `/proc/mdstat`.
    The contents show the speed at which the rebuild is being processed and estimate
    the time it will take for it to complete. Using `watch` to repeatedly display
    `/proc/mdstat`, you can create a make-shift dashboard to monitor the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/image_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The estimated time for this RAID's rebuild to complete is about an hour and
    a half
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following resources for more information on replacing failed drives
    in a RAID:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mdadm` manual page (`man 8 mdadm`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a failed hard drive in a software RAID ([https://www.howtoforge.com/replacing_hard_disks_in_a_raid1_array](https://www.howtoforge.com/replacing_hard_disks_in_a_raid1_array))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Five tips to speed up RAID re-building and re-syncing ([http://www.cyberciti.biz/tips/linux-raid-increase-resync-rebuild-speed.html](http://www.cyberciti.biz/tips/linux-raid-increase-resync-rebuild-speed.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new LVM volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logical Volume Manager (LVM) abstracts data storage away from the physical hardware,
    which lets us configure the partitions on one or more physical drives to act as
    one logical device. We also have the freedom to later add or remove physical partitions
    and grow or shrink the logical device. This recipe show's you how to create a
    new LVM group and a logical device from the group's storage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a working CentOS system and elevated privileges. It assumes
    that at least two new disks have been installed (identified as `/dev/sdb` and
    `/dev/sdc`) and we will partition and configure them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform these steps to set up a new LVM group and create a volume:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `lsblk` to identify the new storage devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can set up LVM with RAID storage as well. Skip to step 5 and replace the
    partitions with RAID devices (for example, `/dev/md/md0`) in the given commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Launch `cfdisk` to partition the first drive and create a single partition
    that occupies the entire disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat step 2 to partition the second drive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `pvcreate` to register the new partitions as physical volumes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the physical volumes are listed in the output of `pvs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `vgcreate`, group the physical volumes to form a volume group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the group is listed in the output of `vgs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `lvcreate`, create a logical volume from the storage pool provided by
    the volume group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Format the volume using the XFS filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mount the volume for use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LVM is another approach to configure multiple storage units to work together,
    focusing on pooling their resources together in a flexible way. These units can
    be disk partitions, as well as RAID arrays, and so the generic term *volume* is
    used.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe starts with the assumption that we have two new disks as our storage
    volumes and provides steps for identifying the devices and partitioning them using
    `lsblk` and `cfdisk`. It uses `/dev/sdb` and `/dev/sdc` as the devices, but you
    should use whatever is appropriate for your system. Once the disks are partitioned,
    we're ready to register the partitions as physical volumes with `pvcreate`. The
    term *physical volume* describes storage available as a physical partition or
    RAID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Next, the physical volumes are grouped as a volume group using `vgcreate`. The
    recipe created a volume group name `vg0` using the `sdb1` and `sdc2` partitions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The desired name for the volume group is passed first to `vgcreate`, followed
    by the physical volumes we want to group together. If `sdb1` and `sdc1` both have
    a capacity of 1 TB each, their storage is combined and the volume group will have
    2 TB. If we were to later add a 500 GB volume to the group, the group's storage
    capacity would increase to 2.5 TB.
  prefs: []
  type: TYPE_NORMAL
- en: The `pvs` and `vgs` commands return basic information about physical volumes
    or volume groups, respectively, and the recipe uses them to verify that each registration
    was successful. `pvs` reports the physical volumes that are registered and which
    group they are assigned to, any attributes, and their storage capacity. `vgs`
    lists the groups, the number of physical volumes that make up each group's pool,
    the number of logical volumes using storage from the group, and the groups' capacities.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: pvs and vgs are used to review the status of physical volumes and volume groups
  prefs: []
  type: TYPE_NORMAL
- en: 'A new logical volume is created from the pooled storage of the volume group
    using the `lvcreate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `-n` option provides the name for the logical volume and `-L` provides the
    amount of storage to allocate the volume from the pool. The final argument is
    the name of the volume group used to support the volume. The values given in the
    recipe's example creates a volume named `myvol` with a capacity of 500 GB backed
    by the `vg0` group. Logical volumes are organized under `/dev` by group, so the
    volume is available as `/dev/vg0/myvol`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the volume is formatted with the XFS filesystem using `mkfs.xfs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The logical volume is now ready for use and can be mounted manually with `mount`
    and/or an entry can be made in /`etc/fstab` to mount the volume automatically
    at system boot time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on getting started with LVM, refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: The `lvcreate` manual page (`man 8 lvcreate`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pvcreate` manual page (`man 8 pvcreate`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vgcreate` manual page (`man 8 vgcreate`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux Partition HOWTO ([http://tldp.org/HOWTO/Partition/index.html](http://tldp.org/HOWTO/Partition/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LVM made easy ([http://www.tuxradar.com/content/lvm-made-easy](http://www.tuxradar.com/content/lvm-made-easy))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage LVM volumes with System Storage Manager ([http://xmodulo.com/manage-lvm-volumes-centos-rhel-7-system-storage-manager.html](http://xmodulo.com/manage-lvm-volumes-centos-rhel-7-system-storage-manager.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing an existing LVM volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flexibility of LVM allows us to allocate the pooled storage of physical
    volumes however we see fit. This recipe shows us how to delete a logical volume
    and free its storage back to the volume group for use by other logical volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a CentOS system with administrative privileges provided
    by logging in with the `root` account or using `sudo`. It assumes that a logical
    volume has been created as described in the preceding recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to remove an LVM volume:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unmount the filesystem with `umount`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `/etc/fstab` and verify that there isn't an entry to automatically mount
    the filesystem. If there is, remove the entry, save your changes, and close the
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `lvremove` to delete the logical volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Review the output of `vgs` to verify the removal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting a volume frees its storage back to the volume group, which can then
    be used to create new logical volumes or support growing an existing volume. This
    recipe taught you how to destroy a logical volume using the `lvremove` command.
  prefs: []
  type: TYPE_NORMAL
- en: Because a volume can't be freed if it's in use, the first step is to make sure
    that its filesystem is unmounted. If the filesystem is mounted automatically,
    its entry in `/etc/fstab` should also be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `lvremove` is invoked with the name of the logical volume to free it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can delete all of the volumes from a pool by providing just the pool name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**lvremove vg0**`'
  prefs: []
  type: TYPE_NORMAL
- en: The recipe suggests checking the output of `vgs` to verify that the logical
    volume was removed. In the output, the number of logical volumes under the `#LV`
    column should have decreased and the amount of free space under the `VFree` column
    increased appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following resources for more information on removing a volume:'
  prefs: []
  type: TYPE_NORMAL
- en: The `lvremove` manual page (`man 8 lvremove`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vgs` manual page (`man 8 vgs`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding storage and growing an LVM volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The size of logical volumes doesn't need to be fixed and we're free to allocate
    more storage for one from its volume group. This recipe teaches us how to add
    more storage to the group and then grow the size of the logical volume to take
    advantage of it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a CentOS system with administrative privileges provided
    by logging in with the `root` account or using `sudo`. It assumes that a new disk
    has been installed and partitioned (identified as `/dev/sdd1`) and a logical group
    and volume have been configured as described in previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add storage and increase the size of an LVM volume:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Register the new partition as a physical volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Review the output of `pvs` to confirm that the volume was registered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `vgextend` to add the physical volume to the desired volume group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Review the output of `vgs` to confirm that the volume was added to the group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `lvextend` to increase the size of the desired logical volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Review the output of `lvs` to confirm the new capacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expand the filesystem with `xfs_grow` to use the new capacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: An XFS filesystem must be mounted to expand its size; if it's not already mounted,
    you'll need to do so before executing `xfs_grow`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Confirm the new size of the filesystem using `df`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The recipe assumed that a new partition has been prepared, which was then registered
    as a physical volume using the `pvcreate` command. Then the physical volume was
    assigned to the `vg0` volume group using `vgextend`, increasing the group''s available
    storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`lvextend` was invoked to grow the size of a logical volume, `vg0/myvol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `-L` argument specifies the amount of storage to allocate from the pool.
    It's value can be an absolute value, for example, `-L 500G`, in which case the
    volume will be resized to have that much capacity. A relative value can also be
    used to increase the volume's current capacity by some amount. The recipe used
    `-L+500G` to grow the size of the logical volume by an additional 500 GB.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will receive an error if you provide a value for `-L` less than the logical
    volume''s current capacity because `lvextend` only increases the capacity of a
    volume. The `lvreduce` command is used to reduce the size of logical volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**lvreduce vg0/myvol -L 500GB**`'
  prefs: []
  type: TYPE_NORMAL
- en: Given a straight value, `-L` specifies the total capacity for the volume. In
    the preceding command, the capacity for `vg0/myvol` is reduced to `500GB`. Given
    a relative value, for example `-L-500GB`, `lvreduce` reduces the volume's capacity
    by the specified amount.
  prefs: []
  type: TYPE_NORMAL
- en: When finished, the logical volume's capacity can be confirmed by inspecting
    the output of the `lvs` command. The command reports the logical volumes that
    exist and to which group they are assigned, their attributes, storage capacity,
    and other statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The capacity of the logical volume has increased but the filesystem needs to
    be resized to use it
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the filesystem needs to be expanded to make use of the additional space
    available to it with `xfs_growfs`. Filesystems must be mounted for the utility
    to work, and the recipe assumes that it's mounted at `/mnt`. The `-d` argument
    instructs `xfs_grow` to increase the size of the filesystem as much as possible
    (the entire size of the volume).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can give a specific size with `-D`. Its value is given in
    block counts, so some math will be required to grow the filesystem to the desired
    size. For example, let''s say you have a 1 TB filesystem and the block size is
    4,096 bytes (the default). The block count will be 268,435,456 blocks. If you
    want to grow the filesystem an additional 500 GB, the target block count will
    be `399507456`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To make life a little easier, here''s a table that presents block counts for
    common sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These block counts can be used with xfs_growfs to grow an XFS filesystem
  prefs: []
  type: TYPE_NORMAL
- en: While it's possible to reduce the size of a logical volume, it's only possible
    to grow an XFS filesystem. If you want to reduce the size of an XFS-supported
    volume you'll have to move its data to a safe location, remove and recreate the
    logical volume with a smaller size, and later move the data back.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following resources for more information on growing an LVM volume:'
  prefs: []
  type: TYPE_NORMAL
- en: The `xfs_growfs` manual page (`man 8 xfs_growfs`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux guide to the XFS filesystem ([http://landoflinux.com/linux_xfs_filesystem_introduction.html](http://landoflinux.com/linux_xfs_filesystem_introduction.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend/Reduce LVM's in Linux ([http://www.tecmint.com/extend-and-reduce-lvms-in-linux/](http://www.tecmint.com/extend-and-reduce-lvms-in-linux/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to grow an XFS-formatted disk ([http://superuser.com/questions/1000092/how-to-grow-xfs-formated-disk/1001486#1001486](http://superuser.com/questions/1000092/how-to-grow-xfs-formated-disk/1001486#1001486))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with LVM snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A logical volume, also called a linear volume, is just one type of volume we
    can create; LVM also lets us create snapshot volumes. A snapshot volume is associated
    with a logical volume and keeps track of changes made to the logical volume's
    data. We can then merge the snapshot back into the logical volume to roll back
    the data. This recipe will show you how to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a CentOS system with administrative privileges provided
    by logging in with the `root` account or using `sudo`. It assumes that a logical
    volume has been configured and sufficient storage exists in its volume group for
    the snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following commands show you how to work with LVM snapshots. Before you begin,
    you should verify that there is sufficient storage available in the volume group
    to support the snapshot using `vgs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `lvcreate -s` to create a snapshot volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A snapshot volume may be deleted using `lvremove`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A snapshot volume may be mounted and accessed with `mount`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To restore a logical volume to the state it was in when the snapshot was made,
    make sure neither are mounted and use `lvconvert`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe presented commands to create a snapshot volume which then tracks
    the changes made to a logical volume and to merge the snapshot back into the logical
    volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Snapshots are created using the `lvcreate` command with the `-s` flag. `-n`
    gives the name for the snapshot and `-L` specifies how much storage will be allocated
    for it from the volume group. The final argument is the logical volume the snapshot
    is created from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The values given in the example create a snapshot of `vg0/myvol` named `myvolsnap`
    with a capacity of 100 MB. Storage for the snapshot volume is allocated from the
    same group as its logical volume so that there should be sufficient storage to
    support the snapshot. Luckily, snapshot volumes don't copy all of the data from
    the original volume. Instead, they use a copy-on-write strategy where only the
    differences are recorded to the snapshot when the data is modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the deltas exceed the snapshot volume''s capacity, LVM won''t be able to
    continue to record changes and the snapshot will no longer be valid. For this
    reason, you should periodically monitor the snapshot''s storage usage and either
    resize the snapshot or discard the snapshot and create a new one with a larger
    capacity if necessary. As with other volumes, `lvremove` is used to delete snapshot
    volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A snapshot can also be mounted and accessed like other logical volumes. LVM
    transparently reads unmodified data from the original logical volume so that the
    data appears as a full copy. Depending on the your reasons for creating a snapshot,
    you may want to use the `ro` mount option to mount the volume read-only to prevent
    inadvertent changes from being introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '`lvconvert` is used to change a volume''s type and other characteristics. You
    should unmount both the logical and snapshot volumes before calling `lvconvert`
    so that the merge process can begin immediately. Otherwise, LVM will schedule
    the process to begin after both have been unmounted and either the logical or
    snapshot volume is mounted again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To revert the logical volume''s data, we target its snapshot volume and use
    the `--merge` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Merging the snapshot volume's data to its logical volume rolls back the changes
    to the logical volume's data, basically restoring it to the state it was in at
    the time the snapshot was created. When finished, the snapshot is automatically
    deleted. `-v` puts `lvconvert` into verbose mode, which is useful to monitor its
    progress and to know when the merge is complete and the snapshot has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following resources for more information on working with snapshots:'
  prefs: []
  type: TYPE_NORMAL
- en: The `lvconvert` manual page (`man 8 lvconvert`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to take a snapshot logical volume and restore ([http://www.tecmint.com/take-snapshot-of-logical-volume-and-restore-in-lvm/](http://www.tecmint.com/take-snapshot-of-logical-volume-and-restore-in-lvm/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to take volume snapshots ([http://www.unixarena.com/2013/08/linux-lvm-how-to-take-volume-snapshot.html](http://www.unixarena.com/2013/08/linux-lvm-how-to-take-volume-snapshot.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
