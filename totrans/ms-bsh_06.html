<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Iterations</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>What we have seen so far enables us to interact with the user, process the input, and provide some output based on conditions we imposed. All of this is fine; and if the user calls our scripts with some arguments, we can store them in an array and process given that we know how many options they are passing to the command line. We must know in advance how many items the user will provide us with, otherwise we will lose those in excess. This is where an iterative construct comes in play. Since we already saw some examples, it can enumerate the content of an array and let us process its content without knowing in advance the number of items stored. In this chapter, we will have a look at how to use the <kbd class="calibre9">for</kbd> loop and <em class="calibre20">while/until</em> loop to get a strong grip on the data the user provides us with.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The for loop</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>The <kbd class="calibre9">for</kbd> loop is one of the most used structures when it comes to a Bash script and enables us to repeat one of more actions on each single item in a list. Its basic structure can be outlined as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">for placeholder in list_of_items<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  action_1 $placeholder<br class="title-page-name"/></strong><strong class="calibre2">  action_2 $placeholder<br class="title-page-name"/></strong><strong class="calibre2">  action_n $placeholder</strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>So, we use a placeholder, which will take at each round of the loop one of the values in the list of items, which will then be processed in the <kbd class="calibre9">do</kbd> section. Once all the list is scanned through, the loop is done, and we exit it. Let's start with a simple and nice example:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">for i in 1 2 3 4 5<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  echo "$i"</strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>And now let's execute it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./counter-simple.sh <br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">4<br class="title-page-name"/></strong><strong class="calibre2">5</strong>
</pre>
<p class="calibre1"><span><span>Actually, quite straightforward, but notice that the list can be the result of any kind of operations:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">for i in {10..1..2}<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  echo "$i"</strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>In this case, we used a brace expansion to get a countdown with a step of 2:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./counter-brace.sh <br class="title-page-name"/></strong><strong class="calibre2">10<br class="title-page-name"/></strong><strong class="calibre2">8<br class="title-page-name"/></strong><strong class="calibre2">6<br class="title-page-name"/></strong><strong class="calibre2">4<br class="title-page-name"/></strong><strong class="calibre2">2</strong>
</pre>
<p class="calibre1"><span><span>We can have a <kbd class="calibre9">for</kbd> loop on one line as well:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ for i in *; do echo "Found the following file: $i"; done<br class="title-page-name"/></strong><strong class="calibre2">Found the following file: counter-brace.sh<br class="title-page-name"/></strong><strong class="calibre2">Found the following file: counter-simple.sh</strong>
</pre>
<p class="calibre1"><span><span>Nice, isn't it? Now let's do something a bit more complex. Let's say we want to write the following list:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Belfast is in UK<br class="title-page-name"/></strong><strong class="calibre2">Redwood is in USA<br class="title-page-name"/></strong><strong class="calibre2">Milan is in ITALY<br class="title-page-name"/></strong><strong class="calibre2">Paris is in FRANCE</strong>
</pre>
<p class="calibre1"><span><span>How can we do this? Let's try with a simple loop and see what happens:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">for cities in Belfast UK Redwood USA Milan ITALY Paris FRANCE<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  echo "$cities is in $cities"<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">exit 0</strong>
</pre>
<p class="calibre1"><span><span>Now let's run it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:$ ./for-pair.sh <br class="title-page-name"/></strong><strong class="calibre2">Belfast is in Belfast<br class="title-page-name"/></strong><strong class="calibre2">UK is in UK<br class="title-page-name"/></strong><strong class="calibre2">Redwood is in Redwood<br class="title-page-name"/></strong><strong class="calibre2">USA is in USA<br class="title-page-name"/></strong><strong class="calibre2">Milan is in Milan<br class="title-page-name"/></strong><strong class="calibre2">ITALY is in ITALY<br class="title-page-name"/></strong><strong class="calibre2">Paris is in Paris<br class="title-page-name"/></strong><strong class="calibre2">FRANCE is in FRANCE</strong>
</pre>
<p class="calibre1"><span><span>Not exactly what we wanted. Well, not at all because the script does not know how to tell what is a city, what is a nation, and what goes with what. We have to find a way to qualify our items; and we can do it using their position. Here we have the set built-in, which enables us to assign the content of a variable to a positional parameter. We will just use it in a fancy way:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">for cities in "Belfast UK" "Redwood USA" "Milan ITALY" "Paris FRANCE"<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  set -- $cities<br class="title-page-name"/></strong><strong class="calibre2">  echo "$1 is in $2"<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">exit 0</strong>
</pre>
<p class="calibre1"><span><span>And now let's run the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./for-pair-set.sh <br class="title-page-name"/></strong><strong class="calibre2">  Belfast is in UK<br class="title-page-name"/></strong><strong class="calibre2">  Redwood is in USA<br class="title-page-name"/></strong><strong class="calibre2">  Milan is in ITALY<br class="title-page-name"/></strong><strong class="calibre2">  Paris is in FRANCE</strong>
</pre>
<p class="calibre1"><span><span>This is much better, and it is exactly what we were looking for; but how did we reach our goal? The first step was grouping the related items into double quotes, so for instance, <kbd class="calibre9">Belfast</kbd> goes with <kbd class="calibre9">UK</kbd>. The tricky part was using the set built-in with <kbd class="calibre9">--</kbd>, which forces the values following it to be assigned to positional parameters even though they start with a dash and if no arguments are given the positional parameters get unset. So, since we have groups of two: city and nation, we have <kbd class="calibre9">$1</kbd> and <kbd class="calibre9">$2</kbd>; one holding the city and the other having the nation. From there on, it was just a matter of printing the positional parameters. We can go even further without specifying a list:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat for-pair-input.sh <br class="title-page-name"/></strong><strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">i=0<br class="title-page-name"/></strong><strong class="calibre2">for cities <br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  echo "City $((i++)) is: $cities"<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">exit 0</strong>
</pre>
<p class="calibre1"><span><span>Then, we can provide the arguments on the command line; the script will take its input from <kbd class="calibre9">$@)</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./for-pair-input.sh <br class="title-page-name"/>Belfast Redwood Milan Paris<br class="title-page-name"/></strong><strong class="calibre2">City 0 is: Belfast<br class="title-page-name"/></strong><strong class="calibre2">City 1 is: Redwood<br class="title-page-name"/></strong><strong class="calibre2">City 2 is: Milan<br class="title-page-name"/></strong><strong class="calibre2">City 3 is: Paris</strong>
</pre>
<p class="calibre1"><span><span>As we discussed before, the list can be anything: a variable, a brace expression, fixed values, the result of a command substitution, anything that creates a list of value through which we iterate:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~/$ cat counter-function.sh <br class="title-page-name"/></strong><strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">counter()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">  echo {10..0..2}<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/></strong><strong class="calibre2">for i in $(counter)<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  echo "$i"<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>In this example, the list is provided by the counter function, which prints out the result of a brace expansion. We then take the value returned by the function through the <kbd class="calibre9">echo</kbd> command and use it as a list to iterate on:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./counter-function.sh <br class="title-page-name"/></strong><strong class="calibre2">10<br class="title-page-name"/></strong><strong class="calibre2">8<br class="title-page-name"/></strong><strong class="calibre2">6<br class="title-page-name"/></strong><strong class="calibre2">4<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">0</strong>
</pre>
<p class="calibre1"><span><span>Do not forget the C-style:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat c-for.sh <br class="title-page-name"/></strong><strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">for ((i=20;i &gt; 0;i--))<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">if (( i % 2 == 0 ))<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">  echo "$i is divisible by 2"</strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/></strong><strong class="calibre2">exit 0</strong>
</pre>
<p class="calibre1"><span><span>So, we have a decreasing counter:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./c-for.sh <br class="title-page-name"/></strong><strong class="calibre2">20 is divisible by 2<br class="title-page-name"/></strong><strong class="calibre2">18 is divisible by 2<br class="title-page-name"/></strong><strong class="calibre2">16 is divisible by 2<br class="title-page-name"/></strong><strong class="calibre2">14 is divisible by 2<br class="title-page-name"/></strong><strong class="calibre2">12 is divisible by 2<br class="title-page-name"/></strong><strong class="calibre2">10 is divisible by 2<br class="title-page-name"/></strong><strong class="calibre2">8 is divisible by 2<br class="title-page-name"/></strong><strong class="calibre2">6 is divisible by 2<br class="title-page-name"/></strong><strong class="calibre2">4 is divisible by 2<br class="title-page-name"/></strong><strong class="calibre2">2 is divisible by 2</strong>
</pre>
<p class="calibre1"><span><span>What we saw so far allows us to cycle through structures of data and work on them as long as we have some items to process, but we do not know yet how to work on something until a condition is met or not, so this is the topic for the next paragraph where we will see how to keep our script alive until something happens.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Let's do something while, until…</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>The <kbd class="calibre9">for</kbd> loop is a great option to enumerate the contents provided by the user, but it is not so handy when it comes to handling a number of options whose number is not known beforehand. In this case, we would find more interesting kinds of loops, which would allow us to cycle until a certain condition is met or while a certain situation persists, for instance, while the user inputs something or until a threshold is met. So, let's see which constructs can help us:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">while condition<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  command_1<br class="title-page-name"/></strong><strong class="calibre2">  command_2<br class="title-page-name"/></strong><strong class="calibre2">  command_n<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>At a first glance, the difference between the <kbd class="calibre9">while</kbd> and <kbd class="calibre9">for</kbd> loops is evident: the latter is based on a placeholder that each time takes a value from a list and we work on that value, the former is triggered while conditions last. Let's make an example starting with a <kbd class="calibre9">for</kbd> loop:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">for i in 1 2 3 4 5<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  echo "$i"<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>It is a simple counter, from 1 to 5, and we already saw it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./counter-simple.sh <br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">4<br class="title-page-name"/></strong><strong class="calibre2">5</strong>
</pre>
<p class="calibre1"><span><span>Now, let's rewrite it using a <kbd class="calibre9">while</kbd> loop:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">i=1<br class="title-page-name"/></strong><strong class="calibre2">while (( i &lt;= 5))<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  echo "$i"</strong><strong class="calibre2">((i++))<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>Let's see if the output is the same:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./while-simple.sh <br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">4<br class="title-page-name"/></strong><strong class="calibre2">5<br class="title-page-name"/></strong>
</pre>
<p class="calibre1"><span><span>Well, the output is exactly the same. Now, we will speak about another loop constructor, the <kbd class="calibre9">until</kbd> loop, which cycles on a list until a condition is met. Its structure is as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">until condition<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  command_1<br class="title-page-name"/></strong><strong class="calibre2">  command_2<br class="title-page-name"/></strong><strong class="calibre2">  command_n<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>The structure is similar to the <kbd class="calibre9">while</kbd> loop, just the conditions change: <kbd class="calibre9">while</kbd> lasts as long as a condition is met, <kbd class="calibre9">until</kbd> lasts until a condition is met. To better understand the difference, let's rewrite the example in the <kbd class="calibre9">until</kbd> form:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">i=1<br class="title-page-name"/></strong><strong class="calibre2">until (( i &gt; 5))<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">echo "$i"</strong><strong class="calibre2">((i++))</strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>As we can see from the code, until we do not reach a value of <kbd class="calibre9">i</kbd> higher than <kbd class="calibre9">5</kbd>, we print its value and increase it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./until-simple.sh </strong><strong class="calibre2">1</strong><strong class="calibre2">2</strong><strong class="calibre2">3</strong><strong class="calibre2">4</strong><strong class="calibre2">5</strong>
</pre>
<p class="calibre1"><span><span>Looks familiar, doesn't it? So we can recap the three kinds of loop under the following conditions:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">for</kbd> iterates on the values taken from a list</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">while</kbd> executes the loop until the condition is <kbd class="calibre9">false</kbd></span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">until</kbd> executes the loop while the condition is <kbd class="calibre9">false</kbd></span></span></li>
</ul>
<p class="calibre1"> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exiting the loop with break and continue</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>This gives us some nice opportunities, such as infinite loops:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">while true ; do echo "Hello" ; done</strong>
</pre>
<p class="calibre1"><span><span>Since <kbd class="calibre9">true</kbd> always evaluates as true, the condition is always verified so we have an infinite execution of the <kbd class="calibre9">do/done</kbd> clause; press <em class="calibre20">Ctrl+ C</em> to exit from the loop. An infinite loop looks like something nasty, but it opens a new scenario for our scripts, since we can make them run or wait for something for as long as we want. Actually, if we do not use a couple of loop control commands: <kbd class="calibre9">break</kbd> will exit the loop and <kbd class="calibre9">continue</kbd> will restart it, jumping over the remaining commands. Let's see an example of creating a hypothetical backup program menu:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">while true<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  clear<br class="title-page-name"/></strong><strong class="calibre2">  cat &lt;&lt;MENU<br class="title-page-name"/></strong><strong class="calibre2">  BACKUP UTIL v 1.0<br class="title-page-name"/></strong><strong class="calibre2">  ------------------<br class="title-page-name"/></strong><strong class="calibre2">  1. Backup a file/directory<br class="title-page-name"/></strong><strong class="calibre2">  2. Restore a file/directory<br class="title-page-name"/></strong><strong class="calibre2">  0. Quit<br class="title-page-name"/></strong><strong class="calibre2">  ------------------<br class="title-page-name"/></strong><strong class="calibre2">MENU<br class="title-page-name"/></strong><strong class="calibre2">  read -p "Please select an option, 0 or Q to exit: " option<br class="title-page-name"/></strong><strong class="calibre2">  case $option in<br class="title-page-name"/></strong><strong class="calibre2">  1 | [Bb])<br class="title-page-name"/></strong><strong class="calibre2">  echo "You chose the first option, Backup"<br class="title-page-name"/></strong><strong class="calibre2">  sleep 3<br class="title-page-name"/></strong><strong class="calibre2">  ;;<br class="title-page-name"/></strong><strong class="calibre2">  2 | [Rr]) <br class="title-page-name"/></strong><strong class="calibre2">  echo "You chose the second option, Restore"<br class="title-page-name"/></strong><strong class="calibre2">  sleep 3<br class="title-page-name"/></strong><strong class="calibre2">  ;;<br class="title-page-name"/></strong><strong class="calibre2">  0 | [Qq])<br class="title-page-name"/></strong><strong class="calibre2">  echo "You chose the third options, Quit, so we quit!"<br class="title-page-name"/></strong><strong class="calibre2">  break<br class="title-page-name"/></strong><strong class="calibre2">  ;;<br class="title-page-name"/></strong><strong class="calibre2">  *)<br class="title-page-name"/></strong><strong class="calibre2">  echo "Not a valid choice, please select an option..."<br class="title-page-name"/></strong><strong class="calibre2">  sleep 3<br class="title-page-name"/></strong><strong class="calibre2">  ;;<br class="title-page-name"/></strong><strong class="calibre2">  esac<br class="title-page-name"/></strong><strong class="calibre2">done </strong>
</pre>
<p class="calibre1"><span><span>Let's see what we did. We opened a <kbd class="calibre9">while true</kbd> loop, so whatever is inside it will be executed over and over. We then used a <em class="calibre20">here</em> document to have a nice menu to display to the user and a <kbd class="calibre9">read</kbd> option to ask the user for a choice to evaluate the input. Any choice except for <kbd class="calibre9">quit</kbd> will do nothing but display a message and wait for 3 seconds, after which the cycle restarts, clearing the screen and showing the menu once again (this is the reason for the <kbd class="calibre9">sleep</kbd> command). The only exception is if the customer hits <kbd class="calibre9">0</kbd>,<kbd class="calibre9">Q</kbd>, or <kbd class="calibre9">q</kbd>: in this case a message is displayed and the loop is exited:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./menu.sh <br class="title-page-name"/></strong><strong class="calibre2">  BACKUP UTIL v 1.0<br class="title-page-name"/></strong><strong class="calibre2">  ------------------<br class="title-page-name"/></strong><strong class="calibre2">  1. Backup a file/directory<br class="title-page-name"/></strong><strong class="calibre2">  2. Restore a file/directory<br class="title-page-name"/></strong><strong class="calibre2">  0. Quit<br class="title-page-name"/></strong><strong class="calibre2">  ------------------<br class="title-page-name"/></strong><strong class="calibre2">  Please select an option, 0 or Q to exit: 0<br class="title-page-name"/></strong><strong class="calibre2">  You chose the third options, Quit, so we quit!</strong>
</pre>
<p class="calibre1"><span><span>Notice that we exit a loop, not necessarily the entire script. This is a nice old style menu, which has its advantages over graphical ones: easier to code, easier to maintain, and less resources consumed, but most of all, it does not require a graphical monitor to be displayed: it works well on character monitors and over serial connections. For the <kbd class="calibre9">continue</kbd> instruction, the action flow is quite different, since it resumes iteration for the main <kbd class="calibre9">for</kbd>, <kbd class="calibre9">while</kbd>, <kbd class="calibre9">until</kbd>, or <kbd class="calibre9">select</kbd> loop. When used in a <kbd class="calibre9">for</kbd> loop the variable takes the value of the next element in the list of conditions:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat for-continue.sh <br class="title-page-name"/></strong><strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">for i in {0..10}<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  if (( i == 4 ))<br class="title-page-name"/></strong><strong class="calibre2">  then<br class="title-page-name"/></strong><strong class="calibre2">  continue<br class="title-page-name"/></strong><strong class="calibre2">  else<br class="title-page-name"/></strong><strong class="calibre2">  echo $i<br class="title-page-name"/></strong><strong class="calibre2">  fi<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">exit 0</strong>
</pre>
<p class="calibre1"><span><span>Our code will enumerate from 0 to 10 and print the values met, except when it hits the number 4: in this case, the <kbd class="calibre9">continue</kbd> will force the <kbd class="calibre9">for</kbd> loop to skip the value and proceed from 5:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./for-continue.sh <br class="title-page-name"/></strong><strong class="calibre2">0<br class="title-page-name"/></strong><strong class="calibre2">1<br class="title-page-name"/></strong><strong class="calibre2">2<br class="title-page-name"/></strong><strong class="calibre2">3<br class="title-page-name"/></strong><strong class="calibre2">5<br class="title-page-name"/></strong><strong class="calibre2">6<br class="title-page-name"/></strong><strong class="calibre2">7<br class="title-page-name"/></strong><strong class="calibre2">8<br class="title-page-name"/></strong><strong class="calibre2">9<br class="title-page-name"/></strong><strong class="calibre2">10</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Time to give our client a menu</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>In this chapter, we are looking at different ways to play with loops in order to work on the pieces of information the user provides us with. From a simple menu, we moved onto something fancier and better looking; and now, it is time to take a step further and have a look at the <kbd class="calibre9">select</kbd> construct whose task is to let us create menu in an effortless way. Its syntax is similar to the for construct:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">select placeholder [in list]<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">command_1<br class="title-page-name"/></strong><strong class="calibre2">command_2<br class="title-page-name"/></strong><strong class="calibre2">command_n<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>So, as we can see, this construct is very similar to <kbd class="calibre9">for</kbd> and sports a list, which gets expanded on the standard error in a series of elements preceded by a number. If we omit the <kbd class="calibre9">in list</kbd> part, the list gets constructed from the positional parameters given on the command line, such as if we used <kbd class="calibre9">[in $@]</kbd>. Once the elements in the list are printed, a <kbd class="calibre9">PS3</kbd> prompt is shown and a line from the <kbd class="calibre9">stdin</kbd> is read and stored into the REPLY variable. If something is read on the line, each word is displayed along with a number; if the line is empty the prompt is displayed again, but <kbd class="calibre9">if</kbd> and <kbd class="calibre9">EOF</kbd> characters are given as an input (<em class="calibre20">Ctrl+D</em>) the loop is exited. As a shortcut, you can use <kbd class="calibre9">break</kbd> to exit. Let's see an example:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">echo "Just select the fruit you like:"<br class="title-page-name"/></strong><strong class="calibre2">select fruit in apple banana orange mango<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">    echo "You picked $fruit (Option $REPLY)"<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>This easy script will show you a menu of choices taken from the <kbd class="calibre9">in list</kbd> and wait for a selection. Once the user inputs a selection, it is echoed and the loop starts again showing the available options:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./simple-select.sh <br class="title-page-name"/></strong><strong class="calibre2">Just select the fruit you like:<br class="title-page-name"/></strong><strong class="calibre2">1) apple<br class="title-page-name"/></strong><strong class="calibre2">2) banana<br class="title-page-name"/></strong><strong class="calibre2">3) orange<br class="title-page-name"/></strong><strong class="calibre2">4) mango<br class="title-page-name"/></strong><strong class="calibre2">#? 3<br class="title-page-name"/></strong><strong class="calibre2">You picked orange (Option 3)<br class="title-page-name"/></strong><strong class="calibre2">#? o<br class="title-page-name"/></strong><strong class="calibre2">You picked (Option o)<br class="title-page-name"/></strong><strong class="calibre2">#? pear<br class="title-page-name"/></strong><strong class="calibre2">You picked (Option pear)<br class="title-page-name"/></strong><strong class="calibre2">#? </strong>
</pre>
<p class="calibre1"><span><span>As we can see, there is no control on what the user provided us with, so this is something we have to implement by ourselves. Also, the prompt is the least sexy thing we have ever seen, but we can alter it giving a value to the <kbd class="calibre9">PS3</kbd> variable, so just add </span></span><span><span><kbd class="calibre9">PS3="Your choice is: "</kbd> </span></span><span><span>right below the sha-bang. Save and rerun the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Just select the fruit you like:<br class="title-page-name"/></strong><strong class="calibre2">Enter the number of the file you want to protect:<br class="title-page-name"/></strong><strong class="calibre2">1) apple<br class="title-page-name"/></strong><strong class="calibre2">2) banana<br class="title-page-name"/></strong><strong class="calibre2">3) orange<br class="title-page-name"/></strong><strong class="calibre2">4) mango<br class="title-page-name"/></strong><strong class="calibre2">Your choice is: </strong>
</pre>
<p class="calibre1"><span><span>Way better now. Great, now another small issue: the script never exits, so how can we force it to exit? Let's see some interesting modifications:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ cat case-select.sh <br class="title-page-name"/></strong><strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">PS3="Your choice is: "<br class="title-page-name"/></strong><strong class="calibre2">echo "Just select the fruit you like:"<br class="title-page-name"/></strong><strong class="calibre2">select fruit in apple banana orange mango<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  case "$fruit" in<br class="title-page-name"/></strong><strong class="calibre2">            mango)<br class="title-page-name"/></strong><strong class="calibre2">               echo "You chose $fruit, so we wanna break free!"<br class="title-page-name"/></strong><strong class="calibre2">               break<br class="title-page-name"/></strong><strong class="calibre2">               ;;<br class="title-page-name"/></strong><strong class="calibre2">           *)<br class="title-page-name"/></strong><strong class="calibre2">               echo "You chose $fruit"<br class="title-page-name"/></strong><strong class="calibre2">               ;;<br class="title-page-name"/></strong><strong class="calibre2">  esac<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>We nested a case construct inside the <kbd class="calibre9">select</kbd> so that we can evaluate the choice given by the user and react accordingly. In any case, we just print out the choice made by the user, but if he selects <kbd class="calibre9">4</kbd>, we print the choice and exit with <kbd class="calibre9">break</kbd>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./case-select.sh<br class="title-page-name"/></strong><strong class="calibre2">Just select the fruit you like:<br class="title-page-name"/></strong><strong class="calibre2">1) apple<br class="title-page-name"/></strong><strong class="calibre2">2) banana<br class="title-page-name"/></strong><strong class="calibre2">3) orange<br class="title-page-name"/></strong><strong class="calibre2">4) mango<br class="title-page-name"/></strong><strong class="calibre2">Your choice is: 2<br class="title-page-name"/></strong><strong class="calibre2">You chose banana<br class="title-page-name"/></strong><strong class="calibre2">Your choice is: 4<br class="title-page-name"/></strong><strong class="calibre2">You chose mango, so we wanna break free!</strong>
</pre>
<p class="calibre1"><span><span>But we can do something more interesting than this, especially if we want to interact with the system. Let's again aim to make a backup script and take advantage of what we just did:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">while true<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  clear<br class="title-page-name"/></strong><strong class="calibre2">  cat &lt;&lt;MENU<br class="title-page-name"/></strong><strong class="calibre2">  BACKUP UTIL v 1.0<br class="title-page-name"/></strong><strong class="calibre2">  ------------------<br class="title-page-name"/></strong><strong class="calibre2">  1. Backup a file/directory<br class="title-page-name"/></strong><strong class="calibre2">  2. Restore a file/directory<br class="title-page-name"/></strong><strong class="calibre2">  0. Quit<br class="title-page-name"/></strong><strong class="calibre2">  ------------------<br class="title-page-name"/></strong><strong class="calibre2">MENU<br class="title-page-name"/></strong><strong class="calibre2">PS3="Which file do you want to backup? "<br class="title-page-name"/></strong><strong class="calibre2">touch EXIT <br class="title-page-name"/></strong><strong class="calibre2">  read -p "Please select an option, 0 or Q to exit: " option<br class="title-page-name"/></strong><strong class="calibre2">  case $option in<br class="title-page-name"/></strong><strong class="calibre2">      1 | [Bb])<br class="title-page-name"/></strong><strong class="calibre2">      echo "You chose the first option, Backup"<br class="title-page-name"/></strong><strong class="calibre2">      clear<br class="title-page-name"/></strong><strong class="calibre2">      select file in *<br class="title-page-name"/></strong><strong class="calibre2">      do<br class="title-page-name"/></strong><strong class="calibre2">         case "$file" in <br class="title-page-name"/></strong><strong class="calibre2">                    EXIT)<br class="title-page-name"/></strong><strong class="calibre2">                    echo "Ok, we exit!"<br class="title-page-name"/></strong><strong class="calibre2">                    rm EXIT<br class="title-page-name"/></strong><strong class="calibre2">                    break<br class="title-page-name"/></strong><strong class="calibre2">                    ;;<br class="title-page-name"/></strong><strong class="calibre2">*)<br class="title-page-name"/></strong><strong class="calibre2">         echo "Compressing file $file"<br class="title-page-name"/></strong><strong class="calibre2">                tar cvzf "${file}".tgz "$file" || exit 1<br class="title-page-name"/></strong><strong class="calibre2">                echo "File $file compressed."<br class="title-page-name"/></strong><strong class="calibre2">                ls "${file}".tgz<br class="title-page-name"/></strong><strong class="calibre2">                echo "Press a key to return to main menu..."<br class="title-page-name"/></strong><strong class="calibre2">                read <br class="title-page-name"/></strong><strong class="calibre2">                break<br class="title-page-name"/></strong><strong class="calibre2">                ;;<br class="title-page-name"/></strong><strong class="calibre2">         esac<br class="title-page-name"/></strong><strong class="calibre2">       done<br class="title-page-name"/></strong><strong class="calibre2">       ;;<br class="title-page-name"/></strong><strong class="calibre2">       2 | [Rr]) <br class="title-page-name"/></strong><strong class="calibre2">         echo "You chose the second option, Restore"<br class="title-page-name"/></strong><strong class="calibre2">         sleep 3<br class="title-page-name"/></strong><strong class="calibre2">         ;;<br class="title-page-name"/></strong><strong class="calibre2">       0 | [Qq])<br class="title-page-name"/></strong><strong class="calibre2">         echo "You chose the third options, Quit, so we quit!"<br class="title-page-name"/></strong><strong class="calibre2">         break<br class="title-page-name"/></strong><strong class="calibre2">         ;;<br class="title-page-name"/></strong><strong class="calibre2">       *)<br class="title-page-name"/></strong><strong class="calibre2">         echo "Not a valid choice, please select an option..."<br class="title-page-name"/></strong><strong class="calibre2">         sleep 3<br class="title-page-name"/></strong><strong class="calibre2">         ;;<br class="title-page-name"/></strong><strong class="calibre2">     esac<br class="title-page-name"/></strong><strong class="calibre2">done <br class="title-page-name"/></strong><strong class="calibre2">rm EXIT</strong>
</pre>
<p class="calibre1"><span><span>We used <kbd class="calibre9">while true</kbd> to make the main loop so that the script will be always running unless we explicitly exit from it, then with a <em class="calibre20">here</em> document, we show a neat menu to the user and then a case construct to provide a way to evaluate the answers given by the user in the next step. The first option in the <kbd class="calibre9">case</kbd> statement clears the screen and embeds a select structure, also it provides a list of files to work on using a filename expansion. Since we do not know in advance how many files we will have in the current directory, and we cannot modify the list, we can rely on a trick, creating a file called <kbd class="calibre9">EXIT</kbd> at the beginning of the script and deleting at the end of it. The output will be something like this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">BACKUP UTIL v 1.0</strong><br class="title-page-name"/><strong class="calibre2">------------------</strong><br class="title-page-name"/><strong class="calibre2">1. Backup a file/directory</strong><br class="title-page-name"/><strong class="calibre2">2. Restore a file/directory</strong><br class="title-page-name"/><strong class="calibre2">0. Quit</strong><br class="title-page-name"/><strong class="calibre2">------------------</strong><br class="title-page-name"/><strong class="calibre2">Please select an option, 0 or Q to exit:</strong>
</pre>
<p class="calibre1">And select option 1:</p>
<div class="packt_figure"><img class="image-border2" src="../images/00007.jpeg"/><strong class="calibre2"><br class="title-page-name"/></strong></div>
<p class="calibre1"><span><span>The files are automatically numbered along without the EXIT placeholder. </span></span><span><span>The files in the directory are all numbered, and our EXIT strategy shows up even though it is not the last option; but renaming it would allow us to place it wherever we want. Inside <kbd class="calibre9">select</kbd>, we find another case, since we want to evaluate the answer given by the user and work on the right file. So, if the user does not select the option corresponding to EXIT, we do not break out from the loop clearing out the file, but proceed by compressing it and exiting to the main loop, which will show up the main menu. All of this is nice, but did you realize that there is a big issue at play here? What happens if you select one option that is not really available in the select menu?</span></span></p>
<pre class="codepackt">
<strong class="calibre2">1) backup-menu.sh  <br class="title-page-name"/></strong><strong class="calibre2">2) case-select.sh  <br class="title-page-name"/></strong><strong class="calibre2">3) c-for.sh  <br class="title-page-name"/></strong><strong class="calibre2">4) counter-brace.sh  <br class="title-page-name"/></strong><strong class="calibre2">5) counter-function.sh<br class="title-page-name"/></strong><strong class="calibre2">6) counter-simple.sh<br class="title-page-name"/></strong><strong class="calibre2">7) EXIT<br class="title-page-name"/></strong><strong class="calibre2">8) for-continue.sh<br class="title-page-name"/></strong><strong class="calibre2">9) for-pair-input.sh<br class="title-page-name"/></strong><strong class="calibre2">10) for-pair-set.sh<br class="title-page-name"/></strong><strong class="calibre2">11) for-pair.sh<br class="title-page-name"/></strong><strong class="calibre2">12) simple-select.sh<br class="title-page-name"/></strong><strong class="calibre2">13) until-simple.sh<br class="title-page-name"/></strong><strong class="calibre2">14) while-simple.sh<br class="title-page-name"/></strong><strong class="calibre2">Which file do you want to backup? 15<br class="title-page-name"/></strong><strong class="calibre2">Compressing file <br class="title-page-name"/></strong><strong class="calibre2">tar: Substituting `.' for empty member name<br class="title-page-name"/></strong><strong class="calibre2">tar: : Cannot stat: No such file or directory<br class="title-page-name"/></strong><strong class="calibre2">tar: Exiting with failure status due to previous errors</strong>
</pre>
<p class="calibre1"><span><span>Well, it is to be expected since we did not provide a real check on the input, or better, we are checking only what we expected to receive, not the unexpected. So let's modify the default option for the inner case statement:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">*)<br class="title-page-name"/></strong><strong class="calibre2">    if [ -z "$file" ]<br class="title-page-name"/></strong><strong class="calibre2">    then <br class="title-page-name"/></strong><strong class="calibre2">       echo "Please, select one of the number displayed"<br class="title-page-name"/></strong><strong class="calibre2">     sleep 3<br class="title-page-name"/></strong><strong class="calibre2">     continue<br class="title-page-name"/></strong><strong class="calibre2">     fi<br class="title-page-name"/></strong><strong class="calibre2">  echo "Compressing file $file"<br class="title-page-name"/></strong><strong class="calibre2">     tar cvzf "${file}".tgz "$file" || exit 1<br class="title-page-name"/></strong><strong class="calibre2">     echo "File $file compressed."<br class="title-page-name"/></strong><strong class="calibre2">     ls "${file}".tgz<br class="title-page-name"/></strong><strong class="calibre2">     echo "Press a key to return to main menu..."<br class="title-page-name"/></strong><strong class="calibre2">     read<br class="title-page-name"/></strong><strong class="calibre2">     break<br class="title-page-name"/></strong><strong class="calibre2">     ;;</strong>
</pre>
<p class="calibre1"><span><span>We simply added a check to the content passed through <kbd class="calibre9">$file variable</kbd>: if the variable does not hold anything and does not point to any filename, we display a message, wait for three seconds, and then restart the loop. We could also use read instead of just waiting to force the user to press a key to continue; and this would leave the warning message displayed until the user reacts.</span></span></p>
<p class="calibre1"><span><span>As we can see from the various examples, there is more than one way to create a user menu in Bash; and in the coming chapters, we will use them and make them even more fancier. But talking about user interaction, we have one topic left to face and it is quite interesting: dealing with how to manage the command line argument passed to our scripts. So, if we do not want to show a menu, but want to receive arguments on the command line, how do we do it? We already saw something, but there is a nice built-in that can ease our job, so it is time to have a look at <kbd class="calibre9">getops</kbd>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">CLI, passing the arguments to the command line</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Geopts is a Bash built-in widely used to efficiently parse switches and arguments passed on the command line of a script. We already saw other ways to accomplish this task, but getops makes it quite easy to handle it, since it can automatically recognize the switches and argument passed to the script. Its syntax is as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">getops options variable</strong>
</pre>
<p class="calibre1"><span><span>The first thing we pass to <kbd class="calibre9">getops</kbd> is a string of options, the classical <kbd class="calibre9">-a -x -f</kbd> of whatever you want, without any leading dash, such as </span></span><span><span><kbd class="calibre9">getops axf</kbd> </span></span><span><span>or also </span></span><span><span><kbd class="calibre9">getops ax:f</kbd>. I</span></span><span><span>f you see an option followed by a colon, this means that the option is meant to have an argument such as follows:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">./our_script.sh -x our_argument -a</strong>
</pre>
<p class="calibre1"><span><span>In our example, <kbd class="calibre9">-x</kbd> has an argument while <kbd class="calibre9">-a</kbd> is a simple switch, or we can also call it <strong class="calibre2">flag</strong> that can just be there or not, but it does not require any arguments. The options can be specified as lower or upper characters or digits. The <kbd class="calibre9">getops</kbd> built-in has some predefined variables for its internal use:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre9">OPTARG</kbd> holds the argument for an option or the flag for an unknown option.</li>
<li class="calibre13"><kbd class="calibre9">OPTBIND</kbd> holds the index for the next option to parse.</li>
<li class="calibre13"><kbd class="calibre9">OPTERR</kbd> holds 0 or 1 and sets the display of error messages from <kbd class="calibre9">getops</kbd>. The default value is 1, so messages are displayed here.</li>
</ul>
<p class="calibre1"><span><span>As it is quite clear, <kbd class="calibre9">getops</kbd> is useful for parsing short options, but it cannot process the long style options, so </span></span><span><span><kbd class="calibre9">-a</kbd> </span></span><span><span>is okay, but </span></span><kbd class="calibre9"><span><span>--all </span></span></kbd><span><span>will not be parsed. It's a limit, but it is just a matter of style. Let's see a simple example and by commenting on it, we will have a look at how <kbd class="calibre9">getops</kbd> works on the field:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">while getopts ":ax:f" option<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">  case $option in<br class="title-page-name"/></strong><strong class="calibre2">  a | f)<br class="title-page-name"/></strong><strong class="calibre2">echo "You selected $option!"<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">  x)<br class="title-page-name"/></strong><strong class="calibre2">echo "You selected $option with argument $OPTARG"<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">  ?)<br class="title-page-name"/></strong><strong class="calibre2">echo "Invalid switch: -$OPTARG"<br class="title-page-name"/></strong><strong class="calibre2">  ;;<br class="title-page-name"/></strong><strong class="calibre2">  :)<br class="title-page-name"/></strong><strong class="calibre2">echo "No arguments provided: -$OPTARG"<br class="title-page-name"/></strong><strong class="calibre2">  ;;<br class="title-page-name"/></strong><strong class="calibre2">esac<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>So, our script starts with a while loop, and this is due to the fact that <kbd class="calibre9">getops</kbd> exits with a status called <kbd class="calibre9">fail</kbd> when there is nothing to parse, and this condition is met when it reaches the first non option argument or when it hits a <kbd class="calibre9">--</kbd>. Next, we see the <kbd class="calibre9">getops</kbd> built-in followed by <kbd class="calibre9">ax:f</kbd>, which means it expects this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">-a<br class="title-page-name"/></strong><strong class="calibre2">-x argument<br class="title-page-name"/></strong><strong class="calibre2">-f</strong>
</pre>
<p class="calibre1"><span><span><kbd class="calibre9">getops</kbd> will read all the options up to the first non-option argument and store them in a variable that in our case is named option. Now, the last part is a bit tricky. Have a look at </span></span><span><span><kbd class="calibre9">getopts ":ax:f"</kbd>.</span></span></p>
<p class="calibre1"><span><span>Did you notice<kbd class="calibre9">:</kbd> before the first option? It disables the standard error messages for getops and alters the way the standard variables are used.</span></span></p>
<p class="calibre1"><span><span>In case of an invalid option, the variable (<kbd class="calibre9">option</kbd> in our example) is used to store the <kbd class="calibre9">?</kbd> character, which highlights the error; and <kbd class="calibre9">OPTARG</kbd> is instanced with the invalid character provided by the user.</span></span></p>
<p class="calibre1"><span><span>In case of an argument, the variable is instanced with a colon <kbd class="calibre9">:</kbd> and <kbd class="calibre9">OPTARG</kbd> holds the option character. Let's run this script with the different options to see how it works:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~/$ ./getops-simple.sh -a<br class="title-page-name"/></strong><strong class="calibre2">You selected a!<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~/$ ./getops-simple.sh -f<br class="title-page-name"/></strong><strong class="calibre2">You selected f!<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~/$ ./getops-simple.sh -f -a<br class="title-page-name"/></strong><strong class="calibre2">You selected f!<br class="title-page-name"/></strong><strong class="calibre2">You selected a!<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~/$ ./getops-simple.sh -x<br class="title-page-name"/></strong><strong class="calibre2">No arguments provided: -x<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~/$ ./getops-simple.sh -x hello<br class="title-page-name"/></strong><strong class="calibre2">You selected x with argument hello<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~/$ ./getops-simple.sh -x hello -a -f<br class="title-page-name"/></strong><strong class="calibre2">You selected x with argument hello<br class="title-page-name"/></strong><strong class="calibre2">You selected a!<br class="title-page-name"/></strong><strong class="calibre2">You selected f!<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~/$ ./getops-simple.sh -z<br class="title-page-name"/></strong><strong class="calibre2">Invalid switch: -z</strong>
</pre>
<p class="calibre1"><span><span>Nice, but do not get fooled, we have two main issues here, do you see them? Let's have a look at the first one:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~/$ ./getops-simple.sh <br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~/$</strong>
</pre>
<p class="calibre1"><span><span>Well, no switches were given, no output at all, and this is not good at all: remember not to leave your user without a feedback, never. Always have your script to show something to the user, so he knows he did something and will not try to invoke it repeatedly. We can manage this situation adding just before the while loop a small fragment of code, which counts the arguments on the command line:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">if (( $# == 0 ))<br class="title-page-name"/></strong><strong class="calibre2">then <br class="title-page-name"/></strong><strong class="calibre2">   echo "Please, give at least one option on the command line"<br class="title-page-name"/></strong><strong class="calibre2">exit 1<br class="title-page-name"/></strong><strong class="calibre2">fi</strong>
</pre>
<p class="calibre1"><span><span>Nothing special, we just checked if the number of arguments passed to the command line is equal to <kbd class="calibre9">0</kbd> and whether this is the case we echo a message and exit with an error:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./getops-arguments.sh <br class="title-page-name"/></strong><strong class="calibre2">Please, give at least one option on the command line<br class="title-page-name"/></strong><strong class="calibre2">Is it this all about our errors? Not precisely:<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ./getops-arguments.sh -a Hello<br class="title-page-name"/></strong><strong class="calibre2">You selected a!</strong>
</pre>
<p class="calibre1"><span><span><kbd class="calibre9">Hello</kbd> is an argument passed to the command line, but <kbd class="calibre9">-a</kbd> does not accept the <kbd class="calibre9">options</kbd> argument, so how do we retrieve <kbd class="calibre9">Hello</kbd>? Notice that there is a difference between these two invocations:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./getops-arguments.sh -x Hello<br class="title-page-name"/></strong><strong class="calibre2">You selected x with argument Hello<br class="title-page-name"/></strong><strong class="calibre2">zarrelli:~$ ./getops-arguments.sh -a Hello<br class="title-page-name"/></strong><strong class="calibre2">You selected a!</strong>
</pre>
<p class="calibre1"><span><span>The first <kbd class="calibre9">Hello</kbd> is the argument of an option and the second is a simple argument on the command line, which is not related to an option, since <kbd class="calibre9">-a</kbd> does not accept any arguments. And so, we were able to reach <kbd class="calibre9">Hello</kbd> the first time, but not on the second scenario. How can we overcome this limitation? Let's rewrite the previous example adding the following lines at the end of the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">echo "And the argument was $*"<br class="title-page-name"/></strong><strong class="calibre2">shift "$((OPTIND-1))"<br class="title-page-name"/></strong><strong class="calibre2">echo "And the argument was $*"</strong>
</pre>
<p class="calibre1"><span><span>Now let's run the script again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./getops-arguments.sh -x whatever -a Hello<br class="title-page-name"/></strong><strong class="calibre2">You selected x with argument whatever<br class="title-page-name"/></strong><strong class="calibre2">You selected a!<br class="title-page-name"/></strong><strong class="calibre2">And the argument was -x whatever -a Hello<br class="title-page-name"/></strong><strong class="calibre2">And the argument was Hello</strong>
</pre>
<p class="calibre1"><span><span>And here we are. Notice the use of shift that helped us in retrieving the argument; this trick is based upon the value hold by <kbd class="calibre9">OPTIND</kbd>, which corresponds to the number of options parsed by the last call of <kbd class="calibre9">getops</kbd>. If we recall how <kbd class="calibre9">getops</kbd> works: each time it is invoked, it puts the next option in the variable used to hold them, initializing it if does not exist and the index of the next argument to parse into the <kbd class="calibre9">OPTIND</kbd> variable. So, <kbd class="calibre9">OPTIND</kbd> at the first run has <kbd class="calibre9">1</kbd> as its argument. Bear in mind that <kbd class="calibre9">OPTIND</kbd> is never reset by the shell, so if you have to make multiple calls to <kbd class="calibre9">getops</kbd>, it is up to you to reinitialize the variable to <kbd class="calibre9">1</kbd>. Then, we use shift to deal with the positional parameter, since this built-in is able to shift the positional parameters on the left by the number specified as its argument. So </span></span><span><span><kbd class="calibre9">shift "$((OPTIND-1))"</kbd> </span></span><span><span>shifts the positional parameter of the next argument of <kbd class="calibre9">getops</kbd> back to one position. Let's rewrite a part of the previous script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">case $option in<br class="title-page-name"/></strong><strong class="calibre2">    a | f)<br class="title-page-name"/></strong><strong class="calibre2">echo "You selected $option with $OPTIND=$OPTIND and the command line argument $*!"<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">x)<br class="title-page-name"/></strong><strong class="calibre2">echo "You selected $option with argument $OPTARG with $OPTIND=$OPTIND and the command line $*!"<br class="title-page-name"/></strong><strong class="calibre2">    ;;<br class="title-page-name"/></strong><strong class="calibre2">    ?)<br class="title-page-name"/></strong><strong class="calibre2">   echo "Invalid switch: -$OPTARG with $OPTIND=$OPTIND"<br class="title-page-name"/></strong><strong class="calibre2">    ;;<br class="title-page-name"/></strong><strong class="calibre2">    :)<br class="title-page-name"/></strong><strong class="calibre2">   echo "No arguments provided: -$OPTARG with $OPTIND=$OPTIND"<br class="title-page-name"/></strong><strong class="calibre2">   ;;<br class="title-page-name"/></strong><strong class="calibre2">   esac<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">echo "$OPTIND at the end of the loop is $OPTIND"<br class="title-page-name"/></strong><strong class="calibre2">shift "$((OPTIND-1))"<br class="title-page-name"/></strong><strong class="calibre2">echo "But at the end of the script we have this left on the command line: $*"</strong>
</pre>
<p class="calibre1"><span><span>Now, run it again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./getops-arguments.sh -f -a Hello<br class="title-page-name"/></strong><strong class="calibre2">You selected f with $OPTIND=2 and the command line argument -f -a Hello!<br class="title-page-name"/></strong><strong class="calibre2">You selected a with $OPTIND=3 and the command line argument -f -a Hello!<br class="title-page-name"/></strong><strong class="calibre2">$OPTIND at the end of the loop is 3</strong>
</pre>
<p class="calibre1"><span><span>But at the end of the script, we have this left on the command line: <kbd class="calibre9">Hello</kbd>.</span></span></p>
<p class="calibre1"><span><span>So, what happens? When you run the script, <kbd class="calibre9">OPTIND</kbd> starts with a value of <kbd class="calibre9">1</kbd> and gets incremented by <kbd class="calibre9">1</kbd> each time <kbd class="calibre9">getops</kbd> gets called. So, since we have two options to process on the command line, at the end of the <kbd class="calibre9">getops</kbd> loop, the value of <kbd class="calibre9">OPTIND</kbd> will be 2+1, so we have 3. Now, if we shift the command line of <kbd class="calibre9">"$((OPTIND-1))"</kbd>, it means that we move the command-line arguments of 2 slots (3-1) to the left. Bear in mind that when you shift the positional arguments to the left, they get essentially lost and so what you are left with is the rest of the arguments. In our case, if we move the positional arguments of 2 on the left, we get rid of <kbd class="calibre9">-f</kbd> and <kbd class="calibre9">-a</kbd>; and we are left with the first non-option argument, <kbd class="calibre9">"Hello"</kbd>. Here we are! If we now print the content of the command line <kbd class="calibre9">$@</kbd> after the loop, we are left exactly with <kbd class="calibre9">Hello</kbd>. Now, it's time to build up the tools we will use in the next chapters and pull together all the bits and parts you learned so far. First things first: the script will become more complex, and it will tend to clutter a bit, so if we recall what we saw in the first chapters about sourcing a file, what we will do now is create a library to hold all the common functions and settings that we are going to use frequently. Adopting this style will help to keep our scripts neat and simple and to master their content with less effort. So, first things first, let's create a library file that we will call </span></span><span><span><kbd class="calibre9">library.lib</kbd> </span></span><span><span>and start writing some functions in it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Library file holding common functions and setting<br class="title-page-name"/></strong><strong class="calibre2"># Functions<br class="title-page-name"/></strong><strong class="calibre2">non_zero_input()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">  if (( $1 == 0 ))<br class="title-page-name"/></strong><strong class="calibre2">    then <br class="title-page-name"/></strong><strong class="calibre2">  echo "Please, give at least one option on the command line"<br class="title-page-name"/></strong><strong class="calibre2">  exit 1<br class="title-page-name"/></strong><strong class="calibre2">  fi<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>Now, let's rewrite the first part of the previous script in the following way:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2">source library.lib<br class="title-page-name"/></strong><strong class="calibre2">non_zero_input "$#"</strong>
</pre>
<p class="calibre1"><span><span>And time to run the script without any options:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./getops-library.sh <br class="title-page-name"/>Please, give at least one option on the command line.</strong>
</pre>
<p class="calibre1"><span><span>As we can see, the check on the zero length input has been moved to the library, then sourced back to the main script. So, now, we have two advantages:</span></span></p>
<ul class="calibre12">
<li class="calibre13">Less rows in our primary script</li>
<li class="calibre13">The <kbd class="calibre9">non_zero_function</kbd> is now available to all the scripts that will source the library we just created</li>
</ul>
<p class="calibre1"><span><span>But now, it is time for something fancy. Ever wanted to give some spice to your output? Just modify this library in the following way:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Library file holding common functions and setting<br class="title-page-name"/></strong><strong class="calibre2"># Functions <br class="title-page-name"/></strong><strong class="calibre2">#----------<br class="title-page-name"/></strong><strong class="calibre2">non_zero_input()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">  if (( $1 == 0 ))<br class="title-page-name"/></strong><strong class="calibre2">    then <br class="title-page-name"/></strong><strong class="calibre2">  echo "Please, give at least one option on the command line"<br class="title-page-name"/></strong><strong class="calibre2">  exit 1<br class="title-page-name"/></strong><strong class="calibre2">  fi<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/></strong><strong class="calibre2">color_print()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">  printf "$1$2${CReset}n"<br class="title-page-name"/></strong><strong class="calibre2">} <br class="title-page-name"/></strong><strong class="calibre2"># Colors - foreground<br class="title-page-name"/></strong><strong class="calibre2">#--------------------<br class="title-page-name"/></strong><strong class="calibre2">Black='33[0;30m'<br class="title-page-name"/></strong><strong class="calibre2">Red='33[0;31m'<br class="title-page-name"/></strong><strong class="calibre2">Green='33[0;32m'<br class="title-page-name"/></strong><strong class="calibre2">Yellow='33[0;33m'<br class="title-page-name"/></strong><strong class="calibre2">Blue='33[0;34m'<br class="title-page-name"/></strong><strong class="calibre2">Purple='33[0;35m'<br class="title-page-name"/></strong><strong class="calibre2">Cyan='33[0;36m'<br class="title-page-name"/></strong><strong class="calibre2">White='33[0;37m'<br class="title-page-name"/></strong><strong class="calibre2"># Colors - Reset<br class="title-page-name"/></strong><strong class="calibre2">#---------------<br class="title-page-name"/></strong><strong class="calibre2">CReset='33[0m'</strong>
</pre>
<p class="calibre1"><span><span>We added some ANSI color code to our library assigning them to a meaningful variable name and also created a small <kbd class="calibre9">color_print</kbd> function. ANSI escape code or sequences are methods to manage colors and attributes on text terminals and are represented by a string starting with the ESC character (033 in octal), followed by a character between 64 to 95 in the ASCII range. W just added a few foreground colors, but by googling, you will find a lengthy list of escaped characters that you can assign to background colors, bold characters, reverse, and so forth. The <kbd class="calibre9">color_print</kbd> function is just a tiny example of what can be done with these control codes and it makes use of <kbd class="calibre9">printf</kbd>, which is a bit more flexible than <kbd class="calibre9">echo</kbd> even though <kbd class="calibre9">echo -e</kbd> will deal with escaped characters and will be good enough to print colors and attributes. Notice that the <kbd class="calibre9">color_print</kbd> functions ends <kbd class="calibre9">printf</kbd> with  </span></span><span><kbd class="calibre9">'33[0m'</kbd>, w</span><span><span>hich is a reset control character that will revert to default all the changes you made to the output: once you modify a color or an attribute, everything will be printed with that alteration until you explicitly reset to default using the reset escape sequence. Now, it is time to take advantage of what we just saw and modify the script we just created so that it ends this way:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">echo "$OPTIND at the end of the loop is $OPTIND"<br class="title-page-name"/></strong><strong class="calibre2">shift "$((OPTIND-1))"<br class="title-page-name"/></strong><strong class="calibre2">echo $@<br class="title-page-name"/></strong><strong class="calibre2">echo -e "${Green}But${CReset} at the end of the script we have this left on the command line: ${Red}$@${CReset}"<br class="title-page-name"/></strong><strong class="calibre2">color_print ${Yellow} "But we can use our color_print function to have a fancy output: $@"</strong>
</pre>
<p class="calibre1"><span><span>There are two different examples on how to use the escape codes to manage the output:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">echo -e "${Green}But${CReset} at the end of the script we have this left on the command line: ${Red}$@${CReset}"</strong>
</pre>
<p class="calibre1"><span><span>The word <kbd class="calibre9">But</kbd> is preceded by the value of the variable <kbd class="calibre9">Green</kbd> that we sourced from the library and it is closed by the <kbd class="calibre9">CReset</kbd> variable value, so echo will turn the output to green foreground right before writing <kbd class="calibre9">But</kbd> and revert to the standard color, usually white, right after thanks to the reset escape sequence. Then, right before printing the command-line arguments, it switches to <kbd class="calibre9">Red</kbd> to revert back once finished. The last line is printed using the <kbd class="calibre9">color_print</kbd> function sourced from the library file:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">color_print ${Yellow} "But we can use our color_print function to have a fancy output: $@"</strong>
</pre>
<p class="calibre1"><span><span>As we can see from the function definition, it accepts two arguments, the escape code and the string to print trailing them with a reset code; in our case we selected <kbd class="calibre9">Yellow</kbd>, so let's see what is the outcome in the following screenshot:</span></span></p>
<div class="packt_figure"><img class="image-border3" src="../images/00008.jpeg"/></div>
<div class="packt_figref"><span><span>Inline escape codes or ad hoc functions kicks up our output</span></span></div>
<p class="calibre1"><span><span>Nice, isn't it? There are actually many ways to color your output using Bash, from interacting with the dialog program, which will give you curses such as interface:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ dialog --begin 10 30 --backtitle "Example menu" --title "This is a Message Box" --msgbox 'Your message goes here!' 10 30<br class="title-page-name"/></strong>
</pre>
<div class="packt_figure"><img class="image-border4" src="../images/00009.jpeg"/><strong class="calibre2"><br class="title-page-name"/></strong></div>
<p class="calibre1"><span><span>This is a simple message box, which reminds me of the old Linux installers </span></span><span><span>to zenity that will give you a GTK+ interface:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ls -l | zenity --text-info --height=600 --width 800<br class="title-page-name"/></strong>
</pre>
<div class="packt_figure"><img class="image-border5" src="../images/00010.jpeg"/><strong class="calibre2"><br class="title-page-name"/></strong></div>
<div class="packt_figref"><span><span>Zenity allows you to create beautiful interfaces using GTK+ decorations</span></span></div>
<p class="calibre1"><span><span>What we can use depends on the level of interaction we want to have with the customer; for instance, scripts dealing with services probably will not need any fancy stuff. And on our concerns about portability: to use dialog and zenity you have to install them; they are not shipped by default with a Linux system. For zenity, keep in mind that it only show its goodness on a graphical interface; if you go over serial or text-based terminals, it will show you curses such as interface at best. If you want to use something more advanced than ANSII escape code, you can resort to the <kbd class="calibre9">tput</kbd> command, which is shipped with Linux; and by using the <kbd class="calibre9">terminfo</kbd> or <kbd class="calibre9">termcap</kbd> databases, it enables you to interact with the terminal in a more interesting way:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash</strong><br class="title-page-name"/><strong class="calibre2">fred=$(tput setaf 1)</strong><br class="title-page-name"/><strong class="calibre2">fgreen=$(tput setaf 2)</strong><br class="title-page-name"/><strong class="calibre2">fwhite=$(tput setaf 7)</strong><br class="title-page-name"/><strong class="calibre2">bblue=$(tput setab 4)</strong><br class="title-page-name"/><strong class="calibre2">esmso=$(tput smso)</strong><br class="title-page-name"/><strong class="calibre2">xsmso=$(tput rmso)</strong><br class="title-page-name"/><strong class="calibre2">dim=$(tput dim)</strong><br class="title-page-name"/><strong class="calibre2">reset=$(tput sgr0)</strong><br class="title-page-name"/><strong class="calibre2">hide=$(tput civis)</strong><br class="title-page-name"/><strong class="calibre2">box() {</strong><br class="title-page-name"/><strong class="calibre2">printf ${hide} </strong><br class="title-page-name"/><strong class="calibre2">printf ${bblue} </strong><br class="title-page-name"/><strong class="calibre2">width=$(tput cols)</strong><br class="title-page-name"/><strong class="calibre2">height=$(tput lines)</strong><br class="title-page-name"/><strong class="calibre2">message="Width is: ${esmso}${fgreen}$width${fwhite} Height is: ${dim}${fred}$height${reset}"</strong><br class="title-page-name"/><strong class="calibre2">length=${#message}</strong><br class="title-page-name"/><strong class="calibre2">clear</strong><br class="title-page-name"/><strong class="calibre2">tput cup $((height / 2)) $(((width / 2) - ((length - 29) / 2)))</strong><br class="title-page-name"/><strong class="calibre2">printf "$message"</strong><br class="title-page-name"/><strong class="calibre2">}</strong><br class="title-page-name"/><strong class="calibre2">trap box WINCH</strong><br class="title-page-name"/><strong class="calibre2">box</strong><br class="title-page-name"/><strong class="calibre2">while true</strong><br class="title-page-name"/><strong class="calibre2">do</strong><br class="title-page-name"/><strong class="calibre2">:</strong><br class="title-page-name"/><strong class="calibre2">done<br class="title-page-name"/></strong>
</pre>
<div class="packt_figure"><img class="image-border6" src="../images/00011.jpeg"/><strong class="calibre2"><br class="title-page-name"/></strong></div>
<div class="packt_figref"><span><span>An auto updating message displayed using tput</span></span></div>
<p class="calibre1"><span><span>This simple script uses <kbd class="calibre9">tput</kbd> with a series of numbers to change the color of the output.</span></span><span><span><kbd class="calibre9">tput setaf x</kbd> </span></span><span><span>sets the foreground color to the value corresponding to the <kbd class="calibre9">x</kbd> integer:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">0 black<br class="title-page-name"/></strong><strong class="calibre2">1 red<br class="title-page-name"/></strong><strong class="calibre2">2 green<br class="title-page-name"/></strong><strong class="calibre2">3 yellow<br class="title-page-name"/></strong><strong class="calibre2">4 blue<br class="title-page-name"/></strong><strong class="calibre2">5 magenta<br class="title-page-name"/></strong><strong class="calibre2">6 cyan<br class="title-page-name"/></strong><strong class="calibre2">7 white</strong>
</pre>
<p class="calibre1"><span><span>For the background, we use </span></span><span><span><kbd class="calibre9">tput setbg x</kbd> </span></span><span><span>with the same list of codes. We used the command substitution to get the output of the command and use it with <kbd class="calibre9">printf</kbd> to modify the output accordingly. The values for the rest of the <kbd class="calibre9">tput</kbd> commands are quite obvious:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">tput smso</kbd> enters the standout mode</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">tput rmso</kbd> exits the standout mode</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">tput dim</kbd> makes the output less bright</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">tput sgro</kbd> reverts back to the standard terminal output</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">tput cvis</kbd> hides the cursor</span></span></li>
</ul>
<p class="calibre1"><span><span>Then, we created a function named <kbd class="calibre9">box</kbd>, which hides the cursor, and then sets the background to blue. The interesting parts are here:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><kbd class="calibre9">tput cols</kbd> gets the number of columns of the terminal</span></span></li>
<li class="calibre13"><span><span><kbd class="calibre9">tput lines</kbd> gets the number of lines of the terminal</span></span></li>
</ul>
<p class="calibre1"><span><span>We stored the output of the two commands in the width and height variables and used the message variable to compose a string, which outputs the dimensions of our terminal, using the <kbd class="calibre9">tput</kbd> colors to format the output, which has a nice flag as a background. We used the various attributes in an unconventional way, but you can play with them and see what kind of output you can get.</span></span></p>
<p class="calibre1"><span><span>Look into </span></span><span><span><kbd class="calibre9">man terminfo</kbd>, </span></span><span><span><kbd class="calibre9">man termcap</kbd>, and </span></span><span><span><kbd class="calibre9">man tput</kbd> </span></span><span><span>to have an idea of all that you can do with <kbd class="calibre9">tput</kbd>. Continuing with the script, we get the length of the message and clear the script, clear the screen, and finally with </span></span><span><span><kbd class="calibre9">tput cup x y</kbd>.</span></span></p>
<p class="calibre1"><span><span>We move the cursor to the right position to center the message on the terminal. We had to compensate the characters used for the <kbd class="calibre9">tput</kbd> attributes. Outside the function, we then use a trap that intercepts the window change signal sent to the process when the terminal, which controls it, changes its size. This way the trap will invoke the function box each time the user changes the size of the window, so the new height and width will be calculated and printed to the terminal. We left an infinite loop at the end, which kicks in play once the first box iteration has been completed: the infinite loop keeps the script running idle waiting for the winch signal to be trap. And as soon as it is trapped, the box function is called, a new height and width values calculated, and an up-to-date message is displayed.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Our scripts are starting to get more complex and ever interesting; we are moving from dealing with the shell to programming, to making something handy out of it. The next part of the book will dive into a bit of real-world programming, creating some applications that will show us how to create some sound and reliable tools for our everyday life as sysadmins or curious users.</span></span></p>


            </article>

            
        </section>
    </body></html>