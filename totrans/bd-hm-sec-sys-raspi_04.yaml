- en: Chapter 4. Adding a Magnetic Contact Sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built our port expander hardware, we need to learn how to program
    it so that our Raspberry Pi can detect the things that we connect to it as part
    of our home security system. We will begin by connecting switches to our system
    in the form of magnetic sensors—the most common component used in home security
    systems to detect intrusions through doors and windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about reed switches and how they work as door sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling and setting up the I2C bus on the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting our sensor to an input on our port expander
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to access our I2C port expander from a Bash script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a script that will detect the state of our door sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at other types of contact sensors that can be connected and programmed
    in the same way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll need the following parts for the exercises in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Our Raspberry Pi and Port Expander board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 x 10K ohm resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A magnetic door sensor and magnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hook-up wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 4-core alarm wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The working of magnetic contact sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **reed switch** is essentially what makes up our **magnetic contact sensor**.
    A reed switch comprises two metal contacts made of magnetic material (called reeds)
    placed inside a glass envelope. When the contacts touch, the switch is on, and
    when they spring apart, the switch is off and the circuit is broken. The way to
    control these contacts is by means of a **magnetic field** that makes or breaks
    the circuit when it is near to the switch.
  prefs: []
  type: TYPE_NORMAL
- en: A normally open (NO) type of reed switch is normally switched off until a magnet
    comes close to the switch, which then pulls the contacts together.
  prefs: []
  type: TYPE_NORMAL
- en: A normally closed (NC) variety works the other way with the switch being normally
    on until the magnet comes close to the switch, pulling the two contacts apart.
  prefs: []
  type: TYPE_NORMAL
- en: '![The working of magnetic contact sensors](img/B04579_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A typical type of reed switch
  prefs: []
  type: TYPE_NORMAL
- en: You can now see how a magnetic reed switch can be a useful sensor in security
    applications, and in particular for our home security system, to detect when **doors**
    and **windows** are opened and closed. We simply put a reed switch on the door
    frame and connect it to our security system, with the magnet placed opposite the
    switch on the actual door. When the door opens and closes, it makes or breaks
    the contacts in our reed switch.
  prefs: []
  type: TYPE_NORMAL
- en: Reed switches and their magnets, which are designed for security systems, usually
    come enclosed in little plastic housings, making them easy to screw onto the door
    and frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![The working of magnetic contact sensors](img/B04579_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A door-frame-mounted magnetic sensor containing a reed switch (Type: Cherry
    MP201801)'
  prefs: []
  type: TYPE_NORMAL
- en: The magnetic sensor is mounted on the door frame (obviously, so it can connect
    to the alarm circuit wires), while the respective magnet will be attached to the
    door, close enough to the edge such that the sensor contacts connect (or break,
    depending on the type) when the magnet is directly opposite it.
  prefs: []
  type: TYPE_NORMAL
- en: '![The working of magnetic contact sensors](img/B04579_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A respective door-mounted magnetic actuator (Type: Cherry AS201801)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the I2C port expander
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built our port expander, we need to get it ready to connect
    our sensors to. First, we need to install the tools on the Raspberry Pi to allow
    us to use the I2C bus and program devices connected to it, including the MCP23017
    chip that makes up our port expander.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't connect your port expander to the Raspberry Pi until after you've set
    up the I2C bus on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the I2C Bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s highly likely that the module for using the I2C bus hasn''t been loaded
    by default. Fortunately, doing this is fairly straightforward and can be done
    using the Raspberry Pi configuration tool. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the Raspberry Pi configuration tool with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Enabling the I2C Bus](img/B04579_04_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Select option 8: `Advanced Options`.![Enabling the I2C Bus](img/B04579_04_05.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Option A7: `I2C`.![Enabling the I2C Bus](img/B04579_04_06.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `<Yes>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot your Raspberry Pi for the setting to take effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the I2C bus has been enabled, we need to set up the operating system
    so that the required modules are loaded each time the system boots. To do this,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **Modules file** using the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file and exit Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing the I2C tools package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So that we can easily access the I2C bus using Bash scripts, we need to install
    the `i2c-tools` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we should shutdown our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After activity has stopped, switch off your Raspberry Pi, connect your port
    expander to the GPIO port, and power it back up so that we can start using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick sanity check, you can see if I2C support has been loaded by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you a list of at least one bus—for example, `/dev/i2c-1`—if
    the module is loaded. If it''s not, you''ll probably get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ls: cannot access /dev/i2c-*: No such file or directory**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, you''ll need to check back through the previous steps as something
    hasn''t happened properly.*'
  prefs: []
  type: TYPE_NORMAL
- en: Finding our devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `i2c-tools` package installs several different tools to help us use our
    port expander attached to the bus. The `i2cdetect` tool allows us to find I2C
    buses and devices attached to the busses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of I2C busses on our system, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pi@raspberrypi ~ $ sudo i2cdetect -l**'
  prefs: []
  type: TYPE_NORMAL
- en: '**i2c-1 i2c 20804000.i2c I2C adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows that we have one I2C bus, and this will be the one
    connected to our GPIO. *Note that earlier models of the Raspberry Pi may return
    the device ID as being i2c-0*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the tool to scan for all of the devices attached to our bus.
    We do this by specifying the bus ID, as in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With nothing attached to the I2C bus (that is, without our port expander attached)
    we''d expect to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Nothing found on the I2C bus*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our port expander attached, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Our I2C port expander slave device can be found at the address, 0x20 (32 decimal).*'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding address is the location of our MCP23017 chip connected to the
    I2C bus. If you don't see this, then there's probably a wiring issue and you'll
    need to go back and check.
  prefs: []
  type: TYPE_NORMAL
- en: You'll recall that we can add up to 8 of these devices to the I2C bus by setting
    the A0-A2 pins to a unique address. If A0 is set to `high`, then the address of
    the device will be shown as 0x21 (33 decimal)—and up to 0x27 (39 decimal), if
    all pins are high.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the port expander
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, we can have 2 x 8-bit busses on our port
    expander, with each pin being defined as an input or output. On the expander board
    we built, we called them I/O BUS A and I/O BUS B.
  prefs: []
  type: TYPE_NORMAL
- en: To configure the MCP23017 chip on the I2C bus, we can send it the appropriate
    commands using the **i2cset** tool we installed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'On our home security system, we are going to assign all of the pins on BUS
    A as inputs for connecting our sensors to it. To do this, we use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does this command mean?
  prefs: []
  type: TYPE_NORMAL
- en: '-y: This runs the command without user interaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: This is the ID of the bus (for example, `i2c-1`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x20: This is the address of the chip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x00: This is the data register on the chip (in this case, the PORT A pin assignment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0xFF: This is the Value loaded into the data register (in this case, all pins
    as inputs—binary %11111111).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check that the data register has been set correctly by reading it using
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This should return a value of `0xFF`, which is the value we set earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting our magnetic contact sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've got our port expander working with the Raspberry Pi, we can start
    connecting things to it and create the scripts that will monitor the sensors on
    the input pins.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to our port expander stripboard that was built in the previous
    chapter and connect our magnetic sensor. But first, we need to ensure that all
    of our inputs are pulled low by default using 10Kohm resistors. This prevents
    them from being in a *floating* state and giving us spurious data when we read
    the port's data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following diagram, I've connected the pull-down resistors externally,
    but you may want to include them directly on the stripboard. Toward the end of
    this book, we'll have a new board layout that brings everything that we've been
    prototyping so far together in a single solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the port''s input value, we use the `i2cget` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This should return `0x00`, which means all inputs are off (binary %00000000).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does this command mean?
  prefs: []
  type: TYPE_NORMAL
- en: '-y: This runs the command without user interaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: This is the ID of the bus (for example i2c-1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x20: This is the address of the chip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x12: This is the data register on the chip (in this case, the PORT A read
    value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's connect one side of our magnetic sensor's reed switch to data pin
    0 of BUS A (which we'll call GPA0 for reference), and the other side to our +3.3V
    line. By default, the switch is normally open (NO), which means that the input
    is still pulled low by the resistor.
  prefs: []
  type: TYPE_NORMAL
- en: But when you move the accompanying magnet near to the sensor switch (for example,
    if the door is closed), the switch will close, pulling the input high to the +3.3V
    line. If you read the port's input value now, by running the same command, you
    should see that it returns 0x01, indicating that the first bit is high (binary
    %00000001).
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting our magnetic contact sensor](img/B04579_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring the sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have everything in place and our magnetic sensor is detecting whether
    the door is closed, we can monitor this sensor with a simple Bash script that
    uses the I2C tool commands that we installed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code listing for `poll-magnetic-switch.sh` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you run the script and then push the button, you should see "**The door
    is open!**" scrolling up the console screen until you stop pressing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'By combining this with our elaborate light switch project in chapter 2, we
    can switch on the LED connected to GPIO17 when the door is opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later, as we add more sensors to different input pins, we will need to be able
    to detect which one has been triggered. We'll look at writing a Bash function
    later in the book, which will parse the returned hex value from the i2cget command,
    and tell us exactly which of the 8 inputs is high.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-tamper circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you take a closer look at our system, you might realize that depending on
    whether you are detecting normally open or normally closed sensor switches, it
    is possible to tamper with the sensor channel by simply cutting the wire. So,
    in the case of a normally open switch, it wouldn't activate the monitoring system
    if the wires were cut, as it would always appear to be open, even if the switch
    was closed.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate this, most alarm systems feature a 4-core wiring system to connect
    the sensor devices to the main control board—two cores are used to connect the
    sensor and two are used to create an **anti-tamper loop**, which then itself forms
    a sensor input for monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: '![Anti-tamper circuits](img/B04579_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 4-core alarm cable
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following circuit so that you see what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Anti-tamper circuits](img/B04579_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this circuit, we have two sensors: one for monitoring a window and one for
    monitoring a door. These are connected to the I/O BUS A inputs, 0 and 1 (or GPA0
    and GPA1, as we like to call them). As before, they are pulled down to 0V by resistors
    but, when switches are closed, the positive voltage rail takes the inputs high.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we've also added an anti-tamper loop throughout the whole system, which
    is connected to GPA7 for monitoring. The loop is daisy-chained through each of
    the cables connecting the sensors to the controller board. All the time the loop
    is intact, the input GPA7 is kept high, but if the cable is cut anywhere, the
    current will stop flowing through it and the resistor, R3, will pull the input
    low. This will then be detected by the monitoring script.
  prefs: []
  type: TYPE_NORMAL
- en: Many security sensor products provide a facility to terminate anti-tamper loop
    wires within them.
  prefs: []
  type: TYPE_NORMAL
- en: So, in our home security system, we're going to assign GPA7 as our anti-tamper
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Getting into the zone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may have occurred to you by now that even a modest-sized property could require
    plenty of door and window sensors; thus, if we used one input for each sensor,
    we'd soon run out unless we put more and more port expanders onto the system.
    The same is true for commercially available security systems.
  prefs: []
  type: TYPE_NORMAL
- en: So, the way this is dealt with is by creating **zones**, with each zone containing
    a group of sensors. A bedroom, for example, may be defined as one zone with a
    window sensor, a door sensor, and movement detector forming that zone. In this
    scenario, each sensor is connected to the next in a series (or daisy-chained);
    if one of them triggers, it will alert the monitoring system that there was a
    trigger in the zone. Obviously, though, it may not necessarily be the actual detector,
    which in most applications isn't really an issue.
  prefs: []
  type: TYPE_NORMAL
- en: However, this can introduce some challenges when we're considering mixing normally
    open and normally closed type sensors within a zone, but this is something we
    will explore later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other sensors you can use are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hall Effect Sensor**: Hall-effect sensors are simple electronic chips that
    are used to detect magnetic fields placed near them. They are not dissimilar to
    the reed switch we''ve been using; however, because they are electronic devices,
    they are able to measure the degree of proximity in relation to the magnet (or
    the strength of magnetism), rather than being just on or off, as is the case with
    the reed switch. Also, because they are solid-state, they could be seen as being
    more reliable than mechanical switches.![Getting into the zone](img/B04579_04_11.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A low-cost hall effect sensor—Allegro Microsystems A1302KUA-T
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Pressure Mat Sensors: Pressure mats are used to detect a person standing or
    walking on them, and can be placed under a floor mat to hide them from sight.
    They can even be used in a chair to detect people sitting on it. Essentially,
    they are switches, just like the reed switch, except that they are activated by
    the pressure of walking on them, and so, can be wired and used in exactly the
    same way as for our magnetic sensor circuits.![Getting into the zone](img/B04579_04_09.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pressure switch can be used under a front-door mat
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got our I2C-based port expander configured and working,
    and we experimented with it by connecting a magnetic sensor—one of the most commonly
    used sensors in security systems. We've also learned how to interact with I2C
    devices using Bash scripts, and how to read and write data to and from these devices.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we should now be beginning to understand the various elements and
    building blocks of a security system, including anti-tamper loops and zones. These
    are concepts that will prepare us for later on in the book, when we start to piece
    all of this together and build our final, all-encompassing system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at passive infra-red motion detectors, how
    they work, and how we can connect the wired and wireless types to our home security
    system. We'll also learn how to create log files based on events using Bash scripts
    so that we can maintain a history of detector states as they change.
  prefs: []
  type: TYPE_NORMAL
