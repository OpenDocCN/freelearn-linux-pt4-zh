- en: Preparing for Administration using PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio Code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring automatic variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing the shell behaviour using a variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling automated execution of commands for each load
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customising the terminal prompt
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding standard redirection in PowerShell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling native Linux commands from PowerShell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding cmdlets and parameters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running cmdlets with minimal keystrokes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding parameter aliases
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling a PowerShell script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dot-sourcing a PowerShell script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling a PowerShell cmdlet from outside of PowerShell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recording the cmdlets run on the PowerShell console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common notion that the more you use the terminal (as opposed to the GUI),
    the more efficient you are. Typing out commands is much easier and faster than
    clicking around the screen. However, to someone who has just begun using the terminal,
    it may not be so. Over time, as administrators grow more and more comfortable
    with the terminal, they learn to configure it for speed and efficiency, much like
    a trained horse. Further, most efficient administrators like automating several
    parts of their workflow—customising `.bashrc` and Vim scripts  are examples of
    it. In this chapter, we will familiarise ourselves with the different consoles
    and tools that work with PowerShell, and will also look at a few simple recipes
    which would help customise our workspace, so that we can be more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting can happen on the console itself, with Vim. It is also possible to
    use other editors like Gedit or even Atom to write PowerShell scripts. It is,
    however, recommended to use Microsoft's open source code editor, called, Visual
    Studio Code (or `vscode`). In this recipe, we would look at installing Visual
    Studio Code, and configuring it to work with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We would look at the steps to install `vscode` on Ubuntu. Today, most repositories
    contain Visual Studio Code. You may check in the software store of your distribution
    to install `vscode`. If not, the easiest way to install `vscode` is to download
    the `.deb` (or the `.rpm` package based on your distro), and run it to install
    the package on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Visual Studio Code is simple.
  prefs: []
  type: TYPE_NORMAL
- en: If your Linux distribution has a software store, search the store for Visual
    Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you find Visual Studio Code, install the package from there. If not, proceed
    with the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The package name for Visual Studio Code is `code`. Use your package manager
    to search for the package in the repository. On Ubuntu, the command would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you're able to find the package in your repository, install vscode like you
    would any other package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you were unable to find the package, go to [https://code.visualstudio.com/Download](https://code.visualstudio.com/Download)
    and download the right `code` package for your distro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To install VS Code, call your package manager with the path to the downloaded
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you would rather install VS Code in portable mode, download the VS Code tarball
    and extract its contents to a convenient location to run VS Code. Although, remember
    that updates to VS Code would be handled by VS Code itself, in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio Code is a powerful code editor in itself. However, it may not
    fully support PowerShell right out of the box. You would need to install the extension
    that packs capabilities which help run write and run PowerShell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Launch Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Extensions icon or press `Ctrl+Shift+X` to go to the Extensions
    pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search bar, enter `powershell publisher:Microsoft` and hit Enter to search
    for the PowerShell package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Install in the resulting package–the PowerShell package should be on
    top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the installation completes, click on Reload to reload Visual Studio Code
    with PowerShell capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now ready to develop PowerShell scripts using a friendly editor that
    supports almost all of the capabilities that Windows PowerShell Integrated Scripting
    Environment has, and more!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows PowerShell ISE was the de-facto environment to develop PowerShell scripts
    and even applications written in PowerShell. Then came Adam Driscoll's PowerShell
    extension to Microsoft Visual Studio which integrated PowerShell into the integrated
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: While PowerShell was being worked on, and the .NET Foundation was formed, Microsoft
    started working on a lightweight code editor called Visual Studio Code that packed
    many of the great features of Visual Studio, without all the load of the language
    libraries. This was enough to build PowerShell scripts; most PowerShell *script-writers*
    use mainly the IntelliSense features, and Visual Studio Code has them.
  prefs: []
  type: TYPE_NORMAL
- en: Using a package manager to install VS Code ensures that all the dependencies
    are met. Also, this method of installation ensures that the signing key is added
    to the system. This way, updates to VS Code can be installed through the system,
    such as by running `sudo apt upgrade`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Installing Visual Studio Code on Linux](https://code.visualstudio.com/docs/setup/linux)
    (Microsoft documentation)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring automatic variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps nothing contributes to efficiency like configurability. Configuring
    a system is a way of moulding it to your taste. You are the only one who knows
    best what works for you. Therefore, the more configurable a system is, the better
    it can be moulded to your use. automatic variables in PowerShell are one of the
    first steps to customisation in PowerShell (profiles are the other; we shall look
    into them shortly). In this recipe, we will list out all the automatic variables,
    and configure some of them to our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the *Listing the various providers in PowerShell* section of *Installation,
    Reference and Help*, to learn how to use the various providers in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us first list out the variables we have. This can be done in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a cmdlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us first look at using the cmdlet to list out the variables built into PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window. If you have one open, restart PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the cmdlet that works with variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the noun in a cmdlet is always singular. Therefore, it would be
    `Variable`, and not `Variables`.
  prefs: []
  type: TYPE_NORMAL
- en: There are five cmdlets that deal with variables. We want to fetch a list of
    all variables already existing in a new session of PowerShell. Let us pick `Get-Variable`,
    and fetch help information for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the cmdlet that we need to list out all the variables predefined in
    the current scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That should list out all the variables predefined in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: Any variables you define would be listed here. Hence, it is important that you
    start a fresh session of PowerShell to see what variables have been predefined.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now use a PowerShell provider to list out the variables defined in the
    current scope.
  prefs: []
  type: TYPE_NORMAL
- en: List out the PowerShell providers. We looked at providers in the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Change location to the `Variable:` drive of the `Variable` provider. This is
    done using `Set-Location`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us list out all the available child items of the `Variable:` drive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The output of this was identical to that of `Get-Variable`, called without an
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell is built with some variables that control its behaviour, and administrators
    are allowed to modify some of them to suit the needs. Some variables, however,
    cannot be modified; they are contextual, and add some amount of flexibility (or
    modularity, as the case might be) to the shell.
  prefs: []
  type: TYPE_NORMAL
- en: One such example would be `$PWD`, which contains the path of the present directory.
    This variable changes itself based on the execution of `Set-Location`. Values
    cannot be explicitly assigned to such variables; setting values explicitly would
    have no effect on the behaviour of the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Some variables, on the other hand, accept values, and let us control the execution
    of commands and scripts. We shall look at an example in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the shell behaviour using a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we took a look at the existing variables. In this recipe,
    we will change the value of one of the variables to control the behaviour of PowerShell.
    Again, remember that the change in the value is ephemeral; the values would be
    reset once the PowerShell process is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the previous recipe to understand what automatic variables that come predefined.
    Also, start Visual Studio Code. Follow the steps below to start VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Open Applications (I'm using the Gnome DE, which shows all applications with
    `Super + A`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `code`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press `` Ctrl + ` `` to launch the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on New File at the welcome screen. (Or press `Ctrl + N`.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom right of the VS Code window, you would see the file type set to
    Plain Text. Click on it; you would be taken to the command bar on top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `powershell` at the command bar. The PowerShell Integrated Console will
    open at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4695ded0-1291-4688-85fc-14410d9643aa.png)'
  prefs: []
  type: TYPE_IMG
- en: We are all set for the recipe now.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us run a command that would result in an error. For now, let us not focus
    on the syntax of the command; our only goal for now is to generate an error. At
    the first line of the script window, type in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b0b222fa-1b67-42e4-a78e-d22e94f2bc8a.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the two-liner script using the `F5` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/104cf932-9a53-42b2-8bed-87e13ae01667.png)'
  prefs: []
  type: TYPE_IMG
- en: PowerShell is prompt to show an error. It also displays the `Hello world!` string.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us set the error action preference, using the variable, `ErrorActionPreference`.
    We know there's such a variable from the previous recipe. First, though, restart
    PowerShell. The easiest way is to click on the little bin icon at the top of the
    Integrated Console window. When VS Code asks if you would like to restart the
    session, click on Yes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9254d0b-3222-4b7d-879b-2d8b4063252b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, set the `ErrorActionPreference` variable. At the PowerShell Integrated
    Console, enter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the two-liner script again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no error this time. And we see `Hello world!` at the console.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want the entire script appear at the prompt, make the first line
    of the script, `Clear-Host`; this would clear the screen before showing the output.
  prefs: []
  type: TYPE_NORMAL
- en: What if you were to check whether an error was generated at all? We check the
    value of the automatic variable, `Error`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/48e32e87-abde-4edd-9ca0-6cf1a296a5aa.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Value` column contains some text. Let's select and expand the contents
    of `Value`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/735a62cc-1e23-4373-8710-1f1c53943594.png)'
  prefs: []
  type: TYPE_IMG
- en: The output text is the same as what we received before we set the error action
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: You can also simply call the `Error` variable to read all the errors that occurred
    in the current session.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the error action preference is `Continue`, which means that PowerShell
    would display the error, and continue with the execution of the rest of the script
    (this effect is not noticeable when running individual commands, hence the creation
    of the two-liner, or three-liner in case you added `Clear-Host` at the top). By
    setting `ErrorActionPreference` to `SilentlyContinue`, we instruct PowerShell
    to record the error but not show it on the screen, and at the same time, go on
    with executing the rest of the script.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[about_Preference_Variables, $ErrorActionPreference](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables?view=powershell-6#erroractionpreference)
    (Microsoft documentation)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recipe: Error handling in PowerShell'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling automated execution of commands for each load
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like we saw in the previous recipes, these changes are ephemeral; they remain
    as long as the session is active. There might be situations wherein administrators
    might require running a few commands, or loading modules to enable them to work
    faster. For instance, I tend to load a series of modules that help me manage Microsoft
    Exchange, Active Directory, VMware vSphere infrastructure, Citrix XenApp, Microsoft
    System Center, and other environments using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: If you see, all of these products require different ways of loading the modules,
    snap-ins and scripts, and many of them require certain configuration every time
    you load the modules (such as connecting to VM servers with administrator credentials).
    These can be done using the PowerShell profile.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell by default does not create a profile during installation. It simply
    runs with its default configuration. Any override to this configuration would
    require creating and modifying the profile.
  prefs: []
  type: TYPE_NORMAL
- en: Open a PowerShell console. (You could either run pwsh at the terminal or use
    the VS Code console. This recipe uses the terminal.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reveal the path of your profile. To do this, simply call the automatic variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Check if your profile exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get True as the response, you can proceed with the recipe. If the response
    is False, which is most likely the case, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You may receive an error, saying a part of the path was not found. This is because
    your `~/.config/` directory does not by default contain a `powershell` directory.
    Adding `-Force` to the command creates this directory and creates your profile
    file at the location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c6790c84-4047-427b-933e-47b24beaf1d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now edit the profile in VS Code. At the terminal, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have the profile open now. It would currently be empty. Let us now
    customise PowerShell's error action behaviour. Remember that we said that setting
    `ErrorActionPreference` to `SilentlyContinue` at the terminal was temporary. Let
    us now ensure that `ErrorActionPreference` is permanently set to `SilentlyContinue`
    every time we launch PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the terminal window. If you have the window open since the last recipe,
    restart PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us see what the error action preference is at the moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Switch to VS Code. The profile should already be open for edits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the very first line, type in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Save the profile and close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the terminal, type `exit` to exit from PowerShell. Start PowerShell again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us now check what the value is for `ErrorActionPreference`. At the prompt,
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure the preference is indeed in place, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/bf5a2583-205d-4e2a-b756-4611f2977719.png)'
  prefs: []
  type: TYPE_IMG
- en: The cursor simply returned to the prompt at the next line without throwing an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Long story short, the PowerShell profile executes every time a PowerShell session
    is loaded. This profile is a PowerShell script file that can contain a series
    of commands and functions, which would be executed just like another script.
  prefs: []
  type: TYPE_NORMAL
- en: One important point to remember is that there is a different profile for each
    host. For instance, there is a separate profile for PowerShell loaded on the Terminal,
    and a different one for the Integrated Terminal on VS Code. This is because each
    of the terminals has a different nature.
  prefs: []
  type: TYPE_NORMAL
- en: Execution Policies have not been implemented in PowerShell on Linux. In case
    PowerShell on Linux gains the safety belt in the future, the execution policy
    should be set to allow execution of scripts in order for the profile to load.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is bad practice to set a global action preference. Empty the profile to
    remove the error action preference. Since the profile has nothing else, you could
    even delete the profile using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Read the best practices for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Customising the terminal prompt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we customised the error action preference using the
    profile. We used an already-demonstrated command to show that commands that can
    be run on the PowerShell console can be added to the profile as well, and this
    was a way to automate running a certain set of commands which could be used to
    increase productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take the next step and customise our console prompt. The options
    are theoretically endless; this recipe is just another demonstration of how flexible
    PowerShell is.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need VS Code for this recipe. If you did not follow along the last recipe,
    follow the steps in the *Getting Ready* section of the last recipe to create a
    PowerShell profile, only this time, run the commands at the PowerShell Integrated
    Console of VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that the profile is empty. If you just created the profile, you can simply
    proceed further. If not, clear all contents in the profile. If the error action
    preference is set in the profile, it would become hard to troubleshoot scripts
    that you create in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the following in the main window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Save the profile script file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the little bin icon at the top of the Integrated Console to kill the
    current PowerShell session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When VS Code prompts you whether you would like to restart the session, click
    Yes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your prompt should look as shown in the image below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6f8c8ed-8df5-4d42-8415-d37b24ac6e27.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The prompt is controlled by a function called `prompt`. To demonstrate this,
    we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that there is indeed such a command, which is of the type
    `Function`. To know the contents of the `prompt` function, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The output shows you the entire function you just wrote. This is, however, the
    function that overrode the default `prompt` function. If you clear your profile,
    restart the PowerShell session, and type in the command above, you would see a
    simple three-liner output, which is the default `prompt` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to break down the function we wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you declare the function you are about to write. This is done using the
    keyword, `function`, followed by the name of the function. Since we want to work
    with the prompt, we use the existing function name so as to override the default
    functionality. The next thing that follows is the script block, which starts with
    a `{`.
  prefs: []
  type: TYPE_NORMAL
- en: We want the location to appear at the prompt. This is a must-have information,
    for obvious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, PowerShell shows the complete Home path at the prompt. While
    this works, we are used to the tilde for Home. Also, I know that Documents, Music
    and other folders reside within my Home folder, and I would rather have just the
    name of the folder appear at the prompt. This would mean some text manipulation.
    Therefore, I assign the current location to a variable, `$Location`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we perform a switch-case operation and arrive at the value for what needs
    to be displayed at the prompt. Don't worry about the syntaxes for now; we will
    look into each of those in the chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we use a few `Write-Host` statements to construct the prompt text. The
    `-NoNewLine` parameter ensures that the contents of each statement do not go to
    the next line. When we need a line break, we explicitly add `` `n ``.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to break a long-running line in a script, use the backtick (`` `
    ``) character at the point where you would like to break the line and press Enter
    to break the line after the backtick. PowerShell would treat the line with the
    backtick, as well as the line that follows, as the same line. Similarly, if you
    would like to write two statements in the same line, use the semicolon (`;`) at
    the end of the first statement, and continue with the second after a space. PowerShell
    will treat both the clauses as separate statements, just like plain English.
  prefs: []
  type: TYPE_NORMAL
- en: Since `Write-Host` just sends text to the host, and does not return anything,
    we add a return statement to the function, with merely an empty space.
  prefs: []
  type: TYPE_NORMAL
- en: When we reload the PowerShell Integrated Console, the profile is loaded, and
    this time, the custom `prompt` function in the profile overrides the default `prompt`
    function, and presents us with a nice prompt, formatted just the way we defined.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play around with the sequences and the contents of the `Write-Host` statements
    for now to customise your prompt. Once we are comfortable with the syntaxes in
    PowerShell, we should be able to customise the profile further.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[about_Prompts](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_prompts?view=powershell-6)
    (Microsoft Documentation)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding standard redirection in PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started using the command line interface, I was daunted by `<`
    and `>` and `>>` at first. Then, I entirely stopped using the command line interface
    for a while and went back to the Windows administrator ways, albeit with an unusual-for-a-Windows-admin
    level of use of keyboard shortcuts (it's all about the speed and efficiency!).
  prefs: []
  type: TYPE_NORMAL
- en: When PowerShell came along, I had forgotten about those operators; I simply
    went ahead and understood the concept of object and pipelines, and worked for
    years that way. Switching to Linux at home made me want to know the "Linux way"
    of using the terminal. The operators came back to haunt me. I simply installed
    PowerShell on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Redirection in PowerShell mainly relies on streams. And streams are covered
    in a different chapter. For now, we stick with the default stream, which is, `Success`.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe covers the different, simple redirections to help with basic administration.
    We shall come back to streams while understanding the concepts of error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, let us understand that PowerShell is very different from Bash
    in terms of redirection, although it packs some minor similarities; similarities
    enough to make you not go away, but rather appreciate the flexibility of the object
    model, and the uniformity of use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We shall perform four activities in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Redirect output to a file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append another output to the same file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the output of a command to the console as well as a file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the input of one command into another
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apart from the operators that we use in the first two activities, we will also
    look at the cmdlet equivalents to those operators.
  prefs: []
  type: TYPE_NORMAL
- en: List out all the processes running on your computer at the moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The output was shown on the console. Now, let us redirect the contents into
    a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: List out the contents of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let us now append the file with the date and time stamp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Read the contents of the file now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the file now contains a list of all the processes running in
    the system, as well as the time stamp. The time stamp got *appended* to the file.
  prefs: []
  type: TYPE_NORMAL
- en: When going the *PowerShell way*, the same results can be accomplished using
    the `Out-File` cmdlet. (`Out-File` has more features such as setting the encoding
    and new line control.) Let us accomplish the same tasks using the `Out-File` cmdlet.
    You may want to delete `processes.txt` before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Let us list out the currently-running processes again, and send the output to
    a file using `Out-File`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us append the time stamp to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you notice, the output of `Get-Process` and `Get-Date` went directly to the
    file; nothing got displayed on the host.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to display the output on the console as well as send the content
    to a file, we simply use `Tee-Object` instead of `Out-File`. If you would like,
    delete the file, `processes.txt` again.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The list of running processes should be shown at the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Check the contents of the file, `processes.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the list of processes appears in the text file as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now proceed with learning to make cmdlets accept input from files. Linux
    administrators are used to making commands accept input from a file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The command accepts input from `input_file.txt`, and performs operations on
    the input content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PowerShell, this is handled using `Get-Content` and the pipe (`|`). The
    PowerShell equivalent of a command accepting input from a file would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This might seem the other way around to most of those who are not used to PowerShell.
    Let us break down the process into pieces and try to understand it better. For
    instance, let us say you have a list of files in a text file called `input.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Reveal the contents of the text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/cfa87d64-fffb-4078-a37e-18d89fb00bae.png)'
  prefs: []
  type: TYPE_IMG
- en: List out the contents of the current directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have five test files in the current directory, four of which are in the list
    (the input file). Let us say that you would like to delete the files listed in
    the input file, from the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Pass the output of `Get-Content` to the command, `Remove-Item`, through the
    pipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f5ac1741-e892-4737-9bc2-842204050c21.png)'
  prefs: []
  type: TYPE_IMG
- en: List out the files currently present in the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Et voilà! If you compare the outputs of `ls` (before) and  `Get-ChildItem` (after);
    the files that were listed in the text file are no more.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we set out to understand the similarities between Bash and PowerShell.
    In spite of being fundamentally different from Bash, PowerShell does pack some
    similarities to Bash. Two of the similarities, as we saw, are passing content
    to files and appending content to the files.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at three cmdlets in this recipe, one of which were used twice.
  prefs: []
  type: TYPE_NORMAL
- en: Out-File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those comfortable with Bash use the `>` for sending the output to a file, and
    `>>` to append the output to an existing file. in PowerShell, we use the `Out-File`
    cmdlet. We run a command that sends output to the standard out, and through the
    pipe, redirect the output to `Out-File`, which handles writing the output to a
    file. Usually, `Out-File` is used to send content to a text file.
  prefs: []
  type: TYPE_NORMAL
- en: When there is a need to append the content to a file, we use the `-Append` switch
    with `Out-File`. This way, if the file that is being written to already contains
    content, the content isn't overwritten (overwriting content is the default behaviour
    of `Out-File`).
  prefs: []
  type: TYPE_NORMAL
- en: Tee-Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations wherein you need to send content to a file, as well as
    display the content on the console. This is handled using a simple call of `Tee-Object`.
    `Tee-Object` works like the letter T; apart from sending content to a file or
    a variable, it also sends the content down the pipeline. In case `Tee-Object`
    is the last cmdlet in the statement, the pipeline output is sent out to standard
    out, which in most cases is the host (or in other words, the console by default).
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, we sent the first output to the file, `processes.txt`, and the
    second output was not sent down the pipeline. Therefore, `Tee-Object` picked the
    standard out.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting input from file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This process is significantly different in PowerShell, compared to Bash. In
    Bash, we call the command first, and then ask it to accept input from a file.
    In PowerShell, we make PowerShell read the contents of the input file first, and
    then send the output to the command that accepts input through the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, we read the contents of the file, `input.txt`, which contained
    a list of four file names. We used `Get-Content` to read the content from the
    file. `Get-Content` sent the output to the standard out at first, thereby showing
    us the contents of the file. We then added a pipe to tell PowerShell that we need
    further processing, and then, added `Remove-Item` to the command chain. (`Remove-Item`
    deletes items, which could be directories, files or links.)
  prefs: []
  type: TYPE_NORMAL
- en: As we would see later in this chapter, the first parameter (positional parameter,
    position 1) of `Remove-Item` is `Path`, which is also the parameter that accepts
    input through the pipeline. For more information, run the following command and
    read about the `Path` parameter of `Remove-Item`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b1fcf9d5-5153-4ba2-a432-5bbcb8028f80.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clean up the contents that we created for this recipe if you are the type that
    likes directories clean! If we need more files or directories in later recipes,
    we will create them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipe 3.8: Understanding cmdlets and parameters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recipe 1.6: Looking for help information specific to a parameter'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling native Linux commands from PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapter, *Introducing the Core and its Capabilities*, we saw how native
    Linux commands were not convenience aliases in PowerShell on Linux, but the commands
    themselves. In this recipe, we would demonstrate using Linux commands at the PowerShell
    prompt. Remember how we used a Bash terminal to run the commands `ls -l` and `awk`
    to list the contents of a directory, and separate the columns in the output, in
    the recipe, *Comparing the outputs of Bash and PowerShell*. We will perform the
    same operation on the home directory, from with PowerShell, without using any
    of the PowerShell cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is recommended that you have a Windows PC with PowerShell installed on it
    (Windows PowerShell would also do) in order to compare the outputs and see if
    we encounter any errors.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the PowerShell prompt, type in the following command to list the contents
    of the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You see the familiar output (albeit without any of the colours, if your terminal
    emulator uses colours for file names).
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at the .NET Type Name of the output. For this, we would need
    to use the `Get-Member` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'PowerShell displays, `TypeName: System.String`, which is consistent with what
    we saw in the aforementioned recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a Windows PC with PowerShell (or Windows PowerShell), run the same
    command on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice the .NET Type Name here; it is `System.IO.DirectoryInfo`, and if you
    scroll down the console a little, you would also see `System.IO.FileInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, at the PowerShell on Windows (or Windows PowerShell) prompt, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You would receive an error, stating that there was no value given to the parameter,
    `LiteralPath`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d565f397-477e-4b86-9518-f45d18ed8ab4.png)'
  prefs: []
  type: TYPE_IMG
- en: At the PowerShell prompt on the Windows PC, enter the following and press the
    Tab key on your keyboard, instead of Enter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You would see that the parameter name was completed to `LiteralPath`.
  prefs: []
  type: TYPE_NORMAL
- en: Press the Esc key to clear the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Come back to Linux, and at the PowerShell prompt, type in the following and
    press the Tab key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing happens. Now, enter the following and press the Tab key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The parameter name was completed to `-LiteralPath`. Let us take one more step
    and conclude this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: At the PowerShell prompt on Windows, run the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/91a6d14f-bbab-406c-8212-2285ff34399e.png)'
  prefs: []
  type: TYPE_IMG
- en: Switch back to Linux and run the same command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You receive an error stating that there is no such alias.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75f2ffac-79de-4a70-af27-a3f0ade44b63.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run any of the Linux commands on PowerShell on Linux, PowerShell does
    not call the convenience aliases that were created for the benefit of Linux administrators,
    when Windows PowerShell was launched; these convenience aliases have not been
    included in PowerShell on Linux. PowerShell, instead, runs the actual Linux commands
    and shows the output on the console. Piping the output to other Linux commands
    work the same way as they do on Bash, when running them on PowerShell on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The first point to note is that `ls -l` is an actual command in Linux, and it
    returns the list of files and directories in the current directory, in a table
    format. When the same command is run on PowerShell on Windows, we receive an error,
    since PowerShell on Windows interprets `ls` as `Get-ChildItem`, and `-l` as the
    incomplete-but-definitive call to `-LiteralPath` and returns an error that the
    literal path was not specified.
  prefs: []
  type: TYPE_NORMAL
- en: When we run `Get-Alias` on `ls` on both the operating systems, PowerShell on
    Linux returns an error, while PowerShell on Windows shows the underlying PowerShell
    cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: The other point that pins down this fact is that the output of `ls` is string,
    as opposed to a system object, when the same `ls` is run on PowerShell on Windows.
    On Windows, PowerShell calls `Get-ChildItem` under the hood, and the output shown
    is that of `Get-ChildItem`. This is supported by the type name in the output of
    `Get-Member`, which is from the `System.IO` namespace. On the other hand, on Linux,
    running `Get-Member` on the output of `ls` simply returns `System.String`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[about_Aliases](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases?view=powershell-6)
    (Microsoft documentation)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding cmdlets and parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of our scripting and administration is going to revolve around running
    cmdlets and chaining them. In some situations, we run a cmdlet expecting it to
    work a certain way, only to find out that the cmdlet threw an error, or worse,
    did something undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: The key to getting cmdlets to do what we want them to do is  to eliminate ambiguity.
    In this recipe, we will learn to construct commands contextually and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the Help section of the first chapter, *Installation, Reference and Help*.
    Let us understand the notifications used in the help information that `Get-Help`
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: While this may not be an exhaustive guide to using help, it should cover most
    of your daily help document reading needs. The idea is to show you the notations.
    These notations may appear in several combinations (parameter values in curly
    braces, surrounded by square brackets, for example).
  prefs: []
  type: TYPE_NORMAL
- en: '| **Notation** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `-Parameter <DataType>` | No square brackets: Mandatory parameter, named.
    The parameter must be called by name, and a value of DataType must be specified.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[-Parameter <DataType>]` | Square brackets around the parameter-data-type-pair:
    Optional parameter, although, it must be called by name, and a value of DataType
    must be passed. |'
  prefs: []
  type: TYPE_TB
- en: '| `[-Parameter] <DataType>` | Square brackets around the parameter name: Positional
    parameter. You can simply pass a value of DataType to the cmdlet, as long as the
    value is at the position shown by the parameter in the help text. The parameter
    need not be called by name as long as the position is right. |'
  prefs: []
  type: TYPE_TB
- en: '| `[[-Parameter] <DataType>]` | Square brackets around the parameter name,
    and another pair of square brackets around the parameter-data-type-pair: Positional
    parameter, which is optional. |'
  prefs: []
  type: TYPE_TB
- en: '| `-Parameter <DataType[]>` | Square brackets after DataType: Multi-valued
    parameter. This parameter accepts multiple values as input, each pair of values
    separated by a comma. |'
  prefs: []
  type: TYPE_TB
- en: '| `-Parameter` | No data type: Switch parameter. Calling the parameter makes
    the switch $true, and not calling it uses the default value for the switch. To
    disable the switch, set it to false, like -Parameter:$false. |'
  prefs: []
  type: TYPE_TB
- en: '| `-Parameter {Value1 &#124; Value2 &#124; Value3}` | Values surrounded by
    curly braces: Parameter that accepts predefined values as input. In this case,
    you would call the parameter like `-Parameter Value1`, or `-Parameter Value2`.
    In other words, this parameter does not accept arbitrary values. |'
  prefs: []
  type: TYPE_TB
- en: 'Bash champions take note: PowerShell needs a comma separating the values in
    a multi-valued parameter. Therefore, if you would like to call `Remove-Item` on
    three files, you would enter `Remove-Item file1, file2, file3`. If only a space
    separates the values (like Bash''s input), PowerShell will consider the three
    values as values to three positional parameters, and would either throw an error,
    or do something you did not want it to, based on the cmdlet you call.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, anything surrounded by square brackets is optional. Anything surrounded
    by curly braces indicates predefined parameter values (the pipe separates each
    value). Data type followed by an empty pair of square brackets indicate array
    of that data type. And the position of the parameter is to be noted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the combination: `Required` is false, there is a default value as shown
    in the text below the parameter name, and the position is `1`. This means that
    you can simply call the cmdlet, and it would run itself against the default value
    for its first parameter. The example used here is `Get-ChildItem`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was a long getting ready section. Let us now put this knowledge to use.
  prefs: []
  type: TYPE_NORMAL
- en: Run a command to get a list of files and directories in the current location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Let us now add a `.` to indicate the current location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Compare the outputs of the last two commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let us go with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Is the output the same as that of the last two commands?
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following and note the values for each of the keys below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Next, create a file in the current location, called `file1` by calling the parameter
    by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two possibilities: `Path` and `Name`. Look for information on `Path`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If we use `Name`, we have to call it by name (no pun intended). If not, we can
    specify the name as part of `Path` (no alliteration intended either).
  prefs: []
  type: TYPE_NORMAL
- en: Let us use `Path` first. “`-Path`” need not be written, since it is a positional
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Try the same operation with `Name`. This time, mention the parameter name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If you would like, create a third file, by calling `Path` by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: List out the contents of the current location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The files are present.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now delete the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Mention the file names as paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: List the contents of the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us delete multiple files in one shot. And this time, let us call the
    parameter by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Let us now create a directory. We need to use parameter called ItemType, which
    has predefined values, based on the provider (we are using `FileSystem`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three new files like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us delete the contents. Wait for a confirmation prompt to appear after
    running the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Read the prompt. It talks something of the `Recurse` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `L` and press Enter to abort the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: That was quiet! List out the contents of the current directory to ensure `test-dir`
    is gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The directory is indeed gone.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with cmdlets is simple. There are two kinds of parameters: named and
    positional.'
  prefs: []
  type: TYPE_NORMAL
- en: Positional parameters work based on the position. They are programmed in such
    a way that PowerShell understands their logical sequence and performs its actions.
    For instance, when moving items, the general way of working is to call the command,
    pass the source first and then the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: would mean that you want to move the directory, `GitHub` to `Code`. Many PowerShell
    cmdlets are programmed to understand this.
  prefs: []
  type: TYPE_NORMAL
- en: Named parameters, on the other hand, are to be called by name. Help text shows
    them without any brackets surrounding them. Calling the positional parameters
    by name is optional—you are allowed to simply pass the values. However, be careful
    with what position or sequence you mention them in.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to always pass parameter values, calling them by name when
    writing scripts. When running quick commands, on the other hand, you may omit
    calling positional parameters by name in the interest of speed.
  prefs: []
  type: TYPE_NORMAL
- en: Some parameters have predefined value validation added to them. These parameters
    accept only those values that have been defined in them. For instance, `ItemType`
    only accepts `File`, `Directory`, `SymbolicLink`, `Junction` and `HardLink` as
    values as of writing this section.
  prefs: []
  type: TYPE_NORMAL
- en: And then, there are switch parameters. `Recurse` is an example. When you call
    these parameters with no value, the parameters assume `True` in most cases. When
    you have to set them to `False`, you mention, `-Parameter:$false` (for example,
    `-Confirm:$false`). If you do not call the switch parameter, the parameter goes
    with the default value specified in the cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you would like to create the files and directories again, don't run four
    commands. Run the following two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The parameter, Force, creates `test-dir` when creating `child-dir`.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and delete the entire directory if you want to, without the `Recurse`
    parameter. At the confirmation prompt, press Enter (`Y` is the default response).
  prefs: []
  type: TYPE_NORMAL
- en: Running cmdlets with minimal keystrokes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commands have been made to be short, historically. However, the situation turned
    into a dilemma over time, since shorter commands meant that they had to be remembered,
    and longer commands meant more keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell has long commands, however, it deals with them in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Aliases, which tend to be shorter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tab completion, which require more keystrokes than aliases, but don't require
    remembering much.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first way necessitates using our memory to recall command names as required.
    The second, on the other hand, solves the keystroke issue efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Bash users are used to getting a list of matches laid out in a nice tabular
    format when the tab key matches more than one strings in the context. On the other
    hand, the matches cycle at the cursor in Windows (which most Bash users find "weird").
  prefs: []
  type: TYPE_NORMAL
- en: Be that as it may, tab completion is a boon, and this recipe makes complete
    use of tab completion and simple string matching to significantly reduce keystrokes
    when using PowerShell cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the Gnome Terminal terminal emulator for this recipe, and tab completion
    on PowerShell on Linux on Gnome Terminal behaves exactly the same way that it
    works on Bash on Gnome Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: If only one word matches the string before the tab, the word is completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple words match the string before the tab, all possible options are
    listed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using VS Code for this recipe, or a different terminal emulator,
    its behaviour may be different.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us get right to it!
  prefs: []
  type: TYPE_NORMAL
- en: Say, we would like to get the list of files and directories within the current
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The right way of doing this, as per best practices would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as we''ve seen before, the easy way of doing this would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We would use the former way when including the cmdlet in a script. This avoids
    ambiguity, in most contexts that the script would run in. This usually means minimal
    bugs. The latter, on the other hand, is the short way of running the same cmdlet,
    by leveraging the user-friendly features of it, combined with the awareness of
    the environment as an intelligent human. This approach significantly reduces key
    strokes–three characters, as opposed to twenty-one.
  prefs: []
  type: TYPE_NORMAL
- en: Although, if you are writing a script and would like to reduce keystrokes, you
    could still do it, without having to remember things such as `gpv` means `Get-ItemPropertyValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter: Tab completion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the keystrokes mentioned below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Those were ten keystrokes including <Enter>.
  prefs: []
  type: TYPE_NORMAL
- en: There may be situations wherein you would need to call a named parameter. And
    the named parameter might be long.
  prefs: []
  type: TYPE_NORMAL
- en: Find a command that has `ComputerName` as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c624b608-e1c3-4cae-91db-beeec2cef223.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But it throws an error. The error says, `Possible matches include: -ParameterName
    -ParameterType`. This is the caveat in PowerShell on Linux. Let us try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e5f9420d-d558-4df5-957a-64e2e050e962.png)'
  prefs: []
  type: TYPE_IMG
- en: Read the list of possibilities and select `ParameterName`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete resolution of that would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: And it worked.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us suspend the activity in our session for, say, five seconds. The
    cmdlet for this would be `Start-Sleep`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us first get help on the cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The help text says that the parameter at position one, which need not be named
    is `Seconds` (square brackets around Seconds in the second parameter set), and
    it accepts integer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to suspend the session for five seconds, we would use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted the session (or script) suspended for 100 milliseconds, we would
    need to use the named `Milliseconds` parameter. With tab completion, it would
    be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would resolve to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, in fact, reduce the number of tabs when using parameter names. Just
    type enough for PowerShell to uniquely identify the parameter name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would resolve to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: If the delay was not noticeable, feel free to increase the number a little (say,
    3000).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen how to use aliases. Aliases work just like normal cmdlets,
    including the syntax of their parameters. The only catch is that we have to remember
    the aliases. Custom aliases, as shall see in the best practices section, are a
    bad idea given that the aliases have to be imported everywhere we want to run
    scripts that have custom aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Tab completion on the other hand, reduces the number of keystrokes, but requires
    muscle memory. It requires some level of practice, given which, significantly
    improves productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tab completion works when writing cmdlets, writing parameter names, as well
    as when passing pre-defined values to parameters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Which completes to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In many situations, it is not necessary to use tab completion at all, for instance,
    in the case of `Start-Sleep`. There is no parameter that starts with `m` in case
    of the cmdlet. Therefore, using `-m` was sufficient for PowerShell to uniquely
    identify `-Milliseconds`. That saved us the `<Tab>` keystroke as well.
  prefs: []
  type: TYPE_NORMAL
- en: Productivity with respect to writing scripts in PowerShell is a skill that comes
    with practice. While aliases sure are a shortcut to speed, they have their perils.
    On the other hand, using the keyboard to write scripts helps with muscle memory,
    which not only helps us think in PowerShell, it also helps speeding up tab completion,
    which works equally well when running commands at the console, or writing scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Using short parameter names is generally not a good practice while scripting;
    use these with a similar caution as aliases. Short parameter names affect readability,
    and also, might break scripts at some point in future. For instance, if you call
    a certain cmdlet in a script, with a short parameter name `-comp`, which at the
    time of the creation of the script, stood only for `ComputerName`. Later, imagine
    the cmdlet received an update with an added parameter, `-CompatibilityMode`; this
    would break the script that you wrote.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to type most commonly used cmdlets along with the parameters to practice
    tab completion.
  prefs: []
  type: TYPE_NORMAL
- en: Get familiar with VS Code by typing the cmdlets in the script pane. Notice how
    cmdlet, parameter and parameter value completion work in VS Code. If you prefer
    completion to work the same way as at the console, refer my custom settings JSON
    in the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Finding parameter aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We worked with aliases for cmdlets, we saw how to uniquely identify parameter
    names without having to type the entire parameter name, and we also looked at
    leveraging the power of tab completion.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the cycle, let us also look at parameter aliases.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, parameter aliases work very similar to cmdlet aliases.
    The primary goal of these aliases is to reduce keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter aliases are not documented in a friendly way, however, can be easily
    found thanks to the object-oriented model of PowerShell. In this recipe, we shall
    look at how to fetch parameter aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Find all the commands that take in `ComputerName` as a parameter, with minimal
    keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This resolves to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7de20ecf-5174-4e9e-a5ae-9e024c717114.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output was the same as what we ran a while ago:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: How did PowerShell know that `Cn` stands for `ComputerName`?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameters are part of cmdlets, and `Get-Command` is the cmdlet that fetches
    information about cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, let us pick the cmdlet, `Invoke-Command`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Examine the object that this command outputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The output shows a member called Parameters. Use the member access operator
    to pick the member.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: See what members this member contains.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Would Values show us the information we need?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Yes, that does give us something, but there is too much output. We need only
    the parameter names and their aliases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: There you go.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw while reading about the Core and its capabilities, that PowerShell, most
    of the time, returns objects. And every object can have objects within itself.
    Going by the same path as that of .NET, a member access operator can be used to
    select the members (which could be properties or methods). Properties are addressed
    by simply using the property names, while methods need arguments passed to them
    (an empty pair of parentheses is still needed if no argument is being passed).
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of a cmdlet are objects of the output that the `Get-Command`
    cmdlet returns. Therefore, calling `Get-Command` with the cmdlet, `Invoke-Command`
    returns data about `Invoke-Command` as the output object. This can be further
    broken down to several other objects (members), among which, there is `Parameters`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Parameters` itself can be further broken down into other members, `Values`
    being one of them—`Values` contains the names of the parameters, as revealed by
    running `Get-Member`.'
  prefs: []
  type: TYPE_NORMAL
- en: We select two objects from within `Values`, called `Name` and `Aliases`.
  prefs: []
  type: TYPE_NORMAL
- en: These parameter aliases can be used in place of parameters themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two caveats with parameter aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: They are case-sensitive, which means reaching for the Shift key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have to be remembered, even though they have a pattern to them, just like
    how cmdlet aliases do (`ip` for `Import` and `g` for `Get`, for instance).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a PowerShell script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell scripts are nothing but a series of PowerShell cmdlets, each in a
    line of a `ps1` file. These instructions are executed one after the other, similar
    to the good old shell script. Using VS Code makes running PowerShell scripts simpler,
    in that you simply have to run the script to make the script work its magic.
  prefs: []
  type: TYPE_NORMAL
- en: However, running PowerShell scripts on VS Code is not the usual way of automation
    for obvious reasons. Also, there are many ways to run a PowerShell script. We
    shall look at a very simple way of running the script in this recipe; as we progress
    in the book, we will also add more features to our scripts, and further, will
    package them into modules for future use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses VS Code to write the script. While any text or code editor
    would work for the script, we use VS Code because in my experience, VS Code is
    the friendliest editor for  PowerShell scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Open VS Code, create a new file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new directory at a convenient location (`~/Code`, perhaps?).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the empty file as `hello-world.ps1` within the directory you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the bottom right of VS Code; it should now say, `PowerShell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press `` Ctrl + ` `` to close the console at the bottom to reduce distraction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything is as shown in the screenshot below, you are good to go. (Ignore
    the colour of the status bar at the bottom, as well as the git status at the bottom-left
    for now.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23eb3582-a3de-490a-804e-16c977434c72.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the script pane, type in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Save (**File** > **Save** or `Ctrl + S`) the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Debug** in the left. Alternatively, press `Ctrl + Shift + D`. This
    opens the Debug pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the green play-button-like **Start debugging** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The console should pop out and display `Hello, World!`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us run the script one more time. This time, we will not open the Debug pane
    or press buttons on the screen. Simply, press `F5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Hello, World!` should again be displayed in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ab2165b-fadb-4c0e-b8e4-b87e283c3067.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us now call the script without using the debug controls.
  prefs: []
  type: TYPE_NORMAL
- en: Close the file (Ctrl + W).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt on the console, type in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: You should see `Hello, World!` appear.
  prefs: []
  type: TYPE_NORMAL
- en: Now, navigate to home.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, type `&`, add a space, `./` and start typing the path to where you stored
    the script. Use tab completion just like how you would on Bash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you reach the location of the script file, press Enter to call the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7d6b31d4-f323-4db3-81a8-b7aaa3faf1b9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to run a PowerShell script is to debug it at the Integrated
    Scripting Environment. We use VS Code as our ISE of choice in this case. The other
    two ways of calling the script described in this recipe are from the PowerShell
    console. You may use the integrated console in VS Code, or a PowerShell console
    called at the Terminal for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the script is located at the present working directory, PowerShell just
    calls the `ps1` file and executes it. Another way of calling PowerShell scripts
    is to use `&` (or the **call operator**): type `&` followed by a space, followed
    by the path to the script file. This way of calling handles spaces in the path
    well.'
  prefs: []
  type: TYPE_NORMAL
- en: If the path to the script contains spaces, the path would need to be surrounded
    by quotes. This would make PowerShell think that you are simply giving it a string
    value. PowerShell would, then, simply display the path as text the moment you
    press Enter.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `&` call operator, you tell PowerShell that you want to run
    a script (or a command).
  prefs: []
  type: TYPE_NORMAL
- en: Another way of calling scripts is to use `.` (or the **dot operator**), which
    we shall look at in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Dot-sourcing a PowerShell script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to call PowerShell scripts from outside of
    the ISE. We gave PowerShell the path, and explicitly mentioned that we would like
    it to run the script, by using a call operator.
  prefs: []
  type: TYPE_NORMAL
- en: This way is ideal if you would just like the script to perform its task and
    not leave anything behind, like variable values and such. However, there are situations
    wherein we would like to run a script and, say, retain values of the variables
    we declared and assigned in them, or use the functions we declared in them.
  prefs: []
  type: TYPE_NORMAL
- en: In such situations where we would like the functions, variables and even aliases
    retained in the current session, we use dot-sourcing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you deleted the file after the previous recipe, restore it or recreate it
    using the steps in the previous recipe. Then,
  prefs: []
  type: TYPE_NORMAL
- en: Open the script file that you created in the previous recipe. At the second
    line, type the following.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Save the script. Do not run it yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place your cursor at the integrated console, and call the script using the call
    operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We declared $Message and assigned a string value to it. Call the variable to
    see what value it contains.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, dot-source the script. (There are two dots; one is the operator, and the
    other after the space is reference to the current directory.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Call the $Message variable again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a0c0e9b2-1b76-46b1-97de-239dcda9adea.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a script or a command is called using the call operator, the script or
    command is simply run without the current session (or technically, scope) being
    modified. The command or script runs and exits without changing anything pertaining
    to the session, including changes to built-in/automatic variables.
  prefs: []
  type: TYPE_NORMAL
- en: When changes to the scope are desired, the script or command must be dot-sourced.
    This way, whatever variables, functions or aliases are defined in it, are retained
    in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new alias using `New-Alias` within the `hello-world.ps1` script. Try
    to get the value of the alias after first calling the script (using the debug
    control, as well as using the call operator), and then, by dot-sourcing the script.
    Observe the outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a PowerShell cmdlet from outside of PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have learnt to call cmdlets from the console, run scripts at the ISE,
    and call scripts in two modes. In this very short recipe, we shall learn how to
    call a PowerShell cmdlet from outside of PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a Terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Read the syntax for the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/23321ef5-fc49-4e61-a77e-e957c0051db9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us now run the `hello-world.ps1` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/705055a1-23b9-4322-bb0b-ee77122284eb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell is not an application that runs on top of Bash. PowerShell is a shell
    itself. However, it can be called from with Bash just like another application.
    Like applications, the `pwsh` command takes in arguments, which are then processed
    by PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: The two main ways we may want to use PowerShell from within Bash is to run a
    single command, or call a script file. You can even call a script block, however,
    this must be done from within PowerShell. In most cases, running single cmdlets
    or calling a script should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: In general, when calling `pwsh` with cmdlets, make `-Command` (or `-c`) the
    last parameter, since anything that comes after the cmdlet itself is considered
    cmdlet arguments. Same goes for `-File` as well.
  prefs: []
  type: TYPE_NORMAL
- en: When a script is designed to accept arguments, the script arguments can be passed
    after the script name, just like with cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: Recording the cmdlets run on the PowerShell console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, there are situations in which you perform a series of tasks on your PowerShell
    console, and after quite some trial-and-error, come across a solution. And then,
    you wish you had recorded everything you did on the console. You could still copy
    content from the console, so you try to scroll up. But you can only go so far.
    Your command history (a little like Bash history) can help you, but sometimes,
    that feels limited as well.
  prefs: []
  type: TYPE_NORMAL
- en: A few months ago, we were troubleshooting a sync issue between two of their
    software update distribution systems which were supposed to work in sync. After
    some of us were done beating around the GUI, (of course) we decided to pick PowerShell
    to fix the issue. We ran a series of commands, and after a few hours of fighting
    with the systems, the systems yielded, and we were back up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our managers asked for all the steps that we took to achieve this, so that
    they could be documented for future use. Of course I cannot tell you all the steps
    that we took—because: a) scope of the book, and b) agreements with our clients—but
    I can tell you what can help in such situations.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start PowerShell at the terminal, or use the PowerShell Integrated Console on
    VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: You can also simply run the cmdlet without any arguments; it would automatically
    create a text file with an auto-generated file name. Get the current system date
    and time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: List out all the files and directories in the current location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file within the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Add content to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Delete the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Stop recording what you did.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: You should have now received the location of the transcript file. Read the contents
    of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3b8eda4d-a326-4155-b8ea-67f3d63f7aa3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A transcript created by running `Start-Transcript` stores all of your actions
    and the console output of all of the commands you ran, in a text file. The transcript
    also contains some of other useful information pertaining to the context the commands
    were run in.
  prefs: []
  type: TYPE_NORMAL
- en: A transcript file is a little more than a history file, in that the former contains
    the output of the commands, apart from the commands themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start-Transcript` cmdlet does not require any argument at all; it can create
    a text file at the user's home, with a unique name to ensure that no other transcript
    is rewritten. In other words, `Path` is an optional parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this chapter about preparing for administration using PowerShell.
    It's time to crack your knuckles and refill your coffee mug. Did I tell you coffee
    speeds up thinking in PowerShell? Placebo, you say? Let's not get into an argument
    right now.
  prefs: []
  type: TYPE_NORMAL
