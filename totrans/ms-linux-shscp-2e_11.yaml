- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will talk about the most mysterious part of using **stream
    editor** (**sed**) and AWK. They are regular expressions, or regexes for short.
    In the previous chapters, we discussed some regular expressions shyly and that's
    because we don't need to dig into them without a good understanding.
  prefs: []
  type: TYPE_NORMAL
- en: If you understand how regular expressions are written, you will save a lot of
    time and effort. With regular expressions, you will unleash the real power behind
    sed and AWK and will use them professionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining BRE patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining ERE patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `grep`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter11](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter11)'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with, what are regular expressions?
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are strings that the regex engine interprets to match a
    specific text. It's like an advanced way of searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you want to search a file for lines starting with any small letters,
    or you want to search for lines that contain a number, or maybe search for lines
    starting with specific text. The normal search can''t be generic: the only way
    to do that is to use regular expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: And what is the regex engine?
  prefs: []
  type: TYPE_NORMAL
- en: The regex engine is the piece of software that understands these strings and
    translates them to find the matched text.
  prefs: []
  type: TYPE_NORMAL
- en: There are many regex engines out there; for example, the engines that are shipped
    with programming languages such as Java, Perl, and Python. Also, the engines that
    Linux tools use are sed and AWK, and the important thing for us now is to learn
    the types of regex engine in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of regex engine in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Basic Regular Expression** (**BRE**) engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Extended Regular Expression** (**ERE**) engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most Linux binaries understand both engines, such as sed and AWK.
  prefs: []
  type: TYPE_NORMAL
- en: '`grep` also can understand ERE, but you have to use the `-E` option, which
    is equivalent to using `egrep`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to define a regex pattern for sed and AWK. We will start by
    defining BRE patterns, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Defining BRE patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define a regex pattern, you can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0b72a10f-089f-49d4-abd9-31b3e728cf5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A very important thing you need to know about regex patterns in general is
    they are case sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3672126e-36f9-4e1c-8260-a225ade9dd96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Say you want to match any of the following characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.*[]^${}\+?|()`'
  prefs: []
  type: TYPE_NORMAL
- en: You must escape them with a backslash because these characters are special characters
    for the regex engines.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to define a BRE pattern. Let's use the common BRE characters.
  prefs: []
  type: TYPE_NORMAL
- en: Anchor characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anchor characters are used to match the beginning or the end of a line. There
    are two anchor characters: the caret (`^`) and the dollar sign (`$`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The caret character is used to match the beginning of a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d8f1ea73-b463-4950-9c52-83b5072c813d.png)'
  prefs: []
  type: TYPE_IMG
- en: So, the caret character is used to check whether the specified text is at the
    beginning of the line.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to search for the caret as a character, you should escape it with
    a backslash if you use AWK.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you use `sed`, you don''t need to escape it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3b7e3143-dce9-44fb-8c75-74d909d6c774.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To match the end of the text, you can use the dollar sign character (`$`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/33bcc23d-2001-4748-b36c-abe7823253c9.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use both characters (`^`) and (`$`) in the same pattern to specify text.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these characters to do something useful, such as search for empty
    lines and trim them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The exclamation mark (`!`) is called the negation character, which negates what's
    after it.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern searches for `^$` where the caret (`^`) refers to the beginning
    of a line and the dollar sign (`$`) refers to the end of a line, which means search
    for lines that have nothing between the beginning and the end which means empty
    lines. Then we negate that with the exclamation mark (`!`) to get the other lines
    that are not empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply it to the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c5be77fb-44be-46be-a43a-315f2b15ae9b.png)'
  prefs: []
  type: TYPE_IMG
- en: The lines are printed without the empty lines.
  prefs: []
  type: TYPE_NORMAL
- en: The dot character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dot character matches any character except the new line (`\n`). Let''s
    use it against the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern matches any line containing `sh` and any text before it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8a32a75-3f95-4a96-869f-2d85c23a0a56.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it matches the first two lines only because the third line starts
    with `sh`, so no match for the third line.
  prefs: []
  type: TYPE_NORMAL
- en: The character class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to match any character using the dot character. What if you want
    to match a specific set of characters only?
  prefs: []
  type: TYPE_NORMAL
- en: You can pass the characters you want to match between square brackets `[]` to
    match them, and this is the character class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following file as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how the character class works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/28fb6091-3614-4e70-91ef-7239f1fdf206.png)'
  prefs: []
  type: TYPE_IMG
- en: The character class `[mbr]` matches any of the included characters followed
    by ash, so this matches the three lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can employ it in something useful, such as matching an uppercase or a lower
    case character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The character class is negated using the caret character like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/34670994-fa8c-4609-9d6c-6e9cdf6c2eeb.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we match any line that contains ash and starts neither with `b` nor `r`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that using the caret character (`^`) outside the square brackets means
    the beginning of a line.
  prefs: []
  type: TYPE_NORMAL
- en: Using character class, you specify your characters. What if you have a long
    range of characters?
  prefs: []
  type: TYPE_NORMAL
- en: Ranges of characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can specify a range of characters to match between square brackets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This means the range of characters from `a` to `d`, so `a`, `b`, `c`, and `d`
    are included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same previous example file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/6f93ec93-4c27-433a-a297-5f0e63776824.png)'
  prefs: []
  type: TYPE_IMG
- en: The character range from `a` to `m` is selected. The third line contains `r`
    before ash, which is not in our range, so only the second line doesn't match.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use numbers ranges as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This pattern means from `0` to `9` is matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write multiple ranges in the same bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/27ed86b0-52da-4632-b4ae-626b7b772dfd.png)'
  prefs: []
  type: TYPE_IMG
- en: In this pattern, from `d` to `h` and from `m` to `z` are selected and since
    the first line contains `b` before ash, only the first line doesn't match.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the ranges to select all uppercase and lowercase characters as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Special character classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to match a set of characters using the character class, then we saw
    how to match a range of characters using character ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, the ERE engine offers ready-to-use classes to match some common sets
    of characters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `[[:alpha:]]` | Matches any alphabetical character |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:upper:]]`         | Matches A–Z uppercase only |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:lower:]]`  | Matches a–z lowercase only |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:alnum:]]`         | Matches 0–9, A–Z, or a–z |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:blank:]] `        | Matches space or Tab only |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:space:]]`         | Matches any whitespace character: space, Tab, CR
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:digit:]]`        | Matches from `0` to `9` |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:print:]]`          | Matches any printable character |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:punct:]]`         | Matches any punctuation character |'
  prefs: []
  type: TYPE_TB
- en: So, if you want to match uppercase characters, you can use `[[:upper:]]` and
    it will work exactly as the character range [A-Z].
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test one of them against the following example file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will match the uppercase characters to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e84ecdd0-f595-4b80-b87a-ca8b9be0b072.png)'
  prefs: []
  type: TYPE_IMG
- en: The uppercase special class makes it easy to match any line that contains uppercase
    letters.
  prefs: []
  type: TYPE_NORMAL
- en: The asterisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The asterisk is used to match the existence of a character or a character class
    zero or more times.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be useful when searching for a word with multiple variations or that
    has been misspelled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/eb7e9eba-4b9a-4a35-beac-2b997b5fe68f.png)'
  prefs: []
  type: TYPE_IMG
- en: If the character `u` doesn't exist at all or exists, that will match the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We can benefit from the asterisk character by using it with the dot character
    to match any number of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use them against the following example file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a pattern that matches any line that contains the word `this`
    and anything after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4287e60f-8f82-4e9c-8833-85373ef9401f.png)'
  prefs: []
  type: TYPE_IMG
- en: The fourth line contains the word `this`, but the first and third lines contain
    a capital `T`, so that it doesn't match.
  prefs: []
  type: TYPE_NORMAL
- en: The second line contains the word and text after it, whereas the fourth line
    contains the word and nothing after it, and in both cases, the asterisk matches
    zero or more instances.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the asterisk with the character class to match the existence of
    any character inside the character class for one time or none at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/077b53df-f18a-4cd9-9711-aa066c304951.png)'
  prefs: []
  type: TYPE_IMG
- en: The first line contains the character `o` two times, so it matches.
  prefs: []
  type: TYPE_NORMAL
- en: The second line contains the `n` character, which doesn't exist in the character
    class, so there is no match.
  prefs: []
  type: TYPE_NORMAL
- en: The third line contains the characters `a` and `r`, once for each, and they
    exist in the character class, so that line matches the pattern too.
  prefs: []
  type: TYPE_NORMAL
- en: Defining ERE patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how easy it is to define BRE patterns. Now, we will see some ERE patterns,
    which are more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'ERE engines understand the following patterns besides BRE patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Question marks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plus signs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curly braces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression grouping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, AWK supports ERE patterns, and sed needs `-r` to understand these
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The question mark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The question mark matches the existence of the preceding character or character
    class zero or one time only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7bcf636d-ba4a-4cb1-bbea-e8e2c994bb96.png)'
  prefs: []
  type: TYPE_IMG
- en: In the first two examples, the character `o` exists zero and one time, whereas
    in the third example, it exists two times, which doesn't match the pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, you can use the question mark with the character class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0e811e77-6ec6-43b0-afb4-e1208a15dcc5.png)'
  prefs: []
  type: TYPE_IMG
- en: The third example only doesn't match because it contains the `o` character two
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when using the question mark with the character class, it doesn't
    need to have all of character class in the text; one is enough to pass the pattern
  prefs: []
  type: TYPE_NORMAL
- en: The plus sign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The plus sign matches the existence of the preceding character or character
    class one time or more, so it must exist at least once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5064634c-3d63-494c-bb9a-c73b222dcb2f.png)'
  prefs: []
  type: TYPE_IMG
- en: The first example doesn't have an `o` character, and that's why it's the only
    example that has no match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can use the plus sign with the character class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/1f9349ec-3cf3-4421-8205-0687c94763f9.png)'
  prefs: []
  type: TYPE_IMG
- en: The first example only doesn't match because it contains no `o` character at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: Curly braces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The curly braces define the number of existence of the preceding character
    or character class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/26941951-26af-4be6-a3b5-a6590b37a572.png)'
  prefs: []
  type: TYPE_IMG
- en: The third example doesn't contain any matches because the `o` character exists
    two times. So, what if you want to specify a more flexible number?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify a range inside the curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4077696d-7328-4b22-9f81-a9181f03e081.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we match the `o` character if it exists one or two times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can use the curly braces with the character class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8c3c15cb-3de6-4cf6-a140-3fac0523afdd.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, if any of the characters `[oa]` exists for one time, the pattern
    will match.
  prefs: []
  type: TYPE_NORMAL
- en: The pipe character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pipe character (`|`) tells the regex engine to match any of the passed
    strings. So, if one of them exists, that is enough for the pattern to match. It''s
    like a logical `OR` between the passed strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/34c4b0fa-ea04-4185-a4ae-607b9b44fdc2.png)'
  prefs: []
  type: TYPE_IMG
- en: All the previous examples have a match, since any of the three words exists
    in each example.
  prefs: []
  type: TYPE_NORMAL
- en: There are no spaces between the pipes and the words.
  prefs: []
  type: TYPE_NORMAL
- en: Expression grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use parentheses `()` to group characters or words to make them one
    piece in the eyes of the regex engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/65059931-7d4e-4bec-a292-51b6ec6273fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the `shell scripting` string is grouped with parentheses, it will be treated
    as a single piece.
  prefs: []
  type: TYPE_NORMAL
- en: So, if the entire sentence doesn't exist, the pattern will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have realized that you can achieve that without parentheses like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, what is the benefit of using parentheses or expression grouping? Check the
    following examples to know the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use any of the ERE characters with the grouping parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d3416465-eb77-481c-8153-f1fc151c952c.png)'
  prefs: []
  type: TYPE_IMG
- en: In the first example, we search for the whole sentence `bash scripting` for
    zero or one time using the question mark, and because the whole sentence doesn't
    exist, the pattern succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Without expression grouping, you won't get the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Using grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we wanted to talk properly about `grep`, an entire book would not be enough.
    `grep` supports many engines along with BRE and ERE. It supports engines such
    as **Perl-compatible regular expression** (**PCRE**).
  prefs: []
  type: TYPE_NORMAL
- en: The `grep` is a very powerful tool that most system administrators use every
    day. We just want to enlighten the point of using BRE and ERE patterns as we did
    with sed and AWK.
  prefs: []
  type: TYPE_NORMAL
- en: '`grep` tool understands BRE patterns by default, and if you want to use ERE
    patterns, you should use the `-E` option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work with the following example file and use a BRE pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test a BRE pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/87d4985b-8e2b-40ad-bc18-c3d8db1d2c91.png)'
  prefs: []
  type: TYPE_IMG
- en: The results are colored in red.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test an ERE pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a6b3f540-f2f8-47d9-ac20-e41e0ef8d74c.png)'
  prefs: []
  type: TYPE_IMG
- en: All other ERE characters can be used in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered regular expressions and the regex engines BRE and
    ERE. We learned how to define patterns for them.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to write these patterns for sed, AWK, and `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we saw how the special character classes make it easy to match sets of
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to use the powerful ERE patterns and how to group expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to use the `grep` tool and how to define BRE and ERE patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we will see some practical examples for AWK.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assume that you have the following file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How many lines will be printed in the output?
  prefs: []
  type: TYPE_NORMAL
- en: How many lines will be printed if we use the following command against the previous
    file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How many lines will be printed if we use the following command against the previous
    sample file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What is the output of the following command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading related to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.regular-expressions.info/engine.html](https://www.regular-expressions.info/engine.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_04.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_04.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
