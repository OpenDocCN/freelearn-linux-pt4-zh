- en: Time for Safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Safety is important, wherever we are. For example, in a construction site as
    in a newly built operating system, safety is a key factor to have things done
    the right way. Our shell is nothing different when it comes to safety: we spend
    most of our time inside our environment, trying to have things done, tasks running,
    and keep everything in order. This last chapter will give us some quick solutions and
    hints on how to strengthen it and preserve it from the most common issues using
    the shell. We will not use more advanced tools such as security or other kernel-level
    enhancement: such tools would require an entire book on their own, and they come
    after we clean up our shell. We will perform *housekeeping*, nothing really invasive,
    just a *finishing touch*, trying to find a balance between security, safety, and
    usability; and this is actually a hard goal: strengthen too much and even the
    easiest task will be almost impossible to be carried on. It will be be usable
    and probably our system will be too exposed or unsafe. We will try to hit the
    sweet spot, having a usable system, fairly safe and secure; but then it is up
    to the administrator of each system to decide what the balance should be: we can
    only advice a few tips and show what could be done.'
  prefs: []
  type: TYPE_NORMAL
- en: The restricted shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different ways to restrict what a user can do on a system and there
    are a lot of reasons why we would restrict a user''s ability to interact with
    a system: maybe we want a user just to be able to copy a file to and from the
    system or to have a simple home where they can work on their tasks without peeking
    around the system. Anyway, whatever is our goal we can start working with a restrict
    shell.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bash itself offers an additional layer of security using the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rbash`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--restricted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Invoking `rbash` or simply `bash` with the `--restricted` or `-r` options spins
    a Bash instance that trims down what the users will be able to do on such an environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user cannot change the directory using the `cd` builtin. The user will
    be prevented to set or unset the values for the following environment variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BASH_ENV`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHELL`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATH`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will not be able to specify command names with slashes and this means
    no command names with absolute paths. No filenames containing a slash can be passed
    as an argument to the built-in command called `.`. So, the user will not be able
    to source (the `read and execute` command from) a file from outside his home directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No filename containing a slash can be passed as an argument to the builtin command
    called `hash` using the `-p` option. Hash determines the full filename of a command
    specified as an argument by searching into the directories specified by the environmental
    variable: `$PATH`. If `-p filename` is given as an option, hash would use the
    filename as the full path to the command searched. So, no commands invoked outside
    the home directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No functions definitions are imported at the start from the shell environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No value is taken into account from the environment SHELLOPTS variable at startup
    and so no shell options are set for the shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No redirections are allowed using the standard operators `>`, `>|`, `<>`, `>&`,
    `&>`, `>>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No exec built-in is available to replace the shell with a different command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to add or delete builtin commands using the `enable` builtin
    with `-d` or `-f` options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to use the `enable` built-in to enable or disable the Bash
    built-ins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option `-p` is not allowed for the built-in command, so no `$PATH` manipulation
    is possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is impossible to turn off a restricted mode using `set +r` or `set +o restricted`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, with all these limits, the user is caged in its home directory. But how
    do you set up an `rbash login` shell? The easiest method is to find the Bash link
    and redirect it to `rbash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, a link already exists between `rbash` and `bash`, but in this
    case there were not anyone of them, so we must create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to check that `rbash` is listed in `/etc/shells` , which sports
    the full pathnames to valid login shells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a user with a restricted shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, let''s `su` to the user and test the `cd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are. The `cd` command is restricted as we expected it to be. Let''s
    check some other restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, no redirections, though the cage is not really isolated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The restricted user can still do something outside its directory. Let''s override
    this using a local profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s delete `.bash_profile` or `.profile` we find in the home directory
    and create it, if it does not exist, the file `.bashrc` whose only line should
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s prevent the user from modifying it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s `su`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s check what we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not allowed to do that, which we already know. Let''s try to list some
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, no commands are available outside our `$HOME/bin`. Let''s try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, there is another failure. Now let''s try the `df` that command
    we linked inside our user''s `$HOME/bin` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, we successfully limited the commands the user has access to and
    restricted it to his home directory. Great, looks like it has been contained,
    but there are some limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The restricted user can escape this *cage* running a program, which has a shell
    function. A classical example is the `vi` editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method to escape a restricted shell is to invoke an unrestricted shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This also means that any script with a valid sha-bang will invoke a full-blown
    shell and escape any restrictions. All of these methods imply that the user has
    access either to Bash or to any programs featuring a shell function, otherwise
    jumping out from the cage would not be so easy. But we have to bear something
    important in mind: this is a method to cage some users in their working space,
    so it will separate them from each other, give them their own isolated home, and
    prevent them from inadvertently messing with other parts of the system. It is
    not a full-blown security layer hacker; for this kind of stuff, we should rely
    on something more at a kernel level, and it is outside the scope of this book,
    since it would require quite a long explanation about security, kernel compiling,
    third-party products, hardening, and so forth. Again, it is a book on its own.'
  prefs: []
  type: TYPE_NORMAL
- en: So, we want to keep things clean, and what can we do to host remote connections
    in an orderly manner?
  prefs: []
  type: TYPE_NORMAL
- en: Restricted shells for OpenSSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though the restricted shell for OpenSSH ([http://www.pizzashack.org/rssh/](http://www.pizzashack.org/rssh/))
    is not strictly a shell tool; its simplicity makes it a good candidate for helping
    to keep the house clean when some visitor knocks on wood. Rssh is available for
    a variety of distributions and platforms and offers a restricted shell allowing
    not only `scp` and `ftp`, but also `csv`, `rdist` , and `rsync`. So, we can create
    accounts available for file copy or synchronization without allowing a full shell
    access; and this can be handy to keep things on a low profile and lower the server
    exposure to attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step consists in installing rssh from a package or from a source.
    In our example, we will rely on a package since the distribution used, Debian,
    has one; and also,  using packages will ensure that the utility will be upgraded
    and patched by the maintainers whenever needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we will have a new shell binary available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now let''s use this new binary as the restricted user''s shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s verify directly on `/etc/passwd` that the shell has been assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems all OK, so let''s connect from remote to the system where the restricted
    user resides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The account is locked out and this is the default behavior of `rssh` since
    we did not configure it yet. So, let''s see the main configuration directives
    that we can use inside the `/etc/rssh.conf` file to enable some protocols and
    per user configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allowsftp`: Allows sftp connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowcvs`: Allows cvs connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowrdist`: Allows rdist connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowrsync`: Allows rsync connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowsvnserve`: Allows svnserve connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`umask`: Sets the umask for the files and directories created during a scp
    or sftp session. The umask is usually set by the shell upon user login, so to
    avoid this, rssh must set the umask itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logfacility`: Specifies which syslog facility or C macros to use for logging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chrootpath`: A helper application for `rssh` (`rssh_chroot_helper`) calls
    the `chroot()` system call changing the root of the filesystem for the session.
    So, for example:  `chrootpath=/opt/jails` will change the root of the virtual
    filesystem to `/opt/jails` for the users whose shell is `rssh`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the login, the `/var/caged/users` directory will appear to the user as
    the root directory of the filesystem, and it will not be able to get outside of
    it. If this directive is used, a `chroot` jail must be in place to provide the
    users a minimal environment. We will see later how to do it. If the user's home
    directory defined in `/etc/passwd` is inside the path specified by `chrootpath`,
    then the user will be `chdired` to his home directory, otherwise it will be `chdired`
    to the root of the `chroot` jail.
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: With this directive, we can set a per user configuration that will
    override all others directives. The `user` keyword appears in a string separated
    in fields by colons (`:`) with the following structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s see what each fields represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '**username**: This is the account name we want to set the configuration for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**umask**: Is the umask expressed in octal for the user. It follows the same
    specification as if we were setting it for the Bash shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**access_digits**: These are six binary digits that specify if the user is
    allowed to use `rsync`, `rdist`, `cvs`, `sftp`, `scp` , and `svnserve` in the
    order listed.  `0` means the user is not allowed, a `1` means the user is allowed
    to use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**path**: It specifies the path to the directory the user will be chrooted
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quotes are not mandatory except when there are spaces in the path field. In
    this case, we can user either single or double quotes. Spaces around `=` are fine.
    So, something like `user=restricted:022:100000:` means that the user restricted
    has a umask of `022` and has the `rsync` connections available. No `chroot` is
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The previous statement means that the user restricted has an umask of `011`,
    `sftp` , and `scp` connections available, and it will be chrooted in `/usr/local/chroot
    jails`.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing a bit more about configurations, let's enable just the `scp` connections
    for our restricted user by adding  `user = restricted:277:000010` to `/etc/rssh.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to check whether we finally can access the remote system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is interesting. The message is slightly different from the previous attempt:
    we are still prevented to log into the remote server using ssh, but it states
    that although the account is restricted by rssh, we can use `scp`. So, let''s
    try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, it seems it worked. Let''s have a look on the remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we go. In the home directory of the restricted user, we have our file
    with the access rights set to `400`, as expected. Nice and easy. But there is
    a small issue and we can see what it is about here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using FileZilla we are able to browse the entire filesystem of the remote host
  prefs: []
  type: TYPE_NORMAL
- en: Even though the user is limited to a protocol, he can browse the remote filesystem
    without any restrictions other than the Unix/POSIX file permissions. In the example
    shown, we enabled the SFTP protocol and actually connected to the system as the
    restricted user browsing, having a look at the `/etc` directory. Can we prevent
    this? Yes, we can `chroot` the user into, ideally, a filesystem on its own, mounted
    with `nosuid` and possibly with a `noxec` options if supported. This way, even
    if a user uploads an executable, he will not be able to run it and/or exploit
    any `suid` rights. Is it easy to do? No, creating a `chroot` jail can be really
    hard since it requires copying the relevant binaries and libraries into the jail
    itself; versions and paths can change depending on the distribution used and also
    the release itself. Actually, the source tarball of rssh offers a script, which
    with some modifications can actually help copying all the necessary files to the
    jail. There are also some other scripts that we can easily find on the internet
    and that will help us in this sensible job. Anyway, there is a much easier way
    to provide a restricted sftp access to a server, and we do not have to look so
    far away from our environment since we can accomplish this task simply using the
    OpenSSH server.
  prefs: []
  type: TYPE_NORMAL
- en: Restricted sftp sessions with OpenSSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using OpenSSH, everything can be easily done with five configuration lines and
    a few commands; let's see how. We are on the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s open the OpenSSH file, which is usually found in `/etc/ssh/sshd_config` and
    add these few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We should already know what these directives are, but let''s recall what we
    wrote in [Chapter 12](part0194.html#5P0D40-8ae483f626fa439a8b6ee1bf9fb955ec),*Remote
    Connections over SSH*, about remote connections over ssh:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Match`: With this directive, we can use conditional statements so that if
    they are satisfied the following configuration lines, we will override the ones
    in the main configuration block. If a keyword/configuration block appears in more
    than one match clause, only the first instance is taken in to account. As matching
    criteria, we can use the following directives: user, group, host, local address,
    l local port, address, or all for all of them. We can match a list, patterns an
    negation. In our example, we are going to match against a group that we are going
    to create in a moment: whatever account belongs to the group sftp-only will be
    subjected to the following configuration lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChrootDirectory`: By specifying the full path to a directory, we can `chroot`
    a user into it after successful authentication. It is not an easy task since the
    directory must be owned by root and cannot be writable by anyone else. In addition,
    we must provide some files required for a session, like the shell, `/dev/null`,
    `/dev/zero`, `/dev/arandom`, `/dev/stdin`, `/dev/stdout`, `/dev/stderr`, and `/dev/ttyx`.
    We can also find some tokens such as `%h` standing for the home directory of the
    account authenticating, or we can also see `%%` , which stands for a simple `%`.  `%u`
    is replaced by the username. In our case, we do not have to provide any binaries,
    because we will allow sftp connections only, since there is no shell, there is
    no chance of executing anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X11Forwarding`: This allows/denies the `X11` forwarding. If set to `yes` ,
    it can expose `X11` to attacks; so this option must be taken with care. Defaults
    to `no`. We prevent the forwarding to `X11`: there is no need for it and it can
    expose the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowTcpForwarding`: This allow/denies TCP forwarding and can take as argument
    `yes`, `all`, `no`, or `local` and `remote`. The first two options allow the forwarding,
    the third denies it, and the `local` allows local forwarding only; `remote` enables
    remote forwarding only. There is no shell or TCP forwarding for our example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ForceCommand`: Overrides any commands sent by the client or listed in the
    `~/.ssh/rc` of the authenticating account and forces the execution of the command
    listed in this directive. The command is executed through the account shell with
    the `-c` option. Defaults to `no`. In our case, we force the execution of the
    OpenSSH internal `sftp` subsystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Talking about the subsystem, let''s verify that in the same config file OpenSSH
    is configured to use the `internal-sftp` subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We may also want to add some more restrictions at the end of the configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`AllowAgentForwarding`: Defines whether ssh-agent forwarding is allowed or
    not. Defaults to `yes` to increase the security, and since it is not really needed
    for an `sftp` account, so we are going to disable it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitTunnel`: This allows/denies the tunnel device forwarding. It takes yes,
    point-to-point , Ethernet, or no as arguments. Yes enables both point-to-point
    and Ethernet forwarding. Defaults to no, and we want to be sure it is disabled
    since we do not need a tunnel for an sftp account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have all the service bits in place, let''s restart the OpenSSH
    server, in our case, this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to add our new group and move our restricted user there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now we have our restricted user added to the `sftp-only` group without
    a valid shell to log in to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s make the user home directory owned by root so that the user would
    not be able to write into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s create a new home owned by `root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Also let a subdir owned by the restricted user who can write to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'All fine now, let''s try to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'That is fine: we do not want a full shell for the restricted user, so let''s
    try sftp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, we are in, but let''s check what we can actually do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: OK, we are in our remote root directory, but what is inside it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This sounds familiar. It is the cage, so let''s escape it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'No, we actually cannot do so. At least, let''s try to upload something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'No way, the user''s root directory is unwritable, so let''s `cd` to the exchange
    directory and try the upload again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It definitely works. Let''s get the file back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here we are, the account is ready for the customer to connect and share data.
    But what if we want to connect using a key for authentication?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first modify `/etc/ssh/ssd_config` by adding the following line at the
    very end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be under the match condition and will be triggered for all the users
    of the `sftp-only` group; but for this to be taken in to account, we have to reload
    the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So, since the new directive instructs OpenSSH to look for `authorized_keys`
    inside `/opt/sftp-jails/authorized_keys/{username}/authorized_keys` for all the
    users belonging to the `sftp-only` group, let''s start creating the correct directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the full path to the user directory holding the authentication key
    for the user that is restricted. We will have to create one of each user; and
    the name of the final directory must be the same as the username. Now, we have
    to trim ownership and access rights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `authorized_keys` directory belongs to user root and the group: `sftp-only` ,
    while the subdirectory restricted belongs to user restricted and group root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'All the users from the `sftp-only` group can traverse the `authorized_keys`
    directory, but only the restricted user can traverse the directory restricted.
    Now, let''s copy our key example to the final destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s give it a correct ownership and access rights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we should end with such a configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything looks fine, so we just have to test what we have done so far. Let''s
    go to the local server and try a connection on the remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try a `ssh` connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is correct, we should not be allowed to connect over `ssh` with shell or
    access a home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try an `sftp` connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, we are connected using our identity key and with no user or file or
    IP address specified. So, let''s make some test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We are in our user root directory; let''s try to climb up to the system root
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'No way, we are caged into our root directory and cannot go to any upper levels.
    Let''s look for a file to upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to upload it to the home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We have no permission, as expected. We need to use the exchange subdirectory
    for our purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Successfully uploaded! Now, let''s see what is inside the exchange directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Done! Everything looks fine. Or something like that since we are blind on what
    happens during the connection. Since everything is in an isolated cage, there
    is no way to use a system facility such as `rsyslog` to actually record what the
    user is doing during an `sftp` session. Or, at least, the normal `rsyslog` configuration
    is not able to do this, but there are a few methods to work around this limitation.
    One that we are going to see  involves the use of a pipe; it will make things
    really easy. First, let's modify a couple of directives in `/etc/ssh/sshd_config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The old `Subsystem` and `ForceCommand` now must be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `internal-sftp` will log with a level of `INFO`, so we have to export
    this information to the main log using a socket. So, let''s create a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what we have done is instruct `rsyslog` to create a Unix socket in in the
    `/dev` directory of the restricted user; and the `sftp` subsystem will be able
    to send the log messages to `rsyslog` using that socket. Yes, but how are these
    messages written? They are written by simply accessing one of the properties of
    the message itself. In this case, if the name of the program that generated the
    messages is `internal-sftp`, then the message is written on `/var/log/openssh-sftp.log`.
    Once done, let''s restart both `sshd` and `rsyslog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you receive a message from `rsyslog` complaining about the `imuxsock` module
    already being loaded, just comment out the first line with `#`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just have to make another connection and issue some commands in order
    to populate the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Now we have a nice log showing us what the user has done during
    his `sftp` session; and the log itself is out of reach of any `sftp` users. In
    our example, we redirected the messages based on the name of the program, which
    created them; but we have other tags we can use to filter. So, let''s see the
    more useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HOSTNAME`: The hostname as it appears in the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FROMHOST`: The hostname of the system the message was received from. In a
    chained configuration, this is the system next to the receiver, not necessarily
    the first sender.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syslogfacility`: The facility reported by the message in numerical form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syslogfacility-text`: The facility reported by the message in text form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syslogseverity`: The severity reported by the message in numerical form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syslogseverity-text`: The severity reported by the message in text form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By using these properties, we can do something interesting. Let''s start creating
    another user with the same group and shell as restricted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s change the home directory owner for the user''s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the new jail copying the one we already have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We just have to fix the ownership now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Time for copying the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, for brevity, we are using the same key as the restricted user,
    but we can always create a new key and copy over the `authorized_keys` file to
    give each user their own key. Once done, let''s try a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, the user can access and has the right permissions, but what about logging?
    Nothing, we did not set up anything for logging, so let''s modify `/etc/rsyslog.d/openssh-sftp.conf`
    by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to get the new instructions taken in account, let''s restart `rsyslog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s connect again to generate some logging lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what is expected. We created a Unix socket in the new user''s jail;
    and we are receiving the messages sent by the `internal-sftp` subsystem for the
    account session. Nice, but confusing. All the log messages from all the users
    will be contained in a single file, and since the command messages such as `May
    12 04:02:11 spoton internal-sftp[18573]: closedir "/exchange"` are not identified
    by a user account name, but from a session ID [18631], it is feasible to follow
    all the actions performed during a session and trace them back to the user who
    made them. But overall, it is not so easy to read. What can we do? Well, as always
    we have to use a bit of imagination and creativity and bend the rules to take
    some advantages. Let''s tinker with the `rsyslog` config file for `openssh-sftp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open it and replace its content with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'What did we do? We used a property manipulation string, which allowed us to
    associate a hostname property to the messages coming from a specific socket. Then,
    we added two rules to redirect the messages to a per user log file, based on the
    hostname property found in the messages themselves. We intentionally wrote the
    hostname property with different cases to show that the property name is case
    insensitive. Time to restart `rsyslogd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The logging facility is ready, let''s connect again and make some *noise*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is the time to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We connected as casualuser, and indeed we see a file named `casualuser-sftp.log`
    exactly where we expected to find it. Let''s have a look at what is inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Our `sftp` session has been fully logged and now if we want to
    know what the casual user did, we just have to open the log file and read it through.
    One interesting note, each line of message has now the name of the user it belongs
    to. Well, it would actually be the hostname, but we streched the rules to get
    what we wanted from the system. Is it really so? Let''s make a final check connecting
    a restricted user to see if a new log file is being generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have issued some commands as a restricted user, let''s see if the
    file we want is really in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The file is correctly in place, so let''s have a look inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The content is there; all the actions performed by the restricted user have
    been logged and are out of his reach. One last check here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This confirms that no lines tagged as restricted are listed into the `casualuser-sftp.log` ,
    so each user has his own log.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we now have a fully functional `sftp` server, along with individual jails
    and per user logging. There is just one nice touch left to give to our server,
    and this will bring us back to the old times: we are talking of a banner to display
    to our users. It can look like that is something not so useful or something that
    belongs to the past times but it is not that. When someone connects to our server
    must be notified that this is a private facility and no illegal action will be
    allowed. This is useful at least for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: If an unauthorized user connects by mistake to our server, he has to know that
    he is not where he thinks he is; so we give him a chance to disconnect and no
    further actions will be taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an unknown user connects willfully to our server, he must be notified that
    he is not allowed to do so. In case he proceeds further, we will then be allowed
    in the future to show this as an evidence of his will to carry some illegal actions
    against our facility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can look quite simplistic, but with a banner in place, no one will be able
    to say *I did not know*. No, the user was notified and that matters. Since we
    do not want to scare our visitors, let's make a banner with a jazz using `figlet`,
    a utility that will apply some nice fonts to our messages ready to be displayed
    over a terminal. In our example, we are using Debian, so a simple `root:# apt-get
    install figlet` will install the utility. The default set of font is not so rich,
    but more can be downloaded from the site of this project at [http://www.figlet.org/fontdb.cgi](http://www.figlet.org/fontdb.cgi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first test what we have already installed on our system. For a Debian
    environment, the font files reside in `/usr/share/figlet/` , but this can differ
    based on the distribution used. So, to test all the fonts and see what we do like
    the most, a one line for loop is what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A simple `for` loop will show us our message in all the fonts available. So,
    let''s create a test file with our welcome banner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s save it to a file named `header.txt` and pass it to `figlet stdin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get something like what is shown in the following screenshot, which
    is nicely centered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A simple `for` loop will show us our message in all the fonts available. Now,
    let''s add some meaningful warning to a `footer.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s pass this message through `figlet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have our banner, let''s clean it up a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all. So we try a new connection to the server, and we will get a nice
    welcome message like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.gif)'
  prefs: []
  type: TYPE_IMG
- en: A nice welcome message will remind the visitors about the restriction of this
    sftp site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, but let''s say we saw a font that we like, but it is not installed.
    For the sake of this example, let''s say we want to use the alligator font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not installed so we cannot use it, but it is just a matter of downloading it
    and copying over the font directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s just give the previous command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The font is available to figlet, and so the result is what we can see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Installing a font is simply a matter of copying it in the fonts directory
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s have fun. Try to change and create your message in the style we
    prefer: a banner shall not be necessarily boring.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the last summary of this book and the last topic was figlet; and it
    was not just a coincidence. What we tried to make clear through all the chapters
    is that Bash is fun. Did we touch every possible topic and example? No, not at
    all, and this is the greatest thing of all: we have so many things to see, so
    many ways to bend Bash to do unthinkable tasks. Just think about something and
    then try the shell: in most cases a bit of imagination will find a creative way
    to overcome obstacles and to chuckle about what has been done. This book is named
    *Mastering Bash*, but no book can exhaust the massive amount of things that we
    can discover about this shell. So, this is not a landing point, this is just a
    step further, maybe higher than usual, but just a step in an ongoing journey in
    our favorite environment, in our beloved GNU/Linux operating system.'
  prefs: []
  type: TYPE_NORMAL
