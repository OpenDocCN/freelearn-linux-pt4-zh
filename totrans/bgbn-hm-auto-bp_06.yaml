- en: Chapter 6. Baby Room Sentinel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to show a possible implementation of a baby room
    sentinel capable of monitoring the room by detecting whether our baby is crying
    or if the baby is breathing during sleep. Also, as a special feature, the system
    will be able to measure the baby's temperature with a contactless temperature
    sensor.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see several kinds of sensor, such as pressure, sound, and temperature.
    Also, regarding the temperature sensors, we'll see an interesting infrared version
    that is useful to measure surface temperature without touching it. Additionally,
    we'll provide our prototype of a nice, tiny LCD screen in order to see what's
    going on in the baby's room.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of functioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a baby, it's quite normal to buy different devices to check when
    the baby cries or has a fever, or if the baby is still breathing during sleep.
    So, in this chapter, we'll try to implement several smart sensors to detect these
    states of danger using our BeagleBone Black and some special sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning! *Let me remind that this project is a prototype and it cannot be used
    as a personal safety application!* It's simply a study of a possible implementation
    of a baby room sentinel device.
  prefs: []
  type: TYPE_NORMAL
- en: '*Neither the author of this book nor Packt Publishing recommends or endorses
    that this product be used alone or as a component in any personal safety applications.*
    The reader is warned about the fact that these sensors and controls do not include
    the self-checking redundant circuitry needed for such use.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Neither the author of this book nor Packt Publishing will be held liable for
    unauthorized use of this prototype. The users can use this device at their own
    risk!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect when the baby is crying, we can use a sound detector, as we did in
    the previous chapter; but this time, we should elaborate the input signal a bit
    more in order to effectively detect whether the baby is really crying or not.
    By looking at the following screenshot, we can see a simple 40 seconds plot of
    an audio signal of a crying baby (sample time is *Ts=0.01 s=10ms*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basics of functioning](img/B00255_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In red is the raw audio signal, while in yellow is the average of that signal
    over a 5 second window over the current time, that is, the yellow signal is the
    average value of all collected audio samples in the last 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: As already stated, the sampling time *Ts* is *10ms*, which is not suitable for
    an audio recording but is enough for our purposes. In fact, we can see that by
    using the average value represented by the yellow line, we can detect if the baby
    is crying by just using a suitable threshold.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the breathing, the problem is quite similar; in fact, we can suppose
    that, more or less, normal breathing during sleep may vary from 12 to 16 breaths
    per minute, that is, a frequency range from 0.26 Hz to 0.2 Hz. However, this time
    the average level of the signal is not useful, but we can use its amplitude in
    a suitable timing window instead. To better explain the concept, consider the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basics of functioning](img/B00255_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The red color is the raw pressure signal, while the yellow color is the average
    of that signal over a 5 second window up to the current time. As stated previously,
    the yellow signal is just the average value of all collected audio samples in
    the last 5 seconds (sampling time is still *Ts=10 ms*). The blue color is the
    amplitude of the pressure signal computed as the difference between the maximum
    and the minimum value found in the considered temporal window, that is, this time,
    we find the **maximum value** (**Vmax**) and the **minimum value** (**Vmin**)
    of the collected audio samples in the last 5 seconds each time, and we compute
    the difference between Vmax and Vmin.
  prefs: []
  type: TYPE_NORMAL
- en: In the first 8 seconds of the preceding plot, the output is near to 0 since
    there is nothing on the sensor. Then, around *T = 8* seconds, a baby has been
    put on the sensor, so it starts to return higher values, as expected. In this
    situation, both the average and the amplitude of the input signal have grown and
    they reach (more or less) some stable values. However, the important thing to
    highlight is when the baby stops breathing (Don't worry! No baby stopped breathing
    during this test! It's just a simulation.). When the baby stops breathing (this
    happened near T = **38** seconds), the pressure sensor still detects something,
    and both the average and the amplitude decrease; but it's the pressure's amplitude
    that does the biggest jump! As you can see in the preceding screenshot, while
    the average moves from **700** to **450**, the amplitude moves from **700** to
    **10**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our prototype, we can use the pressure amplitude to detect the baby''s
    breath, and the pressure average to detect if a baby is present or not. The user
    should notice that both average and amplitude calculations can be done at the
    same time by using a C function like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `extract()`function gets the `arr` array holding the pressure data and,
    by using a single `for` loop, it can do both calculations in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the pressure sensor, we have to take into account that it cannot
    work well if it is not properly put into a box with a special mechanism suitable
    to detect breath. In the following screenshot, I show a possible implementation
    of such a box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basics of functioning](img/B00255_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The box should be put under the baby near the back, and attention should be
    paid to ensure that the upper side is in the right position to capture the movement
    of the lungs. The top of the box (moving surface) can move up and down, thanks
    to the springs, and it can detect pressure due to the movement of the baby's lungs
    with the pin that impinges on the pressure sensor, conveying the pressure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the last thing to take care of is the digital thermometer to measure the
    body temperature level. For this purpose, we can use a normal temperature sensor,
    but since we're talking about babies, we'd like to use a contactless temperature
    sensor. These special sensors are capable to measure an object's temperature without
    touching it by using the infrared rays that a surface emits and that are in the
    *field-of-view* of the sensor. So, when there is nothing in front of the sensor,
    we can detect the environmental temperature, but when we approach a surface, we
    can detect the temperature of that surface without actually touching it!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a suitable zone to aim the sensor at in order
    to measure the baby''s temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basics of functioning](img/B00255_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we are going to use two analog sensors, a digital sensor, and
    a tiny LCD to implement a little GUI. The analog sensors are connected to two
    different ADCs, while the digital sensor (the contactless temperature sensor)
    uses an I²C bus to communicate with the BeagleBone Black. Lastly, the tiny LCD
    is connected to our BeagleBone Black board by an SPI bus and some GPIOs.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the alarm devices to alert the parents, we can use a normal buzzer
    or a more sophisticated SMS gateway, or both. But in any case, the connections
    of these devices can be retrieved from the preceding chapters, so, due to lack
    of space, I'm not going to add any of them in this chapter. The reader can try
    to implement both the hardware and software by themselves as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the contactless temperature sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The contactless temperature sensor used in this prototype is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the contactless temperature sensor](img/B00255_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The devices can be purchased from [http://www.cosino.io/product/contactless-temperature-sensor](http://www.cosino.io/product/contactless-temperature-sensor),
    or found by surfing the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The user guide of this device is available at [https://www.sparkfun.com/datasheets/Sensors/Temperature/SEN-09570-datasheet-3901090614M005.pdf](https://www.sparkfun.com/datasheets/Sensors/Temperature/SEN-09570-datasheet-3901090614M005.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'This device is really interesting since it''s capable of measuring the temperature
    of an object without touching it! In reality, it is an infrared thermometer with
    a 17-bit resolution in wide temperature ranges: –40°C to 85°C for ambient temperature
    and –70°C to 382.2°C for an object''s temperature.'
  prefs: []
  type: TYPE_NORMAL
- en: The measured value is the average temperature of all objects in the *field-of-view*
    of the sensor, so it's quite obvious that we can use it to measure the environmental
    temperature as well as body temperature. We simply need to place the sensor near
    our body, and there we have it!.
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature of this sensor is that it is a digital device, that
    is, data can be retrieved by using a digital connection, which is immune to disturbances
    from the environment, even over (relatively) long distances. So, we can consider
    to put it on a handpiece for more practical usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bus available for this device is the I²C bus, and the necessary connections
    are reported in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | Temperature sensor pin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P9.4 - **VCC** | 3 - **VDD** |'
  prefs: []
  type: TYPE_TB
- en: '| P9.17 - **SCL** | 1 - **SCL** |'
  prefs: []
  type: TYPE_TB
- en: '| P9.18 - **SDA** | 2 - **SDA** |'
  prefs: []
  type: TYPE_TB
- en: '| P9.2 - **GND** | 3 - **Vss** |'
  prefs: []
  type: TYPE_TB
- en: 'For completeness, the device''s pins mapping is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the contactless temperature sensor](img/B00255_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if everything has been properly connected, we can activate the I²C bus
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, by using the `i2cdetect` command, we should get something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that a device at address `0x5a` has answered.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you may get a different address. In this case, all the following commands
    must be modified accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at the datasheet, we discover that the temperature can be retrieved
    by reading at the device location `0x07`. So, by using the `i2cget` command, we
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output value can now be converted in **degrees Celsius** (**°C**) by multiplying
    it by 0.02 after converting it in a decimal value. So, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To better understand what we do with the preceding command, let me explain
    it by using a list of equivalent (and more readable) commands starting with the
    following one where, by using `i2cget`, we get the data from the sensor and store
    it in the `v_hex` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we convert the hexadecimal value to a decimal one and store it in the
    `v_dec` variable by using the `bc` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, we simply multiply the decimal value held in the `v_dec` variable
    by 0.02 to get the temperature in **degrees Kelvin** (**°K**). Then, we subtract
    the value 273.15 to get it in °C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to measure body temperature, we simply need to aim the sensor at our head,
    near the temple, and execute the following command. I get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Great, I'm not ill!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reader can take a look at the book *BeagleBone Essentials*, *Packt Publishing*,
    written by the author of this book, in order to get more information regarding
    how to activate and use the I²C buses available on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the pressure sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pressure sensor is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the pressure sensor](img/B00255_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The devices can be purchased from [http://www.cosino.io/product/pressure-sensor](http://www.cosino.io/product/pressure-sensor),
    or by surfing the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The user guide of this device is available at [https://www.pololu.com/file/download/fsr_datasheet.pdf?file_id=0J383](https://www.pololu.com/file/download/fsr_datasheet.pdf?file_id=0J383).
  prefs: []
  type: TYPE_NORMAL
- en: This device can detect (and measure) a force acting on its active surface. In
    simple words, it can report pressure intensity by varying its internal resistance.
    From the datasheet, we can see that this resistance may vary from over 1 MΩ, when
    no force is present, to few hundred Ohms when a force is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'By remembering that the BeagleBone Black''s ADC inputs must be limited to 1.8V,
    we can use the circuitry shown in the following diagram to safely read from this
    sensor (see [Chapter 2](ch02.html "Chapter 2. Ultrasonic Parking Assistant"),
    *Ultrasonic Parking Assistant*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the pressure sensor](img/B00255_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, *R=6.8 KΩ* and **Rp** are the pressure sensor's internal
    resistors, which are represented by a variable resistor.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the preceding circuitry not only connects the sensor to the BeagleBone
    Black''s ADC input pin, but also prevents the input voltage on that pin from going
    lower than the critical value of 1.8V! The V[ADCin] voltage is given by the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*V[ADCin] = R / (R + Rp + R) * Vcc = R / (2R + Rp) * Vcc*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know that *Vcc* is 3.3V, so, even in case that the *Rp* value drops
    to 0 Ω, the *V[ADCin]* is equal to Vcc/2, that is, 1.65V, which is a safe value
    for the BeagleBone Black's ADCs.
  prefs: []
  type: TYPE_NORMAL
- en: This sensor must be connected to the BeagleBone Black at the *AIN1* input pin,
    which is labeled *P9.40*, while the other end must be connected to the resistor
    R, as shown in the preceding circuitry diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to check all connections, we can enable the BeagleBone Black''s ADCs by
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These settings can be done by using the `bin/load_firmware.sh` script in the
    book''s example code repository, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can read the pressure on the sensor with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding value is due to the fact that there is nothing on the sensor;
    but if we simply try to put a finger on it and then reread the sensor, we get
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, the higher the pressure on the sensor, the higher the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the sound detector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sound detector is the same as the one used in [Chapter 5](ch05.html "Chapter 5. WhatsApp
    Laundry Room Monitor"), *WhatsApp Laundry Room Monitor*, so you can take a look
    at the *Setting up the hardware* section in the same chapter to see how to set
    up and test this device. However, for the sake of completeness, some basic information
    about it is provided again, and it''s shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the sound detector](img/B00255_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The devices can be purchased from [http://www.cosino.io/product/sound-detector](http://www.cosino.io/product/sound-detector),
    or by surfing the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The board is based on the amplifier LMV324, with the datasheet available at
    [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf),
    while the board's schematic is available at [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'The connections are in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | Sound sensor |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P9.4 - VCC | VCC |'
  prefs: []
  type: TYPE_TB
- en: '| P9.39 - AIN0 | R @ENVELOPE |'
  prefs: []
  type: TYPE_TB
- en: '| P9.3 - GND | GND |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the ADCs input must be limited to 1.8V, so we must scale the sensor's
    output voltage by a factor of two, as described in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to check all connections, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to speak while you rerun the command, you should get a higher value,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, the higher the environmental sound, the higher the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the tiny LCD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The tiny LCD used in this chapter is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the tiny LCD](img/B00255_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The device can be purchased from [http://www.cosino.io/product/color-tft-lcd-1-8-160x128](http://www.cosino.io/product/color-tft-lcd-1-8-160x128),
    or by surfing the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The LCD is based on the ST7735R chip, which has its datasheet at [https://www.adafruit.com/datasheets/ST7735R_V0.2.pdf](
    https://www.adafruit.com/datasheets/ST7735R_V0.2.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated previously, to connect the LCD, we must use an SPI bus and some GPIOs
    available in the BeagleBone Black''s expansion connectors. The following table
    shows the electrical connections between the BeagleBone Black''s pins and the
    LCD pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | LCD pin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P9.4 - Vcc | 9 - Vcc |'
  prefs: []
  type: TYPE_TB
- en: '| P9.29 - MISO | Not connected |'
  prefs: []
  type: TYPE_TB
- en: '| P9.30 - MOSI | 4 - MOSI |'
  prefs: []
  type: TYPE_TB
- en: '| P9.31 - SCLK | 3 - SCK |'
  prefs: []
  type: TYPE_TB
- en: '| P9.28 - SS0 | 5 - TFT_CS |'
  prefs: []
  type: TYPE_TB
- en: '| P9.25 | 7 – D/C |'
  prefs: []
  type: TYPE_TB
- en: '| P9.27 | 8 - RESET |'
  prefs: []
  type: TYPE_TB
- en: '| P8.19 | 1 - LITE |'
  prefs: []
  type: TYPE_TB
- en: '| P9.2 - GND | 10 - GND |'
  prefs: []
  type: TYPE_TB
- en: 'To enable the device, we can use a driver that should already be available
    on your system. To verify it, just use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In my kernel configuration, the driver is statically linked into the kernel,
    but it''s okay to have it as a module. In this case, the output should be something
    like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking the driver, we also need a proper DTS file to set up the kernel.
    Instead of writing a new one from scratch, I got a suitable DTS file from the
    following URL by using the `wget` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After the download, we need only to compile the preceding DTS file by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can enable the LCD by using the usual `echo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we get the following error then we have to disable the HDMI support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This can be done by editing the u-boot settings in the `/boot/uboot/uEnv.txt`
    file and then enabling the following line by uncommenting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that on some BeagleBone Black versions, you may find the `uEnv.txt` file
    under the `/boot` directory instead, and the u-boot setting to modify it is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then, we only have to reboot the system. Now, if everything is done correctly,
    we should be able to execute the preceding command without errors.
  prefs: []
  type: TYPE_NORMAL
- en: If everything works well, the BeagleBone Black should enable a colored framebuffer
    device 32 x 26 characters wide represented in the user space by the **/dev/fb0**
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reader can take a look at the book *BeagleBone Essentials*, *Packt Publishing*,
    written by the author of this book, in order to get more information regarding
    how to activate and use the SPI buses available on the system, how to recompile
    a kernel driver, and to have a brief description of the DTS file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final note, the reader should remember that we can print strings on the
    LCD by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `/dev/tty0` device is the one connected to the terminal running on
    the `/dev/fb0` framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: The final picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following image shows the prototype I made to implement this project and
    test the software:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The final picture](img/B00255_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the contactless temperature sensor has been connected to the board
    by using a flat cable in order to easily move it to measure the temperature of
    different objects.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we're going to show a trick to exchange data between two processes
    in a very simple manner. At the beginning of the chapter, it was mentioned that
    the ADCs must be sampled at 100Hz, but we don't need to be so fast to render a
    simple interface on the external LCD. In fact, a reasonable updating frequency
    for the user interface can be 1Hz (once per second.) So, to keep the code simple,
    we implement our device by using two different processes running at different
    frequencies that exchange data with each other instead of using a single process.
  prefs: []
  type: TYPE_NORMAL
- en: Simply speaking, if we realize a program called `adc` that reads the data from
    the ADCs at 100Hz and then prints its output on the `stdout` stream (standard
    output) at 1Hz, we can redirect such output to another program called `lcd.sh`
    that reads the data from its `stdin` stream (standard input) at 1Hz and then draws
    the user interface accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data flow is unidirectional. Program `adc` reads data from the ADC and,
    after its elaboration stage, sends its output to `lcd.sh` that manages the LCD.
    This special functioning is very well represented by a Unix *pipe* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The reader should also notice that the timing for the interface is generated
    by the `adc` program simply printing its output at well-defined intervals, without
    any other timing mechanisms, into the `lcd.sh` program. So, let's see how we can
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: The ADC manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated previously, to correctly manage and analyze the ADC's input signals,
    we need a low jitter and fine-grained sampling time. It has already been mentioned
    that having *Ts=10 ms* as the sampling time would be enough for our purposes,
    so let's see how we can get it!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.html "Chapter 5. WhatsApp Laundry Room Monitor"), *WhatsApp
    Laundry Room Monitor*, we used a simple Bash script to read from the ADC; but
    for that prototype, the signal frequency was so low that the implemented solution
    was really reliable. Now we have to do something more elaborate. This time, we''re
    going to use a C program to read data from the ADCs, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete code can be found in the `chapter_06/adc_simple.c` file in the
    book's example code repository.
  prefs: []
  type: TYPE_NORMAL
- en: The code can be compiled directly on the BeagleBone Black by using the `make`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The code functioning is simple. First, we get the current time with the `clock_gettime()`
    function. Then, we read the data from the ADC by accessing it from the `sysfs`
    interface. And, at the end, we compute the amount of time to sleep for before
    reaching the new active period.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running the preceding code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we notice from the preceding output, the program is quite precise; but if
    we use a simple `awk` script to compute the minimum, maximum, and average `jitter`
    value over 1,000 samples, we discover that the program is not so precise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `awk` script file `jitter.awk` can be found in the `chapter_06/jitter.awk`
    file in the book's example code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The average and the minimum values are acceptable, but the maximum one is really
    high. Moreover, sometimes the following may happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This error happens when the delay computed in the following lines becomes negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If the system is too slow in scheduling the process at the beginning of the
    period, it may happen that we do not have enough time to complete our task! This
    is due to the fact that we are not using a real-time system and we have no guarantees
    of correct scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can try to resolve this problem with some tricks. The Linux kernel
    is not real time, but it has some facilities that may help us in realizing an
    acceptable compromise. In fact, the system allows us to use different schedulers
    to manage the processes running on the BeagleBone Black. In particular, we can
    use the `chrt` command to manipulate the real-time schedule attributes of a process
    and then to set the **FIFO scheduler** that may help us to reduce the `jitter`
    value and the scheduling delay error. If we rerun the preceding test using the
    `chrt` command as follows, we get a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Also, the scheduling delay error disappears!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that even using the `chrt` command, the Linux kernel is not real time anyway,
    so nobody can guarantee that everything will go well forever! To make the system
    reliable, we have to add some recovery code in case something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering what was just explained, a possible implementation of the ADC manager
    is reported in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete code can be found in the `chapter_06/adc.c` file in the book's
    example code repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `setlinebuf()` function is needed to force an output at each printed line,
    while the `sched_setscheduler()` function is used to enable the FIFO scheduler
    (as the `chrt` command does). The code is quite similar to before except the fact
    that we use the `extract()` function (mentioned at the beginning of this chapter)
    to calculate the average, minimum, and maximum values of the input data as requested.
    Note that the program prints its output once per second, thanks to the `ticks`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If executed, the program will then print several lines, one per second, reporting
    the pressure average value, the pressure signal amplitude, and the sound average
    value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: All this data is taken as inputs by the `lcd.sh` process described in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the BeagleBone Black's ADCs have a continuous mode function that can
    be used to reach a higher sampling rate, but I didn't use it in this project due
    to the fact that it's not strictly needed nor supported on all kernels.
  prefs: []
  type: TYPE_NORMAL
- en: The curious reader can get further information about this topic at [http://processors.wiki.ti.com/index.php/AM335x_ADC_Driver's_Guide](http://processors.wiki.ti.com/index.php/AM335x_ADC_Driver's_Guide).
  prefs: []
  type: TYPE_NORMAL
- en: The LCD manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program that manages the LCD is a simple Bash script that uses some tricks
    to realize a fancy rendering of the collected data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated previously, this program runs each second, thanks to the ADC manager
    that sends its output periodically to the `lcd.sh` program. A simple functioning
    of this program can be represented by the following meta-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That's all! The other complexities are only related to how we wish to implement
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding this issue, I decided to use a really simple solution: some terminal
    **escape sequences** to manage the colors, and the `figlet` program to *draw*
    big fonts. Escape sequences are used to easily print some characters on the screen
    with specified colors by using the `echo` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `\e[31m` sequence sets the red color, while the `\e[39m` sequence resets
    the default one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For further information regarding these sequences, a good starting point is
    available at [https://en.wikipedia.org/wiki/ANSI_escape_code](https://en.wikipedia.org/wiki/ANSI_escape_code).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `figlet` program is a tool that can be used to simulate printing big fonts
    on a terminal, a kind of ASCII art. To install it, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, its usage is very simple, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For our user interface implementation, I used some special option arguments
    that I'm not going to explain here due to lack of space, but a curious reader
    can take a look at man pages of `figlet` for further information.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this brief introduction, it''s time to show a snippet of the main code
    of the `lcd.sh` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete code can be found in the `chapter_06/lcd.sh` file in the book's
    example code repository.
  prefs: []
  type: TYPE_NORMAL
- en: From the beginning of the `while` loop until the `read` statement, we simply
    collect the data. Then, the code following the `Draw the GUI` comment is just
    to render the user interface. Note that the line with the `read` command will
    wait until an input line arrives from the `stdin` stream, that is, from the `adc`
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test it via `SSH` in a normal terminal of our host system, simulating the
    LCD, we can execute the following command to reduce the size of the terminal''s
    windows to 32x26 characters, which is the size of the terminal on LCD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the preceding command is just another escape sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can execute the program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The LCD manager](img/B00255_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Final test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the prototype, I used some tricks to simulate the baby: I got the crying
    sound on the Internet and simply reproduced it with an audio player. Regarding
    the breath, I used doll, manually pressurizing its chest in time with my breathing.
    I admit it''s not the best test, but my children are too big to help me in these
    experiments!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up all peripherals and drivers, we can use `SYSINIT.sh`, as in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This command can be found in the `chapter_06/SYSINIT.sh` file in the book's
    example code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, I executed both the `adc` and `lcd.sh` programs by using the following
    command line in order to send all outputs to the terminal that runs on the tiny
    LCD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that on the first framebuffer device, we have at least one terminal defined
    by default, which is referred to by the `/dev/tty0` device.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered a more reliable and precise way to get access
    to the BeagleBone Black's ADCs and learned how we can get access to an I²C device
    by using a raw access to the bus. This was done in order to be able to manage
    a pressure sensor and a contactless temperature sensor. Also, we discovered how
    to connect a tiny LCD via the SPI bus to our BeagleBone Black board to add a little
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll try to implement a plant monitor to measure what
    happens to our beloved plants! Also, we will discover how we can periodically
    take some pictures and then publish them on a Facebook account.
  prefs: []
  type: TYPE_NORMAL
