<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Variables and Objects</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we are discussing the following topics:</p>
<ol>
<li>Using environment variables</li>
<li>Storing the output of an instance of a .NET Core object</li>
<li>Creating custom properties to an object</li>
<li>Creating a custom object from a returned object</li>
<li>Understanding extension of type data</li>
<li>Retaining object modifications across sessions</li>
<li>Removing custom type data</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Variables are important to programming since they act as containers of information stored during the program execution. Although piping makes PowerShell highly versatile, they still cannot replace variables, because objects passed through the pipeline must be consumed immediately, and not all scripts work that way, given our varied requirements.</p>
<p>We are all aware of the various data types: <kbd>int</kbd>, <kbd>double</kbd>, <kbd>string</kbd>, <kbd>char</kbd>, <kbd>array</kbd>, etc. Two other important types of variables in PowerShell are <em>hashtables</em> and <em>objects</em>. A hashtable is a dictionary table formed with key<span>–</span><span>value pairs. An object, as we have seen, could be as complex and as simple as it can get in PowerShell, holding values of different kinds.</span></p>
<p><span>In PowerShell, objects can be stored into variables. For instance,</span></p>
<pre class="western">$Processes = Get-Process</pre>
<p><span>would store all the processes into the variable, <kbd>$Processes</kbd>.</span></p>
<p><span>One more point to remember with variables is the scope. By default, variables have a local scope, meaning, they are valid within the function that they are specified in. Global variables are valid across the program. In general, it is a best practice to use local variables, though.</span></p>
<p>Global variables are declared and used with the <kbd>$Global:</kbd> prefix, such as <kbd>$Global:MyVariable</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using environment variables </h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about environment variables. When interacting with the system through a shell session, there are many pieces of information that the Shell requires in order to determine the program access, the available resources, default configuration, system properties, etc. Some of these settings are configured within the system as variables and these settings are commonly called the <em>Environment<strong> </strong>Variables</em>.</p>
<p>While hard-coding this information during installation is one way to go, it makes the entire system a monolith that cannot be reconfigured without what is known as nuking-and-paving. With environment variables, another layer of flexibility is introduced.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let us start working with an environment variable using the following steps:</p>
<ol>
<li>To Display environment variable, type in <kbd>Get-ChildItem env:</kbd> or <kbd>Get-Item env:</kbd> and press enter</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem env:<br/>PS&gt; Get-Item env:</pre>
<ol start="2">
<li><kbd>Env:</kbd> is also a PowerShell provider, and works just like a file system. Therefore, you could also <kbd>Set-Location</kbd> at <kbd>Env:</kbd> and use <kbd>Get-ChildItem .</kbd> to list out the variables available in your system.</li>
<li>To display the value of the specific environment variable, run the following command.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem Env:/PATH | Select-Object value | Format-Table -Wrap</pre>
<div class="packt_tip">After typing <kbd>Get-ChildItem Env:/</kbd>,  You can use tab-completion to populate all environment variables. </div>
<ol start="4">
<li>Do a <kbd>Get-Member</kbd> on the <kbd>PATH</kbd> environment variable to find its type.</li>
<li>Before changing the environment variable, list the <kbd>PATH</kbd> variable using <kbd>$env:PATH | Get-Member</kbd>. It is a string. Save the contents someplace safe.</li>
<li>Now, update the <kbd>PATH</kbd> environment variable by adding the path of <kbd>sqlcmd</kbd> tool executable to $<kbd>env: PATH</kbd> variable. The operation is a simple addition of a string to the existing value.</li>
</ol>
<div class="packt_tip">You could add any location to <kbd>PATH</kbd>. If you insist on getting <kbd>sqlcmd</kbd>, head over to <a href="https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-setup-tools?view=sql-server-linux-2017">Microsoft docs</a> for SQL Server 2017 for instructions to get yourself a copy.</div>
<pre style="padding-left: 90px">PS&gt; $env:PATH = $env:PATH + ':/opt/mssql-tools/bin'<br/>PS /root&gt; sqlcmd</pre>
<p style="padding-left: 60px">The output of the preceding code block is illustrated in the following image:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/1e6b48cb-4403-4d84-aac1-56e43f0a78b9.png" width="1984" height="1140"/></div>
<ol start="7">
<li>Let us exit the session, launch a new session,  check the <kbd>PATH</kbd> variable, and run the <kbd>sqlcmd</kbd> executable.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; sqlcmd <br/><br/>sqlcmd : The term 'sqlcmd' is not recognized as the name of a cmdlet, function, script file, or operable program.</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As we saw in <em>Listing the various providers in PowerShell</em>, <kbd>Env</kbd> is a provider that contains environment-specific configuration. <span>Most of these configuration options are also exposed to us as environment variables. </span>We are able to use <span>the cmdlets <kbd>Get-ChildItem</kbd> and <kbd>Get-Item</kbd> to list the values of the available environment variables because <kbd>Env:</kbd> is a drive within the <kbd>Env</kbd> provider. As environment variables do not have child items, <kbd>Get-Item</kbd> and <kbd>Get-ChildItem</kbd> return the same output.</span></p>
<p><span>Since these variables determine how your session behaves with you, changes made to these values are ephemeral. In other words, the value of <kbd>$env:PATH</kbd> is picked from the configuration on your Linux computer. The manual change made to <kbd>$env:PATH</kbd> made within a PowerShell session remains as long as the PowerShell session is alive. Changes made to $env:PATH does not change the value within the system itself.</span></p>
<p>If you would like to make a certain change permanent, edit the <kbd>.bashrc</kbd> or the <strong><kbd>~/.bash_profile</kbd> </strong>configuration files. If you would like to use PowerShell instead of Bash, make the change in your PowerShell profile. Instructions on how to do that can be found in the recipe, <span><em>Enabling automated execution of commands for each load</em>, in the chapter, <em>Preparing for Administration using PowerShell</em>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can also access environment variables using  .NET type accelerator and its methods.</p>
<pre>PS&gt; [environment]::GetEnvironmentVariable("PATH")</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>About Environment variables: <kbd>Get-Help about_Environment_Variables</kbd></li>
<li>Recipe 1.11: Listing the various providers in PowerShell</li>
<li>Recipe 3.4: Enabling automated execution of commands for each load</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Storing the output of an instance of a .NET Core Object</h1>
                </header>
            
            <article>
                
<p>.NET is object-oriented, and works on classes and objects. PowerShell, being an extension to this framework, allows you to work with the <span>.NET framework and COM interfaces in order to perform many system administration tasks. This way, you are not limited only to the tasks that can be performed using cmdlets.</span></p>
<p>In this recipe, we will define a simple class from within PowerShell.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>We recommend using Visual Studio Code for this recipe. To know how to install and configure it, visit the recipe, <em>Installing Visual Studio Code</em> from the chapter, <em>Preparing for Administration using PowerShell</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Launch Visual Studio Code and address any immediate requirements it asks for.</p>
<ol>
<li><span>Open a new file in Visual Studio Code and set the file type as PowerShell.</span></li>
<li>Type in the following in the script pane. The file does not have to be saved.</li>
</ol>
<div>
<pre style="padding-left: 90px"><span>class</span><span> </span><span>Person</span><span> {<br/></span><span>    [</span><span>string</span><span>]</span><span>$</span><span>Name<br/></span><span>    [</span><span>Int32</span><span>]</span><span>$</span><span>Age<br/></span><span>    [</span><span>int32</span><span>]</span><span>$</span><span>Salary<br/></span><span>    <br/>    Person () {}<br/></span><span>    <br/>    Person ([</span><span>string</span><span>]</span><span>$</span><span>Name</span><span>,</span><span> [</span><span>int32</span><span>]</span><span>$</span><span>Age</span><span>) {<br/></span><span>        </span><span>$</span><span>this</span><span>.Name</span><span> </span><span>=</span><span> </span><span>$</span><span>Name<br/></span><span>        </span><span>$</span><span>this</span><span>.Age</span><span> </span><span>=</span><span> </span><span>$</span><span>Age<br/></span><span>    }<br/></span><span>    <br/>    [</span><span>int32</span><span>] sal ([</span><span>int32</span><span>]</span><span>$</span><span>Salary</span><span>,</span><span> [</span><span>int32</span><span>]</span><span>$</span><span>Comm</span><span>) {<br/></span><span>        </span><span>return</span><span> </span><span>$</span><span>Salary</span><span> </span><span>*</span><span> </span><span>$</span><span>Comm<br/></span><span>    }<br/></span><span>}</span></pre></div>
<ol start="3">
<li>To find constructors of a class, call the static method, <kbd>New</kbd>; type in the following at the prompt.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; [Person]::New</pre>
<ol start="4">
<li>This gives us two functions of the same name; these are overload definitions. Now, create a new object by passing in the parameters.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; [Person]::New('Prashanth',34) </pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/6134d77a-3052-4d39-b0ba-c260b5982fd6.png" width="1950" height="1399"/></div>
<ol start="5">
<li>Now, let us invoke the constructor the PowerShell way, which in turn calls the .NET constructor. This creates an instance of the Person class (which, by definition, is an object).</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $Person = New-Object -TypeName Person -ArgumentList 'Prashanth', 34</pre>
<ol start="6">
<li>To list the properties of the object (and by extension, the class), run the <kbd>Get-Member</kbd> cmdlet.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $Person | Get-Member <br/><br/>PS&gt; $Person | Select-Object Name, Age, Salary | Format-Table -AutoSize <br/><br/>PS&gt; $Person.sal(200,2)</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/8daf5696-50c8-40ac-b1f9-a9114d7c13b9.png" width="1950" height="1229"/></div>
<ol start="7">
<li>Next, Let us take a look at the other samples. Let us use system-defined class libraries.</li>
</ol>
<div>
<pre style="padding-left: 90px"><span>PS&gt; $</span><span>MailClient</span><span> </span><span>=</span><span> </span><span>New-Object</span><span> </span><span>-</span><span>TypeName System.Net.Mail.SmtpClient </span><span>'packtpub.smtpdomain.com'<br/></span><span>PS&gt; $</span><span>Message</span><span> </span><span>=</span><span> </span><span>New-Object</span><span> System.Net.Mail.MailMessage(</span><span>'pjayaram@packtpub.com'</span><span>,</span><span> </span><span>'pjayaram@packtpub.com'</span><span>,</span><span> </span><span>'Subject'</span><span>,</span><span> </span><span>'Welcome to Packt!'</span><span>)<br/></span><span>PS&gt; $</span><span>MailClient</span><span>.Send</span><span>(</span><span>$</span><span>Message</span><span>)</span></pre></div>
<ol start="8">
<li>Let us see another example of password encryption using <kbd>System.Management.Automation</kbd> class objects.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $User = 'Prashanth' <br/>PS&gt; $Password = 'Y94b^E$85CBLU%at' <br/>PS&gt; $SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force <br/>PS&gt; $Credentials = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User, $SecurePassword <br/>PS&gt; $Credentials | Get-Member</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/6cb687d1-a002-45c1-917f-d2a18d39014e.png" width="1984" height="888"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The goal of this recipe is to demonstrate how PowerShell works hand-in-hand with .NET, and objects that are created the <em>.NET way</em> can be called (and stored) easily in PowerShell. First, we declare a class with the keyword, <kbd>class</kbd>. We then declare its parameters, and then, create two constructors: one default and one parameterised.</p>
<p>We also create a method called <kbd>sal</kbd>. We define its return type as <kbd>int32</kbd>, and defined two parameters. Within it, we define what needs to be returned.</p>
<p>Back at the PowerShell prompt, we call the static (method of the class, not of an object) <kbd>New</kbd> method. The syntax is to mention the class name, followed by two consecutive colons (<kbd>::</kbd>) to call it in the global namespace, followed by the name of the method.</p>
<p><span>If you follow the steps, you'll also see an example of using the two different system class libraries, </span><kbd>System.Net.Mail.SmtpClient</kbd> and <kbd>System.Net.Mail.MailMessage</kbd>, and the instantiation of a method by integrating the output of mail-message with the SMTP-client object.</p>
<p>Next, we use the system class library <kbd>System.Management.Automation.PSCredential</kbd>. In this <span>example, we send some text to </span><kbd>ConvertTo-SecureString</kbd><span> which takes input as plain text</span> and converts it to a secure string. Then, we pass the encrypted string to the <kbd>PSCrendital</kbd> system class to store the user name and the secure string into the <kbd>$Credentials</kbd> variable. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 3.1: Installing Visual Studio Code</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding custom properties to an object</h1>
                </header>
            
            <article>
                
<p>PowerShell cmdlets are capable of allowing the administrators to work with most tasks. However, there are some situations where the returned objects don't satisfy the administrative needs of a certain script. In such situations, we may need to create our own custom objects based on the available .NET classes, or at least, add a custom property to the object.</p>
<p>While a string is an object of <kbd>System. String</kbd> type, the <kbd>Get-Process</kbd> cmdlet returns an object of type <kbd>System.Diagnostics.Process</kbd>, <kbd>Get-ChildItem</kbd> returns an object with the type <kbd>System.IO.FileInfo</kbd>, <span>a custom-created object has the object type, <kbd>PSCustomObject</kbd>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let us now proceed to create a custom object.</p>
<ol>
<li>To create a custom object, use <kbd>New-Object</kbd> cmdlet. </li>
</ol>
<pre style="padding-left: 90px">PS /home/PacktPub&gt; New-Object -TypeName PSCustomObject</pre>
<ol start="2">
<li>That was not of much use to us. Let us add a few properties into it, along with their values and store these values in a variable.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $MyCustomObject = [pscustomobject]@{ <br/>  Name = 'Prashanth Jayaram'<br/>  Title = 'PowerShell'<br/>  Publisher = 'Packt' <br/>}<br/><br/>PS&gt; $MyCustomObject</pre>
<ol start="3">
<li>To add properties to an object, use the <kbd>Add-Member</kbd> cmdlet.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $MyCustomObject | Add-Member -MemberType NoteProperty -Name 'Location' -Value 'United States'<br/>PS&gt; $MyCustomObject</pre>
<ol start="4">
<li>To remove a property from an object, use the following command.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $MyCustomObject.PsObject.Properties.Remove('Location')<br/><br/>PS&gt; # To see if the property is still available, run:<br/>PS&gt; $MyCustomObject.Location</pre>
<ol start="5">
<li>To access properties, you can use the member access operator<span> (</span><kbd>.</kbd><span>)</span>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $MyCustomObject.Name <br/>Prashanth Jayaram<br/><br/>PS&gt; $MyCustomObject.Title <br/>PowerShell<br/><br/>PS&gt; $MyCustomObject.Publication <br/>Packt</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Creating an object is straightforward. All you have to do is tell PowerShell that you are creating a custom object, by calling the <kbd>[psobject]</kbd> accelerator and specifying the properties you would like to add to the object. After the accelerator is called, we specify the names of the properties, and assign values to them. Records are added one at a time, using the hash literal notation (<kbd>Name = 'Prashanth'</kbd>).</p>
<div class="packt_tip">It is easy to confuse a hashtable with a PSObject at this stage, given that we use the hash literal notation when creating the object. Remember that they are very different from each other. We will get into the details of what a hashtable is in the chapter, <em>Arrays and Hashtables</em>.</div>
<p>We mention three properties in the custom object we have created: <kbd>Name</kbd>, <kbd>Title</kbd> and <kbd>Publisher</kbd>. If we would like to add additional properties in the future, we can simply use the <kbd>Add-Member</kbd> cmdlet, where we specify the object (we pass the object through the pipeline), we specify the name of the property, and assign a value to it.</p>
<p>Removing a property is a little more complex, since we do not have a <kbd>Remove-Member</kbd> cmdlet, nor are the members we use in the step easily discoverable. For instance, <kbd>[PSCustomObject] | Get-Member</kbd> does not reveal <kbd>PsObject</kbd> being its member. We call the <kbd>Remove</kbd> method within the <kbd>Properties</kbd> object, which is within the <kbd>PSObject</kbd> object of the custom object we created. (So many objects!)</p>
<p>Accessing properties in an object is as simple as using the member access operator with the property name.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe: Creating and initialising a simple hashtable</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a custom object from a returned object</h1>
                </header>
            
            <article>
                
<p>We now know how to create a custom object from scratch. In this recipe, we will use a returned object, and modify the returned object to create a custom object. When we look at loops, we will extend this capability to create versatile custom objects; in production environments, this capability can be used to do more!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The first step to learning something is to simplify it. Therefore, we will select only one instance of an object and work with it.</p>
<ol>
<li>Get all the processes, select only the name, ID, working set and the start time, pick the 5th process in the list, and assign it to a variable.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $Process = (Get-Process | Select-Object Name, Id, WS, StartTime)[4]</pre>
<ol start="2">
<li>Let us say that we did not like the names of the properties in the object. Let us change the names.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $CustomProcess = New-Object -TypeName PSObject -Property @{<br/>  ProcessName = $Process.Name<br/>  ProcessId = $Process.Id<br/>  WorkingSet = $Process.WS<br/>  StartedAt = $Process.StartTime<br/>}<br/>PS&gt; $CustomProcess</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/a42cf4a5-4cb5-4112-9157-fd017a8d4192.png" width="1984" height="600"/></div>
<ol start="3">
<li>But that is not the sequence we specified. Let us get them in sequence.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $CustomProcess = [ordered]@{<br/>  ProcessName = $Process.Name<br/>  ProcessId = $Process.Id<br/>  WorkingSet = $Process.WS<br/>  StartedAt = $Process.StartTime<br/>} <br/>PS&gt; New-Object -TypeName PSObject -Property $CustomProcess</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/609d4d23-847e-4300-9453-0071a046f302.png" width="1984" height="564"/></div>
<ol start="4">
<li>Recreate the object with information on how long the process has been running for instead of when it was started.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $CustomProcess = [ordered]@{<br/>  ProcessName = $Process.Name<br/>  ProcessId = $Process.Id<br/>  WorkingSet = $Process.WS<br/>  RunningMins = [math]::Floor(((Get-Date) - $Process.StartTime).TotalMinutes)<br/>}<br/>PS&gt; New-Object -TypeName PsObject -Property $CustomProcess</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/9708bd11-619f-45c9-8842-7aac2c1ac587.png" width="1984" height="564"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a custom object (<kbd>$CustomProcess</kbd>) from an output object (<kbd>$Process</kbd>). The properties within <kbd>$Process</kbd> can be accessed using the member access operator. Values from <kbd>$Process</kbd> are treated as values for the properties in <kbd>$CustomObject</kbd>, however, the names in <kbd>$CustomObject</kbd> are different. In this recipe, we also used a calculated property, <kbd>RunningMins</kbd>.</p>
<p>An important point to note here is that the outcome of this recipe can also be achieved using calculated properties along with <kbd>Select-Object</kbd>. However, in situations where object versatility is important and the number of instances of the objects is significantly larger, it is simpler to use a custom object. We will extend this capability in future chapters, after we learn to use looping constructs.</p>
<p>The other point to note is the use of the <kbd>[ordered]</kbd> accelerator. More often than not, the properties of custom objects do not appear in the sequence we mention them in. In this recipe, we separate the hash literal notation from the creation of the custom object. We first create an ordered hashtable with the property names as well as the property values, and then, specify the created hashtable for the <kbd>Property</kbd> parameter of the <kbd>New-Object</kbd> cmdlet to create the custom object with the properties showing in the sequence we want.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="https://docs.microsoft.com/en-us/powershell/scripting/getting-started/cookbooks/creating-.net-and-com-objects--new-object-?view=powershell-6">Creating .NET and COM Objects</a> (Microsoft Docs)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding extension of Type Data</h1>
                </header>
            
            <article>
                
<p><span>In the recipe,</span> <em>Selecting columns from the output</em><span>, we used a hashtable to set the name and the expression for a custom-named column. Later, we also used a small calculation within the</span> <kbd>Select-Object</kbd> <span>statement to get a calculated output. If you tried to select the column by the new name, that would have worked, too. Technically, you have already extended the object. But what is type data anyway? And why do we need a recipe to extend it when we can work with</span> <kbd>Select-Object</kbd><span>?</span></p>
<p><span>Going too deep into what type data is and how to work with them along with .NET classes and objects could potentially make the concept an "advanced" one. Historically, most of us learners have procrastinated learning "advanced" topics. Therefore, we will stick to the simple parts of it, and work only with PowerShell for now. This recipe will serve as a launchpad to help you understand what it is by making it simple and fun, keeping it away from anything "advanced", in the interest of learning.</span></p>
<p>There are two options to extend the type data:</p>
<ol>
<li>Using PowerShell cmdlets (to understand how it all works)</li>
<li>Using an XML file (for portability)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>To understand what we are talking about, here, you need to have read the following recipes:</p>
<ol>
<li>Selecting columns from the output</li>
<li>Creating a custom object from a returned object</li>
</ol>
<p>Let us come back to the question: Why extend type data when we can use <kbd>Select-Object</kbd>?</p>
<p>Efficiency. While you could change the name, add a calculation, and reference the calculated property with the new name, that change would have existed only in that context. If you added it to a variable, <span> </span><span>as in the last recipe, </span><em>Creating a custom object from a returned object</em><span>, where we did some nifty changes to the names and also created a custom </span><kbd>NoteProperty</kbd><span>, that would be a long way to go about it. Enter: extension of type data.</span></p>
<p>The rule of the thumb is,  If you do something repetitively, there's an issue: you haven't considered automating it. For example,  if you run:</p>
<pre>PS&gt; Get-ChildItem -Path . | select Name, Length, @{Name='Age'; Expression={[math]::Round(((Get-Date) - $_.LastWriteTime).TotalDays)}}</pre>
<p>instead of:</p>
<pre>PS&gt; Get-ChildItem -Path . | select Name, Length, Age</pre>
<p>and you do it fifteen times a day, you should consider extending the object to give you what you care about.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Navigate to the location where you created files for lab usage.</p>
<ol>
<li>Enter the following command:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $FilesWithAge = Get-ChildItem . | Select-Object Name, Length, LastWriteTime</pre>
<ol start="2">
<li>Now, add a property to the variable, <kbd>$FilesWithAge</kbd>; the property should be the age of each file, in days.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $FilesWithAge | Add-Member -MemberType ScriptProperty -Name Age -Value { [math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays) }</pre>
<ol start="3">
<li>Add another property to it, called <kbd>ComputerName</kbd>, which is the name of your local host.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $ComputerName = hostname<br/>PS&gt; $FilesWithAge | Add-Member -MemberType NoteProperty -Name ComputerName -Value $ComputerName</pre>
<ol start="4">
<li>Add another property, as an alias to <kbd>LastWriteTime</kbd>, called <kbd>Modified</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $FilesWithAge | Add-Member -MemberType AliasProperty -Name Modified -Value LastWriteTime</pre>
<ol start="5">
<li>To format it like a nice table, use the following:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $FilesWithAge | Format-Table -AutoSize</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/8be1b9ba-03be-4dd0-825e-63cb802c0205.png" width="1812" height="1044"/></div>
<ol start="6">
<li>Now, delete the variable. And query the files within the current directory (because that is what the variable actually held).</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Remove-Variable FilesWithAge<br/>PS&gt; Get-ChildItem .</pre>
<p style="padding-left: 60px">You do not see the <kbd>Age</kbd>, the <kbd>ComputerName</kbd> or the <kbd>Modified</kbd> properties. Try <kbd>Get-Member</kbd> if you would like.</p>
<p style="padding-left: 60px">Next, we see how to extend the type data itself, so that every time you run <kbd>Get-ChildItem</kbd>, you also get the three properties we added to the variable.</p>
<ol start="7">
<li>Get what object is returned when you run <kbd>Get-ChildItem</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem | Get-Member</pre>
<ol start="8">
<li>You get <kbd>System.IO.DirectoryInfo</kbd> as well as <kbd>System.IO.FileInfo</kbd>. We pick <kbd>System.IO.FileInfo</kbd>. Run the following commands.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $ComputerName = hostname <br/><br/>PS&gt; Update-TypeData -TypeName System.IO.FileInfo -MemberType NoteProperty -MemberName ComputerName -Value $ComputerName<br/><br/>PS&gt; Update-TypeData -TypeName System.IO.FileInfo -MemberType AliasProperty -MemberName Modified -Value LastWriteTime<br/><br/>PS&gt; Update-TypeData -TypeName System.IO.FileInfo -MemberType ScriptProperty -MemberName Age -Value { [math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays) } </pre>
<ol start="9">
<li>Query the contents of the current location and optionally, format the output like a table.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem . | Select-Object Name, Length, ComputerName, Age, Modified | Format-Table -AutoSize</pre>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c5b3b81f-1763-4c48-8193-e924941e8b58.png" width="1812" height="1044"/></div>
<ol start="10">
<li>Do the same for any directory in the file system, the only condition being that the directory should contain at least one file, and not just more directories.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem ./cities/ | Select-Object Name, Length, ComputerName, Age, Modified | Format-Table -AutoSize</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the first section, we added members to the objects within a certain variable. This was a command-line-prompt-style extension to the recipe, <em>Creating a custom object from a returned object</em>, which was, by all means, a little more efficient in the context. However, the changes we made to the object remained only while the variable, <kbd>$FilesWithAge</kbd>, was valid. The object returned by <kbd>Get-ChildItem</kbd> was not modified at all.</p>
<p>There is an important point to note here: <kbd>$this</kbd>. We have come across the automatic variable, <kbd>$_</kbd> (or <kbd>$PSItem</kbd> after PowerShell V3) when dealing with objects passed through the pipeline; the variable holds the current instance of the object in the pipeline. However, when we have to perform an object extension, we use the automatic variable, <kbd>$this</kbd>. Why? Because, the property being referred to is being referred <em>within</em> the parent object (the object returned by <kbd>Get-ChildItem</kbd>). External methods would be able to use <kbd>$_</kbd>. In a way, <kbd>$_</kbd> does not even exist yet, when performing the member addition. Also, <kbd>$this</kbd> in fact, refers to the object itself, that is returned by <kbd>Get-ChildItem</kbd>, and not just an instance of it.</p>
<p>When we would like to get a member as part of the object itself, throughout the session, irrespective of the validity of a certain variable or the object instance, we <em>extend the type data itself</em>. Therefore, no matter what context you run the cmdlet in, you would get the additional members you added. Of course, the formatting rules in PowerShell may still not let those members appear in the output by default. You can always call the specific members, though, such as using <kbd>Select-Object</kbd> for properties, or simply using the member access operator on the properties: <kbd>(Get-ChildItem .).Age</kbd>.</p>
<p>For this, we use the <kbd>Update-TypeData</kbd> cmdlet. <kbd>Update-TypeData</kbd>, in this context, requires the <kbd>TypeName</kbd>, which as we have already seen, can be determined using <kbd>Get-Member</kbd> on the returned object.</p>
<p>We mention four things in the <kbd>Update-TypeData</kbd> statements: </p>
<ol>
<li>The type name</li>
<li>The member type</li>
<li>The member name</li>
<li>The member value</li>
</ol>
<p>Member type accepts several values, of which we use three:</p>
<ol>
<li><kbd>AliasProperty</kbd>, which is simply a reference to another member within the object. The new property is just another name to an existing property. Therefore, the <kbd>Value</kbd> parameter can just take the name of the existing member.</li>
<li><kbd>NoteProperty</kbd>, which is a static value. In our case, we can use the host name as the static value.</li>
<li><kbd>ScriptProperty</kbd>, which is essentially a calculation. We calculate the time span between the date when it was last modified and the current date. This calculation is the <kbd>Value</kbd> for the member, and accepts a script block.</li>
</ol>
<p>This modification to the object would be valid as long as the session is valid; the change is not persistent across sessions. That brings us to the next recipe, making object modifications stick across sessions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 5.1: Selecting columns from the output</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Retaining object modifications across sessions</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, Understanding extension of Type Data, we used the <kbd>Update-TypeData</kbd> cmdlet to add members. However, we said that the update was valid as long as the session was. Now, there could be two ways by which to make the type data stick across sessions:</p>
<ol>
<li>Using the PowerShell profile.</li>
<li>Using an XML file</li>
</ol>
<p>PowerShell profile is straightforward. However, usually, the type data extension and formatting rules are packaged as part of PowerShell modules. And adding code to the profile is not particularly helpful in that case. In this recipe, we will write a simple XML (<kbd>.ps1xml</kbd>) file that we will load in order to extend the type data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Restart your PowerShell session so that the custom data type extension is discarded.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We need an XML file. You can either use the <kbd>New-Item</kbd> cmdlet to create one, or simply use your favourite text editor. We use Visual Studio Code for this recipe. </p>
<ol>
<li>Open your text editor and create a new empty file, and save it as <kbd>CustomTypes.ps1xml</kbd>.</li>
<li>Add the following content to the XML file. Ensure not to change the case.</li>
</ol>
<div>
<pre style="padding-left: 90px"><span>&lt;?</span><span>xml</span><span> version</span><span>=</span><span>"1.0"</span><span> encoding</span><span>=</span><span>"utf-8"</span><span> </span><span>?&gt;<br/></span><span>&lt;</span><span>Types</span><span>&gt;<br/></span><span> </span><span>&lt;</span><span>Type</span><span>&gt;<br/></span><span>   </span><span>&lt;</span><span>Name</span><span>&gt;</span><span>System.IO.FileInfo</span><span>&lt;/</span><span>Name</span><span>&gt;<br/></span><span>   </span><span>&lt;</span><span>Members</span><span>&gt;<br/></span><span>     </span><span>&lt;</span><span>AliasProperty</span><span>&gt;<br/></span><span>       </span><span>&lt;</span><span>Name</span><span>&gt;</span><span>Modified</span><span>&lt;/</span><span>Name</span><span>&gt;<br/></span><span>       </span><span>&lt;</span><span>ReferencedMemberName</span><span>&gt;</span><span>LastWriteTime</span><span>&lt;/</span><span>ReferencedMemberName</span><span>&gt;<br/></span><span>     </span><span>&lt;/</span><span>AliasProperty</span><span>&gt;<br/></span><span>     </span><span>&lt;</span><span>ScriptProperty</span><span>&gt;<br/></span><span>       </span><span>&lt;</span><span>Name</span><span>&gt;</span><span>Age</span><span>&lt;/</span><span>Name</span><span>&gt;<br/></span><span>       </span><span>&lt;</span><span>GetScriptBlock</span><span>&gt;</span><span>[math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays)</span><span>&lt;/</span><span>GetScriptBlock</span><span>&gt;<br/></span><span>     </span><span>&lt;/</span><span>ScriptProperty</span><span>&gt;<br/></span>     &lt;<span>NoteProperty</span><span>&gt;<br/></span><span>       &lt;</span><span>Name</span><span>&gt;</span><span>ItemType</span><span>&lt;/</span><span>Name</span><span>&gt;<br/></span><span>       &lt;</span><span>Value</span><span>&gt;</span><span>File</span><span>&lt;/</span><span>Value</span><span>&gt;<br/></span>     &lt;/<span>NoteProperty</span><span>&gt;</span><span><br/></span><span>   </span><span>&lt;/</span><span>Members</span><span>&gt;<br/></span><span> </span><span>&lt;/</span><span>Type</span><span>&gt;<br/></span>&lt;/<span>Types</span><span>&gt;</span></pre></div>
<ol start="3">
<li>Save the file at a convenient location.</li>
<li>Back at the Terminal (or the PowerShell Integrated Console), enter the following command to update the type data using the XML. Notice the <kbd>PrependPath</kbd> parameter.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Update-TypeData -PrependPath ~/Documents/code/github/powershell/chapter-06/CustomTypes.ps1xml</pre>
<ol start="5">
<li>Now, list out all the files within any directory of your choice.</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem . -File | Select-Object Name, Length, Age, Modified</pre>
<p>You should see the new properties that you created.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/fc352f31-1676-4f6f-b492-31380f2aa080.png" width="1812" height="604"/></div>
<div class="packt_tip">It is advised to never modify the PS1XML files in the <kbd>$PSHome</kbd> directory. They are digitally signed by Microsoft and could be replaced with new versions during upgrades or patches.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Custom types and formats are mostly used while creating custom modules. Rarely do administrators require modifying the types or formats for stock PowerShell modules. And when you do require modifying custom types or formats, create a new PS1XML; do not modify the stock files, since they are digitally signed, and modifying them would break your setup.</p>
<p>Think of this PS1XML file as a regular XML file. Here is a simpler way of showing the structure. Remember that each type and each of the members within, must have a name.</p>
<pre>Types<br/>-- Type<br/>---- Members<br/>------ [The custom properties and methods you define]</pre>
<p>In essence, using the XML for type extension is not very different from how we performed type extension in the last recipe, except this uses an XML file, which makes the setup more portable. When we work on creating our custom modules, we will look at packaging the types along with the modules, and at that time, we will look in detail, how to work the paths. For now, we load the XML by manually specifying the exact path to the file. If you would like to load these custom types for every session of yours, you can easily call the PS1XML from your profile. The portability aspect here is that the XML can easily be shared or deployed; only the loading would be manual, or through the profile—much simpler than adding cmdlets to profiles.</p>
<p>When updating the type data using cmdlets, we used the parameters <kbd>Name</kbd> as well as <kbd>Value</kbd>, along with the <kbd>MemberType</kbd> parameter. PowerShell understood the context and set up the types accordingly. In case of XML, though, one must remember to use the correct tags for each of the member types. For instance, for <kbd>AliasProperty</kbd>, the tags within should be <kbd>Name</kbd> and <kbd>ReferencedMemberName</kbd> (shown below); for <kbd>ScriptProperty</kbd>, they should be <kbd>Name</kbd> and <kbd>GetScriptBlock</kbd>; for a <kbd>NoteProperty</kbd>, the tags would be <kbd>Name</kbd> and <kbd>Value</kbd>.</p>
<pre><span>&lt;</span><span>AliasProperty</span><span>&gt;<br/></span><span>   </span><span>&lt;</span><span>Name</span><span>&gt;</span><span>Modified</span><span>&lt;/</span><span>Name</span><span>&gt;<br/></span><span>   </span><span>&lt;</span><span>ReferencedMemberName</span><span>&gt;</span><span>LastWriteTime</span><span>&lt;/</span><span>ReferencedMemberName</span><span>&gt;<br/></span><span>&lt;/</span><span>AliasProperty</span><span>&gt;</span></pre>
<p>Also, remember <em>not</em> to enclose the entire script block in braces when placing the statement within the <kbd>GetScriptBlock</kbd> tag:</p>
<pre><span>&lt;</span><span>GetScriptBlock</span><span>&gt;<br/></span><span> [math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays)<br/></span><span>&lt;/</span><span>GetScriptBlock&gt;</span></pre>
<p>and not:</p>
<pre><span>&lt;</span><span>GetScriptBlock</span><span>&gt;<br/> { </span><span>[math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays) }<br/></span><span>&lt;/</span><span>GetScriptBlock</span><span>&gt;</span></pre>
<p>When loading the XML, we use the <kbd>PrependPath</kbd> parameter to load our XML <em>before</em> the built-in types are loaded. To load them after the built-in types, there is no need to use the <kbd>AppendPath</kbd> parameter, unless the situation really needs it, since <kbd>AppendPath</kbd> is the default. Why do the parameters matter? They determine the precedence of loading the types.</p>
<p>The XML file shown may <em>look like</em> having a large number of items. Use the indent guide in Visual Studio Code to guide you through reading the XML. The file, in reality, is very simple to read. And reading it will help you understand how the properties are defined.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/update-typedata?view=powershell-6">The Update-TypeData cmdlet</a> (Microsoft Docs)</li>
<li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_types.ps1xml?view=powershell-6">The Types.ps1xml file</a> (Microsoft Docs)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Removing custom type data</h1>
                </header>
            
            <article>
                
<p>Now that we know how to create and update type data, the next step for us is to learn to remove the type data. And removing the type data requires us to get the type data first. In this recipe, we learn the process to remove type data; whether it was updated using cmdlets or an XML.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The first step is to understand that a cmdlet can output one or more types of objects. For instance, in our case, <kbd>Get-ChildItem</kbd> output <kbd>System.IO.DirectoryInfo</kbd> as well as <kbd>System.IO.FileInfo</kbd>. Let us learn to work with these guys.</p>
<ol>
<li>Get the type of the object returned by the cmdlet.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem | Get-Member | Select-Object TypeName -Unique</pre>
<ol start="2">
<li>There are two types returned. We created the custom members in the second type. Assign this to a variable.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $TypeData = Get-ChildItem | Get-Member | Select-Object -ExpandProperty TypeName -Unique -Last 1</pre>
<ol start="3">
<li>Get the type data information. Expand its members to see if the custom members are shown.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-TypeData -TypeName $TypeData | Select-Object -ExpandProperty Members</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/cebc3c44-9586-4735-8b2e-b76d90b35c56.png" width="1812" height="604"/></div>
<ol start="4">
<li>Now, remove the type data.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Remove-TypeData -TypeName $TypeData</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The process is straightforward. If you query the help information for the <kbd>TypeName</kbd> parameter of <kbd>Remove-TypeData</kbd>, you would notice that it accepts the type name accepts input via the pipeline by property value as well as the property name. Recall the recipe, <em>Understanding pipeline-enabled parameters</em>, and look at the object returned by <kbd>Get-TypeData</kbd>, for more insight.</p>
<p>The <kbd>Remove-TypeData</kbd> cmdlet removes the type data from the current session. This removal is as ephemeral as the type addition is. Therefore, the <em>default</em> types and formats are not permanently removed by the cmdlet; the reason why you can run this within PowerShell, without administrator privileges. Also remember that the underlying XML <em>files</em> are not deleted either: custom or stock.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 5.8: Understanding pipeline-enabled parameters</li>
</ol>
<p>That concludes the chapter. It is time to take a break, so it helps you assimilate what you learnt. Later, experiment with different data types, create variables, see what type of objects they contain, and what members each object contains. We did not explicitly talk much about variables in this chapter other than environment variables, but we used variables almost in every recipe in the chapter. Ponder over (or better yet, practically try out) these questions:</p>
<ol>
<li>What can be assigned to a variable?</li>
<li>What does the variable contain; the entire object?</li>
<li>Can I refer to one single property of the object that a variable contains, if at all it contains the entire object?</li>
<li>Can I assign a certain member and not the entire object to a variable?</li>
<li>What if the member is a whole object in itself? (Hint: Use<span> </span><kbd>Get-Member</kbd> on the variable to find out.)</li>
<li>What happens when I use<span> </span><kbd>Select-Object</kbd><span> </span>with<span> </span><kbd>-ExpandProperty</kbd><span> </span>and assign the value to a variable? What type is the variable then?</li>
</ol>
<p>That would help you understand more about the variables, now that you have used them so much.</p>


            </article>

            
        </section>
    </div>



  </body></html>