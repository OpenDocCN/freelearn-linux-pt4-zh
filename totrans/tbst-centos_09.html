<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Troubleshooting Web Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Troubleshooting Web Services</h1></div></div></div><p>Troubleshooting is<a id="id351" class="indexterm"/> not always about disaster recovery or fixing broken systems. In fact, most troubleshooters tend to spend their time discovering ways to constantly improve a system or assisting other colleagues to get the best out of the<a id="id352" class="indexterm"/> technology at hand. Some would call this Dev/Ops, but regardless of how you look at it, the essential principles remain the same. You are a troubleshooter, and you are a crucial part of the support network; so with this in mind, we will take a break from "saving the day" and approach the subject of web services a little more proactively.</p><p>In this chapter, we will review the subject of investigating web services with the purpose of making improvements and to build on your knowledge as a troubleshooter.</p><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn how to audit the server with cURL</li><li class="listitem" style="list-style-type: disc">Discover ways to check your Akamai headers</li><li class="listitem" style="list-style-type: disc">Learn how to implement Varnish on Apache</li><li class="listitem" style="list-style-type: disc">Discover how to validate your Varnish installation with cURL</li><li class="listitem" style="list-style-type: disc">Learn how to use cURL in order to access an FTP directory</li><li class="listitem" style="list-style-type: disc">Learn how to monitor Apache by installing <code class="literal">mod_status</code></li></ul></div><div class="section" title="Auditing the server with cURL"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Auditing the server with cURL</h1></div></div></div><p>When a<a id="id353" class="indexterm"/> web server <a id="id354" class="indexterm"/>begins to exhibit problems, it can be for a vast number of reasons. However, when experiencing the <a id="id355" class="indexterm"/>issue as a troubleshooter, remember that you are not looking at the application itself (this is the realm of programmers and they will not thank you for joining in), but you will be looking at the state of the server.</p><p>Essentially, you can say that this is a process to scrutinize the server and its ability to serve web pages or web applications. So, let's begin by checking to confirm that cURL is installed.</p><p>To do this, you<a id="id356" class="indexterm"/> should use the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install curl</strong></span>
</pre></div><p>Having completed<a id="id357" class="indexterm"/> this step, you are now ready to run your first cURL command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://www.example.com</strong></span>
</pre></div><p>More specifically, you can choose a particular location in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://www.example.com/path/to/homepage.html</strong></span>
</pre></div><p>Alternatively, you can pass a string like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://www.example.com/path/to/homepage.html?query=string</strong></span>
</pre></div><p>Each of the <a id="id358" class="indexterm"/>preceding commands will show the entire HTTP content of the target URL; and yes, it can make the screen look a bit messy. Thus,  instead, you can invoke the tidy option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://www.example.com | tidy -i</strong></span>
</pre></div><p>However, if you wish to capture data and save the output to a file of your choice, then you can achieve this by using the command-line redirection method like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://www.example.com &gt; /path/to/folder/example.html</strong></span>
</pre></div><p>Alternatively, you can use the <code class="literal">-o</code> option in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -o /path/to/folder/example.txt http://www.example.com</strong></span>
</pre></div><p>Note that by invoking the <code class="literal">-o</code> option approach, the target file must be stated first. However, given that the preceding example shows that we are saving the output to a text file, you can quite happily change this to almost any type of file you want, like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -o /path/to/folder/example.html http://www.example.com</strong></span>
</pre></div><p>Now, working on the assumption that network connectivity is good, we have chosen cURL because we are now dealing with the specific problem of a web server that may be exhibiting difficulties in displaying web pages.</p><p>As we have already seen, by default, cURL will simply output the contents of the web page that was requested. However, by using an assortment of additional options (or arguments), you can extend its abilities and request far more details.</p><p>For example, if we use the <code class="literal">-w</code> option (write-out), you can obtain the status code of any web page by using the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -w "%{http_code}\n %{content_type}\n" http://www.example.com/path/to/page.html</strong></span>
</pre></div><p>Here, <code class="literal">\n</code> is used<a id="id359" class="indexterm"/> to output the result on <a id="id360" class="indexterm"/>a new line (you can also output a tab with <code class="literal">\t</code> or a carriage return with <code class="literal">\r</code>). You should now know the HTTP status code and HTTP content type <a id="id361" class="indexterm"/>for the web page in question.</p><p>For example, you can try this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -w "%{http_code}\n %{content_type}\n" https://www.packtpub.com/virtualization-and-cloud/troubleshooting-centos</strong></span>
</pre></div><p>The result of the preceding command is a bit too extensive to print in full, but at the end of the output, you should see the following (in which the target data is placed on separate lines as requested):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  &lt;/body&gt;</strong></span>
<span class="strong"><strong>&lt;/html&gt;</strong></span>
<span class="strong"><strong>200</strong></span>
<span class="strong"><strong> text/html; charset=utf-8</strong></span>
</pre></div><p>Moreover, you can even include a remote IP address like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -w "%{remote_ip}\n %{http_code}\n %{content_type}\n" http://www.example.com/path/to/page.html</strong></span>
</pre></div><p>The output of this command should show something like the following towards the end:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  &lt;/body&gt;</strong></span>
<span class="strong"><strong>&lt;/html&gt;</strong></span>
<span class="strong"><strong>23.205.169.129</strong></span>
<span class="strong"><strong> 200</strong></span>
<span class="strong"><strong> text/html;charset=UTF-8</strong></span>
</pre></div><p>You can obtain the size (in bytes) of a web page with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -w "%{size_download}\n" http://www.example.com/path/to/page.html</strong></span>
</pre></div><p>The result of this command will show <code class="literal">63175</code> bytes towards the end of the output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  &lt;/body&gt;</strong></span>
<span class="strong"><strong>&lt;/html&gt;</strong></span>
<span class="strong"><strong>63175</strong></span>
</pre></div><p>On the other hand, if you are dealing with a web server that uses both <code class="literal">301</code> and <code class="literal">302</code> redirection methods, we can use the <code class="literal">-L</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -Lw "%{remote_ip}\n %{http_code}\n %{content_type}\n" http://www.example.com/</strong></span>
</pre></div><p>Finally, if<a id="id362" class="indexterm"/> you <a id="id363" class="indexterm"/>would like to ensure your investigation of the server's web pages provides a complete list of all the headers <a id="id364" class="indexterm"/>cURL may encounter, you should invoke the <code class="literal">-v</code> option for verbosity in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -v http://www.example.com</strong></span>
</pre></div><p>For example, once again you can test Red Hat like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -v http://www.redhat.com</strong></span>
</pre></div><p>The result of this command will provide the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>* About to connect() to www.redhat.com port 80 (#0)</strong></span>
<span class="strong"><strong>*   Trying 104.66.92.228...</strong></span>
<span class="strong"><strong>* Connected to www.redhat.com (104.66.92.228) port 80 (#0)</strong></span>
<span class="strong"><strong>&gt; GET / HTTP/1.1</strong></span>
<span class="strong"><strong>&gt; User-Agent: curl/7.29.0</strong></span>
<span class="strong"><strong>&gt; Host: www.redhat.com</strong></span>
<span class="strong"><strong>&gt; Accept: */*</strong></span>
<span class="strong"><strong>&gt;</strong></span>
<span class="strong"><strong>&lt; HTTP/1.1 301 Moved Permanently</strong></span>
<span class="strong"><strong>&lt; Content-Type: text/html; charset=iso-8859-1</strong></span>
<span class="strong"><strong>&lt; Location: http://www.redhat.com/en</strong></span>
<span class="strong"><strong>&lt; Server: Apache</strong></span>
<span class="strong"><strong>&lt; Content-Length: 296</strong></span>
<span class="strong"><strong>&lt; Expires: Mon, 04 May 2015 14:53:10 GMT</strong></span>
<span class="strong"><strong>&lt; Cache-Control: max-age=0, no-cache</strong></span>
<span class="strong"><strong>&lt; Pragma: no-cache</strong></span>
<span class="strong"><strong>&lt; Date: Mon, 04 May 2015 14:53:10 GMT</strong></span>
<span class="strong"><strong>&lt; Connection: keep-alive</strong></span>
<span class="strong"><strong>&lt; Set-Cookie: AWSELB=014101F31CE28463C273156EDFEB4013EF4DC7B4B58B2D0587192FCB8DB58F8B0E7B8A652EC4DCB07BB3CC9D65387BA7D24617BF645CEBCF6476050FABBDF5D9227C0A5A30;PATH=/;MAX-AGE=30</strong></span>
<span class="strong"><strong>&lt;</strong></span>
<span class="strong"><strong>&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;</strong></span>
<span class="strong"><strong>&lt;html&gt;&lt;head&gt;</strong></span>
<span class="strong"><strong>&lt;title&gt;301 Moved Permanently&lt;/title&gt;</strong></span>
<span class="strong"><strong>&lt;/head&gt;&lt;body&gt;</strong></span>
<span class="strong"><strong>&lt;h1&gt;Moved Permanently&lt;/h1&gt;</strong></span>
<span class="strong"><strong>&lt;p&gt;The document has moved &lt;a href="http://www.redhat.com/en"&gt;here&lt;/a&gt;.&lt;/p&gt;</strong></span>
<span class="strong"><strong>&lt;hr&gt;</strong></span>
<span class="strong"><strong>&lt;address&gt;Apache Server at www.redhat.com Port 80&lt;/address&gt;</strong></span>
<span class="strong"><strong>&lt;/body&gt;&lt;/html&gt;</strong></span>
<span class="strong"><strong>* Connection #0 to host www.redhat.com left intact</strong></span>
</pre></div><p>While for <a id="id365" class="indexterm"/>those of you who would <a id="id366" class="indexterm"/>prefer to minimize the output to response headers <a id="id367" class="indexterm"/>only, instead of using the preceding command you should invoke the <code class="literal">-I</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -I http://www.example.com</strong></span>
</pre></div><p>For example, if you retried Red Hat like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -I http://www.redhat.com</strong></span>
</pre></div><p>The result of this command will provide the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>HTTP/1.1 301 Moved Permanently</strong></span>
<span class="strong"><strong>Content-Type: text/html; charset=iso-8859-1</strong></span>
<span class="strong"><strong>Location: http://www.redhat.com/en</strong></span>
<span class="strong"><strong>Server: Apache</strong></span>
<span class="strong"><strong>Content-Length: 0</strong></span>
<span class="strong"><strong>Expires: Mon, 04 May 2015 14:55:54 GMT</strong></span>
<span class="strong"><strong>Cache-Control: max-age=0, no-cache</strong></span>
<span class="strong"><strong>Pragma: no-cache</strong></span>
<span class="strong"><strong>Date: Mon, 04 May 2015 14:55:54 GMT</strong></span>
<span class="strong"><strong>Connection: keep-alive</strong></span>
<span class="strong"><strong>Set-Cookie: AWSELB=014101F31CE28463C273156EDFEB4013EF4DC7B4B53E1B0B83C0D272B9D220605DDE604A12C4DCB07BB3CC9D65387BA7D24617BF642030376EDB73D2D8C226E62350AE4B75;PATH=/;MAX-AGE=30</strong></span>
</pre></div><p>At this stage, there is always a lot more that can be said about cURL. In fact, you could write an entire book on the subject; however, before we stray too far from our main topic, you will be happy to know that you can discover more about cURL by reading the manual:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ man curl</strong></span>
</pre></div></div></div>
<div class="section" title="Debugging Akamai headers with cURL"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Debugging Akamai headers with cURL</h1></div></div></div><p>CDNs <a id="id368" class="indexterm"/>are becoming commonplace, and the most popular of them all is Akamai. However, where a CDN can <a id="id369" class="indexterm"/>deliver benefits, they can also provide a stumbling block when you are troubleshooting a web service, application, or even a simple <a id="id370" class="indexterm"/>home page. Look at it this way, with a CDN of any type, you are generally working with cached objects and you want to validate the traffic behavior. So, with this in mind, we will now discuss how <code class="literal">cURL</code> can come to the rescue:</p><p>To begin with, we must issue a properly formed Pragma header and, to do this, you can use the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IXGET http://www.example.com/path/to/home.html</strong></span>
</pre></div><p>However, if you wish to include the debug information, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IXGET -H "Pragma: akamai-x-cache-on, akamai-x-cache-remote-on, akamai-x-check-cacheable, akamai-x-get-cache-key, akamai-x-get-extracted-values, akamai-x-get-nonces, akamai-x-get-ssl-client-session-id, akamai-x-get-true-cache-key, akamai-x-serial-no" http://www.example.com/path/to/home.html</strong></span>
</pre></div><p>For example, as Red Hat are known users of Akamai, if you try:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IXGET -H "Pragma: akamai-x-cache-on, akamai-x-cache-remote-on, akamai-x-check-cacheable, akamai-x-get-cache-key, akamai-x-get-extracted-values, akamai-x-get-nonces, akamai-x-get-ssl-client-session-id, akamai-x-get-true-cache-key, akamai-x-serial-no" http://www.redhat.com/en</strong></span>
</pre></div><p>Then, unless there have been any significant changes since the publication of this book (and web pages always do change over time), the output will look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Content-Language: en</strong></span>
<span class="strong"><strong>Content-Type: text/html; charset=utf-8</strong></span>
<span class="strong"><strong>ETag: "1430747458-1"</strong></span>
<span class="strong"><strong>Last-Modified: Mon, 04 May 2015 13:50:58 GMT</strong></span>
<span class="strong"><strong>Link: &lt;http://www.redhat.com/en&gt;; rel="canonical"</strong></span>
<span class="strong"><strong>Server: Apache</strong></span>
<span class="strong"><strong>X-Drupal-Cache: HIT</strong></span>
<span class="strong"><strong>X-Powered-By: PHP/5.3.3</strong></span>
<span class="strong"><strong>X-RedHat-Debug: 1</strong></span>
<span class="strong"><strong>X-Check-Cacheable: NO</strong></span>
<span class="strong"><strong>Expires: Mon, 04 May 2015 13:51:17 GMT</strong></span>
<span class="strong"><strong>Cache-Control: max-age=0, no-cache</strong></span>
<span class="strong"><strong>Pragma: no-cache</strong></span>
<span class="strong"><strong>Date: Mon, 04 May 2015 13:51:17 GMT</strong></span>
<span class="strong"><strong>Transfer-Encoding:  chunked</strong></span>
<span class="strong"><strong>X-Cache: TCP_MISS from a2-20-133-122.deploy.akamaitechnologies.com (AkamaiGHost/7.2.0-15182023) (-)</strong></span>
<span class="strong"><strong>X-Cache-Key: /L/1890/356403/3d/www.rollover.redhat.com.akadns.net/en cid=__</strong></span>
<span class="strong"><strong>X-True-Cache-Key: /L/www.rollover.redhat.com.akadns.net/en cid=__</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=CRS_VERSION; value=2.2.6</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=DC_FORWARD_IP; value=54.187.212.127; full_location_id=X-DC-Origin-IP</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=HEADER_NAMES; value=User-Agent%3aHost%3aAccept%3aPragma; full_location_id=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=INITORIGINIP; value=54.187.212.127</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=NL_2580_BLACKLIST_NAME; value=Black List</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=NL_6042_ORACLE_NAME; value=Oracle bot-block (per Keith Watkins by Sri Sankaran)</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=NSCPCODE; value=298900</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=OVERRIDE_HTTPS_IE_CACHE_BUST; value=all</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=PARENT_SETTING; value=TD</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=SITESHIELDMAP; value=s187.akamaiedge.net</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=SQLI_SELECT_STATEMENT_COUNT; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=SRTOPATH; value=/s/global.css</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=SS4PMAP; value=www.redhat.com</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CREATE_ASSERTION_EXPIRE_TIME; value=1430747537</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_ALLOWED_HTTP_VERSIONS; value=HTTP/0.9 HTTP/1.0 HTTP/1.1</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_ALLOWED_METHODS; value=GET HEAD POST OPTIONS</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_ARG_LENGTH; value=64000</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_ARG_NAME_LENGTH; value=256</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_CMD_INJECTION_ANOMALY_RULE_TUPLE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_CMD_INJECTION_ANOMALY_SCORE; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_CMD_INJECTION_ANOMALY_SCR; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_CRITICAL_ANOMALY_SCORE; value=5</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_DEFAULT_ACTION; value=alert</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_ERROR_ANOMALY_SCORE; value=4</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_INBOUND_ANOMALY_RULE_SCR; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_INBOUND_ANOMALY_RULE_TUPLE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_INBOUND_ANOMALY_SCORE; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_INBOUND_MSG; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_INFO_ANOMALY_SCORE; value=1</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_INVALID_HTTP_RULE_TUPLE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_INVALID_HTTP_SCORE; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_INVALID_HTTP_SCR; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_MAX_NUM_ARGS; value=255</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_NOTICE_ANOMALY_SCORE; value=2</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_OUTBOUND_ANOMALY_RULE_SCR; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_OUTBOUND_ANOMALY_RULE_TUPLE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_OUTBOUND_ANOMALY_SCORE; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_PHP_INJECTION_RULE_SCR; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_PHP_INJECTION_RULE_TUPLE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_PHP_INJECTION_SCORE; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_RESTRICTED_EXTENSIONS; value=asa asax ascx backup bak bat cdx cer cfg cmd com config conf cs csproj csr dat db dbf dll dos htr htw ida idc idq inc ini key licx lnk log mdb old pass pdb pol printer pwd resources resx sql sys vb vbs vbproj vsdisco webinfo xsd xsx</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_RESTRICTED_HEADERS; value=Proxy-Connection Lock-Token Content-Range Translate Via If</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_RFI_ANOMALY_RULE_SCR; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_RFI_ANOMALY_RULE_TUPLE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_RFI_ANOMALY_SCORE; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_RISK_GROUPS; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_RISK_SCRS; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_RISK_TUPLES; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_SQL_INJECTION_RULE_TUPLE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_SQL_INJECTION_SCORE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_SQL_INJECTION_SCR; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_TOTAL_ANOMALY_SCORE; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_TOTAL_ARG_LENGTH; value=64000</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_TROJAN_RULE_SCR; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_TROJAN_RULE_TUPLE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_TROJAN_SCORE; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_WARNING_ANOMALY_SCORE; value=3</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_XSS_RULE_SCR; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_XSS_RULE_TUPLE; value=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_CRS_XSS_SCORE; value=0</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_DATA_HEADER_SIGN_VAL; value=HnWuQRcXIUfMGG3LF/9PllRcUxUkocv8aFiFmuExQZE=</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_DATA_HEADER_VAL; value=/en 1430747537</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_HA_STATUS; value=checking</strong></span>
<span class="strong"><strong>X-Akamai-Session-Info: name=WAF_MYSQLI_COUNT; value=0</strong></span>
<span class="strong"><strong>X-Serial: 1890</strong></span>
<span class="strong"><strong>Connection: keep-alive</strong></span>
<span class="strong"><strong>Connection: Transfer-Encoding</strong></span>
<span class="strong"><strong>Set-Cookie: WL_DCID=origin-www-c; expires=Mon, 04-May-2015 21:51:17 GMT; path=/</strong></span>
<span class="strong"><strong>Set-Cookie: AWSELB=7DE7FB19045D425DE69229FBB7F229663FD24433135E354B67BC8404E265E1F485365E31B3F24C3F30EB76C3348446159423E486323BDC9105B0C92244E19C46091861E2C5;PATH=/;MAX-AGE=30</strong></span>
<span class="strong"><strong>Set-Cookie: AWSELB=014101F31CE28463C273156EDFEB4013EF4DC7B4B52244855012161AA58C6EBAB965CAFA77C4DCB07BB3CC9D65387BA7D24617BF645CEBCF6476050FABBDF5D9227C0A5A30;PATH=/;MAX-AGE=30</strong></span>
<span class="strong"><strong>X-Cache-Remote: TCP_MISS from a195-10-11-245.deploy.akamaitechnologies.com (AkamaiGHost/7.2.0-15182023) (-)</strong></span>
</pre></div><p>Quite a long <a id="id371" class="indexterm"/>example <a id="id372" class="indexterm"/>I agree, but Akamai headers are <a id="id373" class="indexterm"/>quite extensive. Of course, this process is not restricted to web pages per se, as it can be used to target any object of your choice.</p><p>For example, if you want to target a particular image, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IXGET -H "Pragma: akamai-x-cache-on, akamai-x-cache-remote-on, akamai-x-check-cacheable, akamai-x-get-cache-key, akamai-x-get-extracted-values, akamai-x-get-nonces, akamai-x-get-ssl-client-session-id, akamai-x-get-true-cache-key, akamai-x-serial-no" http://www.example.com/path/to/image.jpg</strong></span>
</pre></div><p>Alternatively, you can target a CSS file like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -IXGET -H "Pragma: akamai-x-cache-on, akamai-x-cache-remote-on, akamai-x-check-cacheable, akamai-x-get-cache-key, akamai-x-get-extracted-values, akamai-x-get-nonces, akamai-x-get-ssl-client-session-id, akamai-x-get-true-cache-key, akamai-x-serial-no" http://www.example.com/path/to/style.css</strong></span>
</pre></div><p>At this point, I am assuming that you know most of the HTTP response codes (if not, you can find a reference link at the end of this chapter), but before we close this subject, let's take a brief look <a id="id374" class="indexterm"/>at some of the less obvious headers you will encounter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">X-Check-Cacheable</code>: This value <a id="id375" class="indexterm"/>will tell us whether the object in question is cacheable by Akamai.</li><li class="listitem" style="list-style-type: disc"><code class="literal">X-Cache-Key</code>: Ignoring <a id="id376" class="indexterm"/>the first two values and starting from the third value in the<a id="id377" class="indexterm"/> resulting string, you will see the CP code and the relevant TTL, although the <a id="id378" class="indexterm"/>TTL may differ slightly when set at the application level through the Edge-Control header.</li><li class="listitem" style="list-style-type: disc"><code class="literal">X-Cache</code>: This value <a id="id379" class="indexterm"/>will tell us what the Akamai Edge server returned as output. However, this value will also indicate one of the following instances:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_HIT</code>: This <a id="id380" class="indexterm"/>value implies that the object was fresh in cache and the object was fetched from the disk cache.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_MISS</code>: This <a id="id381" class="indexterm"/>value implies that the object was not in cache; the server fetched the object from the origin.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_REFRESH_HIT</code>: This<a id="id382" class="indexterm"/> value implies that the object was stale in cache and we successfully refreshed the origin on an If-Modified-Since request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_REFRESH_MISS</code>: This <a id="id383" class="indexterm"/>value implies that the object was stale in cache, and refresh obtained a new object from the origin in response to our If-Modified-Since request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_REFRESH_FAIL_HIT</code>: This <a id="id384" class="indexterm"/>value implies that the object was stale in cache, and we failed on refresh (couldn't reach the origin), so we served the stale object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_IMS_HIT</code>: This <a id="id385" class="indexterm"/>value implies that an If-Modified-Since request from the client and object was fresh in cache and served.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_NEGATIVE_HIT</code>: This<a id="id386" class="indexterm"/> value implies that the object previously returned a "not found" message (or any other negatively cacheable response) and that the cached response was a hit for this new request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_MEM_HIT</code>: This <a id="id387" class="indexterm"/>value implies that the object was on disk and in the memory cache. The server served it without hitting the disk.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_DENIED</code>: This <a id="id388" class="indexterm"/>value implies that you have been denied access to the client for whatever reason.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TCP_COOKIE_DENY</code>: This<a id="id389" class="indexterm"/> value implies that you have been denied access on cookie authentication (if the centralized or decentralized authorization feature is being used in configuration).</li></ul></div></li></ul></div><p>So, as you can<a id="id390" class="indexterm"/> see, debugging Akamai headers using cURL is very easy to do. Yes, there are browser plugins <a id="id391" class="indexterm"/>that<a id="id392" class="indexterm"/> will do the same job, but knowing how to do it with cURL is far more fun.</p></div>
<div class="section" title="Adding Varnish to Apache"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Adding Varnish to Apache</h1></div></div></div><p>Varnish <a id="id393" class="indexterm"/>is a high-performance HTTP <a id="id394" class="indexterm"/>accelerator that not only assists in reducing the overall server load, but also serves to improve website response times. For this reason, it has <a id="id395" class="indexterm"/>become very popular; as a consequence of this, we will look at the process of setting up Varnish in conjunction with the Apache web server.</p><p>Before we <a id="id396" class="indexterm"/>begin, it will be assumed that Apache is installed. Moreover, you should be aware that completing the next steps requires access to the EPEL repository. Please refer to <a class="link" href="ch04.html" title="Chapter 4. Troubleshooting Package Management and System Upgrades">Chapter 4</a>, <span class="emphasis"><em>Troubleshooting Package Management and System Upgrades</em></span>, for instructions on how to download and install the EPEL repository on CentOS 7.</p><p>So when you are ready, let's begin by installing Varnish:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install varnish</strong></span>
</pre></div><p>Following a successful installation of Varnish, we will need to enable the service at boot. This can be achieved by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl enable varnish</strong></span>
</pre></div><p>We will then need to activate the service like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl start varnish</strong></span>
</pre></div><p>So, having completed the basic installation, you can now check the status of Varnish by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl status varnish</strong></span>
</pre></div><p>Then you check what version you are running by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># varnishd -V</strong></span>
</pre></div><p>At this stage, we <a id="id397" class="indexterm"/>need to complete the basic configuration of this service and enable it to work in conjunction with Apache. To do this, we will begin by opening the main Apache configuration with your favorite text editor like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/httpd/conf/httpd.conf</strong></span>
</pre></div><p>Now, scroll down to find the following line:</p><div class="informalexample"><pre class="programlisting">Listen 80</pre></div><p>Replace it with the following line:</p><div class="informalexample"><pre class="programlisting">Listen 127.0.0.1:8080</pre></div><p>If the web server is <a id="id398" class="indexterm"/>running one or more virtual hosts, you will need to make the following adjustment in order to reflect the new port that Apache is listening on:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost *:8080&gt;</pre></div><p>Now save <a id="id399" class="indexterm"/>the file and run the following command to check your syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># httpd -t</strong></span>
</pre></div><p>The output should read:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Syntax OK</strong></span>
</pre></div><p>Now, having completed these steps, we will make our first configuration change to the original Varnish installation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/varnish/varnish.params</strong></span>
</pre></div><p>Scroll down and look for the following line:</p><div class="informalexample"><pre class="programlisting">VARNISH_LISTEN_PORT=6081</pre></div><p>Replace it with the following:</p><div class="informalexample"><pre class="programlisting">VARNISH_LISTEN_PORT=80</pre></div><p>Now scroll down and locate the following line:</p><div class="informalexample"><pre class="programlisting">VARNISH_STORAGE=</pre></div><p>This is where Varnish gets interesting, and where you, as the troubleshooter, get to determine the most suitable method for optimizing web performance. Currently, you will notice that Varnish is configured to use the server's hard disk to cache files, and, in this instance, you have two options.</p><p>In a situation where a large cache is expected, where RAM is limited, or you intend to build a dedicated <a id="id400" class="indexterm"/>Varnish store to cache files, by making a simple adjustment to reflect the default settings you can specify the size of your cache.</p><p>For example, if <a id="id401" class="indexterm"/>you want to create a disk cache of 20 GB, you can use the following line:</p><div class="informalexample"><pre class="programlisting">VARNISH_STORAGE="file,/var/lib/varnish/varnish_storage.bin,20G"</pre></div><p>However, if you want the ultimate Varnish experience that uses a RAM-caching approach, this can be achieved by customizing the following line to reflect the system's needs:</p><div class="informalexample"><pre class="programlisting">VARNISH_STORAGE="malloc,1G"</pre></div><p>Now let's take this one stage further.</p><p>For example, if <a id="id402" class="indexterm"/>you want the RAM to cache up to 4 GB of data, you can use:</p><div class="informalexample"><pre class="programlisting">VARNISH_STORAGE="malloc,4G"</pre></div><p>Alternatively, if you want to improve the performance of a not-so-rich RAM-based environment, you can change this value to 512 MB like this:</p><div class="informalexample"><pre class="programlisting">VARNISH_STORAGE="malloc,512m"</pre></div><p>You can now save and close this file before opening the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/varnish/default.vcl</strong></span>
</pre></div><p>This file is the overall configuration file for Varnish. I will not go into the exact details at this point, as there are many Varnish-based books that cover this topic in an exhaustive manner. However, for the purpose of troubleshooting, you will need to make a few basic changes in order to get things up-and-running. To do this, simply ensure that the following section reflects the criteria of the system in question:</p><div class="informalexample"><pre class="programlisting">vcl 4.0;
# Default backend definition. Set this to point to your content server.
backend default {
    .host = "127.0.0.1";
    .port = "8080";
}</pre></div><p>Having done this, you should now restart Apache in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl restart httpd.service</strong></span>
</pre></div><p>Follow this by restarting Varnish like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl restart varnish.service</strong></span>
</pre></div><p>Well done! The <a id="id403" class="indexterm"/>installation of Varnish is now complete; <a id="id404" class="indexterm"/>you can continue<a id="id405" class="indexterm"/> to visit your Apache-based websites in the usual manner, but with the added advantage of experiencing improved speed and performance.</p></div>
<div class="section" title="Testing Varnish with cURL"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Testing Varnish with cURL</h1></div></div></div><p>If the web<a id="id406" class="indexterm"/> server relies on <a id="id407" class="indexterm"/>Varnish, then<a id="id408" class="indexterm"/> it is particularly important to ensure that your web pages are being cached and that they are served in a timely manner.</p><p>To confirm this, you can begin with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># curl -I http://www.example.com/index.html</strong></span>
</pre></div><p>Having used the <code class="literal">-I</code> option to display the headers only, if Varnish is installed, you should see something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Date: Fri, 06 Mar 2015 00:59:24 GMT</strong></span>
<span class="strong"><strong>Server: Apache/2.4.6 (CentOS) PHP/5.5.22</strong></span>
<span class="strong"><strong>X-Powered-By: PHP/5.5.22</strong></span>
<span class="strong"><strong>Content-Type: text/html; charset=UTF-8</strong></span>
<span class="strong"><strong>X-Varnish: 5 3</strong></span>
<span class="strong"><strong>Age: 16</strong></span>
<span class="strong"><strong>Via: 1.1 varnish-v4</strong></span>
<span class="strong"><strong>Content-Length: 97422</strong></span>
<span class="strong"><strong>Connection: keep-alive</strong></span>
</pre></div><p>In the preceding example, the most important lines are the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>X-Varnish: 5 3</strong></span>
<span class="strong"><strong>Age: 16</strong></span>
</pre></div><p>Now, let's run through a quick explanation of these values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">X-Varnish: XXXXXXXX XXXXXXXX</code>: The <code class="literal">X-Varnish</code> header not only contains an ID of the<a id="id409" class="indexterm"/> current request, but also maintains the ID of the request that populated the cache. If there is only one number, you should be aware that the cache was populated with the current request and can be considered to be what is termed a cache miss.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Age: XXXX</code>: This value<a id="id410" class="indexterm"/> indicates how long the content has been stored in cache. If a zero (0) is shown, then it implies that the page in question was not cached at all.</li></ul></div><p>Of course, the <a id="id411" class="indexterm"/>exact values shown may be different, but having <a id="id412" class="indexterm"/>seen this example, you are now able to not only confirm and verify the functionality of Varnish on your server, but also keep a constant eye on the <code class="literal">Age</code> value given (you will know how long (in seconds) a page will exist in the cache).</p></div>
<div class="section" title="Using cURL to access an FTP directory"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Using cURL to access an FTP directory</h1></div></div></div><p>With practice, everyone<a id="id413" class="indexterm"/> can use<a id="id414" class="indexterm"/> an FTP client, but a situation where <a id="id415" class="indexterm"/>you need to script certain events is where you will call on cURL to do all the hard work.</p><p>So, by starting at the most basic level, the easiest way to access an FTP directory with an existing username and password will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl ftp://exampleftpsite.com -u &lt;username&gt;</strong></span>
</pre></div><p>When requested, simply enter your password at the prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl ftp://exampleftpsite.com  -u &lt;username&gt;</strong></span>
<span class="strong"><strong>Enter host password for user '&lt;username&gt;':</strong></span>
</pre></div><p>Now, if you want to search an FTP directory for a particular list of files, you can use the <code class="literal">-s</code> silent option and <code class="literal">grep</code> in combination like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl ftp://exampleftpsite.com -u &lt;username&gt; -s | grep &lt;keyword&gt;</strong></span>
</pre></div><p>You can complete your search and upload a file with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -T filename.zip ftp://exampleftpsite.com -u &lt;username&gt;</strong></span>
</pre></div><p>Or you can make a direct download with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl ftp://exampleftpsite.com -u &lt;username&gt; -o filename.zip</strong></span>
</pre></div><p>Again, you should enter the correct password when prompted but, having found the relevant file, you can use the following syntax to discover your current location:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pwd</strong></span>
</pre></div><p>Finally, to bring <a id="id416" class="indexterm"/>this section to an end, you can delete a file in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl ftp://exampleftpsite.com -X 'DELE filename.zip' -u &lt;username&gt;</strong></span>
</pre></div><p>Remember <a id="id417" class="indexterm"/>that <a id="id418" class="indexterm"/>you need to be extra careful when deleting a file as there will be no prompts. The action to delete with cURL is automatic.</p></div>
<div class="section" title="Enabling mod_status in Apache"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Enabling mod_status in Apache</h1></div></div></div><p>The <a id="id419" class="indexterm"/>
<code class="literal">mod_status</code> is<a id="id420" class="indexterm"/> an Apache module that assists in the practice of <a id="id421" class="indexterm"/>monitoring web server load and current <code class="literal">httpd</code> connections. It comes complete with an HTML interface, and it is accessible using any browser.</p><p>To use <code class="literal">mod_status</code>, we <a id="id422" class="indexterm"/>need to make a few basic configuration changes to the <code class="literal">VirtualHosts</code> file, so let's start at the beginning by creating a rudimentary virtual host with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano  /etc/httpd/conf.d/vhost.conf</strong></span>
</pre></div><p>Add the following lines:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost *:80&gt;
   DocumentRoot /var/www/html
   ServerName servername.domain.com
&lt;/VirtualHost&gt;</pre></div><p>Remember: if you are using Varnish, ensure that it uses the correct port:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost *:8080&gt;
   DocumentRoot /var/www/html
   ServerName servername.domain.com
&lt;/VirtualHost&gt;</pre></div><p>Having done this, you can now add the following lines between the appropriate <code class="literal">&lt;VirtualHost&gt;&lt;/VirtualHost&gt;</code> directives in order to enable <code class="literal">mod_status</code>:</p><div class="informalexample"><pre class="programlisting">&lt;Location /server-status&gt;
  SetHandler server-status
  Order allow,deny
  Allow from all
&lt;/Location&gt;</pre></div><p>The end result should look something like this:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost *:8080&gt;
   DocumentRoot /var/www/html
   ServerName servername.domain.com

  &lt;Location /server-status&gt;
    SetHandler server-status
    Order allow,deny
    Allow from all
  &lt;/Location&gt;
&lt;/VirtualHost&gt;</pre></div><p>You <a id="id423" class="indexterm"/>can <a id="id424" class="indexterm"/>see the line that reads <code class="literal">Allow from all</code>. For the purpose of the preceding example, this is fine, but for security reasons, you should lock the connection access to a specific IP address.</p><p>For this reason, a better option will be to use the following syntax:</p><div class="informalexample"><pre class="programlisting">&lt;Location /server-status&gt;
  SetHandler server-status
  Order deny, allow
  Deny from all
  Allow from localhost
&lt;/Location&gt;</pre></div><p>Of course, you <a id="id425" class="indexterm"/>should customize the preceding example code to suit the needs of your system; when you are finished, simply save and close the file before restarting Apache:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl restart httpd</strong></span>
</pre></div><p>Now, open a browser and visit the chosen virtual host using the following format:</p><p><code class="literal">http://XXX.XXX.XXX.XXX/server-status</code></p><p>This will give you full access to the static <code class="literal">server-status</code> page. However, if you append the URL with the <code class="literal">refresh</code> option as follows, the page should refresh every 5 seconds:</p><p><code class="literal">http://XXX.XXX.XXX.XXX/server-status/?refresh=5</code></p><p>The resulting page will then show you an array of information that includes server uptime, server load, the <a id="id426" class="indexterm"/>total number of connections, CPU usage, process IDs, the total number of requests, and which <a id="id427" class="indexterm"/>requests are currently being processed. All of this should prove most useful<a id="id428" class="indexterm"/> when you are attempting to highlight any issues related to a specific website on the Apache web server.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Summary</h1></div></div></div><p>The purpose of this chapter was to take a very different view on troubleshooting web services. From auditing the server with cURL to making performance enhancements with Varnish, we have not only considered the needs of a systems administrator, but we have also discovered the world of CDNs and Dev/Ops with the intention of showing just how versatile a troubleshooter can be and just how important your skills will become.</p><p>In the next chapter, we will discuss some techniques used when troubleshooting DNS-based services.</p></div>
<div class="section" title="References"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec89"/>References</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Wikipedia home page for Curl: <a class="ulink" href="http://en.wikipedia.org/wiki/CURL">http://en.wikipedia.org/wiki/CURL</a></li><li class="listitem" style="list-style-type: disc">The Curl home page: <a class="ulink" href="http://curl.haxx.se">http://curl.haxx.se</a></li><li class="listitem" style="list-style-type: disc">The Wikipedia home page for HTTP status codes: <a class="ulink" href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">http://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a></li><li class="listitem" style="list-style-type: disc">HTTPie, a curl alternative: <a class="ulink" href="https://github.com/jakubroztocil/httpie">https://github.com/jakubroztocil/httpie</a></li><li class="listitem" style="list-style-type: disc">The Varnish home page: <a class="ulink" href="https://www.varnish-cache.org">https://www.varnish-cache.org</a></li><li class="listitem" style="list-style-type: disc">Varnish Administrator Documentation: <a class="ulink" href="https://www.varnish-cache.org/docs/trunk/index.html">https://www.varnish-cache.org/docs/trunk/index.html</a></li></ul></div></div></body></html>