<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Deploying the Apache HTTPD Server"><div class="titlepage" id="aid-2ACBS2"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Deploying the Apache HTTPD Server</h1></div></div></div><p>The <span class="strong"><strong>Hypertext Transfer Protocol</strong></span> (<span class="strong"><strong>HTTP</strong></span>) server will be commonly referred to as a web server. As the <a id="id336" class="indexterm"/>name suggests, this is a network service that provides content to a client, typically a web browser, on the Internet. This typically means delivery of web pages, but any other documents can be served, such as images, sound, video, and even ISO files for RHEL.</p><p>The web server packaged on RHEL 7 is the Apache <code class="literal">httpd</code> service. This is the most common web server found on the Internet and developed by the Apache Software Foundation. RHEL has updated <code class="literal">httpd</code> to version 2.4, replacing the 2.2 release that has been in use in previous editions of RHEL.</p><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Configuring the <code class="literal">httpd</code> service</li><li class="listitem">Controlling the <code class="literal">httpd</code> service</li><li class="listitem">Adding server modules</li><li class="listitem">Using virtual hosts</li></ul></div><div class="section" title="Configuring the httpd service"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec72"/>Configuring the httpd service</h1></div></div></div><p>The Apache <code class="literal">httpd</code> web server <a id="id337" class="indexterm"/>can serve pages to clients on the Internet or locally on our internal intranet, so don't feel that you will have to necessarily ramp up security if you are deploying a web server. Of course, if the website is to be facing the Internet, additional security and isolation of this service may be required. However, we are working in a lab environment and will focus more on the configuration of the web server.</p><div class="section" title="Installing Apache 2.4"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec50"/>Installing Apache 2.4</h2></div></div></div><p>The required <a id="id338" class="indexterm"/>packages are unlikely to be installed by default, so we will need to at least add the <code class="literal">httpd</code> package. Additionally, you may like to add the <a id="id339" class="indexterm"/>documentation. Consider only adding the documentation to a development server; I would not recommend adding it to a production server. We will add both packages to a server as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo yum install httpd httpd-manual</strong></span>
</pre></div><p>Even at this stage, with so little effort added, we can start our service and browser to the web server using the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl start httpd</strong></span>
<span class="strong"><strong>$ sudo systemct enable httpd</strong></span>
</pre></div><p>If we have a graphic environment, we can use Firefox from our local system to browse the localhost. We will be rewarded with a welcome page similar to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00299.jpeg" alt="Installing Apache 2.4"/></div><p style="clear:both; height: 1em;"> </p><p>Although I would like to think that my work here is done; somehow, I feel that you may just want a little more guidance.</p></div><div class="section" title="The configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec51"/>The configuration</h2></div></div></div><p>The configuration <a id="id340" class="indexterm"/>base for the <code class="literal">httpd</code> service on RHEL 7 is the <code class="literal">/etc/httpd</code> directory. With the <code class="literal">tree</code> command, we can effectively illustrate the configuration hierarchy or service. The single configuration required here is <code class="literal">httpd.conf</code>, but Red Hat is taking a much more modular approach and now includes many sub-configurations to the main file. The following screenshot from the output of the tree shows all files in place after the default installation:</p><div class="mediaobject"><img src="../Images/image00300.jpeg" alt="The configuration"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="tip30"/>Tip</h3><p>If the preceding tree is not installed, it can be installed using <code class="literal">sudo yum install tree</code>.</p></div><p>The <code class="literal">tree</code> command has <a id="id341" class="indexterm"/>been run from the <code class="literal">/etc/httpd</code> directory. We can see the <code class="literal">/etc/httpd/conf/httpd.conf</code> file, which is the main configuration file. This includes other files from <code class="literal">/etc/httpd/conf.d</code> and <code class="literal">/etc/httpd/conf.modules.d</code>. Also, there are three symbolically linked directories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">logs</code></li><li class="listitem"><code class="literal">modules</code></li><li class="listitem"><code class="literal">run</code></li></ul></div><p>The content of a page that we see when we browse through a site comes from the configuration in <code class="literal">/etc/httpd/conf.d/welcome.conf</code>. When no actual website content exists, the default welcome page is generated.</p><p>With the inclusion of the <code class="literal">userdir.conf</code> and <code class="literal">autoindex.conf</code> files, the separate modules configuration is very different from the <code class="literal">httpd</code> configuration on RHEL 6, where these were all part of the main <code class="literal">httpd.conf</code> file.</p><p>We have already mentioned that the configuration root of the web server is the <code class="literal">/etc/httpd</code> directory. The configuration for this is in the <code class="literal">/etc/httpd/conf/httpd.conf</code> file. Some of the key directives from this file are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">ServerRoot</code>: <code class="literal">/etc/httpd</code></li><li class="listitem"><code class="literal">DocumentRoot</code>: <code class="literal">/var/www/html</code></li><li class="listitem"><code class="literal">DirectoryIndex</code>: <code class="literal">index.html</code></li></ul></div><p>The <code class="literal">ServerRoot</code> directive, as we have seen is where we can locate configurations, logs, and modules for the web server. The <code class="literal">DocumentRoot</code> directive represents where the web content can be found, whereas the <code class="literal">DirectoryIndex</code> HTML page is the default page or pages to search for. Using <code class="literal">echo</code>, we can simply create our own content as follows. We run the following command as root and create a very basic welcome page:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># echo '&lt;h1&gt;Welcome to our site&lt;/h1&gt;' &gt; /var/www/html/index.html</strong></span>
</pre></div><p>The use of single quotes <a id="id342" class="indexterm"/>allow tags to be passed as literals.</p><p>We can view a page directly; as we have not changed any configuration, there is no need to reload a service. The page should now appear similar to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00301.jpeg" alt="The configuration"/></div><p style="clear:both; height: 1em;"> </p><p>We can access this site locally or remotely using the hostname or IP address. We can access the same page using <code class="literal">http://192.168.0.69</code>, (or which ever IP Address is assigned to your host interface). To access a page remotely, the firewall will need to include <code class="literal">http</code> and <code class="literal">https</code> in its <code class="literal">firewalld</code> rules:</p><p>In the following code, we open the HTTP port of port <code class="literal">80</code> and the HTTPS port of <code class="literal">443</code>. These are protocols and default ports used to access web servers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo firewall-cmd --add-service=http --permanent</strong></span>
<span class="strong"><strong>$ sudo firewall-cmd --add-service=https --permanent</strong></span>
<span class="strong"><strong>$ sudo firewall-cmd --reload</strong></span>
</pre></div><p>As an administrator of the web server, we are not necessarily going to be the developer on the web content, but we <a id="id343" class="indexterm"/>can show that the web server is working with the configuration.</p></div><div class="section" title="Configuring the DocumentRoot directory"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec52"/>Configuring the DocumentRoot directory</h2></div></div></div><p>The <code class="literal">DocumentRoot</code> <a id="id344" class="indexterm"/>directory should be readable by the <a id="id345" class="indexterm"/>
<code class="literal">httpd</code> service. The account used by a service is listed in the <code class="literal">httpd.conf</code>. Default accounts that are used with corresponding directives are shown in the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>User apache</strong></span>
<span class="strong"><strong>Group apache</strong></span>
</pre></div><p>In an ideal world, the permissions on the <code class="literal">/var/www/html</code> directory would be <code class="literal">2750</code> in an octal notation or <code class="literal">rwx r_s _</code> in a symbolic notation. Setting up a group special bit on a directory ensures that all new content in a directory will be owned by the group owner of the directory. In this way, we do not have to grant any permission to others; as long as the directory is owned by the <code class="literal">apache</code> group, files will be accessible to that group.</p><p>Firstly, we will set up the group ownership for this directory. We will use the <code class="literal">-R</code> option as we have already created the <code class="literal">index</code> page after this directory, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo chgrp -R apache /var/www/html </strong></span>
</pre></div><p>Now, we will set up the group special bit on the directory; this ensures all new files and directories created in this structure will be owned by the <code class="literal">apache</code> group:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo chmod g+s /var/www/html/</strong></span>
</pre></div><p>Finally, we will remove permissions granted to others, helping secure the content as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo chmod -R o= /var/www/html/</strong></span>
</pre></div><p>Although this is not entirely necessary, configuring this at the outset can save work later when perhaps better security is required. With the <code class="literal">httpd.conf</code>, we also have a directory block that configures the access and options for the <code class="literal">DocumentRoot</code>. The following screenshot shows the directory block associated with the <code class="literal">DocumentRoot</code> directory:</p><div class="mediaobject"><img src="../Images/image00302.jpeg" alt="Configuring the DocumentRoot directory"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">Directory</code> block appears similar to an XML-based data. This uses an opening tag and sets the target directory therein. This block is closed with the <code class="literal">&lt;/Directory&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Options Indexes FollowSymLinks</strong></span>
</pre></div><p>The <code class="literal">Indexes</code> option allows the creation of an index page. This option lists the contents of a directory if the name of a page is not included in the URL accessed by a client and no <code class="literal">index.html</code> exists. This is perhaps great for a downloads directory, alleviating the need for you to create a page linking it to all the available downloads; however, at <code class="literal">DocumentRoot</code>, we probably do not want this setting because it may pose a security risk.</p><p>The <code class="literal">FollowSymLinks</code> option is probably self-explanatory, which allows you to follow the path of symbolic links. Symbolic links are pointers to other files and directories in a filesystem.</p><p>The <code class="literal">AllowOverride</code> directive <a id="id346" class="indexterm"/>specifies settings that can be used from the user control <code class="literal">.htaccess</code> file. It may be the case with virtual hosts that the administrator does not have access to the web server's configuration file because they <a id="id347" class="indexterm"/>are just renting space on the web server. They can effect configurations by uploading an <code class="literal">.htaccess</code> file to the root of the directory to which the <code class="literal">Directory</code> block pertains. As the main server administrator, you can control the settings that can be read; here, we allow no settings to be read even if the <code class="literal">.htaccess</code> file is present:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>AllowOverride None</strong></span>
</pre></div><p>The final setting here is new to Apache 2.4 and replaces the <code class="literal">Allow from / Deny from</code> directive in Apache 2.2 and earlier versions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Require all granted</strong></span>
</pre></div><p>The default setting is equivalent to the <code class="literal">Allow from all</code> setting in Apache 2.2.</p><p>If required, you can adjust the host access with a configuration similar to the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Require 192.168.0.0/24</strong></span>
<span class="strong"><strong>Require 127.0.0.1</strong></span>
</pre></div><p>The preceding access control will only allow access to the localhost and the <code class="literal">192.168.0</code> network to the associated <code class="literal">Directory</code> block.</p><p>We will change the configuration setting by editing the <code class="literal">/etc/httpd/conf/httpd.conf</code> file. Once we locate the correct <code class="literal">Directory</code> block for <code class="literal">/var/www/html</code>, we will remove the <code class="literal">Index</code> option and leave it as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Options FollowSymLinks</strong></span>
</pre></div><p>These changes should be saved, but <a id="id348" class="indexterm"/>we need to look at <a id="id349" class="indexterm"/>how we can check our settings before attempting to restart the server.</p></div></div></div>
<div class="section" title="Controlling the Apache web service" id="aid-2BASE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec73"/>Controlling the Apache web service</h1></div></div></div><p>When we are ready to <a id="id350" class="indexterm"/>test the changes made, we can perform a pre-flight check with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># apachectl configtest</strong></span>
</pre></div><p>You may receive an error message reporting that the hostname could not be resolved. This is a warning and is okay for the moment. The warning is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00303.jpeg" alt="Controlling the Apache web service"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">Syntax Ok</code> message at the end is what we want to see; with this, we know that we can restart the web server. Issuing a <code class="literal">reload</code> command to the service will force a graceful restart; wait for the active connections to complete before the restart is initiated:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl reload httpd</strong></span>
</pre></div><p>The effect of the change is limited because we have allowed the local network access and the localhost. Removing the <code class="literal">indexes</code> option has no effect while the <code class="literal">index.html</code> page is present. If we remove the <code class="literal">index.html</code> page, we will receive access forbidden messages because the system will not generate the page. This is important to set because it removes the ability of hackers to be able to retrieve directory listings of our web server.</p><div class="section" title="Setting up the server name"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec53"/>Setting up the server name</h2></div></div></div><p>We also need to <a id="id351" class="indexterm"/>tidy up the warning about our server's name. This is controlled using the <code class="literal">ServerName</code> directive in the <code class="literal">httpd.conf</code>. Adding the <code class="literal">ServerName</code> directive at the top of the file will resolve the issue:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ServerName web.theurbanpenguin.com</strong></span>
</pre></div><p>To completely restart the service, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl restart httpd</strong></span>
</pre></div></div><div class="section" title="Setting up a custom error page"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec54"/>Setting up a custom error page</h2></div></div></div><p>If we try to access a <a id="id352" class="indexterm"/>page on the server that does not exist, the viewer will get a standard <code class="literal">page not found</code> message. We can make the process a little more controlled and user-friendly by adding our own custom pages.</p><p>Within the global section of the <code class="literal">httpd.conf</code>, we can add the following directive to handle the <code class="literal">404 Page Not Found</code> message. This global section can affect all directory blocks, but we can add the following directive just to a single directory block if required. Adding the code document for a 404 error will just affect that particular error, but we can add other codes as and when required:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ErrorDocument 404 /404.html</strong></span>
</pre></div><p>We can reload the server using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl reload httpd</strong></span>
</pre></div><p>Now, when an incorrect page is accessed, the viewer will be shown the custom error page we have created: <code class="literal">404.html</code>. This page should be created in the <code class="literal">DocumentRoot</code> because we have used the <code class="literal">/404.html</code> syntax. If we have many custom pages, we will most likely create an <code class="literal">error</code> directory in <code class="literal">DocumentRoot</code> and then reference the page as <code class="literal">/error/404.html</code>.</p></div></div>
<div class="section" title="Loading modules" id="aid-2C9D01"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec74"/>Loading modules</h1></div></div></div><p>Red Hat has moved <a id="id353" class="indexterm"/>away from loading modules in the standard <code class="literal">httpd.conf</code> file. In the previous release of Red Hat (version 6), the configuration file would have been littered with many <code class="literal">LoadModule</code> directives.</p><p>These modules are now loaded via the configuration files in <code class="literal">/etc/httpd/conf.modules.d/</code>. In this way, the main configuration file is less cluttered and it's easier to drop additional configuration files as and when required.</p><p>To view the currently loaded modules from Command Prompt, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo httpd -M</strong></span>
</pre></div><p>We can see that we have many modules loaded. We can pipe the output to the <code class="literal">wc</code> command to count the lines. Using the RHEL 7.1 demonstration system, the output is <code class="literal">82</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo httpd -M | wc -l</strong></span>
</pre></div><p>With the original output, we should be able to see that the <code class="literal">userdir_module</code> is loaded. If we do not need to support user home directories on the web server, we do not need this module. To load this module, the <code class="literal">LoadModule</code> directive referencing this Apache module is set in the <code class="literal">/etc/httpd/conf.modules.d/00-base.conf</code> file. To ensure that it is not loaded on future restarts of the web server, comment the line that reads as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>LoadModule userdir_module modules/mod_userdir.so</strong></span>
</pre></div><p>With the line now <a id="id354" class="indexterm"/>commented, you will need to restart the web server, but when you check the loaded modules, you should be able to verify that the <code class="literal">userdir_module</code> is not loaded.</p></div>
<div class="section" title="Virtual servers"><div class="titlepage" id="aid-2D7TI2"><div><div><h1 class="title"><a id="ch09lvl1sec75"/>Virtual servers</h1></div></div></div><p>Apache has the <a id="id355" class="indexterm"/>capability to support multiple sites from the same server instance. This gives great flexibility, and at the same time, ease of management. This flexibility is <a id="id356" class="indexterm"/>known as virtual hosting. There are three basic ways of running virtual hosting with Apache:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td valign="top">
<p>
<span class="strong"><strong>Name-based</strong></span>
</p>
</td><td valign="top">
<p>This uses different names for each site and a common IP address, probably the most popular form of virtual hosting</p>
</td></tr><tr><td valign="top">
<p>
<span class="strong"><strong>IP-based</strong></span>
</p>
</td><td valign="top">
<p>This uses a different IP address for each site</p>
</td></tr><tr><td valign="top">
<p>
<span class="strong"><strong>Port-based</strong></span>
</p>
</td><td valign="top">
<p>This uses individual port numbers for each site</p>
</td></tr></tbody></table></div><p>We will look at all three of the methods and configurations within the <code class="literal">httpd.conf</code> required to implement each method.</p><div class="section" title="Name-based"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec55"/>Name-based</h2></div></div></div><p>Name-based virtual <a id="id357" class="indexterm"/>hosting has been made possible with the introduction of <a id="id358" class="indexterm"/>HTTP protocol version 1.1, also known as HTTP/1.1. When a browser is only capable of HTTP/1.0, a protocol tries to load a web page; it goes through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Resolves <code class="literal">theurbanpinguin.org</code> hostname to an IP address.</li><li class="listitem">Connects to the resolved IP address over TCP protocol and port <code class="literal">80</code>.</li><li class="listitem">Requests <code class="literal">/index.html</code> page.<p>Therefore, only one website (defined by its domain name) can be hosted at any given IP address. If you direct another domain name—such as <code class="literal">theboldeagle.net</code>—to the same IP address, a user navigating to a URL will see exactly the same as the user navigating to URL because the web server cannot distinguish between these two requests.</p><p>When the HTTP/1.1 protocol and the HTTP/1.1 capable browser sends a domain name to the web server along with the document path, this is how the next step (step 3) looks:</p></li><li class="listitem">Request <code class="literal">/index.html</code> page from <code class="literal">theurbanpinguin.org</code> server.</li></ol><div style="height:10px; width: 1px"/></div><p>It's now possible to host two or more different sites on the same IP address because the web server can distinguish between different domain names, as domain names now form a part of the HTTP request.</p><p>All contemporary web <a id="id359" class="indexterm"/>browsers support HTTP/1.1. There are two aspects to <a id="id360" class="indexterm"/>name-based virtual hosting, which we will now look at.</p><div class="section" title="The name resolution"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec03"/>The name resolution</h3></div></div></div><p>All the names for a site <a id="id361" class="indexterm"/>need to be mapped to the same IP address either via DNS or a localhost file. If any of the names are used in the system, the returned IP address will always be the same. The redirection of the incoming request to the correct location in the filesystem is handled by the <code class="literal">httpd</code> service and the incoming <code class="literal">http</code> header.</p></div><div class="section" title="The Apache configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec04"/>The Apache configuration</h3></div></div></div><p>The key to name-based <a id="id362" class="indexterm"/>virtual hosting lies in the <code class="literal">httpd.conf</code> file in a block directive:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;VirtualHost virtual host IP&gt;</strong></span>
<span class="strong"><strong>.</strong></span>
<span class="strong"><strong>.</strong></span>
<span class="strong"><strong>.</strong></span>
<span class="strong"><strong>&lt;/VirtualHost&gt;</strong></span>
</pre></div><p>Almost any Apache entry is valid here including the <code class="literal">ErrorDocument</code> directive that we saw earlier. We have included the most typical entries in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;VirtualHost *.80&gt;</strong></span>
<span class="strong"><strong>  ServerName	www.packtpub.com</strong></span>
<span class="strong"><strong>  ServerAdmin andrew@example.com</strong></span>
<span class="strong"><strong>  DocumentRoot "/var/www/packt/html"</strong></span>
<span class="strong"><strong>  ErrorLog "/var/www/packt/logs/packt_error"</strong></span>
<span class="strong"><strong>  TransferLog "/var/www/packt/logs/packt_access"</strong></span>
<span class="strong"><strong>&lt;/VirtualHost&gt;</strong></span>
</pre></div><p>Using the preceding example, we will be directed to the web pages in <code class="literal">/var/www/packt/html</code>, if we use the URL of <a class="ulink" href="https://www.packtpub.com/">https://www.packtpub.com/</a> while accessing the server's IP address.</p><p>In order for Apache to find the correct entries for virtual hosts, we must tell it which IP address they are aliases for. However, it's not enough to define a virtual host using the previous block because <a id="id363" class="indexterm"/>Apache does not allow name-based virtual hosting by default. To make name-based virtual hosts work, this is done using the <code class="literal">NameVirtualHost</code> directive, which needs to be included in the <code class="literal">httpd.conf</code> file. This directive must be in the main server section:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>NameVirtualHost *:80</strong></span>
</pre></div></div></div><div class="section" title="IP-based"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec56"/>IP-based</h2></div></div></div><p>The IP addresses used must <a id="id364" class="indexterm"/>be bound to the main RHEL server. Within the Apache <code class="literal">httpd.conf</code>, we again use the <code class="literal">VirtualHost</code> block, but we do not need to set the <code class="literal">NameVirtualHost</code> directive. Instead of specifying <code class="literal">*:80</code> as IP and port selectors of <code class="literal">VirtualHost</code> block, we will use a real IP address that the Apache server listens to, that is, IP <a id="id365" class="indexterm"/>address assigned to one of the interfaces of the machine that the Apache server is running on. The following commands show a possible configuration we can add to the main <code class="literal">httpd.conf</code>:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost 192.168.0.221:80&gt;
  ServerName www.example.com
  ServerAdmin andrew@example.com
  DocumentRoot "/var/www/example/html"
&lt;/VirtualHost&gt;</pre></div><p>Apache listens for incoming connections on all interfaces of the machine by default, so it should be enough just to specify an IP address of one of the interfaces in the <code class="literal">&lt;VirtualHost&gt;</code> opening directive. However, to be doubly sure that Apache listens to the right interface, the following command should be included in the main section of the <code class="literal">httpd.conf</code> file.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Listen 192.168.0.221:80</strong></span>
</pre></div><p>Using the previous example, when we access the host with the IP address <code class="literal">192.168.0.221</code>, we will be redirected to web pages in <code class="literal">/var/www/example/html</code>.</p></div><div class="section" title="Port-based"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec57"/>Port-based</h2></div></div></div><p>There is only one aspect to <a id="id366" class="indexterm"/>port-based virtual hosting: the Apache configuration <a id="id367" class="indexterm"/>with the main <code class="literal">httpd.conf</code>. An example is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost 192.168.0.220:7070&gt;
  ServerName www.example.com
  ServerAdmin andrew@example.com
  DocumentRoot "/var/www/example/html"
&lt;/VirtualHost&gt;</pre></div><p>Using the previous example, when we access the port <code class="literal">7070</code> on the Apache host with the IP address of <code class="literal">192.168.0.220</code>, we will be redirected to web pages in <code class="literal">/var/www/example/html</code>.</p><p>Within all <code class="literal">VirtualHost</code> <a id="id368" class="indexterm"/>blocks, we can expect a <code class="literal">Directory</code> block in <a id="id369" class="indexterm"/>addition to the code we have shown so far. In this way, options and access control lists can be correctly set for each virtual host.</p></div></div>
<div class="section" title="Automating virtual hosts" id="aid-2E6E41"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec76"/>Automating virtual hosts</h1></div></div></div><p>If we create a template file <a id="id370" class="indexterm"/>for a virtual host, we can easily drop new virtual hosts using a script. First, we need a template file that is similar to the following commands:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost *:80&gt;
  ServerAdmin webmaster@dummy-host.example.com
  ServerName dummy-host.example.com
  DocumentRoot /var/www/dummy-host.example.com
  ErrorLog /var/log/httpd/dummy-host.example.com-error_log
  CustomLog /var/log/httpd/dummy-host.example.com-access_log
  UseCanonicalName Off
  ServerSignature On
  &lt;Directory "/var/www/vhosts/dummy-host.example.com"&gt;
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
  &lt;/Directory&gt;
&lt;/VirtualHost&gt;</pre></div><p>If this file is saved as <code class="literal">/etc/httpd/conf.d/template</code>, it will not be used as a configuration as it does not end in <code class="literal">.conf</code>. We can use it as a template with a script similar to the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/bin/bash</strong></span>
<span class="strong"><strong>CONFDIR=/etc/httpd/conf.d</strong></span>
<span class="strong"><strong>WEBDIR=/var/www/</strong></span>
<span class="strong"><strong>mkdir -p $WEBDIR/$1</strong></span>
<span class="strong"><strong>sed s/"dummy-host.example.com"/$1/g \</strong></span>
<span class="strong"><strong>$CONFDIR/template &gt; $CONFDIR/$1.conf</strong></span>
<span class="strong"><strong>echo "This is a website in construction for $1" \</strong></span>
<span class="strong"><strong>&gt; $WEBDIR/$1/index.html</strong></span>
<span class="strong"><strong>systemctl reload httpd</strong></span>
</pre></div><p>If the script is called <code class="literal">/root/vhost.sh</code>, we can run it as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /root/vhost.sh www.example.com</strong></span>
</pre></div><p>The preceding script will <a id="id371" class="indexterm"/>create a new configuration and replace <code class="literal">dummy-host.example.com</code> with <code class="literal">www.example.com</code>.</p></div>
<div class="section" title="Summary" id="aid-2F4UM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec77"/>Summary</h1></div></div></div><p>This chapter introduced you to the Apache HTTPD service that runs on RHEL 7.1. We looked at the <code class="literal">ServerRoot</code> being <code class="literal">/etc/httpd</code> and the <code class="literal">DocumentRoot</code> being <code class="literal">/var/www/html</code>. With the basics in place, you learned how to configure a server with custom error pages and virtual hosts.</p><p>In the next chapter, we will look at SELinux in detail and try to leave you with the idea that you can implement SELinux without affecting your service delivery in a negative way. In fact, the word negative is far from the truth. SELinux will deliver you a secure and robust platform so that you can deploy public-facing services without any fear of compromise, adding <span class="strong"><strong>Mandatory Access Controls</strong></span> (<span class="strong"><strong>MAC</strong></span>) to the existing, but weaker <span class="strong"><strong>DAC</strong></span> (<span class="strong"><strong>Discretionary Access Controls</strong></span>).</p></div></body></html>