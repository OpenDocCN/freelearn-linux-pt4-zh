<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flow Control using Branches and Loops</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, we cover the following topics:</span></p>
<ol>
<li>Using <span>If</span><span>–ElseIf</span><span>–Else </span>conditions to control script flow</li>
<li>Using <span>Switch–Case </span>conditions to control script flow</li>
<li>Learning to use delays</li>
<li>Writing a basic looping construct</li>
<li>Writing a more complex loop on a predefined array</li>
<li>Using the For loop construct</li>
<li>Using the While loop construct</li>
<li>Cleaning empty directories using the Do–While construct</li>
<li>Cleaning empty directories using the Do–Until construct</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Just like Working with Strings, this Flow Control is also a favourite part of PowerShell to me.</p>
<p><span>Most Linux administrators and Bash scripters would already be familiar with the concepts such as the loops and branches, that cover these recipes. The only main difference we would see is that we would deal with objects, and a more readable, streamlined process of scripting.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using If–ElseIf–Else conditions to control script flow</h1>
                </header>
            
            <article>
                
<p>We have seen how the operators work. Try out more of the operators until it sort of becomes a second nature to you. Most of the flow control as well as filtration in scripts happen using these operators.</p>
<p>In this recipe we are going to look at conditional script flow, also known as <em>branching</em>. In essence, branching works on two conditions (correct: <kbd>$true</kbd> and <kbd>$false</kbd>). And this is generally achieved using two constructs:</p>
<ol>
<li>The If–ElseIf–Else construct</li>
<li>The Switch–Case construct</li>
</ol>
<p>In this recipe, we will give ourselves a simple problem to solve: find if today is a weekend.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>These recipes require you to try them, in order to understand how they work. And these work better on an Integrated Scripting Environment (preferably, Visual Studio Code) than at the prompt. <span>To run the scripts in VS Code, use the F5 key.</span> Also, these recipes should work identically on Windows PowerShell 3.0+ as well: the syntaxes for these constructs are exactly the same in PowerShell and Windows PowerShell.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Open a new PowerShell file in Visual Studio Code.</p>
<ol>
<li>Enter the following in the code pane to simply find if it is a weekend.</li>
</ol>
<div>
<pre style="padding-left: 90px"><span>$</span><span>Date</span><span> </span><span>=</span><span> </span><span>Get-Date<br/><br/></span><span>if</span><span> (</span><span>$</span><span>Date</span><span>.DayOfWeek</span><span> </span><span>-in</span><span> </span><span>'Saturday'</span><span>,</span><span> </span><span>'Sunday'</span><span>) {<br/></span><span>    </span><span>Write-Host</span><span> </span><span>'We party on weekends!'</span><span> </span><span>-</span><span>BackgroundColor Yellow </span><span>-</span><span>ForegroundColor Black<br/></span><span>}</span></pre></div>
<ol start="2">
<li>If you would like to get an output on weekdays as well:</li>
</ol>
<div>
<pre style="padding-left: 90px"><span>$</span><span>Date</span><span> </span><span>=</span><span> </span><span>Get-Date<br/></span><span>if</span><span> (</span><span>$</span><span>Date</span><span>.DayOfWeek</span><span> </span><span>-in</span><span> </span><span>'Saturday'</span><span>,</span><span> </span><span>'Sunday'</span><span>) {<br/></span><span>    </span><span>Write-Host</span><span> </span><span>'It is a weekend!'</span><span><br/></span><span>}<br/></span><span>else</span><span> {<br/></span><span>    </span><span>Write-Host</span><span> </span><span>'It is a weekday.'<br/></span>}<span><br/></span></pre></div>
<ol start="3">
<li>If you would like to jazz it up a little, and use the whole of<span> </span><kbd>if</kbd><span>–</span><kbd>elseif</kbd><span>–</span><kbd>else</kbd>:</li>
</ol>
<pre style="padding-left: 90px">$Date = Get-Date

if ($Date.DayOfWeek -in 'Saturday', 'Sunday') {
    Write-Host 'We party on weekends!' -BackgroundColor Yellow -ForegroundColor Black
}
elseif ($Date.DayOfWeek -eq 'Wednesday') {
    Write-Host 'Half the week is over, and I want to do so much more!'
}
else {
    Write-Host 'Work is worship. Ahem!'
}</pre>
<div class="packt_tip">In general, <kbd>Write-Output</kbd> is a better cmdlet to use than <kbd>Write-Host</kbd>. <kbd>Write-Host</kbd> writes the output <em>only</em> to the host; this output cannot be sent to anything else without manipulation. Use <kbd>Write-Host</kbd> only on occasions that need it.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Simple branching could work with just the If statement. The statement checks for truth, and executes the code block based on the outcome of the condition. In case of either–or, where there are only two conditions, use If–Else. When there are more than two possible outcomes, use If–ElseIf–Else. The <kbd>else</kbd> block is the catch-all.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Switch–Case conditions to control script flow</h1>
                </header>
            
            <article>
                
<p>If–ElseIf–Else work when you have outcomes coming in categories (weekdays being five days, weekends being two). When the outcomes are specific and/or too many in number, it could be a little tedious to use the  <span>If</span><span>–ElseIf</span><span>–Else construct. To understand this better, let us give ourselves a scenario.</span></p>
<p>The dress code at your workplace is decided by a child, who likes everyone wearing the colours of the rainbow. Since she doesn't like anyone working weekends, is not a big fan of orange, and absolutely hates yellow, she has come up with the following scheme (she does not yet know of "Monday Blues"): Red on Mondays, Violet on Tuesdays, Indigo on Wednesdays, Blue on Thursdays, Green on Fridays and Orange during the weekends.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>This situation would require a whole round of If<span>–</span>ElseIf<span>–</span>Else statements to program. A more efficient way of handling the situation is to use the Switch<span>–</span>Case construct.</p>
<ol start="1">
<li>Open a new PowerShell file and add the following content to it:</li>
</ol>
<pre style="padding-left: 90px">$Date = Get-Date

switch ($Date.DayOfWeek) {
    'Monday' { Write-Output 'Red' }
    'Tuesday' { Write-Output 'Violet' }
    'Wednesday' { Write-Output 'Indigo' }
    'Thursday' { Write-Output 'Blue' }
    'Friday' { Write-Output 'Green' }
    Default { Write-Output 'Orange' }
}</pre>
<ol start="2">
<li>If you would rather omit<span> </span><kbd>Default</kbd><span> </span>and use a wildcard matching for the weekends:</li>
</ol>
<pre style="padding-left: 90px">$Date = Get-Date

switch <strong>-Wildcard</strong> ($Date.DayOfWeek) {
    'Monday' { Write-Output 'Red' }
    'Tuesday' { Write-Output 'Violet' }
    'Wednesday' { Write-Output 'Indigo' }
    'Thursday' { Write-Output 'Blue' }
    'Friday' { Write-Output 'Green' }
    'S*' { Write-Output 'Orange' }
}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Like we can see, it is more efficient to write, execute as well as troubleshoot a Switch–Case construct in such situations, rather than writing a series of if–elseif–elseif–elseif–...–else statements. To define a catch-all action in Switch–Case, use <kbd>Default</kbd>.</p>
<p>The Switch–Case construct also supports wildcard (<kbd>-Wildcard</kbd>) and regex (<kbd>-Regex</kbd>). In general, it is not a good practice to omit <kbd>Default</kbd> unless <em>all</em> the possible outcomes have been covered.</p>
<p>The working of <span>Switch–Case is simple: it checks the condition against <em>all the values</em> among the definitions, and whenever it finds a condition to be true, it executes the corresponding script block. Therefore if three conditions among five are met, the three script blocks will be executed. This is a little unlike If–ElseIf–Else, which exits out of the branching construct the moment the first <kbd>$true</kbd> is met and the script block is executed. </span>Therefore, if you want only one outcome from the construct, consider adding the <kbd>break</kbd> keyword in every script block to break out of the construct the moment a<span> </span><kbd>$true</kbd><span> </span>is encountered. For example:</p>
<pre>...<br/>    'Monday' {
        Write-Output 'Red'
        break
    }<br/>...</pre>
<p>Of course, in this particular situation, it is not necessary, since the outcome would be exclusive.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Learning to use delays</h1>
                </header>
            
            <article>
                
<p>PowerShell usually runs one statement after another; the current statement must return the buffer (so to speak) for the next step to begin execution. However, in some cases, you still require a wait; situations where the buffer could be returned before the desired outcome is achieved.</p>
<p>While setting up something like this may require some manipulation, to keep it simple, let us just assume that we need five seconds to register what day it is (sure, disbelief works), before being instructed what to wear.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let us combine the two scripts from the previous recipe, <em>Using conditions to control script flow</em>.</p>
<ol>
<li>Open a new file and type the following:</li>
</ol>
<pre style="padding-left: 90px">$Date = Get-Date

if ($Date.DayOfWeek -in 'Saturday', 'Sunday') {
    Write-Host 'We party on weekends!' -BackgroundColor Yellow -ForegroundColor Black
}
elseif ($Date.DayOfWeek -eq 'Wednesday') {
    Write-Host 'Half the week is over, and I want to do so much more!'
}
else {
    Write-Host 'Work is worship. Ahem!'
}

<strong>Start-Sleep -Seconds 5</strong>

$Date = Get-Date

switch ($Date.DayOfWeek) {
    'Monday' { Write-Output 'Wear red.'; break }
    'Tuesday' { Write-Output 'Wear violet.'; break }
    'Wednesday' { Write-Output 'Wear indigo.'; break }
    'Thursday' { Write-Output 'Wear blue.'; break }
    'Friday' { Write-Output 'Wear green.'; break }
    Default { Write-Output 'Poor you, working today. Wear orange.'; break }
}</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/9586edab-e1bb-444a-a119-28584db1a57b.png" width="1812" height="244"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The reason this is a separate recipe is that it is part of flow control, and is useful in some specific situations. The <kbd>Start-Sleep</kbd> cmdlet accepts <kbd>Seconds</kbd> or <kbd>Milliseconds</kbd> as input, and waits for that amount of time before processing the next instruction.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing a basic looping construct</h1>
                </header>
            
            <article>
                
<p>Automation is perhaps only half-complete without loops. After all, the point of automation in most situations is making the computer do what is repetitive. There are six looping constructs in PowerShell in all:</p>
<ol>
<li>Looping using <kbd>Foreach-Object</kbd></li>
<li>The Foreach loop</li>
<li>The For loop</li>
<li>The While loop</li>
<li>The Do–While loop</li>
<li>The Do-Until loop</li>
</ol>
<p>The <kbd>Foreach-Object</kbd> looping construct is perhaps the simplest of them all.</p>
<p>Let us imagine that we have a list of five guests to a certain event, and you would like to greet them each individually.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it</h1>
                </header>
            
            <article>
                
<p>Let us assume that the guests are Mr Jain, Mr Jacobs, Ms Sanders, Mr Shah and Mr Hugo.</p>
<ol>
<li>Open a new file in Visual Studio Code and, in the script pane, type the following.</li>
</ol>
<pre style="padding-left: 90px">$GuestsRaw = Read-Host "Enter the guest names, separated by commas"
$Guests = $GuestsRaw -split ",$([regex]'[\s]*')"

$Guests | ForEach-Object { Write-Output "Welcome, $PSItem!" }</pre>
<ol start="2">
<li>Run the script, and at the prompt, type in the names of the guests:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Mr Jain, Mr Jacobs, Ms Sanders, Mr Shah, Mr Hugo</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You first take in the input through a prompt from the host. The raw guest list is taken in. PowerShell then splits the input string based on the commas and a regular expression match (necessary so it would work whether the input contains a space after the comma or not: not all users are alike). We use the <kbd>-split</kbd> and cast operators for the operation.</p>
<p>The loop part comes in at <kbd>Foreach-Object</kbd>. You pass the array object into the pipeline. The <kbd>Foreach-Object</kbd> cmdlet picks up the array, and processes one element at a time. When referring to the element within the loop, you use the <kbd>$PSItem</kbd> (a.k.a. <kbd>$_</kbd>) automatic variable, since the object has been passed through the pipeline.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing a more complex loop on a predefined array</h1>
                </header>
            
            <article>
                
<p>In the last recipe, Writing a basic loop construct, we wrote a simple loop by passing content through the pipeline. Now, let us consider that we have these same guests, but specific seats have been allotted to them. We would like to show the seats to the guests. You have the following table in a CSV format.</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 49.6922%">
<div class="CDPAlignCenter CDPAlign"><strong>Name</strong></div>
</td>
<td style="width: 49.3078%">
<div class="CDPAlignCenter CDPAlign"><strong>Seat</strong></div>
</td>
</tr>
<tr>
<td style="width: 49.6922%">Mr Jain</td>
<td style="width: 49.3078%">A-12</td>
</tr>
<tr>
<td style="width: 49.6922%">Mr Jacobs</td>
<td style="width: 49.3078%">C-28</td>
</tr>
<tr>
<td style="width: 49.6922%">Ms Sanders</td>
<td style="width: 49.3078%">B-17</td>
</tr>
<tr>
<td style="width: 49.6922%">Mr Shah</td>
<td style="width: 49.3078%">M-22</td>
</tr>
<tr>
<td style="width: 49.6922%">Mr Hugo</td>
<td style="width: 49.3078%">E-08</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The assumption here is that each row has forty seats, and the aisle goes through the centre of the hall.</p>
<ol>
<li>If you have not cloned the repository, you could create your own CSV file. Either copy the comma-separated content from below, or create a CSV using PowerShell.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; @'
Name,Seat
Mr Jain,A-12
Mr Jacobs,C-28
Ms Sanders,B-17
Mr Shah,M-22
Mr Hugo,E-08
'@ | Out-File -Path './chapter-08/05-Write-GuestSeatDetails.csv'</pre>
<ol start="2">
<li>Open a new PowerShell file in Visual Studio Code and type the following script:</li>
</ol>
<pre style="padding-left: 90px">$Guests = Import-Csv './chapter-08/05-Write-GuestSeatDetails.csv'

foreach ($Guest in $Guests) {
    $RowIdentifier = [byte][char](($Guest.Seat -split '-')[0].ToUpper())
    $RowNumber = ($RowIdentifier - 64).ToString()

    switch -Regex ($RowNumber) {
        '1(1|2|3)$' { $RowNumber += 'th'; break }
        '.?1$'      { $RowNumber += 'st'; break }
        '.?2$'      { $RowNumber += 'nd'; break }
        '.?3$'      { $RowNumber += 'rd'; break }
        Default     { $RowNumber += 'th'; break }
    }

    $SeatNumber = ($Guest.Seat -split "-")[1]

    if ($SeatNumber -gt 20) {
        $Side = 'right'
    }
    else {
        $Side = 'left'
    }

    Start-Sleep -Seconds 1
    Write-Host "Welcome, $($Guest.Name)! " -NoNewline
    Start-Sleep -Seconds 1
    Write-Host "Your seat is in the $RowNumber row, to the $Side the aisle."
}</pre>
<ol start="3">
<li>Run the script.</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/05449802-4f16-462e-a2a1-6ddfb8a26793.png" width="1812" height="404"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The main idea here is the use of <kbd>foreach</kbd>. When using the Foreach loop construct, you refer to each element with a variable; variables are not identified with an index in this case. For every iteration, in our case, <kbd>$Guest</kbd> picks one value from <kbd>$Guests</kbd>, in sequence, so that the current element can be referred using <kbd>$Guest</kbd>.</p>
<p>The seat numbers have a pattern: an alpha row identifier, followed by a hyphen, followed by the numeric seat identifier.</p>
<p>The seat number is a string. We split it at <kbd>-</kbd>, pick the first element in the resultant array, convert it to uppercase (in case it already isn't), convert this letter to a character, and then, use the <kbd>[byte]</kbd> cast operator to find its ASCII identifier. And yes, we subtract 64 from it (so <kbd>A</kbd> becomes <kbd>1</kbd>).</p>
<p>To be able to use the number with switch–case without errors, we convert the number back to a string. We make the number friendly for use in a sentence. We take the second (numeric) part of the array to see which side of the aisle the seat is located on. We combine all these to get the resultant greeting-and-guidance strings, which are displayed after a delay of one second each.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the For loop construct</h1>
                </header>
            
            <article>
                
<p>The Foreach loop and the For loop are different in that the latter uses an index to perform operations. We need a variable to control the flow, whose values form a range. Let us re-implement the same solution as that in <em>Writing a more complex loop on a predefined array</em>, but with a For loop construct instead.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The assumptions made are the same as that in <em>Writing a more complex loop on a predefined array</em>.</p>
<ol>
<li><span>Open a new file and paste the following content into it.</span></li>
</ol>
<pre style="padding-left: 90px">$Guests = Import-Csv './chapter-08/05-Write-GuestSeatDetails.csv'

<strong>for ($CurrentGuest = 0; $CurrentGuest -lt $Guests.Length; $CurrentGuest++) {
    $Guest = $Guests[$CurrentGuest]</strong>

    $RowIdentifier = [byte][char](($Guest.Seat -split '-')[0].ToUpper())
    
    $RowNumber = ($RowIdentifier - 64).ToString()
    
    switch -Regex ($RowNumber) {
        '1(1|2|3)$' { $RowNumber += 'th'; break }
        '.?1$'      { $RowNumber += 'st'; break }
        '.?2$'      { $RowNumber += 'nd'; break }
        '.?3$'      { $RowNumber += 'rd'; break }
        Default     { $RowNumber += 'th'; break }
    }

    $SeatNumber = ($Guest.Seat -split "-")[1]
    
    if ($SeatNumber -gt 20) {
        $Side = 'right'
    }
    else {
        $Side = 'left'
    }

    Start-Sleep -Seconds 1
    Write-Host "Welcome, $($Guest.Name)! " -NoNewline # Subexpression `$Guest.Name` to be computed first.
    Start-Sleep -Seconds 1
    Write-Host "Your seat is in the $RowNumber row, to the $Side the aisle."
}</pre>
<ol start="2">
<li>Run the script.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Some of you might be pointing out that the <kbd>foreach</kbd> construct was simpler than the <kbd>for</kbd> construct in this case, and you would be right. In my stint as an administrator, I may have used the for construct less than ten times over the last three years, compared to hundreds of times I used <kbd>foreach</kbd>. The For construct has its own uses; use with a predefined array is of the less-efficient ones.'</p>
<p>Regardless, <kbd>for</kbd> works as long as the object is an array. <kbd>$CurrentGuest</kbd> is the index we use, which ranges from 0 through the total elements in <kbd>$Guests</kbd> – 1. The loop starts with the index being initialised at 0 in this case, and after every iteration of the script block, the index is incremented (<kbd>$CurrentGuest++</kbd>).</p>
<p>One operation where <kbd>for</kbd> would be more efficient than <kbd>foreach</kbd> is if every <em>alternate</em> guest had to be greeted (rude, I know). In that case, the third part of the definition of <kbd>for</kbd> would have been <kbd>$CurrentGuest += 2</kbd>.</p>
<div class="packt_infobox"><kbd>$CurrentGuest + 2</kbd> instead of <kbd>$CurrentGuest += 2</kbd> would make this loop infinite, since the value of <kbd>$CurrentGuest</kbd> would not be changed at all.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the While loop construct</h1>
                </header>
            
            <article>
                
<p>We shall create two scripts in this recipe: the first one to establish the similarities between For and While, and another to lay the foundation to understanding the Do–While and Do–Until constructs. This way, the learning would be incremental, and understanding, easier.</p>
<p>For the first script, the scenario is the same as described in the last recipe, <em>Using the For loop construct</em>. For the second, the task is to take the year number as input and find the date for Mothers’ Day in that year.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it</h1>
                </header>
            
            <article>
                
<p>First, continue with the assumptions you had for the previous recipe.</p>
<ol>
<li><span>Open a new file and paste the following content into it.</span></li>
</ol>
<pre style="padding-left: 90px">$Guests = Import-Csv './chapter-08/05-Write-GuestSeatDetails.csv'
<strong>$CurrentGuest = 0</strong>

<strong>while ($CurrentGuest -lt $Guests.Length) {</strong>
    $Guest = $Guests[$CurrentGuest]

    $RowIdentifier = [byte][char](($Guest.Seat -split '-')[0].ToUpper())
    $RowNumber = ($RowIdentifier - 64).ToString()

    switch -Regex ($RowNumber) {
        '1(1|2|3)$' { $RowNumber += 'th'; break }
        '.?1$'      { $RowNumber += 'st'; break }
        '.?2$'      { $RowNumber += 'nd'; break }
        '.?3$'      { $RowNumber += 'rd'; break }
        Default     { $RowNumber += 'th'; break }
    }

    $SeatNumber = ($Guest.Seat -split "-")[1]

    if ($SeatNumber -gt 20) { $Side = 'right' }
    else { $Side = 'left' }

    Start-Sleep -Seconds 1
    Write-Host "Welcome, $($Guest.Name)! " -NoNewline
    Start-Sleep -Seconds 1
    Write-Host "Your seat is in the $RowNumber row, to the $Side the aisle."

    <strong>$CurrentGuest++</strong>
}</pre>
<ol start="2">
<li>Run the script; the output should be the same as that of the last recipe.</li>
<li>Now, create a new PowerShell file and add the following code:</li>
</ol>
<pre style="padding-left: 90px">$Year = Read-Host "Enter the year (YYYY) you would like to find Mothers’ Day for"

<strong>$CurrentDay = Get-Date "01 May $Year"</strong>

<strong>while ($CurrentDay.DayOfWeek -ne 'Sunday') {</strong>
    <strong>$CurrentDay = $CurrentDay.AddDays(1)</strong>
}
$MothersDay = $CurrentDay.AddDays(7)

Write-Output "Mothers’ Day falls on $($MothersDay.ToLongDateString())."</pre>
<ol start="4">
<li>Run the script. Enter any year and you should get the date for Mothers’ Day for that year.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Every finite looping construct requires three things:</p>
<ol>
<li>The starting point</li>
<li>The stopping point</li>
<li>The way to proceed towards the stopping point</li>
</ol>
<p>In case of the Foreach construct, the entire logic is pre-coded. It takes an entire array, finds the starting and stopping points, and moves towards the stopping point one step at a time. The For construct has these parameters declared in the loop declaration statements itself, each parameter separated by a semicolon.</p>
<p>The While loop is not very different. Its starting point is defined outside of the loop, the stopping point is the only condition passed, and the operation on the index is specified within the loop. These three parameters have been highlighted in the scripts. The initialisation should happen outside the loop so it is not modified during the course of the loop. The operation on the index should happen for every iteration so the loop moves in some direction. Therefore, this operation falls within the loop.</p>
<div class="packt_tip">Be a little careful with the while loop; you are more prone to getting an infinite loop, because it is easy to forget to add the starting point or the operation to move towards the stopping point.</div>
<p>Now to Mothers’ Day. We first get the date object for the 1<sup>st</sup> of May for that year, so we can manipulate it using its members. This date is the starting point. We then specify the condition, 'keep the loop going if the day is not a Sunday.' Then, we add one day, every iteration. After every iteration, the variable is checked against the condition. Finally, when the first Sunday is encountered, the variable comes out of the loop. We then add a week to it to find the second Sunday, and output the long date version of the value of <kbd>$MothersDay</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cleaning empty directories using the Do–While construct</h1>
                </header>
            
            <article>
                
<p>In the last recipe, we found the second Sunday of May using the year as input. We used a While loop for that. The While loop checks the condition before even starting the iteration. If the condition returns $false at the very beginning, the loop would not even begin; for instance, if you input the year as <kbd>2016</kbd>.</p>
<p>Do–While is a little different; the loop is executed once whether the condition is true or not. The condition is checked only <em>after</em> the first iteration.</p>
<p>The scenario for this recipe is that we want to delete all empty directories within a certain directory.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In order to work with this recipe, let us create a few empty directories within <kbd>$HOME/random</kbd>. Use the input file that is part of the git repository of this book to get the directories created.</p>
<pre>PS&gt; Get-Content ./chapter-08/08-input-file.txt | ForEach-Object { New-Item $($PSItem -replace '\.', "$HOME/random") -ItemType Directory }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>If you run the following recipe within the <kbd>random</kbd> lab directory, all its empty subdirectories will be deleted.</p>
<ol>
<li><span>Open a new file and paste the following content into it.</span></li>
</ol>
<pre style="padding-left: 90px">do {
    $AllDirectories = (Get-ChildItem -Path $HOME/random -Recurse -Directory).FullName
    $EmptyDirectories = $AllDirectories | Where-Object {(Get-ChildItem $PSItem).Count -eq 0}
    $EmptyDirectories | Remove-Item
} while ($EmptyDirectories.Count -gt 0)</pre>
<ol start="2">
<li>Let us add some logging to it so we know what is happening.</li>
</ol>
<pre style="padding-left: 90px">$Iteration = 0
do {
    $AllDirectories = (Get-ChildItem -Path $HOME/random -Recurse -Directory).FullName
    $EmptyDirectories = $AllDirectories | Where-Object {(Get-ChildItem $PSItem).Count -eq 0}
    $EmptyDirectories | Remove-Item

    "Iteration $Iteration. Removed the following $($EmptyDirectories.Count) directories."
    $EmptyDirectories
    $Iteration++
} while ($EmptyDirectories.Count -gt 0)</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/c622064b-ee5e-4f8c-8898-3b6fcb535608.png" width="1950" height="1531"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The execution is similar to the While construct, however, as shown by <kbd>Iteration 0</kbd>, the Do–While construct executes the script block once without checking the condition. In our case, we queried the empty directories within the loop. If we had placed this query outside of the loop, we would have had to place it within as well, for loop control. That is inefficient programming.</p>
<p>PowerShell found nine empty directories during the execution of the script block. When the condition check happened after the execution, <kbd>9</kbd> was evaluated to be greater than <kbd>0</kbd>. The loop ran again. This time, the value of <kbd>$EmptyDirectories.Count</kbd> was evaluated to be <kbd>4</kbd>. The loop ran again, and this time again, the value was <kbd>4</kbd>, greater than <kbd>0</kbd>; the condition was still <kbd>$true</kbd>. During the next run, <kbd>$EmptyDirectories.Count</kbd> was evaluated to be <kbd>2</kbd>, then <kbd>1</kbd>, and then, during the last run, <kbd>0</kbd>. At this time, the outcome of the condition became <kbd>$false</kbd>, and the loop exited. Essentially, the loop statement was, 'Go on <em>while</em> the count is <em>more than</em> zero.'</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 5.7: Taking actions on the returned objects</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cleaning empty directories using the Do–Until construct</h1>
                </header>
            
            <article>
                
<p>It is easy to confuse between Do–While and Do–Until, since they both share a lot of similarities. However, the difference between them is in fact, pretty clear. The Do–While loop executes as long as the outcome of the condition check is <kbd>$true</kbd>, and exits the moment it becomes <kbd>$false</kbd>. Do–Until is the opposite: the loop continues as long as the condition check returns $false, and stops the moment it the condition check returns <kbd>$true</kbd>.</p>
<p>Let us use the same scenario of cleaning up empty folders, but this time, use the Do–Until loop.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>You would need to rerun the command to create those empty directories.</p>
<ol>
<li><span>Open a new file and paste the following content into it.</span></li>
</ol>
<pre style="padding-left: 90px">$Iteration = 0
do {
    $AllDirectories = (Get-ChildItem -Path $HOME/random -Recurse -Directory).FullName
    $EmptyDirectories = $AllDirectories | Where-Object {(Get-ChildItem $PSItem).Count -eq 0}
    $EmptyDirectories | Remove-Item
    $Count = $EmptyDirectories.Count

    "Iteration $Iteration`nRemoved the following $Count directories. '$Count = 0' is $($Count -eq 0)"
    $EmptyDirectories
    $Iteration++
} <strong>until</strong> ($Count <strong>-eq</strong> 0)</pre>
<ol start="2">
<li>Notice the change in the behaviour this time and compare it with the run of Do–While.</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/368f892a-96c9-4179-b2aa-56ae1c662904.png" width="1950" height="1531"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This time, it was made evident in the interactive output how it works. The first run happened without checking for the condition. At the end of the run, the condition was checked for. <kbd>9</kbd> is greater than <kbd>0</kbd>, and not equal. The outcome was <kbd>$false</kbd>, so the loop continued. It went on this way until the count came down to <kbd>0</kbd> (making the outcome of the condition <kbd>$true</kbd>), at which point, the loop exited. Essentially, the loop statement was, 'Go on <em>until</em> the count <em>becomes</em> zero.'</p>
<p>That concludes our chapter on flow control. I hope that you had a nice time learning the techniques, and that this chapter helps you with a good chunk of automation work you wish to carry out after learning to use PowerShell.</p>


            </article>

            
        </section>
    </div>



  </body></html>