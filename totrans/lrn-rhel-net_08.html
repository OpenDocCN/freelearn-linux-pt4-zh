<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Integrating RHEL 7 into Microsoft Active Directory Domains" id="aid-20R681"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Integrating RHEL 7 into Microsoft Active Directory Domains</h1></div></div></div><p>In the previous chapter, we looked at how to share resources to Microsoft's clients. Now, in the spirit of true symbiosis, we will see how RHEL can make use of Active Directory users and groups, implementing domains as identity stores. If users have access to the console of the RHEL server, then simply by their Active Directory credentials, they will have access to RHEL. Not only does this streamline access to a console, but it also simplifies access to any shared folder on the RHEL 7 Samba server.</p><p>We will structure this chapter so that you are able to see the bells and whistles (the good stuff) that Active Directory integration can provide before we delve under the hood at what goes on to make these simple tools work.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Overview of identity management</li><li class="listitem">Overview of the lab environment</li><li class="listitem">Preparing to join an Active Directory domain</li><li class="listitem">Using realm to manage domain enrolment</li><li class="listitem">Logging on to RHEL 7 using Active Directory credentials</li><li class="listitem">User and group management with <code class="literal">adcli</code></li><li class="listitem">Delegating Active Directory accounts with <code class="literal">sudo</code></li><li class="listitem">Leaving a domain</li><li class="listitem">Understanding Active Directory as an identity provider for <code class="literal">sssd</code></li></ul></div><div class="section" title="Overview of identity management"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Overview of identity management</h1></div></div></div><p>To begin our banquet of <a id="id293" class="indexterm"/>delights, we will focus on the importance of identity management in an enterprise. Without using some form of identity store or vault to centralize user accounts, these accounts will need to be duplicated because access is required for other systems. As you can imagine, these user accounts can quickly become out of control as vast numbers are created to support individual account silos on each system. However, we should not be too concerned with the need for creation and management of these accounts; other than this, being an administrative burden is not a security concern. If a user does not have access to a resource, they will soon let you know. The concern with account silos is what happens when a user leaves; do you believe that every account for every user that leaves an organization will be deleted or (at least) disabled. Somehow, however good your system, some will slip through the net and a security issue will be created. Good identity management with one account per user will solve the administrative burden, and more importantly, the security weakness.</p><p>Of course, lesser issues relate to the management of these accounts, such as password changes, and perhaps the need for name changes as time progresses. Ideally, each user in an organization will have just one identity, which is a single set of credentials that they use to gain access to any resource to which they have permission. This can be achieved through some form of central directory service acting as an identity vault. This may be the Active Directory, but it can quite easily be some other form of the <span class="strong"><strong>LDAP</strong></span> (<span class="strong"><strong>Lightweight Directory Access Protocol</strong></span>) server. In small to medium environments, an Active Directory <a id="id294" class="indexterm"/>may be sufficient, but as the organization grows and the size of the identity vault grows, perhaps the need for a completely separate directory for users will be needed. The central user store can then synchronize changes to other connected systems.</p><p>Microsoft has its Identity Management suite to build around the Active Directory, and Red Hat has its identity management directory server. This chapter will focus and integrate RHEL 7 directly into a single Domain Active Directory environment.</p></div></div>
<div class="section" title="An overview of the lab environment" id="aid-21PMQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec63"/>An overview of the lab environment</h1></div></div></div><p>For demonstrations in this <a id="id295" class="indexterm"/>chapter, we will use two virtual machines running in an <span class="strong"><strong>Oracle VirtualBox </strong></span>virtualization environment.</p><p>We have a Microsoft Server 2008R2 Active Directory Domain Controller with the IP address <code class="literal">192.168.0.252</code> and the RHEL 7.1 host with the IP address <code class="literal">192.168.0.69</code>. This is the same setup that we have used in <a class="link" title="Chapter 7. Implementing Windows Shares with Samba 4" href="part0060.xhtml#aid-1P71O1">Chapter 7</a>, <span class="emphasis"><em>Implementing Windows Shares with Samba 4</em></span>; we have left time and DNS configured the same way. If you are stepping into this chapter without having completed <a class="link" title="Chapter 7. Implementing Windows Shares with Samba 4" href="part0060.xhtml#aid-1P71O1">Chapter 7</a>, <span class="emphasis"><em>Implementing Windows Shares with Samba 4</em></span>, ensure <a id="id296" class="indexterm"/>that you have set up the RHEL server to use the Domain Controller for both the time and name resolution.</p></div>
<div class="section" title="Preparing to join an Active Directory domain" id="aid-22O7C1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Preparing to join an Active Directory domain</h1></div></div></div><p>From what we <a id="id297" class="indexterm"/>have seen in <a class="link" title="Chapter 7. Implementing Windows Shares with Samba 4" href="part0060.xhtml#aid-1P71O1">Chapter 7</a>, <span class="emphasis"><em>Implementing Windows Shares with Samba 4</em></span>, using Samba to share files, we can understand that this is pretty impressive stuff. We always need to remind ourselves that this all comes without any price tag or the need of client access licenses.</p><div class="note" title="Note"><h3 class="title"><a id="tip25"/>Tip</h3><p>Samba file sharing is free, that is, <span class="emphasis"><em>without cost</em></span> and free in <span class="emphasis"><em>liberty</em></span>; you can use it as you wish. This is the fundamental premise of open source software and is at the heart of Linux.</p></div><p>The big issue that may act as a potential deal breaker is the need to maintain user accounts on the RHEL server and the AD domain to which the workstation accessing the server belongs. If we implement more than one server, the problem is exacerbated with the need for accounts on each and every server as well as the AD domain. The simple solution is to incorporate the RHEL server into the AD domain and use AD accounts for resource access. In this way, we can use a single sign-on to the Active Directory and gain access to shared resources on the RHEL Samba server.</p><div class="note" title="Note"><h3 class="title"><a id="tip26"/>Tip</h3><p>If the Active Directory is not in place, the central account sharing can be established by installing the openLDAP server on RHEL. One RHEL server can then act as an identity vault, sharing accounts to LDAP clients on other servers.</p></div><p>Irrespective of Samba file shares, your Active Directory users may need access to RHEL servers via SSH or some other mechanism. They will need accounts defined on each RHEL server for this. Joining an RHEL server to the AD domain enables the use of the user's AD account when logging in to any member server, which includes RHEL servers or desktops. Additionally, rights can be delegated to these accounts using the <code class="literal">/etc/sudoers</code> file and file permissions in the normal mechanism.</p><p>Before we join the AD domain, we need to ensure that we have set up the time services and DNS, as detailed in <a class="link" title="Chapter 7. Implementing Windows Shares with Samba 4" href="part0060.xhtml#aid-1P71O1">Chapter 7</a>, <span class="emphasis"><em>Implementing Windows Shares with Samba 4</em></span>. With these infrastructure services in place, we will need the following packages installed on the RHEL server:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">realmd</code>: This manages enrolment and membership to the Active Directory domains</li><li class="listitem"><code class="literal">samba</code>: This denotes the Samba services</li><li class="listitem"><code class="literal">samba-common</code>: This denotes the shared tools for servers and clients</li><li class="listitem"><code class="literal">oddjob</code>: This is a D-bus service that runs the odd jobs for clients</li><li class="listitem"><code class="literal">oddjob-mkhomedir</code>: This is used with the odd job services to create home directories for AD accounts, if needed</li><li class="listitem"><code class="literal">sssd</code>: The System Security Services daemon can be used to divert client authentication as required</li><li class="listitem"><code class="literal">adcli</code>: These are the tools for joining and managing AD domains</li></ul></div><p>The following <a id="id298" class="indexterm"/>command shows the installation of necessary packages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo yum install oddjob realmd samba samba-common oddjob-mkhomedir sssd adcli</strong></span>
</pre></div></div>
<div class="section" title="Using realm to manage domain enrolment" id="aid-23MNU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>Using realm to manage domain enrolment</h1></div></div></div><p>With these <a id="id299" class="indexterm"/>packages installed, we can use the <code class="literal">realm</code> <a id="id300" class="indexterm"/>command to manage our enrolments. This command is part of the <code class="literal">realmd</code> package that we added. We can use the list subcommand to ensure that we are not currently part of a domain:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ realm list</strong></span>
</pre></div><p>The output should be blank. Now, we are ready to proceed with the next step: joining the domain. With a simple environment, you will know the domain that you want to join; at least we certainly hope that you do. In our case, we do know it and this is <code class="literal">example.com</code>. Using the discover subcommand, we can verify that we have all the required packages installed, as shown in the following command extract:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ realm discover example.com</strong></span>
</pre></div><p>The output from this command will list that this is an Active Directory domain and the required packages that we should have in place before joining the AD domain. The following screenshot illustrates this:</p><div class="mediaobject"><img src="../Images/image00284.jpeg" alt="Using realm to manage domain enrolment"/></div><p style="clear:both; height: 1em;"> </p><p>Depending on your Active Directory functionality level, you may require either the <code class="literal">samba-windbind</code> or <code class="literal">sssd</code> packages. We are using Active Directory on 2008R2 with the default level of Windows Server 2003 configured. At this stage, you should verify that you have all the required packages installed.</p><div class="note" title="Note"><h3 class="title"><a id="tip27"/>Tip</h3><p>If we do not need to share resources we do not need the <code class="literal">samba</code> package; <code class="literal">samba</code> is only used to share, not to join domains.</p></div><p>As this is a Kerberos domain type, the <code class="literal">join</code> subcommand will join the server to the domain as a member server and initialize the <code class="literal">/etc/krb5.keytab</code> Kerberos keytab file and the <code class="literal">/etc/krb5.conf</code> configuration file. There will be more detail on these files that act behind the scenes given at the end of the chapter. To join the AD domain, add the computer to the default <a id="id301" class="indexterm"/>folder in the AD domain using the <a id="id302" class="indexterm"/>following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo realm join --user=administrator@example.com example.com</strong></span>
</pre></div><p>Should you want to add it to a designated Organizational Unit within the Active Directory, you will first need to create the OU, or at least ensure that it exists. With the OU being present, the command will be similar to the following, where we add to the Linux OU:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo realm join --computer-ou="OU=Linux" \ --user=administrator@example.com example.com</strong></span>
</pre></div><p>This is the method we will use to add the RHEL server to a path:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>OU=Linux,DC=example,DC=com</strong></span>
</pre></div><p>With either of these methods, you will be prompted for the domain administrator's password or the password of a user with delegated rights to add computers to the AD domain and your <code class="literal">sudo</code> user's password (if required). The command can take a few minutes to take effect, so give it time until the shell prompt is returned. As a standard user, you can then list the domain you have joined using the <code class="literal">realm list</code> command again. We should note that the output at first may seem similar to the <code class="literal">realm discover example.com</code> command that we ran earlier; however, on closer examination, we will see that we are now a member server, as shown by <code class="literal">configured: kerberos-member</code> in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ realm list</strong></span>
</pre></div><p>The output from the <a id="id303" class="indexterm"/>preceding command is shown <a id="id304" class="indexterm"/>in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00285.jpeg" alt="Using realm to manage domain enrolment"/></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="Logging on to RHEL 7 using Active Directory credentials" id="aid-24L8G1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec66"/>Logging on to RHEL 7 using Active Directory credentials</h1></div></div></div><p>Welcome <a id="id305" class="indexterm"/>to the world of centralized <a id="id306" class="indexterm"/>accounts. I think you will have to concede that the process was very simple using RHEL 7 and vastly more simple than the previous releases of RHEL. We are now ready to make use of central user accounts from the Active Directory.</p><p>To log on <a id="id307" class="indexterm"/>to the RHEL 7 server, we can use the Active Directory <span class="strong"><strong>UPN</strong></span> (<span class="strong"><strong>User Principal Name</strong></span>). This is in the format of <code class="literal">user@&lt;Fully Qualified Domain Name&gt;</code>. For example, if we have an account in the <code class="literal">example.com</code> domain named <code class="literal">jjones</code>, we can log on to the RHEL server using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jjones@example.com</strong></span>
</pre></div><p>The following screenshot shows this process as we use the <code class="literal">switch user</code> command to log on as the AD account for <code class="literal">jjones</code>. Note that as the home directory for <code class="literal">jjones</code> does not exist, <code class="literal">oddjob</code> kindly creates it for us, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00286.jpeg" alt="Logging on to RHEL 7 using Active Directory credentials"/></div><p style="clear:both; height: 1em;"> </p><p>To connect <a id="id308" class="indexterm"/>remotely using SSH <a id="id309" class="indexterm"/>tools, such as PuTTY for Windows, we will use the following syntax implementing two <code class="literal">@</code> symbols; this may look a little weird, but is correct:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jjones@example.com@192.168.0.69</strong></span>
</pre></div><p>An SSH connection to RHEL from the Windows PuTTY client is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00287.jpeg" alt="Logging on to RHEL 7 using Active Directory credentials"/></div><p style="clear:both; height: 1em;"> </p><p>We have now seen that we can make use of Active Directory accounts on our Linux systems. With the Red Hat server as part of our domain, we can log on to Linux with a single set of credentials. When a user leaves an organization, there is now only a solitary user account to delete or disable. We have seen this in action on a single server, but this equally applies to all your RHEL 7 or CentOS 7 servers and desktops; this process is the same across the board, making us efficient and secure.</p></div>
<div class="section" title="User and group management with adcli" id="aid-25JP21"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec67"/>User and group management with adcli</h1></div></div></div><p>We are not just <a id="id310" class="indexterm"/>restricted to consuming these domain accounts; we also <a id="id311" class="indexterm"/>have a level of management of Active Directory from the command line of our Linux servers. With the correct privileges in Active Directory, we can:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Create users and groups</li><li class="listitem">Modify group memberships</li><li class="listitem">Delete users and groups</li></ul></div><p>Although the tools are not as rich as you will find with the native OS, especially when using PowerShell, there is a need and advantage to some of the management provided by Linux devices.</p><p>If you are a Linux administrator and work mainly on Linux, it does make sense for you to add Active Directory users to groups that you use for delegation on Linux. For example, you can maintain an Active Directory group called <code class="literal">LinuxAdmins</code> and delegate rights via the <code class="literal">/etc/sudoers</code> file to this group. It's quite correct that you maintain and control the AD group and not necessarily the <code class="literal">Domain Admins</code> group in the AD.</p><div class="section" title="Listing the Active Directory information"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec42"/>Listing the Active Directory information</h2></div></div></div><p>To begin with the <a id="id312" class="indexterm"/>
<code class="literal">adcli</code> command, we will take a look at the <code class="literal">info</code> subcommand. This can display details on domains and the domain controllers that are discovered. We can run this command as a standard user, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adcli info example.com</strong></span>
</pre></div><p>The output will show the Active Directory roles for the domain controller and details on the site, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00288.jpeg" alt="Listing the Active Directory information"/></div><p style="clear:both; height: 1em;"> </p><p>In this way, we will be <a id="id313" class="indexterm"/>able to verify the connection and the domain controller that we are connected to.</p></div><div class="section" title="Creating Active Directory users"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec43"/>Creating Active Directory users</h2></div></div></div><p>This command is <a id="id314" class="indexterm"/>probably not one of the most useful tools given that we can create the user, but can't enable the account or set the password for the new user. In this way, the command is less useful than some of the other tools with <code class="literal">adcli</code>. A sample command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adcli create-user fjones --domain=example.com --display-name="Fred Jones"</strong></span>
</pre></div><p>This command will try to log on to a domain as an administrator and will prompt for the password. To log on as a different user, you may make use of the <code class="literal">-U</code> or <code class="literal">--login-user</code> option.</p><p>For completeness, we cover the <code class="literal">create user</code> command, but in reality, the user will still need to be enabled and have the password set in the Active Directory.</p><p>To delete the account we just created, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adcli delete-user  --domain=example.com fjones</strong></span>
</pre></div></div><div class="section" title="Creating Active Directory groups"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec44"/>Creating Active Directory groups</h2></div></div></div><p>In many respects, the <a id="id315" class="indexterm"/>
<code class="literal">adcli</code> command is very useful to us as Linux administrators. So, as long as our domain accounts have rights to create and manage groups in the AD, it's correct that we should be the ones managing the group membership that affect the Linux access. Assuming that the user accounts are already created, we do not need to concern ourselves with password management on the creation and membership of these groups. We will use the administrator account while accessing the domain as before, but we could use our own account if it had the privileges.</p><p>To create the Linux users group in the Linux OU where we have placed the server, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adcli create-group --domain=example.com \ --domain-ou="OU=Linux,DC=example,dc=com" "Linux Users"</strong></span>
</pre></div><p>We can verify that this has worked as expected by navigating to the <span class="strong"><strong>OU</strong></span> (<span class="strong"><strong>Organizational Unit</strong></span>) within the Active <a id="id316" class="indexterm"/>Directory users and computers on the domain controller. In the following screenshot, we can see that we have the server group and the new group:</p><div class="mediaobject"><img src="../Images/image00289.jpeg" alt="Creating Active Directory groups"/></div><p style="clear:both; height: 1em;"> </p><p>We will keep the created group as it is, because we will add users to it; the process of deleting a group is similar to the process of deleting a user, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adcli delete-group  --domain=example.com "Linux Users"</strong></span>
</pre></div><p>Should we need help on any command, we can issue syntax help with commands similar to the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adcli delete-group --help</strong></span>
</pre></div><p>Just use the correct <a id="id317" class="indexterm"/>subcommand that you need help with.</p></div><div class="section" title="Managing the Active Directory group membership"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec45"/>Managing the Active Directory group membership</h2></div></div></div><p>Now that we have the <a id="id318" class="indexterm"/>Linux users group, we can manage the membership of this group. Within the AD domain, we have the <code class="literal">jjones</code> user that we can add to this group. The following command shows how this is done using our domain:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adcli add-member  --domain=example.com "Linux Users" jjones</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip28"/>Tip</h3><p>Other than when you create a group or user in a given context, we can refer to the object by the <code class="literal">SAMAccountName</code> attribute alone (the user or group name). This is a unique identifier in a domain. In the preceding example, we can simply refer to the group as <code class="literal">Linux Users</code> and the user as <code class="literal">jjones</code>. Quotes are required to protect the space used in the group name.</p></div></div></div>
<div class="section" title="Delegating Active Directory accounts with sudo" id="aid-26I9K1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Delegating Active Directory accounts with sudo</h1></div></div></div><p>Being <a id="id319" class="indexterm"/>able to manage the Active Directory group membership is fundamental to our management of Linux. We can assign the ownership of files and directories to these groups and (more importantly) the delegate rights on the system using the <code class="literal">/etc/sudoers</code> file.</p><p>Let's see how this delegation works. We will create a new group in the Active Directory and add an administrator to this group. As a simple setup, we are limited to users that we have created, as shown in the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adcli create-group  --domain=example.com \ --domain-ou="OU=Linux,DC=example,dc=com" "Linux Admins"</strong></span>
<span class="strong"><strong>$ adcli add-member  --domain=example.com "Linux Admins" Administrator</strong></span>
</pre></div><p>We now have two groups that we may want to use for delegation: <code class="literal">Linux Users</code> and <code class="literal">Linux Admins</code>. To delegate with the <code class="literal">sudoers</code> system, we run the <code class="literal">visudo</code> command as a root user or with <code class="literal">sudo</code>. This file can be used as delegation, which allows selected commands to be run as root by selected users. These commands have to be prefaced with the <code class="literal">sudo</code> command. You can think of <code class="literal">sudo</code> as a similar command to <code class="literal">runas</code> in a Windows system:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo visudo</strong></span>
</pre></div><p>This will open the <code class="literal">/etc/sudoers</code> file for editing purposes. We can use <code class="literal">G</code> to move towards the end of the file and then <code class="literal">o</code> to insert a new line.</p><p>We will add <a id="id320" class="indexterm"/>these two lines of code to the <code class="literal">/etc/sudoers</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%Linux\ Admins@example.com ALL=(root) ALL %Linux\ Users@example.com ALL=(root) /sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip29"/>Tip</h3><p>Note the use of <code class="literal">\</code> to protect the space here. This is required because the <code class="literal">sudoers</code> file does not like the use of quotes.</p></div><p>The Linux admins group is allowed to run all commands on the system as root using <code class="literal">sudo</code>. The Linux users group can run the <code class="literal">mount</code> and <code class="literal">umount</code> commands only to mount and unmount the <code class="literal">cdrom</code> device.</p><p>With all the changes made in <code class="literal">vi</code>, we can use the <code class="literal">ESC</code> key to exit and <code class="literal">:x</code> to save and exit the insert mode.</p><p>The following screenshot from the example system shows the changes as they should appear:</p><div class="mediaobject"><img src="../Images/image00290.jpeg" alt="Delegating Active Directory accounts with sudo"/></div><p style="clear:both; height: 1em;"> </p><p>When we log on as <code class="literal">jjones</code>, We will now find that we have the membership of the <code class="literal">Linux Users</code> group and <code class="literal">Linux Admins</code> for the <code class="literal">Administrator</code>. Additionally, both users will belong to the <code class="literal">Domain Users</code> group.</p><p>We can run the following command as a user of either group:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ id -Gn</strong></span>
</pre></div><p>The preceding command will display the group names that the user belongs to. The domain administrator account will have several group memberships, but it will importantly include the <code class="literal">Linux Admins</code> group. This will allow users to run all commands prefixed with <code class="literal">sudo</code> so that they can run as root, as we have seen with the <code class="literal">andrew</code> account that had similar rights delegated.</p><p>The following screenshot shows the output of the <code class="literal">id</code> command when it is run as the administrator:</p><div class="mediaobject"><img src="../Images/image00291.jpeg" alt="Delegating Active Directory accounts with sudo"/></div><p style="clear:both; height: 1em;"> </p><p>We can also assign the filesystem ownership to users and groups from the directories. While we are still logged in to the RHEL 7.1 system as the domain administrator account, we will prove that the <code class="literal">sudo</code> entry is correct by changing the group ownership of a directory; this is something normally reserved for root:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo chgrp Linux\ Usersexample.com /data</strong></span>
<span class="strong"><strong>$ ls -ld /data</strong></span>
</pre></div><p>In the preceding <a id="id321" class="indexterm"/>example, we changed the group ownership of the <code class="literal">/data</code> directory to the <code class="literal">Linux Users</code> group; subsequently, we displayed the ownership of the directory as well. For additional clarity, we have included a screenshot to demonstrate this process:</p><div class="mediaobject"><img src="../Images/image00292.jpeg" alt="Delegating Active Directory accounts with sudo"/></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="Leaving a domain" id="aid-27GQ61"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Leaving a domain</h1></div></div></div><p>Until now, we <a id="id322" class="indexterm"/>have been able to demonstrate true interoperability with the Active Directory through the use of delegated permissions using <code class="literal">sudo</code> and ownership of files and directories with filesystems. This is outstanding and nothing <a id="id323" class="indexterm"/>less than what you would expect from an Enterprise Linux system; however outstanding this may be, there will be occurrences where the Linux server needs to be removed from a domain. Often, this is the case where it is removed from one domain before being added to another. Should this be required, the realm command makes the process easy, reversing the operation to the <code class="literal">join</code> subcommand as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo realm leave example.com --remove</strong></span>
</pre></div><p>The additional option: <code class="literal">--remove</code> will ensure that the computer account is also deleted from the domain; otherwise, it should be deleted separately. For the moment, we will leave the computer in the domain.</p></div>
<div class="section" title="Understanding Active Directory as an identity provider for sssd"><div class="titlepage" id="aid-28FAO2"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Understanding Active Directory as an identity provider for sssd</h1></div></div></div><p>In many ways, something this simple is very welcome on Linux; however, the simplicity is in masking the <a id="id324" class="indexterm"/>complex series of events <a id="id325" class="indexterm"/>and procedures that occur behind the scenes. It's now time to delve into what makes <code class="literal">sssd</code> work.</p><p>We first need to remind ourselves of all the configurations that we added in the only manual part of the process, that is, setting up the infrastructure services of time and DNS required for integration into the Active Directory. The following diagram shows the relationship between the RHEL server and Active Directory:</p><div class="mediaobject"><img src="../Images/image00293.jpeg" alt="Understanding Active Directory as an identity provider for sssd"/></div><p style="clear:both; height: 1em;"> </p><p>When we interrogated the Active Directory domain with <code class="literal">realm</code>, we could see from the resulting information that we required the <code class="literal">sssd</code> package among others. The System Security Services Daemon (<code class="literal">sssd</code>) provides a set of daemons to manage access to remote directories and authenticate mechanisms, in our case, the Active Directory. The <code class="literal">sssd </code>service provides the <span class="strong"><strong>NSS</strong></span> (<span class="strong"><strong>Name Service Switch</strong></span>) and <span class="strong"><strong>PAM</strong></span> (<span class="strong"><strong>Pluggable Authentication Mechanism</strong></span>) interface for our system and a modular backend system to connect to multiple different account sources and the D-bus interface as well. With this in mind, we should understand that both NSS and PAM modules have been added and configured for us on the system.</p><p>Identifying <a id="id326" class="indexterm"/>accounts on the remote Active <a id="id327" class="indexterm"/>Directory is performed over LDAP and authentication is done via Kerberos to the AD domain. The LDAP account search is referenced and calls for the <code class="literal">/usr/lib64/libnss_sss.so.2</code> NSS module and the <code class="literal">/etc/nsswitch.conf</code> file. Authentication will be referenced using <code class="literal">/lib64/security/pam_nss.so</code>.</p><p>We can expand the relationship diagram to include <code class="literal">sssd</code> as follows:</p><div class="mediaobject"><img src="../Images/image00294.jpeg" alt="Understanding Active Directory as an identity provider for sssd"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="Configuring NSS"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec46"/>Configuring NSS</h2></div></div></div><p>The <span class="strong"><strong>Name Service Switch </strong></span>(<span class="strong"><strong>NSS</strong></span>) configuration file, <code class="literal">/etc/nsswitch.conf</code>, is used by various NSS libraries; one of the NSS libraries is <code class="literal">/usr/lib64/libnss_sss.so.2</code>. The NSS configuration file <a id="id328" class="indexterm"/>determines the sources from which you can obtain the name service information and its order from a range of categories. Each category of information is identified by a resource database name; this can be <code class="literal">hosts</code> for name resolution and <code class="literal">passwd</code> for a database to locate user accounts.</p><p>In my opinion, the simplest approach is to use the <code class="literal">hosts</code> database to explain how these forces work. The entry in the <code class="literal">/etc/nsswitch.conf</code> for hosts is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>hosts:      files dns</strong></span>
</pre></div><p>With the settings in effect, the preceding name resolution is achieved by first resolving names from the <code class="literal">/etc/hosts</code> local file and then via DNS resolver libraries. If you reversed these entries, the DNS will be checked before the local file.</p><p>If we check for <code class="literal">sss</code> within a file, we can see all the databases that rely on a particular library. The <code class="literal">grep</code> command can be used to isolate these entries, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep sss /etc/nsswitch.conf</strong></span>
</pre></div><p>The result of the query should look similar to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00295.jpeg" alt="Configuring NSS"/></div><p style="clear:both; height: 1em;"> </p><p>These are default settings, but we are not forced to accept them; we can implement changes if required. However, this order is probably the best as it allows local accounts to be resolved before searching for a domain (not that domain accounts will clash because they are specified with the full UPN of the user.</p><p>The database names are explained here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">passwd</code>: This specifies the user accounts</li><li class="listitem"><code class="literal">shadow</code>: This denotes the password information</li><li class="listitem"><code class="literal">group</code>: This specifies the group accounts</li><li class="listitem"><code class="literal">services</code>: This denotes the service name resolution</li><li class="listitem"><code class="literal">netgroup</code>: This specifies the groups of hosts that can be used in access control rules</li><li class="listitem"><code class="literal">automount</code>: This denotes the directories to be auto-mounted by <code class="literal">autofs</code></li></ul></div><p>In many setups, it's easy to disable the bottom three elements: <code class="literal">services</code>, <code class="literal">netgroup</code>, and <code class="literal">automount</code>. This will help tune the directory access, for example, if you leave the default settings when you run tools, such as <code class="literal">netstat</code>, to query which ports are open on the server, you will also run an LDAP <a id="id329" class="indexterm"/>query in the AD to resolve port addresses to service names with the service database entry in the <code class="literal">/etc/nsswitch.conf</code>.</p><p>The entry for the services will read similar to the following command to prevent LDAP lookups:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>services: files</strong></span>
</pre></div></div><div class="section" title="Configuring PAM"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec47"/>Configuring PAM</h2></div></div></div><p>We can often leave <span class="strong"><strong>Pluggable Authentication Modules</strong></span> (<span class="strong"><strong>PAM</strong></span>) as they are, but we will look at their configuration here.</p><p>The services that can use PAM <a id="id330" class="indexterm"/>are configured with the associated PAM modules that they should use within a file in the <code class="literal">/etc/pam.d</code> directory. The can be in individual files, such as <code class="literal">/etc/pam.d/login</code>, or through command files that are referenced by many services (such as <code class="literal">/etc/pam.d/system-auth-ac</code>).</p><p>We can display the configuration that <code class="literal">sssd</code> uses with PAM using <code class="literal">grep</code> again to filter <code class="literal">sss</code> from the <code class="literal">/etc/pam.d/system-auth-ac</code> file. The output is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00296.jpeg" alt="Configuring PAM"/></div><p style="clear:both; height: 1em;"> </p><p>We can see that the authentication module is used for all possible triggers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">auth</code>: This is used during authentication</li><li class="listitem"><code class="literal">account</code>: This is used for account restrictions</li><li class="listitem"><code class="literal">password</code>: This is used for password change events</li><li class="listitem"><code class="literal">session</code>: This is used during a logged in session</li></ul></div><p>Let's see some arguments (such as <code class="literal">use_first_pass</code>) that are used with the authentication module. Some <a id="id331" class="indexterm"/>of the possible arguments are stated as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">forward_pass</code>: The entered password can be used for other modules</li><li class="listitem"><code class="literal">use_first_pass</code>: Does not prompt for a password, but uses a previously entered password</li><li class="listitem"><code class="literal">use_authtok</code>: When changing a password, the previously entered password can be used to authenticate the password change</li><li class="listitem"><code class="literal">retry=N</code>: If this is set, the user can be prompted more than once for the password if they enter the wrong password</li></ul></div></div><div class="section" title="Configuring Kerberos"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec48"/>Configuring Kerberos</h2></div></div></div><p>When you join a domain <a id="id332" class="indexterm"/>using realm, the <code class="literal">/etc/krb5.conf</code> keytab file is created to authenticate the RHEL system to the domain alongside the <code class="literal">/etc/krb5.conf</code> file. Having tidied the file, after removing comments for our domain, the file looks similar to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00297.jpeg" alt="Configuring Kerberos"/></div><p style="clear:both; height: 1em;"> </p><p>We can see that the <code class="literal">/etc/krb5.conf</code> file has four sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">logging</code></li><li class="listitem"><code class="literal">libdefaults</code></li><li class="listitem"><code class="literal">realms</code></li><li class="listitem"><code class="literal">domain_realm</code></li></ul></div><p>As the demonstration lab is very small with just a single domain controller, there is no need to make changes. If you have a larger setup, you may want to add some more details to the realm. You can point to the local <a id="id333" class="indexterm"/>domain controllers holding the correct roles; otherwise, just let the DNS service records resolve these records as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[realms]</strong></span>
<span class="strong"><strong>EXAMPLE.COM {</strong></span>
<span class="strong"><strong> kdc = ad1.example.com</strong></span>
<span class="strong"><strong> admin_server = ad1.example.com</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></div><div class="section" title="Configuring SSSD"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec49"/>Configuring SSSD</h2></div></div></div><p>The configuration for <code class="literal">sssd</code> <a id="id334" class="indexterm"/>can be found in the <code class="literal">/etc/sssd/sssd.conf</code> file. We have seen that this works for us by default, but there is room for customization, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00298.jpeg" alt="Configuring SSSD"/></div><p style="clear:both; height: 1em;"> </p><p>A simple change here will be to change the home directory location of the AD users. By default, this is <code class="literal">/home/example.com/username</code>. If you have added the Unix extensions to the Active Directory<a id="id335" class="indexterm"/>, then we will set <code class="literal">ldap_id_mapping</code> to <code class="literal">false</code> and the UID and GID will be set in the Active Directory.</p></div></div>
<div class="section" title="Summary" id="aid-29DRA1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Summary</h1></div></div></div><p>In this chapter, we looked at how to use the Active Directory as an identity store, utilizing users and groups on Linux. The ease of setting this up makes this a very usable and much-needed solution within corporations throughout the world.</p><p>There is a little bit of ground work required before setting up the time and DNS. Once this is set, then configuring <code class="literal">sssd</code> to use Active Directory as an identity source with the command realm is really a doddle.</p><p>With the RHEL system in the AD domain, we can manage this domain to a degree with <code class="literal">adcli</code> and give users' access to the Linux command line through a console or via SSH.</p><p>Next up, we will be staying a little with file sharing, but this time, we will use the Apache HTTPD web server.</p></div></body></html>