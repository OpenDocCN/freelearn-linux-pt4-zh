- en: Chapter 3. Creating Your CoreOS Cluster and Managing the Cluster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：创建您的CoreOS集群并管理集群
- en: This chapter covers CoreOS clustering, providing information on the concepts
    and benefits of clustering. We will also learn how to set up clusters and get
    familiar with all the services involved in clustering with greater detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖CoreOS集群，提供有关集群概念和好处的信息。我们还将学习如何设置集群，并更详细地熟悉集群中涉及的所有服务。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introduction to clustering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群简介
- en: The why and the benefits of clustering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群的原因与好处
- en: CoreOS clustering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreOS集群
- en: Creating a CoreOS cluster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个CoreOS集群
- en: Discovery using etcd
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用etcd进行发现
- en: Systemd
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Systemd
- en: Service deployment and High Availability (HA) using fleet
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fleet进行服务部署和高可用性（HA）
- en: Introduction to clustering
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群简介
- en: There are two ways to scale a system. One is to scale vertically, that is, by
    adding more hardware resources to a machine. If the memory requirement of the
    system increases, add more memory; if more processing is required, upgrade the
    machine to one using higher-end processors or providing a higher number of cores.
    Horizontal scaling is another way to scale a system to higher capacity. This means
    adding more machines when required to form a cluster of nodes. This cluster of
    nodes work in tandem to provide service. The nodes in the cluster may have applications
    performing the same role like a pool or they may perform a different role.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以扩展系统。一种是垂直扩展，即通过向机器添加更多硬件资源来实现。如果系统的内存需求增加，就增加更多内存；如果需要更多的处理能力，则将机器升级为使用更高端处理器或提供更多核心的机器。水平扩展是另一种将系统扩展到更高容量的方法。这意味着根据需要增加更多的机器，形成一个节点集群。这些节点集群协同工作提供服务。集群中的节点可能会有执行相同角色的应用程序，如池，或者它们可能执行不同的角色。
- en: The why and the benefits of clustering
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群的原因与好处
- en: Horizontal scalability of a system is limited by hardware resources available
    in the market. For instance, scaling up RAM from 8 GB to 32 or 64 GB may be cost
    effective, as many products may be commonly available, but increasing it further
    may be cost inhibitive. Similarly, scaling up CPU is also limited by system configuration
    available in the market. Further doubling the hardware capability doesn't result
    in equal performance improvements. It's typically less.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的水平可扩展性受限于市场上可用的硬件资源。例如，将内存从8 GB扩展到32 GB或64 GB可能是具有成本效益的，因为许多产品可能普遍可用，但进一步增加内存可能会变得非常昂贵。类似地，扩展CPU也受到市场上系统配置的限制。进一步增加硬件能力并不会带来相等的性能提升，通常是较少的。
- en: 'With virtualization and cloud services, the cost of buying and maintaining
    hardware is coming down, making vertical scaling or clustering or scaling out
    more is lucrative. The increased performance of communication networks has considerably
    reduced the latency in the communication of nodes in the cluster. Clustering has
    various advantages, such as:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着虚拟化和云服务的发展，购买和维护硬件的成本正在下降，使得垂直扩展、集群扩展或水平扩展变得更加有吸引力。通信网络的性能提升大大减少了集群中节点之间通信的延迟。集群有多种优点，例如：
- en: '**On-demand scaling**: The nodes in the cluster can be added as and when required.
    We can start with a dimensioned system and keep on adding nodes as capacity increases.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需扩展**：集群中的节点可以根据需要随时添加。我们可以从一个有规模的系统开始，随着容量的增加不断添加节点。'
- en: '**Dynamic scaling**: Most of the clustering solutions provide a mechanism to
    add/remove nodes at runtime. Hence, the system as a whole will be up and running
    for providing service while cluster modifications are being performed.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态扩展**：大多数集群解决方案提供在运行时添加/删除节点的机制。因此，在进行集群修改时，整个系统仍然可以正常运行并提供服务。'
- en: '**Redundancy**: A cluster can be configured with few spare nodes. Upon failure
    of any nodes or during planned or unplanned maintenance of nodes, these spare
    nodes can be assigned to the role of the failed node or nodes under maintenance
    without impacting service capacity.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余**：集群可以配置少量备用节点。在任何节点发生故障或在计划内或计划外的节点维护期间，这些备用节点可以被分配为故障节点或维护节点的角色，而不会影响服务容量。'
- en: It's also important to know about the shortcomings of clusters to make an informed
    decision while architecting a system. As the number of nodes increase, the complexity
    in the management of those nodes also increases. All the nodes need to be monitored
    and maintained. The software also has to be designed to be able to run on multiple
    nodes. There comes a requirement for an orchestration mechanism to orchestrate
    the applications across different instances in the cluster. For instance, load
    balancers to distribute load across worker nodes, or job serializers to synchronize
    and serialize a job across nodes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 了解集群的缺点也很重要，这样可以在设计系统时做出明智的决策。随着节点数量的增加，管理这些节点的复杂性也会增加。所有节点都需要进行监控和维护。软件也必须设计成能够在多个节点上运行。这就需要一个编排机制来协调集群中不同实例的应用。例如，负载均衡器将负载分配到工作节点，或作业序列化器用来同步和序列化跨节点的作业。
- en: CoreOS clustering
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoreOS集群
- en: '[Chapter 1](part0014_split_000.html#DB7S1-31555e2039a14139a7f00b384a5a2dd8
    "Chapter 1. CoreOS, Yet Another Linux Distro?"), *CoreOS, Yet Another Linux Distro*
    covers CoreOS cluster architecture. We will summarize it here again. A CoreOS
    member or node can contain multiple Docker containers. There can be multiple CoreOS
    members forming a CoreOS cluster.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](part0014_split_000.html#DB7S1-31555e2039a14139a7f00b384a5a2dd8 "第1章.
    CoreOS，另一个Linux发行版？")，*CoreOS，另一个Linux发行版*介绍了CoreOS集群架构。我们将在这里再次总结它。一个CoreOS成员或节点可以包含多个Docker容器。可以有多个CoreOS成员组成一个CoreOS集群。'
- en: CoreOS uses fleet to schedule and manage the services using `systemd` onto the
    CoreOS members during initialization. This is similar to the `systemd` starting
    and managing service on Linux machines. The scope of the Linux `systemd` process
    is limited to a host node, whereas CoreOS `fleetd` is the init system for a complete
    CoreOS cluster.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS使用fleet在初始化期间通过`systemd`调度和管理服务到CoreOS成员。这类似于在Linux机器上由`systemd`启动和管理服务。Linux的`systemd`进程范围仅限于主机节点，而CoreOS的`fleetd`是完整CoreOS集群的初始化系统。
- en: CoreOS uses etcd for node discovery and storing key-value pairs of configuration
    items accessible across a cluster member.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS使用etcd进行节点发现和存储可在集群成员之间访问的配置项的键值对。
- en: 'It''s possible to set up a cluster in two ways:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过两种方式来设置集群：
- en: '**etcd running on all members**: When the number of members of the cluster
    is few, then etcd can be run on all the members running the services, also called
    workers. This configuration is simpler as the same `cloud-config` can be used
    to start all the members of the cluster.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd运行在所有成员上**：当集群的成员较少时，可以在所有运行服务的成员上运行etcd，也称为工作节点。这种配置更简单，因为相同的`cloud-config`文件可以用于启动集群中的所有成员。'
- en: '**etcd running on few members**: When the number of members in the cluster
    is large, typically greater than ten, it is advisable to run `etcd` and other
    CoreOS cluster services exclusively on some of the machines. This becomes easier
    to dimension the platform configuration of the worker members as they are exclusively
    used for providing services. In this, two `cloud-config` files are required: one
    for CoreOS cluster services including etcd, and the other for workers or proxies.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd运行在少数成员上**：当集群中的成员数量较多，通常大于十个时，建议将`etcd`和其他CoreOS集群服务专门运行在部分机器上。这使得为工作成员配置平台变得更加容易，因为它们专门用于提供服务。在这种情况下，需要两个`cloud-config`文件：一个用于CoreOS集群服务，包括etcd，另一个用于工作节点或代理。'
- en: The setting of CoreOS clusters is fairly simple. Prepare the `cloud-config`
    file and start booting members using the file. Small scripting knowledge is required
    to regenerate the configuration files per member. The discovery service and etcd
    use the discovery token or static token provided to form a cluster as the members
    are started.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS集群的设置相当简单。准备`cloud-config`文件并使用该文件启动成员。需要一些脚本知识来为每个成员重新生成配置文件。发现服务和etcd使用提供的发现令牌或静态令牌来形成集群，当成员被启动时。
- en: Cluster discovery
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群发现
- en: 'This section describes the various discovery mechanisms used by CoreOS to form
    a cluster. For the examples in this chapter, the following is the system configuration:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了CoreOS用于形成集群的各种发现机制。在本章中的示例中，以下是系统配置：
- en: '![Cluster discovery](img/00015.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![集群发现](img/00015.jpeg)'
- en: Static discovery
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态发现
- en: The **static discovery** mechanism is used when the IP addresses of the members
    are known beforehand. IPs are preconfigured in the `cloud-config` file. They are
    useful in scenarios where the cluster size is small and can be generally used
    for test setups. Configuring large numbers of hardcoded IPs will be error prone
    and a maintenance nightmare.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态发现**机制用于成员的IP地址已知的情况。IP地址预先配置在`cloud-config`文件中。它们适用于集群规模较小的场景，通常可用于测试设置。配置大量硬编码IP将容易出错，且维护起来十分麻烦。'
- en: 'The following is the `cloud-config` file that is used to create a cluster using
    static discovery:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于通过静态发现创建集群的`cloud-config`文件：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are two new fields that were not discussed before. The `name` field provides
    the name of the member. This is also used to correlate the member to the URL in
    `initial-cluster`. The `initial-cluster` field provides the member name and URL
    of all the members of the cluster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个新的字段之前没有讨论过。`name`字段提供成员的名称。这个名称还用于将成员与`initial-cluster`中的URL关联起来。`initial-cluster`字段提供集群中所有成员的名称和URL。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The IP addresses provided in the initial-cluster field should contain the static
    IP address.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initial-cluster`字段中提供的IP地址应包含静态IP地址。
- en: In order to create the previously mentioned `cloud-config` file, for all the
    nodes that want to be part of the cluster, the following steps need to be performed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建前述的`cloud-config`文件，需要对所有希望加入集群的节点执行以下步骤。
- en: '`Vagrantfile` should contain static IP addresses allocated to each member.
    As shown in the following sample, IP `172.17.8.101` is assigned to the first member,
    IP `172.17.8.102` is assigned to the second member, and so on:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vagrantfile`应该包含分配给每个成员的静态IP地址。如以下示例所示，IP `172.17.8.101`分配给第一个成员，IP `172.17.8.102`分配给第二个成员，依此类推：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You might have noticed the `cloud-config` file contains the name of only one
    member, but the `systemd` `unit` file for the `etcd` service in each CoreOS VM
    should contain its own member name. This requires the following instrumentation
    in `Vagrantfile` to generate the `cloud-config` file specific to each member.
    Without going into the specifics of `ruby`, the following code modifies the name
    parameter for each member and stores in a separate file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，`cloud-config`文件中仅包含一个成员的名称，但每个CoreOS虚拟机中的`etcd`服务的`systemd` `unit`文件应该包含其自己的成员名称。这需要在`Vagrantfile`中进行如下配置，以生成特定于每个成员的`cloud-config`文件。无需深入`ruby`的具体细节，以下代码修改每个成员的`name`参数并将其存储在单独的文件中。
- en: 'The generated file is `user-data-1` for the first member, `user-data-2` for
    the second member, and so on. Except for the `name` field, all other parameters
    are used from the `cloud-config` file provided. The generated files are used during
    boot-up of Virtual Machines:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件是`user-data-1`用于第一个成员，`user-data-2`用于第二个成员，以此类推。除了`name`字段，所有其他参数都来自提供的`cloud-config`文件。生成的文件在虚拟机启动时使用：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set `$num_instances` to `3` in the `config.rb` file and setup is complete for
    a three-member cluster:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config.rb`文件中将`$num_instances`设置为`3`，并完成三成员集群的设置：
- en: Boot the cluster using `Vagrant up`. Upon successful boot-up, we can see the
    members of the cluster.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Vagrant up`启动集群。启动成功后，我们可以看到集群的成员。
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: etcd discovery
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: etcd 发现
- en: 'The `etcd` discovery mechanism is used when the IP addresses of the members
    are not known in advance or DHCP is used to assign IP addresses. There can be
    two modes of discovery: public and custom.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当成员的IP地址事先不知道或使用DHCP分配IP地址时，会使用`etcd`发现机制。发现可以有两种模式：公共模式和自定义模式。
- en: If the cluster has access to the public IP, the public discovery service `discovery.etcd.io`
    can be used to generate a token and manage cluster membership. Access the website
    [https://discovery.etcd.io/new?size=<clustersize>](https://discovery.etcd.io/new?size=<clustersize>)
    and generate a token. Note that cluster size is required to be provided while
    generating a token.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集群可以访问公共IP，可以使用公共发现服务`discovery.etcd.io`生成令牌并管理集群成员。访问网站[https://discovery.etcd.io/new?size=<clustersize>](https://discovery.etcd.io/new?size=<clustersize>)并生成令牌。请注意，生成令牌时需要提供集群大小。
- en: '![etcd discovery](img/00016.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![etcd discovery](img/00016.jpeg)'
- en: 'Generation of a token can be automated in the `config.rb` file by uncommenting
    the following lines:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过取消注释以下行，可以在`config.rb`文件中自动生成令牌：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the `cloud-config` file that is used to create a cluster using
    public `etcd` discovery:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于通过公共`etcd`发现创建集群的`cloud-config`文件：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Set `$num_instances` to `3` in the `config.rb` file and setup is complete for
    a three-member cluster. Compared to static discovery, this is a simpler process
    and no instrumentation is required in `Vagrantfile`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `config.rb` 文件中将 `$num_instances` 设置为 `3`，并完成三成员集群的设置。与静态发现相比，这是一个更简单的过程，且不需要在
    `Vagrantfile` 中进行额外配置。
- en: 'Boot the cluster using `Vagrant up`. Upon successful boot-up, we can see the
    members of the cluster:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Vagrant up` 启动集群。成功启动后，我们可以看到集群的成员：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of using a public discovery, an `etcd` instance can be used as the discovery
    service to manage cluster membership. One of the `etcd` instances is configured
    with the token and number of cluster instances and other `etcd` instances use
    it to join to the cluster.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用公共发现外，还可以使用一个 `etcd` 实例作为发现服务来管理集群成员。一台 `etcd` 实例配置了令牌和集群实例数量，其他 `etcd`
    实例使用该实例加入集群。
- en: 'The following is the `cloud-config` file that is used to create a cluster using
    public `etcd` discovery:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于通过公共 `etcd` 发现创建集群的 `cloud-config` 文件：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The token can be generated using the `uuidgen` Linux command. The path `v2/keys/discovery`
    is where cluster information is stored. Any path can be provided. Machine one
    is used as the custom discovery node.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌可以通过 `uuidgen` Linux 命令生成。路径 `v2/keys/discovery` 是存储集群信息的地方。可以提供任何路径。第一台机器用作自定义发现节点。
- en: 'The `etcd` service running on machine one doesn''t need a discovery token since
    it is not going to be part of the cluster. This requires the following instrumentation
    in `Vagrantfile` to generate the `cloud-config` file separately for machine one
    and other machines. The following code modifies the name parameter for each member,
    removes unwanted parameters for machine one, and stores in a separate file for
    each member. In the following sample, the parameters that are not required are
    set to empty; they can be deleted:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在第一台机器上的 `etcd` 服务不需要发现令牌，因为它不会成为集群的一部分。这要求在 `Vagrantfile` 中进行以下配置，为第一台机器和其他机器分别生成
    `cloud-config` 文件。以下代码修改了每个成员的 name 参数，移除了第一台机器的不需要的参数，并为每个成员单独存储文件。在以下示例中，不需要的参数设置为空；也可以删除这些参数：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Set `$num_instances` to `3` in the `config.rb` file and boot the cluster using
    `Vagrant` `up`. Initially, the cluster formation will fail as the number of nodes
    corresponding to the discovery token is not set. Set the number of nodes as `2`
    in the cluster. The path provided in the discovery token URL should match the
    path provided in the URL.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `config.rb` 文件中将 `$num_instances` 设置为 `3`，然后使用 `Vagrant` `up` 启动集群。最初，集群的创建会失败，因为与发现令牌对应的节点数量未设置。将集群的节点数量设置为
    `2`。发现令牌 URL 中提供的路径应与 URL 中提供的路径匹配。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Upon setting the node size, we can see the members in the cluster. This time,
    we additionally need to provide the endpoint information on which `etcd` is listening
    as the `cloud-config` file contains a specific IP address instead of wildcard
    IPs in the previous examples:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设置节点大小后，我们可以看到集群中的成员。这时，我们还需要提供 `etcd` 正在监听的端点信息，因为 `cloud-config` 文件包含的是特定的
    IP 地址，而不是前面示例中的通配符 IP。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: DNS discovery
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DNS 发现
- en: Cluster discovery can also be performed using DNS SRV records. Contact your
    system administrator to create DNS SRV records to map the hostname to the service.
    DNS A records should also be created to map the hostname to the IP address of
    the members.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 集群发现也可以通过 DNS SRV 记录来执行。请联系系统管理员创建 DNS SRV 记录，将主机名映射到服务。还应创建 DNS A 记录，将主机名映射到成员的
    IP 地址。
- en: 'The DNS domain name containing the discovery SRV records is required to be
    provided using the `discovery-srv` parameter. The following DNS SRV records are
    looked up in the listed order:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 必须通过 `discovery-srv` 参数提供包含发现 SRV 记录的 DNS 域名。以下 DNS SRV 记录按照列出的顺序进行查找：
- en: _etcd-server-ssl._tcp.<domain name>
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _etcd-server-ssl._tcp.<domain name>
- en: _etcd-server._tcp.<domain name>
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _etcd-server._tcp.<domain name>
- en: If `_etcd-server-ssl._tcp.<domain name>` is found then `etcd` will attempt the
    bootstrapping process over SSL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到 `_etcd-server-ssl._tcp.<domain name>`，则 `etcd` 将尝试通过 SSL 执行引导过程。
- en: 'The following SRV and DNS A records are to be created:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要创建的 SRV 和 DNS A 记录：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the `cloud-config` file that is used to create a cluster using
    public `etcd` discovery:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于通过公共 `etcd` 发现创建集群的 `cloud-config` 文件：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `cloud-config` file contains additional section write-files to point to
    the DNS server where SRV and A records are created.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`cloud-config` 文件包含额外的 section write-files，指向创建 SRV 和 A 记录的 DNS 服务器。'
- en: Set `$num_instances` to `3` in the `config.rb` file and setup is complete for
    a three-member cluster. Compared to static discovery, this is a simpler process
    and no instrumentation is required in `Vagrantfile`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `config.rb` 文件中将 `$num_instances` 设置为 `3`，三成员集群的设置即完成。与静态发现相比，这是一个更简单的过程，并且在
    `Vagrantfile` 中不需要额外的配置。
- en: 'Boot the cluster using `Vagrant up`. Upon successful boot-up, we can see the
    members of the cluster:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Vagrant up` 启动集群。成功启动后，我们可以看到集群的成员：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: systemd
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: systemd
- en: '`systemd` is an init system that most of the Linux distribution, including
    CoreOS, has adopted to start other services/daemons during boot-up. `systemd`
    is designed to run multiple operations required to start services in parallel,
    resulting in faster boot-up. `systemd` manages services, devices, sockets, disk
    mounts, and so on, called units. systemd performs operations like start, stop,
    enable, and disable on the units. Each unit has a corresponding configuration
    file called **unit file** that contains information about actions to be performed
    for each operation, dependencies on other units, execution pre-conditions and
    post-conditions, and so on.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd` 是一种初始化系统，绝大多数 Linux 发行版（包括 CoreOS）都采用它在启动时启动其他服务/守护进程。`systemd` 旨在并行运行启动服务所需的多个操作，从而实现更快的启动速度。`systemd`
    管理服务、设备、套接字、磁盘挂载等，统称为单元（units）。`systemd` 对这些单元执行诸如启动、停止、启用和禁用等操作。每个单元都有一个相应的配置文件，称为
    **单元文件**，其中包含执行每个操作所需的动作、对其他单元的依赖关系、执行的前置条件和后置条件等信息。'
- en: In this section, we will understand how to configure a service using unit file
    and perform basic operations on the services. Let's start by understanding the
    contents of unit file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将了解如何使用单元文件配置服务，并对服务执行基本操作。让我们从理解单元文件的内容开始。
- en: Service unit files
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务单元文件
- en: Unit files are embedded in the `cloud-config` file and CoreOS copies the information
    verbatim to corresponding unit files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件嵌入在 `cloud-config` 文件中，CoreOS 会将信息原封不动地复制到相应的单元文件中。
- en: 'The unit name must be of the form `string.suffix` or `string@instance.suffix`,
    where:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单元名称必须是 `string.suffix` 或 `string@instance.suffix` 的形式，其中：
- en: '`string` must not be an empty string and can only contain alphanumeric characters
    and any of `'':'', ''_'', ''.'', ''@'', ''-''`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 不能为空，只能包含字母数字字符以及 `'':'', ''_'', ''.'', ''@'', ''-''`。'
- en: '`instance` can be empty, and can only contain the same characters as are valid
    for `string`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instance` 可以为空，只能包含与 `string` 相同的有效字符。'
- en: '`suffix` must be one of the following unit types: `service`, `socket`, `device`,
    `mount`, `automount`, `timer`, `path`. `service` is used for describing service.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suffix` 必须是以下单元类型之一：`service`、`socket`、`device`、`mount`、`automount`、`timer`、`path`。`service`
    用于描述服务。'
- en: 'Unit files contain information grouped under sections. Each section contains
    a list of parameters and their values. Each parameter can occur multiple times
    in a section. Section and parameter names are case sensitive. As we will be dealing
    mostly with services, we will discuss configuration relevant to it. The following
    are the important section names used for services:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件包含按部分组织的信息。每个部分包含一系列参数及其值。每个参数可以在一个部分中出现多次。部分和参数名称是区分大小写的。由于我们主要处理服务，我们将讨论与之相关的配置。以下是服务常用的几个重要部分名称：
- en: '`[Unit]` section: This section is not used by `systemd` and contains information
    for the user about the service. Some of the important parameters of the `Unit`
    section are:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Unit]` 部分：此部分不被 `systemd` 使用，包含有关服务的用户信息。`Unit` 部分的一些重要参数包括：'
- en: '`Description`:This specifies the description of the service such as name, service
    provided, and so on.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`：这指定了服务的描述，例如名称、提供的服务等。'
- en: '`After`:This specifies service names that are supposed to be started before
    starting this service.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`After`：这指定了在启动此服务之前应该启动的服务名称。'
- en: '`Before`:This specifies service names that are supposed to be started after
    starting this service.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Before`：这指定了在启动此服务之后应该启动的服务名称。'
- en: '`[Service]` Section: This section contains the configuration for managing units.
    Some of the important parameters of the `Service` section are:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Service]` 部分：此部分包含用于管理单元的配置。`Service` 部分的一些重要参数包括：'
- en: '`Type`:This specifies the startup type for the service. The type can be one
    of the following: `simple`, `forking`, `oneshot`, `dbus`, `notify`, or `idle`.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type`：这指定了服务的启动类型。类型可以是以下之一：`simple`、`forking`、`oneshot`、`dbus`、`notify` 或
    `idle`。'
- en: The type `simple` indicates that the service is started by executing the command
    configured in `ExecStart`, and proceeds with other unit file processing. This
    is the default behavior.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型`simple`表示通过执行`ExecStart`中配置的命令启动服务，并继续进行其他单元文件处理。这是默认行为。
- en: The type `fork` indicates that the parent process will fork a child process
    and exit upon completion of start. Exiting of the main process is the trigger
    to process with other unit file processing. To allow systemd to take recovery
    action upon service failure, the `pid` file containing `pid` if the process providing
    the service can be configured using `PIDFile`.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型`fork`表示父进程将分叉一个子进程，并在启动完成后退出。主进程退出后触发其他单元文件的处理。为了允许`systemd`在服务失败时采取恢复措施，如果提供服务的进程包含`pid`文件，可以使用`PIDFile`配置。
- en: The type `oneshot` indicates that the service is started by executing the command
    configured in `ExecStart`, waits for the exit of the command, and then proceeds
    with other unit file processing. `RemainAfterExit` can be used to indicate that
    the service is an active event after the main process has exited.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型`oneshot`表示通过执行`ExecStart`中配置的命令启动服务，等待该命令退出后再进行其他单元文件处理。`RemainAfterExit`可以用来指示服务在主进程退出后仍然是一个活动事件。
- en: The type `notify` indicates that the service is started by executing the command
    configured in `ExecStart`, and waits for the notification using `sd_notify` to
    indicate startup is complete. Upon notification, `systemd` starts executing other
    units.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型`notify`表示通过执行`ExecStart`中配置的命令启动服务，等待使用`sd_notify`的通知来表示启动已完成。接收到通知后，`systemd`开始执行其他单元。
- en: The type `dbus` indicates that the service is started by executing the command
    configured in `ExecStart`, waits for the service to acquire the D-bus name as
    specified in `BusName` and then proceeds with other unit file processing.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型`dbus`表示通过执行`ExecStart`中配置的命令启动服务，等待服务获取如`BusName`中指定的D-bus名称，然后继续进行其他单元文件处理。
- en: '`TimeoutStartSec`:This specifies the `systemd` wait time during starting the
    service before marking it as failed.'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeoutStartSec`：此项指定`systemd`在启动服务时等待的时间，超过该时间后将标记服务启动失败。'
- en: '`ExecStartPre`:This can be used to execute commands before starting the service.
    This parameter can be provided multiple times in the section to execute multiple
    commands prior to start. The value contains the full path of the command along
    with arguments to the command. The value can be preceded by `-` to indicate that
    the failure of the command will be ignored and next steps will be executed.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecStartPre`：此项可用于在启动服务前执行命令。此参数可以在该部分多次提供，用于在启动之前执行多个命令。该值包含命令的完整路径及命令的参数。该值前可以加上`-`，表示忽略命令失败并继续执行后续步骤。'
- en: '`ExecStart`:This specifies the full path and the arguments of the command to
    be executed to start the service. If the path to the command is preceded by a
    dash `-` character, non-zero exit statuses will be accepted without marking the
    service activation as failed.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecStart`：此项指定执行启动服务命令的完整路径及其参数。如果命令路径前有短横线`-`，则接受非零退出状态，而不会将服务激活标记为失败。'
- en: '`ExecStartPost`:This can be used to execute commands after starting the service.
    This parameter can be provided multiple times in the section to execute multiple
    commands after the start. The value contains the full path of the command along
    with arguments to the command. The value can be preceded by `-` to indicate that
    the failure of the command will be ignored and next steps will be executed.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecStartPost`：此项可用于在启动服务后执行命令。此参数可以在该部分多次提供，用于在启动后执行多个命令。该值包含命令的完整路径及命令的参数。该值前可以加上`-`，表示忽略命令失败并继续执行后续步骤。'
- en: '`ExecStop`:This indicates the command needed to stop the service. If this is
    not given, the process will be killed immediately when the service is stopped.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecStop`：此项指定停止服务所需执行的命令。如果没有指定，服务停止时进程将立即被终止。'
- en: '`TimeoutStopSec`:This specifies the `systemd` wait time during stopping the
    service before forcefully killing it.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeoutStopSec`：此项指定`systemd`在停止服务时等待的时间，超过该时间后将强制终止服务。'
- en: '`PIDFile`:This specifies the absolute filename pointing to the PID file of
    this service. `systemd` reads the PID of the main process of the daemon after
    startup of the service. `systemd` removes the file after the service has shut
    down if it still exists.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PIDFile`：此项指定指向该服务 PID 文件的绝对文件名。`systemd` 在服务启动后读取守护进程主进程的 PID。如果服务关闭后该文件仍然存在，`systemd`
    将删除该文件。'
- en: '`BusName`: This specifies the D-Bus bus name that this service is reachable
    at. This option is mandatory for services where `Type` is set to `dbus`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BusName`：此项指定该服务可访问的 D-Bus 总线名称。对于 `Type` 设置为 `dbus` 的服务，此选项是必需的。'
- en: '`RemainAfterExit`:This flag specifies whether the service shall be considered
    active even when all its processes exited. Defaults to no.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemainAfterExit`：此标志指定即使所有进程退出，服务是否仍应被视为活动的。默认为否。'
- en: Starting and stopping a service
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动和停止服务
- en: '`systemd` provides an interface to monitor and manage the service using the
    `systemctl` command. To start a service, invoke the `start` option with the service
    name. To start the service permanently after reboot, invoke the `enable` option
    with the service name.`.service` can be omitted when the service name is provided
    to the `systemctl` command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd` 提供了一个接口，可以使用 `systemctl` 命令来监控和管理服务。要启动服务，请使用服务名称调用 `start` 选项。要在重启后永久启动服务，请使用
    `enable` 选项并指定服务名称。提供给 `systemctl` 命令的服务名称时，`.service` 可以省略：'
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To stop the service, invoke the `stop` option with the service name:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止服务，请使用服务名称调用 `stop` 选项：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To check the status of the service, invoke the `status` option with the service
    name:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查服务状态，请使用服务名称调用 `status` 选项：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: fleet
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fleet
- en: CoreOS extends the init system to the cluster using fleet. fleet emulates all
    the nodes in the CoreOS cluster to be part of a single init system or system service.
    fleet controls the systemd service at the cluster level, not at the individual
    node level, which allows fleet to manage services in any of the nodes in the cluster.
    fleet handles scheduling a unit/service/container to a cluster member, handles
    units by rescheduling to another member, and provides an interface for monitoring
    and managing units locally or remotely. You don't have to care about the coupling
    of a member to the service, as fleet does it for you. The unit is guaranteed to
    be running on all the clusters meeting the constraint required for running the
    service. Unit files are not only limited to launch a Docker, even though most
    of the time unit files are used to start a Docker. Some of the valid unit types
    are `.socket`, `.mount`, and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS 通过 fleet 将初始化系统扩展到集群中。fleet 模拟 CoreOS 集群中的所有节点作为一个单一的初始化系统或系统服务的一部分。fleet
    在集群层面控制 systemd 服务，而不是在单个节点层面，这使得 fleet 能够在集群中的任何节点上管理服务。fleet 负责将单元/服务/容器调度到集群成员，处理通过重新调度到另一个成员来管理单元，并提供本地或远程监控和管理单元的接口。您无需担心成员与服务的耦合，因为
    fleet 会为您处理这一切。单位文件保证在满足运行服务所需约束的所有集群上运行。单位文件不仅限于启动 Docker，尽管大多数情况下单位文件用于启动 Docker。有效的单位类型包括
    `.socket`、`.mount` 等。
- en: Architectural overview
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构概述
- en: 'fleet consists of two main components: **fleet agent** and **fleet engine**.
    Both these components are part of the `fleetd` module and will be running on all
    the cluster nodes. Both the engine and agent components work with a reconciliation
    model, wherein both these components take a snapshot of the current state of the
    cluster and derive the desired state and try to emulate the derived state of the
    cluster.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: fleet 由两个主要组件组成：**fleet agent** 和 **fleet engine**。这两个组件都是 `fleetd` 模块的一部分，将在所有集群节点上运行。引擎和代理组件都采用协调模型工作，在此模型中，两个组件都获取集群当前状态的快照，推导出期望的状态，并尝试模拟集群的推导状态。
- en: fleet uses the D-Bus interface exposed by systemd. D-Bus is the message bus
    system for IPC provided by the Linux OS, which provides one-to-one messaging methods
    and the pub/sub type of message communication.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: fleet 使用 systemd 暴露的 D-Bus 接口。D-Bus 是 Linux 操作系统提供的 IPC 消息总线系统，提供一对一的消息方法和发布/订阅类型的消息通信。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As fleet is written in Go language, fleet uses `godbus`, which is the native
    GO binding for D-Bus.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 fleet 是用 Go 语言编写的，fleet 使用 `godbus`，这是 D-Bus 的原生 GO 绑定库。
- en: fleet uses `godbus` to communicate with `systemd` for sending the commands to
    start/stop units in a particular node. It also uses `godbus` to get the current
    state of the units periodically.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: fleet 使用 `godbus` 与 `systemd` 通信，以便向特定节点发送启动/停止单元的命令。它还使用 `godbus` 定期获取单元的当前状态。
- en: Engine
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引擎
- en: The fleetd engine is responsible for making the scheduling decision of the units
    among the cluster of nodes based on the constraint, if any. The engine talks to
    `etcd` for getting the current state of units and nodes in the cluster. All the
    units, state of the units, and the nodes in the cluster are stored in the `etcd`
    data store.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: fleetd 引擎负责根据约束条件（如有）做出集群节点间单元的调度决策。引擎通过与`etcd`通信来获取集群中单元和节点的当前状态。所有单元、单元的状态以及集群中的节点都存储在`etcd`数据存储中。
- en: The scheduling decision happens in a timely fashion or is triggered by `etcd`
    events. The reconciliation process is triggered by `etcd` events or time period,
    wherein the engine takes a snapshot of the current state and the desired state
    of the cluster, which includes the state of all the units running on the cluster
    along with the state of all the nodes/agents in the cluster. Based on the current
    state and desired state of the cluster, it takes necessary action to move from
    the current state to the desired state and save the desired state as the current
    state. By default, the engine uses the least-loaded scheduling algorithm, wherein
    it chooses the node that is loaded less for running a new unit.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 调度决策是及时进行的，或者是由`etcd`事件触发的。对账进程由`etcd`事件或时间周期触发，在该过程中，引擎会捕获集群的当前状态和目标状态的快照，其中包括集群中运行的所有单元的状态，以及集群中所有节点/代理的状态。根据集群的当前状态和目标状态，引擎采取必要的措施从当前状态过渡到目标状态，并将目标状态保存为当前状态。默认情况下，引擎使用最少负载调度算法，即选择负载较低的节点来运行新的单元。
- en: Agent
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Agent
- en: '**Agent** is responsible for starting the units in the node. Once the engines
    choose the appropriate node for running the units, it is the responsibility of
    the agent in that node to start the unit. To start the unit, the agent sends start
    or stop unit commands to the local systemd process using the D-Bus. The agent
    is also responsible for sending the state of the units to the etcd, which will
    be later communicated to the engine. Similar to the engine, the agent also runs
    a periodic reconciler process to compute the current state and desired state of
    unit files and takes the necessary action to move to the desired state.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Agent**负责在节点中启动单元。一旦引擎选择了适合的节点来运行单元，该节点中的agent就负责启动该单元。为了启动单元，agent通过D-Bus将启动或停止单元的命令发送给本地的systemd进程。agent还负责将单元的状态发送到etcd，稍后该状态会传达给引擎。与引擎类似，agent还运行周期性对账进程，以计算单元文件的当前状态和目标状态，并采取必要的措施将状态转变为目标状态。'
- en: The following diagram represents how the job/unit is scheduled by the fleet
    engine to one of the nodes in the cluster. When the user wants to start a unit
    using the `fleetctl start` command, the engine picks this job and adds it to the
    job offer. The qualified agent running on the node bids for the job on behalf
    of the node. Once the qualified agent is selected by the engine, it sends the
    unit to the agent for deployment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了如何通过fleet引擎将作业/单元调度到集群中的某个节点。当用户使用`fleetctl start`命令启动一个单元时，引擎会选择这个作业并将其添加到作业列表中。在该节点上运行的合格代理会代表节点竞标该作业。一旦引擎选中了合格代理，它就会将单元发送给代理进行部署。
- en: '![Agent](img/00017.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Agent](img/00017.jpeg)'
- en: fleetctl
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fleetctl
- en: '`fleetctl` is the utility provided by the CoreOS distribution to interface
    and manage the `fleetd` module. This is similar to `systemctl` for `systemd` to
    fleet. `fleetctl` can either be executed on one of the nodes inside the CoreOS
    cluster or it can be executed on a machine that is not part of the CoreOS cluster.
    There are different mechanisms to run `fleetctl` to manage the fleet service.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`fleetctl`是CoreOS发行版提供的工具，用于与`fleetd`模块进行交互和管理。这类似于`systemd`中的`systemctl`，但是是用于fleet的。`fleetctl`可以在CoreOS集群中的一个节点上执行，也可以在一个不属于CoreOS集群的机器上执行。有多种机制可以运行`fleetctl`来管理fleet服务。'
- en: 'By default, `fleetctl` communicates directly with `unix:///var/run/fleet.sock,`
    which is a Unix domain socket of the local host machine. To override and to contact
    a particular node''s HTTP API, the `--endpoint` option should be used, as follows.
    The `--endpoint` option can also be provided using `FLEETCTL_ENDPOINT` environmental
    options:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`fleetctl`直接与`unix:///var/run/fleet.sock`通信，这是本地主机机器的Unix域套接字。要覆盖并联系特定节点的HTTP
    API，应该使用`--endpoint`选项，如下所示。`--endpoint`选项也可以通过`FLEETCTL_ENDPOINT`环境变量来提供：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the user want to execute the `fleetctl` command from an external machine,
    the `--tunnel` option is used, which provides a way to tunnel `fleetctl` commands
    to one of the nodes in the cluster using SSH:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户希望从外部机器执行`fleetctl`命令时，可以使用`--tunnel`选项，这为通过SSH将`fleetctl`命令隧道到集群中的一个节点提供了方式：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`fleetctl` contains the command to start, stop, and destroy units in the cluster.
    The following table lists the commands provided by `fleetctl`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`fleetctl`包含用于启动、停止和销毁集群中单元的命令。下表列出了`fleetctl`提供的命令：'
- en: '| Command | Description | Example |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `fleetctl list-unit-files` | List all units in the fleet cluster. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `fleetctl list-unit-files` | 列出集群中的所有单元。 |'
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `fleetctl start` | To start a unit. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `fleetctl start` | 启动单元。 |'
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `fleetctl stop` | To stop a unit. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `fleetctl stop` | 停止单元。 |'
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `fleetctl load` | To schedule a unit in a cluster without starting the unit.
    This unit will be in an inactive state. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `fleetctl load` | 在集群中调度单元，但不启动该单元。该单元将处于非活动状态。 |'
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `fleetctl unload` | To unschedule a unit in a cluster. This unit will be
    visible in `fleetctl list-unit-files` but will not have any state. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `fleetctl unload` | 从集群中取消调度单元。该单元将在`fleetctl list-unit-files`中可见，但不会有任何状态。
    |'
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `fleetctl submit` | To bring the units into the cluster. This unit will be
    visible in `fleetctl list-unit-files` but will not have any state. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `fleetctl submit` | 将单元引入集群。该单元将在`fleetctl list-unit-files`中可见，但不会有任何状态。
    |'
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `fleetctl destroy` | The destroy command stops the unit and removes the unit
    file from the cluster. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `fleetctl destroy` | 销毁命令停止单元并从集群中移除单元文件。 |'
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `fleetctl status` | To get the status of the unit. This command invokes the
    `systemctl` command on the machine running a given unit over SSH. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `fleetctl status` | 获取单元状态。此命令通过SSH在运行指定单元的机器上调用`systemctl`命令。 |'
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The `fleetctl` syntax looks similar to `systemctl`, which is the management
    interface for `systemd`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`fleetctl`语法类似于`systemctl`，后者是`systemd`的管理接口。'
- en: Standard (local) and global units
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准（本地）单元和全局单元
- en: Global units are units that are scheduled to run on all the members. Standard
    or local units are units that are scheduled to run only on some machines. In case
    of failures, these units are switched to another member in the cluster fit to
    run those units.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 全局单元是调度在所有成员上运行的单元。标准或本地单元是仅调度在某些机器上运行的单元。如果发生故障，这些单元将切换到集群中适合运行这些单元的其他成员上。
- en: Unit file options for fleet
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fleet单元文件选项
- en: 'Unit file format is the same as the file format for `systemd`. fleet extends
    the configuration by adding another section, `X-Fleet`. This section is used by
    fleet to schedule the units on a specific member based on the constraints specified.
    Some of the important parameters of the `X-Fleet` section are:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件格式与`systemd`的文件格式相同。fleet通过添加一个额外的部分`X-Fleet`来扩展配置。该部分用于根据指定的约束，在特定成员上调度单元。`X-Fleet`部分的一些重要参数包括：
- en: '`MachineID`: This specifies the machine on which the unit has to be executed.
    Machine ID can be obtained from the `/etc/machine-id` file, or through the `fleetctl
    list-machines -l` command. This option is to be used with discretion as it defies
    the purpose of fleet, allowing a unit to be targeted specifically on the machine.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MachineID`：指定单元必须执行的机器。机器ID可以通过`/etc/machine-id`文件获取，或通过`fleetctl list-machines
    -l`命令获取。此选项应谨慎使用，因为它违背了fleet的目的，允许将单元专门指向某台机器。'
- en: '`MachineOf`: This instructs fleet to execute the unit on which the specified
    unit is running. This option can be used to group units running on a member.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MachineOf`：指示fleet在指定单元运行的成员上执行该单元。此选项可用于将运行在同一成员上的单元分组。'
- en: '`MachineMetadata`: This instructs fleet to execute the units on the member
    matching the specified metadata. If more than one metadata is provided, all metadata
    should match. To match any of the metadata the parameter can include multiple
    times. `Metadata` is provided for the member in the `cloud-config` fleet configuration.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MachineMetadata`：指示fleet在匹配指定元数据的成员上执行单元。如果提供多个元数据，则所有元数据都应匹配。为了匹配任意一个元数据，可以多次包含该参数。`Metadata`是为成员在`cloud-config`
    fleet配置中提供的。'
- en: '`Conflicts`: This instructs fleet not to execute the unit on the specified
    unit that is running.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Conflicts`：指示fleet不要在指定的运行单元上执行该单元。'
- en: '`Global`: If this is set to true, the unit is scheduled to be executed on all
    the members. Additionally, if `MachineMetadata` is configured, they run only on
    members having matching metadata. Any other options, if provided, make the unit
    configuration invalid.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Global`：如果设置为 true，则该单元会在所有成员上执行。此外，如果配置了 `MachineMetadata`，则它只会在具有匹配元数据的成员上执行。如果提供了其他选项，则会使该单元配置无效。'
- en: Instantiating the service unit in the cluster
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集群中实例化服务单元
- en: 'We have seen what CoreOS clustering is, how to form a cluster, and tools like
    `fleet` and `fleetctl`. Now, let us see how a service unit can be started in one
    of the nodes in the cluster using `fleet`. As mentioned already, `fleetctl` is
    the command-line utility provided by the CoreOS distribution to perform various
    operations, such as start the service, stop the service, and so on in a cluster.
    Like `systemctl`, `fleetctl` also requires a service file to perform these operations.
    Let us see a sample service file and using the service file, how fleet starts
    the service in the cluster:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了什么是 CoreOS 集群，如何形成一个集群，以及像 `fleet` 和 `fleetctl` 这样的工具。现在，让我们看看如何在集群中的某个节点上使用
    `fleet` 启动一个服务单元。如前所述，`fleetctl` 是 CoreOS 发行版提供的命令行工具，用于执行各种操作，比如启动服务、停止服务等。与
    `systemctl` 类似，`fleetctl` 也需要一个服务文件来执行这些操作。让我们来看一个示例服务文件，并通过这个服务文件，看看 `fleet`
    如何在集群中启动服务：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Save the preceding file as `example.service` on the CoreOS machine. Now, execute
    the following command to start the service in the cluster:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述文件保存为 `example.service`，然后在 CoreOS 机器上执行以下命令以启动集群中的服务：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One of the major requirements for running a service is to provide high availability.
    To provide a high-availability service, we may need to run multiple instances
    of the same service. These different instances should be running on different
    nodes. To provide high availability for a unit/service, we should make sure that
    the different instances of the service are running on different nodes in the cluster.
    This can be achieved in CoreOS by using the `conflicts` attribute. Let us have
    a look at the service file for these two instances of the service, say, the service
    as `redis.service`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务的一个主要要求是提供高可用性。为了提供高可用性服务，我们可能需要运行多个相同服务的实例。这些不同的实例应该运行在不同的节点上。为了为单元/服务提供高可用性，我们应该确保该服务的不同实例在集群中的不同节点上运行。这可以通过
    CoreOS 中使用 `conflicts` 属性来实现。让我们看看这两个服务实例的服务文件，假设该服务为 `redis.service`：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Save this content as `redis@1.service` and `redis@2.service`. The conflicts
    attributes in the service file informs fleet not to start these two services in
    the same node:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将此内容保存为 `redis@1.service` 和 `redis@2.service`。服务文件中的冲突属性告知 fleet 不在同一节点上启动这两个服务：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Recovering from node failure
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从节点故障中恢复
- en: CoreOS provides an inherent mechanism to reschedule the units from one node
    to another node when there is a node failure or machine failure. All the nodes
    in the cluster send a heartbeat message to the fleet leader. When the heartbeat
    messages are not received from a particular node, all the units running on that
    node are marked to be rescheduled in different nodes. The fleet engine identifies
    the qualified node and starts the units in the qualified node.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS 提供了一种内建机制，当节点故障或机器故障时，可以将单元从一个节点重新调度到另一个节点。集群中的所有节点都会向 fleet 领导者发送心跳消息。当某个节点未收到心跳消息时，该节点上运行的所有单元会被标记为在其他节点重新调度。fleet
    引擎会识别合适的节点，并在合适的节点上启动单元。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we learned about CoreOS clusters and how members join a cluster
    using cluster discovery. We got ourselves familiar with the init system used to
    start the units in most of the Linux systems and how CoreOS extends it to a multi-member
    cluster using the fleet service. We learned about starting and stopping a service
    on a member using fleet.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 CoreOS 集群以及成员如何使用集群发现加入集群。我们熟悉了用于启动大多数 Linux 系统中单元的初始化系统，以及 CoreOS
    如何通过 fleet 服务将其扩展到多成员集群。我们学会了如何使用 fleet 在成员上启动和停止服务。
- en: In the next chapter, we will understand more about the constraints on the service,
    which helps fleet select the member suitable for it to run.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步了解服务上的约束，这有助于 fleet 选择适合它运行的成员。
