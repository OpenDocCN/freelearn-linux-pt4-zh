- en: Quoting and Escaping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not everything is what it looks like. We must bear in mind that when dealing
    with operators and variables, sometimes we get unexpected results based on how
    we use them. A small example will make this advice more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The directory has no content, so it is our starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We just created a file named star:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do `ls *` , we actually see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We see this even if we issue a simple `ls` without any arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we created three empty files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we tried to list only the star file, but we saw all of them. How to show
    only the star named file? We can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we have quoted the star symbol, we can see the file named after
    it. Why is this? Well, as I said, there are some characters that have a special
    meaning for the shell, such as the star, which is expanded by the shell into *ALL*
    characters. This is why if we issue `ls *`, we will see all the files held into
    the directory, because we are asking to show any file whose name is made up of
    any characters or numbers (except for filenames starting with a dot). Quoting
    the star symbol prevents the shell from actually interpreting the special character
    ,and so take it literally, we want to see the file whose name is simply `*`.
  prefs: []
  type: TYPE_NORMAL
- en: Special characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already used some of these special characters in the previous chapters
    by giving a hint of what was their meaning. Now, we will be closely looking at
    each of them and examining their special value for the shell and how they can
    be used in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The hash character (#)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This represents a comment. Each line beginning with `#` is taken as a comment
    and not interpreted by the shell. Let''s have a look at the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first pound sign is not really a comment, but it is associated to the following
    exclamation mark and is interpreted as a *sha-bang*. The second line shows a typical
    comment line, the third a comment after a command, the fourth line is still a
    comment, and the `ps` command is not interpreted and executed. Let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the output of the `ls` command, but not of `ps` as expected. Also notice
    that the comments are not printed to `stdout`. Since we use it inside the code
    to comment, it is not something to be shown at runtime. Let''s add a couple of
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first `echo` command creates a blank line and the comment
    is not taken in account; so, it is as if we had no argument to the `echo` command.
    The second comment is even more interesting. We escaped the pound sign placing
    a back slash in front of it. So, being escaped the pound sign is just a pound
    sign followed by a bunch of characters, and all together, they get printed to `stdout`
    as the `echo` command arguments. So, be careful since you will find the pound
    sign used with different meaning, as we already saw in the paragraphs dealing
    with a parameter substitution and a pattern matching on variables.
  prefs: []
  type: TYPE_NORMAL
- en: The semicolon character (;)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The semicolon is a command separator, and it allows us to chain one command
    after the other, just as we did for the if construct. For instance, look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a `test.txt` file, and we cat its content right after it. Be careful
    with the find `-exec` command, as the semicolon must be escaped. The `-exec` option
    allows us to perform a command on the files provided by find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the find `-exec` object, the semicolon is the command sequence terminator
    and not a command separator, so it must be escaped in order to avoid the shell
    to interpret it as a special character. After the first escaped semicolon, we
    then added a second semicolon to separate the `find` command from the subsequent
    `ls`. Notice that`{}` in the command is substituted by `find` with the full path
    to the file found.
  prefs: []
  type: TYPE_NORMAL
- en: The double semicolon character (;;)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The double semicolon is a case construct option terminator. We will see the
    case constructor later in this book, but as of now, just think of it as a sequence
    of if/then/else, which is widely adopted to create a user menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the case construct starts with the case keyword and is closed
    by the reverse of it: `esac`. What it does is try to verify each condition into
    the different options that we defined. Each option is separated from the other
    by the double colon. The last option is usually a star, which means *whatever
    you type,* and it is a catchall option just in case any other option did not trap
    what the user typed in. Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this for the default option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Have you noticed that the screen has been cleared out of any content? This is
    thanks to the `clear` command that we wrote at the beginning of the file, as it
    clears out the screen so that whatever you write to the customer, it will appear
    at the top of the screen without any other content distracting the user.
  prefs: []
  type: TYPE_NORMAL
- en: The case terminator (;;&) and (;&))
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are enhanced case terminators too, but they are only available in Bash
    from a version higher than 4.0\. Here are the differences between the three operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`;;`: If the condition is matched, the other options will not be tested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`;&`: This makes the execution continue with the commands associated to the
    next condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`;;&`: This makes the shell check the option and execute the associated commands
    if the condition is matched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no matches are found, the exit status is `0`; otherwise, the exit status
    is the one from the last command executed. We will see more about these terminators
    and the case constructor in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The dot character (.)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dot command is a shell builtin, and it has the same function of the source;
    when executed into the shell, it executes a file. And if it is used inside a script,
    it loads the referenced file content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from this example, the first try was not successful because `comment.sh`
    is not in the search path; but the second time, we were successful since the dot
    command executed the script. Now, let''s see how to include some code from an
    external file into a script. Let''s start writing the external file that we will
    source from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to write the script that will source from this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is just a matter of having a look at what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as we can see, we actually sourced the variables content from the external-data
    file. But there is more since if we source an external script, its code gets executed
    and can also return values to the main script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple menu that asks the user for a digit and then checks it; do
    not worry, as we will see how to match digits and characters later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a quick way to match characters  by using a POSIX character class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[:alnum:]` matches both alphabetic and numeric characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:alpha:]` matches only alphabetic characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:blank:]` matches only a tab or a space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:cntrl:]` matches any control characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:digit:]` matches only digits between 0 to 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:graph:]` matches any the character that has a value between 33 and 126 in
    the ASCII table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:lower:]` matches alphabetic characters in lower case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:print:]` matches the graph, but also matches the range is from 32 to 126,
    including the space characters too'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:space:]` matches the space and horizontal tabs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:upper:]` matches alphabetic characters in upper case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:xdigit:]` matches digits, but in a hexadecimal notation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s do something nicer and modify the previous external script in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of exiting, we are returning a value to the caller script so that the
    execution once ended on the child script will continue on the main one. Now a
    new main script is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see a couple of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now source the `external-script-return.sh` file and ask the customer
    for a digit between `0` to `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now source the `external-script-return.sh` file and ask the customer
    for a digit between `0` to `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now source the `external-script-return.sh` file and ask the customer
    for a digit between `0` to `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the builtin command return to stop the execution of the inner script
    once a condition is met and returned an exit status to the parent script. Usually,
    we can use return without any exit code, and it will serve back the exit status
    of the last command executed, or we can use an integer between `0` to `255`. Would
    it not be nice to have in return something different from a simple number? Well,
    you can''t. Actually you can with a little trick. Let''s modify the previous child
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s call the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What did we do? We got rid of `return` and echoed on the standard output of
    our message. Then, from the calling script, we used a command substitution. What
    does this do? It simply reassigns the output of a command; in our case, we reassigned
    the output of the sourced script to the variable returning. You can do a command
    substitution using `...`: the classic backtics, which has been superseded by `$(...)`.
    So, use the latter form, since it is the most actual and also allows you to nest
    multiple command substitutions. Let''s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh well, nice! It gave us the echoed string from the first case option, but
    unfortunately, we also trapped the message printed to the user asking to input
    a integer. Well, how do you get rid of it? You should already know this; just
    keep in mind that we are getting everything printed to `stdout`, and so we will
    need a tiny alteration to the inner script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We need one modification to the calling script so that the last line will be
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It is time to test our modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'What did we do? First, we redirected `stdout` to `stderr`; and both are attached
    to the terminal, so the user will still see the question asked by the script,
    but the sentence will not be caught by the command substitution since this latter
    works only with `stdout`. Then, we silenced the read builtin so that it will not
    `echo` to the `stdout` and the value typed by the customer; and at the end, we
    just printed the returned value without any comments. This gave us a neat output.
    This trick can be used when you have to return a value from a function to the
    main script body, and you do not want to be limited by the 0-255 value restriction
    of the returned builtin. A file can be sourced passing by it positional parameters
    with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The sourced script will access the parameters value using `$1`, `$2`, and `$n`.
    From the 10th parameter, the value must be accessed bracketing the `${15}` variable.
    Before ending the description of the dot character, we should recall what we said
    in the previous chapter: a single dot is a link to the current directory. It is
    also widely used in filenames to specifically define file extensions. Finally,
    in the regular expressions context, the dot matches any single character except
    for the new line.'
  prefs: []
  type: TYPE_NORMAL
- en: The double quotes ("...")
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Double quotes are also known as partial or weak quoting, which avoid the interpretation
    of most of the special characters by the shell. We will see more about them in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The single quotes ('...')
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The single quote, also known as a full or strong quote, avoids the interpretation
    of all special characters by the shell. More information on it is mentioned in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The comma character (,)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The comma operator chains together arithmetic operations or strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can see here is that even though the operations are concatenated, only
    the value of the last one is returned. So, `x` is instanced with the value of
    just `6-1`. But, as I mentioned before, we can use the comma character to concatenate
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you can concatenate a list of values to create new strings
    and do some funny stuff in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is funny, but it is up to you how to use it. You can cycle in a for statement
    and construct a list of paths to examine; for instance, the applications of a
    string concatenation is really up to your creativity.
  prefs: []
  type: TYPE_NORMAL
- en: The ,, and , () case modificators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is new in Bash 4.0, and it forces a lower case conversion in the parameter
    substitution.
  prefs: []
  type: TYPE_NORMAL
- en: The ^^ and ^ () case modificators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is new in bash 4.0, it forces upper case conversion in the parameter substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will do a couple of tests, starting with a lowercase string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will test an upper case string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This comes in handy when you want to *normalize* a string that you retrieved
    for a previous operation or from a user input.
  prefs: []
  type: TYPE_NORMAL
- en: The backslash (\)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This escape character is used to prevent the special characters interpretation
    by the shell. We saw an example of its usage in the previous bunch of code where
    we escaped `\${my_input}` so that the echo was able to print it literally as a
    string and not trying to output its value. Using `\` has the same effect as surrounding
    a variable with single quotes, so this is a strong quotation useful to literally
    print the `"` and `'` characters, which are usually interpreted as quotation characters.
  prefs: []
  type: TYPE_NORMAL
- en: The forward slash (/)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The forward slash has two different uses:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a file name separator in paths, as we can see in the `/usr/lib/dbus-1.0/dbus-daemon-launch-helper`
    example. Every bit between a forward slash is a directory until the last leaf,
    which is a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the arithmetic operator for the division.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '''...'''
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the command substitution, and we just used it a few pages ago; it assigns
    the `stdout`  command to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: The colon character (:)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The colon does actually nothing except expanding arguments and performing redirection.
    It can be handy in cycles and tests to actually do nothing if a condition is met.
    It is also interesting to see how it can be used to evaluate a series of variables
    using the parameter substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a bite on redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, what we see here is that the combining of the colon with `>` gives us a
    quick method for truncating a regular file without changing the permission. If
    the file does not exist, it gets created; but if we use `>>`, it only creates
    a file and does not truncate a preexisting file. You will find more *strange* uses
    for a colon, such as a field separator in the `/etc/passwd` file or as a legit
    function name.
  prefs: []
  type: TYPE_NORMAL
- en: The exclamation (!)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The exclamation mark is a keyword that negates or reverses a test or an exit
    status. For instance, take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The exit code of ls is `0`, true, since it was successful. But let''s reverse
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *keyword* is a reserved word that has a special meaning to the shell and
    is hardwired in it such as the builtins; but differing from the latter, the keywords
    are not full-blown commands, but parts of a command construct, and you can have
    a list of these by just typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: compgen -k
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: elif
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: esac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: select
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: while
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: until
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[['
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ']]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the command line, but not from a script, the exclamation mark triggers
    the bash history.
  prefs: []
  type: TYPE_NORMAL
- en: The asterisk (*)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The asterisk, also known as a wildcard, when used in a file name expansion,
    matches all the file names in a directory. The file name expansion is also known
    as **Globbing**. It takes into account some special characters as `*`, which is
    expanded to all, and `?`, which expands to any single character along with some character
    lists in brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the example, we listed all the  `*` files whose names started
    either with `e` or `s`. But it also interprets the `^` character as negation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we listed all the files in the current directory whose names
    did not start with either `e` or `s`. Be careful as the `*` in file globbing does
    not trap file names starting with a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Something is clearly missing, so let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also try this for some nice effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Final remarks, you will find the asterisk used as a wild card in regular expressions
    as well with the same meaning and also as a multiplication operator in arithmetic
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: The double asterisk (**)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The double asterisk is being used in two different contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: It is used as a exponentiation operator in an arithmetic context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used as an extended file match globbing operator from Bash 4, meaning
    it matches filenames and directories recursively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is different from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The double star matched all files and directories globally. If the double star
    does not work for you, enable the globstar shell options with `zarrelli:~$ shopt
    -s globstar ; for i in ** ; do echo "$i" ; done`. The `globstar` value changes
    the way the shell interprets the double star, which, in a file name expansion,
    matches all files and any subdirectories. If the pattern is followed by a `/`,
    only the directories and subdirectories will be matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Test operators (?)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test operator can be used in a few different scenarios. We already saw
    in the parameter substitution that it is used to check whether a variable has
    a value or not. In arithmetic operations, it can be used to implement the trinary
    or ternary operator in a C-style notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the C-style notation is more compact even though it is not
    as readable as a standard loop notation. Let''s try it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, you would write a control loop in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can also use the C-style trinary operator to achieve the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we reached the same result but with a more compact code. Essentially,
    we give a condition that ends with the `?` character and then, alternative results
    follow, which are separated by a `:` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that the C-style is widely used in loops and can be defined as a compound
    command used to evaluate mathematical expressions in a loop, and as seen in the
    previous example, assign a variable. It is made of three blocks: the first initializes
    a variable before the first iteration, the second checks for a condition that
    exits the look, and the third modifies the initial condition. Sounds strange?
    Look at this, it will look really familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can find the quotation mark used for file name expansion in globbing
    as a wild card matching any one characters; in regular expressions, use it as
    a single character match.
  prefs: []
  type: TYPE_NORMAL
- en: The substitution ($)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know this and have used it for the variable substitution that allows
    us to access the content of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is also used in a regular expression to match at the end of a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the output of `ls` is filtered on that file whose name ends
    with a single integer.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter substitution (${})
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This gives us a parameter substitution, which we have already seen earlier in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: The quoted string expansion ($'...')
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a quoted string expansion, and it is used to expand escaped octal or
    hex values in Unicode or ASCII:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We just concatenated some escaped octal values to get a nice and welcoming ASCII
    string assigned to the variable `x`.
  prefs: []
  type: TYPE_NORMAL
- en: The positional parameters ($* and $")
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first (`$*`) represents all the positional parameters as a single string
    and the second (`$"`) represents all the positional parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the first case, the parameters are passed as single words,
    but beware, `$*` must be quoted to avoid weird side effects of the expansion.
    `$@` passes each parameter as a quoted string without any interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: The exit status ($?)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already saw this representing the exit status of a command, function, and
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The process ID ($$)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This holds the **Process ID** (**PID**) of the script that appears in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Grouping the command (command1 ; command2 ; commandn)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Grouping the commands into parenthesis have them executed in a subshell, and
    this has a subtle but outstanding implication: whatever you do in the subshell
    will not be reachable from the calling shell, so if you execute a subshell from
    a script with commands inside, what you will do in the subshell will not be available
    to the calling script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'It comes quite straightforward if we recall what we read in the first chapters:
    the subshell inherits the environment of the calling shell from the script, and
    so, it can access the value of the `x` variable, but it cannot inject back anything.
    So, after having multiplied the value of `x` for itself and reassigning it to
    the variable, we could print the result, `100`, in the subshell. But once we exited
    it, we were left with the original value of `x `and `10`. The value of `x` never
    changed in the main script; it changed only into the subshell. As we will see
    later in this book, `()` is also used to initialize an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The brace expansion can come handy to address multiple items at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we expanded `*` in files starting with whatever characters, and
    then ending with a dot, followed either by a single integer or a `txt` postfix.
    But we can actually apply a command to a list of files having the globbing taking
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply, we can do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'But be careful; use no spaces inside the braces unless you escape or quote
    them; otherwise you could face weird issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The extended brace expansion, available from Bash 3, is an easy way to create
    iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Or create something fancier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The curly brackets are widely used to create the so-called anonymous functions,
    which have an interesting property: the code inside these kinds of functions are
    visible to the rest of the script. There is another way of grouping commands,
    but with some interesting differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The commands are executed in the same shell, no subshell spawned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of this, all the variables instanced inside the brackets are available
    from the calling shell, that is, from the calling script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Braces are reserved words and must be separated from the elements enclosed using
    spaces or a metacharacter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A newline or `;` is required at the end of the commands list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of how to use the curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we did not have to call the anonymous function to execute it
    differently from a normal function. We did not use the local scope for the variable
    since it is not allowed, and it will throw an error. We will see more about functions
    and scopes in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Braces support I/O redirection for the code enclosed into it.
  prefs: []
  type: TYPE_NORMAL
- en: Braces ({})
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, braces have another meaning: using braces with `xargs -i` (replace string)
    can be a placeholder for names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The full path ({} \;)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Used with `find -exec`, this holds the full path to the file located by find.
    It is not a shell builtin, and the semicolon at the end of the command sequence
    must be escaped to avoid shell interpretation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Expression ([])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This tests the expression between brackets. It is the shell builtin test and
    not the command called `/usr/bin/[`.
  prefs: []
  type: TYPE_NORMAL
- en: '[[ -f copy.txt ]] && echo "file found'
  prefs: []
  type: TYPE_NORMAL
- en: Expression ([[]])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, this tests expressions between brackets, but in a more flexible way.
    We have already seen this in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The array index ([])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This points us to the object located into the array at the index specified
    between the brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We will see what an array is later on, as of now, just bear in mind that an
    array index starts from `0`, so `1` is the second element into it.
  prefs: []
  type: TYPE_NORMAL
- en: Characters range ([])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This defines a range of characters matched in regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we matched all the filenames starting with a character in the
    range between `c` and `m`.
  prefs: []
  type: TYPE_NORMAL
- en: Integer expansion ($[…])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an integer expansion, deprecated and substituted by `((…))`.
  prefs: []
  type: TYPE_NORMAL
- en: Integer expansion (((..)))
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an integer expansion. We have already seen in the previous chapters
    how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: DEMO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw this at the beginning of this book, and we know they are used for redirections. You
    will find more details on how to use it in the examples provided.
  prefs: []
  type: TYPE_NORMAL
- en: The here document (<<)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A here document is a form of redirection that forces the shell to read the
    input from the subsequent block of characters up to a user-defined delimiter,
    and then it uses this bunch of characters as a standard input for a command or
    a file descriptor. As we can see in the next example, the argument for the `cat`
    command is not provided on the command line or asked to the user, but it is written
    into the script between the two `DELIMITER` words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The delimiter at the right of `<<` can be whatever string you want as long
    as it matches with the last line: everything between the two delimiters will be
    used as standard input for, in our example, `cat`. Be aware that the delimiter
    is not subject to any command substitution, arithmetical, or pathname expansion.
    But if the delimiter is not quoted, then the lines between the delimiters are
    subject to the arithmetic and file expansions and the command substitution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A nice touch is to add `–` at the right side of `<<`so that the trailing tab
    characters get stripped from the input, and this makes it possible to create indented
    here documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'If you swap `<<` with `<`, you will get an unindented input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The here string (<<<)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *here* string is a simple version of the *here* document, and it consists
    of a single line where the delimiter is expanded to feed the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The ASCII comparison operators (<) and (>)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an ASCII comparison between strings. We already saw how to use these
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Delimiters (\< and \>)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Are delimiters are used to identify a word in a regular expression. Let''s
    create a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will `grep` with the word delimiter set to `bar` with the `-o` option,
    which will output only the fragment that matched and not all the lines containing
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This is correct. There is only one single word called `bar`; the others are
    composite words, and we can double check this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: If we do not look for the word named `bar`, but only for the matches of a three
    character string bar, we see that we can match it three times in the file.
  prefs: []
  type: TYPE_NORMAL
- en: The pipe character (|)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pipe is a classic example of inter process communication: it passes the
    `stdout` of a process to the `stdin` of another process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we just listed the content of the current directory and fed
    the output as the `stdin` of the `wc` utility, which counted how many lines there
    were in data just fed in. The command after the pipe runs in a subshell, so it
    will not be able to return any modified value to the parent process; and if one
    of the commands in the pipe aborts somehow, this leads to the so-called broken
    pipe and the execution of the pipe stops.
  prefs: []
  type: TYPE_NORMAL
- en: The force redirection (>|)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This forces redirection even if a `noclobber` option is set for the shell.
    Clobbering means the act of overwriting the content of a file, and this is something
    we have already seen with the redirection, but let''s have a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything goes as expected. We redirected the output of the echo, and on the
    second run, we overwrote the content of the file. But let''s now set the `noclobber`
    option for the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We will try to overwrite the content of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'No way, we are prevented from the accidental overwriting by the `noclobber`
    option set for the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the content of the file is still the same, but now, it is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We forced the redirection and now the content of the file has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Let's revert the `noclobber` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at `man bash` for some interesting options that you can set with
    the `set -o` option to alter the Bash behavior. For instance, take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+B` disables the brace expansion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f` disables the file name expansion, also known as globbing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i` runs a script in the interactive mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n` reads the commands in a script but does not execute them; it is a classical
    dry run mode for syntax check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-o` posix makes everything a POSIX compliant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-p` script runs as SUID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-r` script runs with a restricted shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s` the commands are read from the `stdin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-v` commands are printed to `stdout` before their execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x` is similar to `-v`, but the commands get expanded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logical OR (||)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already understood them, so have a look at the previous pages.
  prefs: []
  type: TYPE_NORMAL
- en: DEMO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This sends a process into the background. Look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'It will hold the prompt for 5 seconds only if you put sleep in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The shell will give you back control immediately, since the sleep process will
    not get any more input from the terminal, leaving the command line available to
    the user. One of the benefits of this is that while you are limited to a single
    foreground process at time. Since during its execution, you will not be able to
    enter any other commands with background processes, you can spawn as many as you
    wish, given the system resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manually force a foreground process to go to the background by pressing *Ctrl*
    + *Z *and then `fg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Logical AND
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the logical AND, and it returns `true` in a test if both the conditions
    are true.
  prefs: []
  type: TYPE_NORMAL
- en: The dash character (-)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dash is the option character, and usually, it denotes an optional parameter
    on a command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also used in parameter substitution as the prefix for the default parameter,
    and it is also used to redirect from/to stdin/stdout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: What we did is get the file name on the `stdout` using the command substitution,
    have it read from the `stdin` with the `-`, then the result of the `tar` operation
    redirected to the `stdout` to create the zipped file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the dash to go back to our previous directory as held in the
    environmental `$OLDPWD` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in an arithmetic operations context, the dash means minus, so we can
    subtract a number from another.
  prefs: []
  type: TYPE_NORMAL
- en: The double dash (--)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The double dash usually stands for long options for a command. For instance,
    in the next example, we use the short option called `-a` and the long option called
    `--all` to enable the same behavior for ls; the long option being usually a more
    human readable form of the shorter one. While the short option starts with a single
    dash, the long option starts with a double dash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: It is also used, as we saw a few pages ago, with the set command to set Bash
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Operator =
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It can be an assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be a string comparison operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Operator +
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This can be used as an operator in an arithmetic context to add a number to
    another one. In a regular expression scenario, it matches one or more of the previous
    regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The plus character is also used by some built-ins to enable some options in
    the parameter substitution context to mark the alternate value that a variable
    expands to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: If `x` is set, it will be use the value of `20` otherwise a null string.
  prefs: []
  type: TYPE_NORMAL
- en: The modulo operator (%)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is the arithmetic operator for modulo, the remainder of a division. The
    modulo operator is also used as the operator for pattern matching in a parameter
    substitution context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Operator ~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This holds the same value of the environment variable called `$HOME`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Operator ~+
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the current working directory whose value is held by the env variable
    named  `$PWD`.
  prefs: []
  type: TYPE_NORMAL
- en: Operator ~-
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the previous working directory whose value is held by the env variable
    named `$OLDPWD`.
  prefs: []
  type: TYPE_NORMAL
- en: Operator ~=
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the matching operator for regular expressions inside double brackets.
    It has been introduced in Bash 3.
  prefs: []
  type: TYPE_NORMAL
- en: Operator ^
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In regular expressions it matches the given pattern starting from the beginning
    of the line. We saw some examples in the previous pages.
  prefs: []
  type: TYPE_NORMAL
- en: The control characters (^ and ^^)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced in Bash 4, they deal with the uppercase conversion in a parameter
    substitution context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the special characters that we saw so far, there is a combination
    of keys. They are usually called control characters that are not actually used
    in a script, but ease your interaction with the terminal. They are a combination
    of two characters, *Ctrl *and another one, pressed together; but they can also
    be written in escaped hexadecimal or octal notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ctrl*+*A*:  This moves the cursor at the beginning of a string of characters
    on the command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+B: This is a backspace, but it does not erase anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+C: This breaks out of a foreground job, terminating it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Ctrl*+*D*: This exits on a shell. If the user is in a terminal window and
    typing, it erases the character the cursor is on. If there is nothing in the window,
    it gets closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*E*: This moves the cursor at the end of a string of characters on the
    command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*F*: This moves the cursor forward of one position on the command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*G*: In a terminal window, this could raise a beep.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*H*: This backspaces and deletes the character under the cursor while 
    backspacing, also known as **rubout**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*I*: This is a horizontal tab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*J*: This is the newline and it can also be expressed as the `\012`
    octal and the `\x0a` hexadecimal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*K*: This is a vertical tab. In a terminal window, it deletes all the
    characters from under the cursor to the end of the line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*L*: This is the formfeed, and it clears the screen from all the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*M*: This is the carriage return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*N*: This  deletes a line called back from the history on the command
    line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*O*: Given on the command line, it brings you to a new line executing
    the current command on CLI .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*P*: This  restores the last command from the history on the command
    line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*Q*: This  resumes `stdin` in a terminal window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*R*: This searches for text in the history, backwards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*S*: This suspends `stdin` in a terminal window, resumed by *Ctrl*+*Q.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*T*: This swaps the character under the cursor with the preceding one
    on the command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*U*: This deletes all characters between the cursor position and at
    the beginning of the command line. In some configurations, it deletes all the
    characters on the command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*V*: This is used mostly in editors, and it allows to enter control
    characters while inserting text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*W*: In a terminal or X term, it deletes characters backwards from under
    the cursor to the first whitespace; in some configurations, it deletes until the
    first non alphanumeric character is reached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*X*: You will find it in quite a number of word processors, as a way
    to cut and paste text from the editor to the clipboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*Y*: This pastes the text erased with *Ctrl*+*U *or *Ctrl*+*W *back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl*+*Z*: This pauses a job that is in the foreground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitespace: This is often used as a field separator. It is sometimes required
    in some context and forbidden in others, as we saw in some of the examples available
    in the previous chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting and escaping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen how important quoting and escaping is in Bash, and this is
    due to the fact that some characters are not just what they look like, but they
    hold some special meaning for the shell, which interprets them whenever it meets
    them. But sometimes, we want these characters for just what they are; we want
    to keep whitespaces in a string and not split it up in words, or we just want
    to see if there is a `*` file name. Or we want to `echo` a double quote and not
    start a quote. So, we quote and escape to preserve what we see from what the shell
    could think it is.
  prefs: []
  type: TYPE_NORMAL
- en: The backslash (\)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The backslash is the character we use to escape all the others. Great. What
    does it mean? Simply put, each character preceded by a backslash keeps its literal
    value or meaning. The backslash does not apply to an entire string, but just to
    its following character, and it is widely used to escape spaces in file names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, not exactly the result we wanted, but it is what we should have expected:
    the whitespace has been interpreted by the shell as a separator, so `mkdir` created
    as many directories as the words given as arguments. We need to have `mkdir` to
    parse a string complete with whitespaces and not a series of words split by spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Here we go, we finally have a directory whose name is filled with spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see the backslash used in scripts or on the command line when
    your instructions are becoming a bit too long. You can see them when you want
    to go on a new line without triggering a carriage return, which would execute
    your incomplete command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Double quotes ("")
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Double quotes** are the so-called weak quoting, since they prevent the interpretation
    by the shell of all metacharacters except for `$`, `"`, `''`, and `\`. This means
    a few things; the most important is that you can reference a variable value even
    if it is quoted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'This also means that you can use backslash to escape `$` to print the literal
    `$a` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: So, to use one of the preceding interpreted characters, you have to escape it
    with a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, double quotes preserve whitespaces, so we can rewrite the command we
    saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mkdir this\ is\ a\ directory\ with\ spaces\ in\ the\ name` as `mkdir "this
    is a directory with spaces in the name".`'
  prefs: []
  type: TYPE_NORMAL
- en: So, what if you want to prevent any interpretations at all? You have to rely
    on a strong quoting.
  prefs: []
  type: TYPE_NORMAL
- en: Single quotes (')
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Single quotes enable a strong quoting so that none of the metacharacters we
    saw before, such as `$`, `"`, `''`, and `\` , are interpreted; and everything
    quoted this way is taken literally except for the single quote itself, which keeps
    its function of the metacharacter. This means that you cannot use it at all since
    the usual way of taking the literal value of a character. Using a backslash does
    not work since inside the single quote, as the backslash itself loses its meta
    effect. One notable effect of strong quoting is that you cannot reference the
    value of a variable any longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'That being said, we still have some characters with special meanings even after
    being escaped; here are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\a` is the alert'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b` is the backspace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\n` is the newline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\r` is the return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\t` is the tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\v` is the vertical tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how to deal safely with variables and special characters,
    it is time to move toward something more useful in our everyday programming. In
    the next chapter, we will have a close look at the case construct, arrays, and
    functions; and this will allow us to create our first fully-fledged command-line
    parser.
  prefs: []
  type: TYPE_NORMAL
