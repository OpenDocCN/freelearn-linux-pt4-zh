<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Managing Web Servers"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Managing Web Servers</h1></div></div></div><p>This chapter contains the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing Apache HTTP Server and PHP</li><li class="listitem" style="list-style-type: disc">Configuring name-based virtual hosting</li><li class="listitem" style="list-style-type: disc">Configuring Apache to serve pages over HTTPS</li><li class="listitem" style="list-style-type: disc">Enabling overrides and performing URL rewriting</li><li class="listitem" style="list-style-type: disc">Installing NGINX as a load balancer</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec80"/>Introduction</h1></div></div></div><p>This chapter contains recipes for working with the Apache HTTP Server to serve websites. You'll first learn how to install the server as well as PHP, a very common server-side scripting engine used to generate dynamic web content. Then you'll see how to serve multiple sites with the same server instance using name-based virtual hosting, encrypt the connection and serve content over HTTPS, and how to rewrite incoming URLs on the fly. We'll finish with looking at NGINX and its use as a reverse proxy to decrease load on the server while at the same time speeding up access to our sites for the user.</p></div></div>
<div class="section" title="Installing Apache HTTP Server and PHP"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec81"/>Installing Apache HTTP Server and PHP</h1></div></div></div><p>You may have heard the acronym LAMP which stands for Linux, Apache, MySQL, and PHP. It refers to the popular pairing of technologies for providing websites and web applications. This recipe teaches you how to install the Apache HTTP Server (Apache for short) and configure it to work with PHP to serve dynamic web content.</p><p>First released over twenty years ago, Apache was one of the first web servers and it continues to be one of the most popular. Its task in the LAMP stack is to interact with the user by responding to their requests for web resources. Perhaps one of its selling points is its design that allows its functionality to be expanded with modules. Many modules exist, from <code class="literal">mod_ssl</code>, which adds HTTPS support to <code class="literal">mod_rewrite</code>, which allows you to modify the request URL on the fly.</p><p>PHP is a scripting language for creating dynamic web content. It works behind the scenes and the output of a script is usually served by Apache to satisfy a request. PHP was commonly installed as a module (<code class="literal">mod_php</code>) that embedded the language's interpreter into Apache's processing, but nowadays, running PHP as a standalone process is preferred. This is the approach we'll take in this recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec261"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. It assumes that the system is configured with the IP address <code class="literal">192.168.56.100</code>. Administrative privileges are also required, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>.</p><p>Note that the official CentOS repositories install PHP 5.4. The Remi repositories offer 5.5, 5.6, and 7.0 if you want to install a newer release. To install one of the 5.x versions, open the <code class="literal">/etc/yum.repos.d/remi.repo</code> file, locate the <code class="literal">enabled</code> option in the <code class="literal">[remi-php55]</code> or <code class="literal">[remi-php56]</code> section and set its value to <code class="literal">1</code>. For 7.0, update the <code class="literal">enabled</code> option found in <code class="literal">/etc/yum.repos.d/remi-php70.repo</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note65"/>Note</h3><p>What happened to PHP 6? <span class="emphasis"><em>It's a long story...</em></span>. The team of volunteers developing PHP was working on version 6, but the initiative faced many hurdles and was eventually shelved. To prevent confusion between the latest release and any blog postings that were written about PHP 6, it was decided that its version number would be bumped to 7. In short, PHP 6 did exist but never achieved a proper release status and most of the cool features planned for 6 made it into PHP 5.3, 5.4, and 7.0.</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec262"/>How to do it...</h2></div></div></div><p>Follow these steps to install Apache HTTP Server and PHP:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">httpd</code> and <code class="literal">php-fpm</code> packages:<pre class="programlisting">
<span class="strong"><strong>yum install httpd php-fpm</strong></span>
</pre></li><li class="listitem">Open Apache's configuration file with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/httpd/conf/httpd.conf</strong></span>
</pre></li><li class="listitem">Locate the <code class="literal">ServerName</code> option. Remove <code class="literal">#</code> appearing at the start of the line to uncomment it and then change the option's value to reflect your server's hostname or IP address:<pre class="programlisting">
<span class="strong"><strong>ServerName 192.168.56.100:80</strong></span>
</pre></li><li class="listitem">Find the <code class="literal">DirectoryIndex</code> option and add <code class="literal">index.php</code> to the list:<pre class="programlisting">
<span class="strong"><strong>       &lt;IfModule dir_module&gt;&#13;
          DirectoryIndex index.html index.php&#13;
       &lt;/IfModule&gt;&#13;
</strong></span>
</pre></li><li class="listitem">At the end of the file, add the following configuration:<pre class="programlisting">
<span class="strong"><strong>       &lt;IfModule proxy_fcgi_module&gt;&#13;
          ProxyPassMatch ^/(.*\.php)$  &#13;
          fcgi://127.0.0.1:9000/var/www/html/$1&#13;
       &lt;/IfModule&gt;&#13;
</strong></span>
</pre></li><li class="listitem">Save your changes to the configuration and close the file.</li><li class="listitem">Verify that <code class="literal">mod_proxy</code> (listed as <code class="literal">proxy_module</code>) and <code class="literal">mod_proxy_fcgi</code> (<code class="literal">proxy_fcgi_module)</code> extension modules are enabled:<pre class="programlisting">
<span class="strong"><strong>httpd -M | grep proxy</strong></span>
</pre></li><li class="listitem">Both modules should appear in the output.</li><li class="listitem">Start Apache and PHP's FPM service and enable them to start automatically when your system reboots:<pre class="programlisting">
<span class="strong"><strong>systemctl start httpd.service php-fpm.service</strong></span>
<span class="strong"><strong>systemctl enable httpd.service php-fpm.service</strong></span>
</pre></li><li class="listitem">Open port <code class="literal">80</code> in the system's firewall to allow HTTP requests through:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-service=http</strong></span>
<span class="strong"><strong>firewall-cmd --reload</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec263"/>How it works...</h2></div></div></div><p>There are several ways to integrate PHP with Apache's HTTP server to generate dynamic web content. Historically, using Apache's <code class="literal">mod_php</code> module was the way to go, but now the preferred approach is to run PHP as a separate process, which the web server communicates with using the FastCGI protocol. So, we installed the <code class="literal">httpd</code> package for the Apache HTTP Server and the <code class="literal">php-fpm</code> package for the PHP interpreter and its process manager:</p><pre class="programlisting">
<span class="strong"><strong>yum install httpd php-fpm</strong></span>
</pre><p>The PHP FastCGI Process Manager (FPM) is included in the core PHP distributions as of version 5.3. Separating PHP from Apache encourages a more scalable architecture, and using a persistent PHP process reduces CPU overhead because a new interpreter doesn't have to be spawned for each request.</p><p>Apache's main configuration file is <code class="literal">/etc/httpd/conf/httpd.conf</code>, in which we updated the <code class="literal">ServerName</code> option to reflect our server's hostname or IP address. While this step isn't strictly necessary, if we don't set the option then the server will write warning messages to its log files. Besides, it's useful for the server to be able to identify itself:</p><pre class="programlisting">
<span class="strong"><strong>ServerName 192.168.56.100:80</strong></span>
</pre><p>Next, we updated for the <code class="literal">DirectoryIndex</code> option by adding <code class="literal">index.php</code> to its list of values. When the user requests a resource that resolves to a directory, the server will look in that directory for a file that matches one of the names in the <code class="literal">DirectoryIndex</code> list. If found, Apache will return that file to satisfy the request. This behavior is what allows visitors to access a website's home page with a URL such as <code class="literal">www.example.com</code> rather than <code class="literal">www.example.com/index.html</code>:</p><pre class="programlisting">
<span class="strong"><strong>DirectoryIndex index.html index.php</strong></span>
</pre><p>The order in which files are listed is significant. For example, if both <code class="literal">index.html</code> and <code class="literal">index.php</code> exist in the directory then <code class="literal">index.html</code> will be returned because it's listed before <code class="literal">index.php</code> in the option's list.</p><p>Then we navigated to the end of the file to add the following proxy configuration. If the regular expression of <code class="literal">ProxyPassMatch</code> matches the incoming request then the server retrieves the given URL and returns that content instead:</p><pre class="programlisting">
<span class="strong"><strong>    &lt;IfModule proxy_fcgi_module&gt;&#13;
      ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/var/www/html/$1&#13;
    &lt;/IfModule&gt;&#13;
</strong></span>
</pre><p>Regular expressions are written using a special notation that describes how to match text. Most characters are matched literally, but some have special meaning:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">.</code>: This matches any character. The pattern <code class="literal">bu.</code> matches against the text <code class="literal">bud</code>, <code class="literal">bug</code>, <code class="literal">bun</code>, <code class="literal">bus</code>, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">+</code>: This matches the preceding element one or more times. The pattern <code class="literal">fe+t</code> matches <code class="literal">fet</code>, <code class="literal">feet</code>, and <code class="literal">feeet</code> and so on but not <code class="literal">ft</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">*</code>: This optionally matches the preceding element any number of times. The pattern <code class="literal">fe*t</code> matches <code class="literal">ft</code>, <code class="literal">fet</code>, <code class="literal">feet</code>, <code class="literal">feeet</code>, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">?</code>: This optionally matches the preceding element once. The pattern <code class="literal">colou?r</code> matches <code class="literal">color</code> and <code class="literal">colour</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">^</code>: This anchors the match to the beginning of the line. The pattern <code class="literal">^abc</code> only matches <code class="literal">abc</code> if <code class="literal">abc</code> appears at the beginning of the text (<code class="literal">^</code> has special significance when used in <code class="literal">[ ]</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">$</code>: This anchors the match to the end of the line. The pattern <code class="literal">xyz$</code> only matches <code class="literal">xyz</code> if <code class="literal">xyz</code> appears at the end of the line.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[ ]</code>: This matches any of the characters given within the brackets. The pattern <code class="literal">co[lr]d</code> matches <code class="literal">cold</code> and <code class="literal">cord</code>. When the first character in <code class="literal">[ ]</code> is <code class="literal">^</code> then the list is negated; <code class="literal">co[^lr]d</code> matches <code class="literal">coed</code> but not <code class="literal">cold</code> or <code class="literal">cord</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">( )</code>: This groups elements and captures matches. The pattern <code class="literal">jump(ed)?</code> matches <code class="literal">jump</code> and <code class="literal">jumped</code>.</li></ul></div><p>If you want any of these special characters to be matched literally then you should escape them with a leading backslash, for example <code class="literal">foo\.html</code> will match <code class="literal">foo.html</code> instead of <code class="literal">fooahtml</code>, <code class="literal">foobhtml</code>, and so on.</p><p>Special numeric variables like <code class="literal">$1</code> and <code class="literal">$2</code> contain the value of any captured matches. The order in which they are populated are the order in which the parentheses capture a match, thus <code class="literal">(foo)\.(html)</code> sets <code class="literal">$1</code> to <code class="literal">foo</code> and <code class="literal">$2</code> to <code class="literal">html</code>.</p><p>With this understanding, you should now be able to decipher that the regular expression <code class="literal">^/(.*\.php)$</code> captures the path and filename of the requested resource that end with the extension <code class="literal">.php</code>. The <code class="literal">$1</code> variable represents the captured path, so a request for <code class="literal">/about/staff.php</code> will be proxied as <code class="literal">fcgi://127.0.0.1:9000/var/www/html/about
/staff.php</code> where PHP's Fast-CGI listener is listening to the local interface on port <code class="literal">9000</code>.</p><p>Apache's functionality is often extended through modules, and as a safeguard it's a good practice to wrap module-specific configuration options in an <code class="literal">IfModule</code> block. The opening of such blocks contain the name of the module and appear in angle brackets <code class="literal">&lt; &gt;</code>. The block's closing appears as <code class="literal">&lt;/IfModule&gt;</code> just like closing an HTML element.</p><p>The directory out of which the server serves files from is set by the option <code class="literal">DocumentRoot</code>. The default value is <code class="literal">/var/www/html</code>, so any files we place there or in a subdirectory within it will be accessible. As an example to illustrate this, the distribution includes a sample <code class="literal">index.html</code> file, which we can use to verify that the server is running correctly; copy the <code class="literal">/usr/share/httpd/noindex/index.html</code> file to <code class="literal">/var/www/html</code>:</p><pre class="programlisting">
<span class="strong"><strong>cp /usr/share/httpd/noindex/index.html /var/www/html</strong></span>
</pre><p>Then, open your browser and navigate to the domain or IP address of the system. You should see the welcome page:</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_10_001.jpg"/><div class="caption"><p>You can copy Apache's default index page to the web directory to test whether the server is up and running</p></div></div><p>For PHP, you need to place a PHP file where it can be read by the Fast-CGI service. The proxy URL is <code class="literal">fcgi://127.0.0.1:9000/var/www/html/$1</code>, so that we can place our PHP files in <code class="literal">/var/www/html</code> as well.</p><p>Create the <code class="literal">info.php</code> file with the following content:</p><pre class="programlisting">
<span class="strong"><strong>    &lt;?php&#13;
    phpinfo();&#13;
</strong></span>
</pre><p>Now save the file and then navigate to the page in your browser. You should see the output of PHP's <code class="literal">phpinfo()</code> function providing detailed information on how PHP is configured and which of its modules are available:</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_10_002.jpg"/><div class="caption"><p>PHP reports information about its environment and the request</p></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note66"/>Note</h3><p>For security purposes, it's recommended that you delete the welcome <code class="literal">index.html</code> file if you copied it over and the <code class="literal">info.php</code> script after you verify everything works. The information they present can give malicious users more information about the set up of your web server than you'd like them to have.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec264"/>See also</h2></div></div></div><p>Refer to the following resources for more information on working with Apache and PHP:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Apache HTTP Server Project (<a class="ulink" href="http://httpd.apache.org/">http://httpd.apache.org/</a>)</li><li class="listitem" style="list-style-type: disc">The PHP home page (<a class="ulink" href="http://php.net/">http://php.net/</a>)</li><li class="listitem" style="list-style-type: disc">Apache <code class="literal">mod_proxy_fcgi</code> documentation (<a class="ulink" href="http://httpd.apache.org/docs/current/mod/mod_proxy_fcgi.html">http://httpd.apache.org/docs/current/mod/mod_proxy_fcgi.html</a>)</li><li class="listitem" style="list-style-type: disc">Httpd Wiki: PHP-FPM (<a class="ulink" href="http://wiki.apache.org/httpd/PHP-FPM">http://wiki.apache.org/httpd/PHP-FPM</a>)</li><li class="listitem" style="list-style-type: disc">RFC-2616: HTTP/1.1 (<a class="ulink" href="http://www.rfc-base.org/txt/rfc-2616.txt">http://www.rfc-base.org/txt/rfc-2616.txt</a>)</li></ul></div></div></div>
<div class="section" title="Configuring name-based virtual hosting"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec82"/>Configuring name-based virtual hosting</h1></div></div></div><p>As you may recall from our discussions surrounding DNS in <a class="link" href="ch08.html" title="Chapter 8. Managing Domains and DNS">Chapter 8</a>, <span class="emphasis"><em>Managing Domains and DNS</em></span> a user's browser needs to translate a website's hostname to its IP address via DNS lookups before it can connect and retrieve the desired web content. You may also recall that this doesn't have to be a one-to-one mapping-more than one site can resolve to the same IP address. Apache is flexible enough so that the same server can serve more than one site by a configuration known as name-based virtual hosting.</p><p>This recipe teaches you how to set up name-based virtual hosting. Each site has it's own configuration (often kept in its own configuration file for better organization). Based on the site name that appears in the request, Apache then selects from the available configurations to properly serve the desired site.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec265"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection and running Apache as described in the previous recipe. Because we'll be connecting to the server via a domain name instead of an IP address, you'll need to make sure the name resolves to the correct address by updating your DNS records or adding entries to <code class="literal">/etc/hosts</code> first. Administrative privileges are also required, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec266"/>How to do it...</h2></div></div></div><p>Follow these steps to set up name-based virtual hosting:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open Apache's configuration file with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/httpd/conf/httpd.conf</strong></span>
</pre></li><li class="listitem">At the bottom of the file, add the following <code class="literal">Include</code> option:<pre class="programlisting">
<span class="strong"><strong>Include sites/*.conf</strong></span>
</pre></li><li class="listitem">Save the updated configuration and close the file.</li><li class="listitem">Create the <code class="literal">sites</code> directory referenced in the configuration:<pre class="programlisting">
<span class="strong"><strong>mkdir /etc/httpd/sites</strong></span>
</pre></li><li class="listitem">Create a virtual host configuration file within the new <code class="literal">sites</code> directory for your first site:<pre class="programlisting">
<span class="strong"><strong>vi /etc/httpd/sites/www.example.conf</strong></span>
</pre></li><li class="listitem">Add the following code to the site's configuration file:<pre class="programlisting">
<span class="strong"><strong>       &lt;VirtualHost *:80&gt;&#13;
         ServerName www.example.com&#13;
         DocumentRoot "/var/www/example.com/www/html"&#13;
    &#13;
         &lt;IfModule proxy_fcgi_module&gt;&#13;
            ProxyPassMatch ^/(.*\.php)$ &#13;
            fcgi://127.0.0.1:9000/var/www/example.com/www/html/$1&#13;
         &lt;/IfModule&gt;&#13;
       &lt;/VirtualHost&gt;&#13;
</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Create the site's document root referenced in the configuration options:<pre class="programlisting">
<span class="strong"><strong>mkdir -p /var/www/example.com/www/html</strong></span>
</pre></li><li class="listitem">Repeat steps 4-8 for each additional site you will be hosting, using the host or domain name to create a unique directory path for each site.</li><li class="listitem">Restart the HTTP server for the configuration changes to take effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart httpd.service</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec267"/>How it works...</h2></div></div></div><p>Configuring Apache to serve multiple domains is a matter of creating a <code class="literal">VirtualHost</code> definition for each site. This recipe organizes the definitions in their own file under the directory <code class="literal">/etc/httpd/sites</code> and then references them in the main <code class="literal">httpd.conf</code> configuration file using an <code class="literal">Include</code> directive:</p><pre class="programlisting">
<span class="strong"><strong>Include sites/*.conf</strong></span>
</pre><p>How you organize your sites is up to you. This recipe uses a scheme where each site is served from a path based on the domain name followed by the subdomain rooted in <code class="literal">/var/www</code>. The path <code class="literal">/var/www/example.com/www/html</code> contains the files for the site at <code class="literal">www.example.com</code>. Files for the site at <code class="literal">web.example.com</code> would be placed in <code class="literal">/var/www/example.com/web/html</code>. The <code class="literal">html</code> directory is simply the web-accessible root for the site. By including it instead of serving files out of <code class="literal">example.com/www</code> directly, we can place any supporting files outside the root which aren't mean to be accessed directly (for example, a script with configuration options for a PHP website), but still keep them organized with the rest of the site's files.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note67"/>Note</h3><p>Naming the publicly accessible directory root <code class="literal">html</code> is a convention, but its one that I find outdated since more than just HTML files are often served. I often name my own root directories <code class="literal">public</code> or <code class="literal">public_files</code> and update their references in the configuration file accordingly.</p></div></div><p>Each definition for a virtual host is contained within a <code class="literal">VirtualHost</code> block. The opening provides the IP address of the interface on which the server is listening followed by the port number. <code class="literal">*</code> indicates that the definition applies to all of the system's interfaces and <code class="literal">80</code> is the default port for HTTP traffic:</p><pre class="programlisting">
<span class="strong"><strong>    &lt;VirtualHost *:80&gt;&#13;
</strong></span>
</pre><p>Options that don't appear explicitly in the definition are assumed to have the same settings as found in the main configuration, so at a minimum, the <code class="literal">ServerName</code> and <code class="literal">DocumentRoot</code> options need to be defined to make the definition unique. If you're using PHP, you'll want to provide the <code class="literal">ProxyPassMatch</code> option as well so that the requests are mapped to the correct PHP files:</p><pre class="programlisting">
<span class="strong"><strong>    &lt;VirtualHost *:80&gt;&#13;
      ServerName www.example.com&#13;
      DocumentRoot "/var/www/example.com/www/html"&#13;
      &lt;IfModule proxy_fcgi_module&gt;&#13;
        ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/var/www/  &#13;
        example.com/www/html/$1&#13;
      &lt;/IfModule&gt;&#13;
    &lt;/VirtualHost&gt;&#13;
</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note68"/>Note</h3><p>The order in which the virtual host definitions are loaded is somewhat important; the first one loaded acts as the default and will handle any requests that do not match any of the virtual hosts definitions. Prefixing the configuration files numerically, for example <code class="literal">10-www.example.conf</code>, can help you control the loading order.</p></div></div><p>Each request is logged to <code class="literal">/var/log/httpd/access_log</code> and any errors are logged to <code class="literal">error_log</code>. Of course, this is fine if you're only serving one site. But when serving multiple sites, you may find it beneficial to route log entries to different files for different sites. The <code class="literal">CustomLog</code> option names a file where the access and general logging messages are written to and the format of the entries. <code class="literal">ErrorLog</code> specifies the file where the error messages are written. Both of these options can appear in a virtual host's configuration:</p><pre class="programlisting">    &lt;VirtualHost *:80&gt;&#13;
      ServerName www.example.com&#13;
      DocumentRoot "/var/www/example.com/www/html"&#13;
      CustomLog "/var/log/httpd/example.com/www/access_log" "%h %u &#13;
      %t "%r" %&gt;s %b"&#13;
      ErrorLog  "/var/log/httpd/example.com/www/error_log"&#13;
      &lt;IfModule proxy_fcgi_module&gt;&#13;
        ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/var/www/&#13;
        example.com/www/html/$1&#13;
      &lt;/IfModule&gt;&#13;
    &lt;/VirtualHost&gt;&#13;
</pre><p>The second argument to <code class="literal">CustomLog</code> can be the format string itself or an alias that represents the format string. Format strings simply define what details are contained in the logged messages.</p><p>There's a slew of format specifiers available which are all documented in the Apache HTTPd Server's documentation. Here's a list of some of the more common ones you may use, while you can find a complete list online at <a class="ulink" href="http://httpd.apache.org/docs/current/mod/mod_log_config.html#formats">http://httpd.apache.org/docs/current/mod/mod_log_config.html#formats</a>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">%b</code>: This is the size of the response (in bytes) served back to the client</li><li class="listitem" style="list-style-type: disc"><code class="literal">%D</code>: This is the time taken to process the request in milliseconds (<code class="literal">%T</code> represents the time taken in seconds)</li><li class="listitem" style="list-style-type: disc"><code class="literal">%h</code>: This is the IP or hostname of the requesting system</li><li class="listitem" style="list-style-type: disc"><code class="literal">%H</code>: This is the protocol used to make the request</li><li class="listitem" style="list-style-type: disc"><code class="literal">%m</code>: This is the method used to make the request</li><li class="listitem" style="list-style-type: disc"><code class="literal">%q</code>: This is the query string portion of the requested URI</li><li class="listitem" style="list-style-type: disc"><code class="literal">%r</code>: This is the first line of the request</li><li class="listitem" style="list-style-type: disc"><code class="literal">%&gt;s</code>: This is the request's final status code (<code class="literal">%s</code> represents the initial status for requests that are redirected)</li><li class="listitem" style="list-style-type: disc"><code class="literal">%t</code>: This is the time when the request was received</li><li class="listitem" style="list-style-type: disc"><code class="literal">%u</code>: This is the username for authenticated requests when the request was received</li><li class="listitem" style="list-style-type: disc"><code class="literal">%v</code>: This is the name of the server (<code class="literal">ServerName</code>) handling the request</li></ul></div><p>The <code class="literal">LogFormat</code> option names a format string with an alias. For example, the <code class="literal">httpd.conf</code> file uses <code class="literal">LogFormat</code> to define strings named as <code class="literal">common</code> and <code class="literal">combined</code>, which can be used elsewhere. It's a good idea to define your own alias for your virtual host logging and use the alias in the individual configuration files rather than having cryptic format strings scattered about. In <code class="literal">httpd.conf</code>, simply add your custom <code class="literal">LogFormat</code> entry in the same area as the <code class="literal">common</code> and <code class="literal">combined</code> entries:</p><pre class="programlisting">
<span class="strong"><strong>LogFormat "%v %h %u %t "%r" %&gt;s %b" vhostcommon</strong></span>
</pre><p>Then, you can reference the alias in your sites' configuration files:</p><pre class="programlisting">
<span class="strong"><strong>CustomLog "/var/www/example.com/www/logs/access_log" vhostcommon</strong></span>
</pre><p>After making the changes, restart Apache for the configuration to take effect.</p><p>Whatever their destination, make sure the ownership/permissions your security context allow Apache runs to write to the log file. If the logs reside under <code class="literal">/var/log/httpd</code> then creating the necessary subdirectories should be sufficient. The server will create the log files itself when it starts:</p><pre class="programlisting">
<span class="strong"><strong>mkidr -p /var/log/httpd/example.com/www</strong></span>
</pre><p>However, if you wish to keep the logs in another directory, perhaps such as <code class="literal">/var/www/example.com/www/logs</code>, the server may be blocked from writing to them. SELinux is enabled regardless of the filesystem permissions appearing sane. To fix the situation, first verify the security context with <code class="literal">ls -Z</code>:</p><pre class="programlisting">
<span class="strong"><strong>ls -Z /var/www/example.com/www | grep logs</strong></span>
<span class="strong"><strong>drwxr-xr-x. apache apache unconfined_u:object_r:httpd_sys_content_  &#13;
t:s0 logs</strong></span>
</pre><p>In this case, the <code class="literal">logs</code> directory is owned by the <code class="literal">apache</code> user, which Apache runs under, and the permissions on the directory should allow the server to create the log files. However, we can also see that the directory has inherited the label that identifies it as web content as indicated by <code class="literal">httpd_sys_content_t</code>. To fix the problem, we need to relabel the directory for logging purposes using <code class="literal">chcon</code>:</p><pre class="programlisting">
<span class="strong"><strong>chcon -Rv --type=httpd_log_t /var/www/example.com/www/logs</strong></span>
</pre></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec268"/>See also</h2></div></div></div><p>Refer to the following resources for more information on working with virtual hosting:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Apache Virtual Host documentation (<a class="ulink" href="http://httpd.apache.org/docs/current/vhosts/">http://httpd.apache.org/docs/current/vhosts/</a>)</li><li class="listitem" style="list-style-type: disc">Apache <code class="literal">mod_log_config</code> documentation (<a class="ulink" href="http://httpd.apache.org/docs/current/mod/mod_log_config.html">http://httpd.apache.org/docs/current/mod/mod_log_config.html</a>)</li><li class="listitem" style="list-style-type: disc">VirtualHost examples (<a class="ulink" href="http://httpd.apache.org/docs/current/vhosts/examples.html">http://httpd.apache.org/docs/current/vhosts/examples.html</a>)</li><li class="listitem" style="list-style-type: disc">CentOS Wiki: SELinux HowTo (<a class="ulink" href="https://wiki.centos.org/HowTos/SELinux">https://wiki.centos.org/HowTos/SELinux</a>)</li></ul></div></div></div>
<div class="section" title="Configuring Apache to serve pages over HTTPS"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec83"/>Configuring Apache to serve pages over HTTPS</h1></div></div></div><p>HTTP traffic is sent in plain text across the network. In an untrusted environment, a malicious user can monitor and capture the traffic to spy on what sites you're visiting and what content you're reading. While such snooping isn't interesting if the victim is just reading the daily news or watching cat videos on YouTube, the user's credit card number, shipping address, and other details could be snagged if an e-commerce transaction were to take place unencrypted. To support encrypted traffic, Apache supports HTTPS. This recipe will teach you how to configure HTTPS support and protect your users' traffic from prying eyes no matter how benign the content is.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec269"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. It assumes that the system is configured with the IP address <code class="literal">192.168.56.100</code> and is running Apache as described in the previous recipes. Administrative privileges are also required, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec270"/>How to do it...</h2></div></div></div><p>Follow these steps to serve pages over HTTPS:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Generate a new key file and security certificate using <code class="literal">openssl</code>:<pre class="programlisting">
<span class="strong"><strong>openssl req -newkey rsa:2048 -nodes \</strong></span>
<span class="strong"><strong>     -keyout /etc/pki/tls/private/www.example.key \</strong></span>
<span class="strong"><strong>     -x509 -days 730 -subj "/CN=www.example.com" -text \</strong></span>
<span class="strong"><strong>     -out /etc/pki/tls/certs/www.example.pem</strong></span>
</pre></li><li class="listitem">Install the server's SSL module:<pre class="programlisting">
<span class="strong"><strong>yum install mod_ssl</strong></span>
</pre></li><li class="listitem">Open the <code class="literal">/etc/httpd/conf.d/ssl.conf</code> file with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/httpd/conf.d/ssl.conf</strong></span>
</pre></li><li class="listitem">Locate the <code class="literal">SSLCertificateFile</code> option and update its value to point to the self-signed certificate file:<pre class="programlisting">
<span class="strong"><strong>SSLCertificateFile /etc/pki/tls/certs/www.example.pem</strong></span>
</pre></li><li class="listitem">Locate the <code class="literal">SSLCertificateKeyFile</code> option and update it to point to the encryption key:<pre class="programlisting">
<span class="strong"><strong>SSLCertificateKeyFile /etc/pki/tls/private/www.example.key</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Restart the server for the updated configuration to take effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart httpd</strong></span>
</pre></li><li class="listitem">Open port <code class="literal">443</code> in the firewall to allow HTTPS traffic:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-service=https</strong></span>
<span class="strong"><strong>firewall-cmd --reload</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec271"/>How it works...</h2></div></div></div><p>The Apache HTTP Server comes with a default SSL/TLS configuration contained within a catch-all virtual host definition in <code class="literal">/etc/httpd/conf.d/ssl.conf</code>. With most of the configuration already done for us, all that's left is to install the SSL module, generate a new key and certificate, and update the configuration to point to our files.</p><p>First, we generated a new encryption key and signing certificate. If you've already read the <span class="emphasis"><em>Configuring Postfix to use TLS</em></span> recipe in <a class="link" href="ch09.html" title="Chapter 9. Managing E-mails">Chapter 9</a>, <span class="emphasis"><em>Managing E-mails</em></span>, then you already know that the key is needed for secured communication and the certificate confirms the ownership of the key:</p><pre class="programlisting">
<span class="strong"><strong>openssl req -newkey rsa:2048 -nodes \</strong></span>
<span class="strong"><strong>  -keyout /etc/pki/tls/private/www.example.key \</strong></span>
<span class="strong"><strong>  -x509 -days 730 -subj "/CN=www.example.com" -text \</strong></span>
<span class="strong"><strong>  -out /etc/pki/tls/certs/www.example.pem</strong></span>
</pre><p>The recipe generates a self-signed certificate which is sufficient for personal use and intranet sites. The <code class="literal">req</code> option creates a new certificate and <code class="literal">-newkey</code> generates a new private key. The key is a 2048-bit RSA key and itself is not encrypted (<code class="literal">-nodes</code>), so we don't need to provide a passphrase to decrypt the key every time we start the web server. The certificate is an X.509 certificate (<code class="literal">-x509</code>) and is valid for 3 years (<code class="literal">-days 730</code>). The certificate's <code class="literal">CN</code> field must match the domain name of the site it will be used for.</p><p>In the configuration file, the <code class="literal">SSLCertificateFile</code> option specifies the file that contains the certificate file and the key is identified using <code class="literal">SSLCertificateKeyFile</code>:</p><pre class="programlisting">
<span class="strong"><strong>SSLCertificateFile /etc/pki/tls/certs/www.example.pem</strong></span>
<span class="strong"><strong>SSLCertificateKeyFile /etc/pki/tls/private/www.example.key</strong></span>
</pre><p>The server determines which virtual host configuration to use to handle a request by looking at the site's name in the incoming request. However, the original HTTPS implementation encrypted the request in its entirety between the web client and server, including the site's hostname, which raised a chicken and egg problem. The server needed to know which certificate to serve and couldn't know it without reading the request, and the client wanted a certificate that matched the site's domain before it would even send the request. It was impossible to use TLS with name-based virtual hosting and any encrypted site required its own dedicated IP address.</p><p>RFC-3546 (Transport Layer Security Extensions) modified the protocol so that the hostname could be sent unencrypted. This allowed the server to select the correct certificate to satisfy the client and opened the door for using TLS with virtual hosting. It took approximately ten years for the major browsers to support the change but we're pretty much there now Internet Explorer as of version 7, Mozilla Firefox as of version 2, and Google Chrome as of version 6 support what is known as Server Name Indication (SNI).</p><p>To server your virtual hosts over HTTPS, each site will need its own certificate and key. Then, add the <code class="literal">SSLEngine</code>, <code class="literal">SSLCertificateFile</code>, and <code class="literal">SSLCertificateKeyFile</code> options to the host's configuration. The port number also needs to be changed in the configuration to <code class="literal">443</code>, the default port for HTTPS traffic:</p><pre class="programlisting">
<span class="strong"><strong>    &lt;VirtualHost *:443&gt;&#13;
      ServerName www.example.com&#13;
      DocumentRoot "/var/www/example.com/www/html"&#13;
      CustomLog "/var/log/httpd/example.com/www/access_log" common&#13;
      ErrorLog  "/var/log/httpd/example.com/www/error_log"&#13;
      SSLEngine on&#13;
      SSLCertificateFile /etc/pki/tls/certs/www.example.pem&#13;
      SSLCertificateKeyFile /etc/pki/tls/private/www.example.key&#13;
      &lt;IfModule proxy_fcgi_module&gt;&#13;
        ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/var/www/&#13;
        example.com/www/html/$1&#13;
      &lt;/IfModule&gt;&#13;
    &lt;/VirtualHost&gt;&#13;
</strong></span>
</pre><p>Although self-signed certificates are adequate for personal use and private network/intranet sites, most likely you'll want to use a trusted certificate for sites accessible on a larger scale. However, depending on the Certificate Authority and the specifics of your request, purchasing a trusted certificate can be expensive. If you need only a basic trusted certificate, then you might want to investigate whether Let's Encrypt will meet your needs. Let's Encrypt is a project offering an automated, self-service model for generating trusted certificates for free.</p><p>To use <span class="emphasis"><em>Let's Encrypt</em></span>, you'll need to install the <code class="literal">certbot</code> package available in the EPEL repository (refer to the <span class="emphasis"><em>Registering the EPEL and Remi repositories</em></span> recipe in          
<a class="link" href="ch04.html" title="Chapter 4. Software Installation Management">Chapter 4</a>,<span class="emphasis"><em> Software Installation Management</em></span> if you haven't already enabled the repository). Then run the <code class="literal">certbot certonly</code> command and follow the prompts to request your certificate. Full instructions can be found online in the Let's Encrypt/Certbot User Guide at   
<a class="ulink" href="http://letsencrypt.readthedocs.io/en/latest/using.html">http://letsencrypt.readthedocs.io/en/latest/using.html</a>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note69"/>Note</h3><p>There are a few caveats to Let's Encrypt. First, the certificates are only valid for three months; you'll need to request a new certificate every 90 days. It also won't generate certificates for IP addresses. Also, it rate limits requests which, although necessary to help prevent abuse, causes issues for those using a dynamic DNS service such as DynDNS or NoIP to make their sites accessible. For Let's Encrypt to be a viable option for you, you'll need a proper domain and access to the web system to automate the renewal. If you're running a home server or using a shared hosting provider, then Let's Encrypt is probably not for you.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec272"/>See also</h2></div></div></div><p>Refer to the following resources for working with HTTPS:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SSL/TLS Strong Encryption: How-To (<a class="ulink" href="http://httpd.apache.org/docs/2.4/ssl/ssl_howto.html">http://httpd.apache.org/docs/2.4/ssl/ssl_howto.html</a>)</li><li class="listitem" style="list-style-type: disc">How to create an SSL Certificate for Apache on CentOS 7 (<a class="ulink" href="http://www.digitalocean.com/community/tutorials/how-to-create-an-ssl-certificate-on-apache-for-centos-7">http://www.digitalocean.com/community/tutorials/how-to-create-an-ssl-certificate-on-apache-for-centos-7</a>)</li><li class="listitem" style="list-style-type: disc">How to secure Apache with Let's Encrypt on CentOS 7 (<a class="ulink" href="https://www.digitalocean.com/community/tutorials/how-to-secure-apache-with-let-s-encrypt-on-centos-7">https://www.digitalocean.com/community/tutorials/how-to-secure-apache-with-let-s-encrypt-on-centos-7</a>)</li></ul></div></div></div>
<div class="section" title="Enabling overrides and performing URL rewriting"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec84"/>Enabling overrides and performing URL rewriting</h1></div></div></div><p>This recipe teaches you how to use <code class="literal">mod_rewrite</code>. I mentioned <code class="literal">mod_rewrite</code> earlier; it is a module for Apache that allows us to modify the URL and resolve it to different resources. There are many reasons one would want to do this. For example, perhaps you moved some files and their URL changed, but you don't want any links that exist elsewhere still pointing to the old destinations to be broken. You can write a rewrite rule that matches the old locations and updates the URL on the fly to successfully satisfy the request. Another example is SEO; you may have long, unfriendly canonical URLs for a resource but want something shorter and more memorable. The friendly URLs can be mapped to the canonical URL behind the scenes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec273"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. It assumes that the system is configured with the IP address <code class="literal">192.168.56.100</code> and is running Apache as described in the previous recipes. Administrative privileges are also required, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec274"/>How to do it...</h2></div></div></div><p>Follow these steps to perform URL rewriting:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">/etc/httpd/conf/httpd.conf</code> file with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/httpd/conf/httpd.conf</strong></span>
</pre></li><li class="listitem">Locate the <code class="literal">Directory</code> section that defines various options for your document root. Find its <code class="literal">AllowOverrides</code> option and update the value from <code class="literal">None</code> to <code class="literal">All</code>:<pre class="programlisting">
<span class="strong"><strong>       &lt;Directory "/var/www/html"&gt;&#13;
       ...&#13;
           AllowOverrides All&#13;
       ...&#13;
       &lt;/Directory&gt;&#13;
</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Restart Apache for the configuration update to take effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart httpd</strong></span>
</pre></li><li class="listitem">Verify that the <code class="literal">mod_rewrite</code> module (identified as <code class="literal">rewrite_module</code>) is available:<pre class="programlisting">
<span class="strong"><strong>httpd -M | grep rewrite</strong></span>
</pre></li><li class="listitem">Create a file named <code class="literal">.htaccess</code> in your document root:<pre class="programlisting">
<span class="strong"><strong>       vi /var/www/html/.htaccess &#13;
</strong></span>
</pre></li><li class="listitem">In the <code class="literal">.htaccess</code> file, add <code class="literal">RewriteEngine</code> to turn on the URL rewriting engine:<pre class="programlisting">
<span class="strong"><strong>RewriteEngine on</strong></span>
</pre></li><li class="listitem">Add <code class="literal">Rewrite</code> rules that describe the desired redirects. For example, the following rule redirects all requests without a file extension to a PHP file of the given name:<pre class="programlisting">
<span class="strong"><strong>RewriteRule ^/?([A-Z]+)$ $1.php [NC,L]</strong></span>
</pre></li><li class="listitem">Save and close the file.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec275"/>How it works...</h2></div></div></div><p>The <code class="literal">.htaccess</code> files are supplemental configuration files that reside in the sites' directory structure. When configured, Apache searches for an <code class="literal">.htaccess</code> file and applies the option settings in it while satisfying a request. Of course, searching and loading configuration values for each request does have a slight performance impact, but its trade-off increases flexibility. For example, the server doesn't need to be restarted for configuration changes in an <code class="literal">.htaccess</code> file to take effect. In a shared-hosting environment, savvy clients can tweak the server's behavior for their own sites without asking a server administrator or requiring access to the main configuration files in <code class="literal">/etc/httpd</code> (which may contain sensitive configuration values). Even web applications that rely on specific server features might include an <code class="literal">.htaccess</code> file with the necessary configuration to make its deployment easier.</p><p>Apache doesn't allow the use of the <code class="literal">.htaccess</code> files to override the server's configuration by default. To enable it, we need to update the <code class="literal">AllowOverrides</code> option in the appropriate context and then restart the server. This recipe made the change in the section that applies to the web root directory:</p><pre class="programlisting">
<span class="strong"><strong>    &lt;Directory "/var/www/html"&gt;&#13;
    ...&#13;
        AllowOverrides All&#13;
    ...&#13;
    &lt;/Directory&gt;&#13;
</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note70"/>Note</h3><p>If you're using virtual hosting, be sure to put the <code class="literal">AllowOverrides</code> option in your site's configuration file.</p></div></div><p>A value of <code class="literal">None</code> causes the server to ignore any <code class="literal">.htaccess</code> files. Apart from that, not all options are allowed in an <code class="literal">.httaccess</code> file. The most common ones found in the files pertain to rewriting requests or directory-specific access. Those that can appear are grouped under different categories and we can specify the category of options that will be allowed to be overridden. The possible group names are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AuthConfig</code>: This allows overriding the authorization options (<code class="literal">AuthUserFile</code>, <code class="literal">AuthDBMUserFile</code>, and so on)</li><li class="listitem" style="list-style-type: disc"><code class="literal">FileInfo</code>: This allows overriding request-related options (<code class="literal">ErrorDocument</code>, <code class="literal">Redirect</code>, <code class="literal">RewriteRule</code>, and so on)</li><li class="listitem" style="list-style-type: disc"><code class="literal">Indexes</code>: These allow index-related options to be overridden (<code class="literal">DirectoryIndex</code>, <code class="literal">IndexOptions</code>, and so on)</li><li class="listitem" style="list-style-type: disc"><code class="literal">Limit</code>: This allows the access options to be overridden (<code class="literal">Allow</code>, <code class="literal">Deny</code>, and <code class="literal">Order</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">All</code>: This allows overriding all of the option groups</li></ul></div><p>Since <code class="literal">AllowOverrides</code> applies to the directory level, it's possible to allow or deny different overrides in different directories. For example, overriding can be disabled across a site, but then the authorization options can be overridden for a <code class="literal">private</code> directory so that the specific authorization databases can be specified:</p><pre class="programlisting">
<span class="strong"><strong>    &lt;Directory "/var/www/html"&gt;&#13;
        AllowOverrides None&#13;
    &lt;/Directory&gt;&#13;
    &lt;Directory "/var/www/html/priv"&gt;&#13;
        AllowOverrides AuthConfig&#13;
    &lt;/Directory&gt;&#13;
</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note71"/>Note</h3><p>Even if you have full control over Apache and you want to place everything in the main <code class="literal">httpd.conf</code> files for performance reasons, allowing rewrite options to be overridden with <code class="literal">FileInfo</code> lets you devise and troubleshoot your rules without restarting the server after each change. You can then migrate the rules to the main configuration file once you're certain they're correct, and turn off overrides.</p></div></div><p><code class="literal">rewrite_module</code> injects itself into the server's request handling workflow and can change what the requested URL looks like on the fly, given what we provide in our ruleset. Although the module is installed by default, we still need to explicitly enable URL rewriting with <code class="literal">RewriteEngine on</code>. Beyond that, the two most important rewrite options are <code class="literal">RewriteRule</code> and <code class="literal">RewriteCond</code>.</p><p>The <code class="literal">RewriteRule</code> option specifies a regular expression against which the URL is compared. If it matches, then the given substitution takes place. Positional variables such as <code class="literal">$1</code> can be used in the substitution to reference captured pattern matches. In our recipe, the rule matches the path (such as <code class="literal">/about</code> or <code class="literal">/contactus</code>) and rewrites it to direct the user to a PHP script of the same name (<code class="literal">about.php</code> or <code class="literal">contact.php</code>), thus hiding the fact that we're using PHP from our users:</p><pre class="programlisting">
<span class="strong"><strong>    RewriteRule ^/?([A-Z]+)$ $1.php [NC,L]&#13;
</strong></span>
</pre><p>We also can provide flags that affect how the request is returned. The <code class="literal">NC</code> flag, for example, performs the pattern matching case insensitively. The <code class="literal">L</code> flag stops the engine and returns the URL without any further rule processing. Also common are <code class="literal">R</code>, which forces a redirect (an HTTP status code is usually given, for example <code class="literal">R=301</code>), and <code class="literal">QSA</code>, which appends the query string from the original URL to the new URL.</p><p>The <code class="literal">RewriteCond</code> option gives a condition that must pass before evaluating a <code class="literal">RewriteRule</code>. The condition is a mix of regular expression matching, variables, and test operators. Special variables are available which we can use to reference pieces of the URL, such as the hostname (<code class="literal">%{HTTP_HOST}</code>), the requested file (<code class="literal">%{REQUEST_FILENAME}</code>), and the query string (<code class="literal">%{QUERY_STRING}</code>), or details about the environment/request, such as cookies (<code class="literal">%{HTTP_COOKIE</code>}) and user agent strings (<code class="literal">%{HTTP_USER_AGENT}</code>). The <code class="literal">-d</code> operator tests whether the path is a directory, <code class="literal">-f</code> tests whether the path is a file, and <code class="literal">!</code> negates the match. <code class="literal">RewriteCond</code> can also accept a handful of flags, such as <code class="literal">NC</code> flag to make comparison without regard to case sensitivity and the <code class="literal">OR</code> flag to join multiple options in an <span class="emphasis"><em>or</em></span> relationship (multiple options are implicitly treated as <span class="emphasis"><em>and</em></span>).</p><p>A very common rewrite that uses both <code class="literal">RewriteCond</code> and <code class="literal">RewriteRule</code> is one that directs the user to a main <code class="literal">index.php</code> file when the request doesn't match an existing file or directory. This is used a lot with web applications that route all requests through a central control point:</p><pre class="programlisting">
<span class="strong"><strong>    RewriteCond %{REQUEST_FILENAME} !-f&#13;
    RewriteCond %{REQUEST_FILENAME} !-d&#13;
    RewriteRule ^(.*) index.php [L,QSA]&#13;
</strong></span>
</pre><p>The first <code class="literal">RewriteCond</code> option checks whether the request is for an existing file and the second checks the same for an existing directory. If the request is neither for a file nor a directory, then the <code class="literal">RewriteRule</code> option maps the request to <code class="literal">index.php</code>. Any query string that may be present is included and it's marked as the last action, so no further rewriting will be performed.</p><p>Many people jokingly refer to rewriting as black magic. Indeed, it's impressive how powerful <code class="literal">mod_rewrite</code> is and how it transforms requests, and it can be frustrating when you can't seem to figure out the proper incantation to make your rule work as desired. In this case, you may want to turn on logging to gain insight into how the engine views the request. To enable logging, use the <code class="literal">RewriteLog</code> option to specify a log file where messages can be written to, and use <code class="literal">RewriteLogLevel</code> to specify the verbosity. Typically, a value of <code class="literal">5</code> for <code class="literal">RewriteLogLevel</code> is sufficient. They can be added to your <code class="literal">.htaccess</code> file and removed later after you're confident that your rules are correct:</p><pre class="programlisting">
<span class="strong"><strong>    RewriteLog /var/log/httpd/rewrite_log&#13;
    RewriteLogLevel 5&#13;
</strong></span>
</pre></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec276"/>See also</h2></div></div></div><p>Refer to the following resources for more information on rewriting URLs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Apache <code class="literal">mod_rewrite</code> documentation (<a class="ulink" href="http://httpd.apache.org/docs/current/mod/mod_rewrite.html">http://httpd.apache.org/docs/current/mod/mod_rewrite.html</a>)</li><li class="listitem" style="list-style-type: disc">URL rewriting guide (<a class="ulink" href="http://httpd.apache.org/docs/2.0/misc/rewriteguide.html">http://httpd.apache.org/docs/2.0/misc/rewriteguide.html</a>)</li><li class="listitem" style="list-style-type: disc">URL rewriting for the fearful (<a class="ulink" href="https://24ways.org/2013/url-rewriting-for-the-fearful">https://24ways.org/2013/url-rewriting-for-the-fearful</a>)</li></ul></div></div></div>
<div class="section" title="Installing NGINX as a load balancer"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec85"/>Installing NGINX as a load balancer</h1></div></div></div><p>High traffic websites can be distributed to different servers, either to better spread out the workload or to achieve redundancy. Each server in the cluster of systems would have their own copy of the website or web application's files and be capable of satisfying the user's request. The trick then is to route the user's request to one of these servers in an orderly fashion. There are different approaches to this, but a common one is to set up a load balancer or reverse proxy server.</p><p>NGINX is somewhat newer to the scene than Apache; written a little over a decade ago specifically to handle high-load connections, it can function as a web server, proxy, cache, and load-balancer. In this recipe, we'll see how to set up NGINX as a load balancer to proxy requests between the client and a cluster of Apache servers.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec277"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system with a working network connection. It assumes that you have other systems configured with Apache to serve a website as described in the earlier recipes; we'll refer to these systems using the IP addresses <code class="literal">192.168.56.20</code> and <code class="literal">192.168.56.30</code>. The package for NGINX is hosted by the EPEL repository; if the repository is not already registered, refer to the <span class="emphasis"><em>Registering the EPEL and Remi repositories</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Software Installation Management">Chapter 4</a>, <span class="emphasis"><em>Software Installation Management</em></span>. Administrative privileges are also required, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec278"/>How to do it...</h2></div></div></div><p>Follow these steps to set up reverse proxy using NGINX:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">nginx</code> package from the EPEL repository:<pre class="programlisting">
<span class="strong"><strong>yum install nginx</strong></span>
</pre></li><li class="listitem">Open the NGINX server's configuration file with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/nginx/nginx.conf</strong></span>
</pre></li><li class="listitem">Within the <code class="literal">http</code> block, add a new <code class="literal">upstream</code> block to identify the servers in your cluster:<pre class="programlisting">
<span class="strong"><strong>       upstream cluster {&#13;
         server 192.168.56.20;&#13;
         server 192.168.56.30;&#13;
       }&#13;
</strong></span>
</pre></li><li class="listitem">Find the <code class="literal">location</code> block and add a <code class="literal">proxy_pass</code> option that references the <code class="literal">upstream</code> block:<pre class="programlisting">
<span class="strong"><strong>       location / {&#13;
           proxy_pass http://cluster;&#13;
       }&#13;
</strong></span>
</pre></li><li class="listitem">Save your changes to the configuration and close the file.</li><li class="listitem">Start the server and enable it to start automatically when your system reboots:<pre class="programlisting">
<span class="strong"><strong>systemctl start nginx.service</strong></span>
<span class="strong"><strong>systemctl enable nginx.service</strong></span>
</pre></li><li class="listitem">Open port <code class="literal">80</code> in the system's firewall to allow HTTP requests through:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-service=http</strong></span>
<span class="strong"><strong>firewall-cmd --reload</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec279"/>How it works...</h2></div></div></div><p>As usual, we began by installing the program's package, this time <code class="literal">nginx</code>. The package is available in the EPEL repository. Once installed, we updated its configuration, identifying the servers in our cluster and then proxying requests. First, we added an <code class="literal">upstream</code> block:</p><pre class="programlisting">
<span class="strong"><strong>    upstream cluster {&#13;
      server 192.168.56.20;&#13;
      server 192.168.56.30;&#13;
    }&#13;
</strong></span>
</pre><p><code class="literal">cluster</code> is simply a name we assigned to this group of servers so that we can refer to the group by name. You can have multiple upstream blocks if you are balancing multiple clusters. Each <code class="literal">server</code> entry within it gives the IP address or hostname of one of the systems running the site.</p><p>Next, we found the main <code class="literal">location</code> block and added a <code class="literal">proxy_pass</code> parameter. <code class="literal">proxy_pass</code> will forward the incoming request to one of the systems in our cluster group and return the response to satisfy the request:</p><pre class="programlisting">
<span class="strong"><strong>    location / {&#13;
        proxy_pass http://cluster;&#13;
    }&#13;
</strong></span>
</pre><p>Communication between NGINX and the hosting web servers is done over <code class="literal">http</code> since that's the protocol specified in the value for <code class="literal">proxy_pass</code>. This is fine because the clustered systems would be running behind the load balancer on a trusted network. If your site is to be served over HTTPS, it's NGINX that will need to handle the TLS negotiation as it's the public server point seen by the client; the client is unaware of anything behind the balancer.</p><p>To configure NGINX to handle HTTPS requests, within the <code class="literal">server</code> block update the <code class="literal">listen</code> options to listen on port 443. Then add entries with the <code class="literal">ssl_certificate</code> and <code class="literal">ssl_certificate_key</code> options to identify the certificate and key, respectively:</p><pre class="programlisting">
<span class="strong"><strong>    server {&#13;
        # listen 80 default_server;&#13;
        # listen [::]:80 default_server;&#13;
        listen 443 ssl default_server;&#13;
        listen [::]:443 ssl default_server;&#13;
    &#13;
        ssl_certificate /etc/pki/tls/certs/www.example.pem;&#13;
        ssl_certificate_key /etc/pki/tls/private/www.example.key;&#13;
    ...&#13;
    }&#13;
</strong></span>
</pre><p>Once the changes are made and the configuration file is saved, open port <code class="literal">443</code> in your firewall and restart NGINX:</p><pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-service=https</strong></span>
<span class="strong"><strong>firewall-cmd --reload</strong></span>
<span class="strong"><strong>systemctctl restart nginx.service</strong></span>
</pre><p>Round-robin is the default approach for load balancing. This means the first request is proxied to the first server in the cluster, then next to the second server, and so on. When NGINX reaches the end of the list, it starts again from the top of the list, proxying the next request to the first server. There are other strategies we can use, for example, weighted balancing.</p><p>To perform weighted balancing, we assign a weight to any of the servers and it will handle that number of requests per iteration. Here, the first server will handle five requests before NGINX proxies anything to the second server:</p><pre class="programlisting">
<span class="strong"><strong>    upstream cluster {&#13;
      server 192.168.56.20 weight=5;&#13;
      server 192.168.56.30;&#13;
    }&#13;
</strong></span>
</pre><p>When using load balancing, remember that any one web server isn't guaranteed to receive the next request sent by a user. If you're balancing access to a web application that uses sessions, this can be problematic. You may want to consider storing session data on a central system that each web server has access to, perhaps using a database such as Redis or Memcache.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note72"/>Note</h3><p>I recommend that you avoid any balancing strategy that relies on session persistence. The post at <a class="ulink" href="http://www.chaosincomputing.com/2012/05/sticky-sessions-are-evil">http://www.chaosincomputing.com/2012/05/sticky-sessions-are-evil</a> offers a good overview of their problems.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec280"/>See also</h2></div></div></div><p>Refer to the following resources for more information on working with NGINX and load balancing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The NGINX website (<a class="ulink" href="https://www.nginx.com/">https://www.nginx.com/</a>)</li><li class="listitem" style="list-style-type: disc">How to install NGINX on CentOS 7 (<a class="ulink" href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7">https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7</a>)</li><li class="listitem" style="list-style-type: disc">Configuring HTTPS servers (<a class="ulink" href="http://nginx.org/en/docs/http/configuring_https_servers.html">http://nginx.org/en/docs/http/configuring_https_servers.html</a>)</li><li class="listitem" style="list-style-type: disc">Using NGINX as a load balancer (<a class="ulink" href="http://nginx.org/en/docs/http/load_balancing.html">http://nginx.org/en/docs/http/load_balancing.html</a>)</li><li class="listitem" style="list-style-type: disc">How to store PHP sessions in Memcache (<a class="ulink" href="http://www.scalescale.com/tips/nginx/store-php-sessions-memcached">http://www.scalescale.com/tips/nginx/store-php-sessions-memcached</a>)</li></ul></div></div></div></body></html>