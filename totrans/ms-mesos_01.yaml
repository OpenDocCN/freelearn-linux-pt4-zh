- en: Chapter 1. Introducing Mesos
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：介绍Mesos
- en: Apache Mesos is open source, distributed cluster management software that came
    out of AMPLab, UC Berkeley in 2011\. It abstracts CPU, memory, storage, and other
    computer resources away from machines (physical or virtual), enabling fault-tolerant
    and elastic distributed systems to be easily built and run effectively. It is
    referred to as a **metascheduler** (scheduler of schedulers) and a "distributed
    systems kernel/distributed datacenter OS".
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Mesos 是一款开源的分布式集群管理软件，起源于2011年 UC Berkeley AMPLab。它将 CPU、内存、存储和其他计算资源从物理或虚拟机器中抽象出来，使得容错和弹性分布式系统可以轻松构建并高效运行。它被称为**元调度器**（调度器的调度器）和“分布式系统内核/分布式数据中心操作系统”。
- en: It improves resource utilization, simplifies system administration, and supports
    a wide variety of distributed applications that can be deployed by leveraging
    its pluggable architecture. It is scalable and efficient and provides a host of
    features, such as resource isolation and high availability, which, along with
    a strong and vibrant open source community, makes this one of the most exciting
    projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它提高了资源利用率，简化了系统管理，并支持多种可以通过利用其可插拔架构部署的分布式应用程序。它具有可扩展性和高效性，并提供诸如资源隔离和高可用性等功能，这些特点，加上一个强大且充满活力的开源社区，使其成为最令人兴奋的项目之一。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to the datacenter OS and architecture of Mesos
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos的数据中心操作系统与架构介绍
- en: Introduction to frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架介绍
- en: Attributes, resources and resource scheduling, allocation, and isolation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性、资源以及资源调度、分配和隔离
- en: Monitoring and APIs provided by Mesos
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos提供的监控与API
- en: Mesos in production
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos在生产环境中的应用
- en: Introduction to the datacenter OS and architecture of Mesos
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos的数据中心操作系统与架构介绍
- en: Over the past decade, datacenters have graduated from packing multiple applications
    into a single server box to having large datacenters that aggregate thousands
    of servers to serve as a massively distributed computing infrastructure. With
    the advent of virtualization, microservices, cluster computing, and hyperscale
    infrastructure, the need of the hour is the creation of an application-centric
    enterprise that follows a software-defined datacenter strategy.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，数据中心已经从将多个应用程序打包到单台服务器中，发展到拥有大型数据中心，聚合数千台服务器作为大规模分布式计算基础设施。随着虚拟化、微服务、集群计算和超大规模基础设施的到来，当前的需求是创建一个以应用为中心的企业，遵循软件定义的数据中心战略。
- en: Currently, server clusters are predominantly managed individually, which can
    be likened to having multiple operating systems on the PC, one each for processor,
    disk drive, and so on. With an abstraction model that treats these machines as
    individual entities being managed in isolation, the ability of the datacenter
    to effectively build and run distributed applications is greatly reduced.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，服务器集群通常是单独管理的，这可以类比于在 PC 上有多个操作系统，每个操作系统分别管理处理器、磁盘驱动器等。采用这种将机器视为独立实体并孤立管理的抽象模型，会大大降低数据中心有效构建和运行分布式应用的能力。
- en: Another way of looking at the situation is comparing running applications in
    a datacenter to running them on a laptop. One major difference is that while launching
    a text editor or web browser, we are not required to check which memory modules
    are free and choose ones that suit our need. Herein lies the significance of a
    platform that acts like a host operating system and allows multiple users to run
    multiple applications simultaneously by utilizing a shared set of resources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这一情况的方式是将数据中心中运行应用程序与在笔记本电脑上运行应用程序进行比较。一个主要的区别是，在启动文本编辑器或网页浏览器时，我们不需要检查哪些内存模块是空闲的，也不需要选择符合需求的内存模块。这里正是平台像主操作系统一样发挥作用的意义，它允许多个用户同时运行多个应用程序，并利用共享的资源集。
- en: Datacenters now run varied distributed application workloads, such as Spark,
    Hadoop, and so on, and need the capability to intelligently match resources and
    applications. The datacenter ecosystem today has to be equipped to manage and
    monitor resources and efficiently distribute workloads across a unified pool of
    resources with the agility and ease to cater to a diverse user base (noninfrastructure
    teams included). A datacenter OS brings to the table a comprehensive and sustainable
    approach to resource management and monitoring. This not only reduces the cost
    of ownership but also allows a flexible handling of resource requirements in a
    manner that isolated datacenter infrastructure cannot support.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，数据中心运行着各种分布式应用工作负载，如Spark、Hadoop等，并需要具备智能匹配资源与应用程序的能力。如今，数据中心生态系统必须具备管理和监控资源的能力，并能够高效地在统一的资源池中分配工作负载，灵活且轻松地满足多样化的用户需求（包括非基础设施团队）。数据中心操作系统为资源管理和监控提供了一种全面且可持续的方法，这不仅降低了拥有成本，还允许以隔离的数据中心基础设施无法支持的方式灵活处理资源需求。
- en: The idea behind a datacenter OS is that of intelligent software that sits above
    all the hardware in a datacenter and ensures efficient and dynamic resource sharing.
    Added to this is the capability to constantly monitor resource usage and improve
    workload and infrastructure management in a seamless way that is not tied to specific
    application requirements. In its absence, we have a scenario with silos in a datacenter
    that force developers to build software catering to machine-specific characteristics
    and make the moving and resizing of applications a highly cumbersome procedure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据中心操作系统的理念是智能软件，它位于数据中心的所有硬件之上，确保高效和动态的资源共享。除此之外，它还具备持续监控资源使用情况并改善工作负载和基础设施管理的能力，这一切都是以一种与特定应用需求无关、无缝的方式进行的。如果没有这种操作系统，数据中心就会呈现出孤岛式的情形，这迫使开发人员构建针对机器特定特性的专用软件，使得应用程序的迁移和调整变得极为繁琐。
- en: The datacenter OS acts as a software layer that aggregates all servers in a
    datacenter into one giant supercomputer to deliver the benefits of multilatency,
    isolation, and resource control across all microservice applications. Another
    major advantage is the elimination of human-induced error during the continual
    assigning and reassigning of virtual resources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据中心操作系统充当着一个软件层，将数据中心中的所有服务器聚合为一个巨大的超级计算机，提供跨所有微服务应用程序的多延迟、隔离和资源控制的优势。另一个主要的优势是消除了在持续分配和重新分配虚拟资源过程中人为错误的发生。
- en: From a developer's perspective, this will allow them to easily and safely build
    distributed applications without restricting them to a bunch of specialized tools,
    each catering to a specific set of requirements. For instance, let's consider
    the case of Data Science teams who develop analytic applications that are highly
    resource intensive. An operating system that can simplify how the resources are
    accessed, shared, and distributed successfully alleviates their concern about
    reallocating hardware every time the workloads change.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，这将使他们能够轻松且安全地构建分布式应用程序，而不必将其局限于一堆专门的工具，这些工具各自针对特定的需求。例如，考虑到数据科学团队的情况，他们开发的分析应用程序通常是资源密集型的。一个能够简化资源访问、共享和分配的操作系统，成功地解决了他们每次工作负载变化时必须重新分配硬件的难题。
- en: Of key importance is the relevance of the datacenter OS to DevOps, primarily
    a software development approach that emphasizes automation, integration, collaboration,
    and communication between traditional software developers and other IT professionals.
    With a datacenter OS that effectively transforms individual servers into a pool
    of resources, DevOps teams can focus on accelerating development and not continuously
    worry about infrastructure issues.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据中心操作系统对DevOps的相关性至关重要，DevOps本质上是一种软件开发方法，强调自动化、集成、协作以及传统软件开发人员与其他IT专业人员之间的沟通。借助能够有效将单独服务器转化为资源池的操作系统，DevOps团队可以专注于加速开发，而无需不断担心基础设施问题。
- en: In a world where distributed computing becomes the norm, the datacenter OS is
    a boon in disguise. With freedom from manually configuring and maintaining individual
    machines and applications, system engineers need not configure specific machines
    for specific applications as all applications would be capable of running on any
    available resources from any machine, even if there are other applications already
    running on them. Using a datacenter OS results in centralized control and smart
    utilization of resources that eliminate hardware and software silos to ensure
    greater accessibility and usability even for noninfrastructural professionals.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式计算成为常态的世界里，数据中心操作系统是一个伪装的福音。通过免去手动配置和维护单独机器与应用程序的麻烦，系统工程师无需为特定应用配置特定的机器，因为所有应用都可以在任何可用的资源上运行，即使这些机器上已经有其他应用在运行。使用数据中心操作系统可以实现集中的控制和智能的资源利用，消除硬件和软件的孤岛，确保即便是非基础设施专业人员也能更好地访问和使用资源。
- en: Examples of some organizations administering their hyperscale datacenters via
    the datacenter OS are Google with the Borg (and next generation Omega) systems.
    The merits of the datacenter OS are undeniable, with benefits ranging from the
    scalability of computing resources and flexibility to support data sharing across
    applications to saving team effort, time, and money while launching and managing
    interoperable cluster applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织通过数据中心操作系统管理其超大规模数据中心的例子包括 Google 的 Borg（以及下一代 Omega）系统。数据中心操作系统的优点是显而易见的，优势包括计算资源的可扩展性、支持应用程序之间数据共享的灵活性，以及在启动和管理可互操作的集群应用程序时节省团队的精力、时间和资金。
- en: It is this vision of transforming the datacenter into a single supercomputer
    that Apache Mesos seeks to achieve. Born out of a Berkeley AMPLab research paper
    in 2011, it has since come a long way with a number of leading companies, such
    as Apple, Twitter, Netflix, and AirBnB among others, using it in production. Mesosphere
    is a start-up that is developing a distributed OS product with Mesos at its core.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正是通过将数据中心转变为单一超级计算机的愿景，Apache Mesos 希望实现这一目标。Mesos 起源于 2011 年伯克利 AMPLab 研究论文，至今已取得长足进展，许多领先公司（如
    Apple、Twitter、Netflix、AirBnB 等）已在生产环境中使用它。Mesosphere 是一家初创公司，正在开发以 Mesos 为核心的分布式操作系统产品。
- en: The architecture of Mesos
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos 的架构
- en: Mesos is an open-source platform for sharing clusters of commodity servers between
    different distributed applications (or frameworks), such as Hadoop, Spark, and
    Kafka among others. The idea is to act as a centralized cluster manager by pooling
    together all the physical resources of the cluster and making it available as
    a single reservoir of highly available resources for all the different frameworks
    to utilize. For example, if an organization has one 10-node cluster (16 CPUs and
    64 GB RAM) and another 5-node cluster (4 CPUs and 16 GB RAM), then Mesos can be
    leveraged to pool them into one virtual cluster of 720 GB RAM and 180 CPUs, where
    multiple distributed applications can be run. Sharing resources in this fashion
    greatly improves cluster utilization and eliminates the need for an expensive
    data replication process per-framework.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 是一个开源平台，用于在不同的分布式应用程序（或框架）之间共享商品服务器的集群，如 Hadoop、Spark、Kafka 等。其核心思想是作为一个集中的集群管理器，通过汇聚集群的所有物理资源，并将其作为一个高度可用的资源池提供给所有不同的框架使用。例如，如果一个组织有一个
    10 节点集群（16 个 CPU 和 64 GB 内存）和一个 5 节点集群（4 个 CPU 和 16 GB 内存），那么可以利用 Mesos 将它们整合成一个虚拟集群，具有
    720 GB 内存和 180 个 CPU，在这个集群上可以运行多个分布式应用程序。以这种方式共享资源大大提高了集群利用率，并消除了每个框架所需的昂贵数据复制过程。
- en: 'Some of the important features of Mesos are:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 的一些重要特性包括：
- en: '**Scalability**: It can elastically scale to over 50,000 nodes'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：可以弹性扩展到超过 50,000 个节点'
- en: '**Resource isolation**: This is achieved through Linux/Docker containers'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源隔离**：通过 Linux/Docker 容器实现'
- en: '**Efficiency**: This is achieved through CPU and memory-aware resource scheduling
    across multiple frameworks'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效性**：通过在多个框架之间进行 CPU 和内存感知的资源调度来实现'
- en: '**High availability**: This is through Apache ZooKeeper'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性**：通过 Apache ZooKeeper 实现'
- en: '**Monitoring Interface**: A Web UI for monitoring the cluster state'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控接口**：用于监控集群状态的 Web UI'
- en: 'Mesos is based on the same principles as the Linux kernel and aims to provide
    a highly available, scalable, and fault-tolerant base for enabling various frameworks
    to share cluster resources effectively and in isolation. Distributed applications
    are varied and continuously evolving, a fact that leads Mesos design philosophy
    towards a thin interface that allows an efficient resource allocation between
    different frameworks and delegates the task of scheduling and job execution to
    the frameworks themselves. The two advantages of doing so are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 基于与 Linux 内核相同的原则，旨在提供一个高可用、可扩展和容错的基础，使得各种框架能够有效且隔离地共享集群资源。分布式应用程序种类繁多且持续发展，这一事实使得
    Mesos 的设计理念趋向于提供一个精简的接口，允许不同框架之间高效地分配资源，并将任务调度和作业执行的工作委托给框架本身。这样做的两个优点是：
- en: Different frame data replication works can independently devise methods to address
    their data locality, fault-tolerance, and other such needs
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的框架数据复制工作可以独立地设计方法来解决它们的数据局部性、容错性及其他需求
- en: It simplifies the Mesos codebase and allows it to be scalable, flexible, robust,
    and agile
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它简化了 Mesos 的代码库，并使其具备可扩展性、灵活性、健壮性和敏捷性
- en: Mesos' architecture hands over the responsibility of scheduling tasks to the
    respective frameworks by employing a resource offer abstraction that packages
    a set of resources and makes offers to each framework. The Mesos master node decides
    the quantity of resources to offer each framework, while each framework decides
    which resource offers to accept and which tasks to execute on these accepted resources.
    This method of resource allocation is shown to achieve a good degree of data locality
    for each framework sharing the same cluster.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 的架构通过采用资源报价抽象将任务调度的责任交给各自的框架，它将一组资源打包并向每个框架发出报价。Mesos 主节点决定向每个框架提供多少资源，而每个框架则决定接受哪些资源报价，并在这些接受的资源上执行哪些任务。这种资源分配方法显示出可以为共享同一集群的每个框架实现良好的数据局部性。
- en: An alternative architecture would implement a global scheduler that took framework
    requirements, organizational priorities, and resource availability as inputs and
    provided a task schedule breakdown by framework and resource as output, essentially
    acting as a matchmaker for jobs and resources with priorities acting as constraints.
    The challenges with this architecture, such as developing a robust API that could
    capture all the varied requirements of different frameworks, anticipating new
    frameworks, and solving a complex scheduling problem for millions of jobs, made
    the former approach a much more attractive option for the creators.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种架构将实现一个全局调度器，该调度器将框架需求、组织优先级和资源可用性作为输入，并提供按框架和资源划分的任务调度输出，本质上充当了作业与资源之间的媒介，优先级作为约束条件。这个架构的挑战，如开发一个能捕捉不同框架各种需求的健壮
    API、预见新框架的出现，以及为数百万个作业解决复杂的调度问题，使得前一种方法对于创作者来说更具吸引力。
- en: Introduction to frameworks
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架介绍
- en: 'A Mesos framework sits between Mesos and the application and acts as a layer
    to manage task scheduling and execution. As its implementation is application-specific,
    the term is often used to refer to the application itself. Earlier, a Mesos framework
    could interact with the Mesos API using only the libmesos C++ library, due to
    which other language bindings were developed for Java, Scala, Python, and Go among
    others that leveraged libmesos heavily. Since v0.19.0, the changes made to the
    HTTP-based protocol enabled developers to develop frameworks using the language
    they wanted without having to rely on the C++ code. A framework consists of two
    components: a) Scheduler and b) Executor.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 框架位于 Mesos 和应用程序之间，充当管理任务调度和执行的层。由于其实现是特定于应用程序的，因此这个术语通常用来指代应用程序本身。早期，Mesos
    框架只能通过 libmesos C++ 库与 Mesos API 交互，因此开发了包括 Java、Scala、Python 和 Go 等语言的绑定，这些语言都大量利用了
    libmesos。从 v0.19.0 版本开始，对基于 HTTP 协议所做的更改使得开发者可以使用他们想要的语言开发框架，而不必依赖 C++ 代码。一个框架由两个组件组成：a)
    调度器和 b) 执行器。
- en: '**Scheduler** is responsible for making decisions on the resource offers made
    to it and tracking the current state of the cluster. Communication with the Mesos
    master is handled by the **SchedulerDriver** module, which registers the framework
    with the master, launches tasks, and passes messages to other components.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**调度器**负责决定它收到的资源报价，并跟踪集群的当前状态。与 Mesos 主节点的通信由 **SchedulerDriver** 模块处理，该模块将框架注册到主节点，启动任务，并向其他组件传递消息。'
- en: The second component, **Executor**, is responsible, as its name suggests, for
    the execution of tasks on slave nodes. Communication with the slaves is handled
    by the **ExecutorDriver** module, which is also responsible for sending status
    updates to the scheduler.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件，**Executor**，顾名思义，负责在从节点上执行任务。与从节点的通信由 **ExecutorDriver** 模块处理，该模块还负责将状态更新发送到调度程序。
- en: The Mesos API, discussed later in this chapter, allows programmers to develop
    their own custom frameworks that can run on top of Mesos. Some other features
    of frameworks, such as authentication, authorization, and user management, will
    be discussed at length in [Chapter 6](ch06.html "Chapter 6. Mesos Frameworks"),
    *Mesos Frameworks*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章稍后讨论的 Mesos API 使程序员能够开发自己的自定义框架，这些框架可以在 Mesos 上运行。框架的其他一些特性，如身份验证、授权和用户管理，将在
    [第 6 章](ch06.html "第 6 章：Mesos 框架")，*Mesos 框架* 中详细讨论。
- en: '![Introduction to frameworks](img/B05186_01_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction to frameworks](img/B05186_01_01.jpg)'
- en: Frameworks built on Mesos
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建在 Mesos 上的框架
- en: 'A list of some of the services and frameworks built on Mesos is given here.
    This list is not exhaustive, and support for new frameworks is added almost every
    day. You can also refer to [http://mesos.apache.org/documentation/latest/frameworks/](http://mesos.apache.org/documentation/latest/frameworks/)
    apart from the following list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出了一些构建在 Mesos 上的服务和框架。此列表并不详尽，几乎每天都有新框架得到支持。除了下面的列表，你还可以参考 [http://mesos.apache.org/documentation/latest/frameworks/](http://mesos.apache.org/documentation/latest/frameworks/)：
- en: Long-running services
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长时间运行的服务
- en: '**Aurora**: This is a service scheduler that runs on top of Mesos, enabling
    you to run long-running services that take advantage of the scalability, fault-tolerance,
    and resource isolation of Mesos.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Aurora**：这是一个运行在 Mesos 上的服务调度程序，允许你运行长时间运行的服务，利用 Mesos 的可扩展性、容错性和资源隔离性。'
- en: '**Marathon**: This is a private PaaS built on Mesos. It automatically handles
    hardware or software failures and ensures that an app is "always on".'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Marathon**：这是一个基于 Mesos 的私有 PaaS。它自动处理硬件或软件故障，并确保应用始终在线。'
- en: '**Singularity**: This is a scheduler (the HTTP API and web interface) for running
    Mesos tasks, such as long-running processes, one-off tasks, and scheduled jobs.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Singularity**：这是一个调度程序（HTTP API 和 Web 界面），用于运行 Mesos 任务，例如长时间运行的进程、一次性任务和定时任务。'
- en: '**SSSP**: This is a simple web application that provides a "Megaupload" white
    label to store and share files in S3.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSSP**：这是一个简单的 Web 应用程序，提供一个“Megaupload”白标用于存储和共享 S3 中的文件。'
- en: Big data processing
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大数据处理
- en: Cray Chapel is a productive parallel programming language. The Chapel Mesos
    scheduler lets you run Chapel programs on Mesos.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cray Chapel 是一种高效的并行编程语言。Chapel Mesos 调度器让你可以在 Mesos 上运行 Chapel 程序。
- en: Dark is a Python clone of Spark, a MapReduce-like framework written in Python
    and running on Mesos.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dark 是一个 Python 版的 Spark，是一个类似 MapReduce 的框架，使用 Python 编写并在 Mesos 上运行。
- en: Exelixi is a distributed framework used to run genetic algorithms at scale.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Exelixi 是一个分布式框架，用于大规模运行遗传算法。
- en: Hadoop Running Hadoop on Mesos distributes MapReduce jobs efficiently across
    an entire cluster.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hadoop：在 Mesos 上运行 Hadoop 会高效地将 MapReduce 作业分配到整个集群中。
- en: Hama is a distributed computing framework based on Bulk Synchronous Parallel
    computing techniques for massive scientific computations—for example, matrix,
    graph, and network algorithms.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hama 是一个分布式计算框架，基于大规模科学计算的批同步并行（Bulk Synchronous Parallel）技术，例如矩阵、图和网络算法。
- en: MPI is a message-passing system designed to function on a wide variety of parallel
    computers.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MPI 是一个消息传递系统，旨在适用于各种并行计算机。
- en: Spark is a fast and general-purpose cluster computing system that makes parallel
    jobs easy to write.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spark 是一个快速且通用的集群计算系统，使并行作业的编写变得简单。
- en: Storm is a distributed real-time computation system. Storm makes it easy to
    reliably process unbounded streams of data, doing for real-time processing what
    Hadoop does for batch processing.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storm 是一个分布式实时计算系统。Storm 使得可靠地处理无界数据流变得简单，它为实时处理做的事情类似于 Hadoop 为批处理所做的工作。
- en: Batch scheduling
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量调度
- en: Chronos is a distributed job scheduler that supports complex job topologies.
    It can be used as a more fault-tolerant replacement for cron.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chronos 是一个分布式作业调度器，支持复杂的作业拓扑结构。它可以作为更具容错性的 cron 替代品。
- en: Jenkins is a continuous integration server. The Mesos-Jenkins plugin allows
    it to dynamically launch workers on a Mesos cluster, depending on the workload.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins 是一个持续集成服务器。Mesos-Jenkins 插件使其能够根据工作负载动态地在 Mesos 集群上启动工作节点。
- en: JobServer is a distributed job scheduler and processor that allows developers
    to build custom batch processing Tasklets using a point and click Web UI.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JobServer是一个分布式作业调度和处理器，允许开发人员使用点选式Web UI构建自定义批处理任务。
- en: Data storage
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据存储
- en: Cassandra is a performant and highly available distributed database. Linear
    scalability and proven fault-tolerance on commodity hardware or cloud infrastructure
    make it the perfect platform for mission-critical data.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cassandra是一个高性能且高度可用的分布式数据库。在线性可扩展性和在商用硬件或云基础设施上经受住了故障容忍性验证，使其成为处理关键数据的理想平台。
- en: Elasticsearch is a distributed search engine. Mesos makes it easy for it to
    run and scale.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elasticsearch是一个分布式搜索引擎。Mesos使其能够轻松运行和扩展。
- en: The attributes and resources of Mesos
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos的属性和资源
- en: 'Mesos describes the slave nodes present in the cluster by the following two
    methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos通过以下两种方法描述集群中存在的从节点：
- en: Attributes
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Attributes are used to describe certain additional information regarding the
    slave node, such as its OS version, whether it has a particular type of hardware,
    and so on. They are expressed as key-value pairs with support for three different
    value types—scalar, range, and text—that are sent along with the offers to frameworks.
    Take a look at the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 属性用于描述有关从节点的某些附加信息，例如其操作系统版本、是否具有某种硬件类型等。它们以键值对的形式表达，支持三种不同的值类型——标量、范围和文本——并与报价一起发送给框架。请查看以下代码：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Resources
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: 'Mesos can manage three different types of resources: scalars, ranges, and sets.
    These are used to represent the different resources that a Mesos slave has to
    offer. For example, a scalar resource type could be used to represent the amount
    of CPU on a slave. Each resource is identified by a key string, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos可以管理三种不同类型的资源：标量、范围和集合。这些资源用于表示Mesos从节点所能提供的不同资源。例如，标量资源类型可以用来表示从节点的CPU数量。每个资源都通过一个键字符串来标识，如下所示：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Predefined uses and conventions
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义用途和惯例
- en: 'The Mesos master predefines how it handles the following list of resources:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos主节点预定义了它如何处理以下资源列表：
- en: '`cpus`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpus`'
- en: '`mem`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem`'
- en: '`disk`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disk`'
- en: '`ports`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`'
- en: In particular, a slave without the `cpu` and `mem` resources will never have
    its resources advertised to any frameworks. Also, the master's user interface
    interprets the scalars in `mem` and `disk` in terms of MB. For example, the value
    `15000` is displayed as `14.65GB`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，一个没有`cpu`和`mem`资源的从节点将永远不会将其资源广告给任何框架。此外，主节点的用户界面将`mem`和`disk`中的标量值解释为MB。例如，值`15000`会显示为`14.65GB`。
- en: Examples
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'Here are some examples of configuring the Mesos slaves:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些配置Mesos从节点的示例：
- en: '`resources=''cpus:24;mem:24576;disk:409600;ports:[21000-24000];bugs:{a,b,c}''`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources=''cpus:24;mem:24576;disk:409600;ports:[21000-24000];bugs:{a,b,c}''`'
- en: '`attributes=''rack:abc;zone:west;os:centos5;level:10;keys:[1000-1500]''`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes=''rack:abc;zone:west;os:centos5;level:10;keys:[1000-1500]''`'
- en: In this case, we have three different types of resources, scalars, a range,
    and a set. They are called `cpus`, `mem`, and `disk`, and the range type is `ports`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有三种不同类型的资源：标量、范围和集合。它们分别被称为`cpus`、`mem`和`disk`，范围类型为`ports`。
- en: A scalar called `cpus` with the value `24`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`cpus`的标量，值为`24`
- en: A scalar called `mem` with the value `24576`
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`mem`的标量，值为`24576`
- en: A scalar called `disk` with the value `409600`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`disk`的标量，值为`409600`
- en: A range called `ports` with values `21000` through `24000` (inclusive)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`ports`的范围，值为`21000`到`24000`（包含端点）
- en: A set called `bugs` with the values `a`, `b`, and `c`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`bugs`的集合，包含值`a`、`b`和`c`
- en: 'In the case of attributes, we will end up with three attributes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性的情况下，我们将得到三个属性：
- en: A `rack` attribute with the text value `abc`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`rack`的属性，文本值为`abc`
- en: A `zone` attribute with the text value `west`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`zone`的属性，文本值为`west`
- en: An `os` attribute with the text value `centos5`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`os`的属性，文本值为`centos5`
- en: A `level` attribute with the scalar value `10`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`level`的属性，标量值为`10`
- en: A `keys` attribute with range values `1000` through `1500` (inclusive)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`keys`的属性，范围值为`1000`到`1500`（包含端点）
- en: Two-level scheduling
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两级调度
- en: Mesos has a two-level scheduling mechanism to allocate resources to and launch
    tasks on different frameworks. In the first level, the master process that manages
    slave processes running on each node in the Mesos cluster determines the free
    resources available on each node, groups them, and offers them to different frameworks
    based on organizational policies, such as priority or fair sharing. Organizations
    have the ability to define their own sharing policies via a custom allocation
    module as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 具有一个两级调度机制，用于为不同框架分配资源并启动任务。在第一层级中，管理 Mesos 集群中每个节点上从节点进程的主控进程会确定每个节点上可用的空闲资源，将其分组，并根据组织政策（如优先级或公平共享）将这些资源提供给不同的框架。组织还可以通过自定义分配模块定义自己的共享政策。
- en: In the second level, each framework's scheduler component that is registered
    as a client with the master accepts or rejects the resource offer made depending
    on the framework's requirements. If the offer is accepted, the framework's scheduler
    sends information regarding the tasks that need to be executed and the number
    of resources that each task requires to the Mesos master. The master transfers
    the tasks to the corresponding slaves, which assign the necessary resources to
    the framework's executor component, which manages the execution of all the required
    tasks in containers. When the tasks are completed, the containers are dismantled,
    and the resources are freed up for use by other tasks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二级，每个框架的调度组件（作为客户端注册到主控）根据框架的需求接受或拒绝所提供的资源。如果接受该资源提供，框架的调度器会向 Mesos 主控发送需要执行的任务信息，以及每个任务所需的资源数量。主控将任务转交给相应的从节点，从节点为框架的执行器组件分配必要的资源，执行器管理容器中所有任务的执行。当任务完成后，容器被拆除，资源被释放供其他任务使用。
- en: 'The following diagram and explanation from the Apache Mesos documentation ([http://mesos.apache.org/documentation/latest/architecture/](http://mesos.apache.org/documentation/latest/architecture/))
    explains this concept in more detail:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示和来自 Apache Mesos 文档的解释（[http://mesos.apache.org/documentation/latest/architecture/](http://mesos.apache.org/documentation/latest/architecture/)）更详细地解释了这一概念：
- en: '![Two-level scheduling](img/B05186_01_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![两级调度](img/B05186_01_02.jpg)'
- en: 'Let''s have a look at the pointers mentioned in the preceding diagram:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下前面图示中提到的要点：
- en: '**1**: Slave 1 reports to the master that it has four CPUs and 4 GB of memory
    free. The master then invokes the allocation module, which tells it that Framework
    1 should be offered all the available resources.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**: 从节点 1 向主控报告其有四个 CPU 和 4 GB 内存空闲。然后，主控调用分配模块，告知它应该将所有可用资源提供给框架 1。'
- en: '**2**: The master sends a resource offer describing these resources to Framework
    1.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**: 主控发送描述这些资源的资源提供信息给框架 1。'
- en: '**3**: The framework''s scheduler replies to the master with information about
    two tasks to run on the slave using two CPUs and 1 GB RAM for the first task and
    one CPU and 2 GB RAM for the second task.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3**: 框架的调度器向主控回复有关在从节点上运行的两个任务的信息，第一个任务使用两个 CPU 和 1 GB 内存，第二个任务使用一个 CPU 和
    2 GB 内存。'
- en: '**4**: The master sends the tasks to the slave, which allocates appropriate
    resources to the framework''s executor, which in turn launches the two tasks.
    As one CPU and 1 GB of RAM are still free, the allocation module may now offer
    them to Framework 2\. In addition, this resource offers process repeats when tasks
    finish and new resources become free.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4**: 主控进程将任务发送到从节点，从节点为框架的执行器分配适当的资源，执行器进而启动这两个任务。由于一个 CPU 和 1 GB 内存仍然空闲，分配模块现在可能会将这些资源提供给框架
    2。此外，当任务完成并且有新的资源释放时，该资源还会提供给进程重试。'
- en: Mesos also provides frameworks with the ability to reject resource offers. A
    framework can reject the offers that do not meet its requirements. This allows
    frameworks to support a wide variety of complex resource constraints while keeping
    Mesos simple at the same time. A policy called **delay scheduling**, in which
    frameworks wait for a finite time to get access to the nodes storing their input
    data, gives a fair level of data locality albeit with a slight latency tradeoff.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 还为框架提供了拒绝资源提供的能力。框架可以拒绝那些不符合其要求的资源提供。这使得框架能够支持各种复杂的资源约束，同时保持 Mesos 的简单性。一种叫做
    **延迟调度** 的策略允许框架等待有限时间以访问存储其输入数据的节点，尽管会有轻微的延迟，但能提供公平的数据本地性。
- en: If the framework constraints are complex, it is possible that a framework might
    need to wait before it receives a suitable resource offer that meets its requirements.
    To tackle this, Mesos allows frameworks to set filters specifying the criteria
    that they will use to always reject certain resources. A framework can set a filter
    stating that it can run only on nodes with at least 32 GB of RAM space free, for
    example. This allows it to bypass the rejection process, minimizes communication
    overheads, and thus reduces overall latency.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果框架约束复杂，可能会出现一个框架在收到符合其需求的合适资源报价之前需要等待的情况。为了解决这个问题，Mesos 允许框架设置过滤器，指定它们将用于始终拒绝某些资源的标准。例如，框架可以设置一个过滤器，表示它只能在至少有
    32 GB 空闲内存的节点上运行。这样可以绕过拒绝过程，减少通信开销，从而降低整体延迟。
- en: Resource allocation
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源分配
- en: The resource allocation module contains the policy that the Mesos master uses
    to determine the type and quantity of resource offers that need to be made to
    each framework. Organizations can customize it to implement their own allocation
    policy—for example, fair sharing, priority, and so on—which allows for fine-grained
    resource sharing. Custom allocation modules can be developed to address specific
    needs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 资源分配模块包含了 Mesos 主节点用来确定需要向每个框架提供的资源类型和数量的策略。组织可以自定义该模块以实现自己的分配策略——例如，公平分配、优先级等——从而实现细粒度的资源共享。可以开发自定义分配模块来解决特定需求。
- en: The resource allocation module is responsible for making sure that resources
    are shared in a fair manner among competing frameworks. The choice of algorithm
    used to determine the sharing policy has a great bearing on the efficiency of
    a cluster manager. One of the most popular allocation algorithms, max-min fairness,
    and its weighted derivative are described in the following section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 资源分配模块负责确保资源在竞争框架之间公平共享。用于确定共享策略的算法选择对集群管理器的效率有着重要影响。最流行的分配算法之一是最大最小公平分配及其加权派生算法，接下来的部分将进行描述。
- en: Max-min fair share algorithm
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大最小公平分配算法
- en: Imagine a set of sources (1, 2, ..., m) that has resource demands x[1], x[2],
    ..., x[m]. Let the total number of resources be R. We will initially give *R*/*m*
    of the resource to each of the *m* sources. Now, starting with the source with
    the least demand, we will compare the allocation to the actual demand. If initial
    allocation (*R*/*m*) is more than the demand requirements of source 1, we will
    redistribute the excess resources equally among the remaining sources. We will
    then compare the new allocation to the actual demand of the source with the second-lowest
    demand and continue the process as before. The process ends when each source gets
    allocated resources that are less than or equal to its actual demand. If any source
    gets allocated resources less than what it actually needs, the algorithm ensures
    that no other source can get more resources than such a source. Such an allocation
    is called a max-min fair share allocation because it maximizes the minimum share
    of sources whose demands are not met.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一组源（1，2，...，m），其资源需求分别为 x[1]，x[2]，...，x[m]。假设资源总数为 R。我们将首先把 *R*/*m* 的资源分配给每个
    *m* 个源。然后，从需求最少的源开始，我们将分配的资源与实际需求进行比较。如果初始分配（*R*/*m*）超过了源 1 的需求要求，我们将把多余的资源在其余源之间平均重新分配。然后，我们将把新的分配与第二个需求最少的源的实际需求进行比较，继续重复这一过程。直到每个源的分配资源小于或等于其实际需求。如果有任何源的分配资源少于其实际需要，算法确保没有其他源可以获得比该源更多的资源。这种分配被称为最大最小公平分配，因为它最大化了需求没有得到满足的源的最小份额。
- en: 'Consider the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下示例：
- en: How to compute the max-min fair allocation for a set of four sources, *S1*,
    *S2*, *S3*, and *S4*, with demands 2, 2.5, 4, and 5, respectively, when the resource
    has an overall capacity of 10.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如何计算一个四个源的最大最小公平分配，*S1*，*S2*，*S3*，*S4*，它们的需求分别为 2，2.5，4 和 5，当资源总容量为 10 时。
- en: Following the methodology described earlier, to solve this, we will tentatively
    divide the resource into four portions of size 2.5 each. Next, we will compare
    this allocation with the actual demand of the source with the least demand (in
    this case, *S1*). As the allocation is greater than the actual demand, the excess
    0.5 is divided equally among the remaining three sources, *S2*, *S3*, and *S4*,
    giving them 2.666 each. Continuing the process, we will note that the new allocation
    is greater than the actual demand of source *S2*. The excess 0.166 is again divided
    evenly among the remaining two sources *S3* and *S4*, giving them *2.666 + 0.084
    = 2.75* each. The allocation for each of the sources is now less than or equal
    to the actual demand, so the process is stopped here. The final allocation is,
    therefore, *S1 – 2*, *S2 – 2.5*, *S3 – 2.75*, and *S4 – 2.75*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前描述的方法，为了解决这个问题，我们将资源初步划分为四个每个大小为2.5的部分。接下来，我们将比较这种分配与需求最小的源（在本例中为*S1*）的实际需求。由于分配大于实际需求，剩余的0.5将均等地分配给其余的三个源，即*S2*、*S3*和*S4*，每个获得2.666。继续这一过程，我们会发现新的分配大于源*S2*的实际需求。多余的0.166再次均匀地分配给剩下的两个源*S3*和*S4*，每个变为*2.666
    + 0.084 = 2.75*。现在每个源的分配量都小于或等于实际需求，因此这个过程停止。最终的分配结果是，*S1 – 2*，*S2 – 2.5*，*S3
    – 2.75*，和*S4 – 2.75*。
- en: This works well in a homogenous environment—that is, one where resource requirements
    are fairly proportional between different competing users, such as a Hadoop cluster.
    However, scheduling resources across frameworks with heterogeneous resource demands
    poses a more complex challenge. What is a suitable fair share allocation policy
    if user A runs tasks that require two CPUs and 8 GB RAM each and user B runs tasks
    that require four CPUs and 2 GB RAM each? As can be noted, user A's tasks are
    RAM-heavy, while user B's tasks are CPU-heavy. How, then, should a set of combined
    RAM and CPU resources be distributed between the two users?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这一策略在同质环境中效果很好——也就是资源需求在不同竞争用户之间大致成比例的环境，比如Hadoop集群。然而，在具有异构资源需求的框架之间调度资源则构成了更复杂的挑战。如果用户A运行的任务每个需要两个CPU和8GB的内存，而用户B运行的任务每个需要四个CPU和2GB内存，那么适合的公平分配政策是什么？如所示，用户A的任务是内存密集型的，而用户B的任务是CPU密集型的。那么，如何在这两种资源（RAM和CPU）之间为两位用户分配资源呢？
- en: The latter scenario is a common one faced by Mesos, designed as it is to manage
    resources primarily in a heterogeneous environment. To address this, Mesos has
    the **Dominant Resource Fairness** algorithm (**DRF**) as its default resource
    allocation policy, which is far more suitable for heterogeneous environments.
    The algorithm and its role in efficient resource allocation will be discussed
    in more detail in the next chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 后者场景是Mesos常遇到的情况，因为Mesos的设计目的是主要在异构环境中管理资源。为了解决这个问题，Mesos将**主导资源公平性**算法（**DRF**）作为其默认资源分配策略，这在异构环境中更为适用。该算法及其在高效资源分配中的作用将在下一章中详细讨论。
- en: Resource isolation
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源隔离
- en: One of the key requirements of a cluster manager is to ensure that the allocation
    of resources to a particular framework does not have an impact on any active running
    jobs of some other framework. Provision for isolation mechanisms on slaves to
    compartmentalize different tasks is thus a key feature of Mesos. Containers are
    leveraged for resource isolation with a pluggable architecture. The Mesos slave
    uses the Containerizer API to provide an isolated environment to run a framework's
    executor and its corresponding tasks. The Containerizer API's objective is to
    support a wide range of implementations, which implies that custom containerizers
    and isolators can be developed. When a slave process starts, the containerizer
    to be used to launch containers and a set of isolators to enforce the resource
    constraints can be specified.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 集群管理器的关键要求之一是确保将资源分配给特定框架时不会影响其他框架上任何正在运行的作业。因此，Mesos提供了在从节点上实施隔离机制以区分不同任务的功能。容器被用于资源隔离，并采用可插拔架构。Mesos的从节点使用Containerizer
    API来提供一个隔离环境，运行框架的执行器及其相应的任务。Containerizer API的目标是支持广泛的实现，这意味着可以开发定制的容器化工具和隔离器。当从节点进程启动时，可以指定用于启动容器的容器化工具以及用于执行资源约束的隔离器。
- en: The Mesos Containerizer API provides a resource isolation of framework executors
    using Linux-specific functionality, such as control groups and namespaces. It
    also provides basic support for POSIX systems (only resource usage reporting and
    not actual isolation). This important topic will be explored at length in subsequent
    chapters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 容器化 API 使用 Linux 特有的功能（如控制组和命名空间）提供框架执行器的资源隔离。它还为 POSIX 系统提供基本支持（仅限资源使用报告，而非实际隔离）。这一重要话题将在后续章节中详细探讨。
- en: Mesos also provides network isolation at a container level to prevent a single
    framework from capturing all the available network bandwidth or ports. This is
    not supported by default, however, and additional dependencies need to be installed
    and configured in order to activate this feature.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 还在容器级别提供网络隔离，以防止单个框架占用所有可用的网络带宽或端口。然而，默认情况下不支持此功能，需要安装和配置额外的依赖项来启用此功能。
- en: Monitoring in Mesos
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos中的监控
- en: In this section, we will take a look at the different metrics that Mesos provides
    to monitor the various components.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 Mesos 提供的用于监控各种组件的不同度量指标。
- en: Monitoring provided by Mesos
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mesos 提供的监控
- en: 'Mesos master and slave nodes provide rich data that enables resource utilization
    monitoring and anomaly detection. The information includes details about available
    resources, used resources, registered frameworks, active slaves, and task state.
    This can be used to create automated alerts and develop a cluster health monitoring
    dashboard. More details can be found here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 主节点和从属节点提供丰富的数据，支持资源利用率监控和异常检测。信息包括可用资源、已用资源、注册框架、活跃从属节点和任务状态的详细信息。这些数据可用于创建自动化警报和开发集群健康监控仪表板。更多细节请参考：
- en: '[http://mesos.apache.org/documentation/latest/monitoring/](http://mesos.apache.org/documentation/latest/monitoring/).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://mesos.apache.org/documentation/latest/monitoring/](http://mesos.apache.org/documentation/latest/monitoring/)。'
- en: Network statistics for each active container are published through the `/monitor/statistics.json`
    endpoint on the slave.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活跃容器的网络统计数据通过从属节点上的`/monitor/statistics.json`端点发布。
- en: Types of metrics
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 度量指标类型
- en: 'Mesos provides two different kinds of metrics: counters and gauges. These can
    be explained as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 提供两种不同类型的度量指标：计数器和仪表。它们的解释如下：
- en: '**Counters**: This is used to measure discrete events, such as the number of
    finished tasks or invalid status updates. The values are always whole numbers.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**：用于衡量离散事件，如已完成的任务数或无效的状态更新。其值始终为整数。'
- en: '**Gauges**: This is used to check the snapshot of a particular metric, such
    as the number of active frameworks or running tasks at a particular time.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表**：用于检查特定度量指标的快照，如某一时刻活跃框架的数量或正在运行的任务数量。'
- en: The Mesos API
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos API
- en: Mesos provides an API to allow developers to build custom frameworks that can
    run on top of the underlying distributed infrastructure. The detailed steps involved
    in developing bespoke frameworks leveraging this API and the new HTTP API will
    be explored in detail in [Chapter 6](ch06.html "Chapter 6. Mesos Frameworks"),
    *Mesos Frameworks*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 提供一个 API，允许开发人员构建可以在底层分布式基础架构上运行的自定义框架。利用此 API 和新的 HTTP API 开发定制框架的详细步骤将在[第6章](ch06.html
    "第6章. Mesos框架")，*Mesos框架*中详细探讨。
- en: Messages
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息
- en: Mesos implements an actor-style message-passing programming model to enable
    nonblocking communication between different Mesos components and leverages protocol
    buffers for the same. For example, a scheduler needs to tell the executor to utilize
    a certain number of resources, an executor needs to provide status updates to
    the scheduler regarding the tasks that are executed, and so on. Protocol buffers
    provide the required flexible message delivery mechanism to enable this communication
    by allowing developers to define custom formats and protocols that can be used
    across different languages. For more details regarding the messages that are passed
    between different Mesos components, refer to [https://github.com/apache/mesos/blob/master/include/mesos/mesos.proto](https://github.com/apache/mesos/blob/master/include/mesos/mesos.proto)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 实现了一种基于演员模型的消息传递编程模型，以实现不同 Mesos 组件之间的非阻塞通信，并使用协议缓冲区进行传输。例如，调度程序需要告诉执行器使用一定数量的资源，执行器需要向调度程序提供有关执行的任务的状态更新，等等。协议缓冲区提供了所需的灵活消息传递机制，允许开发人员定义可以跨不同语言使用的自定义格式和协议。有关不同
    Mesos 组件之间传递的消息的更多详细信息，请参阅[https://github.com/apache/mesos/blob/master/include/mesos/mesos.proto](https://github.com/apache/mesos/blob/master/include/mesos/mesos.proto)
- en: API details
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 详情
- en: 'A brief description of the different APIs and methods that Mesos provides is
    provided in the following section:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分简要介绍了 Mesos 提供的不同 API 和方法：
- en: Executor API
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行器 API
- en: A brief description of the Executor API is given below. For more details, visit
    [http://mesos.apache.org/api/latest/java/org/apache/mesos/Executor.html](http://mesos.apache.org/api/latest/java/org/apache/mesos/Executor.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行器 API 的简要描述。欲了解更多详情，请访问[http://mesos.apache.org/api/latest/java/org/apache/mesos/Executor.html](http://mesos.apache.org/api/latest/java/org/apache/mesos/Executor.html)。
- en: '`registered`: This can be registered via the following code:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registered`：可以通过以下代码注册：'
- en: '[PRE2]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is invoked once the executor driver is able to successfully connect
    with Mesos. In particular, a scheduler can pass some data to its executors through
    the `ExecutorInfo.getData()` field.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码会在执行器驱动程序成功连接到 Mesos 后调用。特别地，调度程序可以通过`ExecutorInfo.getData()`字段将一些数据传递给其执行器。
- en: 'The following are the parameters:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the executor driver that was registered and connected to
    the Mesos cluster'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是已注册并连接到 Mesos 集群的执行器驱动程序。'
- en: '`executorInfo`: This describes information about the executor that was registered'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executorInfo`：这是描述已注册的执行器信息。'
- en: '`frameworkInfo`: This describes the framework that was registered'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frameworkInfo`：这是描述已注册框架的信息。'
- en: '`slaveInfo`: This describes the slave that will be used to launch the tasks
    for this executor'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slaveInfo`：这是描述将用于启动该执行器任务的从节点。'
- en: '`reregistered`: This can be *reregistered* as follows:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reregistered`：可以*重新注册*，具体如下：'
- en: '[PRE3]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code is invoked when the executor reregisters with a restarted slave.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码会在执行器与重新启动的从节点重新注册时调用。
- en: 'The following are the parameters:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the executor driver that was reregistered with the Mesos
    master'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是已与 Mesos 主节点重新注册的执行器驱动程序。'
- en: '`slaveInfo`: This describes the slave that will be used to launch the tasks
    for this executor'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slaveInfo`：这是描述将用于启动该执行器任务的从节点。'
- en: '`disconnected`: This can be disconnected via the following code:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnected`：可以通过以下代码断开连接：'
- en: '[PRE4]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code is invoked when the executor gets "disconnected" from the
    slave—for example, when the slave is restarted due to an upgrade).
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码会在执行器与从节点“断开连接”时调用，例如在从节点由于升级而重新启动时。
- en: 'The following is the parameter:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the executor driver that was disconnected.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是已断开连接的执行器驱动程序。'
- en: '`launchTask`: Take a look at the following code:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launchTask`：请查看以下代码：'
- en: '[PRE5]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code is invoked when a task is launched on this executor (initiated
    via `SchedulerDriver.launchTasks(java.util.Collection<OfferID>, java.util.Collection<TaskInfo>,
    Filters`). Note that this task can be realized with a thread, a process, or some
    simple computation; however, no other callbacks will be invoked on this executor
    until this callback returns.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码会在该执行器上启动任务时调用（通过`SchedulerDriver.launchTasks(java.util.Collection<OfferID>,
    java.util.Collection<TaskInfo>, Filters)`发起）。请注意，此任务可以通过线程、进程或一些简单的计算来实现；但是，在该回调返回之前，不会在此执行器上调用其他回调。
- en: 'The following are the parameters:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the executor driver that launched the task'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是启动任务的执行器驱动程序。'
- en: '`task`: This describes the task that was launched'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task`：描述已启动的任务'
- en: '`killTask`: Run the following code:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`killTask`：运行以下代码：'
- en: '[PRE6]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is invoked when a task running within this executor is killed via `SchedulerDriver.killTask`
    (TaskID). Note that no status update will be sent on behalf of the executor, and
    the executor is responsible for creating a new `TaskStatus` protobuf message (that
    is, with `TASK_KILLED`) and invoking `ExecutorDriver.sendStatusUpdate` (`TaskStatus`).
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当此执行器中的任务通过`SchedulerDriver.killTask`（TaskID）被终止时，将调用此方法。请注意，执行器不会代表任务发送状态更新，执行器负责创建新的`TaskStatus`
    protobuf消息（即，`TASK_KILLED`），并调用`ExecutorDriver.sendStatusUpdate`（`TaskStatus`）。
- en: 'The following are the parameters:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the executor driver that owned the task that was killed'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是拥有被终止任务的执行器驱动程序'
- en: '`taskId`: This is the ID of the task that was killed'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`taskId`：这是已终止任务的ID'
- en: '`frameworkMessage`: Run the following code:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frameworkMessage`：运行以下代码：'
- en: '[PRE7]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is invoked when a framework message arrives for this executor. These messages
    are the best effort; do not expect a framework message to be retransmitted in
    any reliable fashion.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当执行器接收到框架消息时，将调用此方法。这些消息是尽力而为的；不要期望框架消息以任何可靠的方式被重新传输。
- en: 'The following are the parameters:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the executor driver that received the message'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是接收到消息的执行器驱动程序'
- en: '`data`: This is the message payload'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是消息负载'
- en: '`shutdown`: Execute the following code:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown`：执行以下代码：'
- en: '[PRE8]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is invoked when the executor terminates all of its currently running tasks.
    Note that after Mesos determines that an executor has terminated, any tasks that
    the executor did not send Terminal status updates for (for example, `TASK_KILLED`,
    `TASK_FINISHED`, `TASK_FAILED`, and so on), and a `TASK_LOST` status update will
    be created.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当执行器终止其所有当前运行的任务时，将调用此方法。请注意，在Mesos确定执行器已终止后，任何执行器没有发送终止状态更新的任务（例如，`TASK_KILLED`、`TASK_FINISHED`、`TASK_FAILED`等）将创建一个`TASK_LOST`状态更新。
- en: 'The following is the parameter:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the executor driver that should terminate.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是应该终止的执行器驱动程序。'
- en: '`error`: Run the following:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：运行以下：'
- en: '[PRE9]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous code is invoked when a fatal error occurs with the executor and/or
    executor driver. The driver will be aborted BEFORE invoking this callback.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当执行器和/或执行器驱动程序发生致命错误时，前述代码会被调用。在调用此回调之前，驱动程序将被终止。
- en: 'The following are the parameters:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the executor driver that was aborted due to this error'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是由于此错误而被中止的执行器驱动程序'
- en: '`message`: This is the error message'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：这是错误信息'
- en: The Executor Driver API
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行器驱动程序API
- en: A brief description of the Executor Driver API is given below. For more details,
    visit [http://mesos.apache.org/api/latest/java/org/apache/mesos/ExecutorDriver.html](http://mesos.apache.org/api/latest/java/org/apache/mesos/ExecutorDriver.html).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行器驱动程序API的简要说明。如需更多详细信息，请访问 [http://mesos.apache.org/api/latest/java/org/apache/mesos/ExecutorDriver.html](http://mesos.apache.org/api/latest/java/org/apache/mesos/ExecutorDriver.html)。
- en: '`start`: Run the following line:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：运行以下一行：'
- en: '[PRE10]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code starts the executor driver. This needs to be called before
    any other driver calls are made.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码启动了执行器驱动程序。必须在进行其他驱动程序调用之前调用此方法。
- en: The state of the driver after the call is returned.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用后的驱动程序状态已返回。
- en: '`stop`: Run the following line:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`：运行以下一行：'
- en: '[PRE11]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This stops the executor driver.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将停止执行器驱动程序。
- en: The state of the driver after the call is the return.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用后的驱动程序状态就是返回值。
- en: '`abort`: Run the following line:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abort`：运行以下一行：'
- en: '[PRE12]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This aborts the driver so that no more callbacks can be made to the executor.
    The semantics of abort and stop are deliberately separated so that the code can
    detect an aborted driver (via the return status of `join()`; refer to the following
    section) and instantiate and start another driver if desired (from within the
    same process, although this functionality is currently not supported for executors).
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将中止驱动程序，以便不再向执行器发送回调。中止和停止的语义被故意分开，以便代码能够检测到中止的驱动程序（通过`join()`的返回状态；参见以下部分），并根据需要实例化并启动另一个驱动程序（在同一进程内，尽管目前执行器不支持此功能）。
- en: The state of the driver after the call is the return.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用后的驱动程序状态就是返回值。
- en: '`join`: Run the following:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join`：运行以下：'
- en: '[PRE13]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This waits for the driver to be stopped or aborted, possibly blocking the current
    thread indefinitely. The return status of this function can be used to determine
    whether the driver was aborted (take a look at `mesos.proto` for a description
    of status).
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会等待驱动程序停止或中止，可能会无限期地阻塞当前线程。此函数的返回状态可用于确定驱动程序是否被中止（查看 `mesos.proto` 以了解状态描述）。
- en: The state of the driver after the call is the return.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用后的驱动程序状态就是返回值。
- en: '`run`: Take a look at the following line of code:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：查看以下代码行：'
- en: '[PRE14]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This starts and immediately joins (that is, blocks) the driver.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将启动并立即加入（即阻塞）驱动程序。
- en: The state of the driver after the call is the return.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用后的驱动程序状态就是返回值。
- en: '`sendStatusUpdate`: Here''s the code to execute:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendStatusUpdate`：执行以下代码：'
- en: '[PRE15]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This sends a status update to the framework scheduler, retrying as necessary
    until an acknowledgement is received or the executor is terminated (in which case,
    a `TASK_LOST` status update will be sent). Take a look at `Scheduler.statusUpdate(org.apache.mesos.SchedulerDriver,
    TaskStatus)` for more information about status update acknowledgements.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会向框架调度器发送状态更新，必要时会重试，直到收到确认或执行器被终止（在这种情况下，将发送 `TASK_LOST` 状态更新）。有关状态更新确认的更多信息，请查看
    `Scheduler.statusUpdate(org.apache.mesos.SchedulerDriver, TaskStatus)`。
- en: 'The following is the parameter:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`status`: This is the status update to send.'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：这是需要发送的状态更新。'
- en: The state of the driver after the call is the return.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用后的驱动程序状态就是返回值。
- en: '`sendFrameworkMessage`: Run the following code:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendFrameworkMessage`：运行以下代码：'
- en: '[PRE16]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This sends a message to the framework scheduler. These messages are sent on
    a best effort basis and should not be expected to be retransmitted in any reliable
    fashion.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会向框架调度器发送一条消息。这些消息以尽力而为的方式发送，不能期望它们以任何可靠的方式重新传输。
- en: 'The parameters are as follows:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`data`: This is the message payload.'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是消息负载。'
- en: The state of the driver after the call is the return.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用后的驱动程序状态就是返回值。
- en: The Scheduler API
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调度器 API
- en: A brief description of the Scheduler API is given below. For more details, visit
    [http://mesos.apache.org/api/latest/java/org/apache/mesos/Scheduler.html](http://mesos.apache.org/api/latest/java/org/apache/mesos/Scheduler.html).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调度器 API 的简要描述。更多细节，请访问 [http://mesos.apache.org/api/latest/java/org/apache/mesos/Scheduler.html](http://mesos.apache.org/api/latest/java/org/apache/mesos/Scheduler.html)。
- en: '`registered`: This can be registered via the following code:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registered`：可以通过以下代码进行注册：'
- en: '[PRE17]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding is invoked when the scheduler successfully registers with a Mesos
    master. A unique ID (generated by the master) is used to distinguish this framework
    from others, and `MasterInfo` with the IP and port of the current master are provided
    as arguments.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前述代码会在调度器成功注册到 Mesos 主节点时调用。一个由主节点生成的唯一 ID 被用来区分该框架与其他框架，并且包含当前主节点 IP 和端口的 `MasterInfo`
    被作为参数提供。
- en: 'The following are the parameters:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the scheduler driver that was registered'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是已注册的调度器驱动程序。'
- en: '`FrameworkID`: This is the `FrameworkID` generated by the master'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrameworkID`：这是由主节点生成的 `FrameworkID`。'
- en: '`MasterInfo`: This is the information about the current master, including the
    IP and port.'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MasterInfo`：这是关于当前主节点的信息，包括 IP 和端口。'
- en: '`reregistered`: The preceding code can be reregistered as follows:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reregistered`：前述代码可以如下重新注册：'
- en: '[PRE18]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code is invoked when the scheduler reregisters with a newly elected
    Mesos master. This is only called when the scheduler is previously registered.
    `MasterInfo` containing the updated information about the elected master is provided
    as an argument.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前述代码会在调度器重新注册到新选举出的 Mesos 主节点时调用。只有在调度器之前已注册时才会调用。包含选举出的主节点更新信息的 `MasterInfo`
    被作为参数提供。
- en: 'The parameters are as follows:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`driver`: This is the driver that was reregistered'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是已重新注册的驱动程序。'
- en: '`MasterInfo`: This is the updated information about the elected master'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MasterInfo`：这是关于选举出的主节点的更新信息。'
- en: '`resourceOffers`: Execute the following code:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resourceOffers`：执行以下代码：'
- en: '[PRE19]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code is invoked when resources are offered to this framework.
    A single offer will only contain resources from a single slave. Resources associated
    with an offer will not be reoffered to this framework until either; (a) this framework
    rejects these resources (refer to `SchedulerDriver.launchTasks(java.util.Collection<OfferID>,
    java.util.Collection<TaskInfo>, Filters)`), or (b) these resources are rescinded
    (refer to `offerRescinded(org.apache.mesos.SchedulerDriver, OfferID)`). Note that
    resources may be concurrently offered to more than one framework at a time, depending
    on the allocator being used. In this case, the first framework to launch tasks
    using these resources will be able to use them, while the other frameworks will
    have these resources rescinded. (Alternatively, if a framework has already launched
    tasks with these resources, these tasks will fail with a `TASK_LOST` status and
    a message saying as much).
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当资源提供给该框架时，会调用前面的代码。单个提议仅包含来自单个从属节点的资源。与提议相关的资源不会重新提供给该框架，直到以下情况之一发生：（a）该框架拒绝这些资源（参考`SchedulerDriver.launchTasks(java.util.Collection<OfferID>,
    java.util.Collection<TaskInfo>, Filters)`），或（b）这些资源被撤销（参考`offerRescinded(org.apache.mesos.SchedulerDriver,
    OfferID)`）。请注意，资源可能会同时提供给多个框架，具体取决于所使用的分配器。在这种情况下，第一个使用这些资源启动任务的框架将能够使用这些资源，而其他框架将会失去这些资源。（或者，如果一个框架已经使用这些资源启动了任务，这些任务将失败，并显示`TASK_LOST`状态，附带一条说明信息。）
- en: 'The following are the parameters:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the driver that was used to run this scheduler'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是用于运行该调度器的驱动程序'
- en: '`offers`: These are the resources offered to this framework'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offers`：这是提供给该框架的资源'
- en: '`offerRescinded`: Run the following code:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offerRescinded`：运行以下代码：'
- en: '[PRE20]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is invoked when an offer is no longer valid (for example, the slave is
    lost or another framework is used resources in the offer). If, for whatever reason,
    an offer is never rescinded (for example, a dropped message, failing over framework,
    and so on), a framework that attempts to launch tasks using an invalid offer will
    receive a `TASK_LOST` status update for these tasks (take a look at `resourceOffers(org.apache.mesos.SchedulerDriver,
    java.util.List<Offer>)`).
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当提议不再有效时会调用此代码（例如，从属节点丢失或另一个框架使用了提议中的资源）。如果由于某种原因，提议从未被撤销（例如，丢失的消息，框架故障转移等），那么尝试使用无效提议启动任务的框架将收到`TASK_LOST`状态更新（请查看`resourceOffers(org.apache.mesos.SchedulerDriver,
    java.util.List<Offer>)`）。
- en: 'The following are the parameters:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the driver that was used to run this scheduler'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是用于运行该调度器的驱动程序'
- en: '`offerID`: This is the ID of the offer that was rescinded'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offerID`：这是被撤销的提议的ID'
- en: '`statusUpdate`: Take a look at the following code:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statusUpdate`：请查看以下代码：'
- en: '[PRE21]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code is invoked when the status of a task changes (for example,
    a slave is lost, so the task is lost; a task is finished, and an executor sends
    a status update saying so; and so on). If, for whatever reason, the scheduler
    is aborted during this callback or the process exits, then another status update
    will be delivered. (Note, however, that this is currently not true if the slave
    sending the status update is lost or fails during this time.)
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当任务状态发生变化时，会调用前面的代码（例如，某个从属节点丢失，任务也随之丢失；任务完成，执行器发送状态更新；等等）。如果由于某种原因，在这个回调过程中调度器被中止或进程退出，那么会再传递一次状态更新。（不过请注意，如果在此期间发送状态更新的从属节点丢失或失败，当前这种情况并不适用。）
- en: 'The parameters are as follows:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the driver that was used to run this scheduler'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是用于运行该调度器的驱动程序'
- en: '`status`: This is the status update, which includes the task ID and status'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：这是状态更新，包含任务ID和状态'
- en: '`frameworkMessage`: Take a look at the following code:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frameworkMessage`：请查看以下代码：'
- en: '[PRE22]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code is invoked when an executor sends a message. These messages
    are sent on a best effort basis and should not be expected to be retransmitted
    in any reliable fashion.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当执行器发送消息时，会调用前面的代码。这些消息是尽最大努力发送的，不能期望它们会以可靠的方式重新传输。
- en: 'The parameters are as follows:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`driver`: This is the driver that received the message'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：这是接收消息的驱动程序'
- en: '`ExecutorID`: This is the ID of the executor that sent the message'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorID`：这是发送消息的执行器ID'
- en: '`SlaveID`: This is the ID of the slave that launched the executor'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SlaveID`：这是启动执行器的从属节点ID'
- en: '`data`: This is the message payload'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是消息的有效载荷'
- en: '`disconnected`: Run the following:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnected`：运行以下代码：'
- en: '[PRE23]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is invoked when the scheduler becomes disconnected from the master (for
    example, the master fails and another takes over).
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当调度器与主节点断开连接时会触发此操作（例如，主节点失败并由另一个主节点接管）。
- en: 'The following is the parameter:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the driver that was used to run this scheduler'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`: 这是用来运行此调度器的驱动程序'
- en: '`slaveLost`: Execute the following code:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slaveLost`: 执行以下代码：'
- en: '[PRE24]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is invoked when a slave is determined unreachable (for example, machine
    failure or network partition). Most frameworks need to reschedule any tasks launched
    on this slave on a new slave.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当从节点被确定为无法访问时（例如，机器故障或网络分区），会调用此操作。大多数框架需要在新的从节点上重新调度所有在该从节点上启动的任务。
- en: 'The following are the parameters:'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the driver that was used to run this scheduler'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`: 这是用来运行此调度器的驱动程序'
- en: '`SlaveID`: This is the ID of the slave that was lost'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SlaveID`: 这是丢失的从节点 ID'
- en: '`executorLost`: Run the following:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executorLost`: 执行以下操作：'
- en: '[PRE25]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding is invoked when an executor is exited or terminated. Note that
    any running task will have the `TASK_LOST` status update automatically generated.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述操作会在执行器退出或终止时触发。请注意，任何正在运行的任务都会自动生成 `TASK_LOST` 状态更新。
- en: 'The following are the parameters:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the driver that was used to run this scheduler'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`: 这是用来运行此调度器的驱动程序'
- en: '`ExecutorID`: This is the ID of the executor that was lost'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorID`: 这是丢失的执行器的 ID'
- en: '`slaveID`: This is the ID of the slave that launched the executor'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slaveID`: 这是启动执行器的从节点 ID'
- en: '`status`: This is the exit status of the executor'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 这是执行器的退出状态'
- en: '`error`: Run the following code:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`: 执行以下代码：'
- en: '[PRE26]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding is invoked when there is an unrecoverable error in the scheduler
    or driver. The driver will be aborted *before* invoking this callback.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述操作会在调度器或驱动程序发生不可恢复错误时触发。驱动程序将在调用此回调之前被中止 *before*。
- en: 'The following are the parameters:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`driver`: This is the driver that was used to run this scheduler'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`: 这是用来运行此调度器的驱动程序'
- en: '`message`: This is the error message'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`: 这是错误消息'
- en: The Scheduler Driver API
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调度器驱动程序 API
- en: A brief description of the Scheduler Driver API is given below. For more details,
    visit [http://mesos.apache.org/api/latest/java/org/apache/mesos/SchedulerDriver.html](http://mesos.apache.org/api/latest/java/org/apache/mesos/SchedulerDriver.html)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调度器驱动程序 API 的简要描述。更多细节，请访问 [http://mesos.apache.org/api/latest/java/org/apache/mesos/SchedulerDriver.html](http://mesos.apache.org/api/latest/java/org/apache/mesos/SchedulerDriver.html)
- en: '`start`: Run the following code:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`: 执行以下代码：'
- en: '[PRE27]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This starts the scheduler driver. It needs to be called before any other driver
    calls are made.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会启动调度器驱动程序。它需要在任何其他驱动程序调用之前调用。
- en: The preceding returns the state of the driver after the call.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述操作会在调用后返回驱动程序的状态。
- en: '`stop`: Execute the following code:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`: 执行以下代码：'
- en: '[PRE28]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This stops the scheduler driver. If the `failover` flag is set to false, it
    is expected that this framework will never reconnect to Mesos. So, Mesos will
    unregister the framework and shut down all its tasks and executors. If `failover`
    is true, all executors and tasks will remain running (for some framework-specific
    failover timeout), allowing the scheduler to reconnect (possibly in the same process
    or from a different process—for example, on a different machine).
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会停止调度器驱动程序。如果 `failover` 标志设置为 false，则预计该框架永远不会重新连接到 Mesos。因此，Mesos 将注销该框架并关闭所有任务和执行器。如果
    `failover` 为 true，所有执行器和任务将保持运行（在某些特定的故障转移超时内），允许调度器重新连接（可能是在同一进程中或来自不同进程——例如，在不同的机器上）。
- en: 'The following is the parameter:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`failover`: This is whether framework failover is expected'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failover`: 这是是否预计会发生框架故障转移'
- en: This returns the state of the driver after the call.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会返回调用后驱动程序的状态。
- en: '`Stop`: Run the following line:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stop`: 执行以下一行：'
- en: '[PRE29]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This stops the scheduler driver assuming no failover. This will cause Mesos
    to unregister the framework and shut down all its tasks and executors.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会停止调度器驱动程序，假设没有故障转移。这样会导致 Mesos 注销该框架并关闭所有任务和执行器。
- en: This returns the state of the driver after the call.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会返回调用后驱动程序的状态。
- en: '`abort`: Execute the following code:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abort`: 执行以下代码：'
- en: '[PRE30]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This aborts the driver so that no more callbacks can be made to the scheduler.
    The semantics of abort and stop are deliberately separated so that code can detect
    an aborted driver (via the return status of `join()`; refer to the following section)
    and instantiate and start another driver if desired from within the same process.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将中止驱动程序，从而不再对调度器进行任何回调。中止和停止的语义被故意分开，以便代码可以检测到已中止的驱动程序（通过`join()`的返回状态；请参阅以下部分），并根据需要在同一进程内实例化并启动另一个驱动程序。
- en: This returns the state of the driver after the call.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: '`join`: Run the following:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join`: 运行以下代码：'
- en: '[PRE31]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This waits for the driver to be stopped or aborted, possibly *blocking* the
    current thread indefinitely. The return status of this function can be used to
    determine whether the driver was aborted (take a look at `mesos.proto` for a description
    of `Status`).
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将等待驱动程序停止或被中止，可能会*阻塞*当前线程，直到操作完成。该函数的返回状态可用于确定驱动程序是否被中止（请查看`mesos.proto`以了解`Status`的描述）。
- en: This returns the state of the driver after the call.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: '`run`: Execute the following:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`: 执行以下操作：'
- en: '[PRE32]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This starts and immediately joins (that is, blocks) the driver.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将启动并立即加入（即阻塞）驱动程序。
- en: It returns the state of the driver after the call.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: '`requestResources`: Take a look at the following:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestResources`: 请查看以下内容：'
- en: '[PRE33]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This requests resources from Mesos (take a look at `mesos.proto` for a description
    of Request and how, for example, to request resources from specific slaves). Any
    resources available are offered to the framework via the `Scheduler.resourceOffers(org.apache.mesos.SchedulerDriver,
    java.util.List<Offer>)` callback asynchronously.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将从Mesos请求资源（请查看`mesos.proto`以了解Request的描述，以及如何例如从特定的slaves请求资源）。任何可用的资源将通过`Scheduler.resourceOffers(org.apache.mesos.SchedulerDriver,
    java.util.List<Offer>)`回调异步地提供给框架。
- en: 'The following is the parameter:'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`requests`: These are the resource requests.'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requests`: 这些是资源请求。'
- en: It returns the state of the driver after the call.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: '`launchTasks`: Use the following code:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launchTasks`: 使用以下代码：'
- en: '[PRE34]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code launches the given set of tasks on a set of offers. Resources
    from offers are aggregated when more than one is provided. Note that all the offers
    must belong to the same slave. Any resources remaining (that is, not used by the
    tasks or their executors) will be considered declined. The specified filters are
    applied on all unused resources (take a look at `mesos.proto` for a description
    of Filters). Invoking this function with an empty collection of tasks declines
    offers in their entirety (refer to `declineOffer(OfferID, Filters)`).
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将在一组offer上启动给定的任务集。资源来自多个offer时将会被聚合。请注意，所有的offer必须属于同一个slave。任何剩余的资源（即未被任务或其执行器使用的资源）将被视为已拒绝。指定的过滤器将应用于所有未使用的资源（请查看`mesos.proto`以了解Filters的描述）。如果使用空的任务集合调用此函数，则会完全拒绝所有的offer（参见`declineOffer(OfferID,
    Filters)`）。
- en: 'The following are the parameters:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`offerIds`: This is the collection of offer IDs'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offerIds`: 这是offer ID的集合。'
- en: '`tasks`: This is the collection of tasks to be launched'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`: 这是要启动的任务集合。'
- en: '`filters`: This is the filters to set for any remaining resources.'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filters`: 这是用于设置剩余资源的过滤器。'
- en: It returns the state of the driver after the call.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: '`killTask`: Execute the following code:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`killTask`: 执行以下代码：'
- en: '[PRE35]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This kills the specified task. Note that attempting to kill a task is currently
    not reliable. If, for example, a scheduler fails over while it attempts to kill
    a task, it will need to retry in the future. Likewise, if unregistered/disconnected,
    the request will be dropped (these semantics may be changed in the future).
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将终止指定的任务。请注意，尝试终止任务目前并不可靠。例如，如果调度器在尝试终止任务时发生故障，它将在将来需要重新尝试。同样，如果未注册或断开连接，请求将被丢弃（这些语义可能会在未来发生变化）。
- en: 'The following is the parameter:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`taskId`: This is the ID of the task to be killed'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`taskId`: 这是要终止的任务的ID。'
- en: It returns the state of the driver after the call.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: '`declineOffer`: Run the following code:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declineOffer`: 运行以下代码：'
- en: '[PRE36]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This declines an offer in its entirety and applies the specified filters on
    the resources (take a look at `mesos.proto` for a description of Filters). Note
    that this can be done at any time, and it is not necessary to do this within the
    `Scheduler.resourceOffers(org.apache.mesos.SchedulerDriver, java.util.List<Offer>)`
    callback.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将完全拒绝一个请求，并对资源应用指定的过滤器（可以查看 `mesos.proto` 以了解过滤器的描述）。请注意，这可以随时进行，并不需要在 `Scheduler.resourceOffers(org.apache.mesos.SchedulerDriver,
    java.util.List<Offer>)` 回调中完成。
- en: 'The following are the parameters:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`offerId`: This is the ID of the offer to be declined'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offerId`：这是要拒绝的请求的 ID'
- en: '`filters`: These are the filters to be set for any remaining resources'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filters`：这是要为任何剩余资源设置的过滤器'
- en: It returns the state of the driver after the call.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: '`reviveOffers`: Execute the following:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reviveOffers`：执行以下操作：'
- en: '[PRE37]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This removes all the filters previously set by the framework (via `launchTasks(java.util.Collection<OfferID>,
    java.util.Collection<TaskInfo>, Filters)`). This enables the framework to receive
    offers from these filtered slaves.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将删除框架之前设置的所有过滤器（通过 `launchTasks(java.util.Collection<OfferID>, java.util.Collection<TaskInfo>,
    Filters)`）。这使得框架可以从这些被过滤的从节点接收请求。
- en: It returns the state of the driver after the call.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: '`sendFrameworkMessage`: Take a look at the following:'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendFrameworkMessage`：请查看以下内容：'
- en: '[PRE38]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This sends a message from the framework to one of its executors. These messages
    are sent on a best effort basis and should not be expected to be retransmitted
    in any reliable fashion.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会从框架向其一个执行器发送消息。消息是尽最大努力发送的，不应期望以任何可靠的方式进行重传。
- en: 'The parameters are:'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`executorId`: This is the ID of the executor to send the message to'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executorId`：这是发送消息的执行器 ID'
- en: '`slaveId`: This is the ID of the slave that runs the executor'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slaveId`：这是运行执行器的从节点的 ID'
- en: '`data`: This is the message'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是消息'
- en: It returns the state of the driver after the call.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: '`reconcileTasks`: Take a look at the following code:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reconcileTasks`：请查看以下代码：'
- en: '[PRE39]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This allows the framework to query the status for nonterminal tasks. This causes
    the master to send back the latest task status for each task in `statuses` if
    possible. Tasks that are no longer known will result in a `TASK_LOST` update.
    If `statuses` is empty, the master will send the latest status for each task currently
    known.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许框架查询非终结任务的状态。如果可能，主节点会返回 `statuses` 中每个任务的最新状态。那些不再存在的任务会导致 `TASK_LOST` 更新。如果
    `statuses` 为空，主节点将发送当前已知的每个任务的最新状态。
- en: 'The following are the parameters:'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: '`statuses`: This is the collection of nonterminal `TaskStatus` protobuf messages
    to reconcile.'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statuses`：这是待对账的非终结 `TaskStatus` protobuf 消息集合。'
- en: It returns the state of the driver after the call.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回调用后的驱动程序状态。
- en: Mesos in production
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos 在生产环境中
- en: Mesos is in production at several companies such as Apple, Twitter, and HubSpot
    and has even been used by start-ups such as Mattermark and Sigmoid. This broad
    appeal is a validation of Mesos' tremendous utility. Apple, for example, powers
    its consumer-facing, mission–critical, popular *Siri* application through a large
    Mesos cluster (allegedly spanning tens of thousands of nodes). One such case study
    (published on the Mesosphere website) is discussed here.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 已在多家企业中投入生产使用，例如 Apple、Twitter 和 HubSpot，并且甚至被 Mattermark 和 Sigmoid 等初创公司使用过。这种广泛的吸引力验证了
    Mesos 强大的实用性。例如，Apple 通过一个大型 Mesos 集群（据称跨越数万个节点）支持其面向消费者的、任务关键型的流行 *Siri* 应用程序。这里讨论了一个案例研究（发布在
    Mesosphere 网站上）。
- en: Case study on HubSpot
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HubSpot 案例研究
- en: 'Following case study on HubSpot can be found here [https://mesosphere.com/mesos-case-study-hubspot/](https://mesosphere.com/mesos-case-study-hubspot/).
    An excerpt from this link is given below:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 HubSpot 的案例研究可以在此处找到 [https://mesosphere.com/mesos-case-study-hubspot/](https://mesosphere.com/mesos-case-study-hubspot/)。下面给出了该链接的摘录：
- en: HubSpot uses Apache Mesos to run a mixture of web services, long-running processes,
    and scheduled jobs that comprise their SaaS application. Mesos allows HubSpot
    to dynamically deploy services, which in turn reduces developer friction and time
    to deploy, increases reliability, achieves better resource utilization, and reduces
    hardware costs.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: HubSpot 使用 Apache Mesos 运行包括 Web 服务、长时间运行的进程和计划任务在内的混合服务，组成了他们的 SaaS 应用程序。Mesos
    允许 HubSpot 动态部署服务，从而减少了开发人员的摩擦和部署时间，提高了可靠性，实现了更好的资源利用率，并降低了硬件成本。
- en: Mesos provides the core infrastructure to build a next-generation deployment
    system similar to what Heroku provides as a product. On top of Mesos, HubSpot
    built their own scheduler that is capable of executing both long-running services
    and scheduled jobs and is the interface through which the development team can
    view the state of their applications inside the cloud. Building a scheduler framework
    enables HubSpot to better understand the core concepts inside Mesos, be comfortable
    with failure modes, and customize user experience.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 提供了构建下一代部署系统的核心基础设施，这类似于 Heroku 提供的产品。在 Mesos 之上，HubSpot 构建了自己的调度器，能够执行长时间运行的服务和定时任务，并且是开发团队查看其应用程序在云中状态的接口。构建调度器框架使
    HubSpot 更好地理解 Mesos 内部的核心概念，适应故障模式，并定制用户体验。
- en: The cluster environment
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集群环境
- en: Over 150 services run inside Mesos at HubSpot. HubSpot utilizes many hundreds
    of servers inside Amazon EC2, and the Mesos cluster comprises about 30% of these
    resources and is aggressively ramping up as more and more services are migrated
    to Mesos. As Mesos can easily handle large or small server footprints, hundreds
    of smaller servers are replaced with dozens of larger ones.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: HubSpot 内运行着超过 150 个服务。HubSpot 在 Amazon EC2 中使用了数百台服务器，Mesos 集群占据了大约 30% 的资源，并且随着越来越多服务迁移到
    Mesos，集群的规模正在迅速扩大。由于 Mesos 能轻松处理大规模或小规模的服务器配置，数百台小型服务器被替换为数十台更大的服务器。
- en: Benefits
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 好处
- en: 'Mesos provides numerous benefits to both the development team and the company.
    At HubSpot, developers own the operation of their applications. With Mesos, developers
    can deploy services faster and with less maintenance. Here are some of the other
    benefits:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 为开发团队和公司提供了众多好处。在 HubSpot，开发者拥有他们应用程序的操作权。借助 Mesos，开发者可以更快地部署服务，并减少维护工作。以下是一些其他的好处：
- en: Developers get immediate access to cluster resources, whether it be to scale
    or introduce new services.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以立即访问集群资源，无论是为了扩展还是引入新服务。
- en: Developers no longer need to understand the process of requisitioning hardware
    or servers, and it is easier to scale up the resource requirements inside Mesos
    than it is to recreate servers with more or less CPUs and memory.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者不再需要理解硬件或服务器申请的过程，且在 Mesos 中扩大资源需求比重建具有更多或更少 CPU 和内存的服务器要容易得多。
- en: Hardware failures are more transparent to developers as services are automatically
    replaced when tasks are lost or they fail. In other words, developers are no longer
    paged because of a simple hardware failure.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件故障对开发者而言更加透明，因为当任务丢失或失败时，服务会自动替换。换句话说，开发者不再因为简单的硬件故障而接到紧急通知。
- en: Scheduled tasks (cron jobs) are now exposed via a web interface and are not
    tied to a single server, which may fail at any time, taking the cron job with
    it.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时任务（cron 任务）现在通过 Web 界面暴露出来，并且不再绑定到单一服务器，避免了服务器故障时 cron 任务也随之丢失的情况。
- en: Mesos also simplifies the technology stack required to requisition hardware
    and manage it from an operations perspective. HubSpot can standardize server footprints
    and simplify the base image upon which Mesos slaves are executed.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 还简化了从操作角度请求和管理硬件所需的技术栈。HubSpot 可以标准化服务器配置并简化 Mesos slave 执行的基础镜像。
- en: Lastly, resource utilization is improved, which directly corresponds with reducing
    costs. Services, which previously ran on overprovisioned hardware now use the
    exact amount of resources requested.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，资源利用率得到了提高，这直接对应于降低成本。之前在过度配置的硬件上运行的服务现在仅使用所需的精确资源。
- en: Additionally, the QA environment runs at 50% of its previous capacity as the
    HubSpot scheduler ensures that services are restarted when they fail. This means
    that it is no longer necessary to run multiple copies of services inside QA for
    high availability.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，QA 环境的容量已降至之前的 50%，因为 HubSpot 调度器确保当服务失败时会重新启动。这意味着不再需要在 QA 中运行多个副本来保证服务的高可用性。
- en: Challenges
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战
- en: A core challenge behind adoption is introducing a new deployment technology
    to a group of 100 engineers who are responsible for managing their applications
    on a daily basis. HubSpot mitigated this challenge by building a UI around Mesos
    and utilizing Mesos to make the deployment process as simple and rewarding as
    possible.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 采用过程中的核心挑战是向 100 位负责日常管理应用程序的工程师群体引入一种新的部署技术。HubSpot 通过围绕 Mesos 构建 UI，并利用 Mesos
    使部署过程尽可能简单和高效，从而解决了这一挑战。
- en: Looking ahead
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: HubSpot sees Mesos as a core technology behind future migrations into other
    datacenters. As both a virtualization and deployment technology, Mesos has proven
    to be a rewarding path forward. Additionally, HubSpot hopes to eventually leverage
    Mesos to dynamically scale out processes based on load, shrink and grow the cluster
    size relative to demand, and assist developers with resource estimation.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: HubSpot 将 Mesos 视为未来迁移到其他数据中心的核心技术。作为一种虚拟化和部署技术，Mesos 已证明是通往成功的有效路径。此外，HubSpot
    希望最终利用 Mesos 根据负载动态扩展进程，缩小或扩大集群规模以满足需求，并帮助开发人员进行资源估算。
- en: Tip
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Please have a look. The code bundle for the book is also hosted on GitHub
    at [https://github.com/PacktPublishing/Mastering-Mesos](https://github.com/PacktPublishing/Mastering-Mesos).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码包的详细步骤在本书的前言中有提到，请查阅。本书的代码包也托管在 GitHub 上，地址为 [https://github.com/PacktPublishing/Mastering-Mesos](https://github.com/PacktPublishing/Mastering-Mesos)。我们还提供了来自我们丰富书籍和视频目录的其他代码包，地址为
    [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)。赶紧看看吧！
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced Mesos, dived deep into its architecture, and
    discussed some important topics, such as frameworks, resource allocation, and
    resource isolation. We also discussed the two-level scheduling approach that Mesos
    employs and provided a detailed overview of its API. The HubSpot case study at
    the end was to show how it is used in production and that it is ready for prime
    time. The objective was to explain what Mesos is and why it is required and provide
    a high-level overview of how it works.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Mesos，深入探讨了其架构，并讨论了一些重要主题，如框架、资源分配和资源隔离。我们还讨论了 Mesos 使用的两级调度方法，并提供了其
    API 的详细概述。最后的 HubSpot 案例研究展示了它在生产中的应用，并表明它已经准备好投入实际使用。本章的目标是解释 Mesos 是什么、为什么需要它，并提供一个高层次的工作原理概述。
- en: In the next chapter, we will deep dive into its important features and understand
    how it contributes to scaling, efficiency, high availability, and extendibility.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解其重要特性，并理解它如何有助于扩展、效率、高可用性和可扩展性。
