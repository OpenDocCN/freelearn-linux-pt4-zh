["```\n#!/bin/bash\n\nfunction recursive_func() {\n\n    echo -n \"Press anything to continue loop \"\n    read input\n    recursive_func\n}\n\nrecursive_func\nexit 0\n```", "```\n#!/bin/bash\nfor (( ; ; ))\ndo\n   echo \"Shall run for ever\"\n   sleep 1\ndone\nexit 0\n```", "```\n#!/bin/bash\nEXIT_PLEASE=0\nwhile : # Notice no conditions?\ndo\n   echo \"Pres CTRL+C to stop...\"\n   sleep 1\n   if [ $EXIT_PLEASE != 0 ]; then\n      break \n    fi \ndone\nexit 0\n```", "```\n#!/bin/bash\nEXIT_PLEASE=0\nuntil [ $EXIT_PLEASE != 0 ] # EXIT_PLEASE is set to 0, until will never be satisfied\ndo\n   echo \"Pres CTRL+C to stop...\"\n   sleep 1\ndone\nexit 0\n```", "```\n#!/bin/bash\nEXIT_PLEASE=0\nINC=0\n\nuntil [ ${EXIT_PLEASE} != 0 ] # EXIT_PLEASE is set to 0, until will never be satisfied\ndo\n   echo \"Boo $INC\" > /dev/null\n   INC=$((INC + 1))\n   sleep 1\ndone\nexit 0\n```", "```\n$ bash loop_and_print.sh &\n$ ps aux | grep loop_and_print.sh # Take note of the PID - write it down\n```", "```\n$ ps aux | grep loop_and_print.sh # Take note of the PID - write it down\n```", "```\n$ bash loop_and_print.sh & # note the PID againg\n$ disown\n```", "```\n$ ps aux | grep loop_and_print.sh # Take note of the PID - write it down\n```", "```\n$ nohup bash loop_and_print.sh &\n```", "```\n$ ps aux | grep loop_and_print.sh # Take note of the PID - write it down\n```", "```\n$ bash loop_and_print.sh &\n[1]4510\n$ ps aux | grep loop_and_print.sh # Take note of the PID - write it down\nrbrash 4510 0.0 0.0 12548 3024 pts/2 S 12:58 0:00 bash loop_and_print.sh\n```", "```\nrbrash 8097 0.0 0.0 12548 3024 pts/2 S 13:02 0:00 bash loop_and_print.sh\n```", "```\n$ nohup bash loop_and_print.sh &\n[2] 14256\n$ nohup: ignoring input and appending output to 'nohup.out'\n```", "```\n$ ps aux | grep loop_and_print.sh\nrbrash 4510 0.0 0.0 12548 3024 pts/2 S 12:58 0:00 bash loop_and_print.sh\nrbrash 14256 0.0 0.0 12548 3024 pts/2 S 13:02 0:00 bash loop_and_print.sh\n```", "```\n$ sudo ls /root\n$ su -c 'ls /root'\n$ su -\n```", "```\n$ sudo /etc/sudoers\n[sudo] password for rbrash: \n#\n# This file MUST be edited with the 'visudo' command as root.\n#\n# Please consider adding local content in /etc/sudoers.d/ instead of\n# directly modifying this file.\n#\n# See the man page for details on how to write a sudoers file.\n#\nDefaults env_reset\nDefaults mail_badpass\nDefaults secure_path=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin\"\n\n# Host alias specification\n\n# User alias specification\n\n# Cmnd alias specification\n\n# User privilege specification\nroot ALL=(ALL:ALL) ALL\n\n# Members of the admin group may gain root privileges\n%admin ALL=(ALL) ALL\n\n# Allow members of group sudo to execute any command\n%sudo ALL=(ALL:ALL) ALL\n\n# See sudoers(5) for more information on \"#include\" directives:\n\n#includedir /etc/sudoers.d\n\n```", "```\nroot ALL=(ALL:ALL) ALL\n```", "```\n$ sudo visudo\n```", "```\nDec 23 16:16:19 moon sudo: rbrash : TTY=pts/2 ; PWD=/home/rbrash/Desktop/book ; USER=root ; COMMAND=/usr/bin/vi /var/log/auth.log\nDec 23 16:16:19 moon sudo: pam_unix(sudo:session): session opened for user root by (uid=0)\n```", "```\n$ sudo useradd bob\n$ sudo passwd bob #use password\n```", "```\n$ shutdown -h 10\n$ shutdown -c\n```", "```\n$ sudo visudo\n[sudo] password for rbrash: \n#\nDefaults env_reset\nDefaults mail_badpass\nDefaults secure_path=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin\"\n\n# Host alias specification\n\n# User alias specification\n\n# Cmnd alias specification\n\nCmnd_Alias READ_CMDS = /sbin/halt, /sbin/shutdown\n\n# User privilege specification\nroot ALL=(ALL:ALL) ALL\n\nbob ALL=(ALL:ALL) NOPASSWD: READ_CMDS\n\n# Members of the admin group may gain root privileges\n%admin ALL=(ALL) ALL\n\n# Allow members of group sudo to execute any command\n%sudo ALL=(ALL:ALL) ALL\n\n# See sudoers(5) for more information on \"#include\" directives:\n\n#includedir /etc/sudoers.d\n\n```", "```\n$ shutdown -h 10\n$ shutdown -c\n```", "```\n#!/bin/bash\n\nFILE_NAME=$1\necho $FILE_NAME\nls $FILE_NAME\n```", "```\n$ touch TEST.txt\n$ mkdir new_dir/\n$ bash bad_input.sh \".\"\n$ bash bad_input.sh \"../\"\n```", "```\n#!/bin/bash\nFILE_NAME=$1\n\n# first, strip underscores\nFILE_NAME_CLEAN=${FILE_NAME//_/}\n\nFILE_NAME_CLEAN=$(sed 's/..//g' <<< ${FILE_NAME_CLEAN})\n\n# next, replace spaces with underscores\nFILE_NAME_CLEAN=${FILE_NAME_CLEAN// /_}\n\n# now, clean out anything that's not alphanumeric or an underscore\nFILE_NAME_CLEAN=${FILE_NAME_CLEAN//[^a-zA-Z0-9_.]/}\n\n# here you should check to see if the file exists before running the command\nls \"${FILE_NAME_CLEAN}\"\n```", "```\n$ bash better_input.sh \".\"\n$ bash better_input.sh \"../\"\n$ bash better_input.sh \"anyfile\"\n```", "```\n#!/bin/bash\n\nEMAIL=$1\necho \"${EMAIL}\" | grep '^[a-zA-Z0-9._]*@[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\nRES=$?\nif [ $RES -ne 1 ]; then\n    echo \"${EMAIL} is valid\"\nelse\n    echo \"${EMAIL} is NOT valid\"\nfi >/dev/null\nRES=$?\nif [ $RES -ne 1 ]; then\n    echo \"${EMAIL} is valid\"\nelse\n    echo \"${EMAIL} is NOT valid\"\nfi\n```", "```\n$ bash validate_email.sh ron.brash@somedomain.com\nron.brash@somedomain.com is valid\n$ bash validate_email.sh ron.brashsomedomain.com\nron.brashsomedomain.com is NOT valid\n```", "```\n#!/bin/bash\n\nIP_ADDR=$1\nIFS=.\nif echo \"$IP_ADDR\" | { read octet1 octet2 octet3 octet4 extra;\n  [[ \"$octet1\" == *[[:digit:]]* ]] && \n  test \"$octet1\" -ge 0 && test \"$octet1\" -le 255 &&\n  [[ \"$octet2\" == *[[:digit:]]* ]] && \n  test \"$octet2\" -ge 0 && test \"$octet2\" -le 255 &&\n  [[ \"$octet3\" == *[[:digit:]]* ]] && \n  test \"$octet3\" -ge 0 && test \"$octet3\" -le 255 &&\n  [[ \"$octet4\" == *[[:digit:]]* ]] && \n  test \"$octet4\" -ge 0 && test \"$octet4\" -le 255 &&\n  test -z \"$extra\" 2> /dev/null; }; then\n  echo \"${IP_ADDR} is valid\"\nelse\n    echo \"${IP_ADDR} is NOT valid\"\nfi\n```", "```\n$ bash validate_ip.sh \"a.a.a.a\"\n$ bash validate_ip.sh \"0.a.a.a\"\n$ bash validate_ip.sh \"255.255.255.255\"\n$ bash validate_ip.sh \"0.0.0.0\"\n$ bash validate_ip.sh \"192.168.0.10\"\n```", "```\n$ touch TEST.txt\n$ mkdir new_dir/\n$ bash bad_input.sh \".\"\n...\n$ bash bad_input.sh \"../\"\n../all the files backwards\n```", "```\nSelect a file from the list:\n1.) myfirst.file\n2.) mysecond.file\nYou chose: mysecond.file\n```", "```\n#!/bin/bash\nTITLE=\"Select file menu\"\nPROMPT=\"Pick a task:\"\nOPTIONS=(\"list\" \"delete\" \"modify\" \"create\")\n\nfunction list_files() {\n  PS3=\"Choose a file from the list or type \\\"back\\\" to go back to the main: \"\n  select OPT in *; do \n    if [[ $REPLY -le ${#OPT[@]} ]]; then\n      if [[ \"$REPLY\" == \"back\" ]]; then \n        return\n      fi\n      echo \"$OPT was selected\"\n    else\n      list_files\n    fi\n  done\n}\n\nfunction main_menu() {\n  echo \"${TITLE}\"\n  PS3=\"${PROMPT} \"\n  select OPT in \"${OPTIONS[@]}\" \"quit\"; do \n    case \"$REPLY\" in\n      1 ) \n        # List\n        list_files\n        main_menu # Recursive call to regenerate the menu\n      ;;\n      2 ) \n        echo \"not used\"\n      ;;\n      3 ) \n        echo \"not used\"\n      ;;\n      4 )\n        echo \"not used\"\n      ;;\n      $(( ${#OPTIONS[@]}+1 )) ) echo \"Exiting!\"; break;;\n      *) echo \"Invalid option. Try another one.\";continue;;\n    esac\n  done\n}\n\nmain_menu # Enter recursive loop\n```", "```\n$ bash select_menu.sh\n```", "```\n$ kill -s SIGUSR1 <processID>\n$ kill -9 <processID>\n$ kill -9 `pidof myprogram.sh`\n```", "```\n#!/bin/bash\n\nfunction setup() {\n  trap \"cleanup\" SIGINT SIGTERM\n  echo \"PID of script is $$\"\n}\n\nfunction cleanup() {\n  echo \"cleaning up\"\n  exit 1\n}\n\nsetup\n\n# Loop forever with a noop (:)\nwhile :\ndo\n  sleep 1\ndone\n\n```", "```\n$ touch .myfirsthiddenfile.txt\n```", "```\n#!/bin.bash\n\nLOCKFILE=\"/tmp/mylock\"\n\nfunction setup() { \n  # $$ will provide the process ID\n  TMPFILE=\"${LOCKFILE}.$$\"\n  echo \"$$\" > \"${TMPFILE}\"\n\n  # Now we use hard links for atomic file operations \n  if ln \"${TMPFILE}\" \"${LOCKFILE}\" 2>&- ; then\n      echo \"Created tmp lock\"\n  else\n      echo \"Locked by\" $(<$LOCKFILE)\n      rm \"${TMPFILE}\"\n      exit 1\n  fi\n  trap \"rm ${TMPFILE} ${LOCKFILE}\" SIGINT SIGTERM SIGKILL\n}\n\nsetup\n\necho \"Door was left unlocked\"\n\nexit 0\n```", "```\n$ echo \"1000\" > /tmp/mylock\n$ bash mylock.sh\n$ rm /tmp/mylock\n$ bash mylock.sh\n```", "```\n$ bash mylock.sh\nCreated tmp lock\nDoor was left unlocked\n```", "```\n#!/bin/bash\n\nSUBPID=0\n\nfunction func_timer() {\n  trap \"clean_up\" SIGALRM\n  sleep $1& wait\n  kill -s SIGALRM $$\n}\n\nfunction clean_up() {\n  trap - ALRM\n  kill -s SIGALRM $SUBPID\n  kill $! 2>/dev/null\n}\n\n# Call function for timer & notice we record the job's PID\nfunc_timer $1& SUBPID=$!\n\n# Shift the parameters to ignore $0 and $1\nshift \n\n# Setup the trap for signals SIGALRM and SIGINT\ntrap \"clean_up\" ALRM INT\n\n# Execute the command passed and then wait for a signal\n\"$@\" & wait $!\n\n# kill the running subpid and wait before exit\nkill -ALRM $SUBPID \nwait $SUBPID \nexit 0\n```", "```\n$ bash mytimeout.sh 1 ping -c 10 google.ca\n$ bash mytimeout.sh 10 ping -c 10 google.ca\n```", "```\n$ bash mytimeout.sh 1 ping -c 10 google.ca\nPING google.ca (172.217.13.99) 56(84) bytes of data.\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=1 ttl=57 time=10.0 ms\n\n$ bash mytimeout.sh 10 ping -c 10 google.ca\nPING google.ca (172.217.13.99) 56(84) bytes of data.\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=1 ttl=57 time=11.8 ms\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=2 ttl=57 time=14.5 ms\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=3 ttl=57 time=10.8 ms\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=4 ttl=57 time=13.1 ms\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=5 ttl=57 time=12.7 ms\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=6 ttl=57 time=13.4 ms\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=7 ttl=57 time=9.15 ms\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=8 ttl=57 time=14.0 ms\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=9 ttl=57 time=12.0 ms\n64 bytes from yul02s04-in-f3.1e100.net (172.217.13.99): icmp_seq=10 ttl=57 time=11.2 ms\n\n--- google.ca ping statistics ---\n10 packets transmitted, 10 received, 0% packet loss, time 9015ms\nrtt min/avg/max/mdev = 9.155/12.307/14.520/1.545 ms\n```", "```\n#!/bin/bash\n\nFIFO_FILE=/tmp/WORK_QUEUE_FIFO\nmkfifo \"${FIFO_FILE}\"\n\nNUM_WORKERS=5\nI=0\nwhile [ $I -lt $NUM_WORKERS ]; do\n\n  bash worker.sh \"$I\" &\n  I=$((I+1))\n\ndone \n\nI=0\nwhile [ $I -lt $NUM_WORKERS ]; do\n\n  echo \"$I\" > \"${FIFO_FILE}\"\n  I=$((I+1))\n\ndone \n\nsleep 5 \nrm -rf \"${FIFO_FILE}\"\nexit 0\n```", "```\n#!/bin/bash\n\nFIFO_FILE=/tmp/WORK_QUEUE_FIFO\n\nBUFFER=\"\"\necho \"WORKER started: $1\"\n\nwhile :\ndo\n\nread BUFFER < \"${FIFO_FILE}\"\n\nif [ \"${BUFFER}\" != \"\" ]; then\n  echo \"Worker received: $BUFFER\"\n  exit 1\nfi\n\ndone\n\nexit 0\n```", "```\n$ bash master.sh\n```", "```\n$ bash master.sh \nWORKER started: 0\nWORKER started: 1\nWe got 0\nWe got 1\nWORKER started: 4\nWe got 2\nWORKER started: 2\nWe got 3\nWORKER started: 3\nWe got 4\n\n```", "```\n#!/bin/sh\n### BEGIN INIT INFO\n# Provides: myscript\n# Required-Start: $local_fs\n# Required-Stop: $local_fs\n# Default-Start: 2 3 4 5\n# Default-Stop: 0 1 6\n# Short-Description: Start script or daemons example\n### END INIT INFO\n\nPATH=/sbin:/bin:/usr/sbin:/usr/bin\nDAEMON_NAME=myscript.sh\nDESC=myscript\n\nDAEMON=/usr/sbin/$DAEMON_NAME\n\ncase $1 in\n  start)\n  log_daemon_msg \"Starting $DESC\"\n  $DAEMON_NAME\n  log_end_msg 0\n  ;;\n  stop)\n  log_daemon_msg \"Stopping $DESC\"\n  killall $DAEMON_NAME\n  log_end_msg 0\n  ;;\n  restart|force-reload)\n  $0 stop\n  sleep 1\n  $0 start\n  ;;\n  status)\n  status_of_proc \"$DAEMON\" \"$DESC\" && exit 0 || exit $?\n  ;;\n  *)\n  N=/etc/init.d/$DESC\n  echo \"Usage: $N {start|stop|restart|force-reload|status}\" >&2\n  exit 1\n  ;;\nesac\n\nexit 0\n\n# vim:noet\n```", "```\n#!/bin/bash\n\nfor (( ; ; ))\ndo\n   sleep 1\ndone\n```", "```\n$ sudo cp myscript.sh /usr/bin\n$ sudo chmod a+x /usr/bin/myscript.sh\n```", "```\n$ sudo vi /etc/systemd/system/myscript.service \n[Unit]\nDescription=myscript\n\n[Service]\nExecStart=/usr/bin/myscript.sh\nExecStop=killall myscript.sh\n\n[Install]\nWantedBy=multi-user.target\n```", "```\n$ sudo systemctl enable myscript # disable instead of enable will disable the service\n```", "```\n$ sudo systemctl start myscript\n$ sudo systemctl status myscript\n```", "```\n$ sudo systemctl status myscript\nmyscript.service - myscript\n   Loaded: loaded (/etc/systemd/system/myscript.service; enabled; vendor preset:\n   Active: active (running) since Tue 2017-12-26 14:28:51 EST; 6min ago\n Main PID: 17966 (myscript.sh)\n   CGroup: /system.slice/myscript.service\n           ├─17966 /bin/bash /usr/bin/myscript.sh\n           └─18600 sleep 1\n\nDec 26 14:28:51 moon systemd[1]: Started myscript.\n$ ps aux | grep myscript\nroot 17966 0.0 0.0 20992 3324 ? Ss 14:28 0:00 /bin/bash /usr/bin/myscript.sh\nrbrash 18608 0.0 0.0 14228 1016 pts/20 S+ 14:35 0:00 grep --color=auto myscript\n```"]