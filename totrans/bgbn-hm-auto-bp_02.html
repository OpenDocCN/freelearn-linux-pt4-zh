<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Ultrasonic Parking Assistant"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Ultrasonic Parking Assistant</h1></div></div></div><p>In this chapter, we'll learn how to use the BeagleBone Black to implement a park assistant. We're going to use an ultrasonic sensor to detect the distance between our car and the garage wall, and some LEDs to give a feedback of the car position to the driver in order to avoid collisions.</p><p>We'll see how to set up the<a id="id57" class="indexterm"/> ultrasonic range sensor in two different manners, using different interfaces to get the data in order to resolve a problem in two different ways and obtain two different system configurations.</p><div class="section" title="The basic of functioning"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>The basic of functioning</h1></div></div></div><p>The project is really <a id="id58" class="indexterm"/>simple, even if it needs some electronic skills in order to manage the sensor output. Basically, our BeagleBone Black just needs to periodically poll the ultrasonic sensor output and then turn on the LEDs according to the distance from the wall: as level indicator lower is the distance and more LEDs are turned on.</p></div></div>
<div class="section" title="Setting up the hardware"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Setting up the hardware</h1></div></div></div><p>As just stated, in this project we're<a id="id59" class="indexterm"/> trying to implement two<a id="id60" class="indexterm"/> different setups: the first one uses the analog output of the ultrasonic sensor and implements a circuitry, where all the devices are directly connected with the BeagleBone Black (all peripherals are near the board); on the other hand, the second setup allows us to remotely manage the ultrasonic sensor by using an USB connection, so we can mount the sensor far from the BeagleBone Black board. </p><p>Simply speaking, we can put the sensor in one place while the LEDs are in a different location, maybe in a more visible position, as shown in the following image:</p><div class="mediaobject"><img src="graphics/B00255_02_01.jpg" alt="Setting up the hardware"/></div><p>As you can see, the<a id="id61" class="indexterm"/> dotted arrow, which represents the<a id="id62" class="indexterm"/> driver's point of view, is more clear if the LEDs are in a upper position with respect to the distance sensor that should be located near to the floor to better catch the car frontal.</p><div class="section" title="First setup – all devices near the BeagleBone Black"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>First setup – all devices near the BeagleBone Black</h2></div></div></div><p>In this setup, we're going to use an <a id="id63" class="indexterm"/>ADC pin of our BeagleBone Black to read the analog output of the ultrasonic sensor.</p><div class="section" title="Using the analog output of the distance sensor"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Using the analog output of the distance sensor</h3></div></div></div><p>The following <a id="id64" class="indexterm"/>image shows the ultrasonic sensor that I used on my prototype:</p><div class="mediaobject"><img src="graphics/B00255_02_02.jpg" alt="Using the analog output of the distance sensor"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>The devices can be purchased at the <a id="id65" class="indexterm"/>following link (or by surfing the Internet):</p><p>
<a class="ulink" href="http://www.cosino.io/product/ultrasonic-distance-sensor">http://www.cosino.io/product/ultrasonic-distance-sensor</a>.</p><p>The datasheet of this device is available at <a class="ulink" href="http://www.maxbotix.com/documents/XL-MaxSonar-EZ_Datasheet.pdf">http://www.maxbotix.com/documents/XL-MaxSonar-EZ_Datasheet.pdf</a>.</p></div></div><p>This <a id="id66" class="indexterm"/>device is really interesting due to the fact it has several output channels useful to retrieve the measured distance. In particular, it can give us the measurement via an analog voltage channel and via a serial port; the former communication channel is used in this setup, while the latter will be discussed in the second setup.</p><p>Looking into the datasheet, we discover that the analog output has a resolution of <span class="emphasis"><em>Vcc/1024 per cm</em></span> with a maximum reported range of ~700 mm at 5V and ~600 cm at 3.3V. In this setup, we use Vcc set to 3.3V so the maximum output voltage (<span class="strong"><strong>VoutMAX</strong></span>) will result as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>VoutMAX = 3.3V / 1024 * 600 ≈ 1.93V</em></span></li></ul></div><p>Remembering that the BeagleBone Black's ADCs have a maximum input voltage of 1.8V, we have to find a way to scale down this value. A <span class="emphasis"><em>quick and dirty</em></span> trick is to use a classic voltage divider, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/B00255_02_03.jpg" alt="Using the analog output of the distance sensor"/></div><p>By using <a id="id67" class="indexterm"/>the preceding circuit, we simply divide the sensor output by 2. The voltage at ADC in pin is given by the following formula:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>V<sub>ADCin</sub></em></span><span class="emphasis"><em> = R / (R + R) * Vout = R / 2 R * Vout = 1 / 2 * Vout</em></span></li></ul></div><p>So, the only thing to do is to choose a suitable value for the two resistors (<span class="strong"><strong>R</strong></span>). In my prototype, I set this value to <span class="emphasis"><em>R=6.8KΩ</em></span>, which is a reasonable value to have to acquire a suitable current flooding out from the sensor.</p><p>In this situation, our resolution becomes ~1.61mV/cm, and the connections to be done on the BeagleBone Black are shown in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pin</p>
</th><th style="text-align: left" valign="bottom">
<p>Distance sensor pin (label)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>P9.1 - GND</p>
</td><td style="text-align: left" valign="top">
<p>7</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.3 - 3.3V</p>
</td><td style="text-align: left" valign="top">
<p>6 (Vcc)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.39 - AIN0</p>
</td><td style="text-align: left" valign="top">
<p>3 (AN)</p>
</td></tr></tbody></table></div><p>Now, to enable the BeagleBone Black's ADC lines, we can use the following command as we already did in <a class="link" href="ch01.html" title="Chapter 1. Dangerous Gas Sensors">Chapter 1</a>, <span class="emphasis"><em>Dangerous Gas Sensors</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# echo cape-bone-iio &gt; /sys/devices/bone_capemgr.9/slots</strong></span>
</pre></div><p>If everything works well, we should get the following kernel messages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>part_number 'cape-bone-iio', version 'N/A'</strong></span>
<span class="strong"><strong>slot #7: generic override</strong></span>
<span class="strong"><strong>bone: Using override eeprom data at slot 7</strong></span>
<span class="strong"><strong>slot #7: 'Override Board Name,00A0,Override Manuf,cape-bone-iio'</strong></span>
<span class="strong"><strong>slot #7: Requesting part number/version based 'cape-bone-iio-00A0.dtbo</strong></span>
<span class="strong"><strong>slot #7: Requesting firmware 'cape-bone-iio-00A0.dtbo' for board-name 'Override Board Name', version '00A0'</strong></span>
<span class="strong"><strong>slot #7: dtbo 'cape-bone-iio-00A0.dtbo' loaded; converting to live tree</strong></span>
<span class="strong"><strong>slot #7: #1 overlays</strong></span>
<span class="strong"><strong>bone-iio-helper helper.12: ready</strong></span>
<span class="strong"><strong>slot #7: Applied #1 overlays.</strong></span>
</pre></div><p>Then, the <code class="literal">AIN0</code>, <code class="literal">AIN1</code>, …, <code class="literal">AIN7</code> files should become available, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# find /sys -name '*AIN*'</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN0</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN1</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN2</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN3</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN4</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN5</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN6</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN7</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>These settings can be done by using the <code class="literal">bin/load_firmware.sh</code> script in the book's example code repository, as follows:</p><div class="informalexample"><pre class="programlisting">root@beaglebone:~# ./load_firmware.sh adc</pre></div></div></div><p>Then, we<a id="id68" class="indexterm"/> can read the input data by using the <code class="literal">cat</code> command, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cat /sys/devices/ocp.3/helper.12/AIN0</strong></span>
<span class="strong"><strong>1716</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>As already stated in <a class="link" href="ch01.html" title="Chapter 1. Dangerous Gas Sensors">Chapter 1</a>, <span class="emphasis"><em>Dangerous Gas Sensors</em></span>, the ADC can also be read by using another file's still into the <span class="emphasis"><em>sysfs</em></span> filesystem with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cat /sys/bus/iio/devices/iio:device0/in_voltage0_raw</strong></span>
</pre></div></div></div><p>Now, we have to find a way to convert the read values from the ADC into a distance measured in meters so that we can decide how to manage the LEDs to give the feedback to the driver. Recalling what was just said, the resolution is ~1.61mV/cm, and considering that the resolution of the ADC is 12 bits and the maximum voltage is 3.3V, the <span class="strong"><strong>distance</strong></span> (<span class="strong"><strong>d</strong></span>) in centimeters between the car and the wall is given by the following formula (where the value <span class="emphasis"><em>n</em></span> is the data read from the ADC):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>d = 3.3V * n / 4095 / 0.00161V/cm</em></span></li></ul></div><p>Note that these are estimated values, so it is better to do a calibration of the sensor in order to have the correct reads at least near the lowest value that we wish to measure (in our example, this value is 0.20 m.) To do this, we can put something at 20 cm from the sensor, measure the output value from the ADC, and then calculate a compensating value <span class="emphasis"><em>K</em></span> in order that the following formula will return exactly the value 20:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>d<sub>calib</sub> = K * 3.3V * n/4095 / 0.00161V/cm</em></span></li></ul></div><p>Note that in <a id="id69" class="indexterm"/>case of no calibration, <span class="emphasis"><em>K</em></span> can be set to <code class="literal">1</code> (In this case, we obtain again the original formula, <span class="emphasis"><em>d = d<sub>calib</sub></em></span>.)</p><p>On my prototype, putting an object at 20 cm from the sensor, I get the following value:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cat /sys/devices/ocp.3/helper.12/AIN0</strong></span>
<span class="strong"><strong>29</strong></span>
</pre></div><p>So, <span class="emphasis"><em>K</em></span> should be set to <code class="literal">1.38</code>.</p></div><div class="section" title="Connecting the LEDs in the first setup"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Connecting the LEDs in the first setup</h3></div></div></div><p>The LEDs' connections <a id="id70" class="indexterm"/>are very simple since they can be directly connected with the BeagleBone Black's GPIO pins, as shown the following diagram, which shows the schematic of one single LED connection that can be replicated for each LED:</p><div class="mediaobject"><img src="graphics/B00255_02_04.jpg" alt="Connecting the LEDs in the first setup"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>I used an <span class="emphasis"><em>R = 470Ω</em></span> resistor for the <span class="strong"><strong>LED</strong></span> (<span class="strong"><strong>L</strong></span>). Again, as in the previous chapter, let's remember that the resistor value <span class="strong"><strong>R</strong></span> should be changed according to LED color if we wish to have a lighter effect.</p></div></div><p>We have 5 LEDs, so we need 5 GPIO lines. We can use the following connections:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pin</p>
</th><th style="text-align: left" valign="bottom">
<p>LED color</p>
</th><th style="text-align: left" valign="bottom">
<p>Activated when distance is under</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>P8.45-GPIO44</p>
</td><td style="text-align: left" valign="top">
<p>White</p>
</td><td style="text-align: left" valign="top">
<p>5.00 m</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P8.46-GPIO67</p>
</td><td style="text-align: left" valign="top">
<p>Yellow</p>
</td><td style="text-align: left" valign="top">
<p>2.00 m</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P8.7-GPIO69</p>
</td><td style="text-align: left" valign="top">
<p>Red</p>
</td><td style="text-align: left" valign="top">
<p>1.00 m</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P8.8-GPIO68</p>
</td><td style="text-align: left" valign="top">
<p>Red</p>
</td><td style="text-align: left" valign="top">
<p>0.50 m</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P8.9-GPIO45</p>
</td><td style="text-align: left" valign="top">
<p>Red</p>
</td><td style="text-align: left" valign="top">
<p>0.20 m</p>
</td></tr></tbody></table></div><p>The white LED is used<a id="id71" class="indexterm"/> to signal to the user that they are driving at less than 5 m from the wall; the yellow is used to signal that they are driving at less than 2 m from the wall; and the red LED is used to signal that the garage wall is approaching at less than 1 m, 0.50 m, and 0.20 m.</p><p>To test the LEDs' connection, we can use the same commands used in <a class="link" href="ch01.html" title="Chapter 1. Dangerous Gas Sensors">Chapter 1</a>, <span class="emphasis"><em>Dangerous Gas Sensors</em></span>. For instance, we can test the LED on GPIO68 by using the following commands to set up the GPIO first and then to turn it off and on:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# echo 68 &gt; /sys/class/gpio/export</strong></span>
<span class="strong"><strong>root@beaglebone:~# echo out &gt; /sys/class/gpio/gpio68/direction</strong></span>
<span class="strong"><strong>root@beaglebone:~# echo 0 &gt; /sys/class/gpio/gpio68/value  </strong></span>
<span class="strong"><strong>root@beaglebone:~# echo 1 &gt; /sys/class/gpio/gpio68/value</strong></span>
</pre></div></div></div><div class="section" title="Second setup – the distance sensor is remotized"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Second setup – the distance sensor is remotized</h2></div></div></div><p>In this setup, we're going to use<a id="id72" class="indexterm"/> BeagleBone Black's serial port to read the measured distance from the ultrasonic sensor.</p><div class="section" title="Using the serial output of the distance sensor"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Using the serial output of the distance sensor</h3></div></div></div><p>This time, we are interested at the <a id="id73" class="indexterm"/>datasheet section where the serial output capability of our sensor is described. In particular, we read:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>The Pin 5 output delivers asynchronous serial with an RS232 format, except voltages are 0-Vcc. The output is an ASCII capital "R", followed by three ASCII character digits representing the range in centimeters up to a maximum of 765, followed by a carriage return (ASCII 13). The baud rate is 9600, 8 bits, no parity, with one stop bit. Although the voltage of 0-Vcc is outside the RS232 standard, most RS232 devices have sufficient margin to read 0-Vcc serial data. If standard voltage level RS232 is desired, invert, and connect an RS232 converter.</em></span></p></blockquote></div><p>This is very interesting for two main reasons:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <a id="id74" class="indexterm"/>measurement is very precise due to the fact that the sensor gives it to us in a digital format and not by using an analog format (so the measurement is more immune to disturbs.)</li><li class="listitem">The information can be sent over a <span class="strong"><strong>RS-232</strong></span> line (even if with some electronic fixes that will be presented soon), which will allow us to have the system core in a different location with respect to the sensor, providing a better usability of the whole system.</li></ol></div><p>So, by using this new setup, the LEDs are still mounted on the BeagleBone Black, while the distance sensor is connected remotely through a RS-232 line. However, we cannot use a classic RS-232 line due to the fact that we still have to supply power to the sensor, and no power can be transferred via a standard RS-232 cable!</p><p>The solution is to use a RS-232 connection over a USB cable. In fact, by using a standard USB cable, we are able to send/receive RS-232 data with the needed power supply.</p><p>However, some issues are still present:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The USB power voltage is 5V, so we need a <span class="emphasis"><em>USB-to-serial</em></span> converter that can manage such voltage level by default, or, is at least 5V tolerant.</li><li class="listitem">Reading carefully the preceding snippet of the datasheet, we discover that the output level is TLL and inverted! So, before sending the TX signal to the <span class="emphasis"><em>USB-to-serial</em></span> converter (to the RX pin), we must electrically invert it. (Okay don't panic! I'm going to explain this carefully.)</li></ol></div><p>The solution for the first problem is to use the following <span class="emphasis"><em>USB-to-serial</em></span> converter, which not only works at 3.3V, but also is 5V tolerant.</p><div class="mediaobject"><img src="graphics/B00255_02_05.jpg" alt="Using the serial output of the distance sensor"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>The devices can be purchased at the following link (or by surfing the Internet):</p><p>
<a class="ulink" href="http://www.cosino.io/product/usb-to-serial-converter">http://www.cosino.io/product/usb-to-serial-converter</a>.</p><p>The datasheet of<a id="id75" class="indexterm"/> this device is available at <a class="ulink" href="https://www.silabs.com/Support%20Documents/TechnicalDocs/cp2104.pdf">https://www.silabs.com/Support%20Documents/TechnicalDocs/cp2104.pdf</a>.</p></div></div><p>In order to <a id="id76" class="indexterm"/>address the second problem, we can use the following circuitry to invert the TTL levels of the TX signal of the sensor:</p><div class="mediaobject"><img src="graphics/B00255_02_06.jpg" alt="Using the serial output of the distance sensor"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>I used the resistors values <span class="strong"><strong>R1</strong></span>=2,2KΩ, <span class="strong"><strong>R2</strong></span>=10KΩ, and a <span class="strong"><strong>BC546 transistor</strong></span> (<span class="strong"><strong>T</strong></span>). The <span class="strong"><strong>Vin</strong></span> is connected with the sensor's pin 5 (TX), while the <span class="strong"><strong>Vout</strong></span> is connected with the <span class="strong"><strong>RX</strong></span> pin of a <span class="strong"><strong>RS232</strong></span> converter.</p></div></div><p>The functioning is quite simple—it's a logical NOT port with a voltage level translator. When a logical 0 (a voltage near 0V) is applied to <span class="strong"><strong>Vin</strong></span>, the <span class="strong"><strong>transistor</strong></span> (<span class="strong"><strong>T</strong></span>) doesn't work, so no current can pass through it and there is no voltage loss on resistor <span class="strong"><strong>R2</strong></span> and the <span class="strong"><strong>Vout</strong></span> is 5V (a logical 1). On the other hand, when a logical 1 (a voltage near 3.3V) is applied to <span class="strong"><strong>Vin</strong></span>, the <span class="strong"><strong>transistor</strong></span> (<span class="strong"><strong>T</strong></span>) is turned on and a current can now flow through it, and the <span class="strong"><strong>Vout</strong></span> drops down to a voltage near 0V (a logical 0). The following table shows the circuitry functioning in a clear manner, which you can see that it works exactly as we expected!</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Vin (V)/logical</p>
</th><th style="text-align: left" valign="bottom">
<p>Vout (V)/logical</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>0/0</p>
</td><td style="text-align: left" valign="top">
<p>5/1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>3.3/1</p>
</td><td style="text-align: left" valign="top">
<p>0/0</p>
</td></tr></tbody></table></div><p>In this <a id="id77" class="indexterm"/>situation, the connections to be done on the BeagleBone Black are quite simple. In fact, we have to connect a normal USB cable to the <span class="emphasis"><em>USB-to-serial</em></span> converter and then connect it to the distance sensor, as shown in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>USB-to-serial Pin</p>
</th><th style="text-align: left" valign="bottom">
<p>Distance sensor pin (label)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>GND</p>
</td><td style="text-align: left" valign="top">
<p>7</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>VBUS</p>
</td><td style="text-align: left" valign="top">
<p>6 (Vcc)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RX</p>
</td><td style="text-align: left" valign="top">
<p>5 (/TX)</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>Note that in the table, I used the <span class="emphasis"><em>/TX</em></span> electronic notation for the ultrasonic sensor's TX pin (in <span class="strong"><strong>C</strong></span>, we can write <span class="emphasis"><em>!TX</em></span>), since, as already stated, its output signal must be inverted, so, in reality, the TX pin of the distance sensor must be connected with the <span class="strong"><strong>Vin</strong></span> pin of the TTL inverter, while the <span class="strong"><strong>Vout</strong></span> is the effective signal <span class="emphasis"><em>/TX</em></span> that must be connected to the USB-to-serial RX pin!</p></div></div><p>If we decide to use this setup for the distance sensor, the job, from the software point of view, is simpler, since no calibration is needed at all due to the fact that the sensor will return to us the distance in a digital format, that is, without any possible errors due to the analog to digital conversion or voltage scaling, as seen in the preceding section. In fact, we can get the distance simply by reading it from the serial port over the USB connection; so, if everything works well, once we connect the USB cable we should see the following kernel messages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>hub 1-0:1.0: state 7 ports 1 chg 0000 evt 0002</strong></span>
<span class="strong"><strong>usb 1-1: reset full-speed USB device number 2 using musb-hdrc</strong></span>
<span class="strong"><strong>hub 1-0:1.0: state 7 ports 1 chg 0000 evt 0002</strong></span>
<span class="strong"><strong>usb 1-1: cp210x converter now attached to ttyUSB0</strong></span>
</pre></div><p>The <code class="literal">/dev/ttyUSB0</code> device is now available:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/chapter_02# ls -l /dev/ttyUSB0</strong></span>
<span class="strong"><strong>crw-rw---T 1 root dialout 188, 0 Apr 23 20:28 /dev/ttyUSB0</strong></span>
</pre></div><p>Now, to read the measurements, we have to configure the serial port as requested by the datasheet with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# stty -F /dev/ttyUSB0 9600</strong></span>
</pre></div><p>Then, the data can be displayed in real-time with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cat /dev/ttyUSB0</strong></span>
<span class="strong"><strong>126</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>You can stop reading by using the <span class="emphasis"><em>CTRL</em></span> + <span class="emphasis"><em>C</em></span> keys.</p></div></div></div><div class="section" title="Connecting the LEDs in the second setup"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Connecting the LEDs in the second setup</h3></div></div></div><p>In this <a id="id78" class="indexterm"/>second setup, there is nothing special to say regarding LEDs due to the fact the connections are pretty the same here as in the first setup.</p><p>Remember that the LEDs are not related to the USB connection, which is used only to remotize the distance sensor!</p></div></div><div class="section" title="The final picture"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>The final picture</h2></div></div></div><p>The following <a id="id79" class="indexterm"/>screenshot shows the prototype that I realized to implement this project and to test the software.</p><p>Note that I implemented both setups: on the left-half of the breadboard, there is the ultrasonic sensor with related circuitry (that is, the part that can be remotized); on the right-half, there are the circuitry for the LEDs; while in the upper center, there is the inverted voltage translator; and in the lower center, there are the two resistors that implement the voltage divider.</p><p>Note also the USB-to-serial converter in the center of the screenshot, where I connected the USB cable that is put into the USB host port of the BeagleBone Black:</p><div class="mediaobject"><img src="graphics/B00255_02_07.jpg" alt="The final picture"/></div><p>I also used an<a id="id80" class="indexterm"/> external power supplier due to the fact that the external circuitry and the BeagleBone Black may need more power than what the USB port of your PC can supply!</p></div></div>
<div class="section" title="Setting up the software"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Setting up the software</h1></div></div></div><p>In this project, the software <a id="id81" class="indexterm"/>is really simple, since we just need a <a id="id82" class="indexterm"/>procedure that periodically reads the distance and then turn on and off the LEDs accordingly; however, some issues must be pointed out, especially about how to manage the LEDs and the differences between the two setups of the ultrasonic sensor.</p><div class="section" title="Managing the LEDs"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Managing the LEDs</h2></div></div></div><p>Despite of what was <a id="id83" class="indexterm"/>presented in the previous chapter about the GPIO's management, it's important to point out that the Linux kernel has several kinds of devices, each one dedicated to a well-defined usage, and one of these special devices are the led devices, which is a particular type of devices that can be used to manage an LED with different triggers. A <span class="strong"><strong>trigger</strong></span> <a id="id84" class="indexterm"/>is a sort of <span class="emphasis"><em>manager</em></span> of the LED that can be programmed to work in a specific manner. Ok, it's better doing an example instead of trying to explain it!</p><p>First of all, we have to define the led devices by using a dedicated device tree as reported in the <code class="literal">chapter_02/BB-LEDS-C2-00A0.dts</code> file in the book's example code repository. The following is a snippet of this file with the relevant code:</p><div class="informalexample"><pre class="programlisting">   fragment@1 {
      target = &lt;&amp;ocp&gt;;

      __overlay__ {
         c2_leds {
            compatible      = "gpio-leds";
            pinctrl-names   = "default";
            pinctrl-0       = &lt;&amp;bb_led_pins&gt;;

            white_led {
               label   = "c2:white";
               gpios   = &lt;&amp;gpio3 6 0&gt;;
               linux,default-trigger = "none";
               default-state = "on";
            };

            yellow_led {
               label   = "c2:yellow";
               gpios   = &lt;&amp;gpio3 7 0&gt;;
               linux,default-trigger = "none";
               default-state = "on";
            };

            red_far_led {
               label   = "c2:red_far";
               gpios   = &lt;&amp;gpio3 2 0&gt;;
               linux,default-trigger = "none";
               default-state = "on";
            };

            red_mid_led {
               label   = "c2:red_mid";
               gpios   = &lt;&amp;gpio3 3 0&gt;;
               linux,default-trigger = "none";
               default-state = "on";
            };

            red_near__led {
               label   = "c2:red_near";
               gpios   = &lt;&amp;gpio3 5 0&gt;;
               linux,default-trigger = "none";
               default-state = "on";
            };
         };
      };
   };</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>Further information regarding how to define Linux's <span class="strong"><strong>LED devices</strong></span>
<a id="id85" class="indexterm"/> can be found in Linux's source tree in the <code class="literal">linux/Documentation/devicetree/bindings/leds/leds-gpio.txt</code> file, or online at <a class="ulink" href="https://www.kernel.org/doc/Documentation/devicetree/bindings/leds/leds-gpio.txt">https://www.kernel.org/doc/Documentation/devicetree/bindings/leds/leds-gpio.txt</a>.</p></div></div><p>As you can see, each <a id="id86" class="indexterm"/>GPIO is enabled and defined into the kernel as a LED device by using the <code class="literal">gpio-leds</code> driver. The code is quite self-explanatory, and it's easy to see that each GPIO definition has a predefined trigger (that is, the default trigger <code class="literal">none</code>) and the predefined status set to <code class="literal">on</code>.</p><p>To enable this setting, we have to compile it into its binary form by using the <code class="literal">dtc</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# dtc -O dtb -o /lib/firmware/BB-LEDS-C2-00A0.dtbo -b 0 -@ BB-LEDS-C2-00A0.dts</strong></span>
</pre></div><p>And then, we can load it into the kernel by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# echo BB-LEDS-C2 &gt; /sys/devices/bone_capemgr.9/slots</strong></span>
</pre></div><p>If everything works well, we should see the following kernel activities:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>part_number 'BB-LEDS-C2', version 'N/A'</strong></span>
<span class="strong"><strong>slot #7: generic override</strong></span>
<span class="strong"><strong>bone: Using override eeprom data at slot 7</strong></span>
<span class="strong"><strong>slot #7: 'Override Board Name,00A0,Override Manuf,BB-LEDS-C2'</strong></span>
<span class="strong"><strong>slot #7: Requesting part number/version based 'BB-LEDS-C2-00A0.dtbo</strong></span>
<span class="strong"><strong>slot #7: Requesting firmware 'BB-LEDS-C2-00A0.dtbo' for board-name 'Override Board Name', version '00A0'</strong></span>
<span class="strong"><strong>slot #7: dtbo 'BB-LEDS-C2-00A0.dtbo' loaded; converting to live tree</strong></span>
<span class="strong"><strong>slot #7: #2 overlays</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>slot #7: Applied #2 overlays.</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>If we get the following error then we have to disable the <span class="strong"><strong>HDMI</strong></span> support:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>-bash: echo: write error: File exists</strong></span>
</pre></div><p>This can be done by editing the uboot settings into the <code class="literal">/boot/uboot/uEnv.txt</code> file, and then enabling the following line by uncommenting it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>optargs=capemgr.disable_partno=BB-BONELT-HDMI,BB-BONELT-HDMIN</strong></span>
</pre></div><p>Note that on some BeagleBone Black versions, you may find the <code class="literal">uEnv.txt</code> file under the directory <code class="literal">/boot</code> instead, and the <code class="literal">uboot</code> settings to modify are as follows:</p><div class="informalexample"><pre class="programlisting">cape_disable=capemgr.disable_partno=BB-BONELT-HDMI,BB-BONELT-HDMIN</pre></div><p>Then, we only have to reboot the system. Now, if everything was done correctly, we should be able to execute the preceding command without errors.</p></div></div><p>Note that all the <a id="id87" class="indexterm"/>LEDs are now turned on. Now, to manage these new LED devices, we can use the sysfs entries under the following directories:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ls -d /sys/class/leds/c2*</strong></span>
<span class="strong"><strong>/sys/class/leds/c2:red_far   /sys/class/leds/c2:white</strong></span>
<span class="strong"><strong>/sys/class/leds/c2:red_mid   /sys/class/leds/c2:yellow</strong></span>
<span class="strong"><strong>/sys/class/leds/c2:red_near</strong></span>
</pre></div><p>As you can see, all the names we used in the DTS file are present, and we also find the following files in each directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ls /sys/class/leds/c2\:white</strong></span>
<span class="strong"><strong>brightness  device  max_brightness  power  subsystem  trigger  uevent</strong></span>
</pre></div><p>The relevant files are <code class="literal">trigger</code>, <code class="literal">brightness</code>, and  <code class="literal">max_brightness</code>. The <code class="literal">trigger</code> file is used to discover the current trigger, and, in case, to change it. In fact, by reading the file, we see the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cat /sys/class/leds/c2\:white/trigger</strong></span>
<span class="strong"><strong>[none] nand-disk mmc0 mmc1 timer oneshot heartbeat backlight gpio cpu0 default-on transient</strong></span>
</pre></div><p>As we expected, the current trigger is <code class="literal">none</code> (the one between the square brackets), and we can change it simply by writing the new name into the same file (see the preceding example).</p><p>The <code class="literal">brightness</code> and <code class="literal">max_brightness</code> files are specific of the current trigger and can be used to set the brightness of the LED from the <code class="literal">0</code> value to the maximum value stored in the <code class="literal">max_brightness</code> file. Just to test it, we can read the current values into these files to verify that the<a id="id88" class="indexterm"/> current status is at the maximum brightness:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cat /sys/class/leds/c2\:white/max_brightness</strong></span>
<span class="strong"><strong>255</strong></span>
<span class="strong"><strong>root@beaglebone:~# cat /sys/class/leds/c2\:white/brightness</strong></span>
<span class="strong"><strong>255</strong></span>
</pre></div><p>To turn off the LED, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/# echo 0 &gt; /sys/class/leds/c2\:white/brightness</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>Note that our LEDs are two functional values only, that is, <code class="literal">0</code> and <code class="literal">255</code>, due to the fact that the LEDs we are using have only two valid states.</p></div></div><p>However, having a flashing capability in our project for when the car is near a specific distance from the wall in such a way that gives a better warning about the increasing <span class="emphasis"><em>danger</em></span> could be very interesting. In particular, we can do this in such a way that when the red LEDs must be turned on, according to what was stated in the <span class="emphasis"><em>Connecting the LEDs in the first setup</em></span> section, in this chapter, the frequency of the flash will keep increasing as the distance reduces, they will stop flashing and remain turned on when the distance is less than 0.10 m.</p><p>To flash an LED with the desired frequency, we can use the <code class="literal">timer</code> trigger. In order to show how it works, let's try to enable it on the LED named <code class="literal">red_far</code> by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# echo timer &gt; /sys/class/leds/c2\:red_far/trigger</strong></span>
</pre></div><p>After executing this command, the LED should start flashing; then looking again into the directory, we see that new files are now available:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ls /sys/class/leds/c2\:red_far</strong></span>
<span class="strong"><strong>brightness  delay_on  max_brightness  subsystem  uevent</strong></span>
<span class="strong"><strong>delay_off   device    power        trigger</strong></span>
</pre></div><p>The new interesting files are <code class="literal">delay_on</code> and <code class="literal">delay_off</code>, and they can be used to define instead how <a id="id89" class="indexterm"/>long the LED must be turned on and how long it must be turned off. It's quite obvious that the LED's blinking frequencies (F) can now be set with the following formula:</p><p>
<span class="emphasis"><em>F = 1 / T</em></span>, where <span class="emphasis"><em>T = T<sub>delay_on</sub> + T<sub>delay_off</sub></em></span>
</p><p>So, for instance, if we wish that the LED will flash with a frequency of 10Hz, we can use the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# echo 50 &gt; /sys/class/leds/c2\:red_far/delay_on  </strong></span>
<span class="strong"><strong>root@beaglebone:~# echo 50 &gt; /sys/class/leds/c2\:red_far/delay_off</strong></span>
</pre></div><p>The value 50 means: 50ms at <span class="emphasis"><em>on</em></span> state and 50ms at <span class="emphasis"><em>off</em></span> state. So, we have <span class="emphasis"><em>T<sub>delay_on</sub>=50ms</em></span> and <span class="emphasis"><em>T<sub>delay_off</sub></em></span>
<span class="emphasis"><em>=50ms</em></span>, so <span class="emphasis"><em>T=100ms</em></span>, and then <span class="emphasis"><em>F=10Hz</em></span>.</p><p>Considering that the human eye is still sensitive at more or less 25Hz at maximum, and that the minimum allowed frequency is 1Hz, the possible values to be written into each of the preceding two files are from 500 (ms) for a blinking frequency of 1Hz to 20 (ms) for a blinking frequency of 25Hz.</p><p>A possible implementation of a controlling program for the LEDs is in the <code class="literal">chapter_02/led_set.sh</code> file in the book's example code repository. The following code is a snippet of the relevant code:</p><div class="informalexample"><pre class="programlisting">case $mode in
-1)
   # Turn on the LED
   echo none &gt; /sys/class/leds/c2\:$name/trigger
   echo 255 &gt; /sys/class/leds/c2\:$name/brightness
   ;;

0)
   # Turn off the LED
   echo none &gt; /sys/class/leds/c2\:$name/trigger
   echo 0 &gt; /sys/class/leds/c2\:$name/brightness
   ;;

*)
   # Flash the LED
   t=$((1000 / $mode / 2))

   echo timer &gt; /sys/class/leds/c2\:$name/trigger
   echo $t &gt; /sys/class/leds/c2\:$name/delay_on
   echo $t &gt; /sys/class/leds/c2\:$name/delay_off
   ;;
esac</pre></div><p>Here, the code turns on the LED addressed by the <code class="literal">name</code> variable in case the <code class="literal">mode</code> variable is set to <code class="literal">-1</code>, while it turns it off the same LED when <code class="literal">mode</code> is set to <code class="literal">0</code>. Also, the code will enable the <code class="literal">timer</code> trigger with proper settings in case the <code class="literal">mode</code> variable is between the values <code class="literal">1</code> and <code class="literal">25</code>(Hz).</p><p>The following<a id="id90" class="indexterm"/> is a sample usage:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./led_set.sh red_far -1</strong></span>
<span class="strong"><strong>root@beaglebone:~# ./led_set.sh red_far 0</strong></span>
<span class="strong"><strong>root@beaglebone:~# ./led_set.sh red_far 10</strong></span>
</pre></div></div></div>
<div class="section" title="The distance monitor"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>The distance monitor</h1></div></div></div><p>Now it's time to see how our <a id="id91" class="indexterm"/>park assistant can work in practice. A possible implementation of the code is reported in the <code class="literal">chapter_02/distance_mon.sh</code> script in the book's example code repository. The following code snippet shows the main code:</p><div class="informalexample"><pre class="programlisting"># Ok, do the job
while sleep .1 ; do
   # Read the current distance from the sensor
   d=$($d_fun)
   dbg "d=$d"

   # Manage the LEDs
   leds_man $d
done</pre></div><p>The functioning is simple—the code periodically reads the distance from the sensor by using the function pointed by the <code class="literal">d_fun</code> variable, and then turns the LEDs on and off, according to the value of the distance <code class="literal">d</code> (in cm) by using the <code class="literal">leds_man</code> function.</p><p>The <code class="literal">d_fun</code> variable holds the name of the function that should read the distance by using the ADC, that is, <code class="literal">read_adc</code>, or the name of the function that uses the serial port, that is, <code class="literal">read_tty</code>. The following are the two functions:</p><div class="informalexample"><pre class="programlisting">function read_adc () {
   n=$(cat $ADC_DEV)

   d=$(bc -l &lt;&lt;&lt; "$k * 3.3 * $n/4095 / 0.00161")
   printf "%.0f\n" $d
}

function read_tty () {
   while read d &lt; $TTY_DEV ; do
      [[ "$d" =~ R[0-9]{2,3} ]] &amp;&amp; break
   done

   # Drop the "R" character
   d=${d#R}

   # Drop the leading "0"
   echo ${d#0}
}</pre></div><p>Note that the <code class="literal">read_adc</code> file<a id="id92" class="indexterm"/> uses the <code class="literal">bc</code> program to calculate the translation formula discussed before, while the <code class="literal">read_tty</code> uses the Bash's <code class="literal">read</code> and <code class="literal">while</code> commands to read a complete data line (which is in the form <code class="literal">Rxxx\r</code>, as reported in the datasheet.)</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>The <code class="literal">bc</code> command may be not installed by default into the BeagleBone Black's distribution, so you can install it by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# aptitude install bc</strong></span>
</pre></div></div></div><p>The <code class="literal">leds_man</code> function is as follows:</p><div class="informalexample"><pre class="programlisting">function leds_man () {
   d=$1

   # Calculate the blinking frequency with the following
   # fixed values:
   #    f=1Hz  if d=100cm
   #    f=25Hz if d=25cm
   f=$((25 - 21 * ( d - 25 ) / 75))
   [ $f -gt 25 ] &amp;&amp; f=25
   [ $f -lt 1 ] &amp;&amp; f=1

   if [ "$d" -gt 500 ] ; then
      ./led_set.sh white     0
      ./led_set.sh yellow    0
      ./led_set.sh red_far   0
      ./led_set.sh red_mid   0
      ./led_set.sh red_near  0

      return
   fi

   if [ "$d" -le 500 -a "$d" -gt 200 ] ; then
      ./led_set.sh white    -1
      ./led_set.sh yellow    0
      ./led_set.sh red_far   0
      ./led_set.sh red_mid   0
      ./led_set.sh red_near  0

      return
   fi

   if [ "$d" -le 200 -a "$d" -gt 100 ] ; then
      ./led_set.sh white    -1
      ./led_set.sh yellow   -1
      ./led_set.sh red_far   0
      ./led_set.sh red_mid   0
      ./led_set.sh red_near  0

      return
   fi

   if [ "$d" -le 100 -a "$d" -gt 50 ] ; then
      ./led_set.sh white    -1
      ./led_set.sh yellow   -1
      ./led_set.sh red_far  $f
      ./led_set.sh red_mid   0
      ./led_set.sh red_near  0

      return
   fi

   if [ "$d" -le 50 -a "$d" -gt 20 ] ; then
      ./led_set.sh white    -1
      ./led_set.sh yellow   -1
      ./led_set.sh red_far  -1
      ./led_set.sh red_mid  $f
      ./led_set.sh red_near  0

      return
   fi

   # if -le 20
   ./led_set.sh white    -1
   ./led_set.sh yellow   -1
   ./led_set.sh red_far  -1
   ./led_set.sh red_mid  -1
   ./led_set.sh red_near -1
}</pre></div><p>The function first calculates<a id="id93" class="indexterm"/> the blinking frequency in order to respect what was stated in the preceding sections, and then it uses a big case to decide which LEDs configuration must be used to notify the driver.</p></div>
<div class="section" title="Final test"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Final test</h1></div></div></div><p>To test the prototype, we must first select <a id="id94" class="indexterm"/>one setup and perform the needed connections, as stated before. Then we have to turn on the board.</p><p>After the login, we must setup the system by using the commands discussed before, or simply by using the <code class="literal">chapter_02/SYSINIT.sh</code> command in the book's example code repository. Then, we must execute the <code class="literal">distance_mon.sh</code> command accordingly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Note that looking into the <code class="literal">SYSINIT.sh</code> file, you can read:</p><div class="informalexample"><pre class="programlisting"># Uncomment the following in case of buggy kernel in USB host management
# cat /dev/bus/usb/001/001 &gt; /dev/null ; sleep 1</pre></div><p>This is if after plugging in the USB cable, you get an error in recognizing the <code class="literal">/dev/ttyUSB0</code> device.</p></div></div><p>To test my prototype using the first setup, I used the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./distance_mon.sh -d -k 1.38 adc</strong></span>
<span class="strong"><strong>distance_mon.sh: d_fun=read_adc k=1.38</strong></span>
<span class="strong"><strong>distance_mon.sh: d=176</strong></span>
<span class="strong"><strong>distance_mon.sh: d=175</strong></span>
<span class="strong"><strong>distance_mon.sh: d=175</strong></span>
<span class="strong"><strong>distance_mon.sh: d=175</strong></span>
<span class="strong"><strong>distance_mon.sh: d=175</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>On the other hand, to test the second one, I used this other command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./distance_mon.sh -d serial</strong></span>
<span class="strong"><strong>distance_mon.sh: d_fun=read_tty k=1</strong></span>
<span class="strong"><strong>distance_mon.sh: d=151</strong></span>
<span class="strong"><strong>distance_mon.sh: d=152</strong></span>
<span class="strong"><strong>distance_mon.sh: d=151</strong></span>
<span class="strong"><strong>distance_mon.sh: d=152</strong></span>
<span class="strong"><strong>distance_mon.sh: d=152</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>You can stop the <a id="id95" class="indexterm"/>program by using the <span class="emphasis"><em>CTRL</em></span> + <span class="emphasis"><em>C</em></span> keys.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, we discovered how to manage an ultrasonic sensor in two different manners, by using an ADC and by a serial connection over a USB cable, in order to have two different setups of the same device: one with all peripherals on the BeagleBone Black and one where a sensor is remotized by using a USB connection.</p><p>Also, we learned how to manage Linux's LED devices that allow us to have different usage of a simple GPIO line by kernel features.</p><p>In the next chapter, we'll see how to realize an aquarium monitor in which we'll be able to record all the environment data, and then we'll see how to control the life of our be loved fishes from a web panel.</p></div></body></html>