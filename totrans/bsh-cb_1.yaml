- en: Crash Course in Bash
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash 快速入门
- en: The primary purpose of this chapter is to give you enough knowledge about the
    Linux shell/Bash to get you up and running, as that the remainder of the book
    will just fall into place.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目的是让你掌握足够的 Linux shell/Bash 知识，以便你能够顺利启动并运行，之后的内容就会变得简单易懂。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with Bash and CLI fundamentals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始学习 Bash 和 CLI 基础
- en: Creating and using basic variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用基本变量
- en: Hidden Bash variables and reserved words
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏的 Bash 变量和保留字
- en: Conditional logic using if, else, and elseif
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 if、else 和 elseif 的条件逻辑
- en: Case/switch statements and loop constructs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: case/switch 语句和循环结构
- en: Using functions and parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数和参数
- en: Including source files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括源文件
- en: Parsing program input parameters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析程序输入参数
- en: Standard in, standard out, and standard error
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输入、标准输出和标准错误
- en: Linking commands using pipes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道链接命令
- en: Finding more information about the commands used within Bash
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找更多关于 Bash 中使用的命令的信息
- en: This chapter will set you up with the basic knowledge needed to complete the
    recipes in the remaining chapters of the book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为你提供完成本书其余章节食谱所需的基础知识。
- en: Getting started with Bash and CLI fundamentals
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习 Bash 和 CLI 基础
- en: 'First, we need to open a Linux terminal or shell. Depending on your flavor
    (distribution) of Linux, this will be done in one of several ways, but in Ubuntu,
    the easiest way is to navigate to the Applications menu and find one labeled terminal. The
    terminal or shell is the place where commands are entered by a user and executed
    in the same shell. Simply put, results (if any) are displayed, and the terminal
    will remain open, waiting for new commands to be entered. Once a shell has been
    opened, a *prompt* will appear, looking similar to the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要打开一个 Linux 终端或 shell。根据你所使用的 Linux 发行版，这可以通过多种方式完成，但在 Ubuntu 中，最简单的方法是导航到应用程序菜单并找到标有“终端”的程序。终端或
    shell 是用户输入命令并在同一 shell 中执行命令的地方。简而言之，结果（如果有的话）会显示出来，终端将保持打开状态，等待输入新命令。一旦 shell
    被打开，一个*提示符*将会出现，类似于以下内容：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The prompt will be in the format of your `username@YourComputersHostName` followed
    by a delimiter. Throughout this cookbook, you will see commands with the user
    `rbrash`; this is short for the author's name (Ron Brash) and in you case, it
    will match your username.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 提示符的格式为 `username@YourComputersHostName`，后面跟着一个分隔符。在本书的整本食谱中，你会看到命令使用用户 `rbrash`；这是作者名字（Ron
    Brash）的缩写，在你的情况下，它将与你的用户名相匹配。
- en: 'It may also look similar to:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可能看起来类似于：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `$` refers to a regular user and the `#` refers to root. In the Linux and
    Unix worlds, root refers to the *root user*, which is similar to the Windows Administrator
    user. It can be used to perform any manner of tasks, so caution should be used
    when using a user with root privileges. For example, the root user can access
    all files on the OS, and can also be used to delete any or all critical files
    used by the OS, which could render the system unusable or broken.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` 表示普通用户，而 `#` 表示 root 用户。在 Linux 和 Unix 系统中，root 指的是*root 用户*，类似于 Windows
    中的管理员账户。它可以执行任何任务，因此在使用具有 root 权限的用户时应该小心。例如，root 用户可以访问操作系统中的所有文件，并且还可以删除操作系统使用的任何或所有关键文件，这可能会导致系统无法使用或崩溃。'
- en: When a terminal or shell is run, the Bash shell is executed with a set of parameters
    and commands specific to the user's bash profile. This profile is often called
    the `.bashrc` and can be used to contain command aliases, shortcuts, environment
    variables, and other user enhancements, such as prompt colors. It is located at `~/.bashrc or ~/.bash_profile`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当终端或 shell 运行时，Bash shell 会以一组特定于用户 bash 配置文件的参数和命令执行。这个配置文件通常称为 `.bashrc`，它可以用于包含命令别名、快捷方式、环境变量和其他用户增强功能，例如提示符颜色。它位于
    `~/.bashrc 或 ~/.bash_profile`。
- en: '`~ or ~/` is a shortcut for your user’s home directory. It is synonymous with
    `/home/yourUserName/` , and for root, it is `/root`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`~ 或 ~/` 是用户主目录的快捷方式。它与 `/home/yourUserName/` 等效，对于 root 用户来说，它是 `/root`。'
- en: 'Your user''s Bash shell also contains a history of all of the commands run
    by the user (located in `~/.bash_history`), which can be accessed using the `history` command,
    shown as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的 Bash shell 还会包含一个记录用户执行的所有命令的历史记录（位于 `~/.bash_history`），可以通过 `history` 命令查看，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For example, your first command might be to use `ls` to determine the contents
    of the directory. The command `cd` is used to change the directory, to one directory
    in above the parent directory. The `pwd` command is used to return the complete
    path to the working directory (for example, where the terminal is currently navigated
    to).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的第一个命令可能是使用`ls`来确定目录的内容。命令`cd`用于切换到父目录上方的某个目录。`pwd`命令用于返回当前工作目录的完整路径（例如，终端当前所在的目录）。
- en: 'Another command you may execute on the shell might be the `whoami `command,
    which will return the user currently logged in to the shell:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会在shell上执行另一个命令`whoami`，该命令将返回当前登录到shell的用户：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the concept of entering commands, we can put those (or any) commands
    into a *shell script*. In its most simplistic representation, a shell script looks
    like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输入命令的概念，我们可以将这些（或任何）命令放入*shell脚本*中。以最简化的方式表示，shell脚本看起来如下：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first line contains the path to the interpreter and tells the shell which
    interpreter to use when interpreting this script. The first line will *always*
    contain the shebang (`#!`) and the prefix to the path appended without a space:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含解释器的路径，并告诉shell在解释此脚本时使用哪个解释器。第一行*始终*包含shebang（`#!`）和路径前缀，二者之间没有空格：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A script cannot execute by itself; it needs to be executed by a user or to be
    *called* by another program, the system, or another script. The execution of a
    script also requires it to have *executable* permissions, which can be granted
    by a user so that it can become executable; this can be done with the `chmod` command.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本不能自行执行；它需要由用户执行或*被*另一个程序、系统或其他脚本调用。脚本的执行还需要具备*可执行*权限，用户可以授予这些权限以使其变为可执行；这可以通过`chmod`命令完成。
- en: 'To add or *grant* basic executable permissions, use the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加或*授予*基本可执行权限，请使用以下命令：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To execute the script, one of the following methods can be used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本时，可以使用以下方法之一：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the correct permissions are applied, and the shebang and Bash interpreter
    path is correct, you may alternatively use the following two commands to execute
    `script.sh`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用了正确的权限，并且shebang和Bash解释器路径正确，您可以使用以下两条命令来执行`script.sh`：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the preceding command snippets, you might notice a few things regarding
    paths. The path to a script, file, or executable can be referred to using a *relative* address
    and a `full path`. Relative addressing effectively tells the interpreter to execute
    whatever may exist in the current directory or using the user's global shell `$PATH`
    variables. For example, the system knows that binaries or executable binaries
    are stored in `/usr/bin, /bin/ and /sbin` and will look there first. The full
    path is more concrete and *hardcoded;* the interpreter will try to use the complete
    path. For example, `/bin/ls or /usr/local/bin/myBinary`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令片段中，您可能会注意到一些关于路径的事情。脚本、文件或可执行文件的路径可以使用*相对*地址和`完整路径`来引用。相对地址有效地告诉解释器执行当前目录中可能存在的内容，或使用用户的全局shell
    `$PATH` 变量。例如，系统知道二进制文件或可执行二进制文件存储在`/usr/bin`、`/bin/`和`/sbin`中，并会首先在这些目录中查找。完整路径更加具体且*硬编码*；解释器会尝试使用完整路径。例如，`/bin/ls`或`/usr/local/bin/myBinary`。
- en: When you are looking to run a binary in the directory you are currently working
    in, you can use either `./script.sh`, bash `script.sh`, or even the full path.
    Obviously, there are advantages and disadvantages to each approach.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在当前工作目录中运行二进制文件时，可以使用`./script.sh`、bash `script.sh`，甚至是完整路径。当然，每种方法都有其优缺点。
- en: Hardcoded or full paths can be useful when you know exactly where a binary may
    reside on a specific system and you cannot rely on `$PATH` variables for potential
    security or system configuration reasons.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当您确切知道某个二进制文件在特定系统上的位置时，硬编码或完整路径可能很有用，特别是在由于潜在的安全或系统配置原因，无法依赖`$PATH`变量时。
- en: Relative paths are useful when flexibility is required. For example, program
    `ABC` could be in location `/usr/bin` or in `/bin`, but it could be called simply
    with ABC instead of `/pathTo/ABC`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要灵活性时，相对路径非常有用。例如，程序`ABC`可以位于`/usr/bin`或`/bin`位置，但可以简单地使用ABC来调用，而不是`/pathTo/ABC`。
- en: 'So far, we have covered what a basic Bash script looks like, and briefly introduced
    a few very basic, but essential commands and paths. However, to create a script—you
    need an editor! In Ubuntu, usually by default, you have a few editors available
    to you for the creation of a Bash script: vi/vim, nano, and gedit. There are a
    number of other text editors or **integrated development editors** (**IDEs**)
    available, but this is a personal choice and up to the reader to find one they 
    like. All of the examples and recipes in this book can be followed regardless
    of the text editor chosen.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了基本的 Bash 脚本样式，并简要介绍了一些非常基础但关键的命令和路径。然而，要创建脚本，你需要一个编辑器！在 Ubuntu
    中，通常默认情况下，你可以使用几种编辑器来创建 Bash 脚本：vi/vim、nano 和 gedit。还有许多其他的文本编辑器或 **集成开发环境**（**IDE**）可供选择，但这取决于个人偏好，读者可以根据自己的喜好选择一个。无论选择哪个文本编辑器，本书中的所有示例和教程都可以遵循。
- en: Without using a full-blown editor such as the popular Eclipse, Emacs or Geany
    may also be useful as flexible IDEs within resource-constrained environments,
    for example, a Raspberry Pi.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源受限的环境中，例如树莓派，不使用像 Eclipse、Emacs 或 Geany 这样的完整编辑器，仍然可以使用它们作为灵活的集成开发环境（IDE）。
- en: Knowledge of vi/vim and nano is very handy when you want to create or modify
    a script remotely over SSH and on the console. Vi/vim may seem a bit archaic,
    but it saves the day when your favorite editor is not installed or cannot be accessed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望通过 SSH 远程或在控制台上创建或修改脚本时，了解 vi/vim 和 nano 非常有用。虽然 vi/vim 看起来有些过时，但当你最喜欢的编辑器没有安装或无法访问时，它就能派上用场。
- en: Your first Bash script with Vim
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vim 编写你的第一个 Bash 脚本
- en: 'Let''s start by creating a script using improved version of vi (called `vim`).
    If Vim (VI-enhanced) is not installed, it can be installed with `sudo` or `root`
    using the following command (`-y` is short for yes):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用改进版的 vi（称为 `vim`）创建脚本开始。如果 Vim（增强版 VI）没有安装，可以使用 `sudo` 或 `root` 权限通过以下命令进行安装（`-y`
    是 yes 的简写）：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open a terminal and enter the following commands to first see where your terminal
    is currently navigated to, and to create the script using `vim`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并输入以下命令，首先查看当前终端导航到哪里，并使用 `vim` 创建脚本：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The terminal window will transform into the Vim application (similar to the
    following screenshot) and you will be just about ready to program your first script.
    Simultaneously press the *Esc*+ *I* keys to enter Insert mode; there will be an
    indicator in the bottom left and the cursor block will begin to flash:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 终端窗口将转换为 Vim 应用程序（类似于下图），你将准备好编写第一个脚本。与此同时，按下 *Esc* + *I* 键进入插入模式；左下角会有指示符，光标块开始闪烁：
- en: '![](img/532afbdf-f9cf-433c-8975-2119517e937d.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/532afbdf-f9cf-433c-8975-2119517e937d.png)'
- en: 'To navigate Vim, you may use any number of keyboard shortcuts, but the arrow
    keys are the simplest to move the cursor up, down, left, and right. Move the cursor
    to the beginning of the first line and type the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Vim 中导航，你可以使用许多键盘快捷键，但箭头键是最简单的，可以将光标向上、下、左、右移动。将光标移动到第一行的开头并输入以下内容：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have already introduced the concept of a comment and a few basic commands,
    but we have yet to introduce the flexible `echo`command. The `echo` command can
    be used to print text to the console or into files, and the `-n` flag prints text
    without the end line character (end line has the same effect as pressing *Enter*
    on the keyboard)—this allows the output from the `whoami` and `pwd` commands to
    appear on the same line.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了注释的概念和一些基本命令，但还没有介绍灵活的 `echo` 命令。`echo` 命令可以用来将文本输出到控制台或文件中，`-n` 标志可以打印文本而不包含换行符（换行符的效果与按下
    *Enter* 键相同）——这使得 `whoami` 和 `pwd` 命令的输出能够显示在同一行。
- en: The program also exits with a status of `0`, which means that it exited with
    a normal status. This will be covered later as we move toward searching or checking
    command exit statuses for errors and other conditions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 程序退出时返回 `0` 状态，表示它以正常状态退出。随着我们进一步了解如何搜索或检查命令的退出状态，错误和其他条件也将涵盖此内容。
- en: When you've finished, press *Esc* to exit insert mode; going back to command
    mode and typing `:` will allow you to write the vim command *w* + *q*. In summary,
    type the following key sequence: *Esc* and then *:wq*. This will exit Vim by writing
    to disk (w) and quitting (q), and will return you to the console.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，按 *Esc* 键退出插入模式；返回命令模式并输入 `:`，然后可以执行 vim 命令 *w* + *q*。总结起来，键入以下键序列：*Esc*，然后
    *:wq*。这将通过写入磁盘（w）并退出（q）来退出 Vim，并将你带回控制台。
- en: More information about Vim can be obtained by reviewing its documentation using
    the Linux manual pages or by referring to a sibling book available from Packt
    ([https://www.packtpub.com/application-development/hacking-vim-72](https://www.packtpub.com/application-development/hacking-vim-72)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查阅其文档使用Linux手册页或参考Packt提供的一个兄弟书籍获得有关Vim的更多信息（[https://www.packtpub.com/application-development/hacking-vim-72](https://www.packtpub.com/application-development/hacking-vim-72)）。
- en: 'To execute your first script, enter the `bash my_first_script.sh`command and
    the console will return a similar output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行您的第一个脚本，请输入`bash my_first_script.sh`命令，控制台将返回类似的输出：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Congratulations—you have created and executed your first Bash script. With these
    skills, you can begin creating more complex scripts to automate and simplify just
    about any daily CLI routines.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您——您已经创建并执行了您的第一个Bash脚本。有了这些技能，您可以开始创建更复杂的脚本来自动化和简化几乎任何日常CLI例程。
- en: Creating and using basic variables
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用基本变量
- en: 'The best way to think of variables is as placeholders for values. They can
    be permanent (static) or transient (dynamic), and they will have a concept called **scope** (more
    on this later). To get ready to use variables, we need to think about the script
    you just wrote: `my_first_script.sh`. In the script, we could have easily used
    variables to contain values that are static (there every time) or dynamic ones
    created by running commands every time the script is run. For example, if we would
    like to use a value such as the value of `PI` (`3.14`), then we could use a variable
    like this short script snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量视为值的占位符是最好的方式。它们可以是永久的（静态的）或瞬时的（动态的），并且它们将有一个称为**作用域**的概念（稍后详述）。为了准备使用变量，我们需要考虑刚刚编写的脚本：`my_first_script.sh`。在脚本中，我们可以轻松地使用变量来包含静态值（每次都在那里）或通过每次运行脚本创建的动态值。例如，如果我们想使用像`PI`的值（`3.14`的值），那么我们可以像这样使用一个变量来编写这段简短的脚本：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If included in a full script, the script snippet would output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含在完整脚本中，脚本片段将输出：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that the idea of setting a value (`3.14`) to a variable is called assignment.
    We *assigned* the value of `3.14` to a variable with the name `PI`. We also referred
    to the `PI` variable using `$PI`. This can be achieved in a number of ways:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将一个值（`3.14`）分配给变量的想法被称为赋值。我们*赋予*了变量名为`PI`的变量值为`3.14`。我们还使用`$PI`引用了`PI`变量。这可以通过多种方式实现：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will output the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While the output is identical, the mechanisms are slightly different. In version
    1, we refer to the `PI` variable within double quotes, which indicates a **string
    (an array of characters)**. We could also use single quotes, but this would make
    this a **literal string**. In version 2, we refer to the variable inside of `{
    }` or *squiggly* brackets; this is useful for protecting the variable in cases
    where this would break the script. The following is an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然输出是相同的，但机制略有不同。在第1版中，我们在双引号中引用`PI`变量，这表示一个**字符串（字符数组）**。我们也可以使用单引号，但这将使其成为**字面字符串**。在第2版中，我们在`{
    }`或*squiggly*大括号内引用变量；这对于在可能破坏脚本的情况下保护变量非常有用。以下是一个例子：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If any variable is not declared and then we try to use it, that variable will
    be initialized to an empty string.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何变量未声明然后我们尝试使用它，那个变量将被初始化为空字符串。
- en: 'The following command will convert a numeric value to a string representation.
    In our example, `$PI` is still a variable containing a number, but we could have
    created the `PI` variable like this as well:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将把数值转换为字符串表示。在我们的示例中，`$PI`仍然是一个包含数字的变量，但我们也可以像这样创建`PI`变量：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would contain within the variable a string and not a numeric value such
    as **an integer or float**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含一个字符串而不是数值，比如**整数或浮点数**。
- en: The concept of data types is not explored to its fullest in this cookbook. It
    is best left as a topic for the reader to explore, as it is a fundamental concept
    of programming and computer usage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的概念在本手册中没有得到充分探讨。最好将其作为读者探索的主题，因为它是编程和计算机使用的基本概念。
- en: 'Wait! You say there is a difference between a number and a string? Absolutely,
    because without conversion (or being set correctly in the first place), this may
    limit the things you can do with it. For example, 3.14 is not the same as 3.14
    (the number). 3.14 is made up of four characters: 3 + . + 1 +4\. If we wanted
    to perform multiplication on our PI value in string form, either the calculation/script
    would break or we would get a nonsensical answer.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！你说数字和字符串之间有区别？当然有，因为如果没有转换（或者一开始没有正确设置），这可能会限制你能做的事情。例如，3.14与3.14（数字）是不一样的。3.14由四个字符组成：3
    + . + 1 + 4。如果我们想对以字符串形式表示的PI值进行乘法运算，要么计算/脚本会出错，要么我们会得到一个毫无意义的答案。
- en: We will talk more about conversion later, in Chapter 2, *Acting like a Typewriter
    and File Explorer.*
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续的第二章中进一步讲解转换内容，*像打字机和文件浏览器一样工作*。
- en: 'Let''s say we want to assign one variable to another. We would do this like
    so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将一个变量赋值给另一个变量。我们可以这样做：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the preceding snippet were within a functioning Bash script, we would get
    the value 10 for each variable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的代码片段在一个有效的Bash脚本中，我们会为每个变量得到值10。
- en: Hands-on variable assignment
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践变量赋值
- en: 'Open a new blank file and add the following to it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的空白文件并添加以下内容：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice the nomenclature. It is great to use a standardized mechanism to name
    variables, but to use `STR_A` and `VAR_B` is clearly not descriptive enough if
    used multiple times. In the future, we will use more descriptive names, such as `VAL_PI`
    to mean the value of PI or `STR_BOBNAME` to mean the string representing Bob's
    name. In Bash, capitalization is often used to describe variables, as it adds
    clarity.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命名法。使用标准化机制来命名变量是很好的，但如果多次使用`STR_A`和`VAR_B`，显然它们不够具描述性。未来，我们将使用更具描述性的名称，比如`VAL_PI`表示PI的值，或者`STR_BOBNAME`表示代表Bob名字的字符串。在Bash中，通常使用大写字母来描述变量，因为这样可以增加清晰度。
- en: 'Press Save and exit to a terminal (open one if one isn''t already open). Execute
    your script after applying the appropriate permissions, and you should see the
    following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按下保存并退出到终端（如果终端尚未打开，请打开一个）。在应用适当的权限后执行脚本，你应该会看到以下输出：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we saw how we can use three variables, assign values to each of then,
    and print them. Secondly, we saw through a demonstration that the interpreter
    can break when concatenating strings (let's keep this in mind). Thirdly, we printed
    out our `PI` variable and concatenated it to a string using `echo`. Finally, we
    performed a few more types of concatenation, including a final version, which
    converts a numeric value and appends it to a string.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到如何使用三个变量，为它们赋值，并打印它们。其次，我们通过演示看到，连接字符串时解释器可能会出错（我们要记住这一点）。第三，我们打印了我们的`PI`变量，并用`echo`将其连接到一个字符串中。最后，我们进行了几种不同的连接方式，包括最终版本，它将一个数字值转换并附加到字符串中。
- en: Hidden Bash variables and reserved words
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏的Bash变量和保留字
- en: Wait—there are hidden variables and reserved words? Yes! There are words you
    can't use in your script unless properly contained in a construct such as a string.
    Global variables are available in a **global context**, which means that they
    are visible to all scripts in the current shell or open shell consoles. In a later
    chapter, we will explore global shell variables more, but just so you're aware,
    know that there are useful variables available for you to reuse, such as `$USER`,
    `$PWD`, `$OLDPWD`, and `$PATH`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 等等——有隐藏变量和保留字吗？是的！有一些单词你不能直接在脚本中使用，除非它们被正确地包含在某个构造中，比如字符串。全局变量可在**全局上下文**中使用，这意味着它们对当前shell或打开的shell控制台中的所有脚本可见。在后面的章节中，我们将进一步探讨全局shell变量，但目前你需要了解的是，有一些有用的变量可以供你重复使用，例如`$USER`、`$PWD`、`$OLDPWD`和`$PATH`。
- en: 'To see a list of all shell environment variables, you can use the `env`command
    (the output has been cut short):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看所有shell环境变量的列表，可以使用`env`命令（输出已被截短）：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Modifying the `PATH` environment variable can be very useful. It can also be
    frustrating, because it contains the filesystem path to binaries. For example,
    you have binaries in `/bin` or `/sbin` or `/usr/bin`, but when you run a single
    command, the command is run without you specifying the path.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`PATH`环境变量非常有用，但也可能会让人感到沮丧，因为它包含了二进制文件的文件系统路径。例如，你的二进制文件可能位于`/bin`、`/sbin`或`/usr/bin`目录中，但当你运行某个命令时，系统会在你没有指定路径的情况下直接执行该命令。
- en: Alright, so we have acknowledged the existence of pre-existing variables and
    that there could be new global variables created by the user or other programs.
    When using variables that have a high probability of being similarly named, be
    careful to make them specific to your application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经确认了预先存在的变量以及用户或其他程序可能创建的新全局变量的存在。在使用可能具有高概率相似命名的变量时，请务必使其特定于您的应用程序。
- en: In addition to hidden variables, there are also words that are reserved for
    use within a script or shell. For example, if and else are words that are used
    to provide conditional logic to scripts. Imagine if you created a command, variable,
    or function (more later on this) with the same name as one that already exists?
    The script would likely break or run an erroneous operation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了隐藏变量外，还有一些保留用于脚本或 Shell 内部的词语。例如，`if` 和 `else` 是用于为脚本提供条件逻辑的词语。想象一下，如果您创建了一个与已存在的命令、变量或函数（稍后详述）同名的命令，脚本可能会中断或执行错误的操作。
- en: When trying to avoid any naming collisions (or namespace collisions), try to
    make your variables more likely to be used by your application by appending or
    prefixing an identifier that is likely to be unique.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试避免任何命名冲突（或命名空间冲突）时，请尝试通过附加或前缀标识符使您的变量更可能被您的应用程序使用。
- en: The following list contains some of the more common reserved words that you
    will encounter. Some of which are likely to look very familiar because they tell
    the Bash interpreter to interpret any text in a specific way, redirect output,
    run an application in the background, or are even used in other programming/scripting
    languages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含一些您可能会遇到的常见保留字。其中一些可能看起来非常熟悉，因为它们告诉 Bash 解释器以特定方式解释任何文本，重定向输出，后台运行应用程序，甚至在其他编程/脚本语言中使用。
- en: '`if`, `elif`, `else`, `fi`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`, `elif`, `else`, `fi`'
- en: '`while`, `do`, `for`, `done`, `continue`, `break`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`, `do`, `for`, `done`, `continue`, `break`'
- en: '`case`, `select`, `time`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case`, `select`, `time`'
- en: '`function`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`&`, `|`, `>`, `<`, `!`, `=`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&`, `|`, `>`, `<`, `!`, `=`'
- en: '`#`, `$`, `(, )`, `;`, `{, }`, `[, ]`, `\`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#`, `$`, `(, )`, `;`, `{, }`, `[, ]`, `\`'
- en: 'For the full reference, go to: [https://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html](https://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 欲查看完整参考，请访问：[https://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html](https://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html).
- en: 'The last element in the list contains an array of specific characters that
    tell Bash to perform specific functionalities. The pound sign signifies a comment
    for example. However, the backslash `\`is very special because it is an **escape
    character**. Escape characters are used to *escape* or *stop* the interpreter
    from executing specific functionality when it sees those particular characters.
    For example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的最后一个元素包含一组特定字符，告诉 Bash 执行特定的功能。井号标志着例如注释的开始。但是反斜杠 `\` 是非常特殊的，因为它是一个**转义字符**。转义字符用于*转义*或*停止*解释器在看到这些特定字符时执行特定功能。例如：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Escaping characters will become very useful in [Chapter 2](b71b7795-5b29-4a02-90a0-294283079dc8.xhtml),
    *Acting like a Typewriter and File Explorer*, when working with strings and single/double
    quotes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第二章](b71b7795-5b29-4a02-90a0-294283079dc8.xhtml) 中，即《如打字机和文件资源管理器一样操作》时，处理字符串和单/双引号时，转义字符将非常有用。
- en: The escape character prevents the execution of the next character after the
    forward slash. However, this is not necessarily consistent when working with carriage
    returns (`\n`, `\r\n`) and null bytes (`\0`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 转义字符阻止在斜杠后执行下一个字符。但是，当处理换行符 (`\n`, `\r\n`) 和空字节 (`\0`) 时，这种行为不一定是一致的。
- en: Conditional logic using if, else, and elseif
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `if`, `else` 和 `elseif` 进行条件逻辑
- en: 'The previous section introduced the concept that there are several reserved
    words and a number of characters that have an effect on the operation of Bash.
    The most basic, and probably most widely used conditional logic is with `if` and
    `else` statements. Let''s use an example code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节介绍了几个保留字和一些会影响 Bash 运行的字符。其中最基本且可能被广泛使用的条件逻辑是使用 `if` 和 `else` 语句。让我们使用一个代码片段作为例子：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice the space after or before the square brackets in the `if` statement.
    Bash is particularly picky about the syntax of bracketing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `if` 语句中方括号前后的空格。Bash 对括号语法要求格外严格。
- en: If we are evaluating the variable `age` using less than (`<`) or `-lt` (Bash
    offers a number of syntactical constructs for evaluating variables), we need to
    use an `if` statement. In our `if` statement, if `$AGE` is less than `18`, we
    echo the message `You must be 18 or older to see this movie`. Otherwise, the script
    will not execute the `echo` statement and will continue execution. Notice that
    the `if` statement ends with the reserved word `fi`. This is not a mistake and
    is required by Bash syntax.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用小于（`<`）或`-lt`来评估变量`age`（Bash提供了许多用于评估变量的语法构造），我们需要使用`if`语句。在我们的`if`语句中，如果`$AGE`小于`18`，我们将输出消息`You
    must be 18 or older to see this movie`。否则，脚本将不会执行`echo`语句，而是继续执行。注意，`if`语句以保留字`fi`结束。这不是错误，符合Bash语法要求。
- en: 'Let''s say we want to add a catchall using `else`. If the `then` command block
    of the `if` statement is not satisfied, then the `else` will be executed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用`else`添加一个通用的捕获条件。如果`if`语句的`then`命令块不满足条件，则会执行`else`。
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With `AGE` set to the integer value `40`, the `then` command block inside the `if`
    statement will not be satisfied and the `else` command block will be executed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当`AGE`设置为整数值`40`时，`if`语句中的`then`命令块将不满足条件，`else`命令块将被执行。
- en: Evaluating binary numbers
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估二进制数字
- en: 'Let''s say we want to introduce another `if` condition and use `elif` (short
    for *else if*):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想引入另一个`if`条件并使用`elif`（即*else if*的缩写）：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using `if`, `elif`, and `else`, combined with other evaluations, we can execute
    specific branches of logic and functions or even exit our script. To evaluate
    raw binary variables, use the following **operators**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`、`elif`和`else`，结合其他评估方法，我们可以执行特定的逻辑分支和函数，甚至退出脚本。要评估原始的二进制变量，请使用以下**运算符**：
- en: '`-gt` (greater than >)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-gt`（大于 >）'
- en: '`-ge` (greater or equal to >=)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ge`（大于或等于 >=）'
- en: '`-lt` (less than <)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lt`（小于 <）'
- en: '`-le` (less than or equal to <=)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-le`（小于或等于 <=）'
- en: '`-eq` (equal to)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-eq`（等于）'
- en: '`-nq` (not equal to)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-nq`（不等于）'
- en: Evaluating strings
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估字符串
- en: 'As mentioned in the variables subsection, numeric values are different from
    strings. Strings are typically evaluated like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如变量小节所述，数字值与字符串不同。字符串通常按如下方式进行评估：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If `MY_NAME` is equal to `Ron`, then `echo "Ron is home from vacation"`
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`MY_NAME`等于`Ron`，则执行`echo "Ron is home from vacation"`
- en: Else if `MY_NAME` is not equal to `NAME_1` **AND** `MY_NAME` is not equal to `NAME_2`
    **AND** `MY_NAME` is equal to `John`, then `echo "John is home after some unnecessary
    AND logic"`
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果`MY_NAME`不等于`NAME_1` **并且**`MY_NAME`不等于`NAME_2` **并且**`MY_NAME`等于`John`，则执行`echo
    "John is home after some unnecessary AND logic"`
- en: Else if `MY_NAME` is equal to `NAME_3` **OR** `MY_NAME` is equal to `NAME_4`,
    then `echo "Looks like one of the ladies"`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则如果`MY_NAME`等于`NAME_3` **或** `MY_NAME`等于`NAME_4`，则执行`echo "Looks like one of
    the ladies"`
- en: Else `echo "Who is this stranger?"`
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则`echo "Who is this stranger?"`
- en: 'Notice the operators: `&&`, `||`, `==`, and `!=`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意运算符：`&&`、`||`、`==`和`!=`
- en: '`&&` (means and)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`（表示和）'
- en: '`||` (means or)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||`（表示或）'
- en: '`==` (is equal to)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==`（等于）'
- en: '`!=` (not equal to)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=`（不等于）'
- en: '`-n` (is not null or is not set)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`（不是空的或未设置）'
- en: '`-z` (is null and zero length)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-z`（为空且长度为零）'
- en: Null means not set or empty in the world of computing. There are many different
    types of operators or tests that can be used in your scripts. For more information,
    check out:[ http://tldp.org/LDP/abs/html/comparison-ops.html](http://tldp.org/LDP/abs/html/comparison-ops.html)
    and [https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic](https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机世界中，Null表示未设置或为空。你可以在脚本中使用许多不同类型的运算符或测试。欲了解更多信息，请查看：[http://tldp.org/LDP/abs/html/comparison-ops.html](http://tldp.org/LDP/abs/html/comparison-ops.html)和[https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic](https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic)
- en: You can also evaluate numbers as if they are strings using `(("$a" > "$b"))`
    or `[[ "$a" > "$b" ]]`. Notice the usage of double parentheses and square brackets.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以像字符串一样评估数字，使用`((" $a" > "$b"))`或`[[ "$a" > "$b" ]]`。注意使用了双括号和方括号。
- en: Nested if statements
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套的`if`语句
- en: 'If a single level of `if` statements is not enough and you would like to have
    additional logic within an `if` statement, you can create **nested conditional
    statements**. This can be done in the following way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单一层级的`if`语句不足以满足需求，且你希望在`if`语句中添加额外的逻辑，你可以创建**嵌套条件语句**。可以通过以下方式来实现：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Case/switch statements and loop constructs
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`case/switch`语句和循环结构'
- en: Besides `if` and `else` statements, Bash offers case or switch statements and
    loop constructs that can be used to simplify logic so that it is more readable
    and sustainable. Imagine creating an `if` statement with many `elif` evaluations.
    It would become cumbersome!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`if`和`else`语句，Bash还提供了case或switch语句以及循环结构，可以用来简化逻辑，使其更易读和可持续。想象一下，如果有很多`elif`评估的`if`语句，它会变得很繁琐！
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In a large number of blocks of conditional logic of `if` and `elifs`, each `if`
    and `elif` needs to be evaluated before executing a specific branch of code. It
    can be faster to use a case/switch statement, because the first match will be
    executed (and it looks prettier).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量的`if`和`elif`条件逻辑块中，每个`if`和`elif`需要在执行特定的代码分支之前进行评估。使用case/switch语句可能更快，因为第一个匹配的条件会被执行（而且看起来更简洁）。
- en: Basic case statement
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的case语句
- en: Instead of `if`/`else` statements, you can use **case statements** to evaluate
    a variable. Notice that `esac` is case backwards and is used to exit the case
    statement similar to `fi` for `if` statements.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用**case语句**代替`if`/`else`语句来评估一个变量。请注意，`esac`是反向拼写的，用来退出case语句，类似于`fi`用于`if`语句。
- en: 'Case statements follow this flow:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Case语句遵循以下流程：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is a working example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可运行的示例：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Basic loops
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本循环
- en: Can you imagine iterating through a list of files or a dynamic array and monotonously
    evaluating each and every one? Or waiting until a condition was true? For these
    types of scenarios, you may want to use a **for loop, a do while loop, or an until
    loop **to improve your script and make things easy. For loops, do while loops,
    and until loops may seem similar, but there are subtle differences between them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象遍历一个文件列表或动态数组，单调地评估每一个文件吗？或者等到某个条件为真？对于这些类型的场景，你可能想使用**for循环、do while循环或until循环**来优化你的脚本，使得操作更简单。for循环、do
    while循环和until循环可能看起来相似，但它们之间有细微的差别。
- en: For loop
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: For循环
- en: 'The `for` loop is usually used when you have multiple tasks or commands to
    execute for each of the entries in an array or *want to execute a given command
    on a finite number of items*. In this example, we have an array (or list) containing
    three elements: `file1`, `file2`, and `file3`. The `for` loop will `echo` each
    element within `FILES` and exit the script:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环通常用于你需要对数组中的每个条目执行多个任务或命令时，或者*希望在有限数量的项上执行给定命令*。在这个例子中，我们有一个包含三个元素的数组（或列表）：`file1`、`file2`和`file3`。`for`循环将`echo`每个`FILES`中的元素并退出脚本：'
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Do while loop
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Do while循环
- en: 'As an alternative, we have included the `do while` loop. It is similar to a
    `for` loop, but better suited to *dynamic conditions*, such as when you do not
    know when a value will be returned or performing a task until a condition is met.
    The condition within the square brackets is the same as an *if* statement:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，我们包括了`do while`循环。它与`for`循环相似，但更适用于*动态条件*，比如当你不知道什么时候会返回某个值，或者在满足条件之前一直执行任务时。方括号中的条件与*if*语句相同：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Until loop
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Until循环
- en: 'For completeness, we have included the `until` loop. It is not used very often
    and is almost the same as a `do while` loop. Notice that its condition and operation
    is consistent with incrementing a counter `until` a value is reached:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们包括了`until`循环。它并不常用，几乎与`do while`循环相同。请注意，它的条件和操作与递增计数器直到某个值达到时的一致：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using functions and parameters
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数和参数
- en: So far in the book, we have mentioned that function is a reserved word and only
    used in Bash scripts that are in a single procedure, but what is a function?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们提到函数是一个保留字，仅用于单个过程的Bash脚本中，那么什么是函数呢？
- en: To illustrate what a function is, first we need to define what a function is—a** function**
    is a self-contained section of code that performs a single task. However, a function
    performing a task may also execute many subtasks in order to complete its main
    task.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明什么是函数，首先我们需要定义什么是函数——**函数**是一个自包含的代码段，执行单一任务。然而，执行某项任务的函数可能还会执行多个子任务来完成其主要任务。
- en: 'For example, you could have a function called `file_creator` that performs
    the following tasks:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建一个名为`file_creator`的函数，执行以下任务：
- en: Check to see whether a file exists.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件是否存在。
- en: If the file exists, truncate it. Otherwise, create a new one.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，截断它。否则，创建一个新文件。
- en: Apply the correct permissions.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用正确的权限。
- en: A function can also be passed parameters. **Parameters** are like variables
    that can be set outside of a function and then used within the function itself.
    This is really useful because we can create segments of code that perform generic
    tasks that are reusable by other scripts or even within loops themselves. You
    may also have **local **variables that are not accessible outside of a function
    and for usage only within the function itself. So what does a function look like?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以传递参数。**参数**就像变量，可以在函数外部设置，然后在函数内部使用。这非常有用，因为我们可以创建执行通用任务的代码段，其他脚本或甚至循环内的代码都可以重用。你也可以有**局部**变量，它们在函数外部不可访问，仅在函数内部使用。那么函数是什么样子的呢？
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we can see in the simple script, there is a function declared as `my_function`
    using the `function`reserved word. The content of the function is contained within
    the squiggly brackets `{}` and introduces three new concepts:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在简单脚本中看到的那样，有一个使用`function`保留字声明的名为`my_function`的函数。函数的内容包含在大括号`{}`内，并引入了三个新概念：
- en: '**Parameters** are referred to systematically like this: `$1` for parameter
    1, `$2` for parameter 2, `$3` for parameter 3, and so on'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**是这样系统地引用的：`$1`代表参数1，`$2`代表参数2，`$3`代表参数3，依此类推。'
- en: The `local` keyword refers to the fact that variables *declared*with this keyword
    remain accessible only within this function
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`关键字指的是带有此关键字声明的变量仅在该函数内部可访问。'
- en: We can call functions merely by name and use parameters simply by adding them,
    as in the preceding example
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以仅通过名称调用函数，并简单地添加参数，就像在前面的示例中一样。
- en: 'In the next section, we''ll dive into a more realistic example that should
    drive the point home a bit more: functions are helpful everyday and make functionality
    from any section easily reusable where appropriate.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将深入探讨一个更实际的示例，这将使这个观点更清晰：函数是日常有用的，并且能够在适当的地方让任何部分的功能变得易于重用。
- en: Using a function with parameters within a for loop
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在for循环中使用带参数的函数
- en: 'In this short example, we have a function called `create_file`, which is called
    within a loop for each file in the `FILES` array. The function creates a file,
    modifies its permissions, and then passively checks for its existence using the
    `ls` command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的示例中，我们有一个名为`create_file`的函数，它在`FILES`数组中的每个文件上调用。该函数创建一个文件，修改其权限，然后使用`ls`命令被动地检查其存在性：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Including source files
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含源文件
- en: In addition to functions, we can also create multiple scripts and include them
    such that we can utilize any shared variables of functions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数外，我们还可以创建多个脚本并将它们包含在内，这样我们就可以利用任何共享的变量和函数。
- en: 'Let''s say we have a library or utility script that contains a number of functions
    useful for creating files. This script by itself could be useful or **reusable **for
    a number of scripting tasks, so we make it program neutral. Then, we have another
    script, but this one is dedicated to a single task: performing useless file system
    operations (IO). In this case, we would have two files:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含多个用于创建文件的函数的库或工具脚本。这个脚本本身可能在多个脚本任务中有用或**可重用**，因此我们使其与程序无关。然后，我们有另一个脚本，这个脚本专门处理一个任务：执行无用的文件系统操作（IO）。在这种情况下，我们将有两个文件：
- en: '`io_maker.sh` (which includes `library.sh` and uses `library.sh` functions)'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`io_maker.sh`（包括`library.sh`并使用`library.sh`中的函数）'
- en: '`library.sh` (which contains declared functions, but does not execute them)'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`library.sh`（包含已声明的函数，但不执行它们）'
- en: The `io_maker.sh` script simply imports or includes the `library.sh` script
    and inherits knowledge of any global variables, functions, and other inclusions.
    In this manner, `io_maker.sh` effectively thinks that these other available functions
    are its own and can execute them as if they were contained within it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`io_maker.sh`脚本简单地导入或包含了`library.sh`脚本，并继承了任何全局变量、函数和其他包含内容。通过这种方式，`io_maker.sh`实际上认为这些可用的函数是它自己的，并且可以像它们是在其中定义的一样执行它们。'
- en: Including/importing a library script and using external functions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含/导入库脚本并使用外部函数
- en: 'To prepare for this example, create the following two files and open both:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个示例，创建以下两个文件并打开它们：
- en: '`io_maker.sh`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io_maker.sh`'
- en: '`library.sh`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`library.sh`'
- en: 'Inside `library.sh`, add the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`library.sh`中，添加以下内容：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside `io_maker.sh`, add the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`io_maker.sh`中，添加以下内容：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When you run the script, you should get the same output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行脚本时，应该得到相同的输出：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Although not obvious, we can see that both functions are executed. The first
    line of output is the `ls`command, successfully finding `my_test_file.txt` after
    creating the file in `create_file()`. In the second line, we can see that ls returns
    an error when we delete the file passed in as a parameter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不明显，但我们可以看到两个函数都被执行了。第一行输出是 `ls` 命令，在 `create_file()` 中创建文件后成功找到 `my_test_file.txt`。在第二行中，我们可以看到当删除作为参数传入的文件时，`ls`
    返回了一个错误。
- en: Unfortunately, up until now, we have only been able to create and call functions,
    and execute commands. The next step, discussed in the next section, is to retrieve
    commands and function return codes or strings.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，直到现在，我们只能创建和调用函数，并执行命令。下一步将在下一节中讨论，获取命令和函数的返回码或字符串。
- en: Retrieving return codes and output
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取返回码和输出
- en: Up until now, we have been using a command called `exit` intermittently to exit
    scripts. For those of you who are curious, you may have already scoured the web
    to find out what this command does, but the key concept to remember is that *every*
    script, command, or binary exits with a *return code*. Return codes are numeric
    and are limited to being between0-255 because an unsigned 8-bit integer is used.
    If you use a value of `-1`, it will return `255`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在间歇性地使用 `exit` 命令退出脚本。对于那些好奇的人，你们可能已经在网上查找过这个命令的作用，但需要记住的关键概念是，*每个*脚本、命令或二进制文件都会以*返回码*退出。返回码是数字，并且被限制在0到255之间，因为使用的是无符号的8位整数。如果使用
    `-1`，则会返回 `255`。
- en: 'Okay, so return codes are useful in which ways? Return codes are useful when
    you want to know whether you found a match when performing a match (for example),
    and whether the command was completely successfully or there was an error. Let''s
    dig into a real example using the `ls` command on the console:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么返回码有哪些用处呢？返回码在你想知道在执行匹配时是否找到匹配项时非常有用（例如），以及命令是否完全成功或出现错误。让我们通过一个实际示例来探索使用
    `ls` 命令的情况：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice the return values? `0` or `2` in this example mean either success (0)
    or that there are errors (1 and 2). These are obtained by retrieving the `$?`
    variable and we could even set it to a variable like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意返回值吗？在这个例子中，`0` 或 `2` 表示成功（0）或出现错误（1 和 2）。这些值是通过获取 `$?` 变量获得的，我们甚至可以像这样将其设置为一个变量：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From this example, we now know what return codes are, and how we can use them
    to utilize results returned from functions, scripts, and commands.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们现在知道了返回码是什么，以及如何利用它们来获取从函数、脚本和命令返回的结果。
- en: Return code 101
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回码 101
- en: 'Dig into your terminal and create the following Bash script:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 深入终端并创建以下 Bash 脚本：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The script will output the following before exiting with a return code of `0`
    (remember that ls returns `0` if run successfully):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将在退出并返回码为 `0`（记住，`ls` 在成功运行时返回 `0`）之前输出以下内容：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this section, there are three functions that leverage three concepts:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，有三个函数利用了三个概念：
- en: '`my_function_global` uses a `global`variable to return the command''s return
    code'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`my_function_global` 使用 `global` 变量来返回命令的返回码'
- en: '`my_function_return` uses the reserved word, `return`**, **and a value (the
    command''s return code)'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`my_function_return` 使用保留字 `return`** 和一个值（命令的返回码）'
- en: '`my_function_str` uses a `fork` (a special operation) to execute a command
    and get the output (our string, which is echoed)'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`my_function_str` 使用 `fork`（一个特殊操作）来执行命令并获取输出（我们回显的字符串）'
- en: For option 3, there are several ways to get a string back from a function, including
    using the `eval`keyword. However, when using fork, it is best to be aware of the
    resources it may consume when running the same command many times just to get
    the output.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选项3，有多种方法可以从函数中返回字符串，包括使用 `eval` 关键字。然而，在使用 `fork` 时，最好注意它在多次执行相同命令以获取输出时可能消耗的资源。
- en: Linking commands, pipes, and input/output
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接命令、管道和输入/输出
- en: 'This section is probably one of the most important in the book because it describes
    a fundamental and powerful feature on Linux and Unix: the ability to use pipes
    and redirect input or output. By themselves, pipes are a fairly trivial feature
    - commands and scripts can redirect their output to files or commands. So what?
    This could be considered a massive understatement in the Bash scripting world,
    because pipes and redirection allow you to enhance commands with the functionality
    of other commands or features.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本节可能是本书中最重要的一部分，因为它描述了 Linux 和 Unix 上一个基本且强大的功能：使用管道并重定向输入或输出。就其本身而言，管道是一个相当简单的功能——命令和脚本可以将它们的输出重定向到文件或其他命令。那么，这有什么了不起的呢？在
    Bash 脚本世界中，这几乎是对管道和重定向功能的极大低估，因为它们允许你通过其他命令或功能增强命令的功能。
- en: 'Let''s look into this with an example using commands called `tail` and `grep`.
    In this example, the user, Bob, wants to look at his logs in real time (live),
    but he only wants to find the entries related to the wireless interface. The name
    of Bob''s wireless device can be found using the `iwconfig`command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看如何使用名为 `tail` 和 `grep` 的命令。在这个例子中，用户 Bob 想要实时查看他的日志，但他只希望查找与无线接口相关的条目。Bob
    的无线设备名称可以通过 `iwconfig` 命令找到：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `iwconfig` command is deprecated now. The following commands also will
    give you wireless interface information:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`iwconfig` 命令现在已被弃用。以下命令也会为你提供无线接口的信息：'
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now that Bob knows his wireless card's identifying name (`wlp3s0`), Bob can
    search his system's logs. It is usually found within `/var/log/messages`. Using
    the `tail`command and the `-F` flag, which allows continuously outputting the
    logs to the console, Bob can now see *all* the logs for his system. Unfortunately,
    he would like to filter the logs using `grep`, such that only logs with the keyword `wlp3s0`are
    visible.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Bob 知道了他无线网卡的标识名称（`wlp3s0`），他可以在系统日志中进行搜索。日志通常可以在 `/var/log/messages` 中找到。使用
    `tail` 命令和 `-F` 标志（允许将日志持续输出到控制台），Bob 现在可以看到系统的 *所有* 日志。不幸的是，他希望通过 `grep` 过滤日志，使得只显示包含关键词
    `wlp3s0` 的日志。
- en: 'Bob is faced with a choice: does he search the file continuously, or can he combine
    `tail` and `grep` together to get the results he desires? The answer is yes—using *pipes*!'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 面临一个选择：他是持续搜索该文件，还是可以将 `tail` 和 `grep` 结合使用，以获取他所需要的结果？答案是肯定的——使用 *管道*！
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As new logs come in, Bob can now monitor them in real time and can stop the
    console output using *Ctrl*+*C*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的日志进入时，Bob 现在可以实时监控它们，并且可以通过 *Ctrl*+*C* 停止控制台输出。
- en: Using pipes, we can combine commands into powerful hybrid commands, extending
    the best features of each command into one single line. Remember pipes!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道，我们可以将多个命令组合成强大的混合命令，将每个命令的最佳特性扩展到单一命令行中。记住管道！
- en: 'The usage and flexibility of pipes should be relatively straightforward, but
    what about directing the input and output of commands? This requires the introduction
    of three commands to get information from one place to another:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的使用和灵活性应该是相对直接的，但如果我们需要将命令的输入和输出进行重定向呢？这就需要引入三个命令，以便将信息从一个地方传送到另一个地方：
- en: '`stdin` (standard in)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdin`（标准输入）'
- en: '`stdout` (standard out)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdout`（标准输出）'
- en: '`stderr` (standard error)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stderr`（标准错误）'
- en: If we are thinking about a *single* program, `stdin` is anything that can be
    provided to it, usually either as a parameter or a user input, **using read **for
    example. `Stdout` and `stderr` are two **streams** where output can be sent. Usually,
    output for both is sent to the console for display, but what if you only want
    the errors within the `stderr` stream to go to a file?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑的是一个 *单独* 的程序，`stdin` 是任何可以提供给它的内容，通常是作为参数或用户输入，**例如使用 read**。`stdout`
    和 `stderr` 是两种 **流**，用于发送输出。通常，两个流的输出会显示在控制台上，但如果你只想将 `stderr` 流中的错误输出到文件呢？
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Take note of the difference between a single `>` and double `>>`. A single `>`
    **will truncate** any file that will have output directed to it, while `>>` **will
    append** any file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意单个 `>` 和双 `>>` 之间的区别。单个 `>` **会截断**所有输出到文件的内容，而 `>>` **会附加**内容到文件末尾。
- en: There is a common error when redirecting both `stderr` and `stdout` to the same
    file. Bash should pick up the output to a file first, and then the duplication
    of the output file descriptors. For more information on file descriptors, see: [https://en.wikipedia.org/wiki/File_descriptor](https://en.wikipedia.org/wiki/File_descriptor)
    `# This is correct`
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当同时将`stderr`和`stdout`重定向到同一文件时，常会出现错误。Bash应当先将输出写入文件，然后再重复输出文件描述符。有关文件描述符的更多信息，请参见：[https://en.wikipedia.org/wiki/File_descriptor](https://en.wikipedia.org/wiki/File_descriptor)
    `# 这是正确的`
- en: '`ls ~/ > everything.txt 2>&1`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls ~/ > everything.txt 2>&1`'
- en: '`# This is erronous`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 这是错误的`'
- en: '`ls ~/ 2>&1> everything.txt`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls ~/ 2>&1> everything.txt`'
- en: Now that we know the basics of one of the most powerful features available in
    Bash, let's try an example—redirection and pipes bonzanza.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Bash中最强大的功能之一的基础知识，接下来让我们尝试一个例子——重定向和管道大作战。
- en: Redirection and pipe bonzanza
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向和管道大作战
- en: 'Open a shell and create a new bash file in your favorite editor:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个Shell并在你喜欢的编辑器中创建一个新的Bash文件：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: First, `ls` is a way of producing an error and, instead of pushing erroneous
    output to the console, it is instead redirected to a special device in Linux called `/dev/null`. `/dev/null`
    is particularly useful as it is a dump for any input that will not be used again.
    Then, we combine the `cat`command with `grep`to find any lines of text with a
    pipe and use a fork to capture the output to a variable (`HISTORY_TEXT`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`ls`是产生错误的一种方式，而不是将错误输出推送到控制台，而是将其重定向到Linux中的一个特殊设备`/dev/null`。`/dev/null`特别有用，因为它是一个丢弃不会再使用的输入的地方。然后，我们将`cat`命令与`grep`结合使用，通过管道找到任何包含文本的行，并使用`fork`捕获输出到一个变量（`HISTORY_TEXT`）。
- en: Then, we echo the contents of `HISTORY_TEXT` to a file (`history.config`) using
    a `stdout` redirect. Using the `history.config`file, we redirect cat to use the
    raw file—this will be displayed on the console.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`stdout`重定向将`HISTORY_TEXT`的内容回显到一个文件（`history.config`）中。使用`history.config`文件，我们将`cat`命令重定向为使用原始文件——这将在控制台上显示。
- en: Using a double `>>`, we append an arbitrary string to the `history.config` file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双重`>>`，我们将一个任意字符串追加到`history.config`文件中。
- en: Finally, we end the script with redirection for both `stdout` and `stderr,`
    a `pipe,`, and the `tee`command. The `tee`command is useful because it can be
    used to display content even if it has been redirected to a file (as we just demonstrated).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用重定向结束脚本，同时重定向`stdout`和`stderr`，管道以及`tee`命令。`tee`命令很有用，因为即使内容已经重定向到文件，它仍然可以用来显示内容（就像我们刚才演示的那样）。
- en: Getting program input parameters
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取程序输入参数
- en: 'Retrieving program input parameters or arguments is very similar to function
    parameters at the most basic level. They can be accessed in the same fashion as
    `$1 (arg1)`, `$2 (arg2)`, `$3 (arg3)`, and so on. However, so far, we have seen
    a concept called **flags**, which allows you to perform neat things such as`-l`,
    `--long-version`, `-v 10`, `--verbosity=10`. **Flags** are effectively a user-friendly
    way to pass parameters or arguments to a program at runtime. For example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 获取程序输入参数或参数与获取函数参数的方式非常相似，在最基本的层面，它们可以像`$1 (arg1)`，`$2 (arg2)`，`$3 (arg3)`等一样访问。然而，到目前为止，我们已经看到了一种叫做**标志**的概念，它允许你执行一些漂亮的操作，比如`-l`、`--long-version`、`-v
    10`、`--verbosity=10`。**标志**实际上是一种用户友好的方式，可以在程序运行时传递参数或参数。例如：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now that you know what flags are and how they can be helpful to improve your
    script, use the following section as a template.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了标志是什么以及它们如何帮助你改进脚本，可以使用以下部分作为模板。
- en: Passing your program flags
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递程序标志
- en: 'After going into your shell and opening a new file in your favorite editor,
    let''s get started by creating a Bash script that does the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入Shell并打开你喜欢的编辑器中新建一个文件后，让我们开始创建一个Bash脚本，实现以下功能：
- en: When no flags or arguments are specified, prints out a help message
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有指定任何标志或参数时，它会打印帮助信息。
- en: When either the `-h` or `--help` flags are set, it prints out a help message
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置了`-h`或`--help`标志时，它会打印帮助信息。
- en: When the `-f` or `--firstname` flags are set, it sets the the first name variable
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置了`-f`或`--firstname`标志时，它会设置名字变量。
- en: When the `-l` or `--lastname` flags are set, it sets the the last name variable
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置了`-l`或`--lastname`标志时，它会设置姓氏变量。
- en: When *both* the `firstname` and `lastname` flags are set, it prints a welcome
    message and returns without error
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置了*`firstname`*和*`lastname`*标志时，它会打印欢迎信息并且不会报错。
- en: In addition to the basic logic, we can see that the code leverages a piece of
    functionality called `getopts`.Getopts allows us to grab the program parameter
    flags for use within our program. There are also primitives, which we have learned
    as well—conditional logic, while loop, and case/switch statements. Once a script
    develops into more than a simple utility or provides more than a single function,
    the more basic Bash constructs will become commonplace.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的逻辑之外，我们可以看到代码利用了一个叫做`getopts`的功能。Getopts允许我们抓取程序的参数标志，以便在程序中使用。还有一些我们也学过的基本构造——条件逻辑、while循环和case/switch语句。一旦脚本发展成不仅仅是一个简单的工具或提供多个功能时，更基础的Bash构造就会变得司空见惯。
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When we execute the preceding program, we should expect responses similar to
    the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的程序时，我们应该期待类似以下的响应：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Getting additional information about commands
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取有关命令的更多信息
- en: As we progress, you may see this book use many commands extensively and without
    exhaustive explanations. Without polluting this entire book with an introduction
    to Linux and useful commands, there are a couple of commands available that are
    really handy: `man`and `info`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入，您可能会看到本书广泛使用许多命令，且没有详尽的解释。为了不让本书充斥着Linux介绍和有用命令的内容，有几个非常实用的命令可供使用：`man`和`info`。
- en: 'The `man` command, or manual command, is quite extensive and even has multiple
    sections when the same entry exists in different categories. For the purposes
    of investigating executable programs or shell commands, category 1 is sufficient.
    Let''s look at the entry for the mount command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`man`命令，即手册命令，非常详细，甚至在同一条目在不同类别中存在时，有多个部分。对于调查可执行程序或Shell命令来说，第1类就足够了。我们来看一下mount命令的条目：'
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Alternatively, there is the `info` command, which will give you information
    should info pages exist for the item you are looking for.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有`info`命令，如果信息页面存在，它会为你提供相关信息。
- en: Getting used to the style of the man and info pages can easily save you time
    by allowing you to access information quickly, especially if you don't have the
    internet.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯`man`和`info`页面的风格，可以让你快速访问信息，从而节省时间，尤其是在没有网络连接时。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the concept of variables, types, and assignments.
    We also covered some basic Bash programming primitives for for loops, while, and
    switch statements. Later on, we learned what functions are, how they are used,
    and how to pass
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了变量、类型和赋值的概念。我们还介绍了一些基础的Bash编程原语，如for循环、while循环和switch语句。稍后，我们学习了函数的概念，它们的使用方式，以及如何传递
- en: parameters.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 参数。
- en: In the next chapter, we will learn about several bolt-on technologies to make
    Bash even more extensive.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习一些附加技术，使Bash更加强大。
