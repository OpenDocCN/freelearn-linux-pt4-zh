- en: Crash Course in Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of this chapter is to give you enough knowledge about the
    Linux shell/Bash to get you up and running, as that the remainder of the book
    will just fall into place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Bash and CLI fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using basic variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hidden Bash variables and reserved words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional logic using if, else, and elseif
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case/switch statements and loop constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using functions and parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing program input parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard in, standard out, and standard error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking commands using pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding more information about the commands used within Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will set you up with the basic knowledge needed to complete the
    recipes in the remaining chapters of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Bash and CLI fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to open a Linux terminal or shell. Depending on your flavor
    (distribution) of Linux, this will be done in one of several ways, but in Ubuntu,
    the easiest way is to navigate to the Applications menu and find one labeled terminal. The
    terminal or shell is the place where commands are entered by a user and executed
    in the same shell. Simply put, results (if any) are displayed, and the terminal
    will remain open, waiting for new commands to be entered. Once a shell has been
    opened, a *prompt* will appear, looking similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The prompt will be in the format of your `username@YourComputersHostName` followed
    by a delimiter. Throughout this cookbook, you will see commands with the user
    `rbrash`; this is short for the author's name (Ron Brash) and in you case, it
    will match your username.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may also look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `$` refers to a regular user and the `#` refers to root. In the Linux and
    Unix worlds, root refers to the *root user*, which is similar to the Windows Administrator
    user. It can be used to perform any manner of tasks, so caution should be used
    when using a user with root privileges. For example, the root user can access
    all files on the OS, and can also be used to delete any or all critical files
    used by the OS, which could render the system unusable or broken.
  prefs: []
  type: TYPE_NORMAL
- en: When a terminal or shell is run, the Bash shell is executed with a set of parameters
    and commands specific to the user's bash profile. This profile is often called
    the `.bashrc` and can be used to contain command aliases, shortcuts, environment
    variables, and other user enhancements, such as prompt colors. It is located at `~/.bashrc or ~/.bash_profile`.
  prefs: []
  type: TYPE_NORMAL
- en: '`~ or ~/` is a shortcut for your user’s home directory. It is synonymous with
    `/home/yourUserName/` , and for root, it is `/root`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your user''s Bash shell also contains a history of all of the commands run
    by the user (located in `~/.bash_history`), which can be accessed using the `history` command,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For example, your first command might be to use `ls` to determine the contents
    of the directory. The command `cd` is used to change the directory, to one directory
    in above the parent directory. The `pwd` command is used to return the complete
    path to the working directory (for example, where the terminal is currently navigated
    to).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another command you may execute on the shell might be the `whoami `command,
    which will return the user currently logged in to the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the concept of entering commands, we can put those (or any) commands
    into a *shell script*. In its most simplistic representation, a shell script looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line contains the path to the interpreter and tells the shell which
    interpreter to use when interpreting this script. The first line will *always*
    contain the shebang (`#!`) and the prefix to the path appended without a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A script cannot execute by itself; it needs to be executed by a user or to be
    *called* by another program, the system, or another script. The execution of a
    script also requires it to have *executable* permissions, which can be granted
    by a user so that it can become executable; this can be done with the `chmod` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add or *grant* basic executable permissions, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the script, one of the following methods can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the correct permissions are applied, and the shebang and Bash interpreter
    path is correct, you may alternatively use the following two commands to execute
    `script.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding command snippets, you might notice a few things regarding
    paths. The path to a script, file, or executable can be referred to using a *relative* address
    and a `full path`. Relative addressing effectively tells the interpreter to execute
    whatever may exist in the current directory or using the user's global shell `$PATH`
    variables. For example, the system knows that binaries or executable binaries
    are stored in `/usr/bin, /bin/ and /sbin` and will look there first. The full
    path is more concrete and *hardcoded;* the interpreter will try to use the complete
    path. For example, `/bin/ls or /usr/local/bin/myBinary`.
  prefs: []
  type: TYPE_NORMAL
- en: When you are looking to run a binary in the directory you are currently working
    in, you can use either `./script.sh`, bash `script.sh`, or even the full path.
    Obviously, there are advantages and disadvantages to each approach.
  prefs: []
  type: TYPE_NORMAL
- en: Hardcoded or full paths can be useful when you know exactly where a binary may
    reside on a specific system and you cannot rely on `$PATH` variables for potential
    security or system configuration reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Relative paths are useful when flexibility is required. For example, program
    `ABC` could be in location `/usr/bin` or in `/bin`, but it could be called simply
    with ABC instead of `/pathTo/ABC`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have covered what a basic Bash script looks like, and briefly introduced
    a few very basic, but essential commands and paths. However, to create a script—you
    need an editor! In Ubuntu, usually by default, you have a few editors available
    to you for the creation of a Bash script: vi/vim, nano, and gedit. There are a
    number of other text editors or **integrated development editors** (**IDEs**)
    available, but this is a personal choice and up to the reader to find one they 
    like. All of the examples and recipes in this book can be followed regardless
    of the text editor chosen.'
  prefs: []
  type: TYPE_NORMAL
- en: Without using a full-blown editor such as the popular Eclipse, Emacs or Geany
    may also be useful as flexible IDEs within resource-constrained environments,
    for example, a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of vi/vim and nano is very handy when you want to create or modify
    a script remotely over SSH and on the console. Vi/vim may seem a bit archaic,
    but it saves the day when your favorite editor is not installed or cannot be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Your first Bash script with Vim
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a script using improved version of vi (called `vim`).
    If Vim (VI-enhanced) is not installed, it can be installed with `sudo` or `root`
    using the following command (`-y` is short for yes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a terminal and enter the following commands to first see where your terminal
    is currently navigated to, and to create the script using `vim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The terminal window will transform into the Vim application (similar to the
    following screenshot) and you will be just about ready to program your first script.
    Simultaneously press the *Esc*+ *I* keys to enter Insert mode; there will be an
    indicator in the bottom left and the cursor block will begin to flash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/532afbdf-f9cf-433c-8975-2119517e937d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To navigate Vim, you may use any number of keyboard shortcuts, but the arrow
    keys are the simplest to move the cursor up, down, left, and right. Move the cursor
    to the beginning of the first line and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have already introduced the concept of a comment and a few basic commands,
    but we have yet to introduce the flexible `echo`command. The `echo` command can
    be used to print text to the console or into files, and the `-n` flag prints text
    without the end line character (end line has the same effect as pressing *Enter*
    on the keyboard)—this allows the output from the `whoami` and `pwd` commands to
    appear on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: The program also exits with a status of `0`, which means that it exited with
    a normal status. This will be covered later as we move toward searching or checking
    command exit statuses for errors and other conditions.
  prefs: []
  type: TYPE_NORMAL
- en: When you've finished, press *Esc* to exit insert mode; going back to command
    mode and typing `:` will allow you to write the vim command *w* + *q*. In summary,
    type the following key sequence: *Esc* and then *:wq*. This will exit Vim by writing
    to disk (w) and quitting (q), and will return you to the console.
  prefs: []
  type: TYPE_NORMAL
- en: More information about Vim can be obtained by reviewing its documentation using
    the Linux manual pages or by referring to a sibling book available from Packt
    ([https://www.packtpub.com/application-development/hacking-vim-72](https://www.packtpub.com/application-development/hacking-vim-72)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute your first script, enter the `bash my_first_script.sh`command and
    the console will return a similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations—you have created and executed your first Bash script. With these
    skills, you can begin creating more complex scripts to automate and simplify just
    about any daily CLI routines.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using basic variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to think of variables is as placeholders for values. They can
    be permanent (static) or transient (dynamic), and they will have a concept called **scope** (more
    on this later). To get ready to use variables, we need to think about the script
    you just wrote: `my_first_script.sh`. In the script, we could have easily used
    variables to contain values that are static (there every time) or dynamic ones
    created by running commands every time the script is run. For example, if we would
    like to use a value such as the value of `PI` (`3.14`), then we could use a variable
    like this short script snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If included in a full script, the script snippet would output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the idea of setting a value (`3.14`) to a variable is called assignment.
    We *assigned* the value of `3.14` to a variable with the name `PI`. We also referred
    to the `PI` variable using `$PI`. This can be achieved in a number of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'While the output is identical, the mechanisms are slightly different. In version
    1, we refer to the `PI` variable within double quotes, which indicates a **string
    (an array of characters)**. We could also use single quotes, but this would make
    this a **literal string**. In version 2, we refer to the variable inside of `{
    }` or *squiggly* brackets; this is useful for protecting the variable in cases
    where this would break the script. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If any variable is not declared and then we try to use it, that variable will
    be initialized to an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will convert a numeric value to a string representation.
    In our example, `$PI` is still a variable containing a number, but we could have
    created the `PI` variable like this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This would contain within the variable a string and not a numeric value such
    as **an integer or float**.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of data types is not explored to its fullest in this cookbook. It
    is best left as a topic for the reader to explore, as it is a fundamental concept
    of programming and computer usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait! You say there is a difference between a number and a string? Absolutely,
    because without conversion (or being set correctly in the first place), this may
    limit the things you can do with it. For example, 3.14 is not the same as 3.14
    (the number). 3.14 is made up of four characters: 3 + . + 1 +4\. If we wanted
    to perform multiplication on our PI value in string form, either the calculation/script
    would break or we would get a nonsensical answer.'
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about conversion later, in Chapter 2, *Acting like a Typewriter
    and File Explorer.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to assign one variable to another. We would do this like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the preceding snippet were within a functioning Bash script, we would get
    the value 10 for each variable.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on variable assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a new blank file and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice the nomenclature. It is great to use a standardized mechanism to name
    variables, but to use `STR_A` and `VAR_B` is clearly not descriptive enough if
    used multiple times. In the future, we will use more descriptive names, such as `VAL_PI`
    to mean the value of PI or `STR_BOBNAME` to mean the string representing Bob's
    name. In Bash, capitalization is often used to describe variables, as it adds
    clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press Save and exit to a terminal (open one if one isn''t already open). Execute
    your script after applying the appropriate permissions, and you should see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we saw how we can use three variables, assign values to each of then,
    and print them. Secondly, we saw through a demonstration that the interpreter
    can break when concatenating strings (let's keep this in mind). Thirdly, we printed
    out our `PI` variable and concatenated it to a string using `echo`. Finally, we
    performed a few more types of concatenation, including a final version, which
    converts a numeric value and appends it to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden Bash variables and reserved words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wait—there are hidden variables and reserved words? Yes! There are words you
    can't use in your script unless properly contained in a construct such as a string.
    Global variables are available in a **global context**, which means that they
    are visible to all scripts in the current shell or open shell consoles. In a later
    chapter, we will explore global shell variables more, but just so you're aware,
    know that there are useful variables available for you to reuse, such as `$USER`,
    `$PWD`, `$OLDPWD`, and `$PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a list of all shell environment variables, you can use the `env`command
    (the output has been cut short):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the `PATH` environment variable can be very useful. It can also be
    frustrating, because it contains the filesystem path to binaries. For example,
    you have binaries in `/bin` or `/sbin` or `/usr/bin`, but when you run a single
    command, the command is run without you specifying the path.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, so we have acknowledged the existence of pre-existing variables and
    that there could be new global variables created by the user or other programs.
    When using variables that have a high probability of being similarly named, be
    careful to make them specific to your application.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to hidden variables, there are also words that are reserved for
    use within a script or shell. For example, if and else are words that are used
    to provide conditional logic to scripts. Imagine if you created a command, variable,
    or function (more later on this) with the same name as one that already exists?
    The script would likely break or run an erroneous operation.
  prefs: []
  type: TYPE_NORMAL
- en: When trying to avoid any naming collisions (or namespace collisions), try to
    make your variables more likely to be used by your application by appending or
    prefixing an identifier that is likely to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: The following list contains some of the more common reserved words that you
    will encounter. Some of which are likely to look very familiar because they tell
    the Bash interpreter to interpret any text in a specific way, redirect output,
    run an application in the background, or are even used in other programming/scripting
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: '`if`, `elif`, `else`, `fi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`, `do`, `for`, `done`, `continue`, `break`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case`, `select`, `time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`function`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&`, `|`, `>`, `<`, `!`, `=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#`, `$`, `(, )`, `;`, `{, }`, `[, ]`, `\`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the full reference, go to: [https://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html](https://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last element in the list contains an array of specific characters that
    tell Bash to perform specific functionalities. The pound sign signifies a comment
    for example. However, the backslash `\`is very special because it is an **escape
    character**. Escape characters are used to *escape* or *stop* the interpreter
    from executing specific functionality when it sees those particular characters.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Escaping characters will become very useful in [Chapter 2](b71b7795-5b29-4a02-90a0-294283079dc8.xhtml),
    *Acting like a Typewriter and File Explorer*, when working with strings and single/double
    quotes.
  prefs: []
  type: TYPE_NORMAL
- en: The escape character prevents the execution of the next character after the
    forward slash. However, this is not necessarily consistent when working with carriage
    returns (`\n`, `\r\n`) and null bytes (`\0`).
  prefs: []
  type: TYPE_NORMAL
- en: Conditional logic using if, else, and elseif
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous section introduced the concept that there are several reserved
    words and a number of characters that have an effect on the operation of Bash.
    The most basic, and probably most widely used conditional logic is with `if` and
    `else` statements. Let''s use an example code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice the space after or before the square brackets in the `if` statement.
    Bash is particularly picky about the syntax of bracketing.
  prefs: []
  type: TYPE_NORMAL
- en: If we are evaluating the variable `age` using less than (`<`) or `-lt` (Bash
    offers a number of syntactical constructs for evaluating variables), we need to
    use an `if` statement. In our `if` statement, if `$AGE` is less than `18`, we
    echo the message `You must be 18 or older to see this movie`. Otherwise, the script
    will not execute the `echo` statement and will continue execution. Notice that
    the `if` statement ends with the reserved word `fi`. This is not a mistake and
    is required by Bash syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to add a catchall using `else`. If the `then` command block
    of the `if` statement is not satisfied, then the `else` will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With `AGE` set to the integer value `40`, the `then` command block inside the `if`
    statement will not be satisfied and the `else` command block will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating binary numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we want to introduce another `if` condition and use `elif` (short
    for *else if*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `if`, `elif`, and `else`, combined with other evaluations, we can execute
    specific branches of logic and functions or even exit our script. To evaluate
    raw binary variables, use the following **operators**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-gt` (greater than >)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ge` (greater or equal to >=)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-lt` (less than <)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-le` (less than or equal to <=)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-eq` (equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-nq` (not equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the variables subsection, numeric values are different from
    strings. Strings are typically evaluated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If `MY_NAME` is equal to `Ron`, then `echo "Ron is home from vacation"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Else if `MY_NAME` is not equal to `NAME_1` **AND** `MY_NAME` is not equal to `NAME_2`
    **AND** `MY_NAME` is equal to `John`, then `echo "John is home after some unnecessary
    AND logic"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Else if `MY_NAME` is equal to `NAME_3` **OR** `MY_NAME` is equal to `NAME_4`,
    then `echo "Looks like one of the ladies"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Else `echo "Who is this stranger?"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice the operators: `&&`, `||`, `==`, and `!=`'
  prefs: []
  type: TYPE_NORMAL
- en: '`&&` (means and)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`||` (means or)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`==` (is equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=` (not equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n` (is not null or is not set)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-z` (is null and zero length)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null means not set or empty in the world of computing. There are many different
    types of operators or tests that can be used in your scripts. For more information,
    check out:[ http://tldp.org/LDP/abs/html/comparison-ops.html](http://tldp.org/LDP/abs/html/comparison-ops.html)
    and [https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic](https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic)
  prefs: []
  type: TYPE_NORMAL
- en: You can also evaluate numbers as if they are strings using `(("$a" > "$b"))`
    or `[[ "$a" > "$b" ]]`. Notice the usage of double parentheses and square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Nested if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a single level of `if` statements is not enough and you would like to have
    additional logic within an `if` statement, you can create **nested conditional
    statements**. This can be done in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Case/switch statements and loop constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides `if` and `else` statements, Bash offers case or switch statements and
    loop constructs that can be used to simplify logic so that it is more readable
    and sustainable. Imagine creating an `if` statement with many `elif` evaluations.
    It would become cumbersome!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In a large number of blocks of conditional logic of `if` and `elifs`, each `if`
    and `elif` needs to be evaluated before executing a specific branch of code. It
    can be faster to use a case/switch statement, because the first match will be
    executed (and it looks prettier).
  prefs: []
  type: TYPE_NORMAL
- en: Basic case statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of `if`/`else` statements, you can use **case statements** to evaluate
    a variable. Notice that `esac` is case backwards and is used to exit the case
    statement similar to `fi` for `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case statements follow this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a working example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Basic loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you imagine iterating through a list of files or a dynamic array and monotonously
    evaluating each and every one? Or waiting until a condition was true? For these
    types of scenarios, you may want to use a **for loop, a do while loop, or an until
    loop **to improve your script and make things easy. For loops, do while loops,
    and until loops may seem similar, but there are subtle differences between them.
  prefs: []
  type: TYPE_NORMAL
- en: For loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop is usually used when you have multiple tasks or commands to
    execute for each of the entries in an array or *want to execute a given command
    on a finite number of items*. In this example, we have an array (or list) containing
    three elements: `file1`, `file2`, and `file3`. The `for` loop will `echo` each
    element within `FILES` and exit the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Do while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an alternative, we have included the `do while` loop. It is similar to a
    `for` loop, but better suited to *dynamic conditions*, such as when you do not
    know when a value will be returned or performing a task until a condition is met.
    The condition within the square brackets is the same as an *if* statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Until loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For completeness, we have included the `until` loop. It is not used very often
    and is almost the same as a `do while` loop. Notice that its condition and operation
    is consistent with incrementing a counter `until` a value is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using functions and parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the book, we have mentioned that function is a reserved word and only
    used in Bash scripts that are in a single procedure, but what is a function?
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate what a function is, first we need to define what a function is—a** function**
    is a self-contained section of code that performs a single task. However, a function
    performing a task may also execute many subtasks in order to complete its main
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could have a function called `file_creator` that performs
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Check to see whether a file exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file exists, truncate it. Otherwise, create a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the correct permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A function can also be passed parameters. **Parameters** are like variables
    that can be set outside of a function and then used within the function itself.
    This is really useful because we can create segments of code that perform generic
    tasks that are reusable by other scripts or even within loops themselves. You
    may also have **local **variables that are not accessible outside of a function
    and for usage only within the function itself. So what does a function look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the simple script, there is a function declared as `my_function`
    using the `function`reserved word. The content of the function is contained within
    the squiggly brackets `{}` and introduces three new concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameters** are referred to systematically like this: `$1` for parameter
    1, `$2` for parameter 2, `$3` for parameter 3, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `local` keyword refers to the fact that variables *declared*with this keyword
    remain accessible only within this function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can call functions merely by name and use parameters simply by adding them,
    as in the preceding example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next section, we''ll dive into a more realistic example that should
    drive the point home a bit more: functions are helpful everyday and make functionality
    from any section easily reusable where appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a function with parameters within a for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this short example, we have a function called `create_file`, which is called
    within a loop for each file in the `FILES` array. The function creates a file,
    modifies its permissions, and then passively checks for its existence using the
    `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Including source files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to functions, we can also create multiple scripts and include them
    such that we can utilize any shared variables of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a library or utility script that contains a number of functions
    useful for creating files. This script by itself could be useful or **reusable **for
    a number of scripting tasks, so we make it program neutral. Then, we have another
    script, but this one is dedicated to a single task: performing useless file system
    operations (IO). In this case, we would have two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`io_maker.sh` (which includes `library.sh` and uses `library.sh` functions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`library.sh` (which contains declared functions, but does not execute them)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `io_maker.sh` script simply imports or includes the `library.sh` script
    and inherits knowledge of any global variables, functions, and other inclusions.
    In this manner, `io_maker.sh` effectively thinks that these other available functions
    are its own and can execute them as if they were contained within it.
  prefs: []
  type: TYPE_NORMAL
- en: Including/importing a library script and using external functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To prepare for this example, create the following two files and open both:'
  prefs: []
  type: TYPE_NORMAL
- en: '`io_maker.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`library.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside `library.sh`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `io_maker.sh`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the script, you should get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Although not obvious, we can see that both functions are executed. The first
    line of output is the `ls`command, successfully finding `my_test_file.txt` after
    creating the file in `create_file()`. In the second line, we can see that ls returns
    an error when we delete the file passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, up until now, we have only been able to create and call functions,
    and execute commands. The next step, discussed in the next section, is to retrieve
    commands and function return codes or strings.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving return codes and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have been using a command called `exit` intermittently to exit
    scripts. For those of you who are curious, you may have already scoured the web
    to find out what this command does, but the key concept to remember is that *every*
    script, command, or binary exits with a *return code*. Return codes are numeric
    and are limited to being between0-255 because an unsigned 8-bit integer is used.
    If you use a value of `-1`, it will return `255`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so return codes are useful in which ways? Return codes are useful when
    you want to know whether you found a match when performing a match (for example),
    and whether the command was completely successfully or there was an error. Let''s
    dig into a real example using the `ls` command on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the return values? `0` or `2` in this example mean either success (0)
    or that there are errors (1 and 2). These are obtained by retrieving the `$?`
    variable and we could even set it to a variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: From this example, we now know what return codes are, and how we can use them
    to utilize results returned from functions, scripts, and commands.
  prefs: []
  type: TYPE_NORMAL
- en: Return code 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dig into your terminal and create the following Bash script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will output the following before exiting with a return code of `0`
    (remember that ls returns `0` if run successfully):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, there are three functions that leverage three concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_function_global` uses a `global`variable to return the command''s return
    code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`my_function_return` uses the reserved word, `return`**, **and a value (the
    command''s return code)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`my_function_str` uses a `fork` (a special operation) to execute a command
    and get the output (our string, which is echoed)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For option 3, there are several ways to get a string back from a function, including
    using the `eval`keyword. However, when using fork, it is best to be aware of the
    resources it may consume when running the same command many times just to get
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: Linking commands, pipes, and input/output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is probably one of the most important in the book because it describes
    a fundamental and powerful feature on Linux and Unix: the ability to use pipes
    and redirect input or output. By themselves, pipes are a fairly trivial feature
    - commands and scripts can redirect their output to files or commands. So what?
    This could be considered a massive understatement in the Bash scripting world,
    because pipes and redirection allow you to enhance commands with the functionality
    of other commands or features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into this with an example using commands called `tail` and `grep`.
    In this example, the user, Bob, wants to look at his logs in real time (live),
    but he only wants to find the entries related to the wireless interface. The name
    of Bob''s wireless device can be found using the `iwconfig`command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iwconfig` command is deprecated now. The following commands also will
    give you wireless interface information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now that Bob knows his wireless card's identifying name (`wlp3s0`), Bob can
    search his system's logs. It is usually found within `/var/log/messages`. Using
    the `tail`command and the `-F` flag, which allows continuously outputting the
    logs to the console, Bob can now see *all* the logs for his system. Unfortunately,
    he would like to filter the logs using `grep`, such that only logs with the keyword `wlp3s0`are
    visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob is faced with a choice: does he search the file continuously, or can he combine
    `tail` and `grep` together to get the results he desires? The answer is yes—using *pipes*!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As new logs come in, Bob can now monitor them in real time and can stop the
    console output using *Ctrl*+*C*.
  prefs: []
  type: TYPE_NORMAL
- en: Using pipes, we can combine commands into powerful hybrid commands, extending
    the best features of each command into one single line. Remember pipes!
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage and flexibility of pipes should be relatively straightforward, but
    what about directing the input and output of commands? This requires the introduction
    of three commands to get information from one place to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stdin` (standard in)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdout` (standard out)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stderr` (standard error)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are thinking about a *single* program, `stdin` is anything that can be
    provided to it, usually either as a parameter or a user input, **using read **for
    example. `Stdout` and `stderr` are two **streams** where output can be sent. Usually,
    output for both is sent to the console for display, but what if you only want
    the errors within the `stderr` stream to go to a file?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the difference between a single `>` and double `>>`. A single `>`
    **will truncate** any file that will have output directed to it, while `>>` **will
    append** any file.
  prefs: []
  type: TYPE_NORMAL
- en: There is a common error when redirecting both `stderr` and `stdout` to the same
    file. Bash should pick up the output to a file first, and then the duplication
    of the output file descriptors. For more information on file descriptors, see: [https://en.wikipedia.org/wiki/File_descriptor](https://en.wikipedia.org/wiki/File_descriptor)
    `# This is correct`
  prefs: []
  type: TYPE_NORMAL
- en: '`ls ~/ > everything.txt 2>&1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# This is erronous`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ls ~/ 2>&1> everything.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics of one of the most powerful features available in
    Bash, let's try an example—redirection and pipes bonzanza.
  prefs: []
  type: TYPE_NORMAL
- en: Redirection and pipe bonzanza
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a shell and create a new bash file in your favorite editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: First, `ls` is a way of producing an error and, instead of pushing erroneous
    output to the console, it is instead redirected to a special device in Linux called `/dev/null`. `/dev/null`
    is particularly useful as it is a dump for any input that will not be used again.
    Then, we combine the `cat`command with `grep`to find any lines of text with a
    pipe and use a fork to capture the output to a variable (`HISTORY_TEXT`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we echo the contents of `HISTORY_TEXT` to a file (`history.config`) using
    a `stdout` redirect. Using the `history.config`file, we redirect cat to use the
    raw file—this will be displayed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Using a double `>>`, we append an arbitrary string to the `history.config` file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we end the script with redirection for both `stdout` and `stderr,`
    a `pipe,`, and the `tee`command. The `tee`command is useful because it can be
    used to display content even if it has been redirected to a file (as we just demonstrated).
  prefs: []
  type: TYPE_NORMAL
- en: Getting program input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Retrieving program input parameters or arguments is very similar to function
    parameters at the most basic level. They can be accessed in the same fashion as
    `$1 (arg1)`, `$2 (arg2)`, `$3 (arg3)`, and so on. However, so far, we have seen
    a concept called **flags**, which allows you to perform neat things such as`-l`,
    `--long-version`, `-v 10`, `--verbosity=10`. **Flags** are effectively a user-friendly
    way to pass parameters or arguments to a program at runtime. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know what flags are and how they can be helpful to improve your
    script, use the following section as a template.
  prefs: []
  type: TYPE_NORMAL
- en: Passing your program flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After going into your shell and opening a new file in your favorite editor,
    let''s get started by creating a Bash script that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When no flags or arguments are specified, prints out a help message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When either the `-h` or `--help` flags are set, it prints out a help message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `-f` or `--firstname` flags are set, it sets the the first name variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `-l` or `--lastname` flags are set, it sets the the last name variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When *both* the `firstname` and `lastname` flags are set, it prints a welcome
    message and returns without error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the basic logic, we can see that the code leverages a piece of
    functionality called `getopts`.Getopts allows us to grab the program parameter
    flags for use within our program. There are also primitives, which we have learned
    as well—conditional logic, while loop, and case/switch statements. Once a script
    develops into more than a simple utility or provides more than a single function,
    the more basic Bash constructs will become commonplace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the preceding program, we should expect responses similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Getting additional information about commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress, you may see this book use many commands extensively and without
    exhaustive explanations. Without polluting this entire book with an introduction
    to Linux and useful commands, there are a couple of commands available that are
    really handy: `man`and `info`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `man` command, or manual command, is quite extensive and even has multiple
    sections when the same entry exists in different categories. For the purposes
    of investigating executable programs or shell commands, category 1 is sufficient.
    Let''s look at the entry for the mount command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, there is the `info` command, which will give you information
    should info pages exist for the item you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Getting used to the style of the man and info pages can easily save you time
    by allowing you to access information quickly, especially if you don't have the
    internet.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of variables, types, and assignments.
    We also covered some basic Bash programming primitives for for loops, while, and
    switch statements. Later on, we learned what functions are, how they are used,
    and how to pass
  prefs: []
  type: TYPE_NORMAL
- en: parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about several bolt-on technologies to make
    Bash even more extensive.
  prefs: []
  type: TYPE_NORMAL
