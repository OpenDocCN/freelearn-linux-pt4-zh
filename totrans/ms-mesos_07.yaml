- en: Chapter 7. Mesos Containerizers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 Mesos容器化器
- en: 'This chapter briefly introduces the concepts of **containers,** and talks a
    bit about **Docker**, probably the most popular container technology available
    today. It also provides a detailed overview of the different *containerizer* options
    in Mesos besides introducing some other topics such as networking for Mesos-managed
    containers and fetcher cache. Finally, an example for deploying containerized
    apps in Mesos is provided for better understanding. The following topics will
    be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了**容器**的概念，并稍微谈了一下**Docker**，可能是当今最流行的容器技术。它还提供了Mesos中不同*容器化器*选项的详细概述，并介绍了其他一些主题，如Mesos管理的容器的网络配置和获取器缓存。最后，提供了一个在Mesos中部署容器化应用的示例，帮助更好地理解。以下是本章将涵盖的主题：
- en: Containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Mesos Containerizer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos容器化器
- en: Mesos Containerizer
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos容器化器
- en: Docker Containerizer
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器化器
- en: Composing Containerizer
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化器组合
- en: Networking for Mesos-managed containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos管理的容器网络
- en: Mesos Image Provisioning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos镜像提供
- en: Fetcher Cache
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器缓存
- en: Deploying containerized apps using Docker and Mesos
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker和Mesos部署容器化应用
- en: Containers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: A Linux Container, (referred to simply as container for the rest of this chapter)
    allows applications to run on an allocated share of resources within an isolated,
    individual environment. Since all containers share the **Operating system (OS)**
    of the host machine and do not require the OS to be loaded up, they can be created
    in a matter of seconds.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器（在本章其余部分简单称为容器）允许应用程序在分配的资源份额内，在一个隔离的、独立的环境中运行。由于所有容器共享宿主机的**操作系统（OS）**，并且不需要加载操作系统，因此它们可以在几秒钟内创建。
- en: Container technology, based on operating system level virtualization, has been
    present for over a decade now. OS level virtualization is a method by which an
    OS kernel allows creation of many user namespace instances (also called containers)
    instead of only one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基于操作系统级虚拟化的容器技术已经存在十多年。操作系统级虚拟化是一种方法，它允许操作系统内核创建多个用户命名空间实例（也称为容器），而不是仅创建一个。
- en: We can look at containers as encapsulated, individually deployable components
    running as isolated instances on the same kernel. Containers have a big advantage
    over traditional technologies such as bare metal, meaning servers with an operating
    system or virtualized environments such as **Microsoft Hyper-V**. From a developer's
    point of view, we can just package our application and dependencies into a container,
    and deploy it to any environment that supports containers. By doing this, we also
    make our application easy to update, upgrade, and even easily portable from one
    environment to another, for example, from a development environment on the desktop
    to a test environment in the cloud.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将容器看作是封装的、可单独部署的组件，这些组件作为隔离的实例在同一个内核上运行。容器相较于传统技术，如裸金属服务器（具有操作系统的服务器）或虚拟化环境（如**Microsoft
    Hyper-V**）有很大的优势。从开发者的角度来看，我们只需将应用程序及其依赖项打包到一个容器中，并将其部署到任何支持容器的环境中。通过这样做，我们还使得我们的应用程序容易更新、升级，甚至可以轻松地从一个环境迁移到另一个环境，例如从桌面上的开发环境迁移到云中的测试环境。
- en: 'Two popular models for containers are:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 两种流行的容器模型是：
- en: '**Hypervisor-based**: The hypervisor-based model includes redundant OS kernels
    and other libraries, which makes this an inefficient setup, as shown in the subsequent
    image (source: [http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/](http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/)):![Containers](img/B05186_07_01.jpg)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于虚拟机监控程序**：基于虚拟机监控程序的模型包括冗余的操作系统内核和其他库，这使得该设置效率低下，如下图所示（来源：[http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/](http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/))：![Containers](img/B05186_07_01.jpg)'
- en: '**Container-based**: The container-based approach involves encapsulated, individually
    deployable components running as isolated instances on the same kernel, as shown
    in the following image (source: [http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/](http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/)):![Containers](img/B05186_07_02.jpg)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于容器**：基于容器的方法涉及封装的、可单独部署的组件，这些组件作为隔离的实例在同一个内核上运行，如下图所示（来源：[http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/](http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/))：![Containers](img/B05186_07_02.jpg)'
- en: Why containers?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择容器？
- en: 'The following are some important benefits of using containers are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用容器的一些重要好处：
- en: Application-centric management
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以应用程序为中心的管理
- en: Separation of deployment and build
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和构建的分离
- en: Simplifies the application deployment process
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化应用程序部署过程
- en: Supports Agile development through Continuous Integration and deployment
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过持续集成和部署支持敏捷开发
- en: Allows breakdown of large monolithic applications into manageable micro-services
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许将大型单体应用程序拆分为可管理的微服务
- en: Infrastructure environment consistency
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施环境一致性
- en: High portability
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可移植性
- en: Resource isolation
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源隔离
- en: Resource utilization
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源利用率
- en: Docker
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: '**Docker** is an open-source platform that automates the process by which any
    application is deployed in the form of a container that is portable, lightweight,
    self-sufficient, and which can run virtually anywhere. Primarily based on the
    **LXC** or **Linux Container**, Docker is used by developers and system administrators
    while working with distributed applications. Rather than being an underlying technology,
    this platform acts as a comprehensive abstraction layer that enables developers
    to *package* or *containerize* an application, including its dependencies, and
    run it on any infrastructure. Simply put, Docker containers function like shipping
    containers which offer a standard and reliable way of shipping literally any application.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker** 是一个开源平台，自动化了任何应用程序部署为容器的过程，这些容器是便携的、轻量级的、自给自足的，并且可以在几乎任何地方运行。Docker
    主要基于 **LXC** 或 **Linux 容器**，开发人员和系统管理员在处理分布式应用程序时使用它。它不仅仅是一个底层技术，而是充当一个综合的抽象层，使开发人员能够将应用程序及其依赖项进行*打包*或*容器化*，并在任何基础设施上运行。简单来说，Docker
    容器就像货运集装箱，提供了一种标准且可靠的方式来运输任何应用程序。'
- en: Docker provides the Development and IT Operations teams with much needed agility
    and control to 'build, ship, and run any app, anywhere.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 为开发和 IT 运维团队提供了急需的敏捷性和控制能力，使其能够“构建、分发和运行任何应用程序，随时随地”。
- en: '**Build**: Docker gives you the flexibility to create an application from micro-services,
    and not worry about probable inconsistencies between the production and development
    environments. Additionally, there is no restriction on using any particular platform
    or language.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：Docker 赋予您从微服务创建应用程序的灵活性，并且不必担心生产和开发环境之间可能存在的不一致性。此外，使用任何特定平台或语言都不受限制。'
- en: '**Ship**: Docker allows you to design the entire cycle comprising application
    development, testing, and distribution, and simplifies its management via a consistent
    user interface.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分发**：Docker 允许您设计包含应用程序开发、测试和分发的整个周期，并通过一致的用户界面简化其管理。'
- en: '**Run**: Docker offers you the ability to choose from a variety of platforms
    to deploy scalable services in a secure and reliable fashion.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**：Docker 使您能够选择多种平台，以安全、可靠的方式部署可扩展的服务。'
- en: However, the chief advantage of Docker is that it presents an 'application first'
    architecture, which also allows developers and IT Ops / System Admins to focus
    on their core job functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Docker 的主要优势在于它提供了一个“应用优先”的架构，这也允许开发人员和 IT 运维/系统管理员专注于他们的核心职能。
- en: '**Developers**: They are concerned only with what''s *inside* the container,
    such as their code, data, apps, libraries, and the package manager.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发人员**：他们只关注容器内部的内容，如代码、数据、应用程序、库和包管理器。'
- en: '**IT Ops**: They have to focus on what''s *outside* the container, namely logging,
    monitoring, remote access, and network configuration'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IT 运维**：他们需要关注容器外部的内容，即日志、监控、远程访问和网络配置。'
- en: What Docker essentially brings to the table can be effectively summarized in
    the following points:-
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 本质上带来的好处可以有效地总结为以下几点：-
- en: '**Agility**: Using Docker, a developer has the freedom to define an environment.
    Creation and deployment of apps can be carried out in a fast and easier manner
    with IT ops having the flexibility to rapidly respond to change.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏捷性**：使用 Docker，开发人员可以自由定义环境。应用程序的创建和部署可以更快、更轻松地完成，IT 运维能够灵活地快速响应变化。'
- en: '**Control**: Ensures that ownership of the code, all the way from infrastructure
    to the app, lies solely with the developer. The IT operations governs the manageability
    aspect in terms of standardizing, securing, and scaling the operating environment.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**：确保从基础设施到应用程序的代码的所有权仅属于开发人员。IT 运维负责管理方面，确保操作环境的标准化、安全性和可扩展性。'
- en: '**Portability**: Gives you the choice, minus the complexity, of working with
    a single developer or a team, and using private infrastructure or public cloud
    providers.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：让你可以选择与单个开发人员或团队一起工作，使用私有基础设施或公共云提供商，同时避免复杂性。'
- en: For a better understanding of the platform, let us look at some of the core
    terms associated with the Docker solution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解该平台，让我们来看一下与 Docker 解决方案相关的一些核心术语。
- en: '**Image**: Basis of a Docker container when it is at rest. When instantiated
    through a Docker run command, they turn into a container.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**：Docker 容器在静态时的基础。当通过 Docker run 命令实例化时，它们会变成一个容器。'
- en: '**Dockerfile**: Its main function is to inform the image builder as to what
    the image has to look like.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile**：其主要功能是告知镜像构建器镜像应该是什么样子的。'
- en: '**Docker Engine**: Can be installed on physical, virtual, or cloud hosts. This
    provides several core functions, which include the ability to pull Docker images,
    create and run new containers, scale existing containers, or stop and remove them.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Engine**：可以安装在物理、虚拟或云主机上。它提供了多个核心功能，包括拉取 Docker 镜像、创建和运行新容器、扩展现有容器，或停止和移除容器。'
- en: '**Container**: These are built from Docker images. Their lightweight nature
    is attributed to the fact that they share image layer, and use union filesystems.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：这些是从 Docker 镜像构建的。它们的轻量特性归因于镜像层的共享和联合文件系统的使用。'
- en: '**Registry**: This is where Docker images are managed, distributed, and also
    stored.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册表**：这是管理、分发和存储 Docker 镜像的地方。'
- en: '**Docker Hub**: This is Docker''s hosted registry service for managing images.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**：Docker 提供的托管镜像注册表服务，用于管理镜像。'
- en: '**Docker Machine**: This automates container provisioning on the chosen network
    or in the cloud. It can be installed on machines on Linux, Windows or, Mac OS
    X.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Machine**：它自动化了在选定的网络或云环境中容器的配置。可以安装在 Linux、Windows 或 Mac OS X 的机器上。'
- en: '**Docker Compose**: This defines applications that require multiple containers.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Compose**：定义需要多个容器的应用程序。'
- en: '**Docker Toolbox**: This delivers all the Docker tools consisting of Engine,
    Machine, Compose, and Kitematic to a Mac OS X or Windows system.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 工具箱**：将所有 Docker 工具（包括 Engine、Machine、Compose 和 Kitematic）提供给 Mac
    OS X 或 Windows 系统。'
- en: '**Docker Trusted Registry** (**DTR**): This provides a private, dedicated image
    registry.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 受信任注册表** (**DTR**)：提供一个私有的、专用的镜像注册表。'
- en: '**Docker Swarm**: This is used to host clusters and schedule containers.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Swarm**：用于托管集群和调度容器。'
- en: '**Kitematic**: Basically a Desktop GUI for Docker.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kitematic**：基本上是 Docker 的桌面图形界面（GUI）。'
- en: A basic Docker system is shown in the following image.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个基本的 Docker 系统。
- en: '![Docker](img/B05186_07_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Docker](img/B05186_07_03.jpg)'
- en: As can be seen in the preceding diagram, a Docker container encloses a piece
    of software with everything that it needs to run, such as code, runtime, system
    libraries/tools. This encapsulation and isolation provided by a container warrants
    that the container will run in the same manner, irrespective of the environment
    it is run in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，Docker 容器封装了一个软件及其运行所需的所有内容，如代码、运行时、系统库/工具。容器提供的这种封装和隔离性确保了容器在任何运行环境下都能以相同的方式运行。
- en: 'A virtual machine and a Docker container is shown in the following image (source:
    [http://www.jayway.com/2015/03/21/a-not-very-short-introduction-to-docker/](http://www.jayway.com/2015/03/21/a-not-very-short-introduction-to-docker/)):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了虚拟机和 Docker 容器的对比（来源：[http://www.jayway.com/2015/03/21/a-not-very-short-introduction-to-docker/](http://www.jayway.com/2015/03/21/a-not-very-short-introduction-to-docker/)）：
- en: '![Docker](img/B05186_07_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Docker](img/B05186_07_04.jpg)'
- en: The figure that we just saw showcases the architectural difference between a
    virtual machine and a Docker container. The Docker container comprises only the
    application and its associated dependencies, and thus enjoys the benefits of both
    resource isolation and allocation like virtual machines, but is far more efficient
    and portable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的图示展示了虚拟机与 Docker 容器在架构上的差异。Docker 容器仅包含应用程序及其相关依赖，因此享有类似虚拟机的资源隔离和分配的好处，但效率更高且更具可移植性。
- en: Docker's pluggable architecture is further leveraged by the presence of several
    open APIs (Swarm, Compose, Hub, and so on), which support the creation of an ecosystem
    with seamless application delivery. It is this combination that empowers Docker
    containers to make distributed applications composable, portable, dynamic, and
    ideal for agile teams.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的可插拔架构通过多个开放 API（如 Swarm、Compose、Hub 等）的存在得到了进一步的利用，这些 API 支持创建一个无缝的应用交付生态系统。正是这种结合，使得
    Docker 容器能够使分布式应用程序具有组合性、可移植性、动态性，且非常适合敏捷团队。
- en: 'Docker High-Level Architecture is shown in the subsequent image (source: [http://www.docker.com](http://www.docker.com)):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 高级架构如后续图片所示（来源：[http://www.docker.com](http://www.docker.com)）：
- en: '![Docker](img/B05186_07_05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Docker](img/B05186_07_05.jpg)'
- en: 'These advantages become increasingly apparent when we consider some enterprise
    use cases wherein organizations have used the Docker platform to tackle certain
    technical or business challenges:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑一些企业的使用案例时，这些优势变得愈发明显，在这些案例中，组织利用 Docker 平台解决了一些技术或业务挑战：
- en: '**Continuous Integration**: Powered by integration with tools like GitHub and
    Jenkins, Docker provides developers the ability to develop and test applications
    faster and within an environment of their choice. The entire process is perfectly
    streamlined with developers being able to submit code in GitHub, test it, and
    automatically trigger a build via Jenkins. The moment the image is complete, it
    can be easily added to the Docker registries. This functionality not only saves
    time on build and setup processes, but allows developers to automate the running
    of tests while they simultaneously work on other projects. Add to this the absence
    of inconsistencies while dealing with different types of environments, and you
    get a substantial improvement in efficiency levels on using Docker for continuous
    integration jobs.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成**：通过与 GitHub 和 Jenkins 等工具的集成，Docker 使开发者能够更快地开发和测试应用，并在他们选择的环境中进行。整个过程被完美地简化，开发者可以在
    GitHub 中提交代码，进行测试，并自动触发 Jenkins 构建。当镜像构建完成时，可以轻松地将其添加到 Docker 仓库。这一功能不仅节省了构建和设置的时间，还允许开发者在同时处理其他项目时，自动运行测试。再加上处理不同类型环境时不会出现不一致问题，使用
    Docker 进行持续集成工作时，效率得到了显著提高。'
- en: '**Continuous Delivery**: In addition to being language agnostic, Docker works
    in any environment and effectively eliminates problems arising out of irregularities
    between environments. Docker guarantees continuous delivery of code to quality
    assurance teams and customers in a manner that is quick, easy to consume, and
    supportive of a speedy resolution of issues. Combined with Docker registries,
    the integration with other production platforms such as Docker Universal Control
    Plane and Tutum, facilitates code to be distributed to teams that can fully test
    it within the staging environment itself, before placing it into production. This
    aids enterprises by reducing the time and money required to build and ship applications.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续交付**：除了语言无关性外，Docker 在任何环境中都能工作，有效消除了因环境不一致而产生的问题。Docker 保证将代码以快速、易于消费并支持迅速解决问题的方式，持续交付给质量保证团队和客户。结合
    Docker 仓库，以及与其他生产平台如 Docker Universal Control Plane 和 Tutum 的集成，使得代码能够分发给团队，团队可以在上线前在预发布环境中完全测试代码。这帮助企业减少了构建和交付应用所需的时间和费用。'
- en: '**DevOps**: With organizations increasingly adopting the DevOps philosophy,
    Docker provides key tools that assist both developers and operations teams in
    improvising the application development process. These tools break down the traditional
    barrier between the aforesaid teams by compartmentalizing their work and concern
    areas.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevOps**：随着组织越来越多地采用 DevOps 哲学，Docker 提供了帮助开发和运维团队改进应用开发流程的关键工具。这些工具通过将开发和运维团队的工作及关注点进行分隔，打破了传统的团队间壁垒。'
- en: '**Big Data**: Enterprises today are moving to big data systems/technologies
    in a bid to derive deep and comprehensive analysis of the data they collect. However,
    data sources are variant and multiple (images, videos, metadata and so on). Herein
    lies the advantage of utilizing a system that can uniformly transport data across
    analytics platforms. The adoption of the Docker platform provides a significant
    competitive advantage, because it facilitates the unobstructed movement of applications
    across different types of environments to ensure seamless data analysis.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大数据**：如今，企业正在转向大数据系统/技术，旨在对他们收集的数据进行深入和全面的分析。然而，数据源多种多样（如图像、视频、元数据等）。这时，利用一种可以统一在分析平台之间传输数据的系统，就显得尤为重要。采用
    Docker 平台提供了显著的竞争优势，因为它促进了应用程序在不同环境之间的自由流动，从而确保了数据分析的无缝进行。'
- en: '**Infrastructure Optimization**: Unlike virtual machines that require a guest
    OS or hypervisor, Docker containers consist of only what is necessary to build,
    ship, and run applications. Add to this the ability to spin up or down containers
    based on requirements, and Docker proves to be a great value-add to enterprises.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施优化**：与需要客户端操作系统或虚拟机管理程序的虚拟机不同，Docker 容器仅包含构建、分发和运行应用程序所需的内容。再加上根据需求启动或停止容器的能力，Docker
    对企业来说是一个极具价值的附加工具。'
- en: Docker goes a step further and provides cloud portability that frees IT ops
    teams from being tied down to specific environment tools. Effectively, Docker
    reduces the amount of storage and infrastructure costs for enterprises, and also
    increases efficiency.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 进一步提供了云端可移植性，解放了 IT 运维团队，使其不再受限于特定的环境工具。实际上，Docker 减少了企业的存储和基础设施成本，并提高了效率。
- en: Containerizer
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化工具
- en: 'Containers, as described in the previous section, are used for the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，容器用于以下目的：
- en: Isolating a task from other tasks
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离任务与其他任务
- en: Ensuring that tasks run in finite or restricted resource environments
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保任务在有限或受限资源的环境中运行
- en: Programmatically controlling the individual resources of a task
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化控制任务的单个资源
- en: Running applications in different environments through a packaged image
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过打包镜像在不同环境中运行应用程序
- en: Breaking applications into smaller, manageable micro-services
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序拆分为更小、更易管理的微服务
- en: Tasks can be run in containers through **containerizers**. Mesos provides support
    for popular container technologies such as Docker while also having its own container
    technology. Recently, support has also been added for combining and allowing different
    container technologies to work together (for example, Mesos and Docker).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以通过**容器化工具**在容器中运行。Mesos 支持流行的容器技术，如 Docker，同时也有自己的容器技术。最近，还增加了对结合不同容器技术并使其协同工作的支持（例如，Mesos
    和 Docker）。
- en: Motivation
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动机
- en: One of the key requirements of a cluster manager is to ensure that the allocation
    of resources to a particular framework does not have any impact on any active
    running jobs of some other framework. Provision for isolation mechanisms on slaves
    for compartmentalizing different tasks is, thus, a key feature of Mesos. Mesos
    leverages containers for resource isolation, which has a pluggable architecture
    as well. The Mesos slave uses Containerizer API to provide an isolated environment
    to run a framework's executor and its corresponding tasks. The Containerizer API's
    objective is to support a wide range of implementations, which implies that custom
    containerizers and isolators can be developed. When a slave process starts, the
    containerizer to be used to launch containers and the set of isolators to enforce
    the resource constraints can be specified.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 集群管理器的关键要求之一是确保为特定框架分配的资源不会影响其他框架的任何正在运行的作业。因此，Mesos 的关键特性之一是提供在从属节点上实施隔离机制以分隔不同任务的能力。Mesos
    利用容器进行资源隔离，并且具有可插拔的架构。Mesos 从属节点使用容器化工具 API 提供一个隔离的环境来运行框架的执行器及其相应任务。容器化工具 API
    的目标是支持广泛的实现，这意味着可以开发自定义容器化工具和隔离器。当从属进程启动时，可以指定用于启动容器的容器化工具以及用于强制资源约束的隔离器集合。
- en: Containerizer types
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化工具类型
- en: 'The following containerizer options are available in Mesos version 0.27:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mesos 版本 0.27 中可用的容器化工具选项有：
- en: Composing
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Docker
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Mesos (default)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos（默认）
- en: The containerizer type can be specified by the user through the agent flag,
    `--containerizers.`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过代理标志`--containerizers`指定容器化工具类型。
- en: 'For example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Containerizer creation
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化工具创建
- en: A containerizer is created by the slave based on the flag configuration (using
    agent flag `--containerizers`). The composing containerizer is used to create
    the containerizer in cases where multiple containerizers (for example, Mesos and
    Docker) are listed through the `--containerizers` flag.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化工具由从属节点基于标志配置（使用代理标志`--containerizers`）创建。在列出多个容器化工具（例如，Mesos 和 Docker）时，使用组合容器化工具来创建容器化工具，通过`--containerizers`标志来指定。
- en: The Mesos agent utilizes the task default executor in cases where an executor
    is not specifically mentioned in `TaskInfo`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`TaskInfo`中未特别提到执行器时，Mesos 代理将使用任务默认执行器。
- en: 'Containerization in Mesos is shown in the ensuing figure (source: Apache Mesos
    Essentials: [https://www.packtpub.com/big-data-and-business-intelligence/apache-mesos-essentials](https://www.packtpub.com/big-data-and-business-intelligence/apache-mesos-essentials)):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 中的容器化过程如下图所示（来源：《Apache Mesos Essentials》：[https://www.packtpub.com/big-data-and-business-intelligence/apache-mesos-essentials](https://www.packtpub.com/big-data-and-business-intelligence/apache-mesos-essentials)）：
- en: '![Containerizer creation](img/B05186_07_06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![容器化工具创建](img/B05186_07_06.jpg)'
- en: Mesos containerizer
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos 容器化工具
- en: This is the default containerizer type provided by Mesos. In this type, tasks
    can be run through an array of pluggable isolators provided by Mesos. It can be
    enabled by configuring the agent flag as
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Mesos 提供的默认容器化工具类型。在此类型中，任务可以通过 Mesos 提供的多个可插拔的隔离器来运行。可以通过配置代理标志来启用此类型：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This type is typically used when:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型通常在以下情况下使用：
- en: User needs to control the task environment through Mesos without having to rely
    on other container solutions.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要通过 Mesos 控制任务环境，而不依赖其他容器解决方案。
- en: Fine-grained OS controls are desired.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要精细化操作系统控制。
- en: Custom resource isolation needs to be added for tasks.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要为任务添加自定义资源隔离。
- en: User needs to control certain resource parameters (for example, disk usage limits)
    which are not exposed by other container solutions.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要控制某些资源参数（例如，磁盘使用限制），而这些参数在其他容器解决方案中不可见。
- en: Any task which doesn't specify `ContainerInfo::DockerInfo` will be handled by
    the Mesos containerizer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 任何未指定`ContainerInfo::DockerInfo`的任务将由 Mesos 容器化工具处理。
- en: The launching process
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动过程
- en: 'The container launching process includes the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动过程包括以下步骤：
- en: Preparation of calls is done on every **isolator**.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个**隔离器**上的调用准备工作都已完成。
- en: The launcher, responsible for forking/destroying containers, is used to fork
    the executor. The forked 'child' cannot execute until the isolation step is completed.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动器负责分叉/销毁容器，使用它来分叉执行器。分叉出的“子进程”在隔离步骤完成之前无法执行。
- en: The **executor** is isolated by calling the isolators. Isolators are responsible
    for creating an environment for the containers, where resources like CPU, network,
    storage, and memory can be isolated from other containers.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行器**通过调用隔离器进行隔离。隔离器负责为容器创建一个环境，在该环境中，CPU、网络、存储和内存等资源可以与其他容器隔离。'
- en: The executor is fetched and the forked child notified to execute. Isolator preparation
    commands are run first, followed by the execution.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行器被获取并通知分叉的子进程执行。首先运行隔离器准备命令，然后进行执行。
- en: Mesos containerizer states
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mesos 容器化工具状态
- en: 'The different Mesos containerizer states are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 Mesos 容器化工具状态如下：
- en: PREPARING
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PREPARING
- en: ISOLATING
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISOLATING
- en: FETCHING
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FETCHING
- en: RUNNING
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RUNNING
- en: DESTROYING
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DESTROYING
- en: Internals
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部实现
- en: By leveraging Linux features such as namespaces and **control groups** (**cgroups**),
    the Mesos Containerizer provides resource isolation and lightweight containerization.
    It provides the capability for different isolators to be selectively enabled.
    In addition, support for **POSIX** (**Portable Operating system Interface**) systems
    is also present, though it only includes usage reporting and not actual isolation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 Linux 的命名空间和**控制组**（**cgroups**）等功能，Mesos 容器化工具提供资源隔离和轻量级容器化。它提供了选择性启用不同隔离器的能力。此外，虽然仅包括使用报告而不进行实际隔离，但也支持**POSIX**（**可移植操作系统接口**）系统。
- en: 'There are three isolator options present and they are described as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 存在三种隔离器选项，具体描述如下：
- en: Shared Filesystem
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享文件系统
- en: Modifications to every container's shared filesystem view can be enabled using
    the Shared Filesystem isolator on Linux hosts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 Linux 主机上使用共享文件系统隔离器来启用对每个容器的共享文件系统视图的修改。
- en: The modifications can be specified either through the `–default_container_info
    agent` flag or by the framework in the `ContainerInfo`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`–default_container_info agent`标志或框架中的`ContainerInfo`来指定修改。
- en: Volumes, used to map sections of the shared filesystem (such as host path with
    the container's view of the shared filesystem, that is, container path), can be
    specified through `ContainerInfo` as read-only or read-and-write. The path of
    the host can be absolute or relative. If absolute, it also results in the filesystem
    subtree being made accessible for every container under the container path. If
    relative, then it is taken to be a directory which is relative to the work directory
    of the executor. The directory is created, and permissions from the corresponding
    existing directory in the shared filesystem are copied over.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 用于映射共享文件系统部分（例如主机路径与容器视图中的共享文件系统，即容器路径） 的卷，可以通过 `ContainerInfo` 指定为只读或读写模式。主机的路径可以是绝对路径或相对路径。如果是绝对路径，还会导致文件系统子树在容器路径下对每个容器可访问。如果是相对路径，则该路径会被视为相对于执行器工作目录的目录。该目录会被创建，并且共享文件系统中相应现有目录的权限将被复制过来。
- en: The main reason why this isolator is used is to make certain shared filesystem
    sections private to every container selectively. As an example, a private directory
    `/dir_name` can be set by making `host_path="dir_name"` and `container_path="/dir_name"`.
    This creates a directory `dir_name` inside the executor's work directory while
    also mounting it as `/dir_name` within the container. The container won't be able
    to see the host's `/dir_name` or any other container's `/dir_name,` and this action
    is transparent to the processes running within it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此隔离器的主要原因是为了选择性地将某些共享文件系统部分设置为对每个容器私有。例如，可以通过设置 `host_path="dir_name"` 和 `container_path="/dir_name"`
    来设置一个私有目录 `/dir_name`。这将在执行器的工作目录中创建一个目录 `dir_name`，并将其挂载为容器中的 `/dir_name`。容器无法看到主机的
    `/dir_name` 或其他任何容器的 `/dir_name`，并且这个操作对容器内运行的进程是透明的。
- en: Pid namespace
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pid 名称空间
- en: 'This isolator is used to isolate every container in a different pid namespace,
    which gives the following two advantages:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此隔离器用于将每个容器隔离到不同的 pid 名称空间，这带来以下两个优势：
- en: '**Visibility**: The executor and descendant processes running within the container
    cannot view or interact with external processes running outside the namespace.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可见性**：容器内运行的执行器及其后代进程无法查看或与名称空间外部运行的外部进程进行交互。'
- en: '**Clean Termination**: If the leading process in a pid namespace is terminated,
    the kernel terminates all other processes running within the namespace.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**清理终止**：如果 pid 名称空间中的主进程被终止，内核将终止该名称空间内运行的所有其他进程。'
- en: Posix Disk isolator
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Posix 磁盘隔离器
- en: This isolator, which can be used on both OS X as well as Linux, is used for
    providing basic disk isolation. The disk utilization for every sandbox can be
    reported using this, and any set disk quotas can be enforced as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该隔离器可用于 OS X 和 Linux，用于提供基本的磁盘隔离。可以通过此隔离器报告每个沙箱的磁盘使用情况，并可以强制执行任何设置的磁盘配额。
- en: When starting the slave, `posix/disk` must be added to the `--isolation` flag
    to enable this isolator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动从属节点时，必须将 `posix/disk` 添加到 `--isolation` 标志中以启用此隔离器。
- en: The disk quota enforcement is disabled by default. When starting the slave,
    specify `--enforce_container_disk_quota` to enable it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下禁用磁盘配额强制执行。在启动从属节点时，指定 `--enforce_container_disk_quota` 来启用它。
- en: Disk utilization for every sandbox is reported by periodically running the `du`
    command. The resource statistics endpoint (`/monitor/statistics.json`) provides
    a way to retrieve the disk utilization statistics.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个沙箱的磁盘使用情况通过定期运行 `du` 命令进行报告。资源统计端点（`/monitor/statistics.json`）提供了一种检索磁盘使用情况统计信息的方法。
- en: The time interval between two `du` commands can be configured through the agent
    flag `--container_disk_watch_interval`. For example, `--container_disk_watch_interval
    = 1 mins` specifies the time interval as 1 minute. 15 seconds is the default time
    interval.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `du` 命令之间的时间间隔可以通过代理标志 `--container_disk_watch_interval` 来配置。例如，`--container_disk_watch_interval
    = 1 mins` 指定时间间隔为 1 分钟。默认时间间隔为 15 秒。
- en: Docker containerizer
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 容器化器
- en: This containerizer type permits running of tasks inside a Docker container.
    A Docker image can either be launched as an executor or as a task. It can be enabled
    by configuring the agent flag as
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器化类型允许在 Docker 容器内运行任务。可以将 Docker 镜像作为执行器或任务启动。通过配置代理标志启用它
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is normally used when:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在以下情况下使用：
- en: The Docker package needs to be leveraged for running tasks.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要使用 Docker 包来运行任务。
- en: A Mesos slave is running within a Docker container.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Mesos 从属节点正在 Docker 容器中运行。
- en: Setup
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: In order to enable the Docker Containerizer on a slave, the slave must be launched
    with "Docker" as one of the containerizer options.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在从节点上启用 Docker 容器化工具，从节点必须在启动时将 "Docker" 作为其中一个容器化选项。
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every slave where the Docker containerizer is specified must also have the Docker
    Command Line Interface client (version 1.0.0 or above) installed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指定了 Docker 容器化的从节点必须安装 Docker 命令行界面客户端（版本 1.0.0 或以上）。
- en: 'If `iptables` are enabled on the slave, ensure that the `iptables` permit all
    traffic from the bridge interface by making the following change:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从节点启用了 `iptables`，确保 `iptables` 允许来自桥接接口的所有流量，可以通过以下更改来实现：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Launching process
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动过程
- en: 'The container launching process is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动过程如下：
- en: Task launching in Docker is attempted only if `ContainerInfo::type` is set to
    `DOCKER`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当 `ContainerInfo::type` 设置为 `DOCKER` 时，才会尝试在 Docker 中启动任务
- en: The image is pulled first from the specified repository
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像首先从指定的仓库中拉取
- en: The pre-launch hook is then called
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预启动钩子随后被调用
- en: 'The executor is then launched in one of the following two ways:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器随后以以下两种方式之一启动：
- en: 'Mesos agent runs in a Docker container in the following cases:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下情况下，Mesos 代理会在 Docker 容器中运行：
- en: If the flag `--docker_mesos_image` is present, it indicates that the Mesos agent
    is running within a Docker container
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在 `--docker_mesos_image` 标志，表示 Mesos 代理在 Docker 容器中运行
- en: The flag `--docker_mesos_image` value is considered to be the Docker image that
    will be used for launching the Mesos agent
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--docker_mesos_image` 标志的值被视为用于启动 Mesos 代理的 Docker 镜像'
- en: If an executor different from the default command executor is used by the task
    to run, it gets launched within a Docker container
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务使用不同于默认命令执行器的执行器，它将在 Docker 容器中启动
- en: If `TaskInfo` is used by the task, then the default `mesos-docker-executor`
    gets launched within a Docker container to execute commands through the Docker
    Command Line Interface.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务使用 `TaskInfo`，则默认的 `mesos-docker-executor` 会在 Docker 容器中启动，通过 Docker 命令行界面执行命令。
- en: 'Mesos agent does not run in a Docker container in the following cases :'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下情况下，Mesos 代理不会在 Docker 容器中运行：
- en: If `TaskInfo` is used by a task, a sub-process to run default `mesos-docker-executor`
    is forked. Shells are spawned by this executor to run Docker commands through
    the Docker Command Line Interface.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务使用 `TaskInfo`，则会创建一个子进程来运行默认的 `mesos-docker-executor`。该执行器会通过 Docker 命令行界面生成
    Shell 以执行 Docker 命令。
- en: If a custom executor is used by the task to run, it gets launched within a Docker
    container.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务使用了自定义执行器，它将在 Docker 容器中启动。
- en: Docker containerizer states
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker 容器化状态
- en: 'Following are the different Docker containerizer states:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不同的 Docker 容器化状态：
- en: FETCHING
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取中
- en: PULLING
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取中
- en: RUNNING
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行中
- en: DESTROYING
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁中
- en: Composing containerizer
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合容器化工具
- en: This type allows for combining and allowing different container technologies
    to work together (for example, Mesos and Docker). It can be enabled by configuring
    the `--containerizers` agent flag with a comma-separated list of required containerizer
    names
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型允许结合并使不同的容器技术协同工作（例如，Mesos 和 Docker）。可以通过配置 `--containerizers` 代理标志，并用逗号分隔的容器化工具名称列表来启用。
- en: '[PRE5]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first containerizer specified in the list, which provides support for the
    task's container configuration, is used for task launching.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中指定的第一个容器化工具提供对任务容器配置的支持，用于任务启动。
- en: This option is generally used when tasks having different resource isolation
    types need to be tested. A framework can leverage the composer containerizer to
    test a task using the controlled environment provided by the Mesos containerizer,
    while simultaneously ensuring that the task works with Docker containers.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此选项通常在需要测试具有不同资源隔离类型的任务时使用。框架可以利用组合容器化工具，通过 Mesos 容器化工具提供的受控环境来测试任务，同时确保任务与
    Docker 容器兼容。
- en: Networking for Mesos-managed containers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos 管理的容器的网络配置
- en: One of the major goals to provide networking-related support in Mesos was to
    develop a pluggable architecture leveraging which custom networking mechanisms
    could be implemented by users as per their requirements. Since networking requirements
    vary across different deployment scenarios (cloud, on-premise, private cloud,
    or other hybrid models), it is not practical to create a monolithic networking
    mechanism that caters to all needs. Mesos' pluggable architecture proves to be
    very useful in tackling this.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mesos中提供与网络相关的支持的主要目标之一是开发一个可插拔的架构，用户可以根据自己的需求实现定制的网络机制。由于不同部署场景（云环境、本地部署、私有云或其他混合模型）对网络的需求不同，创建一个单一的网络机制来满足所有需求并不现实。Mesos的可插拔架构在解决这一问题时非常有用。
- en: To provide networking support, many opt-in extensions were introduced in Mesos
    components from version 0.25.0 onwards. The opt-in structure allows existing frameworks
    without networking support to continue operating seamlessly on newer Mesos versions.
    Mesos enables integration with other networking mechanisms, and provides features
    like service discovery, IP per container, and isolation of tasks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为提供网络支持，从版本0.25.0开始，Mesos组件引入了许多可选扩展。可选结构允许没有网络支持的现有框架在更新的Mesos版本上无缝运行。Mesos支持与其他网络机制的集成，并提供服务发现、每个容器的IP以及任务隔离等功能。
- en: Networking support is provided through a Mesos module, which implies that it
    is abstracted away from the Mesos master and slaves. All the required support
    needs to be enabled from the networking module itself. Since IP requests are handled
    on a best-effort basis, frameworks also need to be able to take care of cases
    where a request is ignored due to networking modules not being implemented, or
    where a request is denied due to inability of the module to assign an IP.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 网络支持是通过一个Mesos模块提供的，这意味着它被抽象化，脱离了Mesos的主节点和从节点。所有所需的支持需要从网络模块本身启用。由于IP请求是基于尽力而为的原则处理的，因此框架还需要能够处理因未实现网络模块或模块无法分配IP而导致的请求被忽略或拒绝的情况。
- en: Framework Schedulers need to opt in for network isolation through use of additional
    data structures in `TaskInfo`. This structure ensures that backward compatibility
    is maintained with older frameworks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 框架调度器需要通过在`TaskInfo`中使用额外的数据结构来选择网络隔离。这一结构确保与旧框架保持向后兼容。
- en: Architecture
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构
- en: 'The solution architecture with a description of the different components is
    provided as shown in the following diagram (source: [http://mesos.apache.org/documentation/latest/networking-for-mesos-managed-containers/](http://mesos.apache.org/documentation/latest/networking-for-mesos-managed-containers/)):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了包括不同组件描述的解决方案架构，如下图所示（来源：[http://mesos.apache.org/documentation/latest/networking-for-mesos-managed-containers/](http://mesos.apache.org/documentation/latest/networking-for-mesos-managed-containers/)）：
- en: '![Architecture](img/B05186_07_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![架构](img/B05186_07_07.jpg)'
- en: Key terms
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键术语
- en: 'Some key terms regarding networking are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络的一些关键术语如下：
- en: '**IP Address Management (IPAM) Server**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP地址管理（IPAM）服务器**'
- en: IPs are assigned on demand
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP按需分配
- en: IPs are recycled upon being released
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP在释放后会被回收
- en: IPs can be optionally tagged with the provided ID
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP可以选择性地使用提供的ID进行标记
- en: '**IPAM client**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPAM客户端**'
- en: Coupled tightly with the corresponding IPAM server
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对应的IPAM服务器紧密耦合
- en: Serves as a bridge between the IPAM server and Network Isolator Module
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为IPAM服务器与网络隔离模块之间的桥梁
- en: Handles IP-related communications with the server (release, request, and so
    on)
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理与服务器的IP相关通信（释放、请求等）
- en: '**Network Isolator Module (NIM)**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络隔离模块（NIM）**'
- en: Mesos module for the slave where the isolator interface is implemented
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos模块用于实现隔离器接口的从节点
- en: Task IP requirements are determined by looking at `TaskInfo`
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务的IP需求由查看`TaskInfo`来决定
- en: Handles IP-related communications with the IPAM client (release, request, and
    so on)
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理与IPAM客户端的IP相关通信（释放、请求等）
- en: Enables network isolation by communicating with the external network virtualizer
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过与外部网络虚拟化器通信，实现网络隔离
- en: '**Cleanup Module**:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理模块**：'
- en: Handles cleanup tasks (such as IP release) when the slave is lost
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理清理任务（如IP释放），当从节点丢失时
- en: The process
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过程
- en: A Mesos framework requests IPs for every container being launched, using the
    `TaskInfo` message.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mesos框架为每个启动的容器请求IP，使用`TaskInfo`消息。
- en: The Mesos master forwards these messages to the slave after processing them
    for launching and running tasks.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mesos主节点在处理完这些消息后，将其转发给从节点，用于启动和运行任务。
- en: The Mesos slave figures out the container requirements by analyzing these messages,
    and prepares the different isolators for them.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mesos从节点通过分析这些消息来了解容器需求，并为其准备不同的隔离器。
- en: The **Network Isolator Module** analyzes the messages, and decides whether the
    network isolators should be enabled or not.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**网络隔离模块**分析这些消息，并决定是否启用网络隔离器。'
- en: The Network Isolator Module then communicates with the IPAM client to request
    the IP addresses, provided it decides that the network isolator needs to be enabled,
    and gives a status update to the slave.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络隔离模块随后会与IPAM客户端通信，请求IP地址，前提是它决定需要启用网络隔离器，并向从节点提供状态更新。
- en: Upon receiving this update, a container is launched by the slave within a different
    namespace. This is done by the Network Isolator Module which informs the network
    virtualizer to perform container isolation upon getting instructions from the
    slave to do so.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到此更新后，容器将在不同的命名空间中由从节点启动。这是由网络隔离模块完成的，网络隔离模块会在接到从节点的指示后通知网络虚拟化器进行容器隔离。
- en: The IP information is added to `TaskStatus` by the Network Isolator Module.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IP信息由网络隔离模块添加到`TaskStatus`中。
- en: The Network Isolator Module then makes the IP addresses from `TaskStatus` available
    at the master's state endpoint, while also making the frameworks aware of the
    IP addresses by forwarding the `TaskStatus` to them.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络隔离模块随后会将来自`TaskStatus`的IP地址提供给主节点的状态端点，同时通过将`TaskStatus`转发给框架，让框架了解这些IP地址。
- en: If a task is lost, the Network Isolator Module informs the IPAM client of the
    same, and gets the IP addresses released.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任务丢失，网络隔离模块会通知IPAM客户端，并释放IP地址。
- en: The cleanup module then gets notified, and then recycles all the IP addresses
    released by the IPAM client.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后清理模块会收到通知，接着回收所有由IPAM客户端释放的IP地址。
- en: A sample implementation of a Networking Isolator Module can be seen at [https://github.com/mesosphere/net-modules](https://github.com/mesosphere/net-modules).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 网络隔离模块的示例实现可以在[https://github.com/mesosphere/net-modules](https://github.com/mesosphere/net-modules)查看。
- en: IP-per-container capability in frameworks
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架中的每容器IP功能
- en: Frameworks that seek to implement IP per container, need to pass the message
    `NetworkInfo` within `TaskInfo`. The `NetworkInfo` message details are given in
    the following section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 寻求实现每容器IP功能的框架，需要在`TaskInfo`内传递`NetworkInfo`消息。`NetworkInfo`消息的详细信息将在以下部分给出。
- en: NetworkInfo message
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NetworkInfo消息
- en: 'A new `NetworkInfo` message can be introduced as:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`NetworkInfo`消息可以按如下方式引入：
- en: '[PRE6]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The protocol field needs to be set to `IPv4` or `IPv6` while an IP address from
    the IP Address Management is requested. If supported by the Network Isolator Module,
    a framework can set a static IP address for each container. This can be done by
    providing a valid IP as the `ip_address` string. This is typically required when
    tasks that get killed or lost need to be relaunched on another node with the same
    IP address.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求来自IP地址管理的IP地址时，协议字段需要设置为`IPv4`或`IPv6`。如果网络隔离模块支持，框架可以为每个容器设置静态IP地址。可以通过提供有效的IP作为`ip_address`字符串来完成。这通常在需要重新启动已终止或丢失的任务，并且任务需要在另一个节点上使用相同IP地址时才需要。
- en: Examples for specifying network requirements
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定网络要求的示例
- en: 'The frameworks which want to enable an IP per container need to provide `NetworkInfo`
    message in `TaskInfo`. Here are a few examples:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 需要启用每个容器一个IP的框架需要在`TaskInfo`中提供`NetworkInfo`消息。以下是几个示例：
- en: 'Request for single IP address without a protocol version being specified using
    the default command executor:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认命令执行器请求一个IP地址，但未指定协议版本：
- en: '[PRE7]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Request for two IP addresses, one of IPv4 protocol and another of IPv6 protocol,
    in two sets using the default command executor:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认命令执行器请求两个IP地址，其中一个是IPv4协议，另一个是IPv6协议，分为两个组：
- en: '[PRE8]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Request for two network interfaces, each with one IP address and each in a
    different network group using the default command executor:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认命令执行器请求两个网络接口，每个接口一个IP地址且分别属于不同的网络组：
- en: '[PRE10]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Request for a specific IP address using a custom executor:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义执行器请求特定IP地址：
- en: '[PRE11]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Address discovery
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址发现
- en: 'As seen earlier, frameworks can request IP addresses for assignment during
    launching of tasks on the Mesos slaves by passing the `NetworkInfo` message within
    the `TaskInfo` message. The frameworks, after opting for network isolation, also
    need a mechanism for knowing the IP addresses finally assigned so that monitoring
    and other communication activities can be undertaken. This can be done by introducing
    an additional field in the `TaskStatus` message as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所见，框架可以在启动 Mesos 从节点上的任务时，通过在 `TaskInfo` 消息中传递 `NetworkInfo` 消息来请求分配 IP
    地址。框架在选择网络隔离后，还需要一个机制来了解最终分配的 IP 地址，以便进行监控和其他通信活动。这可以通过在 `TaskStatus` 消息中引入一个额外的字段来实现，如下所示：
- en: '[PRE12]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implementing a Custom Network Isolator Module
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义网络隔离模块
- en: Mesos provides an Isolator API to enable custom Network Isolator Module implementations
    on top of it. The implemented module gets manifested as a dynamic shared library
    within the Mesos slave, and seamlessly integrates with the container launch. A
    network isolator often communicates with network virtualizers and IPAM clients
    to meet the framework needs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 提供了一个 Isolator API，允许在其基础上实现自定义的网络隔离模块。实现的模块会以动态共享库的形式在 Mesos 从节点中显现，并与容器启动过程无缝集成。网络隔离器通常与网络虚拟化器和
    IP 地址管理（IPAM）客户端进行通信，以满足框架的需求。
- en: 'The three key functions that a Network Isolator Module must implement are described
    as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 网络隔离模块必须实现的三个关键功能如下：
- en: '`Isolator::prepare()`: This gives the module an option to determine whether
    or not network isolation needs to be enabled for the specified container. The
    `Isolator::prepare` function instructs the slave to create a different network
    namespace if network isolation is to be enabled. This interface is also responsible
    for creating an IP address for the container.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Isolator::prepare()`：此函数为模块提供了一个选项，允许它确定是否需要为指定的容器启用网络隔离。`Isolator::prepare`
    函数指示从节点在启用网络隔离时创建一个不同的网络命名空间。此接口还负责为容器创建一个 IP 地址。'
- en: '`Isolator::isolate()`: This gives the module the chance to isolate the task
    container after its creation but before launching of an executor within it. It
    involves a virtual Ethernet adapter creation for the container and the assignment
    of an IP address to it. It can also leverage an external virtualizer for network
    setup.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Isolator::isolate()`：此函数为模块提供了一个机会，在任务容器创建后但执行器启动之前进行容器隔离。它涉及为容器创建一个虚拟以太网适配器并为其分配
    IP 地址。它还可以利用外部虚拟化器进行网络配置。'
- en: '`Isolator::cleanup()`: This function is called upon container termination.
    Its main job is to recover and recycle released IP addresses, and undertake any
    other cleanups as necessary.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Isolator::cleanup()`：此函数在容器终止时被调用。它的主要任务是回收和再利用已释放的 IP 地址，并进行其他必要的清理工作。'
- en: Monitoring container network statistics
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控容器网络统计信息
- en: Statistics for every container network are provided via the `/monitor/statistics.json`
    slave endpoint by Mesos.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器网络的统计信息可以通过 Mesos 的 `/monitor/statistics.json` 从节点端点提供。
- en: 'The following counters are reported:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 报告了以下计数器：
- en: '| Metric | Description | Type |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 描述 | 类型 |'
- en: '| --- | --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `net_rx_bytes` | Bytes received | Counter |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `net_rx_bytes` | 接收的字节 | 计数器 |'
- en: '| `net_rx_dropped` | Dropped packets (receive) | Counter |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `net_rx_dropped` | 丢弃的包（接收） | 计数器 |'
- en: '| `net_rx_errors` | Reported errors (receive) | Counter |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `net_rx_errors` | 报告的错误（接收） | 计数器 |'
- en: '| `net_rx_packets` | Received packets | Counter |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `net_rx_packets` | 接收的包 | 计数器 |'
- en: '| `net_tx_bytes` | Bytes sent | Counter |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `net_tx_bytes` | 发送的字节 | 计数器 |'
- en: '| `net_tx_dropped` | Dropped packets (send) | Counter |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `net_tx_dropped` | 丢弃的包（发送） | 计数器 |'
- en: '| `net_tx_errors` | Reported errors (send) | Counter |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `net_tx_errors` | 报告的错误（发送） | 计数器 |'
- en: '| `net_tx_packets` | Sent Packets | Counter |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `net_tx_packets` | 发送的包 | 计数器 |'
- en: 'Additionally, the following counters and gauges can be reported for the elements
    which implement bloat reduction or bandwidth limiting under the `statistics/net_traffic_control_statistics`
    key:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下计数器和测量值可以报告用于膨胀减少或带宽限制的元素，这些元素在 `statistics/net_traffic_control_statistics`
    键下实现：
- en: '| Metric | Description | Type |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 描述 | 类型 |'
- en: '| --- | --- | --- |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `backlog` | Queued bytes (only on bloat reduction interface) | Gauge |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `backlog` | 排队的字节（仅在膨胀减少接口上） | 测量 |'
- en: '| `bytes` | Bytes sent | Counter |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `bytes` | 发送的字节 | 计数器 |'
- en: '| `drops` | Dropped packets (send) | Counter |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `drops` | 丢弃的包（发送） | 计数器 |'
- en: '| `overlimits` | Number of times interface was over its transmit limit | Counter
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `overlimits` | 接口超过传输限制的次数 | 计数器 |'
- en: '| `packets` | Sent packets | Counter |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `packets` | 发送的数据包 | 计数器 |'
- en: '| `qlen` | Queued packets | Gauge |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `qlen` | 排队的数据包 | 测量 |'
- en: '| `ratebps` | Rate of transmission (currently, always 0 bytes/second) | Gauge
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `ratebps` | 传输速率（当前始终为 0 字节/秒） | 测量 |'
- en: '| `ratepps` | Rate of transmission (currently, always 0 packets/second) | Gauge
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `ratepps` | 传输速率（当前始终为 0 数据包/秒） | 测量 |'
- en: '| `requeues` | Failed packets | Counter |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `requeues` | 失败的数据包 | 计数器 |'
- en: Example statistics
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例统计
- en: 'An example of the statistics obtained is given as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是获得的统计数据示例：
- en: '[PRE13]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Mesos Image Provisioner
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos 图像供应器
- en: An **Image** is an ordered collection of root filesystem changes and the corresponding
    execution parameters for use within a container runtime.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**Image** 是根文件系统更改的有序集合，以及用于容器运行时的相应执行参数。'
- en: Most of the container specifications, such as Docker, **App** **Container**
    (**AppC**), or **Open Container Project** (**OCP**), combine implementation and
    specification of the image format with other container components such as resource
    isolation and task execution to a large extent. The Mesos **Image Provisioner**
    seeks to enhance the capabilities of Mesos Containerizer by providing support
    for container filesystem provisioning from multiple image formats, while also
    providing features such as resource isolation by combining with other components
    such as Isolators.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数容器规范，如 Docker、**App** **Container**（**AppC**）或 **Open Container Project**（**OCP**），在很大程度上将图像格式的实现和规范与其他容器组件（如资源隔离和任务执行）结合在一起。Mesos
    **Image Provisioner** 旨在通过支持来自多种图像格式的容器文件系统供应，增强 Mesos 容器化器的功能，同时还通过与其他组件（如隔离器）结合，提供资源隔离等特性。
- en: Mesos containers created using the Mesos Containerizer are provided with a root
    filesystem already provisioned with Docker or AppC images using the Mesos Image
    Provisioner.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mesos 容器化器创建的 Mesos 容器提供了一个已经用 Docker 或 AppC 图像配置好的根文件系统，该文件系统是通过 Mesos 图像供应器进行供应的。
- en: 'The container filesystem image is described by a new message `Image,` which
    is given in the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 容器文件系统图像通过一个新的消息`Image`来描述，代码如下所示：
- en: '[PRE14]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This message contains both the image specification type as well as the corresponding
    type configurations. This message can be passed through either 'Volume' or `ContainerInfo`.
    A root filesystem is provided to the task when an image is configured in `ContainerInfo,`
    while volumes are mounted with the image filesystem in cases where the 'Image'
    message is specified within 'Volume'.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息包含了图像规范类型以及相应的类型配置。该消息可以通过'Volume'或`ContainerInfo`传递。当在`ContainerInfo`中配置图像时，会为任务提供一个根文件系统，而在'Volume'中指定'Image'消息的情况下，卷与图像文件系统一起挂载。
- en: The request for container image is forwarded to the respective provider for
    provisioning the layers. Layers are generally filesystem changesets, which are
    nothing but an archive of the added, modified, or deleted files. The Provisioner
    further asks the configured setup to provision a root filesystem from these layers.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的请求被转发给相应的供应商，以供应各层。层通常是文件系统更改集，实际上就是添加、修改或删除文件的归档。供应器进一步要求配置好的设置根据这些层供应一个根文件系统。
- en: Setup and configuration options
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和配置选项
- en: To enable Mesos containerizer on the slave, it must be launched with the `mesos
    containerizer` (default) option, as shown earlier in this chapter. The slave also
    needs to be running on Linux with root permissions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要在从节点上启用 Mesos 容器化功能，必须使用 `mesos containerizer`（默认选项）启动，如本章前文所示。该从节点还需要在 Linux
    系统上运行并具有 root 权限。
- en: Next, filesystem/Linux must be set as the isolator option via the `--isolation`
    flag. The image providers can be configured by passing them as a comma-separated
    list in the agent flag `--image_providers,` and the supported backend can be specified
    though the flag `--image_provisioner_backend`. Additional configurations for every
    image provider can also be provided if required.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须通过 `--isolation` 标志将文件系统/Linux 设置为隔离器选项。可以通过将图像供应商作为逗号分隔的列表传递到代理标志 `--image_providers`
    中来配置图像供应商，并且可以通过 `--image_provisioner_backend` 标志指定支持的后端。如果需要，也可以为每个图像供应商提供额外的配置。
- en: 'The following is an example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE15]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For more information, visit [http://mesos.readthedocs.io/en/latest/mesos-provisioner/](http://mesos.readthedocs.io/en/latest/mesos-provisioner/).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问 [http://mesos.readthedocs.io/en/latest/mesos-provisioner/](http://mesos.readthedocs.io/en/latest/mesos-provisioner/)。
- en: Mesos fetcher
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mesos 获取器
- en: The Mesos fetcher is a way by which resources can be downloaded in the `task
    sandbox` directory while preparing the task execution. The framework requesting
    the execution of the task sends a list of `CommandInfo::URI` values as part of
    the `TaskInfo` message, which in turn serves as the Mesos fetcher input.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 获取器是一种在准备任务执行时可以将资源下载到 `task sandbox` 目录的方式。请求执行任务的框架将一组 `CommandInfo::URI`
    值作为 `TaskInfo` 消息的一部分发送，这些值作为 Mesos 获取器的输入。
- en: The Mesos fetcher natively supports the FTP and HTTP protocols, and is also
    able to copy over files from a filesystem. It also supports all Hadoop client
    protocols such as **Amazon Simple Storage Service** (**S3**), **Hadoop distributed
    Filesystem** (**HDFS**), and so on.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos 获取器原生支持 FTP 和 HTTP 协议，还能够从文件系统中复制文件。它还支持所有 Hadoop 客户端协议，如**Amazon 简单存储服务**（**S3**）、**Hadoop
    分布式文件系统**（**HDFS**）等。
- en: Every Uniform Resource Identifier (URI) that is requested gets downloaded, by
    default, directly into the `sandbox` directory. Multiple requests for the same
    URI results in copies of that resource being downloaded again and again. The downloaded
    URIs can also alternatively be cached in a specified directory for reuse.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求的统一资源标识符（URI）默认会直接下载到 `sandbox` 目录。对相同 URI 的多个请求将导致该资源反复被下载。下载的 URI 也可以选择性地缓存到指定目录中，以供重用。
- en: Mechanism
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: 'The mechanism comprises the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制包括以下内容：
- en: Each slave consists of one internal fetcher instance which is leveraged by all
    containerizer types. The fetcher process, included in the slave program, is responsible
    for performing book-keeping around what is present in the cache.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个从属节点包含一个内部获取器实例，所有容器化类型都会利用该实例。获取器进程包含在从属节点程序中，负责对缓存中存在的内容进行账务管理。
- en: There is also an external `mesos-fetcher` program that gets called by the internal
    program mentioned in Step 1 whenever resources need to be downloaded from specified
    URIs into the cache or directories. It is also called when resources from cache
    need to be moved over to the `sandbox` directory. All disk and network operations,
    barring deletions and querying file size, are performed by it. It acts more like
    a simple helper program while all the intelligence is located in the internal
    program.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个外部 `mesos-fetcher` 程序，它会在需要从指定 URI 下载资源到缓存或目录时由步骤 1 中提到的内部程序调用。当缓存中的资源需要移动到
    `sandbox` 目录时，也会调用该程序。除了删除和查询文件大小外，所有的磁盘和网络操作都由它执行。它更像是一个简单的辅助程序，而所有的智能都位于内部程序中。
- en: No persistent state is maintained in the entire system except for the cache
    files. This helps manage the complexity involved in simultaneous fetching and
    caching, and generally simplifies the overall architecture.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缓存文件外，整个系统不会维护任何持久状态。这有助于管理同时获取和缓存的复杂性，并且通常简化了整体架构。
- en: 'The following diagram depicts the interactions between the internal fetcher
    process and the external `mesos-fetcher` program. Subsequent diagrams dive into
    the internal workflow in more detail. Source: [http://mesos.apache.org/documentation/latest/fetcher-cache-internals/](http://mesos.apache.org/documentation/latest/fetcher-cache-internals/).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了内部获取器进程与外部 `mesos-fetcher` 程序之间的交互。后续的图表将更详细地讲解内部工作流程。来源：[http://mesos.apache.org/documentation/latest/fetcher-cache-internals/](http://mesos.apache.org/documentation/latest/fetcher-cache-internals/)。
- en: '![Mechanism](img/B05186_07_08.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![机制](img/B05186_07_08.jpg)'
- en: Cache entry
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存条目
- en: The fetcher process can provide details around the cached URIs besides giving
    information regarding the location of the cache files, the processing stage, and
    so on.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器进程可以提供关于缓存 URI 的详细信息，除了提供有关缓存文件位置、处理阶段等信息外。
- en: A **HashMap** is used to store all the information mentioned previously. Each
    of the `Cache::Entry` objects contain the details of one cache file. These objects
    can be referenced by numerous callbacks corresponding to the multiple fetches
    while being stored in the HashMap.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**HashMap** 被用来存储之前提到的所有信息。每个 `Cache::Entry` 对象包含一个缓存文件的详细信息。这些对象可以通过多个回调引用，以对应于多个获取操作，并存储在
    HashMap 中。'
- en: Each cache entry has a one-to-one correspondence with a disk cache file during
    the entire duration of the file, which also includes the period before and after
    its creation. The entry includes all relevant state information regarding the
    stage as well as the corresponding URI fetching results.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 每个缓存条目在整个文件存储期间都与一个磁盘缓存文件一一对应，这个过程包括文件创建之前和之后的时间段。该条目包含与该阶段相关的所有状态信息以及相应的 URI
    抓取结果。
- en: A cache entry cannot be removed by any fetch attempt seeking to free up space
    for a newly downloaded cache file while it is being referenced.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个缓存条目正在被引用，它不能通过任何试图腾出空间以便为新下载的缓存文件腾出位置的抓取操作被删除。
- en: 'The next diagram shows the various states of a cache entry. It illustrates
    the sequence of events that take place during a single fetch run. The colors in
    the diagram represent the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图示展示了缓存条目的各种状态。它说明了在一次抓取运行中的事件序列。图中的颜色代表以下含义：
- en: '**Blue**: No cache exists'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝色**：没有缓存存在'
- en: '**Green**: Cache entry unreferenced by this run'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：此运行未引用的缓存条目'
- en: '**Orange**: Cache entry referenced'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**橙色**：缓存条目已引用'
- en: 'A cache entry should not be removed as long as any event is referencing it.
    This is enforced by something called **reference counting**. The value of a field
    called reference count within each cache entry is increased whenever it is being
    used by a fetch attempt, and decreased when the run is over, regardless of whether
    the run was successful or not. The value is incremented in the following cases:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有任何事件引用了某个缓存条目，该条目就不应被删除。这是通过一种叫做**引用计数**的机制来强制执行的。每当一个缓存条目被抓取操作使用时，字段“引用计数”中的值会增加，而在运行结束时，无论该运行是否成功，该值都会减少。值的增加发生在以下情况：
- en: Creation of a new cache entry
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新缓存条目
- en: Waiting for file download of an existing entry
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待下载现有条目的文件
- en: Fetching of the cache file corresponding to an entry
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抓取与条目对应的缓存文件
- en: Each value increase is noted within a list. At the end of the activity causing
    the increment, the value is decreased.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每次值的增加都会在列表中标注。导致增量的活动结束时，该值会减少。
- en: The figure given illustrates the different states which a cache entry can be
    in.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 给出的图示展示了缓存条目可以处于的不同状态。
- en: '![Cache entry](img/B05186_07_09.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![缓存条目](img/B05186_07_09.jpg)'
- en: URI flow diagram
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URI 流程图
- en: 'The fetcher process determines the control logic for handling every URI being
    fetched. The following is a diagram illustrating the flowchart for this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 抓取进程决定处理每个正在抓取的 URI 的控制逻辑。以下是说明此流程图的图示：
- en: '![URI flow diagram](img/B05186_07_10.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![URI 流程图](img/B05186_07_10.jpg)'
- en: Cache eviction
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存驱逐
- en: 'Consider the case where a couple of resources, *A* and *B*, have been fetched
    and cached into two sandboxes respectively, as shown in the following diagram.
    In this process, one cache file for each resource is created along with the cache
    entries mapping the resources with the corresponding cache files. Source: [http://mesos.apache.org/documentation/latest/fetcher-cache-internals/](http://mesos.apache.org/documentation/latest/fetcher-cache-internals/).'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个资源，*A* 和 *B*，它们分别被抓取并缓存到两个沙盒中，如下图所示。在此过程中，每个资源都会创建一个缓存文件，并将资源与相应的缓存文件进行映射。来源：[http://mesos.apache.org/documentation/latest/fetcher-cache-internals/](http://mesos.apache.org/documentation/latest/fetcher-cache-internals/)。
- en: '![Cache eviction](img/B05186_07_11.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![缓存驱逐](img/B05186_07_11.jpg)'
- en: 'Now let us assume a third resource *C*, which is downloaded and cached into
    a new sandbox. Assuming there is no space for all three entries, this requires
    removal or eviction of an existing cache file along with its corresponding entry
    to accommodate the new one. Assuming resource *A* was fetched before *B*, the
    cache eviction process would remove *A*, since it is the oldest entry. The removal
    steps are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设有一个第三个资源 *C*，它被下载并缓存到一个新的沙盒中。假设没有足够的空间容纳所有三个条目，那么就需要删除或驱逐一个现有的缓存文件及其相应条目，以便为新的缓存条目腾出空间。假设资源
    *A* 在 *B* 之前被抓取，那么缓存驱逐过程会移除 *A*，因为它是最早的条目。移除步骤如下：
- en: Cache entry for *A* is removed from the entry table.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*A* 的缓存条目从条目表中被移除。'
- en: '*C* is fetched, which creates a new cache file of a different name along with
    the associated cache entry.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*C* 被抓取，这会创建一个新的缓存文件，并生成与之关联的缓存条目。'
- en: '![Cache eviction](img/B05186_07_12.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![缓存驱逐](img/B05186_07_12.jpg)'
- en: If the first resource *A* is fetched again, then *B* would now get evicted,
    since it is the oldest present entry; the assumption, of course, being that there
    is no space to accommodate three cache files.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一次请求的资源 *A* 被再次获取，那么 *B* 将会被逐出，因为它是最旧的条目；当然，前提是没有足够的空间来容纳三个缓存文件。
- en: '![Cache eviction](img/B05186_07_13.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![缓存驱逐](img/B05186_07_13.jpg)'
- en: Deploying containerized apps using Docker and Mesos
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 和 Mesos 部署容器化应用
- en: 'This section gives a brief overview of deploying a Docker containerized Node.js
    application on Mesos using Marathon. This requires you to have Docker and fig
    already installed on the machine. Let''s follow the steps listed next to carry
    out the deployment:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要概述了如何在 Mesos 上使用 Marathon 部署一个 Docker 容器化的 Node.js 应用。你需要在机器上预先安装 Docker
    和 fig。接下来，让我们按照以下步骤进行部署：
- en: Since we are deploying a simple Node.js application, we can start off by creating
    a simple `App.js` to print `Hello World`, a simple hello world Node.js program.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们部署的是一个简单的 Node.js 应用，我们可以从创建一个简单的 `App.js` 文件开始，打印出 `Hello World`，这是一个简单的
    hello world Node.js 程序。
- en: '[PRE16]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next we create the `package.json` file with the following contents:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建 `package.json` 文件，内容如下：
- en: '[PRE17]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is to dockerize our application. For that, we can create a `Dockerfile`
    with the following contents:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将我们的应用容器化。为此，我们可以创建一个包含以下内容的 `Dockerfile` 文件：
- en: '[PRE18]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now build the container with the following commands:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令构建容器：
- en: '[PRE19]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can make sure everything is working correctly by opening the `localhost:8000`
    from the browser, which should display our **Hello World** text.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打开浏览器中的 `localhost:8000` 来确保一切正常运行，这将显示我们的 **Hello World** 文本。
- en: '![Deploying containerized apps using Docker and Mesos](img/B05186_07_14.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Docker 和 Mesos 部署容器化应用](img/B05186_07_14.jpg)'
- en: 'The next step is to build our `fig.yml` file. Here we will be using fig as
    an orchestration engine to deploy all central services from a single command.
    The `fig.yml` file will look like the following:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是构建我们的 `fig.yml` 文件。在这里，我们将使用 fig 作为编排引擎，通过单个命令部署所有核心服务。`fig.yml` 文件的内容如下：
- en: '[PRE20]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding configuration, we have configured the Docker registry to run
    on port `5000` along with a single Mesos slave, Mesos master, Marathon, and ZooKeeper
    for internal communication.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们已经配置了 Docker 注册表运行在 `5000` 端口，同时还配置了一个 Mesos 从节点、Mesos 主节点、Marathon
    和 ZooKeeper 用于内部通信。
- en: 'We can now start the Docker registry service with the following command:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令启动 Docker 注册表服务：
- en: '[PRE21]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command will start all the services listed in the preceding configuration
    file such as Mesos master, Mesos slave, Marathon, ZooKeeper, and Docker registry.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令将启动前述配置文件中列出的所有服务，如 Mesos 主节点、Mesos 从节点、Marathon、ZooKeeper 和 Docker 注册表。
- en: 'We can now build the Docker image, and push it to the registry with the following
    commands:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以构建 Docker 镜像，并使用以下命令将其推送到注册表：
- en: '[PRE22]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have the cluster ready, we can deploy our Node.js application through
    Marathon. For that we need to create an application configuration file (`app_marathon.json`)
    with the following contents:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好集群，可以通过 Marathon 部署我们的 Node.js 应用。为此，我们需要创建一个应用配置文件（`app_marathon.json`），内容如下：
- en: '[PRE23]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is then deployed on Marathon with the following command:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令将其部署到 Marathon 上：
- en: '[PRE24]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can now open the Marathon Web UI running on port `8080,` and see our Node.js
    application up and running:![Deploying containerized apps using Docker and Mesos](img/B05186_07_15.jpg)
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以打开运行在 `8080` 端口的 Marathon Web UI，并查看我们的 Node.js 应用是否正常运行：![使用 Docker
    和 Mesos 部署容器化应用](img/B05186_07_15.jpg)
- en: 'And we can see our Node.js hello world application by pointing the browser
    to `localhost:31000` port:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将浏览器指向 `localhost:31000` 端口来查看我们的 Node.js hello world 应用：
- en: '![Deploying containerized apps using Docker and Mesos](img/B05186_07_16.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Docker 和 Mesos 部署容器化应用](img/B05186_07_16.jpg)'
- en: '(Reference: [http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute/](http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute/)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: （参考：[http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute/](http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute/))
- en: '[http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute-part-2/](http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute-part-2/))'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute-part-2/](http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute-part-2/))'
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter touched upon several important topics related to containerization
    in Mesos. Resource isolation is one of the most touted features of Mesos, and
    the topics explained in this chapter have hopefully helped you understand this
    feature.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了与 Mesos 中容器化相关的几个重要主题。资源隔离是 Mesos 最受推崇的功能之一，本章节中介绍的主题希望能帮助您理解这一特性。
- en: In the next chapter, we will see some of the important Big Data frameworks which
    are currently supported by Mesos such as Hadoop, Spark, and Storm and understand
    how these can be set up and configured on Mesos.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到一些当前由 Mesos 支持的重要大数据框架，如 Hadoop、Spark 和 Storm，并了解如何在 Mesos 上进行设置和配置。
