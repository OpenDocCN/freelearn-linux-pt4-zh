- en: Chapter 7. Mesos Containerizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter briefly introduces the concepts of **containers,** and talks a
    bit about **Docker**, probably the most popular container technology available
    today. It also provides a detailed overview of the different *containerizer* options
    in Mesos besides introducing some other topics such as networking for Mesos-managed
    containers and fetcher cache. Finally, an example for deploying containerized
    apps in Mesos is provided for better understanding. The following topics will
    be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos Containerizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos Containerizer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Containerizer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing Containerizer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking for Mesos-managed containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos Image Provisioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetcher Cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying containerized apps using Docker and Mesos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Linux Container, (referred to simply as container for the rest of this chapter)
    allows applications to run on an allocated share of resources within an isolated,
    individual environment. Since all containers share the **Operating system (OS)**
    of the host machine and do not require the OS to be loaded up, they can be created
    in a matter of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Container technology, based on operating system level virtualization, has been
    present for over a decade now. OS level virtualization is a method by which an
    OS kernel allows creation of many user namespace instances (also called containers)
    instead of only one.
  prefs: []
  type: TYPE_NORMAL
- en: We can look at containers as encapsulated, individually deployable components
    running as isolated instances on the same kernel. Containers have a big advantage
    over traditional technologies such as bare metal, meaning servers with an operating
    system or virtualized environments such as **Microsoft Hyper-V**. From a developer's
    point of view, we can just package our application and dependencies into a container,
    and deploy it to any environment that supports containers. By doing this, we also
    make our application easy to update, upgrade, and even easily portable from one
    environment to another, for example, from a development environment on the desktop
    to a test environment in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two popular models for containers are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypervisor-based**: The hypervisor-based model includes redundant OS kernels
    and other libraries, which makes this an inefficient setup, as shown in the subsequent
    image (source: [http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/](http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/)):![Containers](img/B05186_07_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container-based**: The container-based approach involves encapsulated, individually
    deployable components running as isolated instances on the same kernel, as shown
    in the following image (source: [http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/](http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/)):![Containers](img/B05186_07_02.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why containers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some important benefits of using containers are:'
  prefs: []
  type: TYPE_NORMAL
- en: Application-centric management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of deployment and build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifies the application deployment process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports Agile development through Continuous Integration and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows breakdown of large monolithic applications into manageable micro-services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure environment consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High portability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker** is an open-source platform that automates the process by which any
    application is deployed in the form of a container that is portable, lightweight,
    self-sufficient, and which can run virtually anywhere. Primarily based on the
    **LXC** or **Linux Container**, Docker is used by developers and system administrators
    while working with distributed applications. Rather than being an underlying technology,
    this platform acts as a comprehensive abstraction layer that enables developers
    to *package* or *containerize* an application, including its dependencies, and
    run it on any infrastructure. Simply put, Docker containers function like shipping
    containers which offer a standard and reliable way of shipping literally any application.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker provides the Development and IT Operations teams with much needed agility
    and control to 'build, ship, and run any app, anywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build**: Docker gives you the flexibility to create an application from micro-services,
    and not worry about probable inconsistencies between the production and development
    environments. Additionally, there is no restriction on using any particular platform
    or language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ship**: Docker allows you to design the entire cycle comprising application
    development, testing, and distribution, and simplifies its management via a consistent
    user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run**: Docker offers you the ability to choose from a variety of platforms
    to deploy scalable services in a secure and reliable fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the chief advantage of Docker is that it presents an 'application first'
    architecture, which also allows developers and IT Ops / System Admins to focus
    on their core job functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Developers**: They are concerned only with what''s *inside* the container,
    such as their code, data, apps, libraries, and the package manager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IT Ops**: They have to focus on what''s *outside* the container, namely logging,
    monitoring, remote access, and network configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Docker essentially brings to the table can be effectively summarized in
    the following points:-
  prefs: []
  type: TYPE_NORMAL
- en: '**Agility**: Using Docker, a developer has the freedom to define an environment.
    Creation and deployment of apps can be carried out in a fast and easier manner
    with IT ops having the flexibility to rapidly respond to change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control**: Ensures that ownership of the code, all the way from infrastructure
    to the app, lies solely with the developer. The IT operations governs the manageability
    aspect in terms of standardizing, securing, and scaling the operating environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Gives you the choice, minus the complexity, of working with
    a single developer or a team, and using private infrastructure or public cloud
    providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a better understanding of the platform, let us look at some of the core
    terms associated with the Docker solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Image**: Basis of a Docker container when it is at rest. When instantiated
    through a Docker run command, they turn into a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile**: Its main function is to inform the image builder as to what
    the image has to look like.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Engine**: Can be installed on physical, virtual, or cloud hosts. This
    provides several core functions, which include the ability to pull Docker images,
    create and run new containers, scale existing containers, or stop and remove them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container**: These are built from Docker images. Their lightweight nature
    is attributed to the fact that they share image layer, and use union filesystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registry**: This is where Docker images are managed, distributed, and also
    stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Hub**: This is Docker''s hosted registry service for managing images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Machine**: This automates container provisioning on the chosen network
    or in the cloud. It can be installed on machines on Linux, Windows or, Mac OS
    X.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Compose**: This defines applications that require multiple containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Toolbox**: This delivers all the Docker tools consisting of Engine,
    Machine, Compose, and Kitematic to a Mac OS X or Windows system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Trusted Registry** (**DTR**): This provides a private, dedicated image
    registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Swarm**: This is used to host clusters and schedule containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kitematic**: Basically a Desktop GUI for Docker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic Docker system is shown in the following image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker](img/B05186_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the preceding diagram, a Docker container encloses a piece
    of software with everything that it needs to run, such as code, runtime, system
    libraries/tools. This encapsulation and isolation provided by a container warrants
    that the container will run in the same manner, irrespective of the environment
    it is run in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A virtual machine and a Docker container is shown in the following image (source:
    [http://www.jayway.com/2015/03/21/a-not-very-short-introduction-to-docker/](http://www.jayway.com/2015/03/21/a-not-very-short-introduction-to-docker/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker](img/B05186_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The figure that we just saw showcases the architectural difference between a
    virtual machine and a Docker container. The Docker container comprises only the
    application and its associated dependencies, and thus enjoys the benefits of both
    resource isolation and allocation like virtual machines, but is far more efficient
    and portable.
  prefs: []
  type: TYPE_NORMAL
- en: Docker's pluggable architecture is further leveraged by the presence of several
    open APIs (Swarm, Compose, Hub, and so on), which support the creation of an ecosystem
    with seamless application delivery. It is this combination that empowers Docker
    containers to make distributed applications composable, portable, dynamic, and
    ideal for agile teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker High-Level Architecture is shown in the subsequent image (source: [http://www.docker.com](http://www.docker.com)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker](img/B05186_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These advantages become increasingly apparent when we consider some enterprise
    use cases wherein organizations have used the Docker platform to tackle certain
    technical or business challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Integration**: Powered by integration with tools like GitHub and
    Jenkins, Docker provides developers the ability to develop and test applications
    faster and within an environment of their choice. The entire process is perfectly
    streamlined with developers being able to submit code in GitHub, test it, and
    automatically trigger a build via Jenkins. The moment the image is complete, it
    can be easily added to the Docker registries. This functionality not only saves
    time on build and setup processes, but allows developers to automate the running
    of tests while they simultaneously work on other projects. Add to this the absence
    of inconsistencies while dealing with different types of environments, and you
    get a substantial improvement in efficiency levels on using Docker for continuous
    integration jobs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Delivery**: In addition to being language agnostic, Docker works
    in any environment and effectively eliminates problems arising out of irregularities
    between environments. Docker guarantees continuous delivery of code to quality
    assurance teams and customers in a manner that is quick, easy to consume, and
    supportive of a speedy resolution of issues. Combined with Docker registries,
    the integration with other production platforms such as Docker Universal Control
    Plane and Tutum, facilitates code to be distributed to teams that can fully test
    it within the staging environment itself, before placing it into production. This
    aids enterprises by reducing the time and money required to build and ship applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps**: With organizations increasingly adopting the DevOps philosophy,
    Docker provides key tools that assist both developers and operations teams in
    improvising the application development process. These tools break down the traditional
    barrier between the aforesaid teams by compartmentalizing their work and concern
    areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Big Data**: Enterprises today are moving to big data systems/technologies
    in a bid to derive deep and comprehensive analysis of the data they collect. However,
    data sources are variant and multiple (images, videos, metadata and so on). Herein
    lies the advantage of utilizing a system that can uniformly transport data across
    analytics platforms. The adoption of the Docker platform provides a significant
    competitive advantage, because it facilitates the unobstructed movement of applications
    across different types of environments to ensure seamless data analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure Optimization**: Unlike virtual machines that require a guest
    OS or hypervisor, Docker containers consist of only what is necessary to build,
    ship, and run applications. Add to this the ability to spin up or down containers
    based on requirements, and Docker proves to be a great value-add to enterprises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker goes a step further and provides cloud portability that frees IT ops
    teams from being tied down to specific environment tools. Effectively, Docker
    reduces the amount of storage and infrastructure costs for enterprises, and also
    increases efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Containers, as described in the previous section, are used for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Isolating a task from other tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that tasks run in finite or restricted resource environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatically controlling the individual resources of a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running applications in different environments through a packaged image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking applications into smaller, manageable micro-services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks can be run in containers through **containerizers**. Mesos provides support
    for popular container technologies such as Docker while also having its own container
    technology. Recently, support has also been added for combining and allowing different
    container technologies to work together (for example, Mesos and Docker).
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the key requirements of a cluster manager is to ensure that the allocation
    of resources to a particular framework does not have any impact on any active
    running jobs of some other framework. Provision for isolation mechanisms on slaves
    for compartmentalizing different tasks is, thus, a key feature of Mesos. Mesos
    leverages containers for resource isolation, which has a pluggable architecture
    as well. The Mesos slave uses Containerizer API to provide an isolated environment
    to run a framework's executor and its corresponding tasks. The Containerizer API's
    objective is to support a wide range of implementations, which implies that custom
    containerizers and isolators can be developed. When a slave process starts, the
    containerizer to be used to launch containers and the set of isolators to enforce
    the resource constraints can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizer types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following containerizer options are available in Mesos version 0.27:'
  prefs: []
  type: TYPE_NORMAL
- en: Composing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos (default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The containerizer type can be specified by the user through the agent flag,
    `--containerizers.`
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Containerizer creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A containerizer is created by the slave based on the flag configuration (using
    agent flag `--containerizers`). The composing containerizer is used to create
    the containerizer in cases where multiple containerizers (for example, Mesos and
    Docker) are listed through the `--containerizers` flag.
  prefs: []
  type: TYPE_NORMAL
- en: The Mesos agent utilizes the task default executor in cases where an executor
    is not specifically mentioned in `TaskInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containerization in Mesos is shown in the ensuing figure (source: Apache Mesos
    Essentials: [https://www.packtpub.com/big-data-and-business-intelligence/apache-mesos-essentials](https://www.packtpub.com/big-data-and-business-intelligence/apache-mesos-essentials)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Containerizer creation](img/B05186_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mesos containerizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the default containerizer type provided by Mesos. In this type, tasks
    can be run through an array of pluggable isolators provided by Mesos. It can be
    enabled by configuring the agent flag as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This type is typically used when:'
  prefs: []
  type: TYPE_NORMAL
- en: User needs to control the task environment through Mesos without having to rely
    on other container solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-grained OS controls are desired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom resource isolation needs to be added for tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User needs to control certain resource parameters (for example, disk usage limits)
    which are not exposed by other container solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any task which doesn't specify `ContainerInfo::DockerInfo` will be handled by
    the Mesos containerizer.
  prefs: []
  type: TYPE_NORMAL
- en: The launching process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The container launching process includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparation of calls is done on every **isolator**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The launcher, responsible for forking/destroying containers, is used to fork
    the executor. The forked 'child' cannot execute until the isolation step is completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **executor** is isolated by calling the isolators. Isolators are responsible
    for creating an environment for the containers, where resources like CPU, network,
    storage, and memory can be isolated from other containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The executor is fetched and the forked child notified to execute. Isolator preparation
    commands are run first, followed by the execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos containerizer states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The different Mesos containerizer states are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: PREPARING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ISOLATING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FETCHING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RUNNING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DESTROYING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By leveraging Linux features such as namespaces and **control groups** (**cgroups**),
    the Mesos Containerizer provides resource isolation and lightweight containerization.
    It provides the capability for different isolators to be selectively enabled.
    In addition, support for **POSIX** (**Portable Operating system Interface**) systems
    is also present, though it only includes usage reporting and not actual isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three isolator options present and they are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Shared Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modifications to every container's shared filesystem view can be enabled using
    the Shared Filesystem isolator on Linux hosts.
  prefs: []
  type: TYPE_NORMAL
- en: The modifications can be specified either through the `–default_container_info
    agent` flag or by the framework in the `ContainerInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes, used to map sections of the shared filesystem (such as host path with
    the container's view of the shared filesystem, that is, container path), can be
    specified through `ContainerInfo` as read-only or read-and-write. The path of
    the host can be absolute or relative. If absolute, it also results in the filesystem
    subtree being made accessible for every container under the container path. If
    relative, then it is taken to be a directory which is relative to the work directory
    of the executor. The directory is created, and permissions from the corresponding
    existing directory in the shared filesystem are copied over.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason why this isolator is used is to make certain shared filesystem
    sections private to every container selectively. As an example, a private directory
    `/dir_name` can be set by making `host_path="dir_name"` and `container_path="/dir_name"`.
    This creates a directory `dir_name` inside the executor's work directory while
    also mounting it as `/dir_name` within the container. The container won't be able
    to see the host's `/dir_name` or any other container's `/dir_name,` and this action
    is transparent to the processes running within it.
  prefs: []
  type: TYPE_NORMAL
- en: Pid namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This isolator is used to isolate every container in a different pid namespace,
    which gives the following two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visibility**: The executor and descendant processes running within the container
    cannot view or interact with external processes running outside the namespace.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Clean Termination**: If the leading process in a pid namespace is terminated,
    the kernel terminates all other processes running within the namespace.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Posix Disk isolator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This isolator, which can be used on both OS X as well as Linux, is used for
    providing basic disk isolation. The disk utilization for every sandbox can be
    reported using this, and any set disk quotas can be enforced as well.
  prefs: []
  type: TYPE_NORMAL
- en: When starting the slave, `posix/disk` must be added to the `--isolation` flag
    to enable this isolator.
  prefs: []
  type: TYPE_NORMAL
- en: The disk quota enforcement is disabled by default. When starting the slave,
    specify `--enforce_container_disk_quota` to enable it.
  prefs: []
  type: TYPE_NORMAL
- en: Disk utilization for every sandbox is reported by periodically running the `du`
    command. The resource statistics endpoint (`/monitor/statistics.json`) provides
    a way to retrieve the disk utilization statistics.
  prefs: []
  type: TYPE_NORMAL
- en: The time interval between two `du` commands can be configured through the agent
    flag `--container_disk_watch_interval`. For example, `--container_disk_watch_interval
    = 1 mins` specifies the time interval as 1 minute. 15 seconds is the default time
    interval.
  prefs: []
  type: TYPE_NORMAL
- en: Docker containerizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This containerizer type permits running of tasks inside a Docker container.
    A Docker image can either be launched as an executor or as a task. It can be enabled
    by configuring the agent flag as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is normally used when:'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker package needs to be leveraged for running tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Mesos slave is running within a Docker container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to enable the Docker Containerizer on a slave, the slave must be launched
    with "Docker" as one of the containerizer options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every slave where the Docker containerizer is specified must also have the Docker
    Command Line Interface client (version 1.0.0 or above) installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `iptables` are enabled on the slave, ensure that the `iptables` permit all
    traffic from the bridge interface by making the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Launching process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The container launching process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Task launching in Docker is attempted only if `ContainerInfo::type` is set to
    `DOCKER`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image is pulled first from the specified repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pre-launch hook is then called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The executor is then launched in one of the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mesos agent runs in a Docker container in the following cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the flag `--docker_mesos_image` is present, it indicates that the Mesos agent
    is running within a Docker container
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The flag `--docker_mesos_image` value is considered to be the Docker image that
    will be used for launching the Mesos agent
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If an executor different from the default command executor is used by the task
    to run, it gets launched within a Docker container
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `TaskInfo` is used by the task, then the default `mesos-docker-executor`
    gets launched within a Docker container to execute commands through the Docker
    Command Line Interface.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mesos agent does not run in a Docker container in the following cases :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `TaskInfo` is used by a task, a sub-process to run default `mesos-docker-executor`
    is forked. Shells are spawned by this executor to run Docker commands through
    the Docker Command Line Interface.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a custom executor is used by the task to run, it gets launched within a Docker
    container.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker containerizer states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following are the different Docker containerizer states:'
  prefs: []
  type: TYPE_NORMAL
- en: FETCHING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PULLING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RUNNING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DESTROYING
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing containerizer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type allows for combining and allowing different container technologies
    to work together (for example, Mesos and Docker). It can be enabled by configuring
    the `--containerizers` agent flag with a comma-separated list of required containerizer
    names
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first containerizer specified in the list, which provides support for the
    task's container configuration, is used for task launching.
  prefs: []
  type: TYPE_NORMAL
- en: This option is generally used when tasks having different resource isolation
    types need to be tested. A framework can leverage the composer containerizer to
    test a task using the controlled environment provided by the Mesos containerizer,
    while simultaneously ensuring that the task works with Docker containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking for Mesos-managed containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major goals to provide networking-related support in Mesos was to
    develop a pluggable architecture leveraging which custom networking mechanisms
    could be implemented by users as per their requirements. Since networking requirements
    vary across different deployment scenarios (cloud, on-premise, private cloud,
    or other hybrid models), it is not practical to create a monolithic networking
    mechanism that caters to all needs. Mesos' pluggable architecture proves to be
    very useful in tackling this.
  prefs: []
  type: TYPE_NORMAL
- en: To provide networking support, many opt-in extensions were introduced in Mesos
    components from version 0.25.0 onwards. The opt-in structure allows existing frameworks
    without networking support to continue operating seamlessly on newer Mesos versions.
    Mesos enables integration with other networking mechanisms, and provides features
    like service discovery, IP per container, and isolation of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Networking support is provided through a Mesos module, which implies that it
    is abstracted away from the Mesos master and slaves. All the required support
    needs to be enabled from the networking module itself. Since IP requests are handled
    on a best-effort basis, frameworks also need to be able to take care of cases
    where a request is ignored due to networking modules not being implemented, or
    where a request is denied due to inability of the module to assign an IP.
  prefs: []
  type: TYPE_NORMAL
- en: Framework Schedulers need to opt in for network isolation through use of additional
    data structures in `TaskInfo`. This structure ensures that backward compatibility
    is maintained with older frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution architecture with a description of the different components is
    provided as shown in the following diagram (source: [http://mesos.apache.org/documentation/latest/networking-for-mesos-managed-containers/](http://mesos.apache.org/documentation/latest/networking-for-mesos-managed-containers/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture](img/B05186_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Key terms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some key terms regarding networking are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP Address Management (IPAM) Server**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPs are assigned on demand
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: IPs are recycled upon being released
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: IPs can be optionally tagged with the provided ID
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPAM client**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coupled tightly with the corresponding IPAM server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Serves as a bridge between the IPAM server and Network Isolator Module
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles IP-related communications with the server (release, request, and so
    on)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Isolator Module (NIM)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos module for the slave where the isolator interface is implemented
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Task IP requirements are determined by looking at `TaskInfo`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles IP-related communications with the IPAM client (release, request, and
    so on)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enables network isolation by communicating with the external network virtualizer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cleanup Module**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles cleanup tasks (such as IP release) when the slave is lost
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Mesos framework requests IPs for every container being launched, using the
    `TaskInfo` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Mesos master forwards these messages to the slave after processing them
    for launching and running tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Mesos slave figures out the container requirements by analyzing these messages,
    and prepares the different isolators for them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Network Isolator Module** analyzes the messages, and decides whether the
    network isolators should be enabled or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Network Isolator Module then communicates with the IPAM client to request
    the IP addresses, provided it decides that the network isolator needs to be enabled,
    and gives a status update to the slave.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon receiving this update, a container is launched by the slave within a different
    namespace. This is done by the Network Isolator Module which informs the network
    virtualizer to perform container isolation upon getting instructions from the
    slave to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IP information is added to `TaskStatus` by the Network Isolator Module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Network Isolator Module then makes the IP addresses from `TaskStatus` available
    at the master's state endpoint, while also making the frameworks aware of the
    IP addresses by forwarding the `TaskStatus` to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a task is lost, the Network Isolator Module informs the IPAM client of the
    same, and gets the IP addresses released.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cleanup module then gets notified, and then recycles all the IP addresses
    released by the IPAM client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A sample implementation of a Networking Isolator Module can be seen at [https://github.com/mesosphere/net-modules](https://github.com/mesosphere/net-modules).
  prefs: []
  type: TYPE_NORMAL
- en: IP-per-container capability in frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frameworks that seek to implement IP per container, need to pass the message
    `NetworkInfo` within `TaskInfo`. The `NetworkInfo` message details are given in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkInfo message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A new `NetworkInfo` message can be introduced as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The protocol field needs to be set to `IPv4` or `IPv6` while an IP address from
    the IP Address Management is requested. If supported by the Network Isolator Module,
    a framework can set a static IP address for each container. This can be done by
    providing a valid IP as the `ip_address` string. This is typically required when
    tasks that get killed or lost need to be relaunched on another node with the same
    IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Examples for specifying network requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The frameworks which want to enable an IP per container need to provide `NetworkInfo`
    message in `TaskInfo`. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Request for single IP address without a protocol version being specified using
    the default command executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Request for two IP addresses, one of IPv4 protocol and another of IPv6 protocol,
    in two sets using the default command executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Request for two network interfaces, each with one IP address and each in a
    different network group using the default command executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Request for a specific IP address using a custom executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Address discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As seen earlier, frameworks can request IP addresses for assignment during
    launching of tasks on the Mesos slaves by passing the `NetworkInfo` message within
    the `TaskInfo` message. The frameworks, after opting for network isolation, also
    need a mechanism for knowing the IP addresses finally assigned so that monitoring
    and other communication activities can be undertaken. This can be done by introducing
    an additional field in the `TaskStatus` message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a Custom Network Isolator Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mesos provides an Isolator API to enable custom Network Isolator Module implementations
    on top of it. The implemented module gets manifested as a dynamic shared library
    within the Mesos slave, and seamlessly integrates with the container launch. A
    network isolator often communicates with network virtualizers and IPAM clients
    to meet the framework needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three key functions that a Network Isolator Module must implement are described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Isolator::prepare()`: This gives the module an option to determine whether
    or not network isolation needs to be enabled for the specified container. The
    `Isolator::prepare` function instructs the slave to create a different network
    namespace if network isolation is to be enabled. This interface is also responsible
    for creating an IP address for the container.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Isolator::isolate()`: This gives the module the chance to isolate the task
    container after its creation but before launching of an executor within it. It
    involves a virtual Ethernet adapter creation for the container and the assignment
    of an IP address to it. It can also leverage an external virtualizer for network
    setup.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Isolator::cleanup()`: This function is called upon container termination.
    Its main job is to recover and recycle released IP addresses, and undertake any
    other cleanups as necessary.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitoring container network statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Statistics for every container network are provided via the `/monitor/statistics.json`
    slave endpoint by Mesos.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following counters are reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Metric | Description | Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `net_rx_bytes` | Bytes received | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `net_rx_dropped` | Dropped packets (receive) | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `net_rx_errors` | Reported errors (receive) | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `net_rx_packets` | Received packets | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `net_tx_bytes` | Bytes sent | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `net_tx_dropped` | Dropped packets (send) | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `net_tx_errors` | Reported errors (send) | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `net_tx_packets` | Sent Packets | Counter |'
  prefs: []
  type: TYPE_TB
- en: 'Additionally, the following counters and gauges can be reported for the elements
    which implement bloat reduction or bandwidth limiting under the `statistics/net_traffic_control_statistics`
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Metric | Description | Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `backlog` | Queued bytes (only on bloat reduction interface) | Gauge |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | Bytes sent | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `drops` | Dropped packets (send) | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `overlimits` | Number of times interface was over its transmit limit | Counter
    |'
  prefs: []
  type: TYPE_TB
- en: '| `packets` | Sent packets | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| `qlen` | Queued packets | Gauge |'
  prefs: []
  type: TYPE_TB
- en: '| `ratebps` | Rate of transmission (currently, always 0 bytes/second) | Gauge
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ratepps` | Rate of transmission (currently, always 0 packets/second) | Gauge
    |'
  prefs: []
  type: TYPE_TB
- en: '| `requeues` | Failed packets | Counter |'
  prefs: []
  type: TYPE_TB
- en: Example statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An example of the statistics obtained is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Mesos Image Provisioner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Image** is an ordered collection of root filesystem changes and the corresponding
    execution parameters for use within a container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the container specifications, such as Docker, **App** **Container**
    (**AppC**), or **Open Container Project** (**OCP**), combine implementation and
    specification of the image format with other container components such as resource
    isolation and task execution to a large extent. The Mesos **Image Provisioner**
    seeks to enhance the capabilities of Mesos Containerizer by providing support
    for container filesystem provisioning from multiple image formats, while also
    providing features such as resource isolation by combining with other components
    such as Isolators.
  prefs: []
  type: TYPE_NORMAL
- en: Mesos containers created using the Mesos Containerizer are provided with a root
    filesystem already provisioned with Docker or AppC images using the Mesos Image
    Provisioner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container filesystem image is described by a new message `Image,` which
    is given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This message contains both the image specification type as well as the corresponding
    type configurations. This message can be passed through either 'Volume' or `ContainerInfo`.
    A root filesystem is provided to the task when an image is configured in `ContainerInfo,`
    while volumes are mounted with the image filesystem in cases where the 'Image'
    message is specified within 'Volume'.
  prefs: []
  type: TYPE_NORMAL
- en: The request for container image is forwarded to the respective provider for
    provisioning the layers. Layers are generally filesystem changesets, which are
    nothing but an archive of the added, modified, or deleted files. The Provisioner
    further asks the configured setup to provision a root filesystem from these layers.
  prefs: []
  type: TYPE_NORMAL
- en: Setup and configuration options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable Mesos containerizer on the slave, it must be launched with the `mesos
    containerizer` (default) option, as shown earlier in this chapter. The slave also
    needs to be running on Linux with root permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, filesystem/Linux must be set as the isolator option via the `--isolation`
    flag. The image providers can be configured by passing them as a comma-separated
    list in the agent flag `--image_providers,` and the supported backend can be specified
    though the flag `--image_provisioner_backend`. Additional configurations for every
    image provider can also be provided if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For more information, visit [http://mesos.readthedocs.io/en/latest/mesos-provisioner/](http://mesos.readthedocs.io/en/latest/mesos-provisioner/).
  prefs: []
  type: TYPE_NORMAL
- en: Mesos fetcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Mesos fetcher is a way by which resources can be downloaded in the `task
    sandbox` directory while preparing the task execution. The framework requesting
    the execution of the task sends a list of `CommandInfo::URI` values as part of
    the `TaskInfo` message, which in turn serves as the Mesos fetcher input.
  prefs: []
  type: TYPE_NORMAL
- en: The Mesos fetcher natively supports the FTP and HTTP protocols, and is also
    able to copy over files from a filesystem. It also supports all Hadoop client
    protocols such as **Amazon Simple Storage Service** (**S3**), **Hadoop distributed
    Filesystem** (**HDFS**), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Every Uniform Resource Identifier (URI) that is requested gets downloaded, by
    default, directly into the `sandbox` directory. Multiple requests for the same
    URI results in copies of that resource being downloaded again and again. The downloaded
    URIs can also alternatively be cached in a specified directory for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The mechanism comprises the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Each slave consists of one internal fetcher instance which is leveraged by all
    containerizer types. The fetcher process, included in the slave program, is responsible
    for performing book-keeping around what is present in the cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is also an external `mesos-fetcher` program that gets called by the internal
    program mentioned in Step 1 whenever resources need to be downloaded from specified
    URIs into the cache or directories. It is also called when resources from cache
    need to be moved over to the `sandbox` directory. All disk and network operations,
    barring deletions and querying file size, are performed by it. It acts more like
    a simple helper program while all the intelligence is located in the internal
    program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No persistent state is maintained in the entire system except for the cache
    files. This helps manage the complexity involved in simultaneous fetching and
    caching, and generally simplifies the overall architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the interactions between the internal fetcher
    process and the external `mesos-fetcher` program. Subsequent diagrams dive into
    the internal workflow in more detail. Source: [http://mesos.apache.org/documentation/latest/fetcher-cache-internals/](http://mesos.apache.org/documentation/latest/fetcher-cache-internals/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mechanism](img/B05186_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cache entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fetcher process can provide details around the cached URIs besides giving
    information regarding the location of the cache files, the processing stage, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: A **HashMap** is used to store all the information mentioned previously. Each
    of the `Cache::Entry` objects contain the details of one cache file. These objects
    can be referenced by numerous callbacks corresponding to the multiple fetches
    while being stored in the HashMap.
  prefs: []
  type: TYPE_NORMAL
- en: Each cache entry has a one-to-one correspondence with a disk cache file during
    the entire duration of the file, which also includes the period before and after
    its creation. The entry includes all relevant state information regarding the
    stage as well as the corresponding URI fetching results.
  prefs: []
  type: TYPE_NORMAL
- en: A cache entry cannot be removed by any fetch attempt seeking to free up space
    for a newly downloaded cache file while it is being referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram shows the various states of a cache entry. It illustrates
    the sequence of events that take place during a single fetch run. The colors in
    the diagram represent the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blue**: No cache exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**: Cache entry unreferenced by this run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orange**: Cache entry referenced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A cache entry should not be removed as long as any event is referencing it.
    This is enforced by something called **reference counting**. The value of a field
    called reference count within each cache entry is increased whenever it is being
    used by a fetch attempt, and decreased when the run is over, regardless of whether
    the run was successful or not. The value is incremented in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation of a new cache entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for file download of an existing entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching of the cache file corresponding to an entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each value increase is noted within a list. At the end of the activity causing
    the increment, the value is decreased.
  prefs: []
  type: TYPE_NORMAL
- en: The figure given illustrates the different states which a cache entry can be
    in.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cache entry](img/B05186_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: URI flow diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fetcher process determines the control logic for handling every URI being
    fetched. The following is a diagram illustrating the flowchart for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![URI flow diagram](img/B05186_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cache eviction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the case where a couple of resources, *A* and *B*, have been fetched
    and cached into two sandboxes respectively, as shown in the following diagram.
    In this process, one cache file for each resource is created along with the cache
    entries mapping the resources with the corresponding cache files. Source: [http://mesos.apache.org/documentation/latest/fetcher-cache-internals/](http://mesos.apache.org/documentation/latest/fetcher-cache-internals/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cache eviction](img/B05186_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let us assume a third resource *C*, which is downloaded and cached into
    a new sandbox. Assuming there is no space for all three entries, this requires
    removal or eviction of an existing cache file along with its corresponding entry
    to accommodate the new one. Assuming resource *A* was fetched before *B*, the
    cache eviction process would remove *A*, since it is the oldest entry. The removal
    steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cache entry for *A* is removed from the entry table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*C* is fetched, which creates a new cache file of a different name along with
    the associated cache entry.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Cache eviction](img/B05186_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the first resource *A* is fetched again, then *B* would now get evicted,
    since it is the oldest present entry; the assumption, of course, being that there
    is no space to accommodate three cache files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cache eviction](img/B05186_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deploying containerized apps using Docker and Mesos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section gives a brief overview of deploying a Docker containerized Node.js
    application on Mesos using Marathon. This requires you to have Docker and fig
    already installed on the machine. Let''s follow the steps listed next to carry
    out the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are deploying a simple Node.js application, we can start off by creating
    a simple `App.js` to print `Hello World`, a simple hello world Node.js program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next we create the `package.json` file with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to dockerize our application. For that, we can create a `Dockerfile`
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now build the container with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can make sure everything is working correctly by opening the `localhost:8000`
    from the browser, which should display our **Hello World** text.
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying containerized apps using Docker and Mesos](img/B05186_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to build our `fig.yml` file. Here we will be using fig as
    an orchestration engine to deploy all central services from a single command.
    The `fig.yml` file will look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding configuration, we have configured the Docker registry to run
    on port `5000` along with a single Mesos slave, Mesos master, Marathon, and ZooKeeper
    for internal communication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now start the Docker registry service with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will start all the services listed in the preceding configuration
    file such as Mesos master, Mesos slave, Marathon, ZooKeeper, and Docker registry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now build the Docker image, and push it to the registry with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the cluster ready, we can deploy our Node.js application through
    Marathon. For that we need to create an application configuration file (`app_marathon.json`)
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is then deployed on Marathon with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now open the Marathon Web UI running on port `8080,` and see our Node.js
    application up and running:![Deploying containerized apps using Docker and Mesos](img/B05186_07_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And we can see our Node.js hello world application by pointing the browser
    to `localhost:31000` port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying containerized apps using Docker and Mesos](img/B05186_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '(Reference: [http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute/](http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute-part-2/](http://container-solutions.com/continuous-delivery-with-docker-on-mesos-in-less-than-a-minute-part-2/))'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter touched upon several important topics related to containerization
    in Mesos. Resource isolation is one of the most touted features of Mesos, and
    the topics explained in this chapter have hopefully helped you understand this
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see some of the important Big Data frameworks which
    are currently supported by Mesos such as Hadoop, Spark, and Storm and understand
    how these can be set up and configured on Mesos.
  prefs: []
  type: TYPE_NORMAL
