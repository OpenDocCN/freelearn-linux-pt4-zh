- en: Passing Data through the Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting columns from the output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limiting the number of items returned by a cmdlet
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expanding selections
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filtering objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grouping the output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sorting the output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Taking actions on the returned objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding pipeline-enabled parameters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing content into PowerShell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time for some information feasting now. In the previous chapter, *First
    Steps in Administration using PowerShell*, we looked at a few simple concepts
    such as working with dates and processes. In doing so, we learnt a thing or two
    about using PowerShell as well, for example, measuring the output objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn to use one of those things that make PowerShell
    highly efficient and friendly: The Pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux administrators would have used the pipeline in their shell commands
    or shell scripts. And most administrators who use any form of shell scripting
    would be aware that the pipe sends the output of one command as input to the next.
    It is also true in case of Bash (and its derivatives) that the pipe sends *text*
    from the preceding command to the succeeding one.
  prefs: []
  type: TYPE_NORMAL
- en: Most PowerShell cmdlets output objects. And the pipeline in PowerShell sends
    the output *object* to the next command. When we run a PowerShell command (and
    not a Linux command) in PowerShell, we get a table-like output in most cases.
    We may think that it is all of the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we ask PowerShell to get any information, it pulls out entire the object
    in the background. This object (or a package that contains a lot of objects) is
    then processed using PowerShell''s built-in formatting rules in order for it to
    be displayed on the host. To quote Microsoft:'
  prefs: []
  type: TYPE_NORMAL
- en: What you see onscreen is a summary of information, and not a complete representation
    of the output object.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, more often than not, what you see on the screen as the output of
    a certain command, is just a tip of the iceberg! Just that the *submerged* part
    was chosen not to be displayed based on the formatting rules. In this chapter,
    we will use the pipeline to get more from the objects, than is displayed on the
    screen by default, and leverage the capability of the pipeline to get more out
    of PowerShell than meets the eye.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting columns from the output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When my brother saw me exploring `awk`, he said, 'Boy, have we overused this
    command!' Of course, not everything displayed on the screen is important—or even
    necessary. In this recipe, we learn to separate the columns in PowerShell, without
    using the Linux command, `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to a directory that has some files that we can play with. If you do not have
    such a directory, create one and create some files in there. Let the files be
    of different extensions, so that we can use them in the future recipes as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already, clone the git repository, [https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook](https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook).
    There is a quick-and-dirty script, `Initialize-PacktPs6CoreLinuxLab.ps1` under
    the directory, `chapter-05`. Run the script to get the necessary files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `awk` command works with text, and based on the delimiters in the output
    text, separates the output into columns. This separated output is displayed as
    columns again, using a the `print` function, like in C. PowerShell works a little
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: Let us get started.
  prefs: []
  type: TYPE_NORMAL
- en: If you did not create files, please do so. Here are some commands you could
    use to create the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may also want to download some real multimedia content, just so we get the
    `length` (file size) property for future use. Just download any random images
    or media files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the location where you saved the files. I have them in a directory
    called `random` in my home directory. You would, too, if you used the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Use tab-completion to complete the cmdlet as well as the path.
  prefs: []
  type: TYPE_NORMAL
- en: List out the contents in the current location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/fc1b8222-bc35-4723-bc80-b3c548ec789f.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us say, you do not require the `Mode` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/66a9b353-b59f-4822-9b84-ea92bae58933.png)'
  prefs: []
  type: TYPE_IMG
- en: If you notice, select does not seem to follow the naming or capitalisation convention
    that PowerShell uses. How is that? Run `Get-Command select` to find out.
  prefs: []
  type: TYPE_NORMAL
- en: This sequence does not really make sense to you in the current context. Shuffle
    the columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3f839c8d-22b8-45c0-bbf9-913af8c94295.png)'
  prefs: []
  type: TYPE_IMG
- en: That looks much better.
  prefs: []
  type: TYPE_NORMAL
- en: Now, change the column name of `LastWriteTime` to `Modified`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice the name of the last column now, and compare it with the previous output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, pick just the year; not the entire date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See how many days have passed since the last change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ran `Get-Command select`, you would have understood by now, that `select`
    is in fact an alias for `Select-Object`. As already established, PowerShell outputs
    objects. These objects are then formatted using built-in formatting rules to show
    on the screen a certain way.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `Select-Object`, we override the formatting rules by specifying
    which objects need to be shown to us. While the primary objective of `Select-Object`
    is to pick the columns we need, the cmdlet also allows us to sequence the output
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell also gives us the freedom to modify the name of the columns returned.
    In such a case, we use a *hashtable* to specify the name that we want, and what
    data we want shown under the column. You can even perform calculations on the
    data returned, and make this a calculated property. At the last step, we subtract
    the date of last modification from the current date, pick the total number of
    days that have passed since, and then, use the `Round` method of the `[math]`
    accelerator to get a rounded figure of the number of days since the last modification.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of `$_` or `$PSItem`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try `Select-Object` with other cmdlets such as `Get-Command`, to select only
    those columns that you need.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipe : Creating and initialising a simple hash table.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number of output objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Selecting columns from the output*, we saw how the
    `Select-Object` cmdlet can be used to select only the columns we want. In this
    recipe, we will learn to limit the output of a cmdlet to a subset of the total
    items returned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you are at a location that has a few files. List out the contents
    of the current directory and count the number of items returned. If the number
    is less than five, you may want to consider adding more items to the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the following command to count the number of files and directories at
    the current path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you would like to reduce keystrokes, given that we are only running commands
    at the terminal, you could use the alias and the defaults of the cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Those parentheses are required; the parentheses work almost similar to how
    they work in mathematics: the instruction within the parentheses is processed
    first. In this case, we want `gci` executed first, and then, the `Count` property
    from within the returned object picked.'
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of parameters `Select-Object` has.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We see parameters like, `First` and `Last`, and they accept integer values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigate to the directory where you have the files.
  prefs: []
  type: TYPE_NORMAL
- en: Select only the first five files and directories from the returned list, using
    the `First` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let us say you would like to pick the last five elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To skip the first three objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to skip the last two objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To pick the fourth element from the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, combine it with what we learnt in the previous recipe. Pick only the file
    names and the last modified time of the first four elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a simple recipe that helps you work with the number of items returned
    in the output. With `Select-Object` in PowerShell, we need not loop through output,
    while simultaneously counting, to only get the number of elements that we want.
    The `Select-Object` cmdlet has that functionality built in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter names are self-explanatory. Except perhaps the `Index` parameter,
    which works exactly how numbering of array elements works with most programming
    languages: it starts with zero. Therefore, the fourth element in the array would
    have an index of `3`, and not `4`.'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters, `Property` and `First` can be combined together since they both
    feature in the same parameter set in the help documentation for `Select-Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the properties within properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far from what we have seen, two things are clear to us:'
  prefs: []
  type: TYPE_NORMAL
- en: An object output feels richer and makes using it easier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An object can have more objects within it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have handled the first point using the `Select-Object` cmdlet, wherein we
    picked only the objects properties that we needed, and omitted the rest. This
    recipe is designed to break down the second point for better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us step into this recipe with one thing in our mind: objects can contain
    objects within them, which in turn can contain more objects within them. To demonstrate
    this, we shall use the `Get-Process` cmdlet.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us begin with listing out the processes; we shall look at all the properties
    the `Get-Process` cmdlet gives us and look for complex ones.
  prefs: []
  type: TYPE_NORMAL
- en: Select all the properties that are part of the output of the `Get-Process` cmdlet.
    Pick only the first object, so your console is not filled with content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Observe the property, `Threads`.
  prefs: []
  type: TYPE_NORMAL
- en: Select the name of the process, the ID and the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: List out all the threads for the `pwsh` process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A lot of content is output. Say, we want just the ID, the priority, and the
    start time of the resulting output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This gave us the ID, the priority level and the start time of all the threads
    that are running under `pwsh`.
  prefs: []
  type: TYPE_NORMAL
- en: What if we use `ExpandProperty` on the ID?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9a082625-cdef-4a3d-ab7a-dc865b01364f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default parameter for `Select-Object`, as we have seen, is `Property`. It
    accepts property names and shows their values in the output. The parameter can
    be used to fetch values of multiple properties (`Name`, `Id`, `Threads`).
  prefs: []
  type: TYPE_NORMAL
- en: However, some properties have more complex objects within them, like how we
    saw in case of the `Threads` property of the object returned by `Get-Process`.
    A simple way to identify complex objects is to see if they are enclosed in curly
    braces.
  prefs: []
  type: TYPE_NORMAL
- en: The `ExpandProperty` parameter accepts only a single property name as input
    and expands the property to show its objects. This can again be piped to `Select-Object`
    (or any other relevant cmdlet) for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where the object is not complex, `ExpandProperty` simply shows the
    output without its header. If you notice the output of `ExpandProperty`, it does
    not contain the name of the expanded object itself (`Threads` in our case); it
    contains only the value. The value, in turn has multiple properties within it.
  prefs: []
  type: TYPE_NORMAL
- en: In case of simple properties, using `ExpandProperty` simply strips off the property
    name from the output.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipe, *Limit the number of items returned by a cmdlet*, we saw how
    to restrict the output content based on a number. In this recipe, we would look
    at filtering the output based on a certain criterion, and not a number.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go back to read the recipe, *Working with date properties*, if you have not
    read it already. This recipe uses one of the properties from the date object to
    filter content. While it is not critical to understand filtration of objects,
    it still demonstrates the simplicity of filtration based on object properties.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigate to the location where you created files for use with this book.
  prefs: []
  type: TYPE_NORMAL
- en: List out the contents of this directory to see what content you have. (If you
    are like me, you would have even forgotten where you created this directory, and
    what content you put in.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice the names of the properties you got.
  prefs: []
  type: TYPE_NORMAL
- en: Now, pick only those files that are larger than `0` bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Pick out all the JPG files from the lot. To do this, add another condition to
    the existing condition. Although, this time, use the `FilterScript` parameter
    instead of `Property`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Add a condition to get only those files whose names start with 'c'.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, choose those files which were created before the 30th minute of any hour.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b3ae5d4b-631d-4e62-9ee6-c0c105aebfb5.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filtration of the output is very simple in PowerShell. Given that the content
    output is an object, we could simply use the properties from within the object
    for the filtration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe shows two modes of filtration:'
  prefs: []
  type: TYPE_NORMAL
- en: Using one property and comparing its value to the input,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a filter script, that uses multiple values, and multiple conditions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Property` parameter accepts only one property. A conditional operator and
    a value for comparison are added to the statement to filter the output.
  prefs: []
  type: TYPE_NORMAL
- en: The `FilterScript` parameter, on the other hand, can handle more complex filtration,
    for example, when we need the output to meet several conditions.
  prefs: []
  type: TYPE_NORMAL
- en: A significant difference between using `Property` and `FilterScript` is the
    use of the automatic variable, `$_`. This variable contains the *current object*
    in the pipeline. For example, in this recipe, we pass the object from `Get-ChildItem`
    to `Where-Object` through the pipeline. The automatic variable, `$_`, contains
    the object returned by `Get-ChildItem`, so that `Where-Object` can process it.
    `$_.LastWriteTime`, in this case, picks the `LastWriteTime` property from the
    object returned by `Get-ChildItem`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `LastWriteTime` object is of type `System.DateTime` or `DateTime`.
    (Run `(Get-ChildItem .).LastWriteTime | Get-Member` to know more.) Therefore,
    it is possible to break it down further into days, hours, minutes, and so on,
    which is the reason, `$_.LastWriteTime.Minute` could be used for filtration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try out the `Where-Object` cmdlet on other outputs, such as that of `Get-Process`.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping the output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations where we could group the objects that were output, so that
    we could handle each group better, or simply for a more organised output. In this
    recipe, we will look at passing the output of one cmdlet through the pipeline
    to Group-Object and group the output based on a property.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To group objects based on a property, we use the `Get-ChildItem` cmdlet on the
    files that we created for use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the location where you created or downloaded the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: List out only the files (exclude the directories).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Or use the *shorthand* version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Group the objects based on the extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The shorthand version of this would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/126cd1df-e553-47c3-becf-a56acb92fb78.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the `Select-Object` cmdlet to only show the extension and the number of
    files in each extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Is there a simpler way to do this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to handle grouping and expanded property selection, let
    us pick only the JPG files from the lot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f0b16425-bada-4fba-ad2d-f7c9a62124a9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we did in this recipe was certainly non-intuitive, considering we could
    use just `Where-Object` along with the `Get-ChildItem`. However, the intention
    of this recipe was to demonstrate the use of `Group-Object`. The `Group-Object`
    cmdlet creates groups based on the criteria we specify, and names the groups on
    the criteria. In our case, the criteria for grouping was the extension, and hence,
    the names of the groups were the extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these groups contains its elements, which are objects in themselves.
    If we simply want the count and the names of the groups, we use the `NoElement`
    parameter. If we want only the elements, we use the `ExpandProperty` parameter
    of the `Select-Object` cmdlet and expand all the elements. The elements thus expanded
    are the objects of the cmdlet preceding the `Group-Object` cmdlet (`Get-ChildItem`
    in our case).
  prefs: []
  type: TYPE_NORMAL
- en: If `Where-Object` and other cmdlets could do what `Group-Object` could in a
    complicated way, why have it in the first place? Read on until *Taking actions
    on the returned objects* to know more.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have gotten a hang of tab completion, you need not even select the properties
    that are not shown by default. All you have to do is type `Group-Object` after
    the pipe, add a space and press Tab; PowerShell will show you what objects are
    available to use for grouping. Try it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipe 05.07: Taking actions on the returned objects
  prefs: []
  type: TYPE_NORMAL
- en: Sorting the output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time for another simple cmdlet, which would build towards the recipe,
    *Taking actions on the returned objects*. In this recipe, we will sort the output
    objects to meet our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue to use the directory and the files we created for the book.
    If all of your files are of zero bytes, download a few files with content. The
    file type does not matter.
  prefs: []
  type: TYPE_NORMAL
- en: List out the files in the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Filter the output to have only files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Pipe the object to the `Sort-Object` cmdlet to sort the output based on the
    file size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The shorthand for the expression would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Sort the files, the largest file to the smallest file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Pick the largest three files in the lot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Create two files, and, using a text editor, add some content into both of them.
    (Or use the following script block to create some random text.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, sort the files in the directory, first, by size, and then, the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Observe the output that you get.
  prefs: []
  type: TYPE_NORMAL
- en: Sort the list in the descending order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/98feda49-fc08-4af2-8a63-c814f055239c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is another demonstration of passing objects through the pipeline.
    In the help documentation for `Sort-Object`, we see a parameter called `InputObject`.
    This parameter is a generic term used in PowerShell for a parameter whose input
    comes through the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '`Sort-Object` accepts input from the pipeline, and sorts the content based
    on the property specified. If a property is not specified, the default property
    for the object output from the preceding command is used for sorting. If there
    are multiple properties are input, the sorting happens based on the order in which
    the properties are specified.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting can happen in the ascending order (default), or the descending order.
  prefs: []
  type: TYPE_NORMAL
- en: Taking actions on the returned objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been using the pipeline throughout this chapter to perform various activities
    on the objects. We have been passing objects from one cmdlet to another, and in
    fact, taking actions on the objects being returned. This recipe, in the technical
    sense therefore, is nothing new. However, in order to get ourselves more comfortable
    using the pipeline, and to show that the pipeline is not just used for selection,
    filtration and sorting, we will use the pipeline to also perform some deletions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you do not have files within the demo directory that we created, please go
    ahead and create some files. Make sure some of the files have some content in
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Let us say that you have been given a requirement. There is a certain team which
    would like the top two largest files of each type, deleted from a directory. If
    there is only one file of a certain type, that file has to be left alone.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an outline of the steps you would want to take:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all the files at the path specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group the files by file type (extension).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter out those groups that contain more than one item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand each group, sort the files by size (length).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the two largest files in each group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While we are working on a sandbox directory, and that we are taking precautions
    not to delete anything important, it is still better to only prototype the action
    using ShouldPerform (the WhatIf parameter). This way, the files would not be actually
    deleted, but PowerShell would only tell you what it would do if the command is
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Let us get cracking.
  prefs: []
  type: TYPE_NORMAL
- en: List the contents of the current directory and group the output based on the
    extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Filter to discard lone files of each extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now comes a loop construct. We will look at how that works in a future chapter.
    For now, just know that it works. The goal here is to only leverage the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c1ae6403-f6e6-48bf-a8cb-188092d3f16e.png)'
  prefs: []
  type: TYPE_IMG
- en: Delete these files using the `Remove-Item` cmdlet. Use the `WhatIf` switch if
    you do not want the files actually deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When any cmdlet reads an object through the pipeline, it reads the entire contents
    of the object. And any cmdlet that is designed to accept input through the pipeline
    picks the right property from the object, and then takes actions on the objects.
    In the case of this recipe, it was the `Path` property that was picked in order
    to identify the files to delete.
  prefs: []
  type: TYPE_NORMAL
- en: To know if a certain cmdlet accepts input from the pipeline, run `Get-Help`
    on the cmdlet with the `Full` parameter, and see if the value for `Accept pipeline
    input?` is true. The `InputObject` parameter of `Where-Object`, or the `Path`
    parameter of `Move-Item` are a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pipeline-enabled parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding pipelines is not so much of a requirement if you plan to use PowerShell
    for only running commands on the console; it is well encapsulated, and the cmdlets
    are well designed to be able to handle passing objects between cmdlets. However,
    if you plan to create custom functions and modules, the concept of the pipeline
    is something you would want to understand well.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look into the two ways cmdlets accept input. At the
    point where we create functions, we will look at how to enable pipeline input
    for parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will mostly use the help documentation to demonstrate the two different kinds
    of pipeline input.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the prompt, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ece35564-34f0-4beb-a575-83b29dc0208e.png)'
  prefs: []
  type: TYPE_IMG
- en: It says the parameter accepts string input, and accepts input by property name
    as well as by value.
  prefs: []
  type: TYPE_NORMAL
- en: Type the following to see if a valid string is accepted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2f9fadc6-7b06-4d05-a0f3-3232e4d88ab8.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us try something similar with `Get-Date`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The Date parameter accepts values through the pipeline. However, the type is
    DateTime, and not string.
  prefs: []
  type: TYPE_NORMAL
- en: Try sending a valid string through the pipeline to see if it gets converted
    into date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It did convert the string into date and time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bf14887-e102-4518-aba5-ef0f00939e1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let us go back to getting details of the current directory. This time,
    however, we would pick only the FullName property of the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Pass this through the pipeline to the `Get-ChildItem` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There is an error.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b9eb33e-158a-47c3-91fa-81c8373590b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the property name to `LiteralPath`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Pass the object to `Get-ChildItem` through the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: That worked.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two kinds of input through the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ByPropertyName`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ByValue`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ByValue` type is perhaps the most common. If a parameter accepts input
    through the pipeline by value, it would look for the data type that matches the
    defined data type in the output, and pick the output as input for itself. In case
    the data type is not the same as that defined, but can be converted to the required
    type, the parameter would convert the value into the data type it takes in, and
    processes it. This happened in the case of `Get-Date`, where we sent the date
    as a string, and passed it through the pipeline to `Get-Date`.
  prefs: []
  type: TYPE_NORMAL
- en: In case of `Get-Item`, the `Path` parameter accepted string input and processed
    the command. In case of `Get-Date`, the `Date` parameter converted the string
    into a `DateTime` object and processed the request.
  prefs: []
  type: TYPE_NORMAL
- en: '`ByPropertyName`, as compared to `ByValue`, looks for a property of the *exact
    same name* as the parameter. In our case, `LiteralPath` of `Get-ChildItem` threw
    an error when we passed the `FullName` property, even though it was essentially
    the literal path of the object, and a string value. The reason for the error was
    that the property was not called `LiteralPath`. When we changed the name of the
    property to `LiteralPath`, `Get-ChildItem` accepted the input through the pipeline,
    and gave us the desired output.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing content into PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Administrators managing multiple computers need to have some sort of input
    fed into cmdlets so they can automate tasks. While most Linux administrators are
    familiar with sending input to files, the important point with PowerShell is that
    apart from taking file-based input (read: `Get-Content`),  PowerShell is also
    capable of *importing* input. This imported input is a PowerShell object.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at two kinds of import cmdlets and learn to work
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipe, *Parsing input from text to object*, we used `Import-Csv` to
    import a comma-separated values file to convert the data contained within to a
    PowerShell object. Let us recapitulate what we learnt, however this time, now
    that we know how to work with objects, we will use the imported content in some
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Before we import content, let us first export some content into a CSV file.
    This way, we would have some relevant content to manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the location where you created files for this chapter. List the
    contents of the directory. While the book uses (and recommends) complete cmdlets
    even at the console (using tab-completion of course), feel free to use aliases
    if you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Export the contents to a CSV file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Open the file in a spreadsheet processor like LibreOffice Calc or even a text
    editor to view its contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: That was a plain text representation of the object returned by `Get-ChildItem.`
  prefs: []
  type: TYPE_NORMAL
- en: Import the contents of the CSV file to convert this text into an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Find the type of the object returned by this command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The object type is `System.Management.Automation.PSCustomObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Check if this is the same as that returned by `Get-ChildItem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The object returned by `Import-Csv` is different. Is it possible to treat it
    just like we do other objects? Get the `CreationTime` using the member access
    operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Get just the year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Find the type of object returned by the last command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Attempt to convert the `LastWriteTime` into a `DateTime` object. Pick just the
    first record, though.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: What if we had to retain all the objects within the object returned by `Get-ChildItem`,
    including their object types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now, import the contents of the XML to the session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Find out the type name of the object returned by the import command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Pick the `CreationTime` property and find its type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Pick just the year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Importing content from a CSV is a straightforward process. The columns in a
    CSV are separated by commas. PowerShell creates an object from the input content,
    with each column making a property of a PowerShell custom object. Operations that
    we perform on objects can be performed on the `PSCustomObject`, however, the only
    limitation with `Import-Csv` is that the properties cannot be multi-valued, nor
    can they have other sub-properties within them. There could be ways to achieve
    multi-valued properties with CSV, but they would involve some manipulation after
    the object is imported within PowerShell. One such way is to separate the values
    of the property with a delimiter, and then, after the import, split the delimited
    value.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a CLIXML (or a Common Language Infrastructure XML) is a complete
    .NET object. When a PowerShell object is exported to CLIXML, the object is retained
    as it is. That is, the CLIXML retains all the properties (of theoretically any
    depth), and the methods that were part of the output object. In other words, it
    can be said that a CLIXML export is almost lossless in terms of the members of
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe: Generate random text using ASCII characters'
  prefs: []
  type: TYPE_NORMAL
