<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Dangerous Gas Sensors"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Dangerous Gas Sensors</h1></div></div></div><p>In this chapter, we will learn how to use the <span class="strong"><strong>BeagleBone Black</strong></span>
<a id="id0" class="indexterm"/> to monitor some dangerous gases in a room, such as <span class="emphasis"><em>CO</em></span>, <span class="emphasis"><em>methane</em></span>, <span class="emphasis"><em>LPG</em></span>, and so on, and then enabling an acoustic and visive alarm in case of danger. Also, by using a GSM module, the user will be able to send an SMS message to a predefined phone number to alert, for instance, a relative.</p><p>Also, the user will be able to control, log, and display the measured concentrations from the system console/terminal by using a command-line interface (this to keep the code simple).</p><p>We'll see how to build the circuitry to manage the sensors and how to get the gas concentration from them. Then, we'll take a look at how to manage a GSM module in order to send SMS messages.</p><div class="section" title="The basic of functioning"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>The basic of functioning</h1></div></div></div><p>In this project, our <a id="id1" class="indexterm"/>BeagleBone Black will periodically read the environmental data from the sensors, comparing them with user selectable ranges, and then generate an alarm in case one (or more) data read is out of that range.</p><p>The sensors will be connected to the BeagleBone Black ADCs with a dedicated circuitry, while the alarms will be enabled with dedicated GPIO lines. Then a GSM module will be connected to our BeagleBone Black's serial port in order to send other alarm messages via SMS.</p></div></div>
<div class="section" title="Setting up the hardware"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Setting up the hardware</h1></div></div></div><p>As just stated, all <a id="id2" class="indexterm"/>devices are connected with the BeagleBone Black, which is the real core of the system, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B00255_01_01.jpg" alt="Setting up the hardware"/></div><p>The data flow <a id="id3" class="indexterm"/>is from the sensors to the alarm actuators (LED, buzzer, and GSM module) and the user will be able to send commands to the system, or check the system status and the collected data, by using the system console.</p><div class="section" title="Connecting the gas sensors"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Connecting the gas sensors</h2></div></div></div><p>The gas sensors are <a id="id4" class="indexterm"/>used to monitor the environment and we can choose different kinds of such devices. I decided to use the ones shown in the following screenshot due to the fact they act as a variable resistor according to the gas concentration, so they can be easily read with a normal ADC:</p><div class="mediaobject"><img src="graphics/B00255_01_02.jpg" alt="Connecting the gas sensors"/></div><p>In the prototype <a id="id5" class="indexterm"/>presented here, the gas sensors are actually four, but the ones named <a id="id6" class="indexterm"/>
<span class="strong"><strong>MQ-2</strong></span> (<span class="strong"><strong>smoke detector</strong></span>), <a id="id7" class="indexterm"/>
<span class="strong"><strong>MQ-4</strong></span> (<span class="strong"><strong>methane detector</strong></span>), and <span class="strong"><strong>MQ-7</strong></span> (<span class="strong"><strong>LPG detector</strong></span>) <a id="id8" class="indexterm"/>look very similar to each other (except the label on each sensor), so I reported only one of them in the preceding screenshot, while the carbon monoxide detector is the red device labeled with MQ-7.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The <a id="id9" class="indexterm"/>devices<a id="id10" class="indexterm"/> can be<a id="id11" class="indexterm"/> purchased at the following links (or by surfing the Internet):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">MQ-2: <a class="ulink" href="http://www.cosino.io/product/mq-2-gas-sensor">http://www.cosino.io/product/mq-2-gas-sensor</a></li><li class="listitem" style="list-style-type: disc">MQ-4: <a class="ulink" href="http://www.cosino.io/product/mq-4-gas-sensor">http://www.cosino.io/product/mq-4-gas-sensor</a></li><li class="listitem" style="list-style-type: disc">MQ-5: <a class="ulink" href="http://www.cosino.io/product/mq-5-gas-sensor">http://www.cosino.io/product/mq-5-gas-sensor</a></li><li class="listitem" style="list-style-type: disc">MQ-7: <a class="ulink" href="http://www.cosino.io/product/mq-7-gas-sensor">http://www.cosino.io/product/mq-7-gas-sensor</a></li></ul></div><p>The following are the URLs where we can get the datasheet for each GAS sensor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">MQ-2: <a class="ulink" href="http://www.seeedstudio.com/depot/datasheet/MQ-2.pdf">http://www.seeedstudio.com/depot/datasheet/MQ-2.pdf</a></li><li class="listitem" style="list-style-type: disc">MQ-4: <a class="ulink" href="https://www.pololu.com/file/0J311/MQ4.pdf">https://www.pololu.com/file/0J311/MQ4.pdf</a></li><li class="listitem" style="list-style-type: disc">MQ-5: <a class="ulink" href="http://www.dfrobot.com/image/data/SEN0130/MQ-5.pdf">http://www.dfrobot.com/image/data/SEN0130/MQ-5.pdf</a></li><li class="listitem" style="list-style-type: disc">MQ-7: <a class="ulink" href="https://www.parallax.com/sites/default/files/downloads/605-00007-MQ-7-Datasheet.pdf">https://www.parallax.com/sites/default/files/downloads/605-00007-MQ-7-Datasheet.pdf</a></li></ul></div></div></div><p>Looking carefully at the datasheet of the gas sensors, we can see exactly how these sensors' class varies their internal resistance according to the gas concentration (in reality, it depends on environment humidity and temperature too; but for an indoor functioning, we can consider these values as constants). So, if we put it in series with a resistor and apply a constant voltage). We can get an output voltage that is proportional to the actual gas concentration.</p><p>The following diagram shows a possible schematics where the gas sensor is connected to <span class="strong"><strong>5V</strong></span> power supply and the <span class="strong"><strong>RL</strong></span> resistor<a id="id12" class="indexterm"/> is formed by two resistors (<span class="strong"><strong>R1</strong></span> &amp; <span class="strong"><strong>R2</strong></span>) due to the fact we cannot put more than 1.8V at a BeagleBone Black's ADC pin. So, by choosing these two resistors in such a way that <span class="emphasis"><em>R1 ≥ 2*R2</em></span>, we can be sure we have no more than <span class="emphasis"><em>5.0V/3 ≈ 1.67V</em></span> at the ADC input pin on every possible functioning condition, even if the sensor's internal resistance is shorted. However, to be completely sure we can add a <span class="strong"><strong>Zener diode</strong></span> (<span class="strong"><strong>Z</strong></span>)<a id="id13" class="indexterm"/> with a reverse threshold on 1.8V (but I didn't use it on my prototype).</p><p>The following diagram<a id="id14" class="indexterm"/> shows the circuitry I used to connect each sensor:</p><div class="mediaobject"><img src="graphics/B00255_01_03.jpg" alt="Connecting the gas sensors"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>Note that the <span class="strong"><strong>GAS sensors</strong></span> have six pins labeled in pairs as <span class="strong"><strong>A</strong></span>, <span class="strong"><strong>B</strong></span>, and <span class="strong"><strong>H</strong></span>; while the <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>B</strong></span> pair pins are shortened, the <span class="strong"><strong>H</strong></span> labeled pairs must be connected at one end to the input voltage (5V in our case) and the other end to the GND (see the datasheet for further information).</p></div></div><p>Another important issue regarding these sensors is the calibration we should perform before using them. This last adjustment is very important; as reported in the MQ-2 datasheet, we read the following recommendation:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>We recommend that you calibrate the detector for 1000 ppm <a id="id15" class="indexterm"/>
<span class="strong"><strong>liquefied petroleum gas</strong></span> (<span class="strong"><strong>LPG</strong></span>), or 1000ppm <span class="strong"><strong>iso-butane</strong></span> (<span class="strong"><strong>i-C</strong></span><sub><span class="strong"><strong>4</strong></span></sub><span class="strong"><strong>H</strong></span><sub><span class="strong"><strong>10</strong></span></sub>) concentration in air and use value of <span class="strong"><strong>load resistance</strong></span>
<a id="id16" class="indexterm"/> that (<span class="strong"><strong>RL</strong></span>) about 20K (5K to 47K).</em></span></p></blockquote></div><p>This step can be <a id="id17" class="indexterm"/>done by replacing resistors <span class="strong"><strong>R1</strong></span> or <span class="strong"><strong>R2</strong></span> with a <span class="strong"><strong>varistor</strong></span> and then fine tuning its resistance. However, I decided to use normal resistors (<span class="emphasis"><em>R1 = 15KΩ</em></span>,<span class="emphasis"><em> R2 = 6.8KΩ</em></span> in such a way that <span class="emphasis"><em>RL = R1 + R2 ≈ 20KΩ</em></span>, as suggested by the datasheet) and then implemented a little translation in software (see the following section), that is, we can translate raw data from the ADCs into a <span class="strong"><strong>ppm</strong></span> (<span class="strong"><strong>part-per-million</strong></span>)<a id="id18" class="indexterm"/> value in such a way the user can work with physic data.</p><p>This translation can be done using a <span class="emphasis"><em>gain</em></span> and an <span class="emphasis"><em>offset</em></span> value in the following formula for each sensor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>ppm = raw * gain + offset</em></span></li></ul></div><p>During the calibration procedure, we just need to use two known points (<span class="emphasis"><em>ppm1</em></span> and <span class="emphasis"><em>ppm2</em></span>), read the corresponding raw data (<span class="emphasis"><em>raw1</em></span> and <span class="emphasis"><em>raw2</em></span>), and then apply the following formulas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>gain = (ppm1 – ppm2) / (raw1 – raw2)</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>offset = ppm1 – raw1 * gain</em></span></li></ul></div><p>Of course, we need four gain/offset couples, one per sensor (the calibration procedure is quite long!)</p><p>Once we have fixed the input circuits, we simply have to connect each <span class="strong"><strong>Vout</strong></span>
<a id="id19" class="indexterm"/> to the BeagleBone Black's ADC input pins. Our board has 8 ADCs inputs, so we can use the following connections:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pin</p>
</th><th style="text-align: left" valign="bottom">
<p>Gas sensor</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>P9.39 - AIN0</p>
</td><td style="text-align: left" valign="top">
<p>Vout @MQ-2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.37 - AIN2</p>
</td><td style="text-align: left" valign="top">
<p>Vout @MQ-4</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.35 - AIN6</p>
</td><td style="text-align: left" valign="top">
<p>Vout @MQ-5</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.33 - AIN4</p>
</td><td style="text-align: left" valign="top">
<p>Vout @MQ-7</p>
</td></tr></tbody></table></div><p>To enable them, we use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# echo cape-bone-iio &gt; /sys/devices/bone_capemgr.9/slots</strong></span>
</pre></div><p>If everything works well, we should get the following kernel messages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>part_number 'cape-bone-iio', version 'N/A'</strong></span>
<span class="strong"><strong>slot #7: generic override</strong></span>
<span class="strong"><strong>bone: Using override eeprom data at slot 7</strong></span>
<span class="strong"><strong>slot #7: 'Override Board Name,00A0,Override Manuf,cape-bone-iio'</strong></span>
<span class="strong"><strong>slot #7: Requesting part number/version based 'cape-bone-iio-00A0.dtbo</strong></span>
<span class="strong"><strong>slot #7: Requesting firmware 'cape-bone-iio-00A0.dtbo' for board-name 'Override Board Name', version '00A0'</strong></span>
<span class="strong"><strong>slot #7: dtbo 'cape-bone-iio-00A0.dtbo' loaded; converting to live tree</strong></span>
<span class="strong"><strong>slot #7: #1 overlays</strong></span>
<span class="strong"><strong>helper.12: ready</strong></span>
<span class="strong"><strong>slot #7: Applied #1 overlays.</strong></span>
</pre></div><p>Then, the<a id="id20" class="indexterm"/> files <code class="literal">AIN0</code>, <code class="literal">AIN1</code>, …, <code class="literal">AIN7</code> should become available as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# find /sys -name '*AIN*'</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN0</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN1</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN2</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN3</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN4</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN5</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN6</strong></span>
<span class="strong"><strong>/sys/devices/ocp.3/helper.12/AIN7</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>These settings can be done using the <code class="literal">bin/load_firmware.sh</code> script in the book's example code repository, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./load_firmware.sh adc</strong></span>
</pre></div></div></div><p>Then, we can read the input data by using the <code class="literal">cat</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cat /sys/devices/ocp.3/helper.12/AIN0</strong></span>
<span class="strong"><strong>1716</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Note that the ADC can also be read by using other files still into the <span class="strong"><strong>sysfs</strong></span> filesystem. The following command, for instance, reads from AIN0 input pin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cat /sys/bus/iio/devices/iio:device0/in_voltage0_raw</strong></span>
</pre></div></div></div></div><div class="section" title="Connecting the alarm actuators"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Connecting the alarm actuators</h2></div></div></div><p>Now, we have to connect the <a id="id21" class="indexterm"/>alarm actuators in such a way the user can have a visual and acoustic feedback of any possible dangerous gas concentration. Also, we have to connect the GSM module to a serial port to communicate with it.</p><div class="section" title="LED and buzzer"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>LED and buzzer</h3></div></div></div><p>The LED and buzzer connections<a id="id22" class="indexterm"/> are very<a id="id23" class="indexterm"/> simple. The LEDs can be directly connected (with a resistor) with the BeagleBone Black's GPIO pins without problems, while the buzzer needs a little more work due to the fact that it needs a higher current than the LED to work. However, we can resolve the problem by using a transistor as shown in the following diagram to manage the buzzer with a higher current.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>Note that the buzzer can't be a simple piezo without an internal oscillator, otherwise an external oscillator circuit or a <span class="strong"><strong>PWM</strong></span> signal<a id="id24" class="indexterm"/> must be used!</p><div class="mediaobject"><img src="graphics/B00255_01_04.jpg" alt="LED and buzzer"/></div><p>In my circuitry, I used an <span class="strong"><strong>R</strong></span> (470Ω) resistor for the <span class="strong"><strong>LED</strong></span> (<span class="strong"><strong>L</strong></span>), an <span class="strong"><strong>R</strong></span> (2KΩ), <span class="strong"><strong>Rd</strong></span> (4.7KΩ) resistors for the buzzer, and a <span class="strong"><strong>BC546 transistor</strong></span> (<span class="strong"><strong>T</strong></span>). Note that, regarding the LEDs, an R = 100Ω resistor can result in a higher brightness, so you may change it according to the LED color to have different results.</p><p>Note also that the<a id="id25" class="indexterm"/> resistor <span class="strong"><strong>Rd</strong></span> in the <a id="id26" class="indexterm"/>buzzer circuitry is needed to pull-down the GPIO during the boot. In fact, during this stage it is set as input, and even in such configuration the current that flows out from the pin can turn on the buzzer!</p></div></div><p>The BeagleBone Black has a lot of GPIOs lines, so we can use the following connections:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pin</p>
</th><th style="text-align: left" valign="bottom">
<p>Actuator</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>P8.9 - GPIO69</p>
</td><td style="text-align: left" valign="top">
<p>R @LED</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P8.10 - GPIO68</p>
</td><td style="text-align: left" valign="top">
<p>R @Buzzer</p>
</td></tr></tbody></table></div><p>Now, to test the connections, we can set up the <span class="strong"><strong>GPIO</strong></span>s by exporting them and then setting these lines as outputs with the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# echo 68 &gt; /sys/class/gpio/export</strong></span>
<span class="strong"><strong>root@beaglebone:~# echo out &gt; /sys/class/gpio/gpio68/direction</strong></span>
<span class="strong"><strong>root@beaglebone:~# echo 0 &gt; /sys/class/gpio/gpio68/value     </strong></span>
<span class="strong"><strong>root@beaglebone:~# echo 69 &gt; /sys/class/gpio/export</strong></span>
<span class="strong"><strong>root@beaglebone:~# echo out &gt; /sys/class/gpio/gpio69/direction</strong></span>
<span class="strong"><strong>root@beaglebone:~# echo 0 &gt; /sys/class/gpio/gpio69/value</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Note that it will be a good idea to use blinking LEDs to do this job. However, for this first chapter I'm going to use normal GPIO lines, leaving this topic for the following chapters.</p></div></div><p>Now, to turn on and <a id="id27" class="indexterm"/>off both the LED and the <a id="id28" class="indexterm"/>buzzer, we simply write <code class="literal">1</code> or <code class="literal">0</code> into the proper files, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# echo 1 &gt; /sys/class/gpio/gpio68/value     </strong></span>
<span class="strong"><strong>root@beaglebone:~# echo 0 &gt; /sys/class/gpio/gpio68/value</strong></span>
<span class="strong"><strong>root@beaglebone:~# echo 1 &gt; /sys/class/gpio/gpio69/value</strong></span>
<span class="strong"><strong>root@beaglebone:~# echo 0 &gt; /sys/class/gpio/gpio69/value</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>These settings can be done by using the <code class="literal">bin/gpio_set.sh</code> script in the book's example code repository, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./gpio_set 68 out</strong></span>
<span class="strong"><strong>root@beaglebone:~# ./gpio_set 69 out</strong></span>
</pre></div></div></div></div><div class="section" title="GSM module"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>GSM module</h3></div></div></div><p>As stated in<a id="id29" class="indexterm"/> the introduction of this chapter, we wish to add a GSM module to be able to alert the user remotely too. In order to do this, we can connect this device with a normal serial port with TTL level signals. In this case, we have only to choose one of the serial ports available on our BeagleBone Black.</p><p>The following screenshot shows the GSM module I decided to use:</p><div class="mediaobject"><img src="graphics/B00255_01_05.jpg" alt="GSM module"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>The device can be <a id="id30" class="indexterm"/>purchased at the following link (or by surfing the Internet):</p><p>
<a class="ulink" href="http://www.cosino.io/product/serial-gsmgprs-module">http://www.cosino.io/product/serial-gsmgprs-module</a>
</p><p>The user manual con be retrieved at <a class="ulink" href="http://www.mikroe.com/downloads/get/1921/gsm_click_manual_v101c.pdf">http://www.mikroe.com/downloads/get/1921/gsm_click_manual_v101c.pdf</a>.</p></div></div><p>The BeagleBone <a id="id31" class="indexterm"/>Black has four available serial ports. By deciding to use the device <code class="literal">/dev/ttyO1</code>, we can use the following connections:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pin</p>
</th><th style="text-align: left" valign="bottom">
<p>GSM module</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>P9.24 - TX-O1</p>
</td><td style="text-align: left" valign="top">
<p>RX</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.26 - RX-O1</p>
</td><td style="text-align: left" valign="top">
<p>TX</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.1 - GND</p>
</td><td style="text-align: left" valign="top">
<p>GND</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.3 - 3.3V</p>
</td><td style="text-align: left" valign="top">
<p>3.3V</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.5 - 3.3V</p>
</td><td style="text-align: left" valign="top">
<p>5V</p>
</td></tr></tbody></table></div><p>To enable the <a id="id32" class="indexterm"/>
<span class="strong"><strong>serial port</strong></span>, we have to use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# echo BB-UART1 &gt; /sys/devices/bone_capemgr.9/slots</strong></span>
</pre></div><p>If everything works well, we should get the following kernel messages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>part_number 'BB-UART1', version 'N/A'</strong></span>
<span class="strong"><strong>slot #8: generic override</strong></span>
<span class="strong"><strong>bone: Using override eeprom data at slot 8</strong></span>
<span class="strong"><strong>slot #8: 'Override Board Name,00A0,Override Manuf,BB-UART1'</strong></span>
<span class="strong"><strong>slot #8: Requesting part number/version based 'BB-UART1-00A0.dtbo</strong></span>
<span class="strong"><strong>slot #8: Requesting firmware 'BB-UART1-00A0.dtbo' for board-name 'Override Board Name', version '00A0'</strong></span>
<span class="strong"><strong>slot #8: dtbo 'BB-UART1-00A0.dtbo' loaded; converting to live tree</strong></span>
<span class="strong"><strong>slot #8: #2 overlays</strong></span>
<span class="strong"><strong>48022000.serial: ttyO1 at MMIO 0x48022000 (irq = 73) is a OMAP UART1</strong></span>
<span class="strong"><strong>slot #8: Applied #2 overlays.</strong></span>
</pre></div><p>The device file <code class="literal">/dev/ttyO1</code> should now become available.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>These settings can be done by using the <code class="literal">bin/load_firmware.sh</code> script in the book's example code repository, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./load_firmware.sh ttyO1</strong></span>
</pre></div></div></div><p>To verify that the<a id="id33" class="indexterm"/> new device is ready, we can use the <code class="literal">ls</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ls -l /dev/ttyO1</strong></span>
<span class="strong"><strong>crw-rw---T 1 root dialout 248, 1 Apr 23 22:25 /dev/ttyO1</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The reader can take a look at the book <span class="emphasis"><em>BeagleBone Essentials</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>, which was written by the author of this book, in order to have more information regarding how to activate and use the GPIO lines and the serial ports available on the system.</p></div></div><p>Now, we can test whether we actually talk with the modem by using the <code class="literal">screen</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# screen /dev/ttyO1 115200</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>The <code class="literal">screen</code> command can be installed by using the <code class="literal">aptitude</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# aptitude install screen</strong></span>
</pre></div></div></div><p>After pressing the <span class="emphasis"><em>ENTER</em></span> key, you should get a blank terminal where, if you enter the <code class="literal">ATZ</code> string, you should get the string <code class="literal">OK</code> as answer, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ATZ</strong></span>
<span class="strong"><strong>OK</strong></span>
</pre></div><p>It's the GSM <a id="id34" class="indexterm"/>module that answers that it's okay and fully functional. To quit from the <code class="literal">screen</code> command, you have to enter the <span class="emphasis"><em>CTRL</em></span> + <span class="emphasis"><em>A</em></span> + <span class="emphasis"><em>\</em></span> keys sequence and then answer <span class="emphasis"><em>yes</em></span> by pressing the <span class="emphasis"><em>y</em></span> key when the program asks you to <code class="literal">Really quit and kill all your windows [y/n]</code>.</p></div></div><div class="section" title="The final picture"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>The final picture</h2></div></div></div><p>Well, now we have to<a id="id35" class="indexterm"/> put it all together! The following image shows the prototype I made to implement this project and to test the software:</p><div class="mediaobject"><img src="graphics/B00255_01_06.jpg" alt="The final picture"/></div><p>Note that we need an <a id="id36" class="indexterm"/>external power supplier due to the fact that the external circuitry (and especially the GSM module) needs the 5V power supply.</p></div></div>
<div class="section" title="Setting up the software"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Setting up the software</h1></div></div></div><p>Now, it's time to<a id="id37" class="indexterm"/> think about the software needed to implement the desired functioning, that is, checking the gas concentrations, logging them, and eventually activating the alarms. We need the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A periodic procedure (<code class="literal">read_sensors.php</code>) that periodically scans all the sensors and then logs their data into a database.</li><li class="listitem">A periodic procedure (<code class="literal">monitor.php</code>) that reads the sensors' data, checks them against preset thresholds, and then sets some internal status.</li><li class="listitem">A periodic procedure (<code class="literal">write_actuators.php</code>) that enables the alarms according to the previously saved status.</li></ol></div><p>The following diagram shows the situation:</p><div class="mediaobject"><img src="graphics/B00255_01_07.jpg" alt="Setting up the software"/></div><p>The core of the system is the database, where we store both the data we wish to log and the system's status. In this manner, all periodic functions can be realized as separate tasks that talk to each other by using the database itself. Also, we can control all the tasks from the system console by just altering the <code class="literal">config</code> table at runtime.</p><p>I used <span class="strong"><strong>MySQL</strong></span>
<a id="id38" class="indexterm"/> to implement the database system, and the preceding configuration can be created by using the <code class="literal">my_init.sh</code> script, where we define the proper tables.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>The MySQL daemon can be installed by using the <code class="literal">aptitude</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# aptitude install mysql-client mysql-server</strong></span>
</pre></div></div></div><p>Here is a<a id="id39" class="indexterm"/> snippet of the script:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE status (
   n VARCHAR(64) NOT NULL,
   v VARCHAR(64) NOT NULL,
   PRIMARY KEY (n)
) ENGINE=MEMORY;

# Setup default values
INSERT INTO status (n, v) VALUES('alarm', 'off');

#
# Create the system configuration table
#

CREATE TABLE config (
   n VARCHAR(64) NOT NULL,
   v VARCHAR(64) NOT NULL,
   PRIMARY KEY (n)
);

# Setup default values
INSERT INTO config (n, v) VALUES('sms_delay_s', '300');

INSERT INTO config (n, v) VALUES('mq2_gain', '1');
INSERT INTO config (n, v) VALUES('mq4_gain', '1');
INSERT INTO config (n, v) VALUES('mq5_gain', '1');
INSERT INTO config (n, v) VALUES('mq7_gain', '1');
INSERT INTO config (n, v) VALUES('mq2_off', '0');
INSERT INTO config (n, v) VALUES('mq4_off', '0');
INSERT INTO config (n, v) VALUES('mq5_off', '0');
INSERT INTO config (n, v) VALUES('mq7_off', '0');

INSERT INTO config (n, v) VALUES('mq2_th_ppm', '2000');
INSERT INTO config (n, v) VALUES('mq4_th_ppm', '2000');
INSERT INTO config (n, v) VALUES('mq5_th_ppm', '2000');
INSERT INTO config (n, v) VALUES('mq7_th_ppm', '2000');

#
# Create one table per sensor data
#

CREATE TABLE MQ2_log (
   t DATETIME NOT NULL,
   d float,
   PRIMARY KEY (t)
);

CREATE TABLE MQ4_log (
   t DATETIME NOT NULL,
   d float,
   PRIMARY KEY (t)
);

CREATE TABLE MQ5_log (
   t DATETIME NOT NULL,
   d float,
   PRIMARY KEY (t)
);

CREATE TABLE MQ7_log (
   t DATETIME NOT NULL,
   d float,
   PRIMARY KEY (t)
);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>The <code class="literal">my_init.sh</code> script is stored in the <code class="literal">chapter_01/my_init.sh</code> file in the book's example code repository.</p></div></div><p>The reader <a id="id40" class="indexterm"/>should notice that we define a <code class="literal">status</code> table with the <code class="literal">MEMORY</code> storage engine since we don't need to preserve it at reboot but need a good performance in accessing it, while the <code class="literal">config</code> table and the per-sensor logging tables (<code class="literal">MQ2_log</code>, <code class="literal">MQ4_log</code>, <code class="literal">MQ5_log</code>, and <code class="literal">MQ7_log</code>) are defined as normal tables since we need to save these data even during a complete restart. Note that we defined one table per variable in order to easily get access to the logged data; however, nothing changes, even if we decide to keep the logged data into a global logging table.</p><p>Note also that during <a id="id41" class="indexterm"/>the database initialization, we can define some default settings by simply recording these values by using an <code class="literal">INSERT</code> command. For the <code class="literal">status</code> table, we just need the <code class="literal">alarm</code> variable to be set to <code class="literal">off</code>, while into the <code class="literal">config</code> table, we can set up the minimum delay in seconds (<code class="literal">sms_delay_s</code>) to wait before resending a new SMS alarm, the gain/offset translation couple variables (<code class="literal">mq2_gain</code>/<code class="literal">mq2_off</code> and friends), and the per-sensor threshold variables (<code class="literal">mq2_th_ppm</code> and friends) to be used to activate the alarms.</p><div class="section" title="Managing the ADCs"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Managing the ADCs</h2></div></div></div><p>Now, to get data from the <a id="id42" class="indexterm"/>
<span class="strong"><strong>ADC</strong></span> and save them into the database, we have to write a periodic task. This is quite easy and the following code snippet shows a PHP implementation of the main function of the file <code class="literal">read_sensors.php</code>, which does this:</p><div class="informalexample"><pre class="programlisting">function daemon_body()
{
   global $loop_time;
   global $sensors;

   # The main loop
   dbg("start main loop (loop_time=${loop_time}s)");
   while (sleep($loop_time) == 0) {
      dbg("loop start");

      # Read sensors
      foreach ($sensors as $s) {
         $name = $s['name'];
         $file = $s['file'];
         $var = $s['var'];
         $log = $s['log'];

         # Get the converting values
         $gain = db_get_config($var . "_gain");
         $off = db_get_config($var . "_off");

         dbg("gain[$var]=$gain off[$var]=$off");

         # Read the ADC file
         $val = file_get_data($file);
         if ($val === false) {
            err("unable to read sensor $name");
            continue;
         }

      # Do the translation
      $ppm = $val * $gain + $off;

      dbg("file=$file val=$val ppm=$ppm");

      # Store the result into the status table
      $ret = db_set_status($var, $ppm);
      if (!$ret) {
         err("unable to save $name status db_err=%s",
             mysql_error());
         continue;
      }

      # Store the result into the proper log table
      $ret = db_log_var($log, $ppm);
      if (!$ret)
         err("unable to save $name log db_err=%s",
             mysql_error());
      }

      dbg("loop end");
   }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>The complete script is stored in the <code class="literal">chapter_01/read_sensors.php</code> file in the book's example code repository.</p></div></div><p>The function<a id="id43" class="indexterm"/> is quite simple. It starts the main loop to periodically read the ADC data, get the <span class="emphasis"><em>gain</em></span> and <span class="emphasis"><em>offset</em></span> conversion values for the current variable needed to convert it into the corresponding <span class="emphasis"><em>ppm</em></span> number, then alters the current <code class="literal">status</code> variables, and adds a new value into the logging table of the read sensor.</p><p>If we execute the script enabling all debugging command-line options, we get:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./read_sensors.php -d -f -l -T 5</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: signals traps installed</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: start main loop (loop_time=5s)</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: loop start</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: gain[mq2]=0.125 off[mq2]=0</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: file=/sys/devices/ocp.3/helper.12/AIN0 val=810 ppm=101.25</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: gain[mq4]=1 off[mq4]=0</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: file=/sys/devices/ocp.3/helper.12/AIN2 val=1477 ppm=1477</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: gain[mq5]=1 off[mq5]=0</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: file=/sys/devices/ocp.3/helper.12/AIN6 val=816 ppm=816</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: gain[mq7]=1 off[mq7]=0</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: file=/sys/devices/ocp.3/helper.12/AIN4 val=572 ppm=572</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: loop end</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: loop start</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: gain[mq2]=0.125 off[mq2]=0</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: file=/sys/devices/ocp.3/helper.12/AIN0 val=677 ppm=84.625</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: gain[mq4]=1 off[mq4]=0</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: file=/sys/devices/ocp.3/helper.12/AIN2 val=1456 ppm=1456</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: gain[mq5]=1 off[mq5]=0</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: file=/sys/devices/ocp.3/helper.12/AIN6 val=847 ppm=847</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: gain[mq7]=1 off[mq7]=0</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: file=/sys/devices/ocp.3/helper.12/AIN4 val=569 ppm=569</strong></span>
<span class="strong"><strong>read_sensors.php[5388]: loop end</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Note that only the first sensor has been (more or less) calibrated!</p></div></div><p>The process <a id="id44" class="indexterm"/>can be stopped as usual with the <span class="emphasis"><em>CTRL</em></span> + <span class="emphasis"><em>C</em></span> sequence.</p><p>Now, we can read the system status (in this case, the last read sensors datum) by using the <code class="literal">my_dump.sh</code> script, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./my_dump.sh status</strong></span>
<span class="strong"><strong>n   v</strong></span>
<span class="strong"><strong>alarm   off</strong></span>
<span class="strong"><strong>mq2   84.625</strong></span>
<span class="strong"><strong>mq4   1456</strong></span>
<span class="strong"><strong>mq5   815</strong></span>
<span class="strong"><strong>mq7   569</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The <code class="literal">my_dump.sh</code> script is stored in the <code class="literal">chapter_01/my_dump.sh</code> file in the book's example code repository.</p></div></div><p>The same script can be used to dump a logging table too. For instance, if we wish to see the MQ-2 logged <a id="id45" class="indexterm"/>data, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./my_dump.sh mq2_log</strong></span>
<span class="strong"><strong>t   v</strong></span>
<span class="strong"><strong>2015-05-15 17:39:36	101.25</strong></span>
<span class="strong"><strong>2015-05-15 17:39:41	84.625</strong></span>
<span class="strong"><strong>2015-05-15 17:39:46	84.625</strong></span>
</pre></div></div><div class="section" title="Managing the actuators"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Managing the actuators</h2></div></div></div><p>When a sensor <a id="id46" class="indexterm"/>detects a dangerous gas concentration, the <code class="literal">alarm</code> status variable is set to <span class="emphasis"><em>on</em></span> state. Therefore, when this happens, we have to turn both the LED and the buzzer on, and we must send an SMS message to the user's predefined number.</p><p>In order to do these actions, we have to properly set up the GPIO lines that manage the LED and the buzzer as shown previously, and then we have to talk with the <span class="strong"><strong>GSM</strong></span> module through the serial port to send the SMS message. To do this last step, we have to to install the <code class="literal">gsm-utils</code> package where we can find the <code class="literal">gsmsendsms</code> command, which is used to actually send the SMS. In order to install the package, we use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# aptitude install gsm-utils</strong></span>
</pre></div><p>Then, after placing a functioning SIM into the module, we can verify to be able to talk with the GSM module with the <code class="literal">gsmctl</code> command, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# gsmctl -d /dev/ttyO1 me    </strong></span>
<span class="strong"><strong>&lt;ME0&gt;  Manufacturer: Telit</strong></span>
<span class="strong"><strong>&lt;ME1&gt;  Model: GL865-QUAD</strong></span>
<span class="strong"><strong>&lt;ME2&gt;  Revision: 10.00.144</strong></span>
<span class="strong"><strong>&lt;ME3&gt;  Serial Number: 356308042878501</strong></span>
</pre></div><p>Then, we can verify the current PIN status by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# gsmctl -d /dev/ttyO1 pin</strong></span>
<span class="strong"><strong>&lt;PIN0&gt; READY</strong></span>
</pre></div><p>The preceding message shows us that the GSM module is correctly configured and the SIM in it is ready to operate; however, the SIM must be enabled by inserting the proper PIN number if we get the following message:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gsmsendsms[ERROR]: ME/TA error 'SIM PIN required' (code 311)</strong></span>
</pre></div><p>In this case, we must use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# gsmctl -d /dev/ttyO1 -I "+cpin=NNNN"</strong></span>
</pre></div><p>In the preceding command, <code class="literal">NNNN</code> is the PIN number of your SIM. If the command hangs with no output at all, it means that the connection is wrong.</p><p>Now that we've checked the connection and the SIM is enabled, we can start to send SMS messages by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# gsmsendsms -d /dev/ttyO1 "+NNNNNNNNNNNN" 'Hello world!'</strong></span>
</pre></div><p>In the preceding command, the <code class="literal">NNNNNNNNNNNN</code> string is the number where the SMS must be sent.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>If the module answers is as follows it means that <span class="strong"><strong>SMS Service Centre Address</strong></span> (<span class="strong"><strong>SCA</strong></span>); which is the phone number of the centre that is accepting SMS for delivery is not set correctly in your phone:</p><div class="informalexample"><pre class="programlisting">gsmsendsms[ERROR]: ME/TA error 'Unidentified subscriber' (code 28)</pre></div><p>In this case, you should ask to your GSM operator and then try the following command:</p><div class="informalexample"><pre class="programlisting">root@beaglebone:~# gsmctl -o setsca "+SSSSSSSSSSSS"</pre></div><p>In the preceding <a id="id47" class="indexterm"/>command, the <code class="literal">SSSSSSSSSSSS</code> string is the number of your centre.</p></div></div><p>Okay, now we<a id="id48" class="indexterm"/> have all the needed information to control our actuators. A possible implementation of main function of the managing task is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>function daemon_body()</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>   global $loop_time;</strong></span>
<span class="strong"><strong>   global $actuators;</strong></span>

<span class="strong"><strong>   $sms_delay = db_get_config("sms_delay_s");</strong></span>

<span class="strong"><strong>   $old_alarm = 0;</strong></span>
<span class="strong"><strong>   $sms_time = strtotime("1970");</strong></span>

<span class="strong"><strong>   # The main loop</strong></span>
<span class="strong"><strong>   dbg("start main loop (loop_time=${loop_time}s)");</strong></span>
<span class="strong"><strong>   while (sleep($loop_time) == 0) {</strong></span>
<span class="strong"><strong>   dbg("loop start");</strong></span>

<span class="strong"><strong>      # Get the "alarm" status and set all alarms properly</strong></span>
<span class="strong"><strong>      $alarm = db_get_status("alarm");</strong></span>
<span class="strong"><strong>         foreach ($actuators as $a) {</strong></span>
<span class="strong"><strong>            $name = $a['name'];</strong></span>
<span class="strong"><strong>            $file = $a['file'];</strong></span>

<span class="strong"><strong>            dbg("file=$file alarm=$alarm");</strong></span>
<span class="strong"><strong>            $ret = gpio_set($file, $alarm);</strong></span>
<span class="strong"><strong>               if (!$ret)</strong></span>
<span class="strong"><strong>                  err("unable to write actuator $name");</strong></span>
<span class="strong"><strong>         }</strong></span>

<span class="strong"><strong>      # Send the SMS only during off-&gt;on transition</strong></span>
<span class="strong"><strong>      if ($alarm == "on" &amp;&amp; $old_alarm == "off" &amp;&amp;</strong></span>
<span class="strong"><strong>         strtotime("-$sms_time seconds") &gt; $sms_delay) {</strong></span>
<span class="strong"><strong>            do_send_sms();</strong></span>
<span class="strong"><strong>            $sms_time = strtotime("now");</strong></span>
<span class="strong"><strong>         }</strong></span>

<span class="strong"><strong>      $old_alarm = $alarm;</strong></span>

<span class="strong"><strong>      dbg("loop end");</strong></span>
<span class="strong"><strong>   }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The complete script is stored in the <code class="literal">chapter_01/write_actuators.php</code> file in the book's example code repository.</p></div></div><p>Again, the <a id="id49" class="indexterm"/>function is really simple—we simply have to read the current <code class="literal">alarm</code> variable status from the database and then set up the actuators according to it. Note that a special job must be done for the SMS management; in fact, the system must send one SMS at time and only during the <span class="emphasis"><em>off-to-on</em></span> transition and not before <code class="literal">sms_delay</code> seconds. To do the trick, we use the <code class="literal">old_alarm</code> and <code class="literal">sms_time</code> variables to save the last loop status.</p><p>To test the code, we can control the <code class="literal">alarm</code> variable by using the <code class="literal">my_set.sh</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./my_set.sh status alarm on</strong></span>
<span class="strong"><strong>root@beaglebone:~# ./my_set.sh status alarm off</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>The script is stored in the <code class="literal">chapter_01/my_set.sh</code> file in the book's example code repository.</p></div></div><p>So, let's start the script with the command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./write_actuators.php -d -f -l -T 5</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: signals traps installed</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: start main loop (loop_time=5s)</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: loop start</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: file=/sys/class/gpio/gpio68 alarm=off</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: file=/sys/class/gpio/gpio69 alarm=off</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: loop end</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: loop start</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: file=/sys/class/gpio/gpio68 alarm=off</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: file=/sys/class/gpio/gpio69 alarm=off</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: loop end</strong></span>
</pre></div><p>On another terminal, we can change the <code class="literal">alarm</code> variable, as already stated, by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./my_set.sh status alarm on</strong></span>
</pre></div><p>After this we notice that the script does its job:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>write_actuators.php[5474]: loop start</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: file=/sys/class/gpio/gpio68 alarm=on</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: file=/sys/class/gpio/gpio69 alarm=on</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: send SMS...</strong></span>
<span class="strong"><strong>write_actuators.php[5474]: loop end</strong></span>
</pre></div><p>Regarding<a id="id50" class="indexterm"/> how to send an SMS message in PHP, I simply used the following code:</p><div class="informalexample"><pre class="programlisting">function do_send_sms()
{
   dbg("send SMS...");
   system('gsmsendsms -d /dev/ttyO1 "' . PHONE_NUM . '" "GAS alarm!"');
}</pre></div><p>Basically, here we use the <code class="literal">system()</code> function to call the <code class="literal">gsmsendsms</code> command.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>You may note that <code class="literal">gsmsendsms</code> takes a while to send the SMS. It's normal.</p></div></div></div><div class="section" title="Controlling the environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Controlling the environment</h2></div></div></div><p>Now, we <a id="id51" class="indexterm"/>only need the glue between the sensors and actuators managing tasks, that is, a periodic function that according to the user inputs periodically checks whether the alarms must be activated according to the information read, or not.</p><p>A possible implementation of the main function of the <code class="literal">monitor.php</code> script is as follows:</p><div class="informalexample"><pre class="programlisting">function daemon_body()
{
   global $loop_time;
   global $actuators;

   # The main loop
   dbg("start main loop (loop_time=${loop_time}s)");
   while (sleep($loop_time) == 0) {
      dbg("loop start");

      # Get the gas concentrations and set the "alarm" variable
      $mq2 = db_get_status("mq2");
      $mq2_th_ppm = db_get_config("mq2_th_ppm");
      dbg("mq2/mq2_th_ppm=$mq2/$mq2_th_ppm");
      $mq4 = db_get_status("mq4");
      $mq4_th_ppm = db_get_config("mq4_th_ppm");
      dbg("mq4/mq4_th_ppm=$mq4/$mq4_th_ppm");
      $mq5 = db_get_status("mq5");
      $mq5_th_ppm = db_get_config("mq5_th_ppm");
      dbg("mq5/mq5_th_ppm=$mq5/$mq5_th_ppm");
      $mq7 = db_get_status("mq7");
      $mq7_th_ppm = db_get_config("mq7_th_ppm");
      dbg("mq7/mq7_th_ppm=$mq7/$mq7_th_ppm");

      $alarm = $mq2 &gt;= $mq2_th_ppm ||
         $mq2 &gt;= $mq2_th_ppm ||
         $mq2 &gt;= $mq2_th_ppm ||
         $mq2 &gt;= $mq2_th_ppm ? 1 : 0;

      db_set_status("alarm", $alarm);
      dbg("alarm=$alarm");

      dbg("loop end");
   }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>The complete script is stored in the <code class="literal">chapter_01/monitor.php</code> file in the book's example code repository.</p></div></div><p>The <a id="id52" class="indexterm"/>function starts the <code class="literal">main</code> loop where, after getting the sensors' thresholds, it simply gets the last sensor's values and sets up the <code class="literal">alarm</code> variable accordingly.</p><p>Again, we can change the gas concentration thresholds by using the <code class="literal">my_set.sh</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./my_set.sh config mq2_th_ppm 5000</strong></span>
</pre></div><p>We can test the script by executing it in the same manner as the previous two, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./monitor.php -d -f -l -T 5</strong></span>
<span class="strong"><strong>monitor.php[5819]: signals traps installed  </strong></span>
<span class="strong"><strong>monitor.php[5819]: start main loop (loop_time=5s)</strong></span>
<span class="strong"><strong>monitor.php[5819]: loop start</strong></span>
<span class="strong"><strong>monitor.php[5819]: mq2/mq2_th_ppm=84.625/5000</strong></span>
<span class="strong"><strong>monitor.php[5819]: mq4/mq4_th_ppm=1456/2000</strong></span>
<span class="strong"><strong>monitor.php[5819]: mq5/mq5_th_ppm=815/2000</strong></span>
<span class="strong"><strong>monitor.php[5819]: mq7/mq7_th_ppm=569/2000</strong></span>
<span class="strong"><strong>monitor.php[5819]: alarm=0</strong></span>
<span class="strong"><strong>monitor.php[5819]: loop end</strong></span>
<span class="strong"><strong>monitor.php[5819]: loop start</strong></span>
<span class="strong"><strong>monitor.php[5819]: mq2/mq2_th_ppm=84.625/5000</strong></span>
<span class="strong"><strong>monitor.php[5819]: mq4/mq4_th_ppm=1456/2000</strong></span>
<span class="strong"><strong>monitor.php[5819]: mq5/mq5_th_ppm=815/2000</strong></span>
<span class="strong"><strong>monitor.php[5819]: mq7/mq7_th_ppm=569/2000</strong></span>
<span class="strong"><strong>monitor.php[5819]: alarm=0</strong></span>
<span class="strong"><strong>monitor.php[5819]: loop end</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>To stop the test, just use the <span class="emphasis"><em>CTRL</em></span> + <span class="emphasis"><em>C</em></span> sequence. You should get an output as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>^Cmonitor.php[5819]: signal trapped!</strong></span>
</pre></div></div></div>
<div class="section" title="Final test"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Final test</h1></div></div></div><p>Once everything has<a id="id53" class="indexterm"/> been connected and the software is ready, it's time to do a little test of our new system. The demonstration can be done by using a lighter. In fact, our system is really sensitive to the gas inside the lighter!</p><p>First of all, we have to check the system configuration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./my_dump.sh config</strong></span>
<span class="strong"><strong>n   v</strong></span>
<span class="strong"><strong>mq2_gain   0.125</strong></span>
<span class="strong"><strong>mq2_off   0</strong></span>
<span class="strong"><strong>mq2_th_ppm   150</strong></span>
<span class="strong"><strong>mq4_gain   0.125</strong></span>
<span class="strong"><strong>mq4_off   0</strong></span>
<span class="strong"><strong>mq4_th_ppm   150</strong></span>
<span class="strong"><strong>mq5_gain   0.125</strong></span>
<span class="strong"><strong>mq5_off   0</strong></span>
<span class="strong"><strong>mq5_th_ppm   150</strong></span>
<span class="strong"><strong>mq7_gain   0.125</strong></span>
<span class="strong"><strong>mq7_off   0</strong></span>
<span class="strong"><strong>mq7_th_ppm   150</strong></span>
<span class="strong"><strong>sms_delay_s   300</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>Note that I used a very weak calibration setting; however, these are okay for a demo.</p></div></div><p>Then, we can take a look at the system's current status:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./my_dump.sh status</strong></span>
<span class="strong"><strong>n   v</strong></span>
<span class="strong"><strong>mq2   73.5</strong></span>
<span class="strong"><strong>mq4   121.75</strong></span>
<span class="strong"><strong>mq5   53</strong></span>
<span class="strong"><strong>mq7   80.5</strong></span>
<span class="strong"><strong>alarm   0</strong></span>
</pre></div><p>Then, we can <a id="id54" class="indexterm"/>do all hardware settings at once by using the <code class="literal">chapter_01/SYSINIT.sh</code> script in the book's example code repository as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./SYSINIT.sh</strong></span>
<span class="strong"><strong>done!</strong></span>
</pre></div><p>Okay, now let's start all the required process daemons:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./read_sensors.php -d -T 2</strong></span>
<span class="strong"><strong>root@beaglebone:~# ./write_actuators.php -d -T 2</strong></span>
<span class="strong"><strong>root@beaglebone:~# ./monitor.php -d -T 2</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>Note that all the daemons are running in background in this way; however, the debugging messages are enabled and they can be viewed into the system log with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tail -f /var/log/syslog</strong></span>
</pre></div></div></div><p>Now, we have to approach the lighter to the sensors and press the button on the lighter in order to allow the sensor to detect the gas. After a while, the alarms should be turned on, and looking at the system status, we should get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./my_dump.sh status</strong></span>
<span class="strong"><strong>n   v</strong></span>
<span class="strong"><strong>mq2   203.875</strong></span>
<span class="strong"><strong>mq4   166.5</strong></span>
<span class="strong"><strong>mq5   52.5</strong></span>
<span class="strong"><strong>mq7   122.625</strong></span>
<span class="strong"><strong>alarm   1</strong></span>
</pre></div><p>Also, if we have set up a phone number, we should receive an SMS on the phone!</p><p>As last step, let's display the data logged by plotting them. We can use the following command to extract the data from the database:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./my_dump.sh mq2_log | awk '{ print $2 " " $3 }' &gt; mq2.log</strong></span>
</pre></div><p>In the <code class="literal">mq2.log</code> file, we should find something like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cat mq2.log</strong></span>
<span class="strong"><strong>15:02:07 75.25</strong></span>
<span class="strong"><strong>15:02:10 74.25</strong></span>
<span class="strong"><strong>15:02:12 74.25</strong></span>
<span class="strong"><strong>15:02:14 74.375</strong></span>
<span class="strong"><strong>15:02:16 74.25</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>Now, using the <a id="id55" class="indexterm"/>next command, we're going to create a PNG image holding a plot of our data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gnuplot mq2.plot</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Note that in order to execute this command, you need the <code class="literal">gnuplot</code> command, which can be installed by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># aptitude install gnuplot</strong></span>
</pre></div><p>Also, both the <code class="literal">mq2.log</code> and <code class="literal">mq2.plot</code> files are need. The former is created by the preceding command line, while the latter can be found in the <code class="literal">chapter_01/mq2.plot</code> file in the book's example code repository. It holds the <code class="literal">gnuplot</code> instructions to effectively draw the plot.</p></div></div><p>The plot of the MQ-2 data of my test is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B00255_01_08.jpg" alt="Final test"/></div><p>As you can see, the<a id="id56" class="indexterm"/> sensors are very sensitive to the gas; as soon as I opened my lighter and the gas reached them, the ppm concentration went to high values very quickly.</p><p>To stop the test, we can use the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# killall read_sensors.php</strong></span>
<span class="strong"><strong>root@beaglebone:~# killall write_actuators.php</strong></span>
<span class="strong"><strong>root@beaglebone:~# killall monitor.php</strong></span>
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>In this chapter, we discovered how to manage the ADCs, the GPIOs lines, a GSM module thought, and a serial port. We also saw how to implement a simple monitoring program that can communicate (through a database server) with a sensors reader task to collect input data, and with an actuators manager to alert the user in case of emergency.</p><p>In the next chapter, we'll see how to manage an <span class="strong"><strong>ultrasonic distance</strong></span> sensor to implement a parking assistant that can communicate to the  driver, the distance between the car and the garage's wall. However, the really interesting part of the next chapter is about how to manage the distance sensor in two different setups: one with all the peripherals near the BeagleBone Black, and another with a remote connection of the sensor through a USB cable.</p></div></body></html>