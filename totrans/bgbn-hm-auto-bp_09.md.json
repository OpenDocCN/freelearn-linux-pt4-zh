["```\nroot@BeagleBone:~# ls -l /dev/ttyO*\ncrw-rw---- 1 root tty 248, 0 Apr 23 20:20 /dev/ttyO0\n\n```", "```\nroot@BeagleBone:~# echo BB-UART1 > /sys/devices/bone_capemgr.9/slots\nroot@BeagleBone:~# echo BB-UART2 > /sys/devices/bone_capemgr.9/slots\n\n```", "```\nroot@beaglebone:~# ls -l /dev/ttyO*\ncrw-rw---- 1 root tty     248, 0 Apr 23 20:20 /dev/ttyO0\ncrw-rw---T 1 root dialout 248, 1 Apr 23 21:48 /dev/ttyO1\ncrw-rw---T 1 root dialout 248, 2 Apr 23 21:48 /dev/ttyO2\n\n```", "```\nusb usb1: usb wakeup-resume\nusb usb1: usb auto-resume\nhub 1-0:1.0: hub_resume\nhub 1-0:1.0: port 1: status 0101 change 0001\nhub 1-0:1.0: state 7 ports 1 chg 0002 evt 0000\nhub 1-0:1.0: port 1, status 0101, change 0000, 12 Mb/s\nusb 1-1: new full-speed USB device number 2 using musb-hdrc\nusb 1-1: ep0 maxpacket = 16\nusb 1-1: skipped 1 descriptor after interface\nusb 1-1: skipped 1 descriptor after interface\nusb 1-1: default language 0x0409\nusb 1-1: udev 2, busnum 1, minor = 1\nusb 1-1: New USB device found, idVendor=1862, idProduct=0001\nusb 1-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3\nusb 1-1: Product: TSC12xxF CCID-DFU Version 2.10\nusb 1-1: Manufacturer: Teridian Semiconductors\nusb 1-1: SerialNumber: 123456789\nusb 1-1: usb_probe_device\nusb 1-1: configuration #1 chosen from 1 choice\nusb 1-1: adding 1-1:1.0 (config #1, interface 0)\nusb 1-1: adding 1-1:1.1 (config #1, interface 1)\nhub 1-0:1.0: state 7 ports 1 chg 0000 evt 0002\nhub 1-0:1.0: port 1 enable change, status 00000103\n\n```", "```\nroot@beaglebone:~# aptitude install pcsc-tools pcscd libccid\n\n```", "```\nroot@beaglebone:~# pcsc_scan\nPC/SC device scanner\nV 1.4.20 (c) 2001-2011, Ludovic Rousseau <ludovic.rousseau@free.fr>\nCompiled with PC/SC lite version: 1.8.3\nUsing reader plug'n play mechanism\nScanning present readers...\nWaiting for the first reader...\n\n```", "```\nSCardEstablishContext: Service not available.\n\n```", "```\n--- /etc/libccid_Info.plist.orig\t2014-04-23 20:39:48.664062641 +0000\n+++ /etc/libccid_Info.plist\t2014-04-23 20:40:28.705078271 +0000\n@@ -325,6 +325,7 @@\n       <string>0x08C3</string>\n       <string>0x08C3</string>\n       <string>0x15E1</string>\n+      <string>0x1862</string>\n    </array>\n\n    <key>ifdProductID</key>\n@@ -550,6 +551,7 @@\n       <string>0x0401</string>\n       <string>0x0402</string>\n       <string>0x2007</string>\n+      <string>0x0001</string>\n    </array>\n\n    <key>ifdFriendlyName</key>\n@@ -775,6 +777,7 @@\n       <string>Precise Biometrics Precise 250 MC</string>\n       <string>Precise Biometrics Precise 200 MC</string>\n       <string>RSA RSA SecurID (R) Authenticator</string>\n+                <string>TSC12xxF</string>\n    </array>\n\n    <key>Copyright</key>\n```", "```\nroot@beaglebone:~# /etc/init.d/pcscd restart\n[ ok ] Restarting pcscd (via systemctl): pcscd.service.\nroot@beaglebone:~# pcsc_scan\nPC/SC device scanner\nV 1.4.20 (c) 2001-2011, Ludovic Rousseau <ludovic.rousseau@free.fr>\nCompiled with PC/SC lite version: 1.8.3\nUsing reader plug'n play mechanism\nScanning present readers...\n0: TSC12xxF (123456789) 00 00\n1: TSC12xxF (123456789) 00 01\n2: TSC12xxF (123456789) 00 02\n3: TSC12xxF (123456789) 00 03\n4: TSC12xxF (123456789) 00 04\n\nWed Apr 23 20:40:56 2014\nReader 0: TSC12xxF (123456789) 00 00\n Card state: Card removed,\nReader 1: TSC12xxF (123456789) 00 01\n Card state: Card removed,\nReader 2: TSC12xxF (123456789) 00 02\n Card state: Card removed,\nReader 3: TSC12xxF (123456789) 00 03\n Card state: Card removed,\nReader 4: TSC12xxF (123456789) 00 04\n Card state: Card removed,\n\n```", "```\nWed Apr 23 20:52:22 2014\nReader 0: TSC12xxF (123456789) 00 00\n Card state: Card inserted,\n ATR: 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00\n\nATR: 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00\n+ TS = 3B --> Direct Convention\n+ T0 = BE, Y(1): 1011, K: 14 (historical bytes)\n TA(1) = 11 --> Fi=372, Di=1, 372 cycles/ETU\n 10752 bits/s at 4 MHz, fMax for Fi = 5 MHz => 13440 bits/s\n TB(1) = 00 --> VPP is not electrically connected\n TD(1) = 00 --> Y(i+1) = 0000, Protocol T = 0\n-----\n+ Historical bytes: 41 01 38 00 00 00 00 00 00 00 00 01 90 00\n Category indicator byte: 41 (proprietary format)\n\nPossibly identified card (using /usr/share/pcsc/smartcard_list.txt):\n3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00\n ACS (Advanced Card System) ACOS-1\n\n```", "```\n#\n# Smart Card Observer\n#\n\nclass printobserver(CardObserver):\n   def update(self, observable, (addedcards, removedcards)):\n      for card in addedcards:\n         logging.info(\"->] \" + toHexString(card.atr))\n      for card in removedcards:\n         logging.info(\"<-] \" + toHexString(card.atr))\n\n#\n# The daemon body\n#\n\ndef daemon_body():\n   # The main loop\n   logging.info(\"INFO waiting for card... (hit CTRL+C to stop)\")\n\n   try:\n      cardmonitor = CardMonitor()\n      cardobserver = printobserver()\n      cardmonitor.addObserver(cardobserver)\n\n      while True:\n         sleep(1000000) # sleep forever\n\n   except:\n      cardmonitor.deleteObserver(cardobserver)\n```", "```\nroot@beaglebone:~/smart_card# ./smart_card.py\nINFO:root:INFO waiting for card... (hit CTRL+C to stop)\nINFO:root:->] 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00\nINFO:root:<-] 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00\n\n```", "```\nImportError: No module named daemon\n\n```", "```\nroot@beaglebone:~/smart_card# pip install python-daemon\n\n```", "```\nroot@BeagleBone:~# stty -F /dev/ttyO1 9600 raw\nroot@BeagleBone:~# cat /dev/ttyO1\n\n```", "```\nroot@BeagleBone:~# cat /dev/ttyO1\n.6F007F4E1E40\n\n```", "```\n# Read the tags' IDs\ncat $dev | while read id ; do\n   # Remove the non printable characters and print the data\n   echo -n $id | tr '\\r' '\\n' | tr -cd '[:alnum:]\\n'\ndone\n```", "```\nroot@beaglebone:~/rfid_lf# ./rfid_lf.sh /dev/ttyO1\n6F007F48C199\n\n```", "```\nroot@beaglebone:~# aptitude install git debhelper dctrl-tools\n\n```", "```\nroot@beaglebone:~# git clone http://github.com/cosino/libmsgbuff.git\n\n```", "```\nroot@beaglebone:~# cd libmsgbuff\nroot@beaglebone:~/libmsgbuff# ./autogen.sh\n\n```", "```\naclocal:configure.ac:11: warning: macro `AM_SILENT_RULES' not found in library\naclocal:configure.ac:18: warning: macro `AM_PROG_AR' not found in library\nconfigure.ac:11: error: possibly undefined macro: AM_SILENT_RULES\n If this token and others are legitimate, please use m4_pattern_allow.\n See the Autoconf documentation.\n\n```", "```\n index dcfd1ce..333e417 100644\n--- a/configure.ac\n+++ b/configure.ac\n@@ -8,14 +8,12 @@ AC_CONFIG_SRCDIR([msgbuff.c])\n AC_CONFIG_HEADERS([configure.h])\n\n AM_INIT_AUTOMAKE([1.9 foreign -Wall -Werror])\n-AM_SILENT_RULES([yes])\n\n # Global settings\n AC_SUBST(EXTRA_CFLAGS, ['-Wall -D_GNU_SOURCE -include configure.h'])\n\n # Checks for programs\n AC_PROG_CXX\n-AM_PROG_AR\n AC_PROG_AWK\n AC_PROG_CC\n AC_PROG_CPP\n```", "```\nroot@beaglebone:~/libmsgbuff# ./debian/rules binary\ndpkg-deb: building package `libmsgbuff0' in `../libmsgbuff0_0.60.0_armhf.deb'\n.\ndpkg-deb: building package `libmsgbuff-dev' in `../libmsgbuff-dev_0.60.0_armhf.deb'.\n\n```", "```\nroot@beaglebone:~/libmsgbuff# dpkg -i ../libmsgbuff0_0.60.0_armhf.deb ../libmsgbuff-dev_0.60.0_armhf.deb\nSetting up libmsgbuff0 (0.60.0) ...\nSetting up libmsgbuff-dev (0.60.0) ...\n\n```", "```\nroot@beaglebone:~# git clone http://github.com/cosino/libavp.git\n\n```", "```\nroot@beaglebone:~# cd libavp\nroot@beaglebone:~/libavp# ./autogen.sh\n\n```", "```\nroot@beaglebone:~/libavp# ./debian/rules binary\ndpkg-deb: building package `libavp0' in `../libavp0_0.80.0_armhf.deb'.\ndpkg-deb: building package `libavp-dev' in `../libavp-dev_0.80.0_armhf.deb'.\n\n```", "```\nroot@beaglebone:~/libavp# dpkg -i ../libavp0_0.80.0_armhf.deb ../libavp-dev_0.80.0_armhf.deb\n\n```", "```\nroot@beaglebone:~# git clone http://github.com/cosino/libcaenrfid.git\nroot@beaglebone:~# cd libcaenrfid/\nroot@beaglebone:~/libcaenrfid# ./autogen.sh\n\n```", "```\nroot@beaglebone:~/libcaenrfid# cp src/linux-gnueabi.c src/linux-gnueabihf.c\nroot@beaglebone:~/libcaenrfid# cp src/linux-gnueabi.h src/linux-gnueabihf.h\n\n```", "```\nroot@beaglebone:~/libcaenrfid# ./debian/rules binary\n...\ndpkg-deb: building package `libcaenrfid0' in `../libcaenrfid0_0.91.0_armhf.deb'.\ndpkg-deb: building package `libcaenrfid-dev' in `../libcaenrfid-dev_0.91.0_armhf.deb'.\nroot@beaglebone:~/libcaenrfid# dpkg -i ../libcaenrfid0_0.91.0_armhf.deb ../libcaenrfid-dev_0.91.0_armhf.deb\n\n```", "```\nint main(int argc, char *argv[])\n{\n   int i;\n   struct caenrfid_handle handle;\n   char string[] = \"Source_0\";\n   struct caenrfid_tag *tag;\n   size_t size;\n   char *str;\n   int ret;\n\n   if (argc < 2)\n      usage();\n\n      /* Start a new connection with the CAENRFIDD server */\n      ret = caenrfid_open(CAENRFID_PORT_RS232, argv[1], &handle);\n      if (ret < 0)\n         usage();\n\n      /* Set session \"S2\" for logical source 0 */\n      ret = caenrfid_set_srcconf(&handle, \"Source_0\",\n         CAENRFID_SRC_CFG_G2_SESSION, 2);\n      if (ret < 0) {\n         err(\"cannot set session 2 (err=%d)\", ret);\n         exit(EXIT_FAILURE);\n      }\n\n      while (1) {\n         /* Do the inventory */\n         ret = caenrfid_inventory(&handle, string, &tag, &size);\n         if (ret < 0) {\n            err(\"cannot get data (err=%d)\", ret);\n            exit(EXIT_FAILURE);\n         }\n\n         /* Report results */\n         for (i = 0; i < size; i++) {\n            str = bin2hex(tag[i].id, tag[i].len);\n            EXIT_ON(!str);\n\n            info(\"%.*s %.*s %.*s %d\",\n               tag[i].len * 2, str,\n               CAENRFID_SOURCE_NAME_LEN, tag[i].source,\n               CAENRFID_READPOINT_NAME_LEN, tag[i].readpoint,\n               tag[i].type);\n\n            free(str);\n         }\n\n         /* Free inventory data */\n         free(tag);\n      }\n\n      caenrfid_close(&handle);\n\n      return 0;\n}\n```", "```\nroot@beaglebone:~/rfid_uhf# ./rfid_uhf /dev/ttyO2\n\n```", "```\nroot@beaglebone:~/chapter_09/rfid_uhf# ./rfid_uhf /dev/ttyO2\nrfid_uhf.c[ 110]: main: e280113020002021dda500ab Source_0 Ant0 3\n\n```", "```\nroot@beaglebone:~# aptitude install ruby-dev\n\n```", "```\nroot@beaglebone:~# gem install t -V\n\n```", "```\nroot@beaglebone:~# t -h\nCommands:\n t accounts                          # List accounts\n t authorize                         # Allows an application to request user...\n t block USER [USER...]              # Block users.\n t delete SUBCOMMAND ...ARGS         # Delete Tweets, Direct Messages, etc.\n t direct_messages                   # Returns the 20 most recent Direct Mes...\n t direct_messages_sent              # Returns the 20 most recent Direct Mes...\n t dm USER MESSAGE                   # Sends that person a Direct Message.\n t does_contain [USER/]LIST USER     # Find out whether a list contains a user.\n t does_follow USER [USER]           # Find out whether one user follows ano...\n ...\n\n```", "```\nroot@beaglebone:~# t authorize\nWelcome! Before you can use t, you'll first need to register an\napplication with Twitter. Just follow the steps below:\n 1\\. Sign in to the Twitter Application Management site and click\n \"Create New App\".\n 2\\. Complete the required fields and submit the form.\n Note: Your application must have a unique name.\n 3\\. Go to the Permissions tab of your application, and change the\n Access setting to \"Read, Write and Access direct messages\".\n 4\\. Go to the API Keys tab to view the consumer key and secret,\n which you'll need to copy and paste below when prompted.\n\nPress [Enter] to open the Twitter Developer site.\n\n```", "```\nxprop:  unable to open display ''\nxprop:  unable to open display ''\nEnter your API key: /usr/bin/xdg-open: 1: eval: www-browser: not found\n/usr/bin/xdg-open: 1: eval: links2: not found\n/usr/bin/xdg-open: 1: eval: elinks: not found\n/usr/bin/xdg-open: 1: eval: links: not found\n/usr/bin/xdg-open: 1: eval: lynx: not found\n/usr/bin/xdg-open: 1: eval: w3m: not found\nxdg-open: no method available for opening 'https://apps.twitter.com'\n\n```", "```\nIn a moment, you will be directed to the Twitter app authorization page.\nPerform the following steps to complete the authorization process:\n 1\\. Sign in to Twitter.\n 2\\. Press \"Authorize app\".\n 3\\. Copy and paste the supplied PIN below when prompted.\n\nPress [Enter] to open the Twitter app authorization page.\n\n```", "```\nxprop:  unable to open display ''\nxprop:  unable to open display ''\nEnter the supplied PIN: /usr/bin/xdg-open: 1: eval: www-browser: not found\n/usr/bin/xdg-open: 1: eval: links2: not found\n/usr/bin/xdg-open: 1: eval: elinks: not found\n/usr/bin/xdg-open: 1: eval: links: not found\n/usr/bin/xdg-open: 1: eval: lynx: not found\n/usr/bin/xdg-open: 1: eval: w3m: not found\nxdg-open: no method available for opening 'https://api.twitter.com/oauth/authorize?oauth_callback=oob&oauth_consumer_key=sHSeFMEGPRqRyf9V0UB4LtQOg&oauth_nonce=9T9rSHXiaSiWXkh0ksVE5ioTcop0srz7xMG92VhVI&oauth_signature=oNWj1Lj%225BUmrFkD%252B065axJv6WSeM%253D&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1443370645&oauth_token=J2fp-gAAAAAAhyrAAABAUA-YNw8&oauth_version=1.0'\n\n```", "```\nhttps://api.twitter.com/oauth/authorize?oauth_callback=oob&oauth_consumer_key=sHSeFMEGPRqRyf9V0UB4LtQOg&oauth_nonce=9T9rSHXiaSiWXkh0ksVE5ioTcop0srz7xMG92VhVI&oauth_signature=oNWj1Lj%225BUmrFkD%252B065axJv6WSeM%253D&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1443370645&oauth_token=J2fp-gAAAAAAhyrAAABAUA-YNw8&oauth_version=1.0\n\n```", "```\nAuthorization successful.\n\n```", "```\nroot@beaglebone:~# t update 'Hello there! This is my first tweet from the command line!'\nTweet posted by @RodolfoGiometti.\n\nRun `t delete status 648174339569897474` to delete.\n\n```", "```\n# The known IDs\nID2NAME = {\n        '11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11': \"user1\",\n        '22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22': \"user2\",\n        '3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00': 'Rodolfo Giometti'\n}\n...\n#\n# Smart Card Observer\n#\n\nclass printobserver(CardObserver):\n   def update(self, observable, (addedcards, removedcards)):\n      for card in addedcards:\n         try:\n            id = toHexString(card.atr)\n         except:\n            pass\n         if len(id) == 0:\n            continue\n         logging.info(\"got tag ID \" + id)\n\n         # Verify that the tag ID is known and then\n         # tweet the event\n         try:\n            name = ID2NAME[id]\n        except:\n           logging.info(\"unknow tag ID! Ignored\")\n           continue\n\n        logging.info(\"Twitting that \" + name + \" was arrived!\")\n        call([t_cmd, t_args, name + \" was arrived!\"])\n```", "```\n# The known IDs\ndeclare -gA 'ID2NAME=(\n   [111111111111]=\"user1\",\n   [222222222222]=\"user2\"\n   [6F007F4E1E40]=\"Rodolfo Giometti\"\n)'\n…\n# Read the tags' IDs\ncat $dev | while read id ; do\n   # Remove the non printable characters\n   id=$(echo $id | tr -cd '[:alnum:]')\n   info \"got tag ID $id\"\n\n   # Verify that the tag ID is known and then tweet the event\n   name=${ID2NAME[$id]}\n   if [ -z \"$name\" ] ; then\n      info \"unknow tag ID! Ignored\"\n   else\n      info \"Twitting that $name was arrived!\"\n      $t_cmd $t_args \"$name was arrived!\"\n   fi\ndone\n```", "```\n/* The known IDs */\nstruct associative_array_s {\n   char *id;\n   char *name;\n} ID2NAME[] = {\n   { \"111111111111111111111111\", \"user1\" },\n   { \"222222222222222222222222\", \"user2\" },\n   { \"e280113020002021dda500ab\", \"Rodolfo Giometti\" },\n};\n...\n   /* The main loop */\n   while (1) {\n      /* Do the inventory */\n      ret = caenrfid_inventory(&handle, string, &tag, &size);\n      if (ret < 0) {\n         err(\"cannot get data (err=%d)\", ret);\n         exit(EXIT_FAILURE);\n      }\n\n      /* Report results */\n      for (i = 0; i < size; i++) {\n         str = bin2hex(tag[i].id, tag[i].len);\n         EXIT_ON(!str);\n         info(\"got tag ID %.*s\", tag[i].len * 2, str);\n\n         for (j = 0; j < ARRAY_SIZE(ID2NAME); j++)\n            if (strncmp(str, ID2NAME[j].id,\n               tag[i].len * 2) == 0)\n            break;\n         if (j < ARRAY_SIZE(ID2NAME)) {\n            info(\"Twitting that %s was arrived!\",\n               ID2NAME[j].name);\n            ret = asprintf(&cmd, \"%s %s %s was arrived!\", t_cmd, t_arg, ID2NAME[j].name);\n            EXIT_ON(ret < 1);\n            ret = system(cmd);\n            EXIT_ON(ret < 0);\n            free(cmd);\n         } else\n         info(\"unknow tag ID! Ignored\");\n\n         free(str);\n   }\n\n   /* Free inventory data */\n   free(tag);\n}\n```", "```\nroot@beaglebone:~# ./SYSINIT.sh\ndone!\n\n```", "```\nroot@beaglebone:~/smart_card# ./smart_card2twitter.py\nINFO:root:got tag ID 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00\nINFO:root:Twitting that Rodolfo Giometti was arrived!\nTweet posted by @RodolfoGiometti.\n\nRun `t delete status 649586168313552896` to delete.\n```", "```\nroot@beaglebone:~/rfid_lf# ./rfid_lf2twitter.sh /dev/ttyO1\nrfid_lf2twitter.sh: got tag ID 6F007F4E1E40\nrfid_lf2twitter.sh: Twitting that Rodolfo Giometti was arrived!\nTweet posted by @RodolfoGiometti.\n\nRun `t delete status 649586168313552896` to delete.\n```", "```\nroot@beaglebone:~/rfid_uhf# ./rfid_uhf2twitter /dev/ttyO2\nrfid_uhf2twitter.c[ 122]: main: Twitting that Rodolfo Giometti was arrived!\nTweet posted by @RodolfoGiometti.\n\nRun `t delete status 649586168313552896` to delete.\n```"]