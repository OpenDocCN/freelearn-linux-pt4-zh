- en: Chapter 10. A Lights Manager with a TV Remote Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will manage the lights of our home by using a normal TV
    remote controller.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, we can use any remote controller we have, but the idea is to add
    remote controlling via the infrared mechanism to any device in our home. In fact,
    in this chapter I'm going to show how to manage a simple on/off device; but this
    concept can be easily extended to any other device we can connect to our BeagleBone
    Black!
  prefs: []
  type: TYPE_NORMAL
- en: We'll see how to capture the infrared messages that a remote controller sends
    to our BeagleBone Black by using a suitable circuitry, and then, we'll use a dedicated
    kernel driver in order to manage such messages and convert them into well-defined
    commands for our userspace programs.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of functioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functioning of the prototype we're going to realize is quite simple. We
    need an electronic circuit that can detect the infrared light emitted by the remote
    controller and then generate some impulses that are caught by a special software
    that can detect and store them into a configuration file in order to be used at
    later time. Then, by using a special daemon, we can convert a button pressed on
    the remote controller into a suitable command for our BeagleBone Black.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the hardware we have to realize is very simple. We just need
    a small circuitry with an infrared-capable photo diode (infrared receiver). On
    the other hand, the software part is a bit more complicated due to the fact that
    we first need a kernel driver to reliably detect the message from the remote control,
    and then a user-level program to record it, a program to recognize which button
    has been pressed, and a last program to convert such pressures into on and off
    commands (or whatever we wish to control).
  prefs: []
  type: TYPE_NORMAL
- en: Due to lack of space, I'm going to manage the relays array used in [Chapter
    3](ch03.html "Chapter 3. Aquarium Monitor"), *Aquarium Monitor*, leaving it to
    you to connect whatever you want.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning—remember that, even if the relays array used is suitable for controlling
    high voltages, *for safety reasons, you should not connect any device with voltages
    higher then 12V if you don't know what you are doing!*
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated before, the hardware setting is quite simple. The relays array has
    already been set up in a previous chapter, while the infrared receiver circuitry
    is really tricky. So, let's go ahead!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the infrared detector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The infrared detector (or receiver) I used in this prototype is shown in the
    following image (actually, the receiver is the device with the red dot; the other
    one is just a transmitter that we're not using here).
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the infrared detector](img/B00255_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The devices can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/infrared-emitter-detector](http://www.cosino.io/product/infrared-emitter-detector).'
  prefs: []
  type: TYPE_NORMAL
- en: The datasheet is available at [https://www.sparkfun.com/datasheets/Components/LTR-301.pdf](https://www.sparkfun.com/datasheets/Components/LTR-301.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the image shows the topmost part only of the infrared devices. In
    reality, they look similar to a normal diode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit to manage it is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the infrared detector](img/B00255_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **infrared receiver** (**IR**) is the diode with the red dot in the preceding
    diagram and **R** is a 6.8KΩ resistor. The following table shows the connections
    with the BeagleBone Black:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | IR receiver label |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P9.3 - Vcc | 3.3V |'
  prefs: []
  type: TYPE_TB
- en: '| P9.12 - GPIO60 | GPIO @R |'
  prefs: []
  type: TYPE_TB
- en: '| P9.1 - GND | GND |'
  prefs: []
  type: TYPE_TB
- en: 'To test the functionality, we can set the GPIO 60 pin as an input pin by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that you must not have any driver loaded into the system that uses
    that pin, otherwise you'll get an error message!
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use the following script to continuously read the GPIO status,
    and then print on the terminal when it goes to value `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you point your remote controller to the infrared receiver and press a
    button you, should get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To stop the script, just hit the *CTRL* + *C* key sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the relays array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The relays array is shown in the following image. It's the device already used
    in [Chapter 3](ch03.html "Chapter 3. Aquarium Monitor"), *Aquarium Monitor*, so
    you can refer there for further information about it, while here I'm going to
    show the connections needed for this prototype only.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the relays array](img/B00255_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The device can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/5v-relays-array](http://www.cosino.io/product/5v-relays-array).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BeagleBone Black''s GPIOs and the pins of the relays array board I used
    with these devices are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pins | Relays array pin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P8.10 - GPIO68 | IN1 |'
  prefs: []
  type: TYPE_TB
- en: '| P8.9 - GPIO69 | IN2 |'
  prefs: []
  type: TYPE_TB
- en: '| P8.12 - GPIO44 | IN3 |'
  prefs: []
  type: TYPE_TB
- en: '| P8.11 GPIO45 | IN4 |'
  prefs: []
  type: TYPE_TB
- en: '| P9.1 - GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| P9.6 - 5V | Vcc |'
  prefs: []
  type: TYPE_TB
- en: 'To test the functionality of each GPIO line, we can use, as an example, the
    following command to enable one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the off state of the relay is `1`, while the on state is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can turn the relay on and off by just writing `0` and `1` in the `/sys/class/gpio/gpio68/value`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The final picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following image shows the prototype I realized to implement this project
    and to test the software. You should notice the infrared receiver on the bottom-right
    corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![The final picture](img/B00255_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that, to use the relays array that needs the 5V power supply voltage, you
    must use an external power supply to power the BeagleBone Black.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to set up the software to manage our infrared detector, and to
    do it, we're going to use the **LIRC** (**Linux Infrared Remote Control**) subsystem,
    which is a special code that has been developed for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For further information on the LIRC subsystem, you can take a look at [http://www.lirc.org/](http://www.lirc.org/).
  prefs: []
  type: TYPE_NORMAL
- en: We'll need a kernel driver to convert the pulse generated by the infrared detector
    into well-defined messages, and then to send them, through a LIRC device, to the
    userspace programs. At userspace level, we're going to use a special tool from
    the LIRC project in order to convert the infrared messages into input events,
    that is, the messages that a normal keyboard sends to the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For further information on the Linux input subsystem, you can take a look at
    [https://www.kernel.org/doc/Documentation/input/input.txt](https://www.kernel.org/doc/Documentation/input/input.txt).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the kernel driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To set up the kernel driver to manage our infrared receiver, we can use a procedure
    similar to the one used in [Chapter 4](ch04.html "Chapter 4. Google Docs Weather
    Station"), *Google Docs Weather Station*. Once the sources from the GitHub repository
    are downloaded, we have to follow the procedure in [Chapter 4](ch04.html "Chapter 4. Google
    Docs Weather Station"), *Google Docs Weather Station*, until the step where we
    have to apply our special patch. In fact, in this case, we have to apply the patch
    in the `chapter_10/0001-Add-support-for-Homebrew-GPIO-Port-Receiver-Transmit.patch`
    file in the book's example code repository in order to add the infrared receiver
    support.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `--whitespace=nowarn` command-line option is needed just in case
    your `git` system is configured to automatically fix up the whitespace errors,
    which is wrong in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything works well, the `git log` command should display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Before starting the kernel compilation, let me spend a few words regarding this
    patch. It simply adds a new driver into the `KERNEL/drivers/staging/media/lirc`
    directory of the Linux sources, so, after applying the patch, if we take a look
    at the new file `lirc_gpio.c`, we can discover how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following is a brief explanation of the driver code. If you don't care about
    it, and just wish to use the driver *as-is*, you can safely skip this part until
    the kernel compilation commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning, we have the kernel module parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use the `gpio_in` parameter in order to specify the input pin
    which the infrared receiver is connected to. Then, some local functions follow
    (which I don''t report here), and then we find the file''s operations definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each function is related to a well-defined system call that we can use on the
    new LIRC device.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the very bottom of the file, there is the `lirc_gpio_init_module()` function,
    which is responsible for setting up the new device. As a first step, this function
    tries to request all needed GPIO lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After requesting the `gpio_in` pin, the function sets it up as an input pin
    and then checks if such a GPIO line is interrupt-capable; otherwise, the driver
    can't work properly. If so, the function requests the IRQ line, and then it proceeds
    with the `gpio_out` pin (note that it's not mandatory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the driver sets the sense mode by using a little auto-detect procedure
    (if not directly specified by the user at loading time), as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can finally set up the LIRC driver by calling first the `lirc_buffer_init()`
    function, to properly allocate a memory buffer for the messages management, and
    then by calling the `lirc_register_driver()`, to register the driver into the
    system, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, now we can start to compile the kernel with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This step, and the subsequent one, are time consuming and require patience,
    so you should take a cup of your preferred tea or coffee, and just wait.
  prefs: []
  type: TYPE_NORMAL
- en: After some time, the procedure will present the standard kernel configuration
    panel, and now we should verify that the needed drivers are enabled. You should
    navigate in the menu to **Device Drivers** | **Staging drivers** | **Media staging
    drivers** | **Linux Infrared Remote Control IR receiver/transmitter drivers**,
    where the **Homebrew GPIO Port Receiver/Transmitter** entry should be selected
    as module (**<M>**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, exit the configuration menu and the kernel compilation should start.
    Then, when it ends, the new kernel image will be ready, and the following message
    should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can install it on the microSD, using the following installation tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything works well, after the usual login, we can verify that the new
    kernel is really running using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the kernel version on your system may be more recent than mine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, the new kernel is ready! Now, we can load the LIRC driver by using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the GPIO 60 must not be in use, or you may get an error like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel messages should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, a new entry should now be ready under the `/dev` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The LIRC tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the kernel module is set up and running, we need some userspace tools
    to manage it. So, let''s install the `lirc` package with the usual `aptitude`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As stated by the preceding line, to enable the `lircd` daemon (that is, the
    tools we need), we have to replace the configuration file `/etc/lirc/lircd.conf`;
    however, we''re not going to use the daemon this way. In reality, we can test
    that the driver is really working as expected by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing should happen until you point your remote controller at the infrared
    receiver and press a button. In this case, you should see some output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Okay! The `/dev/lirc0` device is functioning, and the driver correctly detects
    the messages from the remote controller! Now, we have to create a custom configuration
    file in order to associate an input event to each of the remote controller's buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, due to lack of space, I'm going to configure just a few buttons in the
    following example; but you can add whatever you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to use is `irrecord`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`myremote.conf` is the file where we wish to save our configuration. The program
    then will show an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let''s press the *return*/*Enter* key, and the program will continue
    showing the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Ok, now it's really important to carefully follow the preceding instructions.
    So, let's start pressing different buttons and hold them for approximately one
    second in such a way as to generate at least one dot, but in no case more than
    ten dots, of output for each press!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the program will start printing the dots until it reaches the end of the
    terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When the first line is finished, the program will display the following message,
    and new dots will appear, but, this time, just one per pressed button!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the first detection stage is finished, and we can start the real detection
    one button at a time. Now, the system will ask for a button name or the *Enter*
    key to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I enter the name of button **0** by inserting the `KEY_0` string, as follows.
    Then, the system will ask you to hold down the button **0** until it has got it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The valid button names can be listed by using the `irrecord` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the procedure restarts for the next buttons as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, I simply enter no names and just press *Enter* to exit, and
    then I get the prompt again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a new file called `myremote.conf` should be ready. The following is a
    snippet of my file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to test our job. We have to verify if all buttons have been
    correctly recognized. To do it, we have to execute the `lircd` daemon from the
    command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The last argument `--uinput` is used to instruct the `lircd` daemon to convert
    the button presses into input events as they came from a normal keyboard, so,
    we can test them with the `evtest` command. It must be executed into another terminal
    due to the fact that the previous command must run with `evtest` at the same time!
    The command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to select the (only) available input device with the `0` number,
    and the program will continue showing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when I press a button on my remote controller, I get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `evtest` program can be installed by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the **0** button on the remote controller corresponds to the `KEY_0`
    input event that has the `11` code, while the **1**, **2**, and **3** buttons
    correspond to the `KEY_1`, `KEY_2`, and `KEY_3` input events that have the `2`,
    `3`, and `4` codes. So, we can map such events with the corresponding GPIO line
    by using a look-up table as follows (Python syntax):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `-1` value means *no GPIO*. So, when we press the **0** button, we receive
    the `KEY_0` input event that has the `11` code, and at the 11th position of the
    array (starting the count from **0**), we have the `68` value, so, the `GPIO68`
    is attached to the **0** button on the remote controller. In a similar manner,
    the **1**, **2**, and **3** buttons that correspond to the `KEY_1` (code 2), `KEY_2`
    (code 3), and `KEY_3` (code 4) input events, are connected to `GPIO 69` (array
    index 2), `GPIO 44` (array index 3), and `GPIO 45` (array index 4) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The input events manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we have to add the last element only; that is, the software that takes
    the input events and turns the corresponding relay on and off. To do it in a *dirty
    and quick* way, we can use the Python language with the `evdev` library that can
    be easily installed on our BeagleBone Black with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The curious reader can get more information about this library at [https://python-evdev.readthedocs.org/en/latest/](https://python-evdev.readthedocs.org/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the library has been installed, we can consider a possible implementation
    of our input events manager, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete code is stored in the `chapter_10/read_events.py` file in the book's
    example code repository.
  prefs: []
  type: TYPE_NORMAL
- en: The code is quite self explanatory, but let me explain some points. First of
    all, note that the `GPIO` array is the one defined in the previous section, and
    then the `gpio_get()` and `gpio_set()` methods are used to get and set a GPIO
    status. The program, after a little check to the command line, starts opening
    the input device supplied by the user by using the `InputDevice()` method and
    then enters into the big loop, where it waits for a key press, and then it switches
    the status of the corresponding GPIO (if any).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, before continuing, let me suggest to you an interesting feature in using
    Linux's input layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if it may seem a bit complicated using the input layer instead of directly
    accessing the `lircd` daemon, this approach has the big advantage that we can
    test our relays manager with any input device! In fact, if you try to connect
    a normal keyboard to the BeagleBone Black''s USB port, you''ll get a new input
    device as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, selecting the new input device `/dev/input/event1`, we can generate the
    same input events as before by simply pressing the **0**, **1**, **2**, and **3**
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, even if not shown here due to lack of space, the keyboard generates
    more input events than the usual `EV_KEY` ones. But we can easily skip them just
    by selecting the right input event type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, if we execute our program as in the following command line,
    we can manage the relays as we did with the remote controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The final test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the previous chapters, we have to first execute the `chapter_10/SYSINIT.sh`
    file in the book''s example code repository as usual to set up all GPIOs lines
    and to load the kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must execute the `lircd` daemon by using the command line without
    the `--nodaemon` option argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can execute the preceding `read_events.py` program to manage the relays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now the trick is done. We simply have to direct the remote controller to the
    infrared detector and press the **0**, **1**, **2**, or **3** button. When we
    press the button, the switch turns on, while when we press the button again, the
    switch also turns off changing the status of the connected relay, and, as a last
    step, the device connected to it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at a kernel driver to manage an infrared device.
    Then, we saw how to use the userspace tools from the LIRC project to receive the
    messages from the remote controller, and then to turn them into specific Linux
    input events. This allowed us to manage some devices connected with our BeagleBone
    Black.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discover how to manage a wireless device to manage
    a wall plug and to monitor the power consumption of the device connected to it
    by using a common communication system for the home automation, that is, the **Z-Wave**
    protocol.
  prefs: []
  type: TYPE_NORMAL
