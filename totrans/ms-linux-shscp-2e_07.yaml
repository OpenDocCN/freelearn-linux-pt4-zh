- en: Creating Building Blocks with Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive into the wonderful world of functions. We can
    look at these as modular building blocks creating powerful and adaptive scripts.
    By creating functions, we add the code in a single building block isolated from
    the rest of the script. Focusing on improvements of a single function is a lot
    easier than trying to improve the script as a single object. Without functions,
    it is difficult to hone in on problem areas and the code is often repeated, which
    means that updates need to happen in many locations. Functions are named as blocks
    of code or scripts within scripts and they can overcome many problems associated
    with more complex code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we make our way through the chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning values from functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using functions in menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are blocks of code that exist in memory as **named elements**. These
    elements can be created within the shell environment, as well as within the script
    execution. When a command is issued at the command line, aliases are checked first
    and, following this, we check for a matching function name. To display the functions
    residing in your shell environment, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will vary depending on the distribution you are using and the number
    of functions you have created. On my Linux Mint, the partial output is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d280f40-0bea-4847-81c0-5b1bf0377f89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the small `-f` option, you can display the function and the associated
    definition. However, if we want to see just a single function definition, we can
    use the `type` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code example will display the code block for the `quote` function,
    if it exists within your shell. We can see the output of this command in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6409e11b-7f72-454e-b4a9-2cc2aad5a3fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `quote` function in bash inserts single quotes around a supplied input
    parameter. For example, we can expand the `USER` variable and display the value
    as a string literal; this is shown in the following screenshot. The screenshot
    captures the command and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bffd9d56-fb94-4d67-9ec6-0e7ba69d2192.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Most code can be represented by a pseudo-code which shows an example layout.
    Functions are no different and the code to create a function is listed in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, there is another way of defining functions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `keyword` function is deprecated for portability with the **Portable Operating
    System Interface** (**POSIX**) specification, but it is still used by some developers.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `()` are not necessary when using the `keyword` function, but
    they are a must if you define the function without the `keyword` function.
  prefs: []
  type: TYPE_NORMAL
- en: The function is created without a `do` and `done` block, as we have used in
    the previous loops. It is the purpose of the curly brackets to define the code
    block boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple function to display aggregated system information is shown in the
    following code. This can be created at the command line and will be resident in
    your shell. This will not persist the logins and will be lost when the shell is
    closed or the function is unset. To allow the function to persist, we need to
    add this to the login script of our user account. The sample code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print the detail of the function similar to the prior instance using
    the `type` command; this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9fabef5-8440-4b12-b440-2edcc07412ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To execute the function, we simply need to type `show_system` and we will see
    the static text and output from the three commands: `uptime`, `lscpu`, and `who`.
    This is, of course, a very simple function but we can start to add more functionality
    by allowing parameters to be passed at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier within this chapter, we referred to functions as scripts within scripts
    and we will still maintain that analogy. Similar to how a script can have input
    parameters, we can create functions that also accept parameters that can make
    their operation less static. Before we work on a script, we can look at a useful
    function in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: One of my pet peeves is overcommented configuration files, especially where
    documentation exists to detail the options available.
  prefs: []
  type: TYPE_NORMAL
- en: The **GNU's Not Unix** (**GNU**) Linux `sed` command can easily edit the file
    for us and remove commented lines and empty lines. We are introducing the stream
    editor, `sed`, here but we will look at it in more detail in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sed` command line that runs the in-place edit will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run out forensics in the command line by breaking it down element by
    element. Let''s take a deeper look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sed -i.bak`: This edits the file and creates a backup with the extension `.bak`.
    The original file will then be accessible as `<filename>.bak`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/^`: This caret character (`^`) means edit the lines that start with what
    after the caret. So the caret matches the beginning of a line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s*`: This means any amount of white space, including no spaces or tabs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#/`: This is a normal `#` sign. So the total expression `^\s*#` means we are
    looking for lines that begin with comment or spaces and a comment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: This is the delete action to remove matching lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`;/^$/d`: The semicolon is used to separate expressions and the second expression
    is similar to the first but this time we are preparing to delete empty lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To move this into a function, we will simply need to think of a great name.
    I like to build verbs into function names; it helps with the uniqueness and identifies
    the purpose of the function. We will create the `clean_file` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As within scripts, we use positional parameters to accept command-line arguments.
    We can replace the hardcoded filename that we used previously with `$1` within
    the function. We will quote this variable to protect against spaces within the
    filename. To test the `clean_file` function, we will make a copy of a system file
    and work with the copy. In this way, we can be sure that no harm comes to any
    system file. We can assure all readers that no system files were harmed during
    the making of this book. The following are the detailed steps we need to follow
    to perform the test on the new function:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `clean_file` function as described
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to your `home` directory using the `cd` command without arguments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the time configuration file to your `home` directory `cp /etc/ntp.conf
    $HOME`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Count the number of lines in the file with the following command: `wc -l $HOME/ntp.conf`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now remove the commented and empty lines with `clean_file $HOME/ntp.conf`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now recount the lines using `wc -l $HOME/ntp.conf`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, check the count the backup of the original file that we created: `wc
    -l $HOME/ntp.conf.bak`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The sequence of commands is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f403ad2f-0f83-49c6-ad61-c45577a8042d.png)'
  prefs: []
  type: TYPE_IMG
- en: We can direct the attention of the function to the required file using the argument
    that was supplied while executing the function. If we need to persist this function,
    then we should add it to a login script. However, if we want to test this within
    a shell script, we can create the following file to do this and practice some
    of the other elements we have learned. We will need to take notice that the functions
    should always be created at the start of the script as they need to be stored
    in memory by the time they are called. Just think that your function needs to
    be unlocked and loaded before you pull the trigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new shell script, `$HOME/bin/clean.sh`, and the execute permission,
    as always, will need to be set. The code of the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have provided two functions within the script. The first, `is_file`, simply
    tests to ensure that the filename we have entered is a regular file. Then we declare
    the `clean_file` function with a little added functionality, displaying the line
    count of the file before and after the operation. We can also see that functions
    can be nested and we call the `is_file` function with `clean_file`.
  prefs: []
  type: TYPE_NORMAL
- en: Without the function definitions, we have only three lines of code at the end
    of the file, which we can see in the example code laid out in the previous code
    block that has been saved as `$HOME/bin/clean.sh`. We first prompt for the filename
    and then run the `clean_file` function, which in turn calls the `is_file` function.
    The simplicity of the main code is important here. The complexity is in the functions,
    as each function can be worked on as a standalone unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now test the script operation, first using a wrong filename, as we can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6df07e9-3208-43a8-9f26-b8cf9e0a4d6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have seen the operation with an incorrect file, we can try again
    using an actual file! We can use the same system file we worked on before. We
    need to first return the files to their original state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With the file now ready, we can execute the script from the `$HOME` directory
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6628efa2-505b-472e-a56a-a836aab2f329.png)'
  prefs: []
  type: TYPE_IMG
- en: Passing arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not all your passed values will be single values; you may need to pass an array
    to the function. Let''s see how to pass an array as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/290b2825-016a-4ce3-9f8c-bb517a0f05f5.png)'
  prefs: []
  type: TYPE_IMG
- en: From the result, you can see that the used array is returned the way it is from
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we used `$@` to get the array inside the function. If you use `$1`,
    it will return the first array element only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b4a129d6-1d1d-4e27-8ffc-b329a6b1b92e.png)'
  prefs: []
  type: TYPE_IMG
- en: Because we used `$1`, it returns only the first array element.
  prefs: []
  type: TYPE_NORMAL
- en: Variable scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, any variable you declare inside a function is a global variable.
    That means this variable can be used outside and inside the function without problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you run this script, it will return `50`, which is the value changed inside
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to declare a variable that is exclusive to the function? This
    is called a local variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare local variables by using the `local` command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the variable is used only inside the function, let''s check
    out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you run this script, it will print `30`, which means that the local version
    of the variable is different than the global version.
  prefs: []
  type: TYPE_NORMAL
- en: Returning values from functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we have statements that are printed on the screen within the function,
    we can see their result. However, lots of times we will want the function to populate
    a variable within the script and not display anything. In this case, we use `return`
    in the function. This is especially important when we are gaining input from users.
    We may prefer the case to translate the input to a known case to make the condition
    testing easier. Embedding the code in a function allows it to be used many times
    within a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we can achieve this by creating the `to_lower`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Stepping through the code, we can begin to understand the operation of this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input="$1"`: This is more for ease than anything else; we assign the first
    input parameter to a named variable input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output=$( echo $input | tr [A-Z] [a-z])`: This is the main engine of the function,
    where the translation from uppercase to lowercase occurs. We pipe the input to
    the `tr` command to convert uppercase to lowercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return $output`: This is how we create the return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One use of this function will be within a script that reads the user''s input
    and simplifies the test to see whether they choose `Q` or `q`. This can be seen
    in the following extract of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recursive function is a function that calls itself from inside itself. This
    function is very useful when you need to call the function to do something again
    from inside of it. The most famous example for that is calculating factorials.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the factorial of 4, you multiply the number by the descending
    numbers. You can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `!` sign means factorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a recursive function that calculates the factorial of any given
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0b71574b-6af6-4bb3-b2e7-7ba140b064f1.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we define the function which is called `calc_factorial` and inside it
    we check if the number equals 1 and if so, the function will return 1 because
    the factorial of 1 equals 1.
  prefs: []
  type: TYPE_NORMAL
- en: Then we decrement the number by one and call the function from inside it and
    that will call the function again.
  prefs: []
  type: TYPE_NORMAL
- en: This will continue to happen until it reaches 1 and then the function will exit.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions in menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](a9bad548-8c76-4e5f-adb1-8cf4e6198c50.xhtml), *Iterating with
    Loops*, we created the `menu.sh` file. Menus are great targets to use functions,
    as the `case` statement is maintained very simply with single-line entries, while
    the complexity can still be stored in each function. We should consider creating
    a function for each menu item. If we copy the previous `$HOME/bin/menu.sh` to
    `$HOME/bin/menu2.sh`, we can improve the functionality. The new menu should look
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we still maintain the simplicity of the `case` statement; however,
    we can develop the script to add in more complexity through the functions. For
    example, when choosing option `b` for the calendar, we now check to see whether
    the `ncal` command is available. If it is, we use `ncal` and use the `-w` option
    to print the week number. We can see this in the following screenshot, where we
    have chosen to display the calendar and install `ncal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3aa8b650-4e05-4b77-bf93-1064c38aae86.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also not be concerned about the *Caps Lock* key as the `to_lower` function
    converts our selection to lowercase. Over time, it would be very easy to add additional
    elements to the functions, knowing that we only affect that single function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are still making progress in leaps and bounds in script writing. I hope these
    ideas stay with you and you find the code examples useful. Functions are very
    important for the ease of maintenance of your scripts and their ultimate functionality.
    The easier the scripts are to maintain, the more likely you are to add improvements
    over time. We can define functions at the command line or within scripts but they
    need to be included in the script before they are used.
  prefs: []
  type: TYPE_NORMAL
- en: The functions themselves are loaded into memory while the script is running,
    but as long as the script is forked and not sourced, they will be released from
    memory once the script is finished. We have touched a little upon `sed` in this
    chapter and we will look more at using the stream editor (`sed`) in the next chapter.
    The `sed` command is very powerful and we can make good use of it within scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the printed value of the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What is the output of the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What is the problem with the following code? And how can you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What is the problem with the following code? And how can you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-8.html](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-8.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/abs/html/functions.html](http://tldp.org/LDP/abs/html/functions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://likegeeks.com/bash-functions/](https://likegeeks.com/bash-functions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
