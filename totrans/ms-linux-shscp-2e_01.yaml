- en: The What and Why of Scripting with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the what and why of bash scripting. In this chapter, you will discover
    the types of shells in Linux and why we chose bash. You will learn what bash is,
    how to write your first bash script, and how to run it. Also, you will see how
    to configure Linux editors, such as vim and nano, in order to type your code.
  prefs: []
  type: TYPE_NORMAL
- en: Like in any other scripting language, variables are the basic blocks of coding.
    You will learn how to declare variables such as integers, strings, and arrays.
    Furthermore, you will learn how to export these variables and extend their scope
    outside the running process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will see how to visually debug your code using Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of Linux shells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is bash scripting?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bash command hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing text editors for scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and executing scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command substitution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need a running Linux box. It doesn't matter which distribution you use,
    since all Linux distributions are shipped nowadays with the bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install Visual Studio Code, which is free from Microsoft. You
    can download it from here: [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can use VS Code as an editor instead of vim and nano; it's up to you.
  prefs: []
  type: TYPE_NORMAL
- en: We prefer to use VS Code because it has a lot of features such as code completion,
    debugging, and many more besides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `bashdb`, which is a required package for the bash debug plugin. If
    you are using a Red Hat-based distribution, you can install it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a Debian-based distribution, you can install it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Install the plugin for VS Code, called bash debug, from [https://marketplace.visualstudio.com/items?itemName=rogalmic.bash-debug](https://marketplace.visualstudio.com/items?itemName=rogalmic.bash-debug).
    This plugin will be used to debug bash scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter01)'
  prefs: []
  type: TYPE_NORMAL
- en: Types of Linux shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, Linux consists of some major parts, such as the kernel, the shell,
    and the GUI interface (Gnome, KDE, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The shell translates your commands and sends them to the system. Most Linux
    distributions are shipped with many shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every shell has its own features, and some of them are very popular among developers
    today. These are some of the popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sh shell**: This is called the Bourne shell, this was developed at AT&T labs
    in the 70s by a guy named Stephen Bourne. This shell offers many features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bash shell**: Also called the Bourne again shell, this is very popular and
    compatible with sh shell scripts, so you can run your sh scripts without changing
    them. We are going to use this shell in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ksh shell**: Also called the Korn shell, this is compatible with sh and bash.
    Ksh offers some enhancements over the Bourne shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Csh and tcsh**: Linux was built using the C language and that drove developers
    at Berkeley University to develop a C-style shell in which the syntax is similar
    to the C language. Tcsh adds some minor enhancements to csh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we know the types of shells and we know that we are going to use bash, so
    what is bash scripting?
  prefs: []
  type: TYPE_NORMAL
- en: What is bash scripting?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea of bash scripting is to execute multiple commands to automate
    a specific job.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might know, you can run multiple commands from the shell by separating
    them with semi colons (`;`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous line is a mini bash script.
  prefs: []
  type: TYPE_NORMAL
- en: The first command runs, followed by the result of the second command.
  prefs: []
  type: TYPE_NORMAL
- en: Every keyword you type in bash scripting is actually a Linux binary (program),
    even the `if` statement, or `else` or `while` loops. All are Linux executables.
  prefs: []
  type: TYPE_NORMAL
- en: You can say that the shell is the glue that binds these commands together.
  prefs: []
  type: TYPE_NORMAL
- en: The bash command hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on the bash shell and when you are sitting comfortably at your
    prompt eagerly waiting to type a command, you will most likely feel that it is
    a simple matter of typing and hitting the *Enter* key. You should know better
    than to think this, as things are never quite as simple as we imagine.
  prefs: []
  type: TYPE_NORMAL
- en: Command type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For example, if we type and enter `ls` to list files, it is reasonable to think
    that we were running the command. It is possible, but we often will be running
    an alias. Aliases exist in memory as a shortcut to commands or commands with options;
    these aliases are used before we even check for the file. Bash''s built-in `type`
    command can come to our aid here. The `type` command will display the type of
    command for a given word entered at the command line. The types of command are
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Alias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell built-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is also representative of the order in which they are searched. As
    we can see, it is not until the very end where we search for the executable file
    `ls`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command demonstrates the simple use type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend this further to display all the matches for the given command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to just type in the output, we can use the `-t` option. This is
    useful when we need to test the command type from within a script and only need
    the type to be returned. This excludes any superfluous information, and thus makes
    it easier for us humans to read. Consider the following command and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output is clear and simple, and is just what a computer or script requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `type` can also be used to identify shell keywords such as `if`,
    and `case`. The following command shows `type` being used against multiple arguments
    and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12fda344-022e-437f-9aaf-c4c200b294e0.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also see that the function definition is printed when we stumble across
    a function when using `type`.
  prefs: []
  type: TYPE_NORMAL
- en: Command PATH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux will check for executables in the `PATH` environment only when the full
    or relative path to the program is supplied. In general, the current directory
    is not searched unless it is in the `PATH`. It is possible to include our current
    directory within the `PATH` by adding the directory to the `PATH` variable. This
    is shown in the following command example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This appends the current directory to the value of the `PATH` variable; each
    item in the `PATH` is separated using a colon. Now your `PATH` has been updated
    to include the current working directory and, each time you change directories,
    the scripts can be executed easily. In general, organizing scripts into a structured
    directory hierarchy is probably a great idea. Consider creating a subdirectory
    called `bin` within your home directory and add the scripts into that folder.
    Adding `$HOME/bin` to your `PATH` variable will enable you to find the scripts
    by name and without the file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command-line list will only create the directory, if it does
    not already exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Although the preceding command-line list is not strictly necessary, it does
    show that scripting in bash is not limited to the actual script, and we can use
    conditional statements and other syntax directly at the command line. From our
    viewpoint, we know that the preceding command will work whether you have the `bin`
    directory or not. The use of the `$HOME` variable ensures that the command will
    work without considering your current filesystem context.
  prefs: []
  type: TYPE_NORMAL
- en: As we work through the book, we will add scripts into the `$HOME/bin` directory
    so that they can be executed regardless of our working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing text editors for scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we will be working on Linux Mint, and this will include
    the creation and editing of the scripts. You, of course, can choose the way you
    wish to edit your scripts and may prefer to make use of a graphical editor, so
    we will show some settings in gedit. We will make one excursion into a Red Hat
    system to show screenshots of gedit in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will use Visual Studio Code as a modern GUI editor to edit and debug
    our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: To help make the command-line editor easier to use, we can enable options and
    we can persist with these options through hidden configuration files. Gedit and
    other GUI editors, and their menus, will provide similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring vim
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Editing the command line is often a must and is part of a developer's everyday
    life. Setting up common options that make life easier in the editor give us the
    reliability and consistency we need, a little like scripting itself. We will set
    some useful options in the vi or vim editor file, `$HOME/.vimrc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options we set are detailed in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set showmode`: Ensures we see when we are in insert mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set nohlsearch`: Does not highlight the words that we have searched for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set autoindent`: We indent our code often; this allows us to return to the
    last indent level rather than the start of a new line on each line break'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set tabstop=4`: Sets a tab to be four spaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set expandtab`: Converts tabs to spaces, which is useful when the file moves
    to other systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syntax on`: Note that this does not use the `set` command and is used to turn
    on syntax highlighting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When these options are set, the `$HOME/.vimrc` file should look similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Configuring nano
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The nano text editor is increasing in importance and it is the default editor
    in many systems. Personally, I don''t like the navigation or the lack of navigation
    features that it has. It can be customized in the same way as vim. This time,
    we will edit the `$HOME/.nanorc` file. Your edited file should look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last line enables syntax highlighting for shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring gedit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphical editors, such as gedit, can be configured using the preferences menu,
    and are pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling tab spacing to be set to 4 spaces and expanding tabs to spaces can
    be done using the Preferences | Editor tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3528cb30-2bce-4f89-b1bb-f35137789872.png)'
  prefs: []
  type: TYPE_IMG
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very useful feature is found on the Preferences | Plugins tab. Here,
    we can enable the Snippets plugin, which can be used to insert code samples. This
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0a634a5-2b76-4d00-8bf2-4e2fb0b1ec56.png)'
  prefs: []
  type: TYPE_IMG
- en: For the rest of the book, we will be working on the command line and in vim;
    feel free to use the editor that you work with best. We have now laid the foundations
    to create good scripts, and, although whitespace, tabs, and spaces in bash scripts
    are not significant, a well-laid-out file with consistent spacing is easy to read.
    When we look at Python later in the book, you will realize that in some languages,
    the whitespace is significant to the language and it is better to adopt good habits
    early on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and executing scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our editors primed and ready, we can now move quickly to creating and executing
    our scripts. If you are reading this book with some prior experience, we will
    warn you that we are going to start with the basics, but we will also include
    looking at positional parameters; feel free to move on at your own pace.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know, it is almost obligatory to begin with a `Hello World` script and
    we will not disappoint as far as this is concerned. We will begin by creating
    a new script, `$HOME/bin/hello1.sh`. The contents of the file should read as in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3d20671-aca4-40f8-9218-ab2bc5ee82cd.png)'
  prefs: []
  type: TYPE_IMG
- en: We hope that you haven't struggled with this too much; it is just three lines,
    after all. We encourage you to run through the examples as you read to really
    help you instill the information with good hands-on practice.
  prefs: []
  type: TYPE_NORMAL
- en: '`#!/bin/bash`: Normally, this is always the first line of the script and is
    known as the shebang. The shebang starts with a comment, but the system still
    uses this line. A comment in a shell script has the `#` symbol. The shebang instructs
    the interpreter of the system to execute the script. We use bash for shell scripts,
    and we may use PHP or Perl for other scripts, as required. If we do not add this
    line, then the commands will be run within the current shell; it may cause issues
    if we run another shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`echo "Hello World"`: The `echo` command will be picked up in a built-in shell
    and can be used to write a standard output, `STDOUT`; this defaults to the screen.
    The information to print is enclosed in double quotes; there will be more on quotes
    later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit 0`: The `exit` command is a built-in shell, and is used to leave or exit
    the script. The `exit` code is supplied as an integer argument. A value of anything
    other than `0` will indicate some type of error in the script''s execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the script saved in our `PATH` environment, it still will not execute
    as a standalone script. We will have to assign and execute permissions for the
    file, as needed. For a simple test, we can run the file directly with bash. The
    following command shows you how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be rewarded with the `Hello World` text being displayed on our screens.
    This is not a long-term solution, as we need to have the script in the `$HOME/bin`
    directory, specifically, to make running the script easy from any location without
    typing the full path. We need to add in the execute permissions as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now be able to run the script simply, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5577185-d395-4690-b989-b6a37d813110.png)'
  prefs: []
  type: TYPE_IMG
- en: Checking the exit status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script is simple, but we still need to know how to make use of the exit
    codes from scripts and other applications. The command-line list that we generated
    earlier, while creating the `$HOME/bin` directory, is a good example of how we
    can use the exit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `command2` is executed only if `command1` fails in
    some way. To be specific, `command2` will run if `command1` exits with a status
    code other than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, in the following extract, we will only execute `command2` if `command1`
    succeeds and issues an exit code of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To read the exit code from our script explicitly, we can view the `$?` variable,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The expected output is `0`, as this is what we have added to the last line of
    the file and there is precious little else that can go wrong to cause the failure
    to reach that line.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring a unique name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now create and execute a simple script, but we need to consider the name
    a little. In this case, `hello1.sh` will be good enough and is unlikely to clash
    with anything else on the system. We should avoid using names that may clash with
    existing aliases, functions, keywords, and building commands, as well as avoiding
    names of programs already in use.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `sh` suffix to the file does not guarantee the name will be unique,
    but, in Linux, where we do not use file extensions, the suffix is part of the
    filename. This helps you to provide a unique identity to your script. Additionally,
    the suffix is used by the editor to help you identify the file for syntax highlighting.
    If you recall, we specifically added the syntax highlighting file `sh.nanorc`
    to the nano text editor. Each of these files is specific to a suffix and subsequent
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring back to the command hierarchy within this chapter, we can use a `type`
    to determine the location and type of file `hello.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands and output can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62a86b69-105e-4e05-af8b-0c4ba91d7224.png)'
  prefs: []
  type: TYPE_IMG
- en: Hello Dolly!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible that we might need a little more substance in the script than
    a simple fixed message. Static message content does have its place, but we can
    make this script much more useful by building in some flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the positional parameters or arguments that
    we can supply to the script and in the next chapter, we will see how we can make
    the script interactive and also prompt the user for input at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Running the script with arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can run the script with arguments; after all, it''s a free world and Linux
    promotes your freedom to do what you want to do with the code. However, if the
    script does not make use of the arguments, then they will be silently ignored.
    The following command shows the script running with a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will still run and will not produce an error. The output will not
    change either and will print `Hello World`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Argument Identifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `$0` | The name of the script itself, which is often used in usage statements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$1` | A positional argument, which is the first argument passed to the script.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `${10}` | Where two or more digits are needed to represent the argument position.
    Brace brackets are used to delimit the variable name from any other content. Single
    value digits are expected. |'
  prefs: []
  type: TYPE_TB
- en: '| `$#` | The argument count is especially useful when we need to set the amount
    of arguments needed for correct script execution. |'
  prefs: []
  type: TYPE_TB
- en: '| `$*` | Refers to all arguments. |'
  prefs: []
  type: TYPE_TB
- en: 'For the script to make use of the argument, we can change its content a little.
    Let''s first copy the script, add in the execute permissions, and then edit the
    new `hello2.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to edit the `hello2.sh` file to make use of the argument as it is passed
    at the command line. The following screenshot shows the simplest use of command-line
    arguments, now allowing us to have a custom message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ed6a81a-5951-4afa-a836-ca3d223476c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the script now; we can provide an argument as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should now say `Hello fred`. If we do not provide an argument, then
    the variable will be empty and will just print `Hello`. You can refer to the following
    screenshot to see the execution argument and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bb5ff42-cddd-4513-a670-6e6b43423c75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we adjust the script to use `$*`, all the arguments will print. We will
    see `Hello` and then a list of all the supplied arguments. Edit the script and
    replace the `echo` line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute the script with the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And this will result in the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/612e1eac-7009-47eb-ac8a-b7b86e308f8a.png)'
  prefs: []
  type: TYPE_IMG
- en: If we want to print `Hello <name>`, with each name on a separate line, we will
    need to wait a little until we cover looping structures. A `for` loop is a good
    way to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of correct quotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used a simple double-quoting mechanism to encase the strings
    that we want to use with echo.
  prefs: []
  type: TYPE_NORMAL
- en: In the first script, it does not matter if we use single or double quotes. `echo
    "Hello World"` will be exactly the same as `echo 'Hello World'`.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not the case in the second script, so it is very important
    to understand the quoting mechanisms available in bash.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, using double quotes in `echo "Hello $1"` will result in `Hello
    fred` or whatever the supplied value is. Whereas, if we use single quotes in `echo
    'Hello $1'`, the printed output on the screen will be `Hello $1`; that is, we
    see the variable name and not its value.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the quotes is to protect special characters, such as a space between
    the two words; both quotes protect the space from being misinterpreted. The space
    is normally read as a default field, separated by the shell. In other words, all
    characters are read by the shell as literals with no special meaning. This has
    the knock-on effect of the `$` symbol printing its literal format rather than
    allowing bash to expand its value. The bash shell is prevented from expanding
    the variable's value as it is protected by the single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the double quote comes to our rescue. The double quote will protect
    all the characters except the `$`, allowing bash to expand the stored value.
  prefs: []
  type: TYPE_NORMAL
- en: If we ever need to use a literal `$` within the quoted string, along with variables
    that need to be expanded, we can use double quotes, but escape the desired `$`
    with the backslash (`\`). For example, `echo "$USER earns \$4"` would print as
    `Fred earns $4` if the current user were Fred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following examples at the command line using all quoting mechanisms.
    Feel free to up your hourly rate as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ca3f282-07b0-4866-aeba-a8ae1f28b832.png)'
  prefs: []
  type: TYPE_IMG
- en: Printing the script name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `$0` variable represents the script name, and this is often used in usage
    statements. As we are not yet looking at conditional statements, we will get the
    script name printed above the displayed name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit your script so that it reads like the following complete code block for
    `$HOME/bin/hello2.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/225c3633-3e9e-42b9-8484-18d5832db6c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we prefer not to print the path and only want the name of the script to
    show, we can use the `basename` command, which extracts the name from the path.
    Adjust the script so that the second line now reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `$(....)` syntax is used to evaluate the output of the inner command. We
    first run `basename $0` and feed the result into an unnamed variable represented
    by the `$`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new output will appear as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/011b53df-581f-4da2-aef6-c6bb8916b43d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible to achieve the same results using back quotes; this is less
    easy to read, but we have mentioned this as you might need to understand and modify
    the scripts that have been written by others. The alternative to the `$(....)`
    syntax is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the characters used are back quotes and *NOT* single quotes.
    On UK and US keyboards, these are found in the top-left corner next to the number
    1 key.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like in any programming language, you can declare variables in bash scripts.
    So, what are these variables and what are the benefits of using them?
  prefs: []
  type: TYPE_NORMAL
- en: Well, a variable is like a placeholder where you store some value for later
    use in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of variables you can declare in your script:'
  prefs: []
  type: TYPE_NORMAL
- en: User-defined variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To declare a variable, just type the name you want and set its value using the
    equals sign (`=`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, to print the variable's value, you should use the dollar sign
    (`$`) before it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are **no spaces** between the variable name and the equals sign,
    or between the equals sign and the value.
  prefs: []
  type: TYPE_NORMAL
- en: If you forget and type a space in between, the shell will treat the variable
    as if it were a command, and, since there is no such command, it will show an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following examples are incorrect declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Another useful type of user-defined variable is the array. An array can hold
    multiple values. So, if you have tens of values you want to use, you should use
    arrays instead of filling your script with variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare an array, just enclose its elements between brackets, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To access a specific array element, you can specify its index like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The index is zero based.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the array elements, you can use an asterisk, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a specific element from the array, you can use the `unset` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used variables that we didn't define, such as `$BASH_VERSION`,
    `$HOME`, `$PATH`, and `$USER`. You might wonder, as we didn't declare these variables,
    where did they come from?
  prefs: []
  type: TYPE_NORMAL
- en: These variables are defined by the shell for your use and they are called environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: There are many environment variables. If you want to list them, you can use
    the `printenv` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can print a specific environment variable by specifying it to the
    `printenv` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can use any of these variables in our bash scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all environment variables are written in capital letters, so you can
    declare your variables as lower case to make it easy to differentiate your variables
    from environment variables. This is not required, but is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Variable scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have declared your variable, it will be available for use in your entire
    bash script without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume this scenario: you have divided your code into two files and
    you will execute one of them from inside the other, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The second script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Suppose that you want to use the `name` variable in the second script. If you
    try to print it, nothing will show up; this is because a variable's scope is only
    limited to the process that creates it.
  prefs: []
  type: TYPE_NORMAL
- en: To use the `name` variable, you can export it using the `export` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our code will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now if you run the first script, it will print the name that came from the first
    script file.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the second process or `script2.sh` only makes a copy of the
    variable and never touches the original one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove this, try to change that variable from the second script and try to
    access that variable value from the first script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The second script will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you run the first script, it will print the modified `name` from the second
    script and then it will print the original `name` from the first script. So, the
    original variable remains as it is.
  prefs: []
  type: TYPE_NORMAL
- en: Command substitution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to declare variables. These variables can hold integers,
    strings, arrays, or floats, as we have seen, but this is not everything.
  prefs: []
  type: TYPE_NORMAL
- en: A command substitution means storing the output of a command execution in a
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: As you might know, the `pwd` command prints the current working directory. So,
    we will see how to store its value in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to perform a command substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the backtick character (`'`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the dollar sign format, like this: `$()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the first method, we just surround the command between two backticks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second way is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The output coming from commands can be further processed and actions can be
    made based on that output.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the scripts as simple as we have seen so far, there is little that can
    go wrong or need debugging. As the script grows and decision paths are included
    with conditional statements, we may need to use some level of debugging to analyze
    the scripts' progress better.
  prefs: []
  type: TYPE_NORMAL
- en: Bash provides two options for us, `-v` and `-x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to look at the verbose output from our script and the detailed information
    about the way the script is evaluated line by line, we can use the `-v` option.
    This can be within the shebang, but it is often easier to run the script directly
    with bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is especially useful in this example as we can see how each element of
    the embedded `basename` command is processed. The first step is removing the quotes
    and then the parentheses. Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e6b913f-2cd8-49b5-af54-4b287f65b0d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `-x` option, which displays the commands as they are executed, is more
    commonly used. It''s useful to know the decision branch that has been chosen by
    the script. The following shows this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We again see that the `basename` is evaluated first, but we do not see the
    more detailed steps involved in running that command. The screenshot that follows
    captures the command and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc5c60c6-5587-46d7-ad8f-c3a513ad0e11.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous method might be hard for beginners or people who have a programming
    background in which they debugged their code visually.
  prefs: []
  type: TYPE_NORMAL
- en: Another modern way of debugging shell scripts is by using Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: There is a plugin called **bash debug** that enables you to debug bash scripts
    visually, as is the case for any other programming language.
  prefs: []
  type: TYPE_NORMAL
- en: You can step into, step over, add watches, and do all the other usual debugging
    stuff you know.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the plugin, from the File menu, open your `shell-scripts`
    folder. Then you can configure the debugging process by pressing *Ctrl* + *Shift*
    + *P* and typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open an empty file; type in the following configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a debug configuration named `Packt Bash-Debug`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f43d6a8d-4e19-41fa-a3a7-269e73f4c5f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now insert a breakpoint and press *F5*, or start debugging from the Debug menu;
    it will show you the list of `.sh` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31f4f7c8-67f5-4b5e-87a9-9597df9a1566.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the one you want to debug, and set a breakpoint on any line to test
    it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbe3ea88-c551-4597-ac6d-21de73704fa0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can add watches to watch variables'' values while stepping over your lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea379cba-8879-47ba-9a8c-223e1473ddee.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that your script **MUST** start with the bash shebang, `#!/bin/bash`.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can enjoy the visual method of debugging. Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This marks the end of this chapter and you have no doubt found this useful.
    Especially for those making a start with bash scripting, this chapter will have
    established a firm foundation on which you can build your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: We began by ensuring that bash is secure and not susceptible to shell-shock
    from embedded functions. With bash secured, we considered the execution hierarchy
    where aliases, functions, and so on are checked before the command; knowing this
    can help us plan a good naming structure and a path to locate the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Then we went on to illustrate the types of Linux shells and we found out what
    bash scripting is.
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we were writing simple scripts with static content, but we saw how easy
    it was to add flexibility using arguments. The exit code from the script can be
    read with the `$?` variable and we can create a command-line list using `||` and
    `&&`, which depends on the success or failure of the preceding command in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Then we saw how to declare variables and how to use environment variables. We
    identified the variables' scope and saw how to export them to another process.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we saw how to store commands' output in variables, which is called command
    substitution.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter by looking at debugging the script using bash
    options and VS Code. It's not really required when the script is trivial, but
    it will be useful later when complexity is added.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create interactive scripts that read the user's
    input during script execution.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the problem with the following code? And how do we fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What is the result of the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: What is the problem with the following code? And how do we fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: What is the value of the b and c variables in the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/abs/html/varassignment.html](http://tldp.org/LDP/abs/html/varassignment.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/abs/html/declareref.html](http://tldp.org/LDP/abs/html/declareref.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
