- en: The What and Why of Scripting with Bash
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bash 脚本的目的与原因
- en: Welcome to the what and why of bash scripting. In this chapter, you will discover
    the types of shells in Linux and why we chose bash. You will learn what bash is,
    how to write your first bash script, and how to run it. Also, you will see how
    to configure Linux editors, such as vim and nano, in order to type your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 bash 脚本的介绍与原因。在本章中，你将了解 Linux 中的各种 shell 类型，以及为什么我们选择了 bash。你将学习什么是 bash，如何编写你的第一个
    bash 脚本，并且如何运行它。同时，你将看到如何配置 Linux 编辑器，如 vim 和 nano，以便编写代码。
- en: Like in any other scripting language, variables are the basic blocks of coding.
    You will learn how to declare variables such as integers, strings, and arrays.
    Furthermore, you will learn how to export these variables and extend their scope
    outside the running process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他脚本语言一样，变量是编码的基本单元。你将学习如何声明变量，如整数、字符串和数组。此外，你将学习如何导出这些变量，并扩展它们在运行进程之外的作用范围。
- en: Finally, you will see how to visually debug your code using Visual Studio Code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学会如何使用 Visual Studio Code 进行可视化调试你的代码。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Types of Linux shells
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux shell 的类型
- en: What is bash scripting?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 bash 脚本？
- en: The bash command hierarchy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bash 命令层次结构
- en: Preparing text editors for scripting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备文本编辑器以进行脚本编写
- en: Creating and executing scripts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和执行脚本
- en: Declaring variables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明变量
- en: Variable scope
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量作用域
- en: Command substitution
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令替换
- en: Debugging your scripts
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试你的脚本
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You'll need a running Linux box. It doesn't matter which distribution you use,
    since all Linux distributions are shipped nowadays with the bash shell.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一台正在运行的 Linux 计算机。使用哪个发行版都无所谓，因为如今所有的 Linux 发行版都预装了 bash shell。
- en: 'Download and install Visual Studio Code, which is free from Microsoft. You
    can download it from here: [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装 Visual Studio Code，这是 Microsoft 提供的免费软件。你可以在此下载：[https://code.visualstudio.com/](https://code.visualstudio.com/)。
- en: You can use VS Code as an editor instead of vim and nano; it's up to you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 VS Code 作为编辑器，而不是 vim 和 nano；这取决于你。
- en: We prefer to use VS Code because it has a lot of features such as code completion,
    debugging, and many more besides.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更倾向于使用 VS Code，因为它具有许多功能，如代码自动补全、调试等。
- en: 'Install `bashdb`, which is a required package for the bash debug plugin. If
    you are using a Red Hat-based distribution, you can install it like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`bashdb`，这是 bash 调试插件所需的包。如果你使用的是基于 Red Hat 的发行版，可以按照以下方式安装：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are using a Debian-based distribution, you can install it like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是基于 Debian 的发行版，可以按以下方式安装：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Install the plugin for VS Code, called bash debug, from [https://marketplace.visualstudio.com/items?itemName=rogalmic.bash-debug](https://marketplace.visualstudio.com/items?itemName=rogalmic.bash-debug).
    This plugin will be used to debug bash scripts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://marketplace.visualstudio.com/items?itemName=rogalmic.bash-debug](https://marketplace.visualstudio.com/items?itemName=rogalmic.bash-debug)
    安装 VS Code 的插件，名为 bash debug。这个插件将用于调试 bash 脚本。
- en: 'The source code for this chapter can be downloaded here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在此下载：
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter01)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter01)'
- en: Types of Linux shells
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux shell 的类型
- en: As you know, Linux consists of some major parts, such as the kernel, the shell,
    and the GUI interface (Gnome, KDE, and so on).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的，Linux 由一些主要部分组成，比如内核、shell 和 GUI 界面（如 Gnome、KDE 等）。
- en: The shell translates your commands and sends them to the system. Most Linux
    distributions are shipped with many shells.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 将你的命令翻译并发送到系统。大多数 Linux 发行版都预装了多种 shell。
- en: 'Every shell has its own features, and some of them are very popular among developers
    today. These are some of the popular ones:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 shell 都有自己的特点，其中一些在今天的开发者中非常受欢迎。以下是一些受欢迎的 shell 类型：
- en: '**Sh shell**: This is called the Bourne shell, this was developed at AT&T labs
    in the 70s by a guy named Stephen Bourne. This shell offers many features.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sh shell**：这就是所谓的 Bourne shell，最初由 Stephen Bourne 在 70 年代的 AT&T 实验室开发。这个
    shell 提供了许多功能。'
- en: '**Bash shell**: Also called the Bourne again shell, this is very popular and
    compatible with sh shell scripts, so you can run your sh scripts without changing
    them. We are going to use this shell in this book.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bash shell**：也叫做Bourne Again Shell，这是非常流行的，并且与sh脚本兼容，因此你可以在不修改的情况下运行sh脚本。我们将在本书中使用这个shell。'
- en: '**Ksh shell**: Also called the Korn shell, this is compatible with sh and bash.
    Ksh offers some enhancements over the Bourne shell.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ksh shell**：也叫做Korn shell，它与sh和bash兼容。Ksh在Bourne shell的基础上提供了一些增强功能。'
- en: '**Csh and tcsh**: Linux was built using the C language and that drove developers
    at Berkeley University to develop a C-style shell in which the syntax is similar
    to the C language. Tcsh adds some minor enhancements to csh.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Csh和tcsh**：Linux是使用C语言构建的，这推动了伯克利大学的开发人员开发了一种C风格的shell，其语法与C语言类似。Tcsh对csh进行了少量增强。'
- en: Now we know the types of shells and we know that we are going to use bash, so
    what is bash scripting?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了shell的类型，并且知道我们将使用bash，那么什么是bash脚本呢？
- en: What is bash scripting?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是bash脚本？
- en: The basic idea of bash scripting is to execute multiple commands to automate
    a specific job.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: bash脚本的基本思路是执行多个命令，以自动化特定的任务。
- en: 'As you might know, you can run multiple commands from the shell by separating
    them with semi colons (`;`):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的，你可以通过使用分号（`;`）分隔多个命令，从shell中运行多个命令：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous line is a mini bash script.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行是一个迷你bash脚本。
- en: The first command runs, followed by the result of the second command.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令运行后，紧接着是第二个命令的结果。
- en: Every keyword you type in bash scripting is actually a Linux binary (program),
    even the `if` statement, or `else` or `while` loops. All are Linux executables.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你在bash脚本中输入的每一个关键字实际上都是一个Linux二进制程序（程序），即使是`if`语句，或`else`或`while`循环。所有这些都是Linux可执行文件。
- en: You can say that the shell is the glue that binds these commands together.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说，shell是将这些命令连接在一起的“胶水”。
- en: The bash command hierarchy
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bash命令层级
- en: When working on the bash shell and when you are sitting comfortably at your
    prompt eagerly waiting to type a command, you will most likely feel that it is
    a simple matter of typing and hitting the *Enter* key. You should know better
    than to think this, as things are never quite as simple as we imagine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在bash shell中工作，并且坐在命令提示符前，急切地等待输入命令时，你很可能会觉得这只是输入命令并按下*Enter*键的简单问题。你应该知道这并非如此，因为事情从来都不会像我们想象的那么简单。
- en: Command type
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令类型
- en: 'For example, if we type and enter `ls` to list files, it is reasonable to think
    that we were running the command. It is possible, but we often will be running
    an alias. Aliases exist in memory as a shortcut to commands or commands with options;
    these aliases are used before we even check for the file. Bash''s built-in `type`
    command can come to our aid here. The `type` command will display the type of
    command for a given word entered at the command line. The types of command are
    listed as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们输入并执行`ls`列出文件，合理的想法是我们正在运行该命令。这是可能的，但我们经常会运行一个别名。别名存在于内存中，是对命令或带选项命令的快捷方式；这些别名在我们检查文件之前就会被使用。bash的内建`type`命令可以在这里帮助我们。`type`命令会显示在命令行中输入的单词对应的命令类型。命令类型如下所示：
- en: Alias
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名
- en: Function
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Shell built-in
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell内建命令
- en: Keyword
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字
- en: File
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: This list is also representative of the order in which they are searched. As
    we can see, it is not until the very end where we search for the executable file
    `ls`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表也代表了它们被搜索的顺序。正如我们所看到的，直到最后才会搜索可执行文件`ls`。
- en: 'The following command demonstrates the simple use type:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示了`type`的简单用法：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can extend this further to display all the matches for the given command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步扩展，显示给定命令的所有匹配项：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we need to just type in the output, we can use the `-t` option. This is
    useful when we need to test the command type from within a script and only need
    the type to be returned. This excludes any superfluous information, and thus makes
    it easier for us humans to read. Consider the following command and output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要输出结果，可以使用`-t`选项。当我们需要从脚本内部测试命令类型并且只需要返回类型时，这个选项非常有用。它排除了任何多余的信息，从而使我们更容易阅读。考虑以下命令和输出：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output is clear and simple, and is just what a computer or script requires.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清晰简洁，正是计算机或脚本所需要的。
- en: 'The built-in `type` can also be used to identify shell keywords such as `if`,
    and `case`. The following command shows `type` being used against multiple arguments
    and types:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 内建的`type`命令也可以用来识别shell关键字，如`if`和`case`。以下命令展示了`type`在多个参数和类型中的使用：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the command is shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出在以下屏幕截图中显示：
- en: '![](img/12fda344-022e-437f-9aaf-c4c200b294e0.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12fda344-022e-437f-9aaf-c4c200b294e0.png)'
- en: You can also see that the function definition is printed when we stumble across
    a function when using `type`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到，当我们在使用`type`时遇到函数，函数定义会被打印出来。
- en: Command PATH
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令路径
- en: 'Linux will check for executables in the `PATH` environment only when the full
    or relative path to the program is supplied. In general, the current directory
    is not searched unless it is in the `PATH`. It is possible to include our current
    directory within the `PATH` by adding the directory to the `PATH` variable. This
    is shown in the following command example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 只有在提供了程序的完整路径或相对路径时，才会在`PATH`环境变量中查找可执行文件。一般情况下，当前目录不会被搜索，除非它被包含在`PATH`中。我们可以通过将当前目录添加到`PATH`变量中，从而使当前目录包含在`PATH`内。这在以下命令示例中有所展示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This appends the current directory to the value of the `PATH` variable; each
    item in the `PATH` is separated using a colon. Now your `PATH` has been updated
    to include the current working directory and, each time you change directories,
    the scripts can be executed easily. In general, organizing scripts into a structured
    directory hierarchy is probably a great idea. Consider creating a subdirectory
    called `bin` within your home directory and add the scripts into that folder.
    Adding `$HOME/bin` to your `PATH` variable will enable you to find the scripts
    by name and without the file path.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将当前目录添加到`PATH`变量的值中；`PATH`中的每个项目用冒号分隔。现在你的`PATH`已经更新，包含了当前工作目录，每次你更改目录时，脚本都可以轻松执行。一般来说，将脚本组织到一个有结构的目录层级中可能是个不错的主意。考虑在你的主目录下创建一个名为`bin`的子目录，并将脚本放入其中。将`$HOME/bin`添加到`PATH`变量中将使你能够通过名称而不需要文件路径找到这些脚本。
- en: 'The following command-line list will only create the directory, if it does
    not already exist:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令行列表将只会在目录不存在时创建该目录：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although the preceding command-line list is not strictly necessary, it does
    show that scripting in bash is not limited to the actual script, and we can use
    conditional statements and other syntax directly at the command line. From our
    viewpoint, we know that the preceding command will work whether you have the `bin`
    directory or not. The use of the `$HOME` variable ensures that the command will
    work without considering your current filesystem context.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的命令行列表严格来说不是必需的，但它展示了bash脚本编程不仅仅限于实际的脚本文件，我们可以直接在命令行中使用条件语句和其他语法。从我们的角度来看，无论你是否有`bin`目录，前面的命令都会生效。使用`$HOME`变量确保命令在不考虑当前文件系统上下文的情况下也能正常工作。
- en: As we work through the book, we will add scripts into the `$HOME/bin` directory
    so that they can be executed regardless of our working directory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们会将脚本添加到`$HOME/bin`目录，这样它们就可以在任何工作目录下执行。
- en: Preparing text editors for scripting
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为脚本编程准备文本编辑器
- en: Throughout the book, we will be working on Linux Mint, and this will include
    the creation and editing of the scripts. You, of course, can choose the way you
    wish to edit your scripts and may prefer to make use of a graphical editor, so
    we will show some settings in gedit. We will make one excursion into a Red Hat
    system to show screenshots of gedit in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用Linux Mint，并且包括脚本的创建和编辑。当然，你可以选择任何你希望的脚本编辑方式，可能会更喜欢使用图形化编辑器，所以我们会在gedit中展示一些设置。我们将在本章中稍作偏离，进入Red
    Hat系统，以展示gedit的屏幕截图。
- en: Also, we will use Visual Studio Code as a modern GUI editor to edit and debug
    our scripts.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用Visual Studio Code作为现代GUI编辑器来编辑和调试我们的脚本。
- en: To help make the command-line editor easier to use, we can enable options and
    we can persist with these options through hidden configuration files. Gedit and
    other GUI editors, and their menus, will provide similar functionality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让命令行编辑器更加易用，我们可以启用选项，并通过隐藏的配置文件保持这些选项。Gedit和其他GUI编辑器及其菜单也会提供类似的功能。
- en: Configuring vim
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置vim
- en: Editing the command line is often a must and is part of a developer's everyday
    life. Setting up common options that make life easier in the editor give us the
    reliability and consistency we need, a little like scripting itself. We will set
    some useful options in the vi or vim editor file, `$HOME/.vimrc`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑命令行通常是必须的，它是开发者日常工作的一部分。在编辑器中设置一些常用选项，使得工作更加高效，为我们提供了所需的可靠性和一致性，这有点像脚本编程本身。我们将会在vi或vim编辑器文件`$HOME/.vimrc`中设置一些有用的选项。
- en: 'The options we set are detailed in the following list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的选项详细信息如下：
- en: '`set showmode`: Ensures we see when we are in insert mode'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set showmode`：确保我们看到何时处于插入模式'
- en: '`set nohlsearch`: Does not highlight the words that we have searched for'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set nohlsearch`：不突出显示我们搜索过的单词'
- en: '`set autoindent`: We indent our code often; this allows us to return to the
    last indent level rather than the start of a new line on each line break'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set autoindent`：我们经常缩进代码；这使我们可以在每次换行时返回到上一个缩进级别，而不是从新的一行开始。'
- en: '`set tabstop=4`: Sets a tab to be four spaces'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set tabstop=4`：将制表符设置为四个空格'
- en: '`set expandtab`: Converts tabs to spaces, which is useful when the file moves
    to other systems'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set expandtab`：将制表符转换为空格，这在文件移到其他系统时很有用'
- en: '`syntax on`: Note that this does not use the `set` command and is used to turn
    on syntax highlighting'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syntax on`：注意，这不使用 `set` 命令，而是用于启用语法高亮'
- en: 'When these options are set, the `$HOME/.vimrc` file should look similar to
    this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些选项设置好后，`$HOME/.vimrc` 文件应类似于以下内容：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Configuring nano
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 nano
- en: 'The nano text editor is increasing in importance and it is the default editor
    in many systems. Personally, I don''t like the navigation or the lack of navigation
    features that it has. It can be customized in the same way as vim. This time,
    we will edit the `$HOME/.nanorc` file. Your edited file should look something
    like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: nano 文本编辑器越来越重要，它是许多系统的默认编辑器。就个人而言，我不喜欢它的导航功能，或者说缺乏导航功能。它可以像 vim 一样进行自定义。这一次，我们将编辑
    `$HOME/.nanorc` 文件。你编辑后的文件应类似于以下内容：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last line enables syntax highlighting for shell scripts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行启用 shell 脚本的语法高亮。
- en: Configuring gedit
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 gedit
- en: Graphical editors, such as gedit, can be configured using the preferences menu,
    and are pretty straightforward.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图形编辑器，例如 gedit，可以通过首选项菜单进行配置，并且操作非常简单。
- en: 'Enabling tab spacing to be set to 4 spaces and expanding tabs to spaces can
    be done using the Preferences | Editor tab, as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 启用将制表符间距设置为 4 个空格并将制表符转换为空格，可以通过首选项 | 编辑器标签完成，具体如以下截图所示：
- en: '![](img/3528cb30-2bce-4f89-b1bb-f35137789872.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3528cb30-2bce-4f89-b1bb-f35137789872.png)'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载示例代码文件，适用于你购买的所有
    Packt Publishing 图书。如果你是在其他地方购买此书，你可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，将文件直接通过电子邮件发送给你。
- en: 'Another very useful feature is found on the Preferences | Plugins tab. Here,
    we can enable the Snippets plugin, which can be used to insert code samples. This
    is shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能可以在首选项 | 插件标签中找到。在这里，我们可以启用 Snippets 插件，用于插入代码示例。以下截图展示了这一功能：
- en: '![](img/a0a634a5-2b76-4d00-8bf2-4e2fb0b1ec56.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0a634a5-2b76-4d00-8bf2-4e2fb0b1ec56.png)'
- en: For the rest of the book, we will be working on the command line and in vim;
    feel free to use the editor that you work with best. We have now laid the foundations
    to create good scripts, and, although whitespace, tabs, and spaces in bash scripts
    are not significant, a well-laid-out file with consistent spacing is easy to read.
    When we look at Python later in the book, you will realize that in some languages,
    the whitespace is significant to the language and it is better to adopt good habits
    early on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将使用命令行和 vim 进行操作；你可以随意使用最适合你的编辑器。我们现在已经为创建良好的脚本奠定了基础，尽管在 bash 脚本中空格、制表符和空白字符并不重要，但布局清晰且间距一致的文件更易于阅读。稍后我们将学习
    Python 时，你会意识到在一些编程语言中，空白字符对语言有意义，因此最好从一开始就养成良好的习惯。
- en: Creating and executing scripts
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和执行脚本
- en: With our editors primed and ready, we can now move quickly to creating and executing
    our scripts. If you are reading this book with some prior experience, we will
    warn you that we are going to start with the basics, but we will also include
    looking at positional parameters; feel free to move on at your own pace.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好编辑器后，我们现在可以迅速开始创建和执行脚本。如果你是带着一定经验来阅读这本书的，我们会提醒你我们将从基础开始，但也会涉及位置参数的内容；你可以按自己的节奏继续阅读。
- en: Hello World!
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: 'As you know, it is almost obligatory to begin with a `Hello World` script and
    we will not disappoint as far as this is concerned. We will begin by creating
    a new script, `$HOME/bin/hello1.sh`. The contents of the file should read as in
    the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，几乎每个脚本都从 `Hello World` 开始，我们也不会让你失望。我们将首先创建一个新的脚本，`$HOME/bin/hello1.sh`。该文件的内容应如下所示：
- en: '![](img/e3d20671-aca4-40f8-9218-ab2bc5ee82cd.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3d20671-aca4-40f8-9218-ab2bc5ee82cd.png)'
- en: We hope that you haven't struggled with this too much; it is just three lines,
    after all. We encourage you to run through the examples as you read to really
    help you instill the information with good hands-on practice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你没有为此感到太困难；毕竟只有三行。我们鼓励你在阅读时运行这些示例，真正通过动手实践帮助你掌握信息。
- en: '`#!/bin/bash`: Normally, this is always the first line of the script and is
    known as the shebang. The shebang starts with a comment, but the system still
    uses this line. A comment in a shell script has the `#` symbol. The shebang instructs
    the interpreter of the system to execute the script. We use bash for shell scripts,
    and we may use PHP or Perl for other scripts, as required. If we do not add this
    line, then the commands will be run within the current shell; it may cause issues
    if we run another shell.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#!/bin/bash`：通常这是脚本的第一行，称为 shebang。Shebang 以注释开始，但系统仍然会使用这一行。shell 脚本中的注释以
    `#` 符号开始。Shebang 告诉系统的解释器执行这个脚本。我们使用 bash 来编写 shell 脚本，必要时也可以使用 PHP 或 Perl 来编写其他脚本。如果我们没有添加这一行，命令将在当前
    shell 中运行；如果我们启动另一个 shell，可能会导致问题。'
- en: '`echo "Hello World"`: The `echo` command will be picked up in a built-in shell
    and can be used to write a standard output, `STDOUT`; this defaults to the screen.
    The information to print is enclosed in double quotes; there will be more on quotes
    later.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`echo "Hello World"`：`echo` 命令将在内置的 shell 中执行，并用于写入标准输出 `STDOUT`；默认情况下输出到屏幕。要打印的信息被双引号括起来，稍后会详细讨论引号。'
- en: '`exit 0`: The `exit` command is a built-in shell, and is used to leave or exit
    the script. The `exit` code is supplied as an integer argument. A value of anything
    other than `0` will indicate some type of error in the script''s execution.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit 0`：`exit` 命令是内置的 shell 命令，用于退出或离开脚本。`exit` 代码作为整数参数传递。任何不为 `0` 的值都表示脚本执行时出现了某种错误。'
- en: Executing the script
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行脚本
- en: 'With the script saved in our `PATH` environment, it still will not execute
    as a standalone script. We will have to assign and execute permissions for the
    file, as needed. For a simple test, we can run the file directly with bash. The
    following command shows you how to do this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 即便脚本保存在我们的 `PATH` 环境变量中，它仍然无法作为独立脚本执行。我们需要为文件分配并执行相应的权限。对于一个简单的测试，我们可以直接用 bash
    运行文件。以下命令演示了如何执行：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We should be rewarded with the `Hello World` text being displayed on our screens.
    This is not a long-term solution, as we need to have the script in the `$HOME/bin`
    directory, specifically, to make running the script easy from any location without
    typing the full path. We need to add in the execute permissions as shown in the
    following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能看到 `Hello World` 文本显示在屏幕上。这并不是一个长期的解决方案，因为我们需要将脚本放在 `$HOME/bin` 目录中，特别是为了方便在任何位置运行脚本而无需输入完整路径。我们需要为该文件添加执行权限，代码如下所示：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We should now be able to run the script simply, as shown in the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够简单地运行脚本，如下图所示：
- en: '![](img/c5577185-d395-4690-b989-b6a37d813110.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5577185-d395-4690-b989-b6a37d813110.png)'
- en: Checking the exit status
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查退出状态
- en: 'This script is simple, but we still need to know how to make use of the exit
    codes from scripts and other applications. The command-line list that we generated
    earlier, while creating the `$HOME/bin` directory, is a good example of how we
    can use the exit code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本很简单，但我们仍然需要了解如何利用脚本和其他应用程序的退出码。我们之前生成的命令行列表，在创建 `$HOME/bin` 目录时，就是一个很好的例子，说明了如何使用退出码：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, `command2` is executed only if `command1` fails in
    some way. To be specific, `command2` will run if `command1` exits with a status
    code other than `0`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，只有在 `command1` 以某种方式失败时，才会执行 `command2`。具体来说，如果 `command1` 退出状态码不是 `0`，则会执行
    `command2`。
- en: 'Similarly, in the following extract, we will only execute `command2` if `command1`
    succeeds and issues an exit code of `0`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在以下示例中，只有在 `command1` 成功并返回 `0` 的退出码时，才会执行 `command2`：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To read the exit code from our script explicitly, we can view the `$?` variable,
    as shown in the following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要显式地读取脚本的退出代码，我们可以查看`$?`变量，如下例所示：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The expected output is `0`, as this is what we have added to the last line of
    the file and there is precious little else that can go wrong to cause the failure
    to reach that line.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是`0`，因为这是我们在文件的最后一行添加的内容，几乎没有其他情况能导致无法到达该行。
- en: Ensuring a unique name
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保名称唯一
- en: We can now create and execute a simple script, but we need to consider the name
    a little. In this case, `hello1.sh` will be good enough and is unlikely to clash
    with anything else on the system. We should avoid using names that may clash with
    existing aliases, functions, keywords, and building commands, as well as avoiding
    names of programs already in use.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建并执行一个简单的脚本，但需要稍微考虑一下名称。在这种情况下，`hello1.sh`就足够好，而且不太可能与系统中的其他内容冲突。我们应该避免使用可能与现有别名、函数、关键字和构建命令发生冲突的名称，也要避免使用已经在系统中使用的程序名称。
- en: Adding the `sh` suffix to the file does not guarantee the name will be unique,
    but, in Linux, where we do not use file extensions, the suffix is part of the
    filename. This helps you to provide a unique identity to your script. Additionally,
    the suffix is used by the editor to help you identify the file for syntax highlighting.
    If you recall, we specifically added the syntax highlighting file `sh.nanorc`
    to the nano text editor. Each of these files is specific to a suffix and subsequent
    language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 给文件添加`sh`后缀并不能保证名称是唯一的，但在 Linux 中，我们不使用文件扩展名，后缀是文件名的一部分。这有助于为脚本提供唯一的身份标识。此外，编辑器还使用后缀帮助你识别文件并进行语法高亮。如果你记得，我们特意将语法高亮文件`sh.nanorc`添加到nano文本编辑器中。这些文件都与后缀和随之而来的语言相关。
- en: 'Referring back to the command hierarchy within this chapter, we can use a `type`
    to determine the location and type of file `hello.sh`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回到本章中的命令层级，我们可以使用`type`来确定文件`hello.sh`的位置和类型：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These commands and output can be seen in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令和输出可以在以下截图中看到：
- en: '![](img/62a86b69-105e-4e05-af8b-0c4ba91d7224.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62a86b69-105e-4e05-af8b-0c4ba91d7224.png)'
- en: Hello Dolly!
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello Dolly!
- en: It is possible that we might need a little more substance in the script than
    a simple fixed message. Static message content does have its place, but we can
    make this script much more useful by building in some flexibility.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中可能需要的不仅仅是一个简单的固定消息。静态消息内容确实有其用途，但通过在脚本中加入一些灵活性，我们可以使这个脚本变得更加有用。
- en: In this chapter, we will look at the positional parameters or arguments that
    we can supply to the script and in the next chapter, we will see how we can make
    the script interactive and also prompt the user for input at runtime.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看可以提供给脚本的位置参数或参数，在下一章中，我们将学习如何使脚本具有交互性，并在运行时提示用户输入。
- en: Running the script with arguments
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用参数运行脚本
- en: 'We can run the script with arguments; after all, it''s a free world and Linux
    promotes your freedom to do what you want to do with the code. However, if the
    script does not make use of the arguments, then they will be silently ignored.
    The following command shows the script running with a single argument:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用参数运行脚本；毕竟，这是一个自由的世界，Linux 鼓励你根据自己的需要使用代码。然而，如果脚本没有使用这些参数，那么它们会被默默地忽略。以下命令展示了脚本在使用一个参数时的运行：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The script will still run and will not produce an error. The output will not
    change either and will print `Hello World`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本仍然可以运行，并且不会产生错误。输出也不会改变，依然会打印`Hello World`：
- en: '| **Argument Identifier** | **Description** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **参数标识符** | **描述** |'
- en: '| `$0` | The name of the script itself, which is often used in usage statements.
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `$0` | 脚本本身的名称，通常用于使用说明中。 |'
- en: '| `$1` | A positional argument, which is the first argument passed to the script.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `$1` | 一个位置参数，是传递给脚本的第一个参数。 |'
- en: '| `${10}` | Where two or more digits are needed to represent the argument position.
    Brace brackets are used to delimit the variable name from any other content. Single
    value digits are expected. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `${10}` | 当需要两个或更多数字来表示参数位置时使用。大括号用来将变量名与其他内容区分开来。期望为单一值数字。 |'
- en: '| `$#` | The argument count is especially useful when we need to set the amount
    of arguments needed for correct script execution. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `$#` | 参数计数，当我们需要设置正确脚本执行所需的参数数量时，这个参数特别有用。 |'
- en: '| `$*` | Refers to all arguments. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `$*` | 指代所有参数。 |'
- en: 'For the script to make use of the argument, we can change its content a little.
    Let''s first copy the script, add in the execute permissions, and then edit the
    new `hello2.sh`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让脚本利用该参数，我们可以稍微修改其内容。首先，复制脚本，添加执行权限，然后编辑新的`hello2.sh`：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to edit the `hello2.sh` file to make use of the argument as it is passed
    at the command line. The following screenshot shows the simplest use of command-line
    arguments, now allowing us to have a custom message:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编辑`hello2.sh`文件，以利用命令行传递的参数。以下截图展示了命令行参数的最简单使用方式，现在我们可以有一个自定义消息：
- en: '![](img/5ed6a81a-5951-4afa-a836-ca3d223476c1.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ed6a81a-5951-4afa-a836-ca3d223476c1.png)'
- en: 'Run the script now; we can provide an argument as shown in the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行脚本；我们可以提供如下所示的参数：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output should now say `Hello fred`. If we do not provide an argument, then
    the variable will be empty and will just print `Hello`. You can refer to the following
    screenshot to see the execution argument and output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在应该显示`Hello fred`。如果我们不提供任何参数，则变量将为空，并且只会打印`Hello`。你可以参考以下截图查看执行参数和输出：
- en: '![](img/7bb5ff42-cddd-4513-a670-6e6b43423c75.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bb5ff42-cddd-4513-a670-6e6b43423c75.png)'
- en: 'If we adjust the script to use `$*`, all the arguments will print. We will
    see `Hello` and then a list of all the supplied arguments. Edit the script and
    replace the `echo` line as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调整脚本使用`$*`，所有参数都会打印。我们会看到`Hello`，然后是所有提供的参数列表。编辑脚本并将`echo`行替换如下：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will execute the script with the following arguments:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用以下参数执行脚本：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And this will result in the output shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致如下截图中的输出：
- en: '![](img/612e1eac-7009-47eb-ac8a-b7b86e308f8a.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/612e1eac-7009-47eb-ac8a-b7b86e308f8a.png)'
- en: If we want to print `Hello <name>`, with each name on a separate line, we will
    need to wait a little until we cover looping structures. A `for` loop is a good
    way to achieve this.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想打印`Hello <name>`，并且每个名字都在单独的行上，我们需要稍等一下，直到讲解循环结构。`for`循环是实现这一目标的好方法。
- en: The importance of correct quotes
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确使用引号的重要性
- en: So far, we have used a simple double-quoting mechanism to encase the strings
    that we want to use with echo.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了简单的双引号机制，将我们想用`echo`的字符串包裹起来。
- en: In the first script, it does not matter if we use single or double quotes. `echo
    "Hello World"` will be exactly the same as `echo 'Hello World'`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个脚本中，使用单引号或双引号并不重要。`echo "Hello World"`与`echo 'Hello World'`是完全一样的。
- en: However, this is not the case in the second script, so it is very important
    to understand the quoting mechanisms available in bash.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但在第二个脚本中情况并非如此，因此理解bash中可用的引用机制非常重要。
- en: As we have seen, using double quotes in `echo "Hello $1"` will result in `Hello
    fred` or whatever the supplied value is. Whereas, if we use single quotes in `echo
    'Hello $1'`, the printed output on the screen will be `Hello $1`; that is, we
    see the variable name and not its value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用双引号`echo "Hello $1"`会输出`Hello fred`或任何提供的值。而如果我们在`echo 'Hello $1'`中使用单引号，则屏幕上打印的输出将是`Hello
    $1`；也就是说，我们看到的是变量名，而不是它的值。
- en: The idea of the quotes is to protect special characters, such as a space between
    the two words; both quotes protect the space from being misinterpreted. The space
    is normally read as a default field, separated by the shell. In other words, all
    characters are read by the shell as literals with no special meaning. This has
    the knock-on effect of the `$` symbol printing its literal format rather than
    allowing bash to expand its value. The bash shell is prevented from expanding
    the variable's value as it is protected by the single quotes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 引号的作用是保护特殊字符，例如两个单词之间的空格；这两种引号都保护了空格，防止它被误解。空格通常被shell视为默认字段，且由shell分隔。换句话说，所有字符都被shell读取为字面量，没有特殊含义。这会导致`$`符号打印其字面格式，而不是允许bash扩展其值。由于被单引号保护，bash
    shell无法扩展变量的值。
- en: This is where the double quote comes to our rescue. The double quote will protect
    all the characters except the `$`, allowing bash to expand the stored value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是双引号帮助我们的地方。双引号会保护所有字符，除了`$`，从而允许bash扩展存储的值。
- en: If we ever need to use a literal `$` within the quoted string, along with variables
    that need to be expanded, we can use double quotes, but escape the desired `$`
    with the backslash (`\`). For example, `echo "$USER earns \$4"` would print as
    `Fred earns $4` if the current user were Fred.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在引号字符串中使用字面量的`$`符号，并且需要展开变量，可以使用双引号，但要用反斜杠（`\`）转义所需的`$`符号。例如，`echo "$USER
    earns \$4"`如果当前用户是Fred，将会打印`Fred earns $4`。
- en: 'Try the following examples at the command line using all quoting mechanisms.
    Feel free to up your hourly rate as required:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中尝试以下示例，使用所有引号机制。根据需要自由调整你的小时费率：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下面的截图所示：
- en: '![](img/5ca3f282-07b0-4866-aeba-a8ae1f28b832.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ca3f282-07b0-4866-aeba-a8ae1f28b832.png)'
- en: Printing the script name
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印脚本名称
- en: The `$0` variable represents the script name, and this is often used in usage
    statements. As we are not yet looking at conditional statements, we will get the
    script name printed above the displayed name.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`$0`变量表示脚本名称，这通常用于用法说明中。由于我们尚未讨论条件语句，我们将显示脚本名称，而不是显示的名称。'
- en: 'Edit your script so that it reads like the following complete code block for
    `$HOME/bin/hello2.sh`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你的脚本，使其读起来像以下完整的`$HOME/bin/hello2.sh`代码块：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output from the command is shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下面的截图所示：
- en: '![](img/225c3633-3e9e-42b9-8484-18d5832db6c3.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/225c3633-3e9e-42b9-8484-18d5832db6c3.png)'
- en: 'If we prefer not to print the path and only want the name of the script to
    show, we can use the `basename` command, which extracts the name from the path.
    Adjust the script so that the second line now reads as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想打印路径，只希望显示脚本的名称，可以使用`basename`命令，它从路径中提取文件名。调整脚本，使第二行现在如下所示：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `$(....)` syntax is used to evaluate the output of the inner command. We
    first run `basename $0` and feed the result into an unnamed variable represented
    by the `$`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(....)`语法用于评估内部命令的输出。我们首先运行`basename $0`，并将结果传递给一个无名变量，由`$`表示。'
- en: 'The new output will appear as seen in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 新的输出将如下面的截图所示：
- en: '![](img/011b53df-581f-4da2-aef6-c6bb8916b43d.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/011b53df-581f-4da2-aef6-c6bb8916b43d.png)'
- en: 'It is possible to achieve the same results using back quotes; this is less
    easy to read, but we have mentioned this as you might need to understand and modify
    the scripts that have been written by others. The alternative to the `$(....)`
    syntax is shown in the following example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反引号也可以实现相同的结果；虽然这种方式较难阅读，但我们提到它是因为你可能需要理解并修改由其他人编写的脚本。`$(....)`语法的替代方式如下面的示例所示：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Please note that the characters used are back quotes and *NOT* single quotes.
    On UK and US keyboards, these are found in the top-left corner next to the number
    1 key.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用的字符是反引号，而*不是*单引号。在英国和美国的键盘上，它们位于左上角，紧挨数字1键。
- en: Declaring variables
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明变量
- en: Just like in any programming language, you can declare variables in bash scripts.
    So, what are these variables and what are the benefits of using them?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在任何编程语言中一样，你可以在bash脚本中声明变量。那么，这些变量是什么，使用它们有什么好处呢？
- en: Well, a variable is like a placeholder where you store some value for later
    use in your code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，变量就像是一个占位符，用来存储一些值，以便稍后在代码中使用。
- en: 'There are two kinds of variables you can declare in your script:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在脚本中声明两种类型的变量：
- en: User-defined variables
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的变量
- en: Environment variables
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: User-defined variables
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义的变量
- en: To declare a variable, just type the name you want and set its value using the
    equals sign (`=`).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个变量，只需输入你想要的名称，并通过等号（`=`）设置其值。
- en: 'Check out this example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个示例：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, to print the variable's value, you should use the dollar sign
    (`$`) before it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，要打印变量的值，你应该在变量前面加上美元符号（`$`）。
- en: Note that there are **no spaces** between the variable name and the equals sign,
    or between the equals sign and the value.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，变量名和等号之间，或者等号和值之间**没有空格**。
- en: If you forget and type a space in between, the shell will treat the variable
    as if it were a command, and, since there is no such command, it will show an
    error.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了，在变量名和等号之间输入了空格，shell会把这个变量当作命令来处理，而由于没有这样的命令，它会显示错误。
- en: 'All of the following examples are incorrect declarations:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有示例都是错误的声明：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Another useful type of user-defined variable is the array. An array can hold
    multiple values. So, if you have tens of values you want to use, you should use
    arrays instead of filling your script with variables.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare an array, just enclose its elements between brackets, like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To access a specific array element, you can specify its index like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The index is zero based.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the array elements, you can use an asterisk, like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To remove a specific element from the array, you can use the `unset` command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Environment variables
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used variables that we didn't define, such as `$BASH_VERSION`,
    `$HOME`, `$PATH`, and `$USER`. You might wonder, as we didn't declare these variables,
    where did they come from?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: These variables are defined by the shell for your use and they are called environment
    variables.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: There are many environment variables. If you want to list them, you can use
    the `printenv` command.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can print a specific environment variable by specifying it to the
    `printenv` command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can use any of these variables in our bash scripts.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Note that all environment variables are written in capital letters, so you can
    declare your variables as lower case to make it easy to differentiate your variables
    from environment variables. This is not required, but is preferable.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Variable scope
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have declared your variable, it will be available for use in your entire
    bash script without any problems.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume this scenario: you have divided your code into two files and
    you will execute one of them from inside the other, like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The second script looks like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Suppose that you want to use the `name` variable in the second script. If you
    try to print it, nothing will show up; this is because a variable's scope is only
    limited to the process that creates it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: To use the `name` variable, you can export it using the `export` command.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our code will be like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now if you run the first script, it will print the name that came from the first
    script file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the second process or `script2.sh` only makes a copy of the
    variable and never touches the original one.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove this, try to change that variable from the second script and try to
    access that variable value from the first script:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The second script will be like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you run the first script, it will print the modified `name` from the second
    script and then it will print the original `name` from the first script. So, the
    original variable remains as it is.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Command substitution
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to declare variables. These variables can hold integers,
    strings, arrays, or floats, as we have seen, but this is not everything.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: A command substitution means storing the output of a command execution in a
    variable.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: As you might know, the `pwd` command prints the current working directory. So,
    we will see how to store its value in a variable.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to perform a command substitution:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Using the backtick character (`'`)
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the dollar sign format, like this: `$()`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the first method, we just surround the command between two backticks:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the second way is written as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output coming from commands can be further processed and actions can be
    made based on that output.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your scripts
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the scripts as simple as we have seen so far, there is little that can
    go wrong or need debugging. As the script grows and decision paths are included
    with conditional statements, we may need to use some level of debugging to analyze
    the scripts' progress better.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Bash provides two options for us, `-v` and `-x`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to look at the verbose output from our script and the detailed information
    about the way the script is evaluated line by line, we can use the `-v` option.
    This can be within the shebang, but it is often easier to run the script directly
    with bash:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is especially useful in this example as we can see how each element of
    the embedded `basename` command is processed. The first step is removing the quotes
    and then the parentheses. Take a look at the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e6b913f-2cd8-49b5-af54-4b287f65b0d9.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'The `-x` option, which displays the commands as they are executed, is more
    commonly used. It''s useful to know the decision branch that has been chosen by
    the script. The following shows this in action:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We again see that the `basename` is evaluated first, but we do not see the
    more detailed steps involved in running that command. The screenshot that follows
    captures the command and output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc5c60c6-5587-46d7-ad8f-c3a513ad0e11.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: The previous method might be hard for beginners or people who have a programming
    background in which they debugged their code visually.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Another modern way of debugging shell scripts is by using Visual Studio Code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: There is a plugin called **bash debug** that enables you to debug bash scripts
    visually, as is the case for any other programming language.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: You can step into, step over, add watches, and do all the other usual debugging
    stuff you know.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the plugin, from the File menu, open your `shell-scripts`
    folder. Then you can configure the debugging process by pressing *Ctrl* + *Shift*
    + *P* and typing the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will open an empty file; type in the following configurations:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will create a debug configuration named `Packt Bash-Debug`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f43d6a8d-4e19-41fa-a3a7-269e73f4c5f8.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'Now insert a breakpoint and press *F5*, or start debugging from the Debug menu;
    it will show you the list of `.sh` files:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31f4f7c8-67f5-4b5e-87a9-9597df9a1566.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Select the one you want to debug, and set a breakpoint on any line to test
    it, as shown in the following screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbe3ea88-c551-4597-ac6d-21de73704fa0.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: 'You can add watches to watch variables'' values while stepping over your lines
    of code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea379cba-8879-47ba-9a8c-223e1473ddee.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: Note that your script **MUST** start with the bash shebang, `#!/bin/bash`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Now you can enjoy the visual method of debugging. Happy coding!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This marks the end of this chapter and you have no doubt found this useful.
    Especially for those making a start with bash scripting, this chapter will have
    established a firm foundation on which you can build your knowledge.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: We began by ensuring that bash is secure and not susceptible to shell-shock
    from embedded functions. With bash secured, we considered the execution hierarchy
    where aliases, functions, and so on are checked before the command; knowing this
    can help us plan a good naming structure and a path to locate the scripts.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Then we went on to illustrate the types of Linux shells and we found out what
    bash scripting is.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we were writing simple scripts with static content, but we saw how easy
    it was to add flexibility using arguments. The exit code from the script can be
    read with the `$?` variable and we can create a command-line list using `||` and
    `&&`, which depends on the success or failure of the preceding command in the
    list.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Then we saw how to declare variables and how to use environment variables. We
    identified the variables' scope and saw how to export them to another process.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Also, we saw how to store commands' output in variables, which is called command
    substitution.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter by looking at debugging the script using bash
    options and VS Code. It's not really required when the script is trivial, but
    it will be useful later when complexity is added.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create interactive scripts that read the user's
    input during script execution.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the problem with the following code? And how do we fix it?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What is the result of the following code?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What is the problem with the following code? And how do we fix it?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What is the value of the b and c variables in the following code?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Further reading
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/abs/html/varassignment.html](http://tldp.org/LDP/abs/html/varassignment.html)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/abs/html/declareref.html](http://tldp.org/LDP/abs/html/declareref.html)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
