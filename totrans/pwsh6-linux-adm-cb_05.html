<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passing Data through the Pipeline</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we cover the following topics:</p>
<ol>
<li>Selecting columns from the output</li>
<li>Limiting the number of items returned by a cmdlet</li>
<li>Expanding selections</li>
<li>Filtering objects</li>
<li>Grouping the output</li>
<li>Sorting the output</li>
<li>Taking actions on the returned objects</li>
<li>Understanding pipeline-enabled parameters</li>
<li>Importing content into PowerShell</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>It is time for some information feasting now. In the previous chapter, <em>First Steps in Administration using PowerShell</em>, we looked at a few simple concepts such as working with dates and processes. In doing so, we learnt a thing or two about using PowerShell as well, for example, measuring the output objects.</p>
<p>In this chapter, we will learn to use one of those things that make PowerShell highly efficient and friendly: The Pipeline.</p>
<p>Most Linux administrators would have used the pipeline in their shell commands or shell scripts. And most administrators who use any form of shell scripting would be aware that the pipe sends the output of one command as input to the next. It is also true in case of Bash (and its derivatives) that the pipe sends <em>text</em> from the preceding command to the succeeding one.</p>
<p>Most PowerShell cmdlets output objects. And the pipeline in PowerShell sends the output <em>object</em> to the next command. When we run a PowerShell command (and not a Linux command) in PowerShell, we get a table-like output in most cases. We may think that it is all of the output.</p>
<p>When we ask PowerShell to get any information, it pulls out entire the object in the background. This object <span>(or a package that contains a lot of objects) </span>is then processed using PowerShell's built-in formatting rules in order for it to be displayed on the host. To quote Microsoft:</p>
<div class="packt_quote"><span>What you see onscreen is a summary of information, and not a complete representation of the output object.</span></div>
<p>Therefore, more often than not, what you see on the screen as the output of a certain command, is just a tip of the iceberg! Just that the <em>submerged</em> part was chosen not to be displayed based on the formatting rules. In this chapter, we will use the pipeline to get more from the objects, than is displayed on the screen by default, and leverage the capability of the pipeline to get more out of PowerShell than meets the eye.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Selecting columns from the output</h1>
                </header>
            
            <article>
                
<p>When my brother saw me exploring <kbd>awk</kbd>, he said, 'Boy, have we overused this command!' Of course, not everything displayed on the screen is important—or even necessary. In this recipe, we learn to separate the columns in PowerShell, without using the Linux command, <kbd>awk</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Go to a directory that has some files that we can play with. If you do not have such a directory, create one and create some files in there. Let the files be of different extensions, so that we can use them in the future recipes as well.</p>
<div class="packt_tip">If you have not already, clone the git repository, <a href="https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook">https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook</a>. There is a quick-and-dirty script, <span><kbd>Initialize-PacktPs6CoreLinuxLab.ps1</kbd> under the directory, <kbd>chapter-05</kbd>. Run the script to get the necessary files.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The <kbd>awk</kbd> command works with text, and based on the delimiters in the output text, separates the output into columns. This separated output is displayed as columns again, using a the <kbd>print</kbd> function, like in C. PowerShell works a little differently.</p>
<p>Let us get started.</p>
<ol>
<li>If you did not create files, please do so. Here are some commands you could use to create the files.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; New-Item ./random/cities -ItemType Directory -Force<br/>PS&gt; Set-Location ./random/<br/>PS&gt; New-Item random-text.txt, himalayas.jpg, crunched-numbers.csv, bangalore.jpg, screenshot-001.png, screenshot-002.png, screenshot-003.png, demo.doc, my-plugin.rb, ./cities/mumbai.html, ./cities/nyc.html, ./cities/cairo.html, ./cities/dubai.html, ./cities/paris.html -ItemType File</pre>
<ol start="2">
<li>You may also want to download some real multimedia content, just so we get the <kbd>length</kbd> (file size) property for future use. Just download any random images or media files.</li>
<li>Navigate to the location where you saved the files. I have them in a directory called <kbd>random</kbd> in my home directory. You would, too, if you used the script.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Set-Location ./random/</pre>
<div class="packt_tip">Use tab-completion to complete the cmdlet as well as the path.</div>
<ol start="4">
<li>List out the contents in the current location.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path .</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/fc1b8222-bc35-4723-bc80-b3c548ec789f.png" width="1812" height="1004"/></div>
<ol start="5">
<li>Let us say, you do not require the <kbd>Mode</kbd> column.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . | Select-Object LastWriteTime, Length, Name</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/66a9b353-b59f-4822-9b84-ea92bae58933.png" width="1812" height="1004"/></div>
<div class="packt_tip">If you notice, select does not seem to follow the naming or capitalisation convention that PowerShell uses. How is that? Run <kbd>Get-Command select</kbd> to find out.</div>
<ol start="6">
<li>This sequence does not really make sense to you in the current context. Shuffle the columns.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . | Select-Object Name, Length, LastWriteTime</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/3f839c8d-22b8-45c0-bbf9-913af8c94295.png" width="1812" height="1004"/></div>
<p style="padding-left: 60px">That looks much better.</p>
<ol start="7">
<li>Now, change the column name of <kbd>LastWriteTime</kbd> to <kbd>Modified</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . | Select-Object Name, Length, @{Name='Modified'; Expression={$_.LastWriteTime}}</pre>
<p style="padding-left: 60px">Notice the name of the last column now, and compare it with the previous output.</p>
<ol start="8">
<li>Now, pick just the year; not the entire date.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . | Select-Object Name, Length, @{Name='Modified'; Expression={$_.LastWriteTime.Year}}</pre>
<ol start="9">
<li>See how many days have passed since the last change.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . | select Name, Length, @{Name='DaysSinceModification'; Expression={[math]::Round(((Get-Date) - $_.LastWriteTime).TotalDays)}}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>If you ran <kbd>Get-Command select</kbd>, you would have understood by now, that <kbd>select</kbd> is in fact an alias for <kbd>Select-Object</kbd>. As already established, PowerShell outputs objects. These objects are then formatted using built-in formatting rules to show on the screen a certain way.</p>
<p>When we use the <kbd>Select-Object</kbd>, we override the formatting rules by specifying which objects need to be shown to us. While the primary objective of <kbd>Select-Object</kbd> is to pick the columns we need, the cmdlet also allows us to sequence the output columns.</p>
<p>PowerShell also gives us the freedom to modify the name of the columns returned. In such a case, we use a <em>hashtable</em> to specify the name that we want, and what data we want shown under the column. You can even perform calculations on the data returned, and make this a calculated property. At the last step, we subtract the date of last modification from the current date, pick the total number of days that have passed since, and then, use the <kbd>Round</kbd> method of the <kbd>[math]</kbd> accelerator to get a rounded figure of the number of days since the last modification.</p>
<p>The concept of <kbd>$_</kbd> or <kbd>$PSItem</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Try <kbd>Select-Object</kbd> with other cmdlets such as <kbd>Get-Command</kbd>, to select only those columns that you need.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Recipe : Creating and initialising a simple hash table.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Limiting the number of output objects</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, <em>Selecting columns from the output</em>, we saw how the <kbd>Select-Object</kbd> cmdlet can be used to select only the columns we want. In this recipe, we will learn to limit the output of a cmdlet to a subset of the total items returned.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">Ensure that you are at a location that has a few files. List out the contents of the current directory and count the number of items returned. If the number is less than five, you may want to consider adding more items to the directory.</p>
<ol>
<li>Enter the following command to count the number of files and directories at the current path.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; (Get-ChildItem -Path .).Count</pre>
<ol start="2">
<li class="mce-root">If you would like to reduce keystrokes, given that we are only running commands at the terminal, you could use the alias and the defaults of the cmdlet.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; (gci).Count</pre>
<div class="packt_tip">Those parentheses are required; the parentheses work almost similar to how they work in mathematics: the instruction within the parentheses is processed first. In this case, we want <kbd>gci</kbd> executed first, and then, the <kbd>Count</kbd> property from within the returned object picked.</div>
<ol start="3">
<li class="mce-root">Get the list of parameters <kbd>Select-Object</kbd> has.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-Help Select-Object</pre>
<p class="mce-root">We see parameters like, <kbd>First</kbd> and <kbd>Last</kbd>, and they accept integer values.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Navigate to the directory where you have the files.</p>
<ol>
<li class="mce-root">Select only the first five files and directories from the returned list, using the <kbd>First</kbd> parameter.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-ChildItem . | Select-Object -First 5</pre>
<ol start="2">
<li class="mce-root">Let us say you would like to pick the last five elements.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-ChildItem . | Select-Object -Last 5</pre>
<ol start="3">
<li class="mce-root">To skip the first three objects:</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-ChildItem . | Select-Object -Skip 3</pre>
<ol start="4">
<li class="mce-root">If you would like to skip the last two objects:</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-ChildItem . | Select-Object -SkipLast 2</pre>
<ol start="5">
<li class="mce-root">To pick the fourth element from the output:</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-ChildItem . | Select-Object -Index 3</pre>
<ol start="6">
<li>Now, combine it with what we learnt in the previous recipe. Pick only the file names and the last modified time of the first four elements.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem . | select -Property Name, LastWriteTime -First 4</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">This is a simple recipe that helps you work with the number of items returned in the output. With <kbd>Select-Object</kbd> in PowerShell, we need not loop through output, while simultaneously counting, to only get the number of elements that we want. The <kbd>Select-Object</kbd> cmdlet has that functionality built in.</p>
<p class="mce-root">The parameter names are self-explanatory. Except perhaps the <kbd>Index</kbd> parameter, which works exactly how numbering of array elements works with most programming languages: it starts with zero. Therefore, the fourth element in the array would have an index of <kbd>3</kbd>, and not <kbd>4</kbd>.</p>
<p>The parameters, <kbd>Property</kbd> and <kbd>First</kbd> can be combined together since they both feature in the same parameter set in the help documentation for <kbd>Select-Object</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Expanding the properties within properties</h1>
                </header>
            
            <article>
                
<p>So far from what we have seen, two things are clear to us:</p>
<ol>
<li class="mce-root">An object output feels richer and makes using it easier.</li>
<li class="mce-root">An object can have more objects within it.</li>
</ol>
<p class="mce-root">We have handled the first point using the <kbd>Select-Object</kbd> cmdlet, wherein we picked only the objects properties that we needed, and omitted the rest. This recipe is designed to break down the second point for better understanding.</p>
<p class="mce-root">Let us step into this recipe with one thing in our mind: objects can contain objects within them, which in turn can contain more objects within them. To demonstrate this, we shall use the <kbd>Get-Process</kbd> cmdlet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let us begin with listing out the processes; we shall look at all the properties the <kbd>Get-Process</kbd> cmdlet gives us and look for complex ones.</p>
<ol>
<li class="mce-root">Select all the properties that are part of the output of the <kbd>Get-Process</kbd> cmdlet. Pick only the first object, so your console is not filled with content.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-Process | Select-Object -Property * -First 1</pre>
<p style="padding-left: 60px" class="mce-root">Observe the property, <kbd>Threads</kbd>.</p>
<ol start="2">
<li class="mce-root">Select the name of the process, the ID and the threads.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-Process | Select-Object -Property Name, Id, Threads</pre>
<ol start="3">
<li class="mce-root">List out all the threads for the <kbd>pwsh</kbd> process.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-Process pwsh | Select-Object -ExpandProperty Threads</pre>
<ol start="4">
<li class="mce-root">A lot of content is output. Say, we want just the ID, the priority, and the start time of the resulting output.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-Process pwsh | Select-Object -ExpandProperty Threads | Select-Object -Property Id, PriorityLevel, StartTime</pre>
<p style="padding-left: 60px"><span>This gave us the ID, the priority level and the start time of all the threads that are running under <kbd>pwsh</kbd>.</span></p>
<ol start="5">
<li>What if we use <kbd>ExpandProperty</kbd> on the ID?</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-Process pwsh | Select-Object -ExpandProperty Threads | Select-Object -ExpandProperty Id</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/9a082625-cdef-4a3d-ab7a-dc865b01364f.png" width="1812" height="1044"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">The default parameter for <kbd>Select-Object</kbd>, as we have seen, is <kbd>Property</kbd>. It accepts property names and shows their values in the output. The parameter can be used to fetch values of multiple properties (<kbd>Name</kbd>, <kbd>Id</kbd>, <kbd>Threads</kbd>).</p>
<p class="mce-root">However, some properties have more complex objects within them, like how we saw in case of the <kbd>Threads</kbd> property of the object returned by <kbd>Get-Process</kbd>. A simple way to identify complex objects is to see if they are enclosed in curly braces.</p>
<p class="mce-root">The <kbd>ExpandProperty</kbd> parameter accepts only a single property name as input and expands the property to show its objects. This can again be piped to <kbd>Select-Object</kbd> (or any other relevant cmdlet) for further processing.</p>
<p class="mce-root">In cases where the object is not complex, <kbd>ExpandProperty</kbd> simply shows the output without its header. If you notice the output of <kbd>ExpandProperty</kbd>, it does not contain the name of the expanded object itself (<kbd>Threads</kbd> in our case); it contains only the value. The value, in turn has multiple properties within it.</p>
<p class="mce-root">In case of simple properties, using <kbd>ExpandProperty</kbd> simply strips off the property name from the output.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Filtering objects</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the recipe, <em>Limit the number of items returned by a cmdlet</em>, we saw how to restrict the output content based on a number. In this recipe, we would look at filtering the output based on a certain criterion, and not a number.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">Go back to read the recipe, <em>Working with date properties</em>, if you have not read it already. This recipe uses one of the properties from the date object to filter content. While it is not critical to understand filtration of objects, it still demonstrates the simplicity of filtration based on object properties.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Navigate to the location where you created files for use with this book.</p>
<ol>
<li class="mce-root">List out the contents of this directory to see what content you have. (If you are like me, you would have even forgotten where you created this directory, and what content you put in.)</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Set-Location ~/random<br/>PS&gt; Get-ChildItem -Path .</pre>
<p style="padding-left: 60px" class="mce-root">Notice the names of the properties you got.</p>
<ol start="2">
<li class="mce-root">Now, pick only those files that are larger than <kbd>0</kbd> bytes.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-ChildItem -Path . | Where-Object -Property Length -GT -Value 0</pre>
<ol start="3">
<li class="mce-root">Pick out all the JPG files from the lot. To do this, add another condition to the existing condition. Although, this time, use the <kbd>FilterScript</kbd> parameter instead of <kbd>Property</kbd>.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-ChildItem -Path . | Where-Object -FilterScript {$_.Length -GT 0 -and $_.Extension -EQ '.jpg'}</pre>
<ol start="4">
<li class="mce-root">Add a condition to get only those files whose names start with 'c'.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-ChildItem -Path . | Where-Object -FilterScript {$_.Length -GT 0 -and $_.Extension -EQ '.jpg' -and $_.Name -CMatch '^c'}</pre>
<ol start="5">
<li class="mce-root">Now, choose those files which were created before the 30th minute of any hour.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-ChildItem -Path . | Where-Object -FilterScript {$_.Length -GT 0 -and $_.Extension -EQ '.jpg' -and $_.Name -CMatch '^c' -and $_.LastWriteTime.Minute -LT 30}</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/b3ae5d4b-631d-4e62-9ee6-c0c105aebfb5.png" width="1812" height="1044"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Filtration of the output is very simple in PowerShell. Given that the content output is an object, we could simply use the properties from within the object for the filtration.</p>
<p class="mce-root">This recipe shows two modes of filtration:</p>
<ol>
<li class="mce-root">Using one property and comparing its value to the input,</li>
<li class="mce-root">Using a filter script, that uses multiple values, and multiple conditions.</li>
</ol>
<p class="mce-root">The <kbd>Property</kbd> parameter accepts only one property. A conditional operator and a value for comparison are added to the statement to filter the output.</p>
<p class="mce-root">The <kbd>FilterScript</kbd> parameter, on the other hand, can handle more complex filtration, for example, when we need the output to meet several conditions.</p>
<p class="mce-root">A significant difference between using <kbd>Property</kbd> and <kbd>FilterScript</kbd> is the use of the automatic variable, <kbd>$_</kbd>. This variable contains the <em>current object</em> in the pipeline. For example, in this recipe, we pass the object from <kbd>Get-ChildItem</kbd> to <kbd>Where-Object</kbd> through the pipeline. The automatic variable, <kbd>$_</kbd>, contains the object returned by <kbd>Get-ChildItem</kbd>, so that <kbd>Where-Object</kbd> can process it. <kbd>$_.LastWriteTime</kbd>, in this case, picks the <kbd>LastWriteTime</kbd> property from the object returned by <kbd>Get-ChildItem</kbd>.</p>
<p>Also, the <kbd>LastWriteTime</kbd> object is of type <kbd>System.DateTime</kbd> or <kbd><span>DateTime</span></kbd>. (Run <kbd>(Get-ChildItem .).LastWriteTime | Get-Member</kbd> to know more.) Therefore, it is possible to break it down further into days, hours, minutes, and so on, which is the reason, <kbd>$_.LastWriteTime.Minute</kbd> could be used for filtration.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Try out the <kbd>Where-Object</kbd> cmdlet on other outputs, such as that of <kbd>Get-Process</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Grouping the output</h1>
                </header>
            
            <article>
                
<p>There are situations where we could group the objects that were output, so that we could handle each group better, or simply for a more organised output. In this recipe, we will look at passing the output of one cmdlet through the pipeline to Group-Object and group the output based on a property.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To group objects based on a property, we use the <kbd>Get-ChildItem</kbd> cmdlet on the files that we created for use in this book.</p>
<ol>
<li>Navigate to the location where you created or downloaded the files.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Set-Location ~/random</pre>
<ol start="2">
<li>List out only the files (exclude the directories).</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File</pre>
<p style="padding-left: 60px">Or use the <em>shorthand</em> version.</p>
<pre style="padding-left: 90px">PS&gt; gci -File</pre>
<ol start="3">
<li>Group the objects based on the extension.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem . -File | Group-Object Extension</pre>
<ol start="4">
<li>The shorthand version of this would be:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; gci -File | group Extension</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/126cd1df-e553-47c3-becf-a56acb92fb78.png" width="1812" height="1044"/></div>
<ol start="5">
<li>Use the <kbd>Select-Object</kbd> cmdlet to only show the extension and the number of files in each extension.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension | Select-Object -Property Name, Count</pre>
<ol start="6">
<li>Is there a simpler way to do this?</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension -NoElement</pre>
<ol start="7">
<li>Now that we know how to handle grouping and expanded property selection, let us pick only the JPG files from the lot.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension | Where-Object Name -EQ .jpg | Select-Object -ExpandProperty Group</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/f0b16425-bada-4fba-ad2d-f7c9a62124a9.png" width="1812" height="1044"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>What we did in this recipe was certainly non-intuitive, considering we could use just <kbd>Where-Object</kbd> along with the <kbd>Get-ChildItem</kbd>. However, the intention of this recipe was to demonstrate the use of <kbd>Group-Object</kbd>. The <kbd>Group-Object</kbd> cmdlet creates groups based on the criteria we specify, and names the groups on the criteria. In our case, the criteria for grouping was the extension, and hence, the names of the groups were the extensions.</p>
<p>Each of these groups contains its elements, which are objects in themselves. If we simply want the count and the names of the groups, we use the <kbd>NoElement</kbd> parameter. If we want only the elements, we use the <kbd>ExpandProperty</kbd> parameter of the <kbd>Select-Object</kbd> cmdlet and expand all the elements. The elements thus expanded are the objects of the cmdlet preceding the <kbd>Group-Object</kbd> cmdlet (<kbd>Get-ChildItem</kbd> in our case).</p>
<p>If <kbd>Where-Object</kbd> and other cmdlets could do what <kbd>Group-Object</kbd> could in a complicated way, why have it in the first place? Read on until <em>Taking actions on the returned objects</em> to know more.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you have gotten a hang of tab completion, you need not even select the properties that are not shown by default. All you have to do is type <kbd>Group-Object</kbd> after the pipe, add a space and press Tab; PowerShell will show you what objects are available to use for grouping. Try it with:</p>
<pre>PS&gt; Get-ChildItem . -File | Group-Object&lt;Space&gt;&lt;Tab&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Recipe 05.07: <span>Taking actions on the returned objects </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sorting the output</h1>
                </header>
            
            <article>
                
<p>It is time for another simple cmdlet, which would build towards the recipe, <em>Taking actions on the returned objects</em>. In this recipe, we will sort the output objects to meet our requirements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will continue to use the directory and the files we created for the book. If all of your files are of zero bytes, download a few files with content. The file type does not matter.</p>
<ol>
<li>List out the files in the directory.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path .</pre>
<ol start="2">
<li>Filter the output to have only files.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File</pre>
<ol start="3">
<li>Pipe the object to the <kbd>Sort-Object</kbd> cmdlet to sort the output based on the file size.</li>
</ol>
<pre style="padding-left: 90px"><span>PS&gt; Get-ChildItem -Path . -File | Sort-Object -Property Length</span></pre>
<ol start="4">
<li>The shorthand for the expression would be:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; gci . -File | sort Length</pre>
<ol start="5">
<li>Sort the files, the largest file to the smallest file.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Sort-Object -Property Length -Descending</pre>
<ol start="6">
<li>Pick the largest three files in the lot.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Sort-Object -Property Length -Descending -Top 3</pre>
<ol start="7">
<li>Create two files, and, using a text editor, add some content into both of them. (Or use the following script block to create some random text.)</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $($i = 0; while ($i -lt 520) {(-join ((65..90) + (97..122) | Get-Random -Count 8 | ForEach-Object {[char]$_})).ToString(); $i++}) -join ' ' | Out-File ./random-text-1.txt; Start-Sleep -Seconds 60; $($i = 0; while ($i -lt 500) {(-join ((65..90) + (97..122) | Get-Random -Count 8 | ForEach-Object {[char]$_})).ToString(); $i++}) -join ' ' | Out-File ./random-text-2.txt</pre>
<ol start="8">
<li>Now, sort the files in the directory, first, by size, and then, the name.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Sort-Object -Property Length, Name</pre>
<p style="padding-left: 60px">Observe the output that you get.</p>
<ol start="9">
<li>Sort the list in the descending order.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Sort-Object -Property Length, Name -Descending</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/98feda49-fc08-4af2-8a63-c814f055239c.png" width="1812" height="1044"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe is another demonstration of passing objects through the pipeline. In the help documentation for <kbd>Sort-Object</kbd>, we see a parameter called <kbd>InputObject</kbd>. This parameter is a generic term used in PowerShell for a parameter whose input comes through the pipeline.</p>
<p><kbd>Sort-Object</kbd> accepts input from the pipeline, and sorts the content based on the property specified. If a property is not specified, the default property for the object output from the preceding command is used for sorting. If there are multiple properties are input, the sorting happens based on the order in which the properties are specified.</p>
<p>Sorting can happen in the ascending order (default), or the descending order.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Taking actions on the returned objects</h1>
                </header>
            
            <article>
                
<p>We have been using the pipeline throughout this chapter to perform various activities on the objects. We have been passing objects from one cmdlet to another, and in fact, taking actions on the objects being returned. This recipe, in the technical sense therefore, is nothing new. However, in order to get ourselves more comfortable using the pipeline, and to show that the pipeline is not just used for selection, filtration and sorting, we will use the pipeline to also perform some deletions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p><span>If you do not have files within the demo directory that we created, please go ahead and create some files. Make sure some of the files have some content in them.</span></p>
<p>Let us say that you have been given a requirement. There is a certain team which would like the top two largest files of each type, deleted from a directory. If there is only one file of a certain type, that file has to be left alone.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here is an outline of the steps you would want to take:</p>
<ol>
<li>Get all the files at the path specified.</li>
<li>Group the files by file type (extension).</li>
<li>Filter out those groups that contain more than one item.</li>
<li>Expand each group, sort the files by size (length).</li>
<li>Pick the two largest files in each group.</li>
<li>Delete the files.</li>
</ol>
<p>While we are working on a sandbox directory, and that we are taking precautions not to delete anything important, it is still better to only prototype the action using ShouldPerform (the WhatIf parameter). This way, the files would not be actually deleted, but PowerShell would only tell you what it would do if the command is run.</p>
<p>Let us get cracking.</p>
<ol>
<li>List the contents of the current directory and group the output based on the extension.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension</pre>
<ol start="2">
<li>Filter to discard lone files of each extension.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension | Where-Object Count -GT 1</pre>
<ol start="3">
<li>Now comes a loop construct. We will look at how that works in a future chapter. For now, just know that it works. The goal here is to only leverage the pipeline.</li>
</ol>
<pre style="padding-left: 90px"><span>PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension | Where-Object Count -GT 1 | ForEach-Object {$_.Group | Sort-Object Length -Bottom 2}</span></pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/c1ae6403-f6e6-48bf-a8cb-188092d3f16e.png" width="1812" height="1004"/></div>
<ol start="4">
<li>Delete these files using the <kbd>Remove-Item</kbd> cmdlet. Use the <kbd>WhatIf</kbd> switch if you do not want the files actually deleted.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension | Where-Object Count -GT 1 | ForEach-Object {$_.Group | Sort-Object Length -Bottom 2} | Remove-Item -WhatIf</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When any cmdlet reads an object through the pipeline, it reads the entire contents of the object. And any cmdlet that is designed to accept input through the pipeline picks the right property from the object, and then takes actions on the objects. In the case of this recipe, it was the <kbd>Path</kbd> property that was picked in order to identify the files to delete.</p>
<p>To know if a certain cmdlet accepts input from the pipeline, run <kbd>Get-Help</kbd> on the cmdlet with the <kbd>Full</kbd> parameter, and see if the value for <kbd>Accept pipeline input?</kbd> is true. The <kbd>InputObject</kbd> parameter of <kbd>Where-Object</kbd>, or the <kbd>Path</kbd> parameter of <kbd>Move-Item</kbd> are a couple of examples.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding pipeline-enabled parameters</h1>
                </header>
            
            <article>
                
<p>Understanding pipelines is not so much of a requirement if you plan to use PowerShell for only running commands on the console; it is well encapsulated, and the cmdlets are well designed to be able to handle passing objects between cmdlets. However, if you plan to create custom functions and modules, the concept of the pipeline is something you would want to understand well.</p>
<p>In this recipe, we will look into the two ways cmdlets accept input. At the point where we create functions, we will look at how to enable pipeline input for parameters.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will mostly use the help documentation to demonstrate the two different kinds of pipeline input.</p>
<ol>
<li>At the prompt, type the following command:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Help Get-Item -Parameter Path</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/ece35564-34f0-4beb-a575-83b29dc0208e.png" width="1812" height="1004"/></div>
<p style="padding-left: 60px">It says the parameter accepts string input, and accepts input by property name as well as by value.</p>
<ol start="2">
<li>Type the following to see if a valid string is accepted.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; '/home/ram/random' | Get-Item</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/2f9fadc6-7b06-4d05-a0f3-3232e4d88ab8.png" width="1812" height="1004"/></div>
<ol start="3">
<li>Let us try something similar with <kbd>Get-Date</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Help Get-Date -Parameter *</pre>
<p style="padding-left: 60px">The Date parameter accepts values through the pipeline. However, the type is DateTime, and not string.</p>
<ol start="4">
<li>Try sending a valid string through the pipeline to see if it gets converted into date.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; '21 June 2018' |  Get-Date</pre>
<p style="padding-left: 60px">It did convert the string into date and time.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/9bf14887-e102-4518-aba5-ef0f00939e1d.png" width="1812" height="1004"/></div>
<ol start="5">
<li>Now, let us go back to getting details of the current directory. This time, however, we would pick only the FullName property of the object.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Item . | Select-Object FullName</pre>
<ol start="6">
<li>Pass this through the pipeline to the <kbd>Get-ChildItem</kbd> cmdlet.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Item . | Select-Object FullName | Get-ChildItem</pre>
<p style="padding-left: 60px">There is an error.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/4b9eb33e-158a-47c3-91fa-81c8373590b4.png" width="1812" height="1004"/></div>
<ol start="7">
<li>Change the property name to <kbd>LiteralPath</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Item . | Select-Object @{Name = 'LiteralPath'; Expression = {$_.FullName}}</pre>
<ol start="8">
<li>Pass the object to <kbd>Get-ChildItem</kbd> through the pipeline.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Item . | Select-Object @{Name = 'LiteralPath'; Expression = {$_.FullName}} | Get-ChildItem</pre>
<p>That worked.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>There are two kinds of input through the pipeline:</p>
<ol>
<li><kbd>ByPropertyName</kbd></li>
<li><kbd>ByValue</kbd></li>
</ol>
<p>The <kbd>ByValue</kbd> type is perhaps the most common. If a parameter accepts input through the pipeline by value, it would look for the data type that matches the defined data type in the output, and pick the output as input for itself. In case the data type is not the same as that defined, but can be converted to the required type, the parameter would convert the value into the data type it takes in, and processes it. This happened in the case of <kbd>Get-Date</kbd>, where we sent the date as a string, and passed it through the pipeline to <kbd>Get-Date</kbd>.</p>
<p>In case of <kbd>Get-Item</kbd>, the <kbd>Path</kbd> parameter accepted string input and processed the command. In case of <kbd>Get-Date</kbd>, the <kbd>Date</kbd> parameter converted the string into a <kbd>DateTime</kbd> object and processed the request.</p>
<p><kbd>ByPropertyName</kbd>, as compared to <kbd>ByValue</kbd>, looks for a property of the <em>exact same name</em> as the parameter. In our case, <kbd>LiteralPath</kbd> of <kbd>Get-ChildItem</kbd> threw an error when we passed the <kbd>FullName</kbd> property, even though it was essentially the literal path of the object, and a string value. The reason for the error was that the property was not called <kbd>LiteralPath</kbd>. When we changed the name of the property to <kbd>LiteralPath</kbd>, <kbd>Get-ChildItem</kbd> accepted the input through the pipeline, and gave us the desired output.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Importing content into PowerShell</h1>
                </header>
            
            <article>
                
<p>Administrators managing multiple computers need to have some sort of input fed into cmdlets so they can automate tasks. While most Linux administrators are familiar with sending input to files, the important point with PowerShell is that apart from taking file-based input (read: <kbd>Get-Content</kbd>),  PowerShell is also capable of <em>importing</em> input. This imported input is a PowerShell object.</p>
<p>In this recipe, we will look at two kinds of import cmdlets and learn to work with them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In the recipe, <em>Parsing input from text to object</em>, we used <kbd>Import-Csv</kbd> to import a comma-separated values file to convert the data contained within to a PowerShell object. Let us recapitulate what we learnt, however this time, now that we know how to work with objects, we will use the imported content in some way.</p>
<p>Before we import content, let us first export some content into a CSV file. This way, we would have some relevant content to manipulate.</p>
<ol>
<li>Navigate to the location where you created files for this chapter. List the contents of the directory. While the book uses (and recommends) complete cmdlets even at the console (using tab-completion of course), feel free to use aliases if you want.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . | Select-Object Name, FullName, CreationTime, LastWriteTime, Extension, Length</pre>
<ol start="2">
<li>Export the contents to a CSV file.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . | Select-Object Name, FullName, CreationTime, LastWriteTime, Extension, Length | Export-Csv ./file-list.csv</pre>
<ol start="3">
<li>Open the file in a spreadsheet processor like LibreOffice Calc or even a text editor to view its contents.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Content ./file-list.csv</pre>
<p style="padding-left: 60px">That was a plain text representation of the object returned by <kbd>Get-ChildItem.</kbd></p>
<ol start="4">
<li>Import the contents of the CSV file to convert this text into an object.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Import-Csv ./file-list.csv</pre>
<ol start="5">
<li>Find the type of the object returned by this command.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Import-Csv ./file-list.csv | Get-Member</pre>
<p style="padding-left: 60px">The object type is <kbd>System.Management.Automation.PSCustomObject</kbd>.</p>
<ol start="6">
<li>Check if this is the same as that returned by <kbd>Get-ChildItem</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem . | Get-Member</pre>
<ol start="7">
<li>The object returned by <kbd>Import-Csv</kbd> is different. Is it possible to treat it just like we do other objects? Get the <kbd>CreationTime</kbd> using the member access operator.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Import-Csv ./file-list.csv).CreationTime</pre>
<ol start="8">
<li>Get just the year.</li>
</ol>
<pre style="padding-left: 90px"><span>PS&gt; (Import-Csv ./file-list.csv).CreationTime.Year</span></pre>
<ol start="9">
<li>Find the type of object returned by the last command.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Import-Csv ./file-list.csv).CreationTime | Get-Member<br/><br/>    TypeName: System.String</pre>
<ol start="10">
<li>Attempt to convert the <kbd>LastWriteTime</kbd> into a <kbd>DateTime</kbd> object. Pick just the first record, though.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date (Import-Csv ./file-list.csv | Select-Object CreationTime -First 1).CreationTime</pre>
<ol start="11">
<li>What if we had to retain all the objects within the object returned by <kbd>Get-ChildItem</kbd>, including their object types?</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -Path . | Export-Clixml ./file-list.xml</pre>
<ol start="12">
<li>Now, import the contents of the XML to the session.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Import-Clixml ./file-list.xml</pre>
<ol start="13">
<li>Find out the type name of the object returned by the import command.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Import-Clixml ./file-list.xml | Get-Member</pre>
<ol start="14">
<li>Pick the <kbd>CreationTime</kbd> property and find its type.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Import-Clixml ./file-list.xml).CreationTime | Get-Member<br/><br/>    TypeName: System.DateTime</pre>
<ol start="15">
<li>Pick just the year.</li>
</ol>
<pre style="padding-left: 90px"><span>PS&gt; (Import-Clixml ./file-list.xml).CreationTime.Year</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Importing content from a CSV is a straightforward process. The columns in a CSV are separated by commas. PowerShell creates an object from the input content, with each column making a property of a PowerShell custom object. Operations that we perform on objects can be performed on the <kbd>PSCustomObject</kbd>, however, the only limitation with <kbd>Import-Csv</kbd> is that the properties cannot be multi-valued, nor can they have other sub-properties within them. There could be ways to achieve multi-valued properties with CSV, but they would involve some manipulation after the object is imported within PowerShell. One such way is to separate the values of the property with a delimiter, and then, after the import, split the delimited value.</p>
<p>On the other hand, a CLIXML (or a Common Language Infrastructure XML) is a complete .NET object. When a PowerShell object is exported to CLIXML, the object is retained as it is. That is, the CLIXML retains all the properties (of theoretically any depth), and the methods that were part of the output object. In other words, it can be said that a CLIXML export is almost lossless in terms of the members of the object.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Recipe: Generate random text using ASCII characters</p>


            </article>

            
        </section>
    </div>



  </body></html>