- en: Chapter 5. WhatsApp Laundry Room Monitor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. WhatsApp 洗衣房监控器
- en: In this chapter, we'll see how to implement a laundry monitor room with several
    sensors capable of alerting the user directly on their WhatsApp account when a
    specific event occurs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何实现一个洗衣房监控系统，使用多个传感器，当特定事件发生时，能够通过 WhatsApp 账号直接提醒用户。
- en: We'll see how to connect a sound sensor and a light sensor to our BeagleBone
    Black and then how we can monitor our washing machine with them. Also, we'll see
    how we can interact with the user directly on the user's smartphone by using a
    WhatsApp account in order to notify them of some events.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何将声音传感器和光线传感器连接到 BeagleBone Black，并通过它们监控我们的洗衣机。此外，我们还将看到如何通过使用 WhatsApp
    账号直接与用户的智能手机进行交互，以便在某些事件发生时通知他们。
- en: The basics of functioning
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本工作原理
- en: Let's assume that our laundry room is equipped with a washing machine and a
    lamp used by the user when they have to pick up the laundry. In these conditions,
    the BeagleBone Black can be equipped with some special sensors to detect when
    the washing machine has started or finished its job and when someone goes into
    the laundry room to pick up the washed clothes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的洗衣房配备了一台洗衣机和一盏灯，用户在取衣服时会用到这盏灯。在这种情况下，BeagleBone Black 可以配备一些特殊传感器，用于检测洗衣机何时开始或完成工作，以及何时有人进入洗衣房取走洗好的衣物。
- en: In this scenario, the BeagleBone Black should detect when the washing machine
    has been started by the user and then wait until the job has finished. At this
    point, the system can generate a WhatsApp message to alert the user that they
    have to pick up their clothes. When the user enters into the room, the light is
    turned on, and when they leave the room, the light is turned off. In this manner,
    our BeagleBone Black can detect when the user has done their job and then restart
    the cycle.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，BeagleBone Black 应该能够检测到用户何时启动洗衣机，并在工作完成后等待。此时，系统可以生成一条 WhatsApp 消息，提醒用户取走衣服。当用户进入房间时，灯会亮起，当他们离开房间时，灯会熄灭。通过这种方式，我们的
    BeagleBone Black 可以检测到用户是否已完成任务，并重新启动循环。
- en: Setting up the hardware
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置硬件
- en: 'As just stated, in this project we need two different kind of sensors: one
    to detect when the washing machine starts/stop, and one to detect when someone
    enters/exits the laundry room. The former task can be achieved by using a sound
    detector, that is, a device that is able to measure the environment sound level;
    while the latter task can be achieved by using a light sensor, that is, a device
    that is able to measure the environment light. Both these signals can be compared
    with thresholds in order to detect our relevant events.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在本项目中，我们需要两种不同类型的传感器：一种用于检测洗衣机的启动/停止，另一种用于检测是否有人进出洗衣房。前者的任务可以通过使用声音传感器来实现，即能够测量环境声音水平的设备；而后者的任务可以通过使用光线传感器来实现，即能够测量环境光线的设备。我们可以将这两种信号与阈值进行比较，以便检测相关的事件。
- en: When the washing machine is running, we should measure a high sound level for
    a long amount of time; while it is not running, the environment sound should be
    near to zero for a long time. On the other hand, we can assume that the person
    designed to pick up the washed clothes has to turn the light on in the laundry
    room, while the light is normally turned off when there is nobody in the room.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当洗衣机运行时，我们应当测得较高的声音水平，且持续一段较长的时间；而当洗衣机未运行时，环境声音应接近零并持续一段较长的时间。另一方面，我们可以假设，负责取衣服的人需要在洗衣房内打开灯，而当房间里没有人的时候，灯通常是关闭的。
- en: To help the user understand what happens inside the system, we can add two LEDs
    that can be turned on/off or put in a blinking mode with special meanings (in
    the next section, I'm going to explain these meanings in detail).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助用户理解系统内部发生了什么，我们可以添加两颗 LED 灯，它们可以被打开/关闭或设置为闪烁模式，并赋予特定的含义（在下一节中，我将详细解释这些含义）。
- en: Setting up the sound detector
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置声音传感器
- en: 'The device to detect the environment sound used in this project is shown in
    the following image:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中用于检测环境声音的设备如下图所示：
- en: '![Setting up the sound detector](img/B00255_05_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![设置声音传感器](img/B00255_05_01.jpg)'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The devices can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/sound-detector](http://www.cosino.io/product/sound-detector).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备可以通过以下链接购买（或在网上搜索）：[http://www.cosino.io/product/sound-detector](http://www.cosino.io/product/sound-detector)。
- en: The board is based on the amplifier LMV324 with the datasheet available at [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf),
    while the board's schematic is available at [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该板基于放大器LMV324，数据手册可在[http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf)上查看，而该板的原理图可在[http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf)上查看。
- en: 'This device is very simple since it presents three outputs: the one labeled
    as **AUDIO** can be used to directly get the audio captured, while the output
    labeled **ENVELOPE** can be used to easily read the amplitude of sound by simply
    reading the analog voltage. The last output labeled **GATE** is a binary indication
    of the presence of the sound by using a fixed threshold (even if you can change
    it by changing the on-board resistors).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备非常简单，因为它提供了三个输出：标记为**AUDIO**的输出可以直接获取捕获的音频，而标记为**ENVELOPE**的输出则可以通过简单地读取模拟电压来轻松读取声音的幅度。最后一个标记为**GATE**的输出则是通过使用固定的阈值（尽管你可以通过改变板载电阻来改变阈值）来指示声音的存在。
- en: 'For our prototype, we can use the **ENVELOPE** output since we can read an
    analog voltage. Not only this, it allows us to set our own software threshold
    too. So, let''s see the connections in the following table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的原型，我们可以使用**ENVELOPE**输出，因为我们可以读取模拟电压。不仅如此，它还允许我们设置自己的软件阈值。因此，让我们看看下面表格中的连接：
- en: '| Pin | Sound Sensor Pin |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | 声音传感器引脚 |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| P9.4 - Vcc | VCC |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| P9.4 - Vcc | VCC |'
- en: '| P9.39 - AIN0 | R @ENVELOPE |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| P9.39 - AIN0 | R @ENVELOPE |'
- en: '| P9.3 - GND | GND |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| P9.3 - GND | GND |'
- en: As already mentioned in [Chapter 2](ch02.html "Chapter 2. Ultrasonic Parking
    Assistant"), *Ultrasonic Parking Assistant*, the ADC's input must be limited to
    1.8V and since the Vcc level is 3.3V, we can use the voltage divider proposed
    there in order to scale the output voltage by a factor of 2\. Be sure, then, that
    the maximum input level is not greater than 1.8V. So, the reader should not directly
    connect the *P9.39* pin with the sound detector; they should use the resistors
    connected as in [Chapter 2](ch02.html "Chapter 2. Ultrasonic Parking Assistant"),
    *Ultrasonic Parking Assistant*, to protect the BeagleBone Black's **ADC**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第二章](ch02.html "第二章：超声波停车助手")中所述，*超声波停车助手*，ADC的输入必须限制在1.8V，而Vcc电平是3.3V，因此我们可以使用那里提到的电压分压器来将输出电压按2倍的比例缩放。请确保最大输入电平不超过1.8V。因此，读者不应直接将*P9.39*引脚与声音传感器连接；他们应该使用[第二章](ch02.html
    "第二章：超声波停车助手")中所使用的电阻连接方式，来保护BeagleBone Black的**ADC**。
- en: 'Now, to verify that all the connections are okay, we enable the BeagleBone
    Black''s ADCs by using the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了验证所有连接是否正常，我们可以使用以下命令启用BeagleBone Black的ADC：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'These settings can be done by using the `bin/load_firmware.sh` script in the
    book''s example code repository as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置可以通过使用书中示例代码库中的`bin/load_firmware.sh`脚本来完成，具体如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we can read the captured sound envelope with the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令读取捕获的声音包络：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we try to speak while we rerun the command, we should get a higher value,
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在重新运行命令时尝试说话，我们应该得到更高的值，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, the higher the environment sound, the higher the returned value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，环境声音越大，返回的值也就越高。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Let me remind you again that, as stated in [Chapter 1](ch01.html "Chapter 1. Dangerous
    Gas Sensors"), *Dangerous Gas Sensors*, the ADC can also be read by using another
    file''s still in the `sysfs` filesystem with the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，如[第一章](ch01.html "第一章：危险气体传感器")中所述，*危险气体传感器*，也可以通过以下命令使用`sysfs`文件系统中另一个文件来读取ADC：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting up the light sensor
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置光传感器
- en: 'The light sensor is the device shown in the following image:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 光传感器是下图所示的设备：
- en: '![Setting up the light sensor](img/B00255_05_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![设置光传感器](img/B00255_05_02.jpg)'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The devices can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/light-sensor](http://www.cosino.io/product/light-sensor).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备可以通过以下链接购买（或通过上网搜索）：[http://www.cosino.io/product/light-sensor](http://www.cosino.io/product/light-sensor)。
- en: The user guide of this device is available at [http://www.phidgets.com/docs/1143_User_Guide](http://www.phidgets.com/docs/1143_User_Guide).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本设备的用户指南可在[http://www.phidgets.com/docs/1143_User_Guide](http://www.phidgets.com/docs/1143_User_Guide)中找到。
- en: 'As for the sound detector, this device has an analog output that can be used
    to measure the environment luminosity. According to the user guide, the luminosity
    can be obtained by using the following formula:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 至于声音传感器，这个设备有一个模拟输出，可以用来测量环境光照度。根据用户指南，光照度可以通过以下公式获得：
- en: '*Luminosity(lux) = e^(m*sensor_output+b)*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*光照度（lux） = e^(m*传感器输出 + b)*'
- en: Here, *sensor_output* is the raw value from the sensor, and the *m* and *b*
    are well-defined constants used to get a rough approximation. However, since we
    are only interested in measuring the light presence and not its precise intensity,
    we can use our own values or, to make it as simple as possible, the *sensor_output*
    value directly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*传感器输出*是传感器的原始值，*m*和*b*是用来获取粗略近似值的已定义常数。不过，由于我们只关心测量光的存在，而不是其精确强度，我们可以使用我们自己的值，或者为了简单起见，直接使用*传感器输出*值。
- en: In the user guide, we also read that even if the device needs a 5V Vcc to function,
    its output value will not exceed 2.5V. So, considering that our BeagleBone Black's
    ADC maximum input value is 1.8V, we can use the voltage divider as above to scale
    down the output value by 2, thus being sure that the 1.8V threshold is satisfied.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户指南中，我们还读到，即使设备需要5V的Vcc来工作，它的输出值不会超过2.5V。因此，考虑到我们的BeagleBone Black的ADC最大输入值为1.8V，我们可以使用上面提到的电压分压器将输出值缩小2倍，从而确保满足1.8V的阈值。
- en: 'The connections are as shown in the following table:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 连接方式如以下表格所示：
- en: '| Pin | Light sensor cable |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | 光传感器电缆 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| P9.6 - Vcc | red |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| P9.6 - Vcc | 红色 |'
- en: '| P9.40 - AIN1 | R @white |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| P9.40 - AIN1 | 红色 @white |'
- en: '| P9.1 - GND | black |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| P9.1 - GND | 黑色 |'
- en: 'Now, as done in the previous section for the sound detector, we can test the
    device by using the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像在上一节中对声音传感器的操作一样，我们可以通过以下命令来测试设备：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, if I put the device under a light, I get:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我将设备放在光线下，我得到：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Whereas if I cover the sensor with a cup of coffee, I get:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 而当我用一杯咖啡覆盖传感器时，我得到：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, as for the sound detector, the same rule exists: the higher the environment
    light intensity, the higher the returned value from the sensor.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于声音传感器，同样的规则适用：环境光强度越高，传感器返回的值越高。
- en: Connecting the LEDs
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接LED
- en: 'To connect the LEDs, we can use the same circuitry that was used in [Chapter
    1](ch01.html "Chapter 1. Dangerous Gas Sensors"), *Dangerous Gas Sensors*. The
    connections are reported in the following table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接LED，我们可以使用与[第1章](ch01.html "第1章：危险气体传感器")中相同的电路，*危险气体传感器*。连接方式见下表：
- en: '| Pin | LED color |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | LED颜色 |'
- en: '| --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| P8.9 - GPIO69 | R @red |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| P8.9 - GPIO69 | 红色 @red |'
- en: '| P8.10 - GPIO68 | R @yellow |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| P8.10 - GPIO68 | 红色 @yellow |'
- en: 'To test the connections, we can use the following commands to set up the lines
    as outputs and then to set them into a high state:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试连接，我们可以使用以下命令将线路设置为输出，然后将其设置为高电平状态：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If everything works well, you should see both LEDs turned on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该看到两个LED都亮起。
- en: The final picture
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终图片
- en: 'The following image shows the prototype I realized to implement this project
    and to test the software:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了我为实现这个项目并测试软件所做的原型：
- en: '![The final picture](img/B00255_05_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![最终图片](img/B00255_05_03.jpg)'
- en: Nothing special to say here, apart from the fact that you must provide a network
    connection for your BeagleBone Black; otherwise, the WhatsApp alerting service
    will not work! As you can see, I used a normal Ethernet cable, but let me remind
    that you can also use a USB connection with the host, as mentioned in the *Preface*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么特别要说的，除了你必须为你的BeagleBone Black提供网络连接，否则WhatsApp警报服务将无法工作！如你所见，我使用了普通的以太网电缆，但让我提醒你，你也可以使用USB连接到主机，正如在*前言*中提到的那样。
- en: Setting up the software
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置软件
- en: 'This time, to implement the software of this prototype, we can use a state-machine
    with the following states and their relative transactions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，为了实现这个原型的软件，我们可以使用一个状态机，包含以下状态及其相应的交易：
- en: '| State | Description | Actions | Transaction conditions |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 描述 | 操作 | 交易条件 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `IDLE` | Idle state; the washing machine is not working. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `IDLE` | 空闲状态；洗衣机未工作。 |'
- en: LED yellow off
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 黄色关闭
- en: LED red off
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 红色关闭
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If sound is detected, set `t0=t` and move state to `SOUND`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到声音，将`t0=t`并将状态切换为`SOUND`。
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `SOUND` | Sound detected! Keep monitoring the environment for a while. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `SOUND` | 检测到声音！请继续监控环境一段时间。 |'
- en: LED yellow is blinking
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 黄灯闪烁
- en: LED red is off
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 红灯熄灭
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If sound is detected and `t-t0 > timeout`, move to `RUNNING`.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到声音且 `t-t0 > timeout`，则切换到 `RUNNING` 状态。
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `RUNNING` | Continuous sound detected so the washing machine has started
    its job. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `RUNNING` | 检测到持续声音，因此洗衣机开始工作。 |'
- en: LED yellow is on
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 黄灯亮起
- en: LED red is off
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 红灯熄灭
- en: Alert the user
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提醒用户
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If no sound is detected, set `t0=t` and move to `NO_SOUND`.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未检测到声音，设置 `t0=t` 并切换到 `NO_SOUND` 状态。
- en: '|'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `NO_SOUND` | No more sound detected! Keep monitoring the environment for
    a while. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `NO_SOUND` | 不再检测到声音！请继续监控环境一段时间。 |'
- en: LED yellow is on
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 黄灯亮起
- en: LED red is blinking
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 红灯闪烁
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If no sound is detected and `t-t0 > timeout`, move to `DONE`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未检测到声音且 `t-t0 > timeout`，则切换到 `DONE` 状态。
- en: If sound is detected, move to `RUNNING`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到声音，切换到 `RUNNING` 状态。
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `DONE` | No more sound for a long delay; the washing machine has finished
    its job. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `DONE` | 长时间没有声音；洗衣机已完成工作。 |'
- en: LED yellow is on
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 黄灯亮起
- en: LED red is on
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 红灯亮起
- en: Alert the user
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提醒用户
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If light is detected, set `t0=t` and move state to `LIGHT`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到光线，设置 `t0=t` 并将状态切换到 `LIGHT`。
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `LIGHT` | Light detected! Keep monitoring the environment for a while. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `LIGHT` | 检测到光线！请继续监控环境一段时间。 |'
- en: LED yellow is blinking
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 黄灯闪烁
- en: LED red is on
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 红灯亮起
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If light is detected and `t-t0 > timeout`, move to `ROOM`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到光线且 `t-t0 > timeout`，则切换到 `ROOM` 状态。
- en: If no light is detected, move to `DONE`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未检测到光线，切换到 `DONE` 状态。
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `ROOM` | Light is continuously on; someone has entered into the laundry room.
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `ROOM` | 灯光持续亮起；有人进入洗衣房。 |'
- en: LED yellow is off
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 黄灯熄灭
- en: LED red is on
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 红灯亮起
- en: '|'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If no light is detected, set `t0=t` and move state to `NO_LIGHT`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未检测到光线，设置 `t0=t` 并将状态切换到 `NO_LIGHT`。
- en: '|'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `NO_LIGHT` | No more light detected! Keep monitoring the environment for
    a while. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `NO_LIGHT` | 不再检测到光线！请继续监控环境一段时间。 |'
- en: LED yellow is off
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 黄灯熄灭
- en: LED red is blinking
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED 红灯闪烁
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If no light is detected and `t-t0 > timeout`, move to `IDLE`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未检测到光线且 `t-t0 > timeout`，则切换到 `IDLE` 状态。
- en: '|'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The starting state is `IDLE` and the variable `t` holds the current time. `t0`
    is used to address a starting time, while the `timeout` value can be fixed to
    a suitable amount of time in order to avoid false positive (so, you should try
    different values to suite your needs).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 起始状态为 `IDLE`，变量 `t` 存储当前时间。`t0` 用来表示开始时间，而 `timeout` 值可以设置为适当的时间，以避免误判（因此，您应该尝试不同的值来适应您的需求）。
- en: For each state, if any of the transaction conditions are not met, the state-machine
    assumes that no transaction must have been done at all and it remains in the original
    state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个状态，如果任何交易条件未满足，状态机假定没有执行任何转换，并保持在原始状态。
- en: Another representation of the preceding table is given by the following screenshot,
    where all the states of our machine are represented by circles and the state transactions
    are represented by arrows with a corresponding label holding the state transaction
    condition (the squares are just actions to be done before moving from one state
    to another). This representation more clearly shows the conditions we need to
    move from one state to another and how the states are connected to each other.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格的另一种表示方式如下所示，其中我们机器的所有状态通过圆圈表示，状态转换通过箭头和相应的标签表示，标签中包含状态转换条件（方块只是表示在状态之间转换前需要执行的动作）。这种表示方式更加清晰地展示了我们从一个状态到另一个状态所需的条件，以及状态之间的连接方式。
- en: '![Setting up the software](img/B00255_05_04.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![设置软件](img/B00255_05_04.jpg)'
- en: The sound detector manager
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音检测器管理器
- en: 'Okay, now we should try to understand how we can detect when the washing machine
    is running and when it''s stopped. As already mentioned, the sound detector can
    help us distinguish these two states. In fact, by using the script in the `chapter_05/sample.sh`
    file in the book''s example code repository, we can plot a graph of some samples
    taken from an ADC input. The script is simple and a snippet of the relevant code
    is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们应该尝试理解如何检测洗衣机在运行和停止时的状态。如前所述，声音检测器可以帮助我们区分这两种状态。实际上，通过使用书中示例代码库中 `chapter_05/sample.sh`
    文件中的脚本，我们可以绘制从 ADC 输入采样得到的图表。该脚本很简单，相关代码片段如下：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first part of the script is simply a `while` loop used to read the ADC
    data at more or less 500 ms (the script is in Bash, so don''t expect too much
    precision from it). When the user strikes the *CTRL* + *C* keys, they generate
    a signal which is trapped by the `sig_handler` signal handler that simply sets
    the `do_exit` variable to `true`, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第一部分仅仅是一个`while`循环，用于每500毫秒左右读取ADC数据（脚本是Bash编写的，所以不要期望太高的精度）。当用户按下*CTRL*
    + *C*键时，它们会生成一个信号，该信号被`sig_handler`信号处理程序捕获，该处理程序简单地将`do_exit`变量设置为`true`，如下所示：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `tee` command is used to display the sampled data to the terminal and to
    save them in the `sample.log` file at the same time. Once the data are collected,
    we use the `gnuplot` tool to generate the graph in a similar way as done in [Chapter
    1](ch01.html "Chapter 1. Dangerous Gas Sensors"), *Dangerous Gas Sensors*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee`命令用于将采样数据显示到终端并同时保存到`sample.log`文件中。一旦数据被收集，我们使用`gnuplot`工具生成图表的方法与[第一章](ch01.html
    "第一章. 危险气体传感器") *危险气体传感器* 中所做的类似。'
- en: 'The following is a sample demo I did on my prototype. In the middle of the
    test, I discussed the letter *A* in order to produce a detectable sound level:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我在原型机上做的一个样品演示。在测试的中间，我讨论了字母*A*以产生可检测的声音水平：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see in the preceding output where I just used my voice, I can easily
    distinguish sound absence or presence. However, the following screenshot, taken
    from the `sample.png` file generated by the preceding script, is more explicative:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的输出中所看到的，我只是用了我的声音，就可以轻松区分声音的存在或不存在。然而，以下屏幕截图是从前述脚本生成的`sample.png`文件中获取的，更具说明性：
- en: '![The sound detector manager](img/B00255_05_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![声音检测管理器](img/B00255_05_05.jpg)'
- en: It's clear that just by using a threshold of 200, we can do the trick.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，只需使用阈值为200，我们就可以搞定。
- en: The light sensor manager
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光传感器管理器
- en: The light sensor functioning is very similar to the sound one, so we can use
    the same `sample.sh` script to get some samples from it. This time, I simulate
    the light absence/presence by simply covering the light sensor with a small cup.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 光传感器的功能与声音传感器非常相似，因此我们可以使用相同的`sample.sh`脚本来从中获取一些样本。这次，我通过简单地用小杯子盖住光传感器来模拟光的缺失/存在。
- en: 'The command used is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的命令如下所示：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the corresponding plot is shown in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的绘图如下所示：
- en: '![The light sensor manager](img/B00255_05_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![光传感器管理器](img/B00255_05_06.jpg)'
- en: Even in this case, we can use a threshold of 200 to distinguish between the
    two states.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这种情况下，我们可以使用阈值200来区分这两种状态。
- en: Controlling the LEDs
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制LED
- en: As already shown in [Chapter 1](ch01.html "Chapter 1. Dangerous Gas Sensors"),
    *Dangerous Gas Sensors*, or in [Chapter 2,](ch02.html "Chapter 2. Ultrasonic Parking
    Assistant") *Ultrasonic Parking Assistant*, there are two different manners of
    managing LED in a Linux-based system. The first is by using GPIO and the second
    is by using LED device; but, since our state-machine requires that the LEDs should
    blink, we should use the LED management method that allows us to use a trigger
    to get a blinking status.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第一章](ch01.html "第一章. 危险气体传感器") *危险气体传感器* 或[第二章](ch02.html "第二章. 超声波停车助手")
    *超声波停车助手* 中已经显示的，Linux系统中管理LED有两种不同的方式。第一种是使用GPIO，第二种是使用LED设备；但是，由于我们的状态机要求LED应该闪烁，我们应该使用允许我们使用触发器获取闪烁状态的LED管理方法。
- en: 'Similarly, as done in [Chapter 2](ch02.html "Chapter 2. Ultrasonic Parking
    Assistant"), *Ultrasonic Parking Assistant*, we need a proper `.dts` file that
    the reader can find in the `chapter_05/BB-LEDS-C5-00A0.dts` file in the book''s
    example code repository. After finding it, we have to compile it with the following
    command line:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如同在[第二章](ch02.html "第二章. 超声波停车助手") *超声波停车助手* 中所做的那样，我们需要一个合适的`.dts`文件，读者可以在书中示例代码库的`chapter_05/BB-LEDS-C5-00A0.dts`文件中找到。找到后，我们必须使用以下命令行编译它：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can enable it by using the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令启用它：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then, two new LEDs are now available in the system, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，系统中现在有两个新的LED，如下所示：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Setting up the WhatsApp API
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 WhatsApp API
- en: Now it's time to show you how we can interact with the **WhatsApp** service.
    In this project, we simply need to send messages to the user's account, but even
    this simple task needs us to accomplish several steps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向您展示如何与**WhatsApp**服务进行交互了。在这个项目中，我们只需要向用户的账户发送消息，但即使是这么简单的任务，也需要我们完成几个步骤。
- en: 'First of all, we must install some prerequisite packages into our BeagleBone
    Black, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在BeagleBone Black上安装一些前提软件包，如下所示：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we have to install the package named `yowsup` that we can use to send
    our messages via WhatsApp:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装一个名为`yowsup`的软件包，它可以用来通过WhatsApp发送消息：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The wiki page of the `yowsup` tool is at [https://github.com/tgalal/yowsup/wiki](https://github.com/tgalal/yowsup/wiki).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`yowsup`工具的维基页面在[https://github.com/tgalal/yowsup/wiki](https://github.com/tgalal/yowsup/wiki)。'
- en: 'When the installation is finished, we can use the following command to get
    a sample configuration file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以使用以下命令来获取一个示例配置文件：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The new file `yowsup-cli.config` should now hold the following lines:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 新的文件`yowsup-cli.config`现在应该包含以下几行：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lines starting with the character # are comments and they can be removed so
    the important lines are:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以#字符开头的行是注释，可以删除，重要的行如下：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the `id=` line may not be present.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`id=` 行可能不存在。
- en: In the preceding example, for privacy reasons I replaced my phone number with
    the `X` characters, but you have to put your phone number here in order to get
    access to the system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，为了保护隐私，我将我的电话号码替换成了`X`字符，但你必须在此处输入你的电话号码，以便访问系统。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that you cannot use a phone number when you actually already use WhatsApp
    or else you're going to get into conflict with the WhatsApp client you are using
    on your smartphone. That's why I used a phone number when no WhatsApp services
    are active.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你已经在使用WhatsApp时，无法使用该电话号码，否则会与你在智能手机上使用的WhatsApp客户端产生冲突。这就是为什么我在没有激活WhatsApp服务时使用了一个电话号码。
- en: Simply speaking, you don't need the WhatsApp client running on the phone that
    is receiving the SMS!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，你不需要在接收短信的手机上运行WhatsApp客户端！
- en: 'Once you have added a phone number, you can put it into the preceding `yowsup-cli.config`
    configuration file, leaving the lines with the `id` and `password` variables unassigned.
    Then, the following command must be executed:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了一个电话号码，你可以将其放入前面的`yowsup-cli.config`配置文件中，并保持`id`和`password`变量的行未分配。然后，必须执行以下命令：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After a while, the command should answer as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一会儿，命令应该会回应如下信息：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, you should receive an SMS on the phone with your number. You just need
    the information inside the message itself; in fact, the SMS should hold a message
    like `WhatsApp code 633-170`, so you have to use the following command to finish
    the registration:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该会收到一条短信，短信内容会显示你号码的信息；你只需要短信中的信息即可；实际上，短信内容应该类似于`WhatsApp code 633-170`，因此你需要使用以下命令完成注册：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If everything works well, the preceding command should answer, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，前面的命令应该会输出如下信息：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The important information here is the password that we must use to correctly
    log in into our new WhatsApp account. The password is the field `pw`, so after
    putting this information into the `password` field of the configuration file,
    the new look of the `yowsup-cli.config` file should be as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要信息是我们必须使用的密码，以便正确登录我们的新WhatsApp账户。密码在`pw`字段中，因此在将此信息填入配置文件中的`password`字段后，`yowsup-cli.config`文件的新样式应如下所示：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we are ready to log in into our new account and send messages from it!
    For example, the following command line can be used to send a message from the
    command line:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以登录到我们的新账户，并从中发送消息了！例如，可以使用以下命令行从命令行发送消息：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that I used another phone number as the destination number, obscured as
    `39YYYYYYYYYY`, to distinguish it from the transmitter one used before.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用了另一个电话号码作为目标号码，隐藏为`39YYYYYYYYYY`，以便与之前使用的发送号码区分开。
- en: Tip
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The warning message can be safely ignored.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 警告信息可以安全地忽略。
- en: Also, it may happen that the first time you execute the command, you get no
    a "Message Sent" output. In this case, try to rerun the command.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也可能发生第一次执行命令时，未显示“Message Sent”输出。在这种情况下，请尝试重新执行该命令。
- en: Okay, now everything is in place and we just need to see how the state-machine
    can be implemented. So let's move to the next section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在一切都准备好了，我们只需要看看如何实现状态机。接下来我们进入下一节。
- en: The state-machine
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机
- en: Now that every subsystem has been set up, it's time to take a look at a possible
    implementation of the state-machine described before. The complete code is so
    simple that it has been developed in Bash and it can be found in the `chapter_05/state_machine.sh`
    file in the book's example code repository. However, the following are some snippets
    of the relevant code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个子系统都已设置完成，是时候看看之前描述的状态机的可能实现了。完整的代码非常简单，已用 Bash 开发，并可以在书中的示例代码库中的`chapter_05/state_machine.sh`文件中找到。以下是相关代码的几个片段。
- en: 'The first snippet is about the configuration file reading, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个片段是关于配置文件读取的，如下所示：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After some initial settings, the code sources the `config.sh` file that holds
    the system settings (see the last section for an example of this file), and then
    the settings variables are checked up. Then, the code continues defining the sensor''s
    reading functions. In the following snippet, I reported only one of these functions
    since they are very similar:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些初始设置后，代码会加载包含系统设置的`config.sh`文件（有关该文件的示例，请参见最后一节），然后检查设置变量。接着，代码继续定义传感器的读取函数。在以下代码片段中，我只展示了其中一个函数，因为它们非常相似：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The function simply reads the ADC and checks the datum against a specified threshold.
    The returned value is `0` or `1`, according to the absence/presence of the sound
    or light. Note that in case of errors in reading the datum, the function retries
    the operation until a successful reading.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数简单地读取 ADC 并将数据与指定的阈值进行比较。返回的值是`0`或`1`，取决于声音或光的有无。请注意，如果读取数据时发生错误，函数会重试操作直到成功读取。
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Here, we should add a retries limit in order to avoid an infinite loop. But
    for the sake of simplicity, I decided to not implement it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该添加一个重试次数限制，以避免进入无限循环。但为了简化，我决定不实现它。
- en: 'The LED''s management section looks as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: LED 管理部分如下所示：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `set_led` function simply sets the LED status according to the system status
    passed by the `signal_status` function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_led`函数根据`signal_status`函数传递的系统状态简单地设置 LED 状态。'
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the `signal_status` function can be implemented in a more compact
    manner (maybe by using an associative array), but this form is more readable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`signal_status`函数可以更紧凑地实现（可能通过使用关联数组），但这种形式更具可读性。
- en: 'Then, the code of the function to send the alerting messages via WhatsApp system
    is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过 WhatsApp 系统发送警报消息的函数代码如下：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, the core of the whole project is the `change_status` function. This is
    the function that implements the state-machine. It decides which is the new status
    according to the current one and the system''s inputs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个项目的核心是`change_status`函数。这个函数实现了状态机。它根据当前状态和系统输入决定新的状态：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can verify that this function correctly implements the state-machine table
    (or graph) presented previously in this chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以验证这个函数是否正确地实现了本章之前展示的状态机表（或图）。
- en: 'At this point, the core of the main function looks like the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，主函数的核心看起来如下所示：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the `main` function is just a big loop that periodically reads
    the sensor's inputs and then changes the system's internal status according to
    it, sending some alerts when needed and setting the LED's statuses accordingly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`main`函数只是一个大循环，它定期读取传感器输入，然后根据输入更改系统的内部状态，在需要时发送一些警报，并相应地设置 LED 的状态。
- en: Final test
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终测试
- en: To test the prototype, I used some tricks to simulate the washing machine and
    the light in the room. The washing machine can be easily simulated by an audio/video
    played on the host PC with a reasonable volume level, while the room light on/off
    status can be simulated by using a small cup to cover the light sensor.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试原型，我使用了一些技巧来模拟洗衣机和房间里的灯。洗衣机可以通过在主机 PC 上播放音频/视频并调节合理的音量来轻松模拟，而房间灯的开/关状态可以通过用小杯子遮住光传感器来模拟。
- en: 'To set up all peripherals and drivers, we can use all the preceding commands
    or the `SYSINIT.sh` script as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置所有外设和驱动程序，我们可以使用所有前面的命令或`SYSINIT.sh`脚本，如下所示：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This command can be found in the `chapter_05/SYSINIT.sh` file in the book's
    example code repository
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令可以在书中示例代码库中的`chapter_05/SYSINIT.sh`文件中找到
- en: 'As an initial state (`IDLE`), we should cover the light sensor (to simulate
    that the light is off) and we should stop the video/audio player (to simulate
    that the washing machine is off). Then, we have to set a low threshold level into
    the configuration file for both sound and light detection and a very short timeout
    (`5` seconds) in order to speed up the test. The following is my configuration
    file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初始状态（`IDLE`），我们应该覆盖光传感器（以模拟灯关了）并停止视频/音频播放器（以模拟洗衣机关了）。然后，我们需要在配置文件中设置音频和光检测的低阈值，并设置一个非常短的超时（`5`秒）以加速测试。以下是我的配置文件：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, I started the system, enabling all debugging messages on the terminal,
    by using the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我启动了系统，并通过以下命令在终端启用了所有调试消息：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the initial state is `IDLE` and nothing changes until no new events
    are detected.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，初始状态是`IDLE`，在没有检测到新事件之前，状态不会发生变化。
- en: 'In the next output listing, I''m going to use the `...` characters to skip
    non-relevant lines:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的输出列表中，我将使用`...`字符跳过不相关的行：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now I''m going to simulate the following situation: first, I turn on the washing
    machine and wait for the end of its job. Then, I go to the laundry room to pick
    up my washed clothes. As already said before, I''m going to simulate the running
    washing machine with a video/audio player while the light on/off is simulated
    by uncovering/covering the light sensor with a cup.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将模拟以下情况：首先，我打开洗衣机并等待它完成工作。然后，我去洗衣房拿我的洗净衣物。如前所述，我将通过视频/音频播放器来模拟运行中的洗衣机，而开/关灯则通过揭开/覆盖光传感器来模拟。
- en: 'Okay, the test begins. After a while, I start the video/audio player. So, a
    sound has been detected and the new state turns to `SOUND`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，测试开始了。过了一会儿，我启动了视频/音频播放器。所以，检测到了声音，新的状态变为`SOUND`：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Ouch! For a moment, the sound level went under the threshold, so we switched
    again to the `IDLE` state! This is correct because it may happen that the washing
    machine stops for a while. Here is where the `timeout` enters in action, that
    is, we have to select it for longer than all the possible washing machine''s pauses:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！有一瞬间，声音水平低于阈值，所以我们又切换回了`IDLE`状态！这是正确的，因为洗衣机可能会暂时停下来。这里就是`timeout`起作用的地方，也就是说，我们必须选择比所有可能的洗衣机暂停时间更长的超时：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This an error during the reading of the ADC input, but the software is written
    to retry the faulty operation without problems:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是读取 ADC 输入时的一个错误，但软件已编写为在没有问题的情况下重试故障操作：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Good! When the timeout expires while we are into the `SOUND` state, it means
    that a continuous sound has been detected, so it means that the washing machine
    has started its job.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！当超时在`SOUND`状态下过期时，意味着已经检测到持续的声音，这意味着洗衣机已经开始工作。
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that a more reliable implementation should use different timeouts to identify
    a specific transaction.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，更可靠的实现应该使用不同的超时来标识特定的事务。
- en: 'This is demonstrated in the following snippet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段展示了这一点：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, I have stopped the video/audio player and no sound has been detected,
    so we switch to the `NO_SOUND` state:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已停止了视频/音频播放器，并且没有检测到声音，因此我们切换到`NO_SOUND`状态：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Okay, when the timeout expires when we are in the `NO_SOUND` state, we switch
    to the `DONE` state to signal that the washing machine has finished its job:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，当我们在`NO_SOUND`状态下超时过期时，我们切换到`DONE`状态，表示洗衣机已经完成了工作：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, I have uncovered the light sensor to simulate that someone has turned
    on the light in the laundry room:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经揭开了光传感器，以模拟有人在洗衣房里打开了灯：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Again, the timeout has expired, so we can consider that the light has been
    on for a long time, which means that the user has received our WhatsApp message
    and they have come into the laundry room to pick up the laundry:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于超时已过，我们可以认为灯已经开了很长时间，这意味着用户已经收到了我们的 WhatsApp 消息并且进入了洗衣房拿取洗好的衣物：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, I have covered the light sensor again to simulate that the light in the
    laundry room has been turned off:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我再次覆盖了光传感器，以模拟洗衣房里的灯已经关闭：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the end, after `timeout` has expired, we can return to the `IDLE` state waiting
    for a new cycle to begin.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`timeout`超时后，我们可以返回到`IDLE`状态，等待新一轮循环的开始。
- en: 'The following is the screenshot of my smartphone showing the WhatsApp activity:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我的智能手机显示 WhatsApp 活动的截图：
- en: '![Final test](img/B00255_05_07.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![最终测试](img/B00255_05_07.jpg)'
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered how to detect sound and light levels by using
    specific sensors and how to write a simple Bash script to implement a state machine
    to manage our laundry room. Also, we discovered how to send some alerting messages
    to a smartphone through the WhatsApp service.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何使用特定的传感器检测声音和光线的强度，并学习了如何编写一个简单的 Bash 脚本来实现一个状态机，用以管理我们的洗衣房。此外，我们还了解了如何通过
    WhatsApp 服务向智能手机发送一些警报信息。
- en: In the next chapter, we'll try to implement a baby room sentinel to control
    what happens to our little baby! We'll be able to monitor the room temperature,
    detect if the baby is crying or if she is actually breathing, and much more.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将尝试实现一个婴儿房间守卫来控制我们的小宝宝的情况！我们将能够监控房间温度，检测宝宝是否在哭泣，或者她是否正在呼吸，还有更多功能。
