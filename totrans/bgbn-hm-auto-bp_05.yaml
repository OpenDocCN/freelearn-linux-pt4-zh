- en: Chapter 5. WhatsApp Laundry Room Monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll see how to implement a laundry monitor room with several
    sensors capable of alerting the user directly on their WhatsApp account when a
    specific event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see how to connect a sound sensor and a light sensor to our BeagleBone
    Black and then how we can monitor our washing machine with them. Also, we'll see
    how we can interact with the user directly on the user's smartphone by using a
    WhatsApp account in order to notify them of some events.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of functioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that our laundry room is equipped with a washing machine and a
    lamp used by the user when they have to pick up the laundry. In these conditions,
    the BeagleBone Black can be equipped with some special sensors to detect when
    the washing machine has started or finished its job and when someone goes into
    the laundry room to pick up the washed clothes.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the BeagleBone Black should detect when the washing machine
    has been started by the user and then wait until the job has finished. At this
    point, the system can generate a WhatsApp message to alert the user that they
    have to pick up their clothes. When the user enters into the room, the light is
    turned on, and when they leave the room, the light is turned off. In this manner,
    our BeagleBone Black can detect when the user has done their job and then restart
    the cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As just stated, in this project we need two different kind of sensors: one
    to detect when the washing machine starts/stop, and one to detect when someone
    enters/exits the laundry room. The former task can be achieved by using a sound
    detector, that is, a device that is able to measure the environment sound level;
    while the latter task can be achieved by using a light sensor, that is, a device
    that is able to measure the environment light. Both these signals can be compared
    with thresholds in order to detect our relevant events.'
  prefs: []
  type: TYPE_NORMAL
- en: When the washing machine is running, we should measure a high sound level for
    a long amount of time; while it is not running, the environment sound should be
    near to zero for a long time. On the other hand, we can assume that the person
    designed to pick up the washed clothes has to turn the light on in the laundry
    room, while the light is normally turned off when there is nobody in the room.
  prefs: []
  type: TYPE_NORMAL
- en: To help the user understand what happens inside the system, we can add two LEDs
    that can be turned on/off or put in a blinking mode with special meanings (in
    the next section, I'm going to explain these meanings in detail).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the sound detector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The device to detect the environment sound used in this project is shown in
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the sound detector](img/B00255_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The devices can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/sound-detector](http://www.cosino.io/product/sound-detector).'
  prefs: []
  type: TYPE_NORMAL
- en: The board is based on the amplifier LMV324 with the datasheet available at [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf),
    while the board's schematic is available at [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'This device is very simple since it presents three outputs: the one labeled
    as **AUDIO** can be used to directly get the audio captured, while the output
    labeled **ENVELOPE** can be used to easily read the amplitude of sound by simply
    reading the analog voltage. The last output labeled **GATE** is a binary indication
    of the presence of the sound by using a fixed threshold (even if you can change
    it by changing the on-board resistors).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our prototype, we can use the **ENVELOPE** output since we can read an
    analog voltage. Not only this, it allows us to set our own software threshold
    too. So, let''s see the connections in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | Sound Sensor Pin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P9.4 - Vcc | VCC |'
  prefs: []
  type: TYPE_TB
- en: '| P9.39 - AIN0 | R @ENVELOPE |'
  prefs: []
  type: TYPE_TB
- en: '| P9.3 - GND | GND |'
  prefs: []
  type: TYPE_TB
- en: As already mentioned in [Chapter 2](ch02.html "Chapter 2. Ultrasonic Parking
    Assistant"), *Ultrasonic Parking Assistant*, the ADC's input must be limited to
    1.8V and since the Vcc level is 3.3V, we can use the voltage divider proposed
    there in order to scale the output voltage by a factor of 2\. Be sure, then, that
    the maximum input level is not greater than 1.8V. So, the reader should not directly
    connect the *P9.39* pin with the sound detector; they should use the resistors
    connected as in [Chapter 2](ch02.html "Chapter 2. Ultrasonic Parking Assistant"),
    *Ultrasonic Parking Assistant*, to protect the BeagleBone Black's **ADC**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to verify that all the connections are okay, we enable the BeagleBone
    Black''s ADCs by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These settings can be done by using the `bin/load_firmware.sh` script in the
    book''s example code repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can read the captured sound envelope with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to speak while we rerun the command, we should get a higher value,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, the higher the environment sound, the higher the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let me remind you again that, as stated in [Chapter 1](ch01.html "Chapter 1. Dangerous
    Gas Sensors"), *Dangerous Gas Sensors*, the ADC can also be read by using another
    file''s still in the `sysfs` filesystem with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the light sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The light sensor is the device shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the light sensor](img/B00255_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The devices can be purchased at the following link (or by surfing the Internet):
    [http://www.cosino.io/product/light-sensor](http://www.cosino.io/product/light-sensor).'
  prefs: []
  type: TYPE_NORMAL
- en: The user guide of this device is available at [http://www.phidgets.com/docs/1143_User_Guide](http://www.phidgets.com/docs/1143_User_Guide).
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the sound detector, this device has an analog output that can be used
    to measure the environment luminosity. According to the user guide, the luminosity
    can be obtained by using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Luminosity(lux) = e^(m*sensor_output+b)*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *sensor_output* is the raw value from the sensor, and the *m* and *b*
    are well-defined constants used to get a rough approximation. However, since we
    are only interested in measuring the light presence and not its precise intensity,
    we can use our own values or, to make it as simple as possible, the *sensor_output*
    value directly.
  prefs: []
  type: TYPE_NORMAL
- en: In the user guide, we also read that even if the device needs a 5V Vcc to function,
    its output value will not exceed 2.5V. So, considering that our BeagleBone Black's
    ADC maximum input value is 1.8V, we can use the voltage divider as above to scale
    down the output value by 2, thus being sure that the 1.8V threshold is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The connections are as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | Light sensor cable |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P9.6 - Vcc | red |'
  prefs: []
  type: TYPE_TB
- en: '| P9.40 - AIN1 | R @white |'
  prefs: []
  type: TYPE_TB
- en: '| P9.1 - GND | black |'
  prefs: []
  type: TYPE_TB
- en: 'Now, as done in the previous section for the sound detector, we can test the
    device by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if I put the device under a light, I get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas if I cover the sensor with a cup of coffee, I get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as for the sound detector, the same rule exists: the higher the environment
    light intensity, the higher the returned value from the sensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the LEDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect the LEDs, we can use the same circuitry that was used in [Chapter
    1](ch01.html "Chapter 1. Dangerous Gas Sensors"), *Dangerous Gas Sensors*. The
    connections are reported in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pin | LED color |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| P8.9 - GPIO69 | R @red |'
  prefs: []
  type: TYPE_TB
- en: '| P8.10 - GPIO68 | R @yellow |'
  prefs: []
  type: TYPE_TB
- en: 'To test the connections, we can use the following commands to set up the lines
    as outputs and then to set them into a high state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If everything works well, you should see both LEDs turned on.
  prefs: []
  type: TYPE_NORMAL
- en: The final picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following image shows the prototype I realized to implement this project
    and to test the software:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The final picture](img/B00255_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nothing special to say here, apart from the fact that you must provide a network
    connection for your BeagleBone Black; otherwise, the WhatsApp alerting service
    will not work! As you can see, I used a normal Ethernet cable, but let me remind
    that you can also use a USB connection with the host, as mentioned in the *Preface*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, to implement the software of this prototype, we can use a state-machine
    with the following states and their relative transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| State | Description | Actions | Transaction conditions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IDLE` | Idle state; the washing machine is not working. |'
  prefs: []
  type: TYPE_TB
- en: LED yellow off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED red off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If sound is detected, set `t0=t` and move state to `SOUND`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `SOUND` | Sound detected! Keep monitoring the environment for a while. |'
  prefs: []
  type: TYPE_TB
- en: LED yellow is blinking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED red is off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If sound is detected and `t-t0 > timeout`, move to `RUNNING`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `RUNNING` | Continuous sound detected so the washing machine has started
    its job. |'
  prefs: []
  type: TYPE_TB
- en: LED yellow is on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED red is off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alert the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If no sound is detected, set `t0=t` and move to `NO_SOUND`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `NO_SOUND` | No more sound detected! Keep monitoring the environment for
    a while. |'
  prefs: []
  type: TYPE_TB
- en: LED yellow is on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED red is blinking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If no sound is detected and `t-t0 > timeout`, move to `DONE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If sound is detected, move to `RUNNING`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `DONE` | No more sound for a long delay; the washing machine has finished
    its job. |'
  prefs: []
  type: TYPE_TB
- en: LED yellow is on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED red is on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alert the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If light is detected, set `t0=t` and move state to `LIGHT`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `LIGHT` | Light detected! Keep monitoring the environment for a while. |'
  prefs: []
  type: TYPE_TB
- en: LED yellow is blinking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED red is on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If light is detected and `t-t0 > timeout`, move to `ROOM`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no light is detected, move to `DONE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `ROOM` | Light is continuously on; someone has entered into the laundry room.
    |'
  prefs: []
  type: TYPE_TB
- en: LED yellow is off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED red is on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If no light is detected, set `t0=t` and move state to `NO_LIGHT`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `NO_LIGHT` | No more light detected! Keep monitoring the environment for
    a while. |'
  prefs: []
  type: TYPE_TB
- en: LED yellow is off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED red is blinking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If no light is detected and `t-t0 > timeout`, move to `IDLE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The starting state is `IDLE` and the variable `t` holds the current time. `t0`
    is used to address a starting time, while the `timeout` value can be fixed to
    a suitable amount of time in order to avoid false positive (so, you should try
    different values to suite your needs).
  prefs: []
  type: TYPE_NORMAL
- en: For each state, if any of the transaction conditions are not met, the state-machine
    assumes that no transaction must have been done at all and it remains in the original
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Another representation of the preceding table is given by the following screenshot,
    where all the states of our machine are represented by circles and the state transactions
    are represented by arrows with a corresponding label holding the state transaction
    condition (the squares are just actions to be done before moving from one state
    to another). This representation more clearly shows the conditions we need to
    move from one state to another and how the states are connected to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the software](img/B00255_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The sound detector manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okay, now we should try to understand how we can detect when the washing machine
    is running and when it''s stopped. As already mentioned, the sound detector can
    help us distinguish these two states. In fact, by using the script in the `chapter_05/sample.sh`
    file in the book''s example code repository, we can plot a graph of some samples
    taken from an ADC input. The script is simple and a snippet of the relevant code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the script is simply a `while` loop used to read the ADC
    data at more or less 500 ms (the script is in Bash, so don''t expect too much
    precision from it). When the user strikes the *CTRL* + *C* keys, they generate
    a signal which is trapped by the `sig_handler` signal handler that simply sets
    the `do_exit` variable to `true`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `tee` command is used to display the sampled data to the terminal and to
    save them in the `sample.log` file at the same time. Once the data are collected,
    we use the `gnuplot` tool to generate the graph in a similar way as done in [Chapter
    1](ch01.html "Chapter 1. Dangerous Gas Sensors"), *Dangerous Gas Sensors*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample demo I did on my prototype. In the middle of the
    test, I discussed the letter *A* in order to produce a detectable sound level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding output where I just used my voice, I can easily
    distinguish sound absence or presence. However, the following screenshot, taken
    from the `sample.png` file generated by the preceding script, is more explicative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The sound detector manager](img/B00255_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's clear that just by using a threshold of 200, we can do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: The light sensor manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The light sensor functioning is very similar to the sound one, so we can use
    the same `sample.sh` script to get some samples from it. This time, I simulate
    the light absence/presence by simply covering the light sensor with a small cup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command used is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the corresponding plot is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The light sensor manager](img/B00255_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even in this case, we can use a threshold of 200 to distinguish between the
    two states.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the LEDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As already shown in [Chapter 1](ch01.html "Chapter 1. Dangerous Gas Sensors"),
    *Dangerous Gas Sensors*, or in [Chapter 2,](ch02.html "Chapter 2. Ultrasonic Parking
    Assistant") *Ultrasonic Parking Assistant*, there are two different manners of
    managing LED in a Linux-based system. The first is by using GPIO and the second
    is by using LED device; but, since our state-machine requires that the LEDs should
    blink, we should use the LED management method that allows us to use a trigger
    to get a blinking status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, as done in [Chapter 2](ch02.html "Chapter 2. Ultrasonic Parking
    Assistant"), *Ultrasonic Parking Assistant*, we need a proper `.dts` file that
    the reader can find in the `chapter_05/BB-LEDS-C5-00A0.dts` file in the book''s
    example code repository. After finding it, we have to compile it with the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can enable it by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, two new LEDs are now available in the system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the WhatsApp API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it's time to show you how we can interact with the **WhatsApp** service.
    In this project, we simply need to send messages to the user's account, but even
    this simple task needs us to accomplish several steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we must install some prerequisite packages into our BeagleBone
    Black, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to install the package named `yowsup` that we can use to send
    our messages via WhatsApp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The wiki page of the `yowsup` tool is at [https://github.com/tgalal/yowsup/wiki](https://github.com/tgalal/yowsup/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the installation is finished, we can use the following command to get
    a sample configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The new file `yowsup-cli.config` should now hold the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines starting with the character # are comments and they can be removed so
    the important lines are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `id=` line may not be present.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, for privacy reasons I replaced my phone number with
    the `X` characters, but you have to put your phone number here in order to get
    access to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you cannot use a phone number when you actually already use WhatsApp
    or else you're going to get into conflict with the WhatsApp client you are using
    on your smartphone. That's why I used a phone number when no WhatsApp services
    are active.
  prefs: []
  type: TYPE_NORMAL
- en: Simply speaking, you don't need the WhatsApp client running on the phone that
    is receiving the SMS!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have added a phone number, you can put it into the preceding `yowsup-cli.config`
    configuration file, leaving the lines with the `id` and `password` variables unassigned.
    Then, the following command must be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After a while, the command should answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you should receive an SMS on the phone with your number. You just need
    the information inside the message itself; in fact, the SMS should hold a message
    like `WhatsApp code 633-170`, so you have to use the following command to finish
    the registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything works well, the preceding command should answer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The important information here is the password that we must use to correctly
    log in into our new WhatsApp account. The password is the field `pw`, so after
    putting this information into the `password` field of the configuration file,
    the new look of the `yowsup-cli.config` file should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to log in into our new account and send messages from it!
    For example, the following command line can be used to send a message from the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that I used another phone number as the destination number, obscured as
    `39YYYYYYYYYY`, to distinguish it from the transmitter one used before.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The warning message can be safely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it may happen that the first time you execute the command, you get no
    a "Message Sent" output. In this case, try to rerun the command.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now everything is in place and we just need to see how the state-machine
    can be implemented. So let's move to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The state-machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that every subsystem has been set up, it's time to take a look at a possible
    implementation of the state-machine described before. The complete code is so
    simple that it has been developed in Bash and it can be found in the `chapter_05/state_machine.sh`
    file in the book's example code repository. However, the following are some snippets
    of the relevant code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first snippet is about the configuration file reading, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After some initial settings, the code sources the `config.sh` file that holds
    the system settings (see the last section for an example of this file), and then
    the settings variables are checked up. Then, the code continues defining the sensor''s
    reading functions. In the following snippet, I reported only one of these functions
    since they are very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The function simply reads the ADC and checks the datum against a specified threshold.
    The returned value is `0` or `1`, according to the absence/presence of the sound
    or light. Note that in case of errors in reading the datum, the function retries
    the operation until a successful reading.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we should add a retries limit in order to avoid an infinite loop. But
    for the sake of simplicity, I decided to not implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The LED''s management section looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `set_led` function simply sets the LED status according to the system status
    passed by the `signal_status` function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `signal_status` function can be implemented in a more compact
    manner (maybe by using an associative array), but this form is more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code of the function to send the alerting messages via WhatsApp system
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the core of the whole project is the `change_status` function. This is
    the function that implements the state-machine. It decides which is the new status
    according to the current one and the system''s inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can verify that this function correctly implements the state-machine table
    (or graph) presented previously in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the core of the main function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `main` function is just a big loop that periodically reads
    the sensor's inputs and then changes the system's internal status according to
    it, sending some alerts when needed and setting the LED's statuses accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Final test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test the prototype, I used some tricks to simulate the washing machine and
    the light in the room. The washing machine can be easily simulated by an audio/video
    played on the host PC with a reasonable volume level, while the room light on/off
    status can be simulated by using a small cup to cover the light sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up all peripherals and drivers, we can use all the preceding commands
    or the `SYSINIT.sh` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This command can be found in the `chapter_05/SYSINIT.sh` file in the book's
    example code repository
  prefs: []
  type: TYPE_NORMAL
- en: 'As an initial state (`IDLE`), we should cover the light sensor (to simulate
    that the light is off) and we should stop the video/audio player (to simulate
    that the washing machine is off). Then, we have to set a low threshold level into
    the configuration file for both sound and light detection and a very short timeout
    (`5` seconds) in order to speed up the test. The following is my configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I started the system, enabling all debugging messages on the terminal,
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the initial state is `IDLE` and nothing changes until no new events
    are detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next output listing, I''m going to use the `...` characters to skip
    non-relevant lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I''m going to simulate the following situation: first, I turn on the washing
    machine and wait for the end of its job. Then, I go to the laundry room to pick
    up my washed clothes. As already said before, I''m going to simulate the running
    washing machine with a video/audio player while the light on/off is simulated
    by uncovering/covering the light sensor with a cup.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, the test begins. After a while, I start the video/audio player. So, a
    sound has been detected and the new state turns to `SOUND`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Ouch! For a moment, the sound level went under the threshold, so we switched
    again to the `IDLE` state! This is correct because it may happen that the washing
    machine stops for a while. Here is where the `timeout` enters in action, that
    is, we have to select it for longer than all the possible washing machine''s pauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This an error during the reading of the ADC input, but the software is written
    to retry the faulty operation without problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Good! When the timeout expires while we are into the `SOUND` state, it means
    that a continuous sound has been detected, so it means that the washing machine
    has started its job.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that a more reliable implementation should use different timeouts to identify
    a specific transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is demonstrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I have stopped the video/audio player and no sound has been detected,
    so we switch to the `NO_SOUND` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, when the timeout expires when we are in the `NO_SOUND` state, we switch
    to the `DONE` state to signal that the washing machine has finished its job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I have uncovered the light sensor to simulate that someone has turned
    on the light in the laundry room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the timeout has expired, so we can consider that the light has been
    on for a long time, which means that the user has received our WhatsApp message
    and they have come into the laundry room to pick up the laundry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I have covered the light sensor again to simulate that the light in the
    laundry room has been turned off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the end, after `timeout` has expired, we can return to the `IDLE` state waiting
    for a new cycle to begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the screenshot of my smartphone showing the WhatsApp activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final test](img/B00255_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered how to detect sound and light levels by using
    specific sensors and how to write a simple Bash script to implement a state machine
    to manage our laundry room. Also, we discovered how to send some alerting messages
    to a smartphone through the WhatsApp service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll try to implement a baby room sentinel to control
    what happens to our little baby! We'll be able to monitor the room temperature,
    detect if the baby is crying or if she is actually breathing, and much more.
  prefs: []
  type: TYPE_NORMAL
