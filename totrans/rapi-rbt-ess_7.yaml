- en: Chapter 7. Accessing Your Biped Remotely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that your biped is up and running, you'll want to able to send it on its
    way into the world, but still be able to monitor and control it remotely. This
    will help you in development as well as deployment and will open up all sorts
    of new scenarios and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to add a wireless LAN dongle to your biped robot and set it up as a wireless
    access point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to control your biped robot using this access and a joystick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the wireless LAN connection to get **First Person Video** (**FPV**)
    back so that you can see what your biped robot is seeing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a wireless dongle and creating an access point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Configuring and Programming Raspberry Pi"),
    *Configuring and Programming Raspberry Pi*, you learned how to add a wireless
    dongle and have the Raspberry Pi connect to your wireless network. This is a useful
    way to access the Raspberry Pi, but if you want to take your robot outside the
    coverage of your wireless LAN, you'll want to set it up as an access point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in doing this is to install the wireless LAN device. One device
    that is inexpensive and easy to configure is the Edimax Wifi Adapter device (the
    product information is available at [http://www.edimax.com/edimax/merchandise/merchandise_detail/data/edimax/global/wireless_adapters_n150/ew-7811un](http://www.edimax.com/edimax/merchandise/merchandise_detail/data/edimax/global/wireless_adapters_n150/ew-7811un)).
    It is available at most online electronic outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a wireless dongle and creating an access point](img/B04591_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have installed the device and booted Raspberry Pi, type `lsusb` command.
    This should display something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a wireless dongle and creating an access point](img/B04591_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Edimax device is listed in the set of devices connected to the USB port.
    Now, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you have `hostapd` installed by typing `sudo apt-get install
    hostapd`. This application is a background application that controls the configuration
    of wireless on Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default version of `hostapd` unfortunately does not support the Edimax chipset
    by default. So, you'll need to download a version that does by typing `wget http://www.daveconroy.com/wp3/wp-content/uploads/2013/07/hostapd.zip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, unzip this file by typing `unzip hostapd.zip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a backup of your original `hostapd` application by typing `sudo mv /usr/sbin/hostapd
    /usr/sbin/hostapd.bak`. This way, you'll have it if you want to restore it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move the new version of `hostapd` to the proper directory by typing `sudo
    mv hostapd /usr/sbin/hostapd.edimax`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the next step, type `sudo ln -sf /usr/sbin/hostapd.edimax /usr/sbin/hostapd`;
    this will create a soft link to the new file so that it will be executed as the
    `hostapd` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `sudo chown root.root /usr/sbin/hostapd`, and this will change the owner
    and the group of this file to `root`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `sudo chmod 755 /usr/sbin/hostapd` to make this file executable to the
    owner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you will want to configure your wireless access point. Edit the file by
    typing `sudo emacs /etc/hostapd/hostapd.conf` so that it looks like the following
    screenshot:![Adding a wireless dongle and creating an access point](img/B04591_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll now want to edit the `/etc/network/interfaces` file, as shown in the
    following screenshot:![Adding a wireless dongle and creating an access point](img/B04591_07_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will set the address of the access point to **10.10.0.1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, type `sudo apt-get install isc-dhcp-server` to install a `dhcp` server
    so that devices that connect to it will be able to get a dynamic address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, edit the `/etc/dhcp/dhcpd.conf` and add these lines:![Adding a wireless
    dongle and creating an access point](img/B04591_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to edit the `/etc/default/hostapd` so that this will all start
    at power up by adding this line:![Adding a wireless dongle and creating an access
    point](img/B04591_07_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now type the following two commands; `sudo update-rc.d hostapd enable` and `sudo
    update-rc.d isc-dhcp-server enable` and then reboot the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be able to connect to your Raspberry Pi as a wireless access
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a joystick remote control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you can access your Raspberry Pi from a remote computer, you can SSH,
    just like you may have been doing with a wired connection, issue commands, and
    even control the biped using the remote computer. This introduces a number of
    different possibilities, one of which is to control your project with a joystick
    connected to the remote computer.
  prefs: []
  type: TYPE_NORMAL
- en: To add the game controller, you'll need to first find a game controller that
    can connect to your computer. If you are using Microsoft Windows as the OS on
    the host computer, pretty much any USB controller that can connect to a PC will
    work. The same type of controller also works if you are using Linux for the remote
    computer. In fact, you can use another Raspberry Pi as the remote computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the joystick will be connected to the remote computer, you''ll need to
    run two programs: one on the remote computer and one on the Raspberry Pi on the
    biped robot. You''ll also need a way to communicate between them. In the following
    example, you''ll use the wireless LAN interface and a client-server model of communication.
    You''ll run the server program on the remote computer, and the client program
    on the Raspberry Pi on the biped robot.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an excellent tutorial of this type of model and how it is used in a gaming
    application, see [http://www.raywenderlich.com/38732/multiplayer-game-programming-for-teens-with-python](http://www.raywenderlich.com/38732/multiplayer-game-programming-for-teens-with-python).
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to simply plug in your USB game controller to the remote computer.
    Once you have the controller connected to the remote computer, you'll need to
    create a Python program on the Raspberry Pi that will take the signals sent from
    the remote computer client and send the control to the server running on Raspberry
    Pi so that you can send the correct signals to the servos on your biped.
  prefs: []
  type: TYPE_NORMAL
- en: Before you do this, you'll need to install the libraries on Raspberry Pi that
    will allow this to work. The first is a library called `pygame`. Install this
    by typing `sudo apt-get install python-pygame`. You'll also need to install a
    set of Python install tools by typing `sudo apt-get install python-setuptools`.
    Then, you'll need a LAN communication layer library called `PodSixNet`. This will
    allow the two applications, the client on the remote computer and the server running
    on Raspberry Pi, to communicate. To install this, follow the instructions at [http://mccormick.cx/projects/PodSixNet/](http://mccormick.cx/projects/PodSixNet/).
    Now you are ready to create the program on Raspberry Pi on the biped. The first
    part of the program is the Python functions from the program you created in [Chapter
    3](ch03.html "Chapter 3. Motion for the Biped"), *Motion for the Biped*. In this
    section, you'll create a class called `QuadGame`. This class will take the inputs
    from the game controller connected to the server and turn them into commands that
    will be sent to the servo controller for your biped robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table of those controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Joystick control | Biped control |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Button 2 | Robot home position |'
  prefs: []
  type: TYPE_TB
- en: '| Button 1 | Robot turn right |'
  prefs: []
  type: TYPE_TB
- en: '| Button 3 | Robot turn left |'
  prefs: []
  type: TYPE_TB
- en: '| Joystick Up | Robot walk forward |'
  prefs: []
  type: TYPE_TB
- en: 'Now, the following is the initial part of the code, the Python import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a joystick remote control](img/B04591_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the following is the `BoxesGame` class, the code that will respond to the
    joystick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a joystick remote control](img/B04591_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the interesting part of the code. This code takes the input from the
    remote computer and translates it into action. The first `if` statement determines
    what type of data is being sent from the remote computer with the joystick attached.
    It can be a button press, where `data["type"] == 10`, and then the statement `data["info"]["button"]
    == 2` determines that **button 2** has been pressed. In this case, this will send
    commands that will cause the robot to go to the home position. If the `if data["type"]
    == 7:`, then this is a joystick event, and the `if data["info"]["value"] < - 0.9`,
    then this will determine that the joystick is in the up position and the robot
    should move forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the final part of the joystick controller aspect of the client
    program for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a joystick remote control](img/B04591_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This final piece of code initializes the game loop, which loops while taking
    the inputs, sends them to the servo controller, and on to the flight controller.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need a server program running on the remote computer that will take
    the signals from the game controller and send them to the client. You'll be writing
    this code in Python using Python version 2.7, which can be installed from here.
    Additionally, you'll need to install the `pygame` library. If you are using Linux
    on the remote computer, then type `sudo apt-get install python-pygame`. If you
    are using Microsoft Windows on the remote machine, then follow the instructions
    at [http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll also need the LAN communication layer described previously. You can
    find a version that will run on Microsoft Windows or Linux at [http://mccormick.cx/projects/PodSixNet/](http://mccormick.cx/projects/PodSixNet/).
    The following is a listing of the server code in two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a joystick remote control](img/B04591_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This first part creates three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The first, class `ClientChannel`, establishes a communication channel for your
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second, class `BoxServer`, sets up a server so that you can communicate
    the joystick action to the Raspberry Pi on the biped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the third class, `Game` , just initializes a game that contains everything
    you'll need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the latter part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a joystick remote control](img/B04591_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This part of the code initializes the joystick so that all the controls can
    be sent to the biped's Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need to run these programs on both computers, entering the Internet
    address of the remote computer connected to the joystick. The following is what
    running the program on that computer will look like, before running the program
    on the remote computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a joystick remote control](img/B04591_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the following is what the program will look like when run on the Raspberry
    Pi and connected to the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a joystick remote control](img/B04591_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the following is what the program will look like on the remote computer
    when the robot''s Raspberry Pi is up and connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a joystick remote control](img/B04591_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can control you robot remotely using the joystick!
  prefs: []
  type: TYPE_NORMAL
- en: Adding the capability to see remotely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your biped can now get information from your remote computer and respond to
    joystick key presses, but you may want to be able to see what the biped sees from
    its webcam. This is straightforward to configure with a webcam, vncserver, and
    the capability you used in [Chapter 6](ch06.html "Chapter 6. Adding Vision to
    Your Biped"), *Adding Vision to Your Biped*. Using this method, you can easily
    get a picture of what your biped is seeing, and it should be something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the capability to see remotely](img/B04591_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can both see where your robot is going and control it via a joystick.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it, but really it is only the beginning. Your robot has some basic motions
    and some basic control capability, but now you should also have the knowledge
    and skills to take your biped robot much further. You can teach it how to dance,
    follow gestures, and almost anything that you can imagine.
  prefs: []
  type: TYPE_NORMAL
