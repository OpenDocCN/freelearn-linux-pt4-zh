- en: Chapter 6. Adding Cameras to Our Security System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we've been putting together the elements that will allow us to connect
    sensors to our alarm system to detect intrusions using either switches or passive
    infra-red motion detectors, which in turn will tell our Raspberry Pi that something
    has happened in a particular zone. These elements will all come together as a
    whole system later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Our system is now going to become a whole lot more sophisticated with the addition
    of cameras to take pictures and video clips, and e-mail them to us straightaway
    when it detects something.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also use e-mail to send us alerts on our smart phone when we're out and
    about when any of the sensors in the system are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Raspberry Pi camera module and learning how to capture stills
    and video images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to overlay captured images with text and time-stamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering image captures with a motion detector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-mailing the image and video files to us in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the differences between capturing images during the day and during
    the night
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching on and off security lighting and other high-current devices when required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting a USB webcam instead of the native camera module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll need the following parts for this chapter, on top of the components
    used in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A Raspberry Pi standard camera module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raspberry Pi NoIR camera module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Infra-Red LED array and/or visible LED array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB webcam
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Raspberry Pi camera module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi Camera Module is an official Raspberry Pi accessory that works
    with all models of the Pi, and can be used to take high-definition stills and
    video images. It connects directly to the Pi board's **camera serial interface**
    (**CSI**) port, which is dedicated to these modules to enable high-speed operation.
  prefs: []
  type: TYPE_NORMAL
- en: The camera itself is a 5 megapixel fixed-focus sensor supporting 1080p, 720p,
    and VGA video modes and still captures.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Raspberry Pi camera module](img/B04579_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The official Raspberry Pi Camera Module
  prefs: []
  type: TYPE_NORMAL
- en: You can also obtain housings for the camera modules, which, unless you're going
    to build your own enclosure for the camera system, I recommend you use.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Raspberry Pi camera module](img/B04579_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi camera housings come in various colors and styles
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the camera module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned, the module connects directly to the Raspberry Pi board
    via its dedicated camera interfaces, as shown in the following image. When connecting
    the camera, the contact side of the ribbon cable is toward the HDMI connector
    and the blue side of the cable is toward the network connector.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the camera module](img/B04579_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connect the camera module to the dedicated interface
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following image, the ribbon connector is not that long,
    so the camera needs to be located close to the Raspberry Pi. By using a camera
    enclosure, you could actually mount the camera directly on top of the Raspberry
    Pi case itself, if that works for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the camera module](img/B04579_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The camera module, housed within an enclosure
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the camera module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can use the camera module, we need to enable camera support on the
    Raspberry Pi. To do this, we use the `raspi-config` tool, as we did with the I2C
    bus earlier in our journey.
  prefs: []
  type: TYPE_NORMAL
- en: Connect to your Raspberry Pi the lazy way from your sofa using SSH, or directly
    using a keyboard and monitor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you''ve logged in, launch the config tool with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And then, select `5 Enable Camera`.![Setting up the camera module](img/B04579_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll then be asked to confirm whether you want to enable camera support.![Setting
    up the camera module](img/B04579_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `<Enable>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select **Finish** and reboot your Pi to enable the camera settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing the camera module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once your Raspberry Pi has rebooted, your camera should be enabled. We can
    test this by taking a still image using the `raspistill` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will delay for 5 seconds then take a picture, while displaying various
    pieces of information, such as that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the camera module](img/B04579_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The camera module needs at least 128 MB of GPU memory to operate properly on
    Raspian. If you experience any issues, first ensure that the the `gpu_mem` setting
    in the `/boot/config.txt` configuration file is set to at least `128`.
  prefs: []
  type: TYPE_NORMAL
- en: And if all goes well, you should find the file, `test.jpg`, in your home folder.
    As you're connected via the shell, you wouldn't have seen the 5 second preview
    image displayed when the command was running.
  prefs: []
  type: TYPE_NORMAL
- en: If you download the image file to your PC, you should see a nice quality snap
    taken by the camera module.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the camera module](img/B04579_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The test photo taken by the Raspberry Pi Camera Module
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you find that raspistill outputs errors when you run it, ensure that it is
    connected properly at both ends of the ribbon cable. One other catch is that sometimes
    the ribbon that connects the actual camera lens component to the tiny connector
    on the camera board can come loose. Just ensure that this is securely connected
    too. I've had this issue a couple times after the camera modules have been taken
    out of my box of random test bits to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `raspistill` utility has loads of options for manipulating the images it
    captures, and we''ll use some of them a bit later in our capture script. In the
    meantime, to see the available options, run `raspistill` without any options and
    they will be listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Be a video star
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know our camera module is working, we can try and capture some
    video. To do this, we''ll use the `raspivid` utility. The following command will
    take 5 seconds of high-definition video and save the file to your Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that file is called `test.h264`—this is because the video is captured
    as a raw **H.264** video stream. Unfortunately, not many media players will handle
    these files (although VLC player will—it rocks and handles practically anything
    you throw at it—get it on your PC at [www.videolan.org](http://www.videolan.org)).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play the file on smartphones and conventional media players,
    then we will need to wrap it in a container format, such as MPEG-4, and give the
    file a `.mp4` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll use the **GPAC** package, which is an open source multimedia
    framework. It comes with a utility called **MP4Box**, which is a tool we''ll use
    to create an MP4 container for our video file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the GPAC package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once it''s installed, run the command to convert the test video we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should now have the file, `test.mp4`, which you can download and play on
    your PC or smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another popular conversion tool is **ffmpeg**, which I use a lot on Windows
    to convert video files; however, it can be quite complex and although there is
    a package for the Raspberry Pi, I actually couldn't get it to convert properly
    on the Pi. MP4Box is much more straightforward and fitting for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Caught on camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we now have a method of capturing still images and video, which we can put
    to use in our security system. If we want to have this running constantly, we
    could write a script to take video constantly, but this would soon fill up our
    memory card and wouldn't be particularly efficient. So, we'll combine our camera
    system with the motion detectors we connected earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we created an alarm zone which had a couple of sensors
    and a motion detector connected to our system on the input GPA0\. So, let''s write
    a script that will take a video clip whenever the motion detector is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You have new mail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the images stored on your Raspberry Pi is not really much use—ideally,
    you would want the images sent to you straightaway, as soon as they are captured,
    so that you can view them on your smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: An easy, quick, and reliable way to do this is to simply have them e-mailed
    to you. Hence we're going to add an e-mailing functionality to our home security
    system so that image captures are attached to a message and sent to your e-mail
    address straightaway, which you can access from your smartphone. The images can
    then be removed from your Raspberry Pi to prevent the SD card space from being
    clogged up with these reasonably large files.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the e-mail sender client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fortunately, there are some good packages available that will help us with
    this. Carry out the following steps to install the email packages we need:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the package installer with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install and set up the SMTP client with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You'll now need to set up the client to send emails through your email account.
    In the following configuration file, I've assumed that you have a Gmail account.
    The settings may be different if you use another email provider.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `ssmtp` configuration file using **Nano** or another text editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the entries with the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ssmtp` can be used on its own but can be a bit of a faff while automatically
    sending emails (by default, you manually type the email in with the command line,
    or create a text file), so we''re also going to install the `mailutils` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once it''s installed, we can use the `mail` command to send emails more easily.
    Send a test email through the (G)mail account that we set up earlier, using the
    following command to make sure your settings are working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If all goes well, you should receive the test email in your mailbox within a
    few seconds or so.
  prefs: []
  type: TYPE_NORMAL
- en: Sending attachments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can send basic emails from our home security system, let''s try
    sending the still image taken from our camera earlier. But first, we need to install
    yet another package to help us with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that''s installed, you can send the test image file we took previously
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We now have all of the elements needed to send alerts and images from our home
    security system directly to our smartphone using email.
  prefs: []
  type: TYPE_NORMAL
- en: Where was that taken?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ordinarily, you could just annotate the email message with where and when the
    attached image was taken, but that wouldn''t be as cool as actually overlaying
    the image with some text, would it? So let''s do some magic with the help of `imagemagick`,
    which is a popular command-line image manipulation tool. Install it with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now use the command line to take the test photo that we took earlier,
    overlay some text using one of the `imagemagick` utilities, and save it to another
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, this will have generated a file called `annotated.jpg`
    containing our image with **Camera 1** written in red in the top corner. When
    we put all of this together in our final system, we'll also overlay the image
    with a time stamp.
  prefs: []
  type: TYPE_NORMAL
- en: '![Where was that taken?](img/B04579_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the moment, the images generated by the `raspistill` tool are pretty large,
    being high resolution photos. This makes manipulating and sending them a bit time-consuming
    as far as processing time is concerned, so when we build our final system, we'll
    be using the `raspistill` options, `–w`, `–h` and, `–q`, to reduce the size and
    quality of the images to make the system more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture smaller image files, try using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Night vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard Raspberry Pi camera is great for taking daytime snaps of people
    walking up the garden path, but when it comes to night time shots, it''s not really
    suitable. There are two ways of dealing with this: the first is to illuminate
    the capture area with a bright light when the PIR detector is triggered, and the
    second is to use the Raspberry Pi **NoIR camera module** and an infra-red LED
    array to let the camera see in the dark. More about that in a minute.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Night vision](img/B04579_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Raspberry Pi NoIR camera module; it looks similar to the standard model
  prefs: []
  type: TYPE_NORMAL
- en: An illuminating experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to switch on a light or LED array from the Raspberry Pi GPIO or our
    port expander circuit, we need something that will allow us to drive higher currents
    and voltages than can be provided by the GPIO ports alone.
  prefs: []
  type: TYPE_NORMAL
- en: A good candidate for this is the **TIP120** **Darlington transistor**, which
    will allow us to switch on and off loads of up to 80V and 5 A from our GPIO pins.
    In our full system later on, we're going to use Port B of our MCP23017 port expander
    to control outputs, but the principle stands for any of the GPIO outputs available
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: '![An illuminating experience](img/B04579_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TIP120 transistors can be bought cheaply but can drive large loads
  prefs: []
  type: TYPE_NORMAL
- en: The following circuit shows how we can drive big loads from our GPIO port outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '![An illuminating experience](img/B04579_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our example circuit, we're using a GPIO output pin to control the base of
    our transistor via a 220 ohm resistor. When the GPIO pin goes high, the transistor
    is switched on and allows the 12V circuit to flow through the LED array.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding circuit, there is no current limiting for the LEDs because
    they are connected in series, and so with nine of them, each dropping about 1.5V
    across, this is about right for a 12V supply (yes I know I've only included six
    LEDs here but it's just for illustration). Remember to adjust for your particular
    needs. This circuit could easily drive other loads, such as bulbs or sounders.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you intend to drive high power loads, you will probably need to attach the
    TIP120 to a heat sink that will dissipate any heat and prevent it from over-heating
    and burning out. In our circuit that was demonstrated previously, however, you
    probably won't need one as we're only driving a couple of hundred milliwatts at
    most.
  prefs: []
  type: TYPE_NORMAL
- en: The Elaborate light switch re-visited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expanding once again on our elaborate light switch from previous chapters, we
    can once again write a Bash script that will switch on our camera light, take
    a snap with the camera, and e-mail it to us when a PIR detector is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the following script, we''re assuming that the output controlling the TIP120
    transistor is the Raspberry PI GPIO17 pin (D0 or pin 11 of our connector), which
    replaces the LED in our earlier set-up. The input from the PIR trigger is, again,
    connected to the GPA0 (port A, data pin 0) of our MCP23017 port expander. All
    the other inputs are tied low, as before, using 10 K resistors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`pir-camera-trigger.sh`'
  prefs: []
  type: TYPE_NORMAL
- en: You'll now see that we've started developing the foundations of the software
    that will control our home security system.
  prefs: []
  type: TYPE_NORMAL
- en: Is that a badger?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don't want to illuminate an area before capturing an image, you can use
    **infra-red lighting** in conjunction with a compatible camera. The standard Raspberry
    Pi camera module won't work with infra-red lighting because it contains an infra-red
    filter, but we can use the NoIR version of the camera module instead.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi NoIR camera module is exactly the same as the standard one,
    except that it doesn't have an infra-red filter built in, which means it will
    see in the dark with the aid of infra-red lighting. This makes it good for watching
    badgers at night as well as for use in our home security system.
  prefs: []
  type: TYPE_NORMAL
- en: You will need an infra-red LED array or cluster to invisibly illuminate the
    area you want to capture with the camera. These are readily available in various
    form factors and intensities, or you can build your own using individual infra-red
    LEDs purchased from an electronics store.
  prefs: []
  type: TYPE_NORMAL
- en: '![Is that a badger?](img/B04579_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Kingbright infra-red LED cluster runs from a 6V supply, which means you
    can connect two in series—one on either side of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting and driving the LED cluster modules works exactly the same as our
    illuminating light above, using the TIP120 driver circuit. The only difference
    is that we humans can't see when the LEDs are on.
  prefs: []
  type: TYPE_NORMAL
- en: Using USB cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of using the Raspberry Pi Camera Module, it's also possible to use a
    standard USB **webcam** to take still images. You should be aware though that
    the dedicated camera module is far superior to a USB webcam in terms of image
    quality. Although, you may already have a webcam knocking about in your box of
    bits, so why not try it?
  prefs: []
  type: TYPE_NORMAL
- en: Installing the webcam
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you''ve connected your webcam to a USB port on your Pi, you can check
    whether it''s been recognized using the `lsusb` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m using a Logitech webcam that gets reported as follows with `lsusb` (Device
    006):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all webcams will work with the Raspberry Pi. Even though it may be recognized
    as a USB device, it might not actually work properly with the operating system
    and create a video device (for example, `/dev/video0`). For example, an old cheap
    Trust webcam I had appeared as a USB device but wouldn't capture any images.
  prefs: []
  type: TYPE_NORMAL
- en: You can check whether your webcam is likely to work with the Pi by checking
    your make and model at [http://elinux.org/RPi_USB_Webcams](http://elinux.org/RPi_USB_Webcams).
  prefs: []
  type: TYPE_NORMAL
- en: So, now that the Pi knows that we have a webcam device attached, we can use
    the `fswebcam` utility to capture image frames. You can find out more about `fswebcam`
    from the developer's site at [http://www.sanslogic.co.uk/fswebcam](http://www.sanslogic.co.uk/fswebcam).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `fswebcam` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Taking a snap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can now test the webcam by capturing a still image, which can be done by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should expect to see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking a snap](img/B04579_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fswebcam` has lots of options for things like the resolution and quality of
    the image. Use the command `fswebcam` `-?` to get a list of all options.'
  prefs: []
  type: TYPE_NORMAL
- en: Snap snap snap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fswebcam` doesn''t take video streams, but you can set it up to take a series
    of **frames** at regular intervals. For example, to take a snap every 10 seconds,
    you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: An example of how this would be useful can be demonstrated by setting the webcam
    to take a snap every few seconds in the background (the `–q` switch runs `fswebcam`
    in the background). When our security system is triggered, we could then take
    the latest image snapped with the webcam which could be looking down your pathway.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of putting together our entire system later in this book, we'll
    be focusing on the Raspberry Pi Camera Module, but you can always replace the
    code with the previous examples if you want to use USB webcams instead.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that `fswebcam`, unlike `raspistill`, has the ability to overlay
    the images with timestamp information, so you don't need to worry about overlaying
    text as we did previously. Look at the `fswebcam` command line options for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The multicamera setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may have occurred to you that the Raspberry Pi has only one camera module
    input. Now, this is obviously limiting if you want to have multiple cameras around
    your property that are triggered by motion detectors.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is nothing stopping us from building standalone units that have
    a separate Raspberry Pi board with a PIR detector, Camera Module, and network
    connection, either using a Wi-Fi dongle or Ethernet.
  prefs: []
  type: TYPE_NORMAL
- en: Because you only need a single input to the Raspberry Pi to detect when the
    PIR motion sensor is triggered, you can use the on-board GPIO port to connect
    the sensor, rather than using a port expander. The Raspberry Pi will email the
    alert over the network, and could alert the main controller Pi if required—making
    it a slave sensor device.
  prefs: []
  type: TYPE_NORMAL
- en: You can readily obtain small PIR detectors, such as the Parallax one shown next,
    which you can mount onto a Raspberry Pi Case along with the camera module, creating
    a self-contained unit.
  prefs: []
  type: TYPE_NORMAL
- en: '![The multicamera setup](img/B04579_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A Parallax PIR motion sensor (type 555-28027)
  prefs: []
  type: TYPE_NORMAL
- en: The Slave driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it may seem quite elaborate to have a Raspberry Pi for each camera—think
    about it—you can actually build each camera unit with all of the components for
    around £50, which is significantly cheaper than buying a wireless *smart* camera.
    If you really want to be clever, you could also use this as a slave device to
    accept further sensor inputs local to the unit.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing to stop you from connecting a GPIO output pin on the slave
    unit to drive an input on the main controller and control the pin depending on
    the state of its local sensors. By running a 6-core cable between the units, you
    could even power the slave unit if your power supply is man enough (you'd need
    to have a supply of 5V @ 1A for the slave Pi running along the wire).
  prefs: []
  type: TYPE_NORMAL
- en: I'm not going to go into any more detail about this configuration at this time,
    but you could set yourself a challenge to create a fully distributed home security
    system using multiple Raspberry Pis and the building blocks and concepts learned
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to connect both Raspberry Pi camera modules
    and USB cameras to our Pi board in order to take image and video captures when
    required by our home security system. We also learned how to overlay our images
    with informative text and have the files immediately emailed to us.
  prefs: []
  type: TYPE_NORMAL
- en: In order to capture images from our camera at night, we also looked at ways
    to illuminate the capture area using both visible and infra-red lighting, with
    the ability to switch the lighting on and off as required by using a high-current
    Darlington transistor driver.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to get down to the business of putting together
    modules by building a mobile-optimized web-based control panel for our home security
    system. We'll learn how to set up a Web server on our Raspberry Pi and manipulate
    files using our Web control panel, which means that we'll start to explore how
    all of the elements we've encountered so far can come together as part of our
    final system.
  prefs: []
  type: TYPE_NORMAL
