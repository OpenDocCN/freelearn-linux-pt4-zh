- en: Chapter 3. The Software Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 软件层
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Exploring an image's contents
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索镜像的内容
- en: Adding a new software layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的软件层
- en: Selecting a specific package versions and providers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择特定的包版本和提供者
- en: Adding supported packages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加支持的包
- en: Adding new packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新包
- en: Adding data, scripts, or configuration files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加数据、脚本或配置文件
- en: Managing users and groups
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户和组
- en: Using the sysvinit initialization system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 sysvinit 初始化系统
- en: Using the systemd initialization system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 systemd 初始化系统
- en: Installing package-installation scripts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装包安装脚本
- en: Reducing the Linux kernel image size
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减小 Linux 内核镜像大小
- en: Reducing the root filesystem image size
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减小根文件系统镜像大小
- en: Releasing software
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布软件
- en: Analyzing your system for compliance
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析系统合规性
- en: Working with open source and proprietary code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开源和专有代码
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: With hardware-specific changes on their way, the next step is customizing the
    target root filesystem; that is, the software that runs under the Linux kernel,
    also called the Linux user space.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着硬件特定更改的到来，下一步是定制目标根文件系统；即在 Linux 内核下运行的软件，也称为 Linux 用户空间。
- en: The usual approach to this is to start with one of the available core images
    and both optimize and customize it as per the needs of your embedded project.
    Usually, the images chosen as a starting point are either `core-image-minimal`
    or `core-image-sato`, but any of them will do.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的做法是从一个可用的核心镜像开始，然后根据嵌入式项目的需求进行优化和定制。通常选择的起始镜像是 `core-image-minimal` 或 `core-image-sato`，但任何一个都可以。
- en: This chapter will show you how to add a software layer to contain those changes,
    and will explain some of the common customizations made, such as size optimization.
    It will also show you how to add new packages to your root filesystem, including
    licensing considerations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示如何添加软件层以包含这些更改，并解释一些常见的定制，如大小优化。还将展示如何向根文件系统添加新包，包括许可考虑事项。
- en: Exploring an image's contents
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索镜像的内容
- en: We have already seen how to use the build history feature to obtain a list of
    packages and files included in our image. In this recipe, we will explain how
    the root filesystem is built so that we are able to track its components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用构建历史功能来获取包含在镜像中的包和文件列表。在这个配方中，我们将解释根文件系统是如何构建的，以便能够跟踪其组件。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'When packages are built, they are classified inside the working directory of
    your project (`tmp/work`) according to their architecture. For example, on a `wandboard-quad`
    build, we find the following directories:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当包构建完成后，它们会根据架构在项目的工作目录（`tmp/work`）中进行分类。例如，在 `wandboard-quad` 构建中，我们会看到以下目录：
- en: '`all-poky-linux`: This is used for architecture-independent packages'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all-poky-linux`：用于架构无关的包'
- en: '`cortexa9hf-vfp-neon-poky-linux-gnueabi`: This is used for cortexa9, hard floating
    point packages'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cortexa9hf-vfp-neon-poky-linux-gnueabi`：用于 cortexa9 硬浮动点包'
- en: '`wandboard_quad-poky-linux-gnueabi`: This is used for machine-specific packages;
    in this case, `wandboard-quad`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wandboard_quad-poky-linux-gnueabi`：用于机器特定包；在此情况下，是 `wandboard-quad`'
- en: '`x86_64-linux`: This is used for the packages that form the host `sysroot`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x86_64-linux`：用于构成主机 `sysroot` 的包'
- en: BitBake will build all the packages included in its dependency list inside its
    own directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake 将在其自己的目录中构建其依赖列表中的所有包。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To find the `build` directory for a given package, we can execute the following
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找给定包的 `build` 目录，可以执行以下命令：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `build` directory, we find some subdirectories (assuming `rm_work`
    is not used) that the build system uses in the packaging task. These subdirectories
    include the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `build` 目录中，我们可以找到一些子目录（假设未使用 `rm_work`），这些子目录是构建系统在打包任务中使用的。这些子目录包括以下内容：
- en: '`deploy-rpms`: This is the directory where the final packages are stored. We
    look here for individual packages that can be locally copied to a target and installed.
    These packages are copied to the `tmp/deploy` directory and are also used when
    Yocto builds the root filesystem image.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy-rpms`：这是存储最终包的目录。我们可以在这里找到可以本地复制到目标并安装的单个包。这些包被复制到 `tmp/deploy` 目录，在
    Yocto 构建根文件系统镜像时也会使用这些包。'
- en: '`image`: This is the default destination directory where the `do_install` task
    installs components. It can be modified by the recipe with the `D` configuration
    variable.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：这是默认的目标目录，`do_install`任务会将组件安装到该目录。它可以通过配方中的`D`配置变量进行修改。'
- en: '`package`: This one contains the actual package contents.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`：这个包含了实际的包内容。'
- en: '`package-split`: This is where the contents are categorized in subdirectories
    named after their final packages. Recipes can split the package contents into
    several final packages, as specified by the `PACKAGES` variable. The default packages
    besides the default package name are:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-split`：这里是根据最终的包名将内容分类到各个子目录中。配方可以根据`PACKAGES`变量指定将包内容拆分为多个最终包。除了默认包名称外，默认的包有：'
- en: '`dbg`: This installs components used in debugging'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbg`：安装用于调试的组件'
- en: '`dev`: This installs components used in development, such as headers and libraries'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`：安装用于开发的组件，如头文件和库'
- en: '`staticdev`: This installs libraries and headers used in static compilation'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staticdev`：安装用于静态编译的库和头文件'
- en: '`doc`: This is where the documentation is placed'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc`：这是文档所在的目录'
- en: '`locale`: This installs localization components'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locale`：安装本地化组件'
- en: 'The components to be installed in each package are selected using the `FILES`
    variable. For example, to add to the default package, you could execute the following
    command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包中要安装的组件由`FILES`变量选择。例如，要添加到默认包，可以执行以下命令：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And to add to the development package, you could use the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要添加到开发包，可以使用以下命令：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Once the Yocto build system has built all the individual packages in its dependency
    list, it runs the `do_rootfs` task, which populates the `sysroot` and builds the
    root filesystem before creating the final package images. You can find the location
    of the root filesystem by executing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Yocto构建系统完成其依赖包列表中的所有单独包的构建，它会运行`do_rootfs`任务，填充`sysroot`并构建根文件系统，然后创建最终的包镜像。你可以通过执行以下命令找到根文件系统的位置：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `IMAGE_ROOTFS` variable is not configurable and should not be
    changed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`IMAGE_ROOTFS`变量不可配置，且不应更改。
- en: The contents of this directory will later be prepared into an image according
    to what image types are configured in the `IMAGE_FSTYPES` configuration variable.
    If something has been installed in this directory, it will then be installed in
    the final image.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录中的内容稍后将根据`IMAGE_FSTYPES`配置变量中配置的镜像类型准备成一个镜像。如果某些内容已安装在此目录中，它将被安装到最终镜像中。
- en: Adding a new software layer
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的软件层
- en: Root filesystem customization involves adding or modifying content to the base
    image. Metadata for this content goes into one or more software layers, depending
    on the amount of customization needed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统的定制涉及向基础镜像中添加或修改内容。与这些内容相关的元数据将进入一个或多个软件层，具体取决于定制的需求量。
- en: A typical embedded project will have just one software layer containing all
    non-hardware-specific customizations. But it is also possible to have extra layers
    for graphical frameworks or system-wide elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的嵌入式项目通常只有一个包含所有非硬件特定定制的软件层。但也可以为图形框架或系统范围的元素添加额外的层。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before starting work on a new layer, it is good practice to check whether someone
    else provides a similar layer. Also, if you are trying to integrate an open source
    project, check whether a layer for it already exists. There is an index of available
    layers at [http://layers.openembedded.org/](http://layers.openembedded.org/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始工作之前，最好检查是否有其他人提供了类似的层。此外，如果你试图集成一个开源项目，检查是否已有现成的层。可以在[http://layers.openembedded.org/](http://layers.openembedded.org/)找到可用层的索引。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We can then create a new `meta-custom` layer using the `yocto-layer` command
    as we learned in the *Creating a custom BSP layer* recipe in [Chapter 2](ch02.html
    "Chapter 2. The BSP Layer"), *The BSP Layer*. From the `sources` directory, execute
    the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过`yocto-layer`命令创建一个新的`meta-custom`层，正如我们在[第2章](ch02.html "第2章. BSP层")的*创建自定义BSP层*配方中所学到的。从`sources`目录中执行以下命令：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don't forget to add the layer to your project's `conf/bblayers.conf` file and
    to your template's `conf` directory to make it available for all new projects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了将该层添加到项目的`conf/bblayers.conf`文件以及模板的`conf`目录中，以便在所有新项目中使用。
- en: 'The default `conf/layer.conf` configuration file is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`conf/layer.conf`配置文件如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have discussed all the relevant variables in this snippet in the *Creating
    a custom BSP layer* recipe in [Chapter 2](ch02.html "Chapter 2. The BSP Layer"),
    *The BSP Layer*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章 BSP层")的*创建自定义BSP层*配方中讨论了所有相关变量，*BSP层*。
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When adding content to a new software layer, we need to keep in mind that our
    layer needs to play well with other layers in the Yocto project. To this end,
    when customizing recipes, we will always use append files, and will only override
    existing recipes if we are completely sure there is no way to add the customization
    required through an append file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在向新软件层添加内容时，我们需要记住我们的层需要与Yocto项目中的其他层良好兼容。因此，在定制配方时，我们将始终使用附加文件，并且仅在完全确定无法通过附加文件添加所需定制时，才会重载现有配方。
- en: 'To help us manage the content across several layers, we can use the following
    `bitbake-layers` command-line utilities:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们管理多个层中的内容，我们可以使用以下`bitbake-layers`命令行工具：
- en: '`$ bitbake-layers show-layers`: This will display the configured layers as
    BitBake sees them. It is helpful to detect errors on your `conf/bblayer.conf`
    file.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ bitbake-layers show-layers`：此命令将显示配置的层，按BitBake的视角展示。这有助于检测`conf/bblayer.conf`文件中的错误。'
- en: '`$ bitbake-layers show-recipes`: This command will display all the available
    recipes and the layers that provide them. It can be used to verify that BitBake
    is seeing your newly created recipe. If it does not appear, verify that the filesystem
    hierarchy corresponds to the one defined in your layer''s `BBFILES` variable in
    `conf/layer.conf`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ bitbake-layers show-recipes`：此命令将显示所有可用的配方及提供它们的层。它可以用来验证BitBake是否识别了你新创建的配方。如果没有显示，请验证文件系统层级是否与层的`BBFILES`变量在`conf/layer.conf`中的定义一致。'
- en: '`$ bitbake-layers show-overlayed`: This command will show all the recipes that
    are overlayed by another recipe with the same name but in a higher priority layer.
    It helps detect recipe clashes.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ bitbake-layers show-overlayed`：此命令将显示所有被另一个具有相同名称但优先级更高层中的配方所覆盖的配方。它有助于检测配方冲突。'
- en: '`$ bitbake-layers show-appends`: This command will list all available append
    files and the recipe files they apply to. It can be used to verify that BitBake
    is seeing your append files. Also, as before with recipes, if they don''t appear,
    you will need to check the filesystem hierarchy and your layer''s `BBFILES` variable.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ bitbake-layers show-appends`：此命令将列出所有可用的附加文件及其应用到的配方文件。它可以用来验证BitBake是否识别了你的附加文件。此外，和配方一样，如果它们没有显示，你需要检查文件系统层级和你层中的`BBFILES`变量。'
- en: '`$ bitbake-layers flatten <output_dir>`: This command will create a directory
    with the contents of all configured layers without overlayed recipes and with
    all the append files applied. This is how BitBake will see the metadata. This
    flattened directory is useful to discover conflicts with your layer''s metadata.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ bitbake-layers flatten <output_dir>`：此命令将创建一个目录，其中包含所有配置层的内容，且没有覆盖的配方，并应用所有附加文件。这是BitBake将看到的元数据。这个扁平化目录有助于发现与层的元数据冲突。'
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We will sometimes add customizations that are specific to one board or machine.
    These are not always hardware-related, so they could be found both in a BSP or
    software layer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会添加特定于某个开发板或机器的定制内容。这些内容不总是与硬件相关，因此它们可能出现在BSP或软件层中。
- en: 'When doing so, we will try to keep our customizations as specific as possible.
    One typical example is customizing for a specific machine or machine family. If
    you need to add a patch for the `wandboard-quad` machine, you would use the following
    line of code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做时，我们会尽量保持我们的定制尽可能具体。一个典型的例子是针对特定机器或机器系列进行定制。如果你需要为`wandboard-quad`机器添加补丁，可以使用以下代码行：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And, if the patch is applicable to all i.MX6-based boards, you can use the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果补丁适用于所有基于i.MX6的开发板，你可以使用以下命令：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To be able to use machine families overrides, the machine configuration files
    need to include a `SOC_FAMILY` variable, such as the one for the `wandboard-quad`
    in `meta-fsl-arm-extra`. Refer to the following line of code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用机器系列重载，机器配置文件需要包含一个`SOC_FAMILY`变量，例如在`meta-fsl-arm-extra`中用于`wandboard-quad`的配置。参考以下代码行：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And for it to appear in the `MACHINEOVERRIDES` variable, the `soc-family.inc`
    file needs to be included, as it is in `meta-fsl-arm`. Here is the relevant code
    excerpt from the `conf/machine/include/imx-base.inc` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它出现在`MACHINEOVERRIDES`变量中，需要包含`soc-family.inc`文件，正如在`meta-fsl-arm`中的配置。以下是`conf/machine/include/imx-base.inc`文件中的相关代码摘录：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'BitBake will search a predefined path, looking for files inside the package''s
    working directory, defined in the `FILESPATH` variable as a colon-separated list.
    Specifically:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake将搜索预定义的路径，查找包工作目录内的文件，该目录由`FILESPATH`变量定义，作为以冒号分隔的列表。具体来说：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the specific case of the `wandboard-quad`, this translates to the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`wandboard-quad`的具体情况下，这将转换为以下内容：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `PN` is the package name and `PV` is the package version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PN`是包名，`PV`是包版本。
- en: It is best to place patches in the most specific of these, so `wandboard-quad`,
    followed by `wandboard`, `mx6q`, `mx6`, `armv7a`, `arm`, and finally the generic
    `PN-PV`, `PN`, and `files`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将补丁放在这些层中最具体的地方，比如`wandboard-quad`，然后是`wandboard`、`mx6q`、`mx6`、`armv7a`、`arm`，最后是通用的`PN-PV`、`PN`和`files`。
- en: 'Note that the search path refers to the location of the BitBake recipe, so
    append files need to always add the path when adding content. Our append files
    can add extra folders to this search path if needed by appending or prepending
    to the `FILESEXTRAPATHS` variable as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，搜索路径指的是BitBake配方的位置，因此在添加内容时，追加文件始终需要添加路径。如果需要，我们的追加文件可以通过以下方式在`FILESEXTRAPATHS`变量中追加或前置，来添加额外的文件夹到该搜索路径：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the immediate operator (`:=`) that expands `THISDIR` immediately, and the
    prepend that places your added path before any other path so that your patches
    and files are found first in the search.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意立即操作符(`:=`)，它会立即扩展`THISDIR`，以及前置操作符，它将你添加的路径放在其他路径之前，这样你的补丁和文件可以首先在搜索中被找到。
- en: Also, we have seen the `+=` and `=+` style of operators in configuration files,
    but they should be avoided in recipe files and the append and prepend operators
    should be given preference, as seen in the example code explained previously to
    avoid ordering issues.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们也看到在配置文件中使用`+=`和`=+`风格的操作符，但应避免在配方文件中使用，应该优先使用追加和前置操作符，如之前的示例代码所解释，以避免顺序问题。
- en: Selecting a specific package version and providers
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择特定的包版本和提供者
- en: 'Our layers can provide recipes for different versions of the same package.
    For example, the `meta-fsl-arm` layer contains several different types of Linux
    sources:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的层可以为同一包的不同版本提供配方。例如，`meta-fsl-arm`层包含多个不同类型的Linux源：
- en: '`linux-imx`: This corresponds to the Freescale BSP kernel image fetched from
    [http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/](http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-imx`：这是来自于Freescale BSP内核镜像，来源于[http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/](http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/)'
- en: '`linux-fslc`: This is the mainline Linux kernel and fetched from [https://github.com/Freescale/linux-fslc](https://github.com/Freescale/linux-fslc)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-fslc`：这是主线Linux内核，来自于[https://github.com/Freescale/linux-fslc](https://github.com/Freescale/linux-fslc)'
- en: '`linux-timesys`: This is a kernel with Vybrid platform support fetched from
    [https://github.com/Timesys/linux-timesys](https://github.com/Timesys/linux-timesys)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-timesys`：这是一个支持Vybrid平台的内核，来自于[https://github.com/Timesys/linux-timesys](https://github.com/Timesys/linux-timesys)'
- en: As we mentioned before, all recipes provide the package name (for example, `linux-imx`
    or `linux-fslc`) by default, but all Linux recipes must also provide the `virtual/kernel`
    virtual package. The build system will resolve `virtual/kernel` to the most appropriate
    Linux recipe name, taking into account the requirements of the build, such as
    the machine it is building for.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有配方默认提供包名（例如，`linux-imx`或`linux-fslc`），但所有Linux配方还必须提供`virtual/kernel`虚拟包。构建系统将根据构建的要求，如目标机器，解析`virtual/kernel`到最合适的Linux配方名称。
- en: And within those recipes, `linux-imx`, for example, has both 2.6.35.3 and 3.10.17
    recipe versions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这些配方中，`linux-imx`例如，包含了2.6.35.3和3.10.17的配方版本。
- en: In this recipe, we will show how to tell the Yocto build system which specific
    package and version to build.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示如何告诉Yocto构建系统构建哪个特定的包和版本。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To specify the exact package we want to build, the build system allows us to
    specify what provider and version to use.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定我们要构建的精确包，构建系统允许我们指定要使用的提供者和版本。
- en: How do we select which provider to use?
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何选择使用哪个提供者？
- en: 'We can tell BitBake which recipe to use by using the `PREFERRED_PROVIDER` variable.
    To set a preferred provider for the `virtual/kernel` virtual package on our Wandboard
    machine, we would add the following to its machine configuration file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`PREFERRED_PROVIDER`变量来告诉BitBake使用哪个配方。为了在我们的Wandboard机器上为`virtual/kernel`虚拟包设置首选提供者，我们需要在其机器配置文件中添加以下内容：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How do we select which version to use?
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何选择使用哪个版本？
- en: 'Within a specific provider, we can also tell BitBake which version to use with
    the `PREFERRED_VERSION` variable. For example, to set a specific `linux-imx` version
    for all i.MX6-based machines, we would add the following to our `conf/local.conf`
    file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定的提供者中，我们还可以告诉 BitBake 使用哪个版本，方法是使用 `PREFERRED_VERSION` 变量。例如，要为所有基于 i.MX6
    的机器设置特定的 `linux-imx` 版本，我们将在 `conf/local.conf` 文件中添加以下内容：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `%` wildcard is accepted to match any character, as we see here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`%` 通配符被接受来匹配任何字符，正如我们在这里看到的：'
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is, however, more common to see this type of configuration done in machine
    configuration files, in which case we would not use the `_mx6` append.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，这种类型的配置会在机器配置文件中完成，在这种情况下，我们就不会使用 `_mx6` 的附加操作符了。
- en: How do we select which version not to use?
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何选择不使用哪个版本？
- en: We can use the `DEFAULT_PREFERENCE` variable set to `-1` to specify that a version
    is not to be used unless explicitly set by a `PREFERRED_VERSION` variable. This
    is commonly used in development versions of packages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用将 `DEFAULT_PREFERENCE` 变量设置为 `-1` 的方式来指定除非通过 `PREFERRED_VERSION` 变量显式设置，否则不使用某个版本。这在软件包的开发版本中很常见。
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding supported packages
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加支持的包
- en: It is common to want to add new packages to an image that already has an available
    recipe in one of the included Yocto layers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望向已经在包含的 Yocto 层中有现成配方的镜像中添加新软件包。
- en: When the target image desired is very different from the supplied core images,
    it is recommended to define a new image rather than to customize an existing one.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标镜像与提供的核心镜像差异较大时，建议定义一个新的镜像，而不是定制现有的镜像。
- en: This recipe will show how to customize an existing image by adding supported
    packages to it, but also to create a completely new image recipe if needed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示如何通过向现有镜像中添加支持的包来定制它，但如果需要，也可以创建一个全新的镜像配方。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To discover whether a package we require is included in our configured layers,
    and what specific versions are supported, we can use `bitbake-layers` from our
    build directory as we saw previously:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现我们需要的软件包是否包含在我们配置的层中，以及支持哪些特定版本，我们可以使用来自构建目录的 `bitbake-layers`，正如我们之前所见：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, we can also use BitBake as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以像下面这样使用 BitBake：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or we can use the `find` Linux command in our `sources` directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在 `sources` 目录中使用 `find` Linux 命令：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once we know what packages we want to include in our final images, let's see
    how we can add them to the image.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道要包含哪些软件包在最终的镜像中，接下来我们来看看如何将它们添加到镜像中。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'While developing, we will use our project''s `conf/local.conf` file to add
    customizations. To add packages to all images, we can use the following line of
    code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们将使用我们项目的 `conf/local.conf` 文件来添加自定义内容。要向所有镜像中添加软件包，我们可以使用以下代码行：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there is a space after the first quote to separate the new package
    from the existing ones, as the append operator does not add a space.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个引号后有一个空格，用于将新包与现有包分开，因为附加操作符不会自动添加空格。
- en: 'We could also limit the addition to a specific image with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过以下方式将添加限制到特定镜像：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another way to easily customize is by making use of **features**. A feature
    is a logical grouping of packages. For example, we could create a new feature
    called `debug-utils`, which will add a whole set of debugging utilities. We could
    define our feature in a configuration file or class as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种简单的定制方式是通过利用 **特性**。特性是软件包的逻辑分组。例如，我们可以创建一个新的特性叫做 `debug-utils`，它将添加一整套调试工具。我们可以在配置文件或类中按如下方式定义我们的特性：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We could then add this feature to our image by adding an `EXTRA_IMAGE_FEATURES`
    variable to our `conf/local.conf` file as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过在 `conf/local.conf` 文件中添加 `EXTRA_IMAGE_FEATURES` 变量来将此特性添加到我们的镜像中，如下所示：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you were to add it to an image recipe, you would use the `IMAGE_FEATURES`
    variable instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其添加到镜像配方中，你将使用 `IMAGE_FEATURES` 变量。
- en: 'Usually, features get added as a `packagegroup` recipe instead of being listed
    as packages individually. Let''s show how to define a `packagegroup` recipe in
    the `recipes-core/packagegroups/packagegroup-debug-utils.bb` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，特性作为 `packagegroup` 配方被添加，而不是单独列出作为软件包。让我们展示如何在 `recipes-core/packagegroups/packagegroup-debug-utils.bb`
    文件中定义一个 `packagegroup` 配方：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And you would then add it to the `FEATURE_PACKAGES` variable as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将它添加到 `FEATURE_PACKAGES` 变量中，如下所示：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can use `packagegroups` to create more complex examples. Refer to the *Yocto
    Project Development Manual* at [http://www.yoctoproject.org/docs/1.7.1/dev-manual/dev-manual.html](http://www.yoctoproject.org/docs/1.7.1/dev-manual/dev-manual.html)
    for details.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`packagegroups`来创建更复杂的示例。有关详细信息，请参考*Yocto项目开发手册*，[http://www.yoctoproject.org/docs/1.7.1/dev-manual/dev-manual.html](http://www.yoctoproject.org/docs/1.7.1/dev-manual/dev-manual.html)。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The best approach to customize images is to create our own images using an
    existing image as template. We could use `core-image-minimal.bb`, which contains
    the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义镜像的最佳方法是使用现有镜像作为模板来创建我们自己的镜像。我们可以使用`core-image-minimal.bb`，它包含以下代码：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And extend it to your own version that allows for the customization of `IMAGE_FEATURES`,
    by adding the following `meta-custom/recipes-core/images/custom-image.bb` image
    file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后扩展为我们自己的版本，以允许通过添加以下`meta-custom/recipes-core/images/custom-image.bb`镜像文件来自定义`IMAGE_FEATURES`：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of course, we can also define a new image from scratch using one of the available
    images as a template.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用现有的镜像作为模板，从头定义一个新的镜像。
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A final way to customize images is by adding shell functions that get executed
    once the image has been created. You do this by adding the following to your image
    recipe or `conf/local.conf` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义镜像的最终方法是通过添加 shell 函数，这些函数在镜像创建后执行。你可以通过在镜像配方或`conf/local.conf`文件中添加以下内容来实现：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can use the path to the root filesystem in your command with the `IMAGE_ROOTFS`
    variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在命令中使用`IMAGE_ROOTFS`变量来指定根文件系统的路径。
- en: Classes would use the `IMAGE_POSTPROCESS_COMMAND` variable instead of `ROOTFS_POSTPROCESS_COMMAND`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类别将使用`IMAGE_POSTPROCESS_COMMAND`变量，而不是`ROOTFS_POSTPROCESS_COMMAND`。
- en: One example of usage can be found in the `debug-tweaks` feature in `image.bbclass`,
    when images are tweaked to allow passwordless root logins. This method is also
    commonly used to customize the root password of a target image.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用例示例可以在`image.bbclass`中的`debug-tweaks`功能中找到，当镜像被调整以允许无密码root登录时。这个方法也通常用于自定义目标镜像的root密码。
- en: Configuring packages
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置包
- en: As we saw in the *Configuring the Linux kernel* recipe in [Chapter 2](ch02.html
    "Chapter 2. The BSP Layer"), *The BSP Layer*, some packages, like the Linux kernel,
    provide a configuration menu and can be configured with the `menuconfig` BitBake
    command.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.html "第2章 BSP层")的*配置Linux内核*一节中看到的那样，*BSP层*，一些包（比如Linux内核）提供了一个配置菜单，可以通过`menuconfig`
    BitBake命令进行配置。
- en: 'Another package worth mentioning with a configuration interface is BusyBox.
    We will show how to configure BusyBox, for example to add `pgrep`, a tool that
    looks up process''s IDs by name. To do so follow the next steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的、带有配置界面的包是BusyBox。我们将展示如何配置BusyBox，例如添加`pgrep`，这是一个通过名称查找进程ID的工具。具体步骤如下：
- en: 'Configure BusyBox:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置BusyBox：
- en: '[PRE29]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In **Process utilities** choose `pgrep`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**进程工具**中选择`pgrep`。
- en: 'Compile BusyBox:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译BusyBox：
- en: '[PRE30]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Copy the RPM package into the target:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RPM包复制到目标：
- en: '[PRE31]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Install the RPM package on the target:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标上安装RPM包：
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that we are forcing the update as the package version has not increased
    with the configuration change.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，由于配置更改后包的版本没有增加，我们强制更新。
- en: Adding new packages
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新包
- en: We have seen how to customize our image so that we can add supported packages
    to it. When we can't find an existing recipe or we need to integrate some new
    software we have developed, we will need to create a new Yocto recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何自定义我们的镜像，以便我们可以向其中添加支持的包。当我们找不到现有的配方，或者需要集成我们自己开发的新软件时，我们将需要创建一个新的Yocto配方。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'There are some questions we need to ask ourselves before starting to write
    a new recipe:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写新配方之前，我们需要问自己一些问题：
- en: Where is the source code stored?
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码存储在哪里？
- en: Is it source-controlled or released as a tarball?
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是源代码控制的，还是以tarball形式发布的？
- en: What is the source code license?
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码许可证是什么？
- en: What build system is it using?
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用什么构建系统？
- en: Does it need configuration?
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要配置吗？
- en: Can we cross-compile it as is or does it need to be patched?
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否按原样交叉编译，还是需要打补丁？
- en: What are the files that need to be deployed to the root filesystem, and where
    do they go?
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要部署到根文件系统的文件有哪些，它们应该放在哪里？
- en: Are there any system changes that need to happen, such as new users or `init`
    scripts?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要进行任何系统更改，比如新增用户或`init`脚本？
- en: Are there any dependencies that need to be installed into `sysroot` beforehand?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何依赖项需要提前安装到`sysroot`中？
- en: Once we know the answers to these questions, we are ready to start writing our
    recipe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了这些问题的答案，就可以开始编写我们的食谱了。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: It is best to start from a blank template like the one that follows than to
    start from a similar recipe and modify it, as the result will be cleaner and contain
    only the strictly needed instructions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最好从如下的空白模板开始，而不是从一个类似的食谱开始并修改它，因为这样做的结果会更加干净，并且仅包含严格需要的指令。
- en: 'A good starting base for a minimal recipe addition is:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 添加最小食谱的一个良好起点是：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will explain each one of the recipe sections in more detail in the following
    sections.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分中更详细地解释每个食谱部分。
- en: Package licensing
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包许可证
- en: 'Every recipe needs to contain a `LICENSE` variable. The `LICENSE` variable
    allows you to specify multiple, alternative, and per-package type licenses, as
    seen in the following examples:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个食谱都需要包含`LICENSE`变量。`LICENSE`变量允许你指定多个、替代的以及按包类型的许可证，如下例所示：
- en: 'For MIT or GPLv2 alternative licenses, we will use:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 MIT 或 GPLv2 替代许可证，我们将使用：
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For both ISC and MIT licenses, we will use:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 ISC 和 MIT 许可证，我们将使用：
- en: '[PRE35]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For split packages, all of them GPLv2 except the documentation that is covered
    under the Creative Commons, we will use:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于拆分包，所有包都是 GPLv2，除了文档部分，它是由知识共享协议保护的，我们将使用：
- en: '[PRE36]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Open source packages usually have the license included with the source code
    in `README`, `COPYING`, or `LICENSE` files, and even the source code header files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 开源包通常会在源代码中包含许可证，如`README`、`COPYING`或`LICENSE`文件，甚至在源代码头文件中。
- en: 'For open source licenses, we also need to specify `LIC_FILES_CHECKSUM` for
    all licenses so that the build system can notify us when the licenses change.
    To add it, we locate the file or file portion that contains the license and provide
    its relative path from the directory containing the source and a MD5 checksum
    for it. For example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开源许可证，我们还需要为所有许可证指定`LIC_FILES_CHECKSUM`，以便构建系统在许可证发生变化时通知我们。要添加它，我们定位包含许可证的文件或文件部分，并提供其相对于源目录的路径以及其
    MD5 校验和。例如：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Proprietary code should have the license set as `CLOSED`, and no `LIC_FILES_CHECKSUM`
    is needed for it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 专有代码的许可证应设置为`CLOSED`，不需要为其提供`LIC_FILES_CHECKSUM`。
- en: Fetching package contents
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取包内容
- en: 'The `SRC_URI` variable lists the files to fetch. The build system will use
    different fetchers depending on the file prefix. These can be:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`SRC_URI`变量列出了要获取的文件。构建系统将根据文件前缀使用不同的获取器。这些获取器可以是：'
- en: 'Local files included with the metadata (`file://`). If the local file is a
    patch, the `SRC_URI` variable can be extended with patch-specific arguments such
    as:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与元数据一起包含的本地文件（`file://`）。如果本地文件是补丁，`SRC_URI`变量可以通过补丁特定的参数扩展，如下所示：
- en: '`striplevel`: The default patch strip level is 1 but it can be modified with
    this argument'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`striplevel`：默认的补丁去除级别是 1，但可以通过此参数进行修改'
- en: '`patchdir`: This specifies the directory location to apply the patch to, with
    the default being the source directory'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patchdir`：此参数指定应用补丁的目录位置，默认值为源目录'
- en: '`apply`: This argument controls whether to apply the patch or not, with the
    default being to apply it'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`：此参数控制是否应用补丁，默认情况下会应用补丁'
- en: Files stored in remote servers (typically, `http(s)://`, `ftp://`, or `ssh://`).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在远程服务器上的文件（通常为`http(s)://`、`ftp://`或`ssh://`）。
- en: Files stored in remote repositories (typically, `git://`, `svn://`, `hg://`,
    or `bzr://`). These also need a `SRCREV` variable to specify the revision.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在远程仓库中的文件（通常为`git://`、`svn://`、`hg://`或`bzr://`）。这些文件也需要一个`SRCREV`变量来指定修订版本。
- en: 'Files stored in remote servers (not local files or remote repositories) need
    to specify two checksums. If there are several files, they can be distinguished
    with a `name` argument; for example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在远程服务器上的文件（不是本地文件或远程仓库）需要指定两个校验和。如果有多个文件，可以通过`name`参数来区分；例如：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The source directory folder, `S`, specifies the location of the source files.
    The repository will be checked out here, or the tarball decompressed in this location.
    If the tarball decompresses in the standard `${PN}-${PV}` location, it can be
    omitted as it is the default. For repositories, it needs to always be specified;
    for example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 源目录文件夹`S`指定了源文件的位置。仓库将在此处检出，或者 tarball 会解压到此位置。如果 tarball 解压到标准的`${PN}-${PV}`位置，则可以省略，因为这是默认值。对于仓库，必须始终指定；例如：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Specifying task overrides
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定任务覆盖
- en: 'All recipes inherit the `base.bbclass` class, which defines the following tasks:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有食谱都继承了`base.bbclass`类，该类定义了以下任务：
- en: '`do_fetch`: This method fetches the source code, selecting the fetcher using
    the `SRC_URI` variable.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_fetch`：该方法通过`SRC_URI`变量选择获取器，获取源代码。'
- en: '`do_unpack`: This method unpacks the code in the working directory to a location
    specified by the `S` variable.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_unpack`：该方法将代码解包到由`S`变量指定的位置。'
- en: '`do_configure`: This method configures the source code if needed. It does nothing
    by default.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_configure`：该方法根据需要配置源代码。默认情况下不执行任何操作。'
- en: '`do_compile`: This method compiles the source and runs the GNU make target
    by default.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_compile`：该方法默认编译源代码并运行GNU make目标。'
- en: '`do_install`: This method copies the results of the build from the `build`
    directory `B` to the destination directory `D`. It does nothing by default.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_install`：该方法将构建结果从`build`目录`B`复制到目标目录`D`。默认情况下不执行任何操作。'
- en: '`do_package`: This method splits the deliverables into several packages. It
    does nothing by default.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_package`：该方法将交付物拆分成多个包。默认情况下不执行任何操作。'
- en: Usually, only the configuration, compilation, and installation tasks are overridden,
    and this is mostly done implicitly by inheriting a class like `autotools`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，仅重写配置、编译和安装任务，并且大多数情况下是通过继承`autotools`类隐式完成的。
- en: 'For a custom recipe that does not use a build system, you need to provide the
    required instructions for configuration (if any), compilation, and installation
    in their corresponding `do_configure`, `do_compile`, and `do_install` overrides.
    As an example of this type of recipe, `meta-custom/recipes-example/helloworld/helloworld_1.0.bb`,
    may be seen here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不使用构建系统的自定义配方，您需要在相应的`do_configure`、`do_compile`和`do_install`重写方法中提供所需的配置（如果有）、编译和安装指令。以下是这种类型配方的示例，位于`meta-custom/recipes-example/helloworld/helloworld_1.0.bb`：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the `meta-custom/recipes-example/helloworld/helloworld-1.0/helloworld.c`
    source file being the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta-custom/recipes-example/helloworld/helloworld-1.0/helloworld.c`源文件如下：'
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will see example recipes that use the most common build systems in the next
    chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到使用最常见构建系统的示例配方。
- en: Configuring packages
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置包
- en: 'The Yocto build system provides the `PACKAGECONFIG` variable to help in the
    configuration of packages by defining a number of features. Your recipe defines
    the individual features as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto构建系统提供了`PACKAGECONFIG`变量，用于通过定义多个特性来帮助配置包。您的配方通过以下方式定义单个特性：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `PACKAGECONFIG` variable contains a space-separated list of feature names,
    and it can be extended or overridden in `bbappend` files; have a look at the following
    example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`PACKAGECONFIG`变量包含一个以空格分隔的特性名称列表，并且可以在`bbappend`文件中进行扩展或重写；请查看以下示例：'
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To extend or override it from a distribution or local configuration file, you
    would use the following syntax:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要从发行版或本地配置文件扩展或重写它，您需要使用以下语法：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Following that, we characterize each feature with four ordered arguments:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用四个有序参数来描述每个特性：
- en: Extra configuration arguments (for `EXTRA_OECONF`) when the feature is enabled
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用特性时的额外配置参数（对于`EXTRA_OECONF`）
- en: Extra configuration arguments (for `EXTRA_OECONF`) when the feature is disabled
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用特性时的额外配置参数（对于`EXTRA_OECONF`）
- en: Extra build dependencies (for `DEPENDS`) when the feature is enabled
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用特性时的额外构建依赖（对于`DEPENDS`）
- en: Extra runtime dependencies (for `RDEPENDS`) when the feature is enabled
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用特性时的额外运行时依赖（对于`RDEPENDS`）
- en: The four arguments are optional, but the ordering needs to be maintained by
    leaving the surrounding commas.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个参数是可选的，但必须保持其顺序，并且需要保留分隔的逗号。
- en: 'For example, the `wpa-supplicant` recipe defines two features, `gnutls` and
    `openssl`, but only enables `gnutls` by default, as seen here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`wpa-supplicant`配方定义了两个特性，`gnutls`和`openssl`，但默认仅启用`gnutls`，如下所示：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Splitting into several packages
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆分成多个包
- en: 'It is common to separate the recipe contents into different packages that serve
    different needs. Typical examples are to include documentation in a `doc` package,
    and header and/or libraries in a `dev` package. We can do this using the `FILES`
    variable as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将配方内容分成不同的包以满足不同的需求是常见做法。典型的例子是将文档包含在`doc`包中，将头文件和/或库包含在`dev`包中。我们可以通过使用`FILES`变量来实现这一点，示例如下：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Setting machine-specific variables
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置特定于机器的变量
- en: Each recipe has a `PACKAGE_ARCH` variable that categorizes the recipe into a
    package feed, as we saw in the *Exploring an image's contents* recipe. Most of
    the times, they are automatically sorted out by the Yocto build system. For example,
    if the recipe is a kernel, a kernel module recipe, or an image recipe, or even
    if it is cross-compiling or building native applications, the Yocto build system
    will set the package architecture accordingly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配方都有一个`PACKAGE_ARCH`变量，用于将配方分类到一个软件包源中，正如我们在*探索镜像内容*的配方中看到的那样。大多数时候，它们由Yocto构建系统自动分类。例如，如果配方是内核、内核模块配方、镜像配方，或者是交叉编译或构建本地应用程序，Yocto构建系统将相应地设置软件包架构。
- en: BitBake will also look at the `SRC_URI` machine overrides and adjust the package
    architecture, and if your recipe is using the `allarch` class, it will set the
    package architecture to `all`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake还会查看`SRC_URI`的机器覆盖并调整软件包架构，如果你的配方使用`allarch`类，它将把软件包架构设置为`all`。
- en: 'So when working on a recipe that only applies to a machine or machine family,
    or that contains changes that are specific to a machine or machine family, we
    need to check whether the package is categorized in the appropriate package feed,
    and if not, specify the package architecture explicitly in the recipe itself by
    using the following line of code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在处理仅适用于特定机器或机器系列的配方时，或者涉及特定机器或机器系列的更改时，我们需要检查软件包是否被分类到适当的软件包源中。如果没有，则需要通过在配方中明确指定以下代码行来指定软件包架构：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Also, when a recipe is only to be parsed for specific machine types, we specify
    it with the `COMPATIBLE_MACHINE` variable. For example, to make it compatible
    only with the `mxs, mx5 and mx6 SoC families`, we would use the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当一个配方仅用于特定的机器类型时，我们使用`COMPATIBLE_MACHINE`变量来指定。例如，为了让它仅兼容`mxs、mx5 和 mx6 SoC
    系列`，我们会使用以下内容：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Adding data, scripts, or configuration files
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据、脚本或配置文件
- en: All recipes inherit the base class with the default set of tasks to run. After
    inheriting the base class, a recipe knows how to do things like fetching and compiling.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所有配方都继承了基类，并执行默认的任务集合。继承基类后，配方知道如何执行诸如获取和编译之类的任务。
- en: As most recipes are meant to install some sort of executable, the base class
    knows how to build it. But sometimes all we want is to install data, scripts,
    or configuration files into the filesystem.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数配方旨在安装某种可执行文件，基类知道如何构建它。但有时我们所需要的仅仅是将数据、脚本或配置文件安装到文件系统中。
- en: If the data or configuration is related to an application, the most logical
    thing to do is to package it together with the application's recipe itself, and
    if we think it is better to be installed separately, we could even split it into
    its own package.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据或配置与应用程序相关，最合逻辑的做法是将其与应用程序的配方本身打包在一起，如果我们认为分开安装更好，甚至可以将其拆分成单独的包。
- en: But some other times, the data or configuration is unrelated to an application,
    maybe it applies to the whole system or we just want to provide a separate recipe
    for it. Optionally, we could even want to install some Perl or Python scripts
    that don't need to be compiled.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，数据或配置与应用程序无关，可能适用于整个系统，或者我们只想为其提供一个单独的配方。根据需要，我们甚至可能希望安装一些不需要编译的Perl或Python脚本。
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In those cases, our recipe should inherit the `allarch` class that is inherited
    by recipes that do not produce architecture-specific output.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们的配方应该继承`allarch`类，该类被那些不产生特定架构输出的配方继承。
- en: 'An example of this type of recipe, `meta-custom/recipes-example/example-data/example-data_1.0.bb`,
    may be seen here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的配方示例`meta-custom/recipes-example/example-data/example-data_1.0.bb`可以在这里查看：
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It assumes that the fictitious `examples.git` repository contains a `python-scripts`
    folder, which we want to include in our root filesystem.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 它假设虚构的`examples.git`仓库包含一个我们想要包括在根文件系统中的`python-scripts`文件夹。
- en: A working recipe example can be found in the source that accompanies the book.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可用的配方示例可以在与本书附带的源代码中找到。
- en: Managing users and groups
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户和组
- en: It is also common to need to add or modify users and groups to our filesystem.
    This recipe explains how it is done.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，我们还需要向文件系统中添加或修改用户和组。这个配方解释了如何做到这一点。
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The user information is stored in the `/etc/passwd` file, a text file that is
    used as a database for the system user's information. The `passwd` file is human-readable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 用户信息存储在`/etc/passwd`文件中，这是一个文本文件，用作系统用户信息的数据库。`passwd`文件是人类可读的。
- en: 'Each line on it corresponds to one user in the system, and it has the following
    format:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行对应系统中的一个用户，格式如下：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s see each of the parameters of this format:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种格式的每个参数：
- en: '`username`: A unique string that identifies the user at login'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`：一个唯一的字符串，用于标识用户在登录时的身份'
- en: '`uid`: User ID, a number that Linux uses to identify the user'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uid`：用户ID，Linux用来识别用户的数字'
- en: '`gid`: Group ID, a number that Linux uses to identify the user''s primary group'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gid`：组ID，Linux用来识别用户主组的数字'
- en: '`comment`: Comma-separated values that describe the account, typically the
    user''s contact details'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comment`：以逗号分隔的值，用来描述账户，通常是用户的联系方式'
- en: '`home directory`: Path to the user''s home directory'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home directory`：用户主目录的路径'
- en: '`login shell`: Shell that is started for interactive logins'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login shell`：为交互式登录启动的Shell'
- en: 'The default `passwd` file is stored with the `base-passwd` package and looks
    as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`passwd`文件存储在`base-passwd`包中，格式如下：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: All accounts have disabled direct logins, indicated by an asterisk on the password
    field, except for root, which has no password. This is because, by default, the
    image is built with the `debug-tweaks` feature that enables passwordless login
    for the root user, among other things. If the root password was enabled, we would
    see the encrypted root password.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 所有账户的直接登录功能都被禁用，密码字段上会显示一个星号，除root用户外，root没有密码。这是因为默认情况下，镜像是通过启用`debug-tweaks`功能构建的，该功能启用了root用户的无密码登录功能。若启用root密码，则会显示加密后的root密码。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not forget to remove the `debug-tweaks` feature from production images.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记从生产镜像中移除`debug-tweaks`功能。
- en: There is a corresponding `/etc/group` file that is installed at the same time
    with the information for the system groups.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同时间安装的`/etc/group`文件包含系统组的信息。
- en: The `core-image-minimal` image does not include shadow password protection,
    but other images, such as `core-image-full-cmdline`, do. When enabled, all password
    fields contain an *x*, and the encrypted passwords are kept on a `/etc/shadow`
    file, which is only accessible to the super user.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`core-image-minimal`镜像不包括影子密码保护，但其他镜像，如`core-image-full-cmdline`，是包括的。启用时，所有密码字段会包含一个*
    x *，加密后的密码存储在`/etc/shadow`文件中，该文件只有超级用户才能访问。'
- en: Any user that is needed by the system but not included in the list we saw earlier
    needs to be created.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 系统所需的任何用户，如果不在我们之前看到的列表中，也需要被创建。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The standard way for a recipe to add or modify system users or groups is to
    use the `useradd` class, which uses the following variables:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱添加或修改系统用户或组的标准方法是使用`useradd`类，该类使用以下变量：
- en: '`USERADD_PACKAGES`: This variable specifies the individual packages in the
    recipe that require users or groups to be added. For the main package, you would
    use the following:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USERADD_PACKAGES`：此变量指定食谱中需要添加用户或组的独立包。对于主包，您可以使用以下内容：'
- en: '[PRE52]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`USERADD_PARAM`: This variable corresponds to the arguments passed to the Linux
    `useradd` command, to add new users to the system.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USERADD_PARAM`：此变量对应传递给Linux `useradd`命令的参数，用于向系统添加新用户。'
- en: '`GROUPADD_PARAM`: This variable corresponds to the arguments passed to the
    Linux `groupadd` command, to add new groups to the system.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GROUPADD_PARAM`：此变量对应传递给Linux `groupadd`命令的参数，用于向系统添加新组。'
- en: '`GROUPMEMS_PARAM`: This variable corresponds to the arguments passed to the
    Linux `groupmems` command, which administers members of the user''s primary group.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GROUPMEMS_PARAM`：此变量对应传递给Linux `groupmems`命令的参数，用于管理用户主组的成员。'
- en: 'An example snippet of a recipe using the `useradd` class follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`useradd`类的食谱示例片段：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The password can be generated on your host using the `mkpasswd` Linux command-line
    utility, installed with the `whois` Ubuntu package.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 密码可以通过在主机上使用`mkpasswd` Linux命令行工具生成，该工具随着`whois` Ubuntu包一起安装。
- en: There's more...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: When generating users and groups using the `useradd` class, the `uid` and `gid`
    values are assigned dynamically during package installation. If this is not desired,
    there is a way to assign system-wide static `uid` and `gid` values by providing
    your own `passwd` and group files.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`useradd`类生成用户和组时，`uid`和`gid`值会在包安装过程中动态分配。如果不希望这样，可以通过提供自己的`passwd`和组文件来分配全局静态的`uid`和`gid`值。
- en: 'To do this, you need to define the `USERADDEXTENSION` variable in your `conf/local.conf`
    file as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要在`conf/local.conf`文件中定义`USERADDEXTENSION`变量，如下所示：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The build system will then search the `BBPATH` variable for `files/passwd` and
    `files/group` files to obtain the `uid` and `gid` values. The files have the standard
    `passwd` layout as defined previously, with the password field ignored.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统将搜索 `BBPATH` 变量以获取 `files/passwd` 和 `files/group` 文件，以获取 `uid` 和 `gid` 值。这些文件具有先前定义的标准
    `passwd` 布局，密码字段被忽略。
- en: The default filenames can be overridden by using the `USERADD_UID_TABLES` and
    `USERADD_GID_TABLES` variables.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `USERADD_UID_TABLES` 和 `USERADD_GID_TABLES` 变量重写默认文件名。
- en: 'You also need to define the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要定义以下内容：
- en: '[PRE55]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is done so that the build system produces an error if the required `uid`
    and `gid` values are not found in the provided files.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了当提供的文件中找不到所需的 `uid` 和 `gid` 值时，构建系统产生错误。
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you use the `useradd` class in a project that is already built,
    you will need to remove the `tmp` directory and rebuild from the `sstate-cache`
    directory or you will get build errors.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果在已构建的项目中使用 `useradd` 类，您需要删除 `tmp` 目录并从 `sstate-cache` 目录重新构建，否则将出现构建错误。
- en: 'There is also a way to add user and group information that is not tied to a
    specific recipe but to an image – by using the `extrausers` class. It is configured
    by the `EXTRA_USERS_PARAMS` variable in an image recipe and used as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以添加与特定配方无关但与映像相关的用户和组信息 - 使用 `extrausers` 类。它通过映像配方中的 `EXTRA_USERS_PARAMS`
    变量配置，并如下使用：
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This sets the root password to `password`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 root 密码设置为 `password`。
- en: Using the sysvinit initialization manager
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 sysvinit 初始化管理器
- en: The initialization manager is an important part of the root filesystem. It is
    the first thing the kernel executes, and it has the responsibility to start the
    rest of the system.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化管理器是根文件系统的重要部分。这是内核执行的第一件事，并且有责任启动系统的其余部分。
- en: This recipe will introduce the `sysvinit` initialization manager.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方将介绍 `sysvinit` 初始化管理器。
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This is the default initialization manager in Yocto and it has been used in
    Linux since the operating system's origin. The kernel is passed an `init` command-line
    argument, typically `/sbin/init`, which is then launched. This `init` process
    has PID 1 and is the parent of all processes. The `init` process can either be
    implemented by BusyBox or be an independent program installed with the `sysvinit`
    package. Both of them work in the same way, based on the concept of **runlevel**,
    a machine state that defines which processes to run.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Yocto 中的默认初始化管理器，并且自操作系统起源以来一直在 Linux 中使用。内核传递一个 `init` 命令行参数，通常为 `/sbin/init`，然后启动它。此
    `init` 进程具有 PID 1 并且是所有进程的父进程。`init` 进程可以由 BusyBox 实现，也可以是与 `sysvinit` 包独立安装的独立程序。它们都以相同的方式工作，基于
    **运行级别** 的概念，即定义要运行哪些进程的机器状态。
- en: 'The `init` process will read an `inittab` file and look for a default runlevel.
    The default `inittab` file is installed with the `sysvinit-inittab` package and
    is as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 进程将读取一个 `inittab` 文件，并查找默认运行级别。默认的 `inittab` 文件安装在 `sysvinit-inittab`
    包中，并且如下所示：'
- en: '[PRE57]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Then, `init` runs all scripts starting with `S` in the `/etc/rcS.d` directory,
    followed by all the scripts starting with `S` in the `/etc/rcN.d` directory, where
    `N` is the runlevel value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`init` 运行 `/etc/rcS.d` 目录中以 `S` 开头的所有脚本，然后运行 `/etc/rcN.d` 目录中以 `S` 开头的所有脚本，其中
    `N` 是运行级别值。
- en: So the `init` process just performs the initialization and forgets about the
    processes. If something goes wrong and the processes are killed, no one will care.
    The system watchdog will reboot the system if it becomes unresponsive, but applications
    built with more than one process usually need some type of process monitor that
    can react to the health of the system, but `sysvinit` does not offer these types
    of mechanisms.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`init` 进程只执行初始化并忽略进程。如果发生故障并且进程被终止，没有人会关心。如果系统不响应，系统看门狗将重新启动系统，但通常需要具有某种类型进程监视器以响应系统健康的应用程序，但
    `sysvinit` 不提供这些类型的机制。
- en: However, `sysvinit` is a well-understood and reliable initialization manager
    and the recommendation is to keep it unless you need some extra feature.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`sysvinit` 是一个被充分理解和可靠的初始化管理器，建议保留，除非需要一些额外的功能。
- en: How to do it...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: When using `sysvinit` as the initialization manager, Yocto offers the `update-rc.d`
    class as a helper to install initialization scripts so that they are started and
    stopped when needed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `sysvinit` 作为初始化管理器时，Yocto 提供 `update-rc.d` 类作为辅助工具，安装初始化脚本，以便在需要时启动和停止它们。
- en: 'When using this class, you need to specify the `INITSCRIPT_NAME` variable with
    the name of the script to install and `INITSCRIPT_PARAMS` with the options to
    pass to the `update-rc.d` utility. You can optionally use the `INITSCRIPT_PACKAGES`
    variable to list the packages to contain the initialization scripts. By default,
    this contains the main package only, and if multiple packages are provided, the
    `INITSCRIPT_NAME` and `INITSCRIPT_PARAMS` need to be specified for each using
    overrides. An example snippet follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此类时，你需要指定`INITSCRIPT_NAME`变量，该变量指定要安装的脚本名称，`INITSCRIPT_PARAMS`指定传递给`update-rc.d`工具的选项。你可以选择性地使用`INITSCRIPT_PACKAGES`变量列出包含初始化脚本的包。默认情况下，这只包含主包，如果提供多个包，则需要为每个包指定`INITSCRIPT_NAME`和`INITSCRIPT_PARAMS`，并使用覆盖方式。以下是一个示例片段：
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When an initialization script is not tied to a particular recipe, we can add
    a specific recipe for it. For example, the following recipe will run a `mount.sh`
    script in the `recipes-example/sysvinit-mount/sysvinit-mount_1.0.bb` file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化脚本未绑定到特定的食谱时，我们可以为其添加一个特定的食谱。例如，以下食谱将在`recipes-example/sysvinit-mount/sysvinit-mount_1.0.bb`文件中运行`mount.sh`脚本。
- en: '[PRE59]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using the systemd initialization manager
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`systemd`初始化管理器
- en: As an alternative to `sysvinit`, you can configure your project to use `systemd`
    as an initialization manager, although `systemd` packs many more features.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`sysvinit`的替代方案，你可以配置项目使用`systemd`作为初始化管理器，尽管`systemd`包含更多功能。
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `systemd` initialization manager is replacing `sysvinit` and other initialization
    managers in most Linux distributions. It is based on the concepts of units, an
    abstraction of all elements that are relevant for system startup and maintenance,
    and targets, which group units and can be viewed as a runlevel equivalent. Some
    of the units `systemd` defines are:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`初始化管理器正在取代大多数Linux发行版中的`sysvinit`和其他初始化管理器。它基于单元的概念，单元是所有与系统启动和维护相关的元素的抽象，而目标是将单元分组，并且可以视为运行级别的等价物。`systemd`定义的一些单元包括：'
- en: Services
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Sockets
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字
- en: Devices
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备
- en: Mount points
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载点
- en: Snapshots
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照
- en: Timers
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器
- en: Paths
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径
- en: 'The default targets and their runlevel equivalents are defined in the following
    table:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 默认目标及其对应的运行级别在下表中定义：
- en: '| Sysvinit | Runlevel | Systemd target | Notes |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| Sysvinit | 运行级别 | Systemd目标 | 备注 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | `runlevel0.target` | `poweroff.target` | Halt the system. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 0 | `runlevel0.target` | `poweroff.target` | 关闭系统。|'
- en: '| 1, s, single | `runlevel1.target` | `rescue.target` | Single user mode. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 1, s, single | `runlevel1.target` | `rescue.target` | 单用户模式。|'
- en: '| 2, 4 | `runlevel2.target`, `runlevel4.target` | `multi-user.target` | User-defined/site-specific
    runlevels. By default, identical to `3`. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 2, 4 | `runlevel2.target`, `runlevel4.target` | `multi-user.target` | 用户定义的/特定站点的运行级别。默认情况下，与`3`相同。|'
- en: '| 3 | `runlevel3.target` | `multi-user.target` | Multiuser, non-graphical.
    Users can usually log in via multiple consoles or via the network. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `runlevel3.target` | `multi-user.target` | 多用户、非图形模式。用户通常可以通过多个控制台或网络登录。|'
- en: '| 5 | `runlevel5.target` | `graphical.target` | Multiuser, graphical. Usually
    has all the services of runlevel 3 plus a graphical login. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `runlevel5.target` | `graphical.target` | 多用户、图形模式。通常包括运行级别3的所有服务以及图形登录。|'
- en: '| 6 | `runlevel6.target` | `reboot.target` | Reboot the system. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `runlevel6.target` | `reboot.target` | 重启系统。|'
- en: The `systemd` initialization manager is designed to be compatible with `sysvinit`,
    including using `sysvinit init` scripts.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`初始化管理器设计上与`sysvinit`兼容，包括使用`sysvinit init`脚本。'
- en: 'Some of the features of `systemd` are:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`的一些特点包括：'
- en: Parallelization capabilities that allow for faster boot times
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许更快启动时间的并行化功能
- en: Service initialization via sockets and D-Bus so that services are only started
    when needed
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过套接字和D-Bus进行服务初始化，以便仅在需要时启动服务
- en: Process monitoring that allows for process failure recovery
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许进程失败恢复的进程监控
- en: System state snapshots and restoration
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统状态快照和恢复
- en: Mount point management
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载点管理
- en: Transactional-dependency-based unit control, where units establish dependencies
    between them
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于事务依赖的单元控制，其中单元之间建立了依赖关系
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To configure your system to use `systemd`, you need to add the `systemd` distribution
    feature to your project by adding the following to your distribution''s configuration
    file, under `sources/poky/meta-yocto/conf/distro/poky.conf` for the default `poky`
    distribution, or locally on your project''s `conf/local.conf` file:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置你的系统使用`systemd`，你需要通过将以下内容添加到分发配置文件中，在`poky`分发的默认配置文件` sources/poky/meta-yocto/conf/distro/poky.conf`中，或者在你项目的`conf/local.conf`文件中，来将`systemd`分发功能添加到项目中：
- en: '[PRE60]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the space required after the starting quote.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意开始引号后的空格。
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This configuration example allows you to define a main image with `systemd`
    and a rescue image with `sysvinit`, providing it does not use the `VIRTUAL-RUNTIME_init_manager`
    variable. Hence, the rescue image cannot use the `packagegroup-core-boot` or `packagegroup-core-full-cmdline`
    recipes. As an example, the recipe where the image size has been reduced, which
    we will introduce in the *Reducing the root filesystem image size* recipe in this
    chapter, could be used as the basis for a rescue image.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置示例允许你定义一个带有`systemd`的主镜像和一个带有`sysvinit`的救援镜像，前提是它不使用`VIRTUAL-RUNTIME_init_manager`变量。因此，救援镜像不能使用`packagegroup-core-boot`或`packagegroup-core-full-cmdline`食谱。例如，本章稍后将介绍的*减少根文件系统镜像大小*食谱中的镜像大小已被减小，可以作为救援镜像的基础。
- en: 'To remove `sysvinit` completely from your system, you would do the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全从系统中删除`sysvinit`，你需要执行以下操作：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Feature backfilling is the automatic extension of machine and distribution features
    to keep backwards compatibility. The `sysvinit` distribution feature is automatically
    filled in, so to remove it, we need to blacklist it by adding it to the `DISTRO_FEATURES_BACKFILL_CONSIDERED`
    variable as shown earlier.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 功能回填是自动扩展机器和分发功能，以保持向后兼容性。`sysvinit`分发功能会自动回填，因此，要删除它，我们需要将其添加到`DISTRO_FEATURES_BACKFILL_CONSIDERED`变量中，如前所述。
- en: Tip
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that if you are using an existing project and you change the `DISTRO_FEATURES`
    variable as explained earlier, you will need to remove the `tmp` directory and
    build with `sstate-cache` or the build will fail.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你正在使用现有项目，并且按照前文所述更改了`DISTRO_FEATURES`变量，你需要删除`tmp`目录并使用` sstate-cache`重新构建，否则构建将失败。
- en: There's more...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Not only does the root filesystem needs to be configured, but the Linux kernel
    also needs to be specifically configured with all the features required by `systemd`.
    There is an extensive list of kernel configuration variables in the `systemd`
    source README file. As an example, to extend the minimal kernel configuration
    that we will introduce in the *Reducing the Linux kernel image size* recipe later
    on this chapter, for the Wandboard to support `systemd`, we would need to add
    the following configuration changes in the `arch/arm/configs/wandboard-quad_minimal_defconfig`
    file:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅根文件系统需要配置，Linux内核也需要特别配置，以满足`systemd`所需的所有功能。`systemd`源代码README文件中有一份详细的内核配置变量列表。举例来说，要扩展我们将在本章稍后介绍的*减少Linux内核镜像大小*食谱中的最小内核配置，以支持Wandboard的`systemd`，我们需要在`arch/arm/configs/wandboard-quad_minimal_defconfig`文件中添加以下配置更改：
- en: '[PRE63]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The default kernel configuration provided for the Wandboard will launch a `core-image-minimal`
    image of `systemd` just fine.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为Wandboard提供的默认内核配置将正常启动一个带有`systemd`的`core-image-minimal`镜像。
- en: Installing systemd unit files
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装systemd单元文件
- en: Yocto offers the `systemd` class as a helper to install unit files. By default,
    unit files are installed on the `${systemd_unitdir}/system` path on the destination
    directory.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto提供了`systemd`类作为辅助工具来安装单元文件。默认情况下，单元文件会安装在目标目录的`${systemd_unitdir}/system`路径下。
- en: When using this class, you need to specify the `SYSTEMD_SERVICE_${PN}` variable
    with the name of the unit file to install. You can optionally use the `SYSTEMD_PACKAGES`
    variable to list the packages to contain the unit files. By default, this is the
    main package only, and if multiple packages are provided, the `SYSTEMD_SERVICE`
    variable needs to be specified using overrides.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此类时，需要指定`SYSTEMD_SERVICE_${PN}`变量，值为要安装的单元文件的名称。你也可以选择使用`SYSTEMD_PACKAGES`变量来列出包含单元文件的包。默认情况下，这只包含主包，如果提供多个包，则需要使用覆盖方式指定`SYSTEMD_SERVICE`变量。
- en: Services are configured to launch at boot by default, but this can be changed
    with the `SYSTEMD_AUTO_ENABLE` variable.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 服务默认配置为在启动时自动启动，但你可以通过`SYSTEMD_AUTO_ENABLE`变量来更改此设置。
- en: 'An example snippet follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例代码片段：
- en: '[PRE64]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Installing package-installation scripts
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装包安装脚本
- en: The supported package formats, RPM, ipk, and deb, support the addition of installation
    scripts that can be run at different times during a package installation process.
    In this recipe, we will see how to install them.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的包格式（RPM、ipk 和 deb）支持在包安装过程中添加安装脚本，这些脚本可以在不同的时间运行。在本配方中，我们将看到如何安装这些脚本。
- en: Getting ready
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are different types of installation scripts:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的安装脚本：
- en: '**Preinstallation scripts** (`pkg_preinst`): These are called before the package
    is unpacked'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预安装脚本** (`pkg_preinst`)：这些脚本在软件包解包之前调用。'
- en: '**Postinstallation scripts** (`pkg_postinst`): These are called after the package
    is unpacked, and dependencies will be configured'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后安装脚本** (`pkg_postinst`)：这些脚本在软件包解包后调用，并且会配置依赖关系。'
- en: '**Preremoval scripts** (`pkg_prerm`): These are called with installed or at
    least partially installed packages'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卸载前脚本** (`pkg_prerm`)：这些脚本在已安装或至少部分安装的软件包时调用。'
- en: '**Postremoval scripts** (`pkg_postrm`): These are called after the package''s
    files have been removed or replaced'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卸载后脚本** (`pkg_postrm`)：这些脚本在软件包的文件被移除或替换之后调用。'
- en: How to do it...
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'An example snippet of the installation of a preinstallation script in a recipe
    is as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在配方中安装预安装脚本的示例片段：
- en: '[PRE65]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'All installation scripts work in the same way, with the exception that the
    postinstallation scripts may be run either on the host at root filesystem image
    creation time, on the target (for those actions that cannot be performed on the
    host), or when a package is directly installed on the target. Have a look at the
    following code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 所有安装脚本的工作方式相同，不同之处在于，后安装脚本可以在主机上创建根文件系统镜像时、在目标设备上（对于无法在主机上执行的操作），或者在软件包直接安装到目标设备时运行。请查看以下代码：
- en: '[PRE66]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the postinstallation script succeeds, the package is marked as installed.
    If the script fails, the package is marked as unpacked and the script is executed
    when the image boots again.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后安装脚本成功，软件包将被标记为已安装。如果脚本失败，软件包将被标记为未解包，脚本将在镜像再次启动时执行。
- en: How it works...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Once the recipe defines an installation script, the class for the specific package
    type will install it while following the packaging rules of the specific format.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配方定义了安装脚本，特定包类型的类将在遵循特定格式的打包规则的同时安装该脚本。
- en: For postinstallation scripts, when running on the host, `D` is set to the destination
    directory, so the comparison test will fail. But `D` will be empty when running
    on the target.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后安装脚本，当在主机上运行时，`D` 被设置为目标目录，因此比较测试将失败。但当在目标设备上运行时，`D` 将为空。
- en: Note
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended to perform postinstallation scripts on the host if possible,
    as we need to take into account that some root filesystems will be read only and
    hence it would not be possible to perform some operations on the target.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，建议在主机上执行后安装脚本，因为我们需要考虑到某些根文件系统将是只读的，因此无法在目标设备上执行某些操作。
- en: Reducing the Linux kernel image size
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少 Linux 内核镜像大小
- en: Before or in parallel with the root filesystem customization, embedded projects
    usually require an image size optimization that will reduce the boot time and
    memory usage.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在根文件系统定制之前或与之并行，嵌入式项目通常需要进行镜像大小优化，以减少启动时间和内存使用。
- en: Smaller images mean less storage space, less transmission time, and less programming
    time, which saves money both in manufacturing and field updates.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 更小的镜像意味着更少的存储空间、传输时间和编程时间，从而在制造和现场更新中节省成本。
- en: By default, the compressed Linux kernel image (**zImage**) for the `wandboard-quad`
    is around 5.2 MB. This recipe will show how we can reduce that.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`wandboard-quad` 的压缩 Linux 内核镜像（**zImage**）大约为 5.2 MB。这个配方将展示我们如何减少该镜像的大小。
- en: How to do it...
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'An example of a minimal kernel configuration for a Wandboard that is able to
    boot from a microSD card root filesystem is the `arch/arm/configs/wandboard-quad_minimal_defconfig`
    file that follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一个能够从 microSD 卡根文件系统启动的 Wandboard 的最小内核配置示例是以下的 `arch/arm/configs/wandboard-quad_minimal_defconfig`
    文件：
- en: '[PRE67]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This configuration builds an 886 K compressed Linux kernel image (zImage).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置生成一个 886 KB 压缩的 Linux 内核镜像（zImage）。
- en: How it works...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Apart from hardware design considerations (such as running the Linux kernel
    from a NOR flash and **execute in place** (**XIP**) to avoid loading the image
    to memory), the first step in kernel size optimization is to review the kernel
    configuration and remove all superfluous features.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 除了硬件设计考虑因素（如从NOR闪存运行Linux内核，并使用**就地执行** (**XIP**) 来避免将镜像加载到内存中），内核大小优化的第一步是审查内核配置并移除所有多余的功能。
- en: 'To analyze the sizes of kernel blocks, we may use:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析内核块的大小，我们可以使用：
- en: '[PRE68]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, `vmlinux` is the Linux kernel ELF image, which can be found in the Linux
    `build` directory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`vmlinux`是Linux内核ELF镜像，可以在Linux的`build`目录中找到。
- en: 'Some of the usual things to exclude are:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 一些通常需要排除的内容包括：
- en: Remove IPv6 (`CONFIG_IPV6`) and other superfluous networking features
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除IPv6（`CONFIG_IPV6`）和其他多余的网络功能
- en: Remove block devices (`CONFIG_BLOCK`) if not needed
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不需要，请移除块设备（`CONFIG_BLOCK`）
- en: Remove cryptographic features (`CONFIG_CRYPTO`) if unused
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未使用，请移除加密特性（`CONFIG_CRYPTO`）
- en: Review the supported filesystem types and remove the unneeded ones, such as
    flash filesystems on flashless devices
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查支持的文件系统类型并移除不需要的文件系统，例如在没有闪存设备上使用的闪存文件系统
- en: Avoid modules and remove the module support (`CONFIG_MODULES`) from the kernel
    if possible
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免模块，如果可能，移除内核中的模块支持（`CONFIG_MODULES`）。
- en: A good strategy is to start with a minimal kernel and add the essential stuff
    until you get a working system. Start with the `allnoconfig` GNU make target and
    review the configuration items under `CONFIG_EXPERT` and `CONFIG_EMBEDDED` as
    they are not included in the `allnoconfig` setting.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的策略是从一个最小的内核开始，逐步添加必要的功能直到你得到一个工作系统。从`allnoconfig` GNU make目标开始，并审查`CONFIG_EXPERT`和`CONFIG_EMBEDDED`下的配置项，因为这些配置项不包含在`allnoconfig`设置中。
- en: 'Some configuration changes that might not be obvious but reduce the image size
    considerably without feature removal are listed here:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能不太明显，但在不移除功能的情况下显著减少镜像大小的配置更改：
- en: Change the default compression method from **Lempel–Ziv–Oberhumer** (**LZO**)
    to XZ (`CONFIG_KERNEL_XZ`). The decompression speed will be a bit lower though.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将默认压缩方法从**Lempel–Ziv–Oberhumer** (**LZO**)改为XZ（`CONFIG_KERNEL_XZ`）。不过，解压速度可能稍微慢一些。
- en: Change the allocator from SLUB to **Simple List Of Blocks** (**SLOB**) (`CONFIG_SLOB`)
    for small embedded systems with little memory.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分配器从SLUB更改为**简单块列表** (**SLOB**)（`CONFIG_SLOB`），适用于内存较小的小型嵌入式系统。
- en: Use no high memory (`CONFIG_HIGHMEM`) unless you have 4 GB or more memory.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你有4GB或更多内存，否则请不要使用高内存（`CONFIG_HIGHMEM`）。
- en: 'You may also want to have a different configuration for production and development
    systems, so you may remove the following from your production images:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还希望为生产和开发系统设置不同的配置，因此你可以从生产镜像中移除以下内容：
- en: '`printk` support (`CONFIG_PRINTK`)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printk`支持（`CONFIG_PRINTK`）'
- en: '`tracing` support (`CONFIG_FTRACE`)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracing`支持（`CONFIG_FTRACE`）'
- en: In the compilation side of things, optimize for size using `CONFIG_CC_OPTIMIZE_FOR_SIZE`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译方面，使用`CONFIG_CC_OPTIMIZE_FOR_SIZE`进行大小优化。
- en: 'Once the basics are covered, we would need to analyze the kernel functions
    to identify further reduction areas. You can print a sorted list of kernel symbols
    with the following:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦基本配置完成，我们需要分析内核功能，找出进一步的优化空间。你可以使用以下命令打印一个已排序的内核符号列表：
- en: '[PRE69]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You would then need to look into the kernel source to find optimizations.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要查看内核源码以找到优化点。
- en: 'The actual space used by the uncompressed kernel in memory can be obtained
    from a running Wandboard kernel log as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行中的Wandboard内核日志获取未压缩内核在内存中实际使用的空间，如下所示：
- en: '[PRE70]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'From here, the `.text` section contains code and constant data, the `.data`
    section contains the initialization data for variables, and the `.bss` sections
    contains all uninitialized data. The `.init` section contains global variables
    used during Linux initialization only, which are freed afterwards as can be seen
    from the following Linux kernel boot message:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，`.text`部分包含代码和常量数据，`.data`部分包含变量的初始化数据，`.bss`部分包含所有未初始化的数据。`.init`部分仅包含在Linux初始化期间使用的全局变量，这些变量在之后会被释放，如下所示的Linux内核启动信息所示：
- en: '[PRE71]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There are ongoing efforts to reduce the size of the Linux kernel, so it is expected
    that newer kernel versions will be smaller and will allow for better customization
    for use in embedded systems.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当前正在进行的工作旨在减少Linux内核的大小，因此预计新版本的内核将更小，并且能够更好地定制以用于嵌入式系统。
- en: Reducing the root filesystem image size
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减小根文件系统镜像大小
- en: By default, the `core-image-minimal` size for the `wandboard-quad` unpacked
    tarball is around 45 MB, and `core-image-sato` is around 150 MB. This recipe will
    explore methods to reduce their size.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`wandboard-quad` 解包后的 `core-image-minimal` 大约为 45 MB，而 `core-image-sato`
    大约为 150 MB。本文将探讨减小它们大小的方法。
- en: How to do it...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'An example of a small image, `core-image-small`, that does not include the
    `packagegroup-core-boot` recipe and can be used as the base for a root filesystem
    image with reduced size, `recipes-core/images/core-image-small.bb`, is shown next:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了一个小映像示例 `core-image-small`，不包括 `packagegroup-core-boot` 配方，并且可用作根文件系统映像的基础，`recipes-core/images/core-image-small.bb`：
- en: '[PRE72]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This recipe produces an image of about 6.4 MB. You can go even smaller if you
    use the `poky-tiny` distribution by adding the following to your `conf/local.conf`
    file:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方生成约 6.4 MB 的映像。如果使用 `poky-tiny` 发行版，可以通过在 `conf/local.conf` 文件中添加以下内容进一步减小。
- en: '[PRE73]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `poky-tiny` distribution makes a series of size optimizations that may
    restrict the set of packages you can include in your image. To successfully build
    this image, you have to skip one of the sanity checks that the Yocto build system
    performs, by adding the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`poky-tiny` 发行版进行了一系列大小优化，可能会限制您可以包含在映像中的软件包集。要成功构建此映像，您必须跳过 Yocto 构建系统执行的某个完整性检查之一，方法是添加以下内容：'
- en: '[PRE74]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: With `poky-tiny`, the size of the image is further reduced to around 4 MB.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `poky-tiny`，映像的大小进一步减小至约 4 MB。
- en: There are further reductions that can be done to the image; for example, we
    could replace `sysvinit` with `tiny-init`, but that is left as an exercise for
    the reader.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进一步减小映像的大小；例如，我们可以将 `sysvinit` 替换为 `tiny-init`，但这留给读者作为练习。
- en: Images with reduced sizes are also used alongside production images for tasks
    such as rescue systems and manufacturing test processes. They are also ideal to
    be built as `initramfs` images; that is, images that the Linux kernel mounts from
    memory, and can even be bundled into a single Linux kernel image binary.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 大小缩小的映像还与生产映像一起用于救援系统和制造测试流程。它们还非常适合作为 `initramfs` 映像，即 Linux 内核从内存中挂载的映像，甚至可以打包成单个
    Linux 内核映像二进制文件。
- en: How it works...
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Start with an appropriate image like `core-image-minimal` and analyze the dependencies
    as shown in the *Debugging the build system* recipe in [Chapter 1](ch01.html "Chapter 1. The
    Build System"), *The Build System*, and decide which of them are not needed. You
    could also use the file sizes listed in the image''s build history, as seen in
    the *Using build history* recipe, also in [Chapter 1](ch01.html "Chapter 1. The
    Build System"), *The Build System*, to detect the biggest files in the filesystem
    and review them. To sort the file sizes, which appear in the fourth column of
    the `files-in-image.txt` file, in reverse order, we could execute:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 从适当的映像（如 `core-image-minimal`）开始，并分析依赖项，如 [第 1 章](ch01.html "Chapter 1. The
    Build System") 中的 *调试构建系统* 配方所示，决定哪些不需要。您还可以使用映像构建历史中列出的文件大小，如 *使用构建历史* 配方中所见，也在
    [第 1 章](ch01.html "Chapter 1. The Build System") 中的 *构建系统* 中，对文件大小按照 `files-in-image.txt`
    文件的第四列进行逆序排序。
- en: '[PRE75]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'From this, we observe that `glic` is the biggest contributor to the filesystem
    size. Some other places where some space on a console-only system can be saved
    are:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以观察到 `glic` 是文件系统大小的最大贡献者。在仅限控制台系统上可以节省空间的其他地方包括：
- en: Use the IPK package manager, as it is the lightest, or better yet, remove the
    `package-management` feature from your production root filesystem altogether.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IPK 软件包管理器，因为它是最轻量的，或者更好的是，完全从生产根文件系统中删除 `package-management` 功能。
- en: 'Use BusyBox''s `mdev` device manager instead of `udev` by specifying it in
    your `conf/local.conf` file as follows:'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `conf/local.conf` 文件中指定 BusyBox 的 `mdev` 设备管理器，而不是 `udev`，如下所示：
- en: '[PRE76]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that this will only work with core images that include `packagegroup-core-boot`.
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，这仅适用于包括 `packagegroup-core-boot` 的核心映像。
- en: If we are running the root filesystem on a block device, use ext2 instead of
    ext3 or ext4 without the journal.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在块设备上运行根文件系统，请在没有日志的情况下使用 ext2 而不是 ext3 或 ext4。
- en: Configure BusyBox with only the essential applets by providing your own configuration
    file in `bbappend`.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在 `bbappend` 中提供自己的配置文件，仅配置 BusyBox 的基本应用程序：
- en: Review the `glibc` configuration, which can be changed via the `DISTRO_FEATURES_LIBC`
    distribution configuration variable. An example of its usage can be found in the
    `poky-tiny` distribution, which is included in the `poky` source. The `poky-tiny`
    distribution can be used as a template for the distribution customization of small
    systems.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查`glibc`配置，可以通过`DISTRO_FEATURES_LIBC`分发配置变量进行更改。它的使用示例可以在`poky-tiny`分发中找到，该分发包含在`poky`源代码中。`poky-tiny`分发可以作为定制小型系统分发的模板。
- en: Consider switching to a lighter `C` library than the default `glibc`. For a
    while, `uclibc` was being used as an alternative, but the library seems to be
    unmaintained for the last couple of years, and the `core-image-minimal` image
    for the Wandboard does not currently build using it.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑切换到比默认的`glibc`更轻量的`C`库。曾经，`uclibc`被用作替代方案，但该库似乎在过去几年未再维护，并且当前的Wandboard的`core-image-minimal`镜像无法使用它进行构建。
- en: Note
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Recently, there has been some activity with **musl** ([http://www.musl-libc.org/](http://www.musl-libc.org/)),
    a new MIT-licensed `C` library. To enable it, you would add the following to your
    `conf/local.conf` file:'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最近，**musl**（[http://www.musl-libc.org/](http://www.musl-libc.org/)）有了一些新的动向，它是一个新的MIT许可证的`C`库。要启用它，你需要将以下内容添加到你的`conf/local.conf`文件中：
- en: TCLIBC = "musl"
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TCLIBC = "musl"
- en: And you would need to add the `meta-musl` layer ([https://github.com/kraj/meta-musl](https://github.com/kraj/meta-musl))
    to your `conf/bblayers.conf` file.
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要将`meta-musl`层（[https://github.com/kraj/meta-musl](https://github.com/kraj/meta-musl)）添加到你的`conf/bblayers.conf`文件中。
- en: It currently builds `core-image-minimal` for QEMU targets, but there is still
    work to be done to use it on real hardware like the Wandboard.
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它目前为QEMU目标构建`core-image-minimal`，但仍然需要一些工作才能在真实硬件（如Wandboard）上使用它。
- en: Compile your applications with `-Os` to optimize for size.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-Os`编译你的应用程序，以优化大小。
- en: Releasing software
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布软件
- en: When releasing a product based on the Yocto project, we have to consider that
    we are building on top of a multitude of different open source projects, each
    with different licensing requirements.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当发布基于Yocto项目的产品时，我们必须考虑到我们是建立在许多不同的开源项目之上的，每个项目都有不同的许可要求。
- en: At the minimum, your embedded product will contain a bootloader (probably U-Boot),
    the Linux kernel, and a root filesystem with one or more applications. Both U-Boot
    and the Linux kernel are licensed under the **General Public License version 2**
    (**GPLv2**). And the root filesystem could contain a variety of programs with
    different licenses.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，你的嵌入式产品将包含一个引导加载程序（可能是U-Boot）、Linux内核以及一个包含一个或多个应用程序的根文件系统。U-Boot和Linux内核都使用**通用公共许可证第2版**（**GPLv2**）授权。根文件系统可能包含具有不同许可证的各种程序。
- en: All open source licenses allow you to sell a commercial product with a mixture
    of proprietary and open licenses as long as they are independent and the product
    complies with all the open source licenses. We will discuss open source and proprietary
    cohabiting in the *Working with open source and proprietary code* recipe later
    on.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 所有开源许可证都允许你销售一个商业产品，该产品可以同时包含专有和开源许可证的混合，只要它们是独立的，并且产品符合所有开源许可证的要求。我们将在稍后的*与开源和专有代码共存*食谱中讨论开源与专有代码的共存。
- en: It is important to understand all the licensing implications before releasing
    your product to the public. The Yocto project provides tools to make handling
    licensing requirements an easier job.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在将你的产品发布到公众之前，理解所有许可的影响非常重要。Yocto项目提供了工具，使得处理许可要求变得更加简单。
- en: Getting ready
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We first need to specify what requirements we need to comply with to distribute
    a product built with the Yocto project. For the most restrictive open source licenses,
    this usually means:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要明确我们在使用Yocto项目构建的产品中需要遵守的要求。对于最严格的开源许可证，这通常意味着：
- en: Source code distribution, including modifications
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码分发，包括修改
- en: License texts distributions
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可文本分发
- en: Distribution of the tools used to build and run the software
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发构建和运行软件所用的工具
- en: How to do it...
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can use the `archiver` class to provide the deliverables that need to be
    distributed to comply with the licenses. We can configure it to:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`archiver`类来提供需要分发的成果物，以遵守许可要求。我们可以将其配置为：
- en: Provide the original unpatched source as tarballs
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供原始未修补源代码作为tar包
- en: Provide the patches to apply to the original source
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供应用于原始源代码的补丁
- en: Provide the recipes used to build the source
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用于构建源代码的配方
- en: Provide the license text that must sometimes accompany the binary (according
    to some licenses)
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供有时必须附带的许可证文本（根据某些许可证的要求）
- en: 'To use the `archiver` class as specified earlier, we add the following to our
    `conf/local.conf` file:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用前面提到的`archiver`类，我们需要在`conf/local.conf`文件中添加以下内容：
- en: '[PRE77]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The sources will be provided in the `tmp/deploy/sources` directory under a license
    subdirectory hierarchy.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码将在`tmp/deploy/sources`目录下的一个许可证子目录层次中提供。
- en: 'For the `wandboard-quad`, we find the following directories under `tmp/deploy/sources`:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`wandboard-quad`，我们可以在`tmp/deploy/sources`下找到以下目录：
- en: '`allarch-poky-linux`'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allarch-poky-linux`'
- en: '`arm-poky-linux-gnueabi`'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arm-poky-linux-gnueabi`'
- en: 'And looking for what''s distributed for the Linux kernel source, a GPLv2 package,
    we find under `tmp/deploy/sources/arm-poky-linux-gnueabi/linux-wandboard-3.10.17-r0`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看分发的Linux内核源代码时，作为GPLv2软件包，我们可以在`tmp/deploy/sources/arm-poky-linux-gnueabi/linux-wandboard-3.10.17-r0`下找到以下内容：
- en: '`defconfig`'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defconfig`'
- en: '`github.com.wandboard-org.linux.git.tar.gz`'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com.wandboard-org.linux.git.tar.gz`'
- en: '`linux-wandboard-3.10.17-r0-recipe.tar.gz`'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-wandboard-3.10.17-r0-recipe.tar.gz`'
- en: 'So we have the kernel configuration, the source tarball, and the recipes used
    to build it, which include:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有了内核配置、源代码压缩包，以及用于构建它的配方，其中包括：
- en: '`linux-wandboard_3.10.17.bb`'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-wandboard_3.10.17.bb`'
- en: '`linux-dtb.inc`'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-dtb.inc`'
- en: '`linux-wandboard.inc`'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-wandboard.inc`'
- en: And the license text for the root filesystem packages will also be included
    in the root filesystem under `/usr/share/common-licenses`, in a package directory
    hierarchy.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统软件包的许可证文本也将包含在根文件系统中的`/usr/share/common-licenses`目录下，并按照软件包的目录层次进行存放。
- en: This configuration will provide deliverables for all build packages, but what
    we really want to do is provide them only for those whose licenses require us
    to.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置将为所有构建软件包提供交付物，但我们真正想做的是仅为那些许可证要求我们提供交付物的软件包提供它们。
- en: For sure, we don't want to blindly distribute all the contents of the `sources`
    directory as is, as it will also contain our proprietary source, which we most
    likely don't want to distribute.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不希望盲目地分发`source`目录中的所有内容，因为它还会包含我们的专有源代码，而我们很可能不希望分发这些代码。
- en: 'We can configure the `archiver` class only to provide the source for GPL and
    LGPL packages with the following:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置`archiver`类，仅为GPL和LGPL软件包提供源代码，方法如下：
- en: '[PRE78]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And also, for an embedded product, we are usually only concerned with the software
    that ships in the product itself, so we can limit the recipe type to be archived
    to target images with the following:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于嵌入式产品，我们通常只关心实际出现在产品中的软件，因此我们可以通过以下方式限制要归档的配方类型，仅限于目标镜像：
- en: '[PRE79]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We should obtain legal advice to decide which packages have licenses that make
    source distribution a requirement.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应当获得法律建议，以决定哪些软件包的许可证要求我们进行源代码分发。
- en: Other configuration options exist, such as providing the patched or configured
    source instead of the separated original source and patches, or source `rpms`
    instead of source tarballs. See the `archiver` class for more details.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他配置选项，例如提供补丁或配置过的源代码，而不是分开的原始源代码和补丁，或者提供源`rpm`包而不是源代码压缩包。有关更多详情，请参见`archiver`类。
- en: There's more…
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: We can also choose to distribute the whole of our build environment. The best
    way to do this is usually to publish our BSP and software layers on a public Git
    repository. Our software layer can then provide `bblayers.conf.sample` and `local.conf.sample`,
    which can be used to set up ready-to-use `build` directories.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以选择分发整个构建环境。通常做到这一点的最佳方法是将我们的BSP和软件层发布到公共Git仓库中。我们的软件层可以提供`bblayers.conf.sample`和`local.conf.sample`，用于设置即用型`build`目录。
- en: See also
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: There are other requirements that haven't been discussed here, such as the mechanism
    chosen for distribution. It is recommended to get legal advice before releasing
    a product to ensure all the license obligations have been met.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里没有讨论的其他要求包括选择的分发机制。建议在发布产品之前获得法律建议，以确保所有许可证义务都已履行。
- en: Analyzing your system for compliance
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析您的系统以确保合规性
- en: The Yocto build system makes it easy to provide auditing information to our
    legal advisers. This recipe will explain how.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto构建系统使得向我们的法律顾问提供审计信息变得更加容易。此配方将解释如何操作。
- en: How to do it...
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Under `tmp/deploy/licenses`, we find a directory list of packages (including
    their corresponding licenses) and an `image` folder with a package and license
    manifest.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tmp/deploy/licenses`下，我们可以找到一个包含软件包（及其相应许可证）的目录列表，以及一个包含软件包和许可证清单的`image`文件夹。
- en: 'For the example image provided before, `core-image-small`, we have the following:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前提供的示例镜像`core-image-small`，我们有以下内容：
- en: '[PRE80]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'And the corresponding `tmp/deploy/licenses/core-image-small-wandboard-quad-<timestamp>/license.manifest`
    file excerpt is as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`tmp/deploy/licenses/core-image-small-wandboard-quad-<timestamp>/license.manifest`文件摘录如下：
- en: '[PRE81]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: These files can be used to analyze all the different packages that form our
    root filesystem. We can also audit them to make sure we comply with the licenses
    when releasing our product to the public.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件可以用来分析构成我们根文件系统的所有不同包。我们还可以对它们进行审核，以确保在公开发布产品时遵守许可证。
- en: There's more
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: 'You can instruct the Yocto build system to specifically avoid certain licenses
    by using the `INCOMPATIBLE_LICENSE` configuration variable. The usual way to use
    it is to avoid GPLv3-type licenses by adding the following to your `conf/local.conf`
    file:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`INCOMPATIBLE_LICENSE`配置变量来指示Yocto构建系统特意避免某些许可证。通常使用它的方法是通过在`conf/local.conf`文件中添加以下内容来避免使用GPLv3类型的许可证：
- en: '[PRE82]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This will build `core-image-minimal` and `core-image-base` images as long as
    no extra image features are included.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建`core-image-minimal`和`core-image-base`镜像，只要没有包含额外的镜像特性。
- en: Working with open source and proprietary code
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开源和专有代码
- en: It is common for an embedded product to be built upon an open source system
    like the one built by Yocto, and to include proprietary software that adds value
    and specializes the product. This proprietary part usually is intellectual property
    and needs to be protected, and it's important to understand how it can coexist
    with open source.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式产品通常是基于像Yocto这样的开源系统构建的，并且包含增加价值和专门化产品的专有软件。这个专有部分通常是知识产权，需要得到保护，了解它如何与开源软件共存非常重要。
- en: This recipe will discuss some examples of open source packages commonly found
    on embedded products and will briefly explain how to use proprietary software
    with them.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将讨论一些常见的开源包示例，这些包通常出现在嵌入式产品中，并简要解释如何将专有软件与它们一起使用。
- en: How to do it...
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open source licenses can be broadly divided into two categories based on whether
    they are:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 开源许可证可以大致分为两类，取决于它们是否：
- en: '**Permissive**: These are similar to **Internet Software Consortium** (**ISC**),
    MIT, and BSD licenses. They have few requirements attached to them and just require
    us to preserve copyright notices.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽松性**：这些许可证类似于**互联网软件协会**（**ISC**）、MIT和BSD许可证。它们附带的要求较少，只要求我们保留版权声明。'
- en: '**Restrictive**: These are similar to the GPL, which bind us to not only distribute
    the source code and modifications, either with the binary itself or at a later
    date, but also to distribute tools to build, install, and run the source.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制性**：这些许可证类似于GPL，它们要求我们不仅要分发源代码和修改版本，无论是与二进制文件一起还是在后期分发，还需要分发构建、安装和运行源代码的工具。'
- en: However, some licenses might "pollute" modifications and derivative work with
    their own conditions, commonly referred to as *viral licenses*, while others will
    not. For example, if you link your application to GPL-licensed code, your application
    will be bound by the GPL too.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，某些许可证可能会“污染”修改和衍生作品的条件，这些通常被称为*病毒性许可证*，而其他一些则不会。例如，如果你将应用程序链接到GPL许可的代码，那么你的应用程序也将受到GPL的约束。
- en: The virulent nature of the GPL has made some people wary of using GPL-licensed
    software, but it's important to note that proprietary software can run alongside
    GPL software as long as the license terms are understood and respected.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: GPL的病毒性特性让一些人对使用GPL许可的软件保持警惕，但需要注意的是，专有软件可以与GPL软件共存，只要理解并遵守许可证条款。
- en: For example, violating the GPLv2 license would mean losing the right to distribute
    the GPLv2 code in the future, even if further distribution is GPLv2 compliant.
    In this case, the only way to be able to distribute the code again would be to
    ask the copyright holder for permission.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，违反GPLv2许可证将意味着失去将来分发GPLv2代码的权利，即使进一步的分发符合GPLv2规定。在这种情况下，能够再次分发代码的唯一方法是请求版权持有者的许可。
- en: How it works...
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Next, we will provide guidance regarding licensing requirements for some open
    source packages commonly used in embedded products. It does not constitute legal
    advice, and as stated before, proper legal auditing of your product should be
    done before public release.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提供有关一些常见用于嵌入式产品的开源包的许可要求的指南。这并不构成法律建议，如前所述，在公开发布之前，应该对你的产品进行适当的法律审查。
- en: The U-Boot bootloader
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: U-Boot引导程序
- en: U-Boot is licensed under the GPLv2, but any program launched by it does not
    inherit its license. So you are free to use U-Boot to launch a proprietary operating
    system, for example. However, your final product must comply with the GPLv2 with
    regards to U-Boot, so U-Boot source code and modifications must be provided.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot采用GPLv2许可证，但由它启动的任何程序不会继承其许可证。因此，你可以自由使用U-Boot启动专有操作系统。例如，你可以使用U-Boot启动一个专有操作系统。然而，你的最终产品必须遵守关于U-Boot的GPLv2条款，因此必须提供U-Boot的源代码和修改。
- en: The Linux kernel
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux内核
- en: The Linux kernel is also licensed under the GPLv2\. Any application that runs
    in the Linux kernel user space does not inherit its license, so you can run your
    proprietary software in Linux freely. However, Linux kernel modules are part of
    the Linux kernel and as such must comply with the GPLv2\. Also, your final product
    must release the Linux kernel source and modifications, including external modules
    that run in your product.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核也采用GPLv2许可证。任何在Linux内核用户空间运行的应用程序都不会继承其许可证，因此你可以在Linux上自由运行你的专有软件。然而，Linux内核模块是Linux内核的一部分，因此必须遵守GPLv2许可证。此外，你的最终产品必须发布Linux内核源代码和修改，包括在你的产品中运行的外部模块。
- en: Glibc
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Glibc
- en: The GNU `C` library is licensed under the **Lesser General Public License**
    (**LGPL**), which allows dynamic linking without license inheritance. So your
    proprietary code can dynamically link with `glibc`, but of course you still have
    to comply with the LGPL with regards to `glibc`. Note, however, that statically
    linking your application would pollute it with the LGPL.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `C`库采用**较宽松通用公共许可证**（**LGPL**），允许动态链接而无需继承许可证。因此，你的专有代码可以与`glibc`动态链接，但当然你仍然需要遵守关于`glibc`的LGPL。不过，值得注意的是，静态链接你的应用程序会使其与LGPL绑定。
- en: BusyBox
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BusyBox
- en: BusyBox is also licensed under the GPLv2\. The license allows for non-related
    software to run alongside it, so your proprietary software can run alongside BusyBox
    freely. As before, you have to comply with the GPLv2 with regards to BusyBox and
    distribute its source and modifications.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox也采用GPLv2许可证。该许可证允许不相关的软件与它一起运行，因此你的专有软件可以与BusyBox自由运行。如前所述，关于BusyBox，你需要遵守GPLv2并分发其源代码和修改。
- en: The Qt framework
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Qt框架
- en: Qt is licensed under three different licenses, which is common for open source
    projects. You can choose whether you want a commercial license (in which case,
    your proprietary application is protected), a LGPL license (which, as discussed
    before, would also protect your proprietary software by allowing the dynamic linking
    of your application as long as you complied with the LGPL for the Qt framework
    itself), or the GPLv3 (which would be inherited by your application).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: Qt有三种不同的许可证，这对于开源项目来说是很常见的。你可以选择是否需要商业许可证（在这种情况下，你的专有应用程序将受到保护），LGPL许可证（如前所述，通过允许你的应用程序与Qt框架动态链接，只要你遵守LGPL条款，也能保护你的专有软件），或者GPLv3许可证（它将被继承到你的应用程序中）。
- en: The X Windows system
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: X Windows系统
- en: The `X.Org` source is licensed under permissive MIT-style licenses. As such,
    your proprietary software is free to make any use of it as long as its use is
    stated and copyright notices are preserved.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`X.Org`源代码采用宽松的MIT风格许可证。因此，只要声明使用情况并保留版权声明，你的专有软件可以自由使用它。'
- en: There's more...
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Let''s see how to integrate our proprietary-licensed code into the Yocto build
    system. When preparing the recipe for our application, we can take several approaches
    to licensing:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将我们的专有许可证代码集成到Yocto构建系统中。在为我们的应用程序准备配方时，我们可以采取几种许可证方式：
- en: 'Mark `LICENSE` as closed. This is the usual case for a proprietary application.
    We use the following:'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`LICENSE`标记为封闭。这是专有应用程序的常见做法。我们使用以下方式：
- en: '[PRE83]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Mark `LICENSE` as proprietary and include some type of license agreement. This
    is commonly done when releasing binaries with some sort of end user agreement
    that is referenced in the recipe. For example, `meta-fsl-arm` uses this type of
    license to comply with Freescale''s End User License Agreement. An example follows:'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`LICENSE`标记为专有，并包括某种类型的许可协议。这通常在发布二进制文件时使用，附带某种终端用户协议，并在配方中引用。例如，`meta-fsl-arm`使用这种类型的许可证来遵守Freescale的终端用户许可协议。以下是一个示例：
- en: '[PRE84]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Provide multiple licensing options, such as an open source license and a commercial
    license. In this case, the `LICENSE` variable is used to specify the open licenses,
    and the `LICENSE_FLAGS` variable is used for the commercial licenses. A typical
    example is the `gst-plugins-ugly` package in Poky:'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多种许可选项，例如开源许可证和商业许可证。在这种情况下，`LICENSE` 变量用于指定开源许可证，而 `LICENSE_FLAGS` 变量用于商业许可证。一个典型的例子是Poky中的`gst-plugins-ugly`包：
- en: '[PRE85]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When the `LICENSE_FLAGS` variable is set on a recipe, the package will not
    be built unless the license appears on the `LICENSE_FLAGS_WHITELIST` variable
    too, typically defined in your `conf/local.conf` file. For the earlier example,
    we would add:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 当在配方中设置了 `LICENSE_FLAGS` 变量时，除非许可证也出现在 `LICENSE_FLAGS_WHITELIST` 变量中，否则包将不会被构建，通常该变量在你的
    `conf/local.conf` 文件中定义。对于前面的例子，我们需要添加：
- en: '[PRE86]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `LICENSE` and `LICENSE_FLAGS_WHITELIST` variables can match exactly for
    a very narrow match or broadly, as in the preceding example, which matches all
    licenses that begin with the word `commercial`. For narrow matches, the package
    name must be appended to the license name; for instance, if we only wanted to
    whitelist the `gst-plugins-ugly` package from the earlier example but nothing
    else, we could use the following:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`LICENSE` 和 `LICENSE_FLAGS_WHITELIST` 变量可以精确匹配以进行非常狭窄的匹配，也可以像前面例子那样广泛匹配，匹配所有以
    `commercial` 开头的许可证。对于狭窄匹配，包名必须附加到许可证名称上；例如，如果我们只希望将前面例子中的 `gst-plugins-ugly`
    包加入白名单，而不包括其他包，我们可以使用如下方式：'
- en: '[PRE87]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: See also
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: You should refer to the specific licenses for a complete understanding of the
    requirements imposed by them. You can find a complete list of open source licenses
    and their documentation at [http://spdx.org/licenses/](http://spdx.org/licenses/).
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该参考具体的许可证，以完整理解它们所施加的要求。你可以在[http://spdx.org/licenses/](http://spdx.org/licenses/)找到完整的开源许可证列表及其文档。
