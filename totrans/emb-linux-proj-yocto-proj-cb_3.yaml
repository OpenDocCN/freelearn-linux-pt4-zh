- en: Chapter 3. The Software Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 软件层
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Exploring an image's contents
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索镜像的内容
- en: Adding a new software layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的软件层
- en: Selecting a specific package versions and providers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择特定的包版本和提供者
- en: Adding supported packages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加支持的包
- en: Adding new packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新包
- en: Adding data, scripts, or configuration files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加数据、脚本或配置文件
- en: Managing users and groups
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户和组
- en: Using the sysvinit initialization system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 sysvinit 初始化系统
- en: Using the systemd initialization system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 systemd 初始化系统
- en: Installing package-installation scripts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装包安装脚本
- en: Reducing the Linux kernel image size
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减小 Linux 内核镜像大小
- en: Reducing the root filesystem image size
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减小根文件系统镜像大小
- en: Releasing software
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布软件
- en: Analyzing your system for compliance
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析系统合规性
- en: Working with open source and proprietary code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开源和专有代码
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: With hardware-specific changes on their way, the next step is customizing the
    target root filesystem; that is, the software that runs under the Linux kernel,
    also called the Linux user space.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着硬件特定更改的到来，下一步是定制目标根文件系统；即在 Linux 内核下运行的软件，也称为 Linux 用户空间。
- en: The usual approach to this is to start with one of the available core images
    and both optimize and customize it as per the needs of your embedded project.
    Usually, the images chosen as a starting point are either `core-image-minimal`
    or `core-image-sato`, but any of them will do.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的做法是从一个可用的核心镜像开始，然后根据嵌入式项目的需求进行优化和定制。通常选择的起始镜像是 `core-image-minimal` 或 `core-image-sato`，但任何一个都可以。
- en: This chapter will show you how to add a software layer to contain those changes,
    and will explain some of the common customizations made, such as size optimization.
    It will also show you how to add new packages to your root filesystem, including
    licensing considerations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示如何添加软件层以包含这些更改，并解释一些常见的定制，如大小优化。还将展示如何向根文件系统添加新包，包括许可考虑事项。
- en: Exploring an image's contents
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索镜像的内容
- en: We have already seen how to use the build history feature to obtain a list of
    packages and files included in our image. In this recipe, we will explain how
    the root filesystem is built so that we are able to track its components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用构建历史功能来获取包含在镜像中的包和文件列表。在这个配方中，我们将解释根文件系统是如何构建的，以便能够跟踪其组件。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'When packages are built, they are classified inside the working directory of
    your project (`tmp/work`) according to their architecture. For example, on a `wandboard-quad`
    build, we find the following directories:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当包构建完成后，它们会根据架构在项目的工作目录（`tmp/work`）中进行分类。例如，在 `wandboard-quad` 构建中，我们会看到以下目录：
- en: '`all-poky-linux`: This is used for architecture-independent packages'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all-poky-linux`：用于架构无关的包'
- en: '`cortexa9hf-vfp-neon-poky-linux-gnueabi`: This is used for cortexa9, hard floating
    point packages'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cortexa9hf-vfp-neon-poky-linux-gnueabi`：用于 cortexa9 硬浮动点包'
- en: '`wandboard_quad-poky-linux-gnueabi`: This is used for machine-specific packages;
    in this case, `wandboard-quad`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wandboard_quad-poky-linux-gnueabi`：用于机器特定包；在此情况下，是 `wandboard-quad`'
- en: '`x86_64-linux`: This is used for the packages that form the host `sysroot`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x86_64-linux`：用于构成主机 `sysroot` 的包'
- en: BitBake will build all the packages included in its dependency list inside its
    own directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake 将在其自己的目录中构建其依赖列表中的所有包。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To find the `build` directory for a given package, we can execute the following
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找给定包的 `build` 目录，可以执行以下命令：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `build` directory, we find some subdirectories (assuming `rm_work`
    is not used) that the build system uses in the packaging task. These subdirectories
    include the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `build` 目录中，我们可以找到一些子目录（假设未使用 `rm_work`），这些子目录是构建系统在打包任务中使用的。这些子目录包括以下内容：
- en: '`deploy-rpms`: This is the directory where the final packages are stored. We
    look here for individual packages that can be locally copied to a target and installed.
    These packages are copied to the `tmp/deploy` directory and are also used when
    Yocto builds the root filesystem image.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy-rpms`：这是存储最终包的目录。我们可以在这里找到可以本地复制到目标并安装的单个包。这些包被复制到 `tmp/deploy` 目录，在
    Yocto 构建根文件系统镜像时也会使用这些包。'
- en: '`image`: This is the default destination directory where the `do_install` task
    installs components. It can be modified by the recipe with the `D` configuration
    variable.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：这是默认的目标目录，`do_install`任务会将组件安装到该目录。它可以通过配方中的`D`配置变量进行修改。'
- en: '`package`: This one contains the actual package contents.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`：这个包含了实际的包内容。'
- en: '`package-split`: This is where the contents are categorized in subdirectories
    named after their final packages. Recipes can split the package contents into
    several final packages, as specified by the `PACKAGES` variable. The default packages
    besides the default package name are:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-split`：这里是根据最终的包名将内容分类到各个子目录中。配方可以根据`PACKAGES`变量指定将包内容拆分为多个最终包。除了默认包名称外，默认的包有：'
- en: '`dbg`: This installs components used in debugging'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbg`：安装用于调试的组件'
- en: '`dev`: This installs components used in development, such as headers and libraries'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`：安装用于开发的组件，如头文件和库'
- en: '`staticdev`: This installs libraries and headers used in static compilation'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staticdev`：安装用于静态编译的库和头文件'
- en: '`doc`: This is where the documentation is placed'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc`：这是文档所在的目录'
- en: '`locale`: This installs localization components'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locale`：安装本地化组件'
- en: 'The components to be installed in each package are selected using the `FILES`
    variable. For example, to add to the default package, you could execute the following
    command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包中要安装的组件由`FILES`变量选择。例如，要添加到默认包，可以执行以下命令：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And to add to the development package, you could use the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要添加到开发包，可以使用以下命令：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Once the Yocto build system has built all the individual packages in its dependency
    list, it runs the `do_rootfs` task, which populates the `sysroot` and builds the
    root filesystem before creating the final package images. You can find the location
    of the root filesystem by executing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Yocto构建系统完成其依赖包列表中的所有单独包的构建，它会运行`do_rootfs`任务，填充`sysroot`并构建根文件系统，然后创建最终的包镜像。你可以通过执行以下命令找到根文件系统的位置：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `IMAGE_ROOTFS` variable is not configurable and should not be
    changed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`IMAGE_ROOTFS`变量不可配置，且不应更改。
- en: The contents of this directory will later be prepared into an image according
    to what image types are configured in the `IMAGE_FSTYPES` configuration variable.
    If something has been installed in this directory, it will then be installed in
    the final image.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录中的内容稍后将根据`IMAGE_FSTYPES`配置变量中配置的镜像类型准备成一个镜像。如果某些内容已安装在此目录中，它将被安装到最终镜像中。
- en: Adding a new software layer
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的软件层
- en: Root filesystem customization involves adding or modifying content to the base
    image. Metadata for this content goes into one or more software layers, depending
    on the amount of customization needed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统的定制涉及向基础镜像中添加或修改内容。与这些内容相关的元数据将进入一个或多个软件层，具体取决于定制的需求量。
- en: A typical embedded project will have just one software layer containing all
    non-hardware-specific customizations. But it is also possible to have extra layers
    for graphical frameworks or system-wide elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的嵌入式项目通常只有一个包含所有非硬件特定定制的软件层。但也可以为图形框架或系统范围的元素添加额外的层。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before starting work on a new layer, it is good practice to check whether someone
    else provides a similar layer. Also, if you are trying to integrate an open source
    project, check whether a layer for it already exists. There is an index of available
    layers at [http://layers.openembedded.org/](http://layers.openembedded.org/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始工作之前，最好检查是否有其他人提供了类似的层。此外，如果你试图集成一个开源项目，检查是否已有现成的层。可以在[http://layers.openembedded.org/](http://layers.openembedded.org/)找到可用层的索引。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We can then create a new `meta-custom` layer using the `yocto-layer` command
    as we learned in the *Creating a custom BSP layer* recipe in [Chapter 2](ch02.html
    "Chapter 2. The BSP Layer"), *The BSP Layer*. From the `sources` directory, execute
    the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过`yocto-layer`命令创建一个新的`meta-custom`层，正如我们在[第2章](ch02.html "第2章. BSP层")的*创建自定义BSP层*配方中所学到的。从`sources`目录中执行以下命令：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don't forget to add the layer to your project's `conf/bblayers.conf` file and
    to your template's `conf` directory to make it available for all new projects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了将该层添加到项目的`conf/bblayers.conf`文件以及模板的`conf`目录中，以便在所有新项目中使用。
- en: 'The default `conf/layer.conf` configuration file is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`conf/layer.conf`配置文件如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have discussed all the relevant variables in this snippet in the *Creating
    a custom BSP layer* recipe in [Chapter 2](ch02.html "Chapter 2. The BSP Layer"),
    *The BSP Layer*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When adding content to a new software layer, we need to keep in mind that our
    layer needs to play well with other layers in the Yocto project. To this end,
    when customizing recipes, we will always use append files, and will only override
    existing recipes if we are completely sure there is no way to add the customization
    required through an append file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us manage the content across several layers, we can use the following
    `bitbake-layers` command-line utilities:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`$ bitbake-layers show-layers`: This will display the configured layers as
    BitBake sees them. It is helpful to detect errors on your `conf/bblayer.conf`
    file.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ bitbake-layers show-recipes`: This command will display all the available
    recipes and the layers that provide them. It can be used to verify that BitBake
    is seeing your newly created recipe. If it does not appear, verify that the filesystem
    hierarchy corresponds to the one defined in your layer''s `BBFILES` variable in
    `conf/layer.conf`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ bitbake-layers show-overlayed`: This command will show all the recipes that
    are overlayed by another recipe with the same name but in a higher priority layer.
    It helps detect recipe clashes.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ bitbake-layers show-appends`: This command will list all available append
    files and the recipe files they apply to. It can be used to verify that BitBake
    is seeing your append files. Also, as before with recipes, if they don''t appear,
    you will need to check the filesystem hierarchy and your layer''s `BBFILES` variable.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ bitbake-layers flatten <output_dir>`: This command will create a directory
    with the contents of all configured layers without overlayed recipes and with
    all the append files applied. This is how BitBake will see the metadata. This
    flattened directory is useful to discover conflicts with your layer''s metadata.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will sometimes add customizations that are specific to one board or machine.
    These are not always hardware-related, so they could be found both in a BSP or
    software layer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'When doing so, we will try to keep our customizations as specific as possible.
    One typical example is customizing for a specific machine or machine family. If
    you need to add a patch for the `wandboard-quad` machine, you would use the following
    line of code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And, if the patch is applicable to all i.MX6-based boards, you can use the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To be able to use machine families overrides, the machine configuration files
    need to include a `SOC_FAMILY` variable, such as the one for the `wandboard-quad`
    in `meta-fsl-arm-extra`. Refer to the following line of code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And for it to appear in the `MACHINEOVERRIDES` variable, the `soc-family.inc`
    file needs to be included, as it is in `meta-fsl-arm`. Here is the relevant code
    excerpt from the `conf/machine/include/imx-base.inc` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'BitBake will search a predefined path, looking for files inside the package''s
    working directory, defined in the `FILESPATH` variable as a colon-separated list.
    Specifically:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake将搜索预定义的路径，查找包工作目录内的文件，该目录由`FILESPATH`变量定义，作为以冒号分隔的列表。具体来说：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the specific case of the `wandboard-quad`, this translates to the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`wandboard-quad`的具体情况下，这将转换为以下内容：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `PN` is the package name and `PV` is the package version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PN`是包名，`PV`是包版本。
- en: It is best to place patches in the most specific of these, so `wandboard-quad`,
    followed by `wandboard`, `mx6q`, `mx6`, `armv7a`, `arm`, and finally the generic
    `PN-PV`, `PN`, and `files`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将补丁放在这些层中最具体的地方，比如`wandboard-quad`，然后是`wandboard`、`mx6q`、`mx6`、`armv7a`、`arm`，最后是通用的`PN-PV`、`PN`和`files`。
- en: 'Note that the search path refers to the location of the BitBake recipe, so
    append files need to always add the path when adding content. Our append files
    can add extra folders to this search path if needed by appending or prepending
    to the `FILESEXTRAPATHS` variable as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，搜索路径指的是BitBake配方的位置，因此在添加内容时，追加文件始终需要添加路径。如果需要，我们的追加文件可以通过以下方式在`FILESEXTRAPATHS`变量中追加或前置，来添加额外的文件夹到该搜索路径：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the immediate operator (`:=`) that expands `THISDIR` immediately, and the
    prepend that places your added path before any other path so that your patches
    and files are found first in the search.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意立即操作符(`:=`)，它会立即扩展`THISDIR`，以及前置操作符，它将你添加的路径放在其他路径之前，这样你的补丁和文件可以首先在搜索中被找到。
- en: Also, we have seen the `+=` and `=+` style of operators in configuration files,
    but they should be avoided in recipe files and the append and prepend operators
    should be given preference, as seen in the example code explained previously to
    avoid ordering issues.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们也看到在配置文件中使用`+=`和`=+`风格的操作符，但应避免在配方文件中使用，应该优先使用追加和前置操作符，如之前的示例代码所解释，以避免顺序问题。
- en: Selecting a specific package version and providers
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择特定的包版本和提供者
- en: 'Our layers can provide recipes for different versions of the same package.
    For example, the `meta-fsl-arm` layer contains several different types of Linux
    sources:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的层可以为同一包的不同版本提供配方。例如，`meta-fsl-arm`层包含多个不同类型的Linux源：
- en: '`linux-imx`: This corresponds to the Freescale BSP kernel image fetched from
    [http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/](http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-imx`：这是来自于Freescale BSP内核镜像，来源于[http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/](http://git.freescale.com/git/cgit.cgi/imx/linux-2.6-imx.git/)'
- en: '`linux-fslc`: This is the mainline Linux kernel and fetched from [https://github.com/Freescale/linux-fslc](https://github.com/Freescale/linux-fslc)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-fslc`：这是主线Linux内核，来自于[https://github.com/Freescale/linux-fslc](https://github.com/Freescale/linux-fslc)'
- en: '`linux-timesys`: This is a kernel with Vybrid platform support fetched from
    [https://github.com/Timesys/linux-timesys](https://github.com/Timesys/linux-timesys)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-timesys`：这是一个支持Vybrid平台的内核，来自于[https://github.com/Timesys/linux-timesys](https://github.com/Timesys/linux-timesys)'
- en: As we mentioned before, all recipes provide the package name (for example, `linux-imx`
    or `linux-fslc`) by default, but all Linux recipes must also provide the `virtual/kernel`
    virtual package. The build system will resolve `virtual/kernel` to the most appropriate
    Linux recipe name, taking into account the requirements of the build, such as
    the machine it is building for.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有配方默认提供包名（例如，`linux-imx`或`linux-fslc`），但所有Linux配方还必须提供`virtual/kernel`虚拟包。构建系统将根据构建的要求，如目标机器，解析`virtual/kernel`到最合适的Linux配方名称。
- en: And within those recipes, `linux-imx`, for example, has both 2.6.35.3 and 3.10.17
    recipe versions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这些配方中，`linux-imx`例如，包含了2.6.35.3和3.10.17的配方版本。
- en: In this recipe, we will show how to tell the Yocto build system which specific
    package and version to build.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示如何告诉Yocto构建系统构建哪个特定的包和版本。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To specify the exact package we want to build, the build system allows us to
    specify what provider and version to use.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定我们要构建的精确包，构建系统允许我们指定要使用的提供者和版本。
- en: How do we select which provider to use?
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何选择使用哪个提供者？
- en: 'We can tell BitBake which recipe to use by using the `PREFERRED_PROVIDER` variable.
    To set a preferred provider for the `virtual/kernel` virtual package on our Wandboard
    machine, we would add the following to its machine configuration file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`PREFERRED_PROVIDER`变量来告诉BitBake使用哪个配方。为了在我们的Wandboard机器上为`virtual/kernel`虚拟包设置首选提供者，我们需要在其机器配置文件中添加以下内容：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How do we select which version to use?
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within a specific provider, we can also tell BitBake which version to use with
    the `PREFERRED_VERSION` variable. For example, to set a specific `linux-imx` version
    for all i.MX6-based machines, we would add the following to our `conf/local.conf`
    file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `%` wildcard is accepted to match any character, as we see here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is, however, more common to see this type of configuration done in machine
    configuration files, in which case we would not use the `_mx6` append.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: How do we select which version not to use?
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the `DEFAULT_PREFERENCE` variable set to `-1` to specify that a version
    is not to be used unless explicitly set by a `PREFERRED_VERSION` variable. This
    is commonly used in development versions of packages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding supported packages
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common to want to add new packages to an image that already has an available
    recipe in one of the included Yocto layers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: When the target image desired is very different from the supplied core images,
    it is recommended to define a new image rather than to customize an existing one.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to customize an existing image by adding supported
    packages to it, but also to create a completely new image recipe if needed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To discover whether a package we require is included in our configured layers,
    and what specific versions are supported, we can use `bitbake-layers` from our
    build directory as we saw previously:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, we can also use BitBake as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or we can use the `find` Linux command in our `sources` directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once we know what packages we want to include in our final images, let's see
    how we can add them to the image.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While developing, we will use our project''s `conf/local.conf` file to add
    customizations. To add packages to all images, we can use the following line of
    code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there is a space after the first quote to separate the new package
    from the existing ones, as the append operator does not add a space.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also limit the addition to a specific image with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another way to easily customize is by making use of **features**. A feature
    is a logical grouping of packages. For example, we could create a new feature
    called `debug-utils`, which will add a whole set of debugging utilities. We could
    define our feature in a configuration file or class as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We could then add this feature to our image by adding an `EXTRA_IMAGE_FEATURES`
    variable to our `conf/local.conf` file as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you were to add it to an image recipe, you would use the `IMAGE_FEATURES`
    variable instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, features get added as a `packagegroup` recipe instead of being listed
    as packages individually. Let''s show how to define a `packagegroup` recipe in
    the `recipes-core/packagegroups/packagegroup-debug-utils.bb` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And you would then add it to the `FEATURE_PACKAGES` variable as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can use `packagegroups` to create more complex examples. Refer to the *Yocto
    Project Development Manual* at [http://www.yoctoproject.org/docs/1.7.1/dev-manual/dev-manual.html](http://www.yoctoproject.org/docs/1.7.1/dev-manual/dev-manual.html)
    for details.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`packagegroups`来创建更复杂的示例。有关详细信息，请参考*Yocto项目开发手册*，[http://www.yoctoproject.org/docs/1.7.1/dev-manual/dev-manual.html](http://www.yoctoproject.org/docs/1.7.1/dev-manual/dev-manual.html)。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The best approach to customize images is to create our own images using an
    existing image as template. We could use `core-image-minimal.bb`, which contains
    the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义镜像的最佳方法是使用现有镜像作为模板来创建我们自己的镜像。我们可以使用`core-image-minimal.bb`，它包含以下代码：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And extend it to your own version that allows for the customization of `IMAGE_FEATURES`,
    by adding the following `meta-custom/recipes-core/images/custom-image.bb` image
    file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后扩展为我们自己的版本，以允许通过添加以下`meta-custom/recipes-core/images/custom-image.bb`镜像文件来自定义`IMAGE_FEATURES`：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of course, we can also define a new image from scratch using one of the available
    images as a template.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用现有的镜像作为模板，从头定义一个新的镜像。
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A final way to customize images is by adding shell functions that get executed
    once the image has been created. You do this by adding the following to your image
    recipe or `conf/local.conf` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义镜像的最终方法是通过添加 shell 函数，这些函数在镜像创建后执行。你可以通过在镜像配方或`conf/local.conf`文件中添加以下内容来实现：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can use the path to the root filesystem in your command with the `IMAGE_ROOTFS`
    variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在命令中使用`IMAGE_ROOTFS`变量来指定根文件系统的路径。
- en: Classes would use the `IMAGE_POSTPROCESS_COMMAND` variable instead of `ROOTFS_POSTPROCESS_COMMAND`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类别将使用`IMAGE_POSTPROCESS_COMMAND`变量，而不是`ROOTFS_POSTPROCESS_COMMAND`。
- en: One example of usage can be found in the `debug-tweaks` feature in `image.bbclass`,
    when images are tweaked to allow passwordless root logins. This method is also
    commonly used to customize the root password of a target image.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用例示例可以在`image.bbclass`中的`debug-tweaks`功能中找到，当镜像被调整以允许无密码root登录时。这个方法也通常用于自定义目标镜像的root密码。
- en: Configuring packages
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置包
- en: As we saw in the *Configuring the Linux kernel* recipe in [Chapter 2](ch02.html
    "Chapter 2. The BSP Layer"), *The BSP Layer*, some packages, like the Linux kernel,
    provide a configuration menu and can be configured with the `menuconfig` BitBake
    command.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.html "第2章 BSP层")的*配置Linux内核*一节中看到的那样，*BSP层*，一些包（比如Linux内核）提供了一个配置菜单，可以通过`menuconfig`
    BitBake命令进行配置。
- en: 'Another package worth mentioning with a configuration interface is BusyBox.
    We will show how to configure BusyBox, for example to add `pgrep`, a tool that
    looks up process''s IDs by name. To do so follow the next steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的、带有配置界面的包是BusyBox。我们将展示如何配置BusyBox，例如添加`pgrep`，这是一个通过名称查找进程ID的工具。具体步骤如下：
- en: 'Configure BusyBox:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置BusyBox：
- en: '[PRE29]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In **Process utilities** choose `pgrep`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**进程工具**中选择`pgrep`。
- en: 'Compile BusyBox:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译BusyBox：
- en: '[PRE30]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Copy the RPM package into the target:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RPM包复制到目标：
- en: '[PRE31]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Install the RPM package on the target:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标上安装RPM包：
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that we are forcing the update as the package version has not increased
    with the configuration change.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，由于配置更改后包的版本没有增加，我们强制更新。
- en: Adding new packages
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新包
- en: We have seen how to customize our image so that we can add supported packages
    to it. When we can't find an existing recipe or we need to integrate some new
    software we have developed, we will need to create a new Yocto recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何自定义我们的镜像，以便我们可以向其中添加支持的包。当我们找不到现有的配方，或者需要集成我们自己开发的新软件时，我们将需要创建一个新的Yocto配方。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'There are some questions we need to ask ourselves before starting to write
    a new recipe:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写新配方之前，我们需要问自己一些问题：
- en: Where is the source code stored?
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码存储在哪里？
- en: Is it source-controlled or released as a tarball?
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是源代码控制的，还是以tarball形式发布的？
- en: What is the source code license?
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码许可证是什么？
- en: What build system is it using?
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用什么构建系统？
- en: Does it need configuration?
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要配置吗？
- en: Can we cross-compile it as is or does it need to be patched?
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否按原样交叉编译，还是需要打补丁？
- en: What are the files that need to be deployed to the root filesystem, and where
    do they go?
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要部署到根文件系统的文件有哪些，它们应该放在哪里？
- en: Are there any system changes that need to happen, such as new users or `init`
    scripts?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要进行任何系统更改，比如新增用户或`init`脚本？
- en: Are there any dependencies that need to be installed into `sysroot` beforehand?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何依赖项需要提前安装到`sysroot`中？
- en: Once we know the answers to these questions, we are ready to start writing our
    recipe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了这些问题的答案，就可以开始编写我们的食谱了。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: It is best to start from a blank template like the one that follows than to
    start from a similar recipe and modify it, as the result will be cleaner and contain
    only the strictly needed instructions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最好从如下的空白模板开始，而不是从一个类似的食谱开始并修改它，因为这样做的结果会更加干净，并且仅包含严格需要的指令。
- en: 'A good starting base for a minimal recipe addition is:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 添加最小食谱的一个良好起点是：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will explain each one of the recipe sections in more detail in the following
    sections.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分中更详细地解释每个食谱部分。
- en: Package licensing
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包许可证
- en: 'Every recipe needs to contain a `LICENSE` variable. The `LICENSE` variable
    allows you to specify multiple, alternative, and per-package type licenses, as
    seen in the following examples:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个食谱都需要包含`LICENSE`变量。`LICENSE`变量允许你指定多个、替代的以及按包类型的许可证，如下例所示：
- en: 'For MIT or GPLv2 alternative licenses, we will use:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 MIT 或 GPLv2 替代许可证，我们将使用：
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For both ISC and MIT licenses, we will use:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 ISC 和 MIT 许可证，我们将使用：
- en: '[PRE35]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For split packages, all of them GPLv2 except the documentation that is covered
    under the Creative Commons, we will use:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于拆分包，所有包都是 GPLv2，除了文档部分，它是由知识共享协议保护的，我们将使用：
- en: '[PRE36]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Open source packages usually have the license included with the source code
    in `README`, `COPYING`, or `LICENSE` files, and even the source code header files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 开源包通常会在源代码中包含许可证，如`README`、`COPYING`或`LICENSE`文件，甚至在源代码头文件中。
- en: 'For open source licenses, we also need to specify `LIC_FILES_CHECKSUM` for
    all licenses so that the build system can notify us when the licenses change.
    To add it, we locate the file or file portion that contains the license and provide
    its relative path from the directory containing the source and a MD5 checksum
    for it. For example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开源许可证，我们还需要为所有许可证指定`LIC_FILES_CHECKSUM`，以便构建系统在许可证发生变化时通知我们。要添加它，我们定位包含许可证的文件或文件部分，并提供其相对于源目录的路径以及其
    MD5 校验和。例如：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Proprietary code should have the license set as `CLOSED`, and no `LIC_FILES_CHECKSUM`
    is needed for it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 专有代码的许可证应设置为`CLOSED`，不需要为其提供`LIC_FILES_CHECKSUM`。
- en: Fetching package contents
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取包内容
- en: 'The `SRC_URI` variable lists the files to fetch. The build system will use
    different fetchers depending on the file prefix. These can be:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`SRC_URI`变量列出了要获取的文件。构建系统将根据文件前缀使用不同的获取器。这些获取器可以是：'
- en: 'Local files included with the metadata (`file://`). If the local file is a
    patch, the `SRC_URI` variable can be extended with patch-specific arguments such
    as:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与元数据一起包含的本地文件（`file://`）。如果本地文件是补丁，`SRC_URI`变量可以通过补丁特定的参数扩展，如下所示：
- en: '`striplevel`: The default patch strip level is 1 but it can be modified with
    this argument'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`striplevel`：默认的补丁去除级别是 1，但可以通过此参数进行修改'
- en: '`patchdir`: This specifies the directory location to apply the patch to, with
    the default being the source directory'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patchdir`：此参数指定应用补丁的目录位置，默认值为源目录'
- en: '`apply`: This argument controls whether to apply the patch or not, with the
    default being to apply it'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`：此参数控制是否应用补丁，默认情况下会应用补丁'
- en: Files stored in remote servers (typically, `http(s)://`, `ftp://`, or `ssh://`).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在远程服务器上的文件（通常为`http(s)://`、`ftp://`或`ssh://`）。
- en: Files stored in remote repositories (typically, `git://`, `svn://`, `hg://`,
    or `bzr://`). These also need a `SRCREV` variable to specify the revision.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在远程仓库中的文件（通常为`git://`、`svn://`、`hg://`或`bzr://`）。这些文件也需要一个`SRCREV`变量来指定修订版本。
- en: 'Files stored in remote servers (not local files or remote repositories) need
    to specify two checksums. If there are several files, they can be distinguished
    with a `name` argument; for example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在远程服务器上的文件（不是本地文件或远程仓库）需要指定两个校验和。如果有多个文件，可以通过`name`参数来区分；例如：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The source directory folder, `S`, specifies the location of the source files.
    The repository will be checked out here, or the tarball decompressed in this location.
    If the tarball decompresses in the standard `${PN}-${PV}` location, it can be
    omitted as it is the default. For repositories, it needs to always be specified;
    for example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 源目录文件夹`S`指定了源文件的位置。仓库将在此处检出，或者 tarball 会解压到此位置。如果 tarball 解压到标准的`${PN}-${PV}`位置，则可以省略，因为这是默认值。对于仓库，必须始终指定；例如：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Specifying task overrides
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定任务覆盖
- en: 'All recipes inherit the `base.bbclass` class, which defines the following tasks:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有食谱都继承了`base.bbclass`类，该类定义了以下任务：
- en: '`do_fetch`: This method fetches the source code, selecting the fetcher using
    the `SRC_URI` variable.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_fetch`：该方法通过`SRC_URI`变量选择获取器，获取源代码。'
- en: '`do_unpack`: This method unpacks the code in the working directory to a location
    specified by the `S` variable.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_unpack`：该方法将代码解包到由`S`变量指定的位置。'
- en: '`do_configure`: This method configures the source code if needed. It does nothing
    by default.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_configure`：该方法根据需要配置源代码。默认情况下不执行任何操作。'
- en: '`do_compile`: This method compiles the source and runs the GNU make target
    by default.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_compile`：该方法默认编译源代码并运行GNU make目标。'
- en: '`do_install`: This method copies the results of the build from the `build`
    directory `B` to the destination directory `D`. It does nothing by default.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_install`：该方法将构建结果从`build`目录`B`复制到目标目录`D`。默认情况下不执行任何操作。'
- en: '`do_package`: This method splits the deliverables into several packages. It
    does nothing by default.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do_package`：该方法将交付物拆分成多个包。默认情况下不执行任何操作。'
- en: Usually, only the configuration, compilation, and installation tasks are overridden,
    and this is mostly done implicitly by inheriting a class like `autotools`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，仅重写配置、编译和安装任务，并且大多数情况下是通过继承`autotools`类隐式完成的。
- en: 'For a custom recipe that does not use a build system, you need to provide the
    required instructions for configuration (if any), compilation, and installation
    in their corresponding `do_configure`, `do_compile`, and `do_install` overrides.
    As an example of this type of recipe, `meta-custom/recipes-example/helloworld/helloworld_1.0.bb`,
    may be seen here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不使用构建系统的自定义配方，您需要在相应的`do_configure`、`do_compile`和`do_install`重写方法中提供所需的配置（如果有）、编译和安装指令。以下是这种类型配方的示例，位于`meta-custom/recipes-example/helloworld/helloworld_1.0.bb`：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the `meta-custom/recipes-example/helloworld/helloworld-1.0/helloworld.c`
    source file being the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta-custom/recipes-example/helloworld/helloworld-1.0/helloworld.c`源文件如下：'
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will see example recipes that use the most common build systems in the next
    chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到使用最常见构建系统的示例配方。
- en: Configuring packages
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置包
- en: 'The Yocto build system provides the `PACKAGECONFIG` variable to help in the
    configuration of packages by defining a number of features. Your recipe defines
    the individual features as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto构建系统提供了`PACKAGECONFIG`变量，用于通过定义多个特性来帮助配置包。您的配方通过以下方式定义单个特性：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `PACKAGECONFIG` variable contains a space-separated list of feature names,
    and it can be extended or overridden in `bbappend` files; have a look at the following
    example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`PACKAGECONFIG`变量包含一个以空格分隔的特性名称列表，并且可以在`bbappend`文件中进行扩展或重写；请查看以下示例：'
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To extend or override it from a distribution or local configuration file, you
    would use the following syntax:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要从发行版或本地配置文件扩展或重写它，您需要使用以下语法：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Following that, we characterize each feature with four ordered arguments:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用四个有序参数来描述每个特性：
- en: Extra configuration arguments (for `EXTRA_OECONF`) when the feature is enabled
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用特性时的额外配置参数（对于`EXTRA_OECONF`）
- en: Extra configuration arguments (for `EXTRA_OECONF`) when the feature is disabled
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用特性时的额外配置参数（对于`EXTRA_OECONF`）
- en: Extra build dependencies (for `DEPENDS`) when the feature is enabled
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用特性时的额外构建依赖（对于`DEPENDS`）
- en: Extra runtime dependencies (for `RDEPENDS`) when the feature is enabled
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用特性时的额外运行时依赖（对于`RDEPENDS`）
- en: The four arguments are optional, but the ordering needs to be maintained by
    leaving the surrounding commas.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个参数是可选的，但必须保持其顺序，并且需要保留分隔的逗号。
- en: 'For example, the `wpa-supplicant` recipe defines two features, `gnutls` and
    `openssl`, but only enables `gnutls` by default, as seen here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`wpa-supplicant`配方定义了两个特性，`gnutls`和`openssl`，但默认仅启用`gnutls`，如下所示：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Splitting into several packages
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆分成多个包
- en: 'It is common to separate the recipe contents into different packages that serve
    different needs. Typical examples are to include documentation in a `doc` package,
    and header and/or libraries in a `dev` package. We can do this using the `FILES`
    variable as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将配方内容分成不同的包以满足不同的需求是常见做法。典型的例子是将文档包含在`doc`包中，将头文件和/或库包含在`dev`包中。我们可以通过使用`FILES`变量来实现这一点，示例如下：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Setting machine-specific variables
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置特定于机器的变量
- en: Each recipe has a `PACKAGE_ARCH` variable that categorizes the recipe into a
    package feed, as we saw in the *Exploring an image's contents* recipe. Most of
    the times, they are automatically sorted out by the Yocto build system. For example,
    if the recipe is a kernel, a kernel module recipe, or an image recipe, or even
    if it is cross-compiling or building native applications, the Yocto build system
    will set the package architecture accordingly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: BitBake will also look at the `SRC_URI` machine overrides and adjust the package
    architecture, and if your recipe is using the `allarch` class, it will set the
    package architecture to `all`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'So when working on a recipe that only applies to a machine or machine family,
    or that contains changes that are specific to a machine or machine family, we
    need to check whether the package is categorized in the appropriate package feed,
    and if not, specify the package architecture explicitly in the recipe itself by
    using the following line of code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Also, when a recipe is only to be parsed for specific machine types, we specify
    it with the `COMPATIBLE_MACHINE` variable. For example, to make it compatible
    only with the `mxs, mx5 and mx6 SoC families`, we would use the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Adding data, scripts, or configuration files
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All recipes inherit the base class with the default set of tasks to run. After
    inheriting the base class, a recipe knows how to do things like fetching and compiling.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: As most recipes are meant to install some sort of executable, the base class
    knows how to build it. But sometimes all we want is to install data, scripts,
    or configuration files into the filesystem.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: If the data or configuration is related to an application, the most logical
    thing to do is to package it together with the application's recipe itself, and
    if we think it is better to be installed separately, we could even split it into
    its own package.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: But some other times, the data or configuration is unrelated to an application,
    maybe it applies to the whole system or we just want to provide a separate recipe
    for it. Optionally, we could even want to install some Perl or Python scripts
    that don't need to be compiled.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In those cases, our recipe should inherit the `allarch` class that is inherited
    by recipes that do not produce architecture-specific output.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this type of recipe, `meta-custom/recipes-example/example-data/example-data_1.0.bb`,
    may be seen here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It assumes that the fictitious `examples.git` repository contains a `python-scripts`
    folder, which we want to include in our root filesystem.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: A working recipe example can be found in the source that accompanies the book.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Managing users and groups
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is also common to need to add or modify users and groups to our filesystem.
    This recipe explains how it is done.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user information is stored in the `/etc/passwd` file, a text file that is
    used as a database for the system user's information. The `passwd` file is human-readable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line on it corresponds to one user in the system, and it has the following
    format:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s see each of the parameters of this format:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '`username`: A unique string that identifies the user at login'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uid`: User ID, a number that Linux uses to identify the user'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gid`: Group ID, a number that Linux uses to identify the user''s primary group'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment`: Comma-separated values that describe the account, typically the
    user''s contact details'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`home directory`: Path to the user''s home directory'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login shell`: Shell that is started for interactive logins'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default `passwd` file is stored with the `base-passwd` package and looks
    as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: All accounts have disabled direct logins, indicated by an asterisk on the password
    field, except for root, which has no password. This is because, by default, the
    image is built with the `debug-tweaks` feature that enables passwordless login
    for the root user, among other things. If the root password was enabled, we would
    see the encrypted root password.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not forget to remove the `debug-tweaks` feature from production images.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: There is a corresponding `/etc/group` file that is installed at the same time
    with the information for the system groups.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The `core-image-minimal` image does not include shadow password protection,
    but other images, such as `core-image-full-cmdline`, do. When enabled, all password
    fields contain an *x*, and the encrypted passwords are kept on a `/etc/shadow`
    file, which is only accessible to the super user.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Any user that is needed by the system but not included in the list we saw earlier
    needs to be created.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard way for a recipe to add or modify system users or groups is to
    use the `useradd` class, which uses the following variables:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '`USERADD_PACKAGES`: This variable specifies the individual packages in the
    recipe that require users or groups to be added. For the main package, you would
    use the following:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`USERADD_PARAM`: This variable corresponds to the arguments passed to the Linux
    `useradd` command, to add new users to the system.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GROUPADD_PARAM`: This variable corresponds to the arguments passed to the
    Linux `groupadd` command, to add new groups to the system.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GROUPMEMS_PARAM`: This variable corresponds to the arguments passed to the
    Linux `groupmems` command, which administers members of the user''s primary group.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example snippet of a recipe using the `useradd` class follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The password can be generated on your host using the `mkpasswd` Linux command-line
    utility, installed with the `whois` Ubuntu package.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When generating users and groups using the `useradd` class, the `uid` and `gid`
    values are assigned dynamically during package installation. If this is not desired,
    there is a way to assign system-wide static `uid` and `gid` values by providing
    your own `passwd` and group files.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you need to define the `USERADDEXTENSION` variable in your `conf/local.conf`
    file as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The build system will then search the `BBPATH` variable for `files/passwd` and
    `files/group` files to obtain the `uid` and `gid` values. The files have the standard
    `passwd` layout as defined previously, with the password field ignored.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The default filenames can be overridden by using the `USERADD_UID_TABLES` and
    `USERADD_GID_TABLES` variables.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to define the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is done so that the build system produces an error if the required `uid`
    and `gid` values are not found in the provided files.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you use the `useradd` class in a project that is already built,
    you will need to remove the `tmp` directory and rebuild from the `sstate-cache`
    directory or you will get build errors.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a way to add user and group information that is not tied to a
    specific recipe but to an image – by using the `extrausers` class. It is configured
    by the `EXTRA_USERS_PARAMS` variable in an image recipe and used as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This sets the root password to `password`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Using the sysvinit initialization manager
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initialization manager is an important part of the root filesystem. It is
    the first thing the kernel executes, and it has the responsibility to start the
    rest of the system.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will introduce the `sysvinit` initialization manager.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the default initialization manager in Yocto and it has been used in
    Linux since the operating system's origin. The kernel is passed an `init` command-line
    argument, typically `/sbin/init`, which is then launched. This `init` process
    has PID 1 and is the parent of all processes. The `init` process can either be
    implemented by BusyBox or be an independent program installed with the `sysvinit`
    package. Both of them work in the same way, based on the concept of **runlevel**,
    a machine state that defines which processes to run.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init` process will read an `inittab` file and look for a default runlevel.
    The default `inittab` file is installed with the `sysvinit-inittab` package and
    is as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Then, `init` runs all scripts starting with `S` in the `/etc/rcS.d` directory,
    followed by all the scripts starting with `S` in the `/etc/rcN.d` directory, where
    `N` is the runlevel value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: So the `init` process just performs the initialization and forgets about the
    processes. If something goes wrong and the processes are killed, no one will care.
    The system watchdog will reboot the system if it becomes unresponsive, but applications
    built with more than one process usually need some type of process monitor that
    can react to the health of the system, but `sysvinit` does not offer these types
    of mechanisms.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: However, `sysvinit` is a well-understood and reliable initialization manager
    and the recommendation is to keep it unless you need some extra feature.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using `sysvinit` as the initialization manager, Yocto offers the `update-rc.d`
    class as a helper to install initialization scripts so that they are started and
    stopped when needed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'When using this class, you need to specify the `INITSCRIPT_NAME` variable with
    the name of the script to install and `INITSCRIPT_PARAMS` with the options to
    pass to the `update-rc.d` utility. You can optionally use the `INITSCRIPT_PACKAGES`
    variable to list the packages to contain the initialization scripts. By default,
    this contains the main package only, and if multiple packages are provided, the
    `INITSCRIPT_NAME` and `INITSCRIPT_PARAMS` need to be specified for each using
    overrides. An example snippet follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When an initialization script is not tied to a particular recipe, we can add
    a specific recipe for it. For example, the following recipe will run a `mount.sh`
    script in the `recipes-example/sysvinit-mount/sysvinit-mount_1.0.bb` file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using the systemd initialization manager
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an alternative to `sysvinit`, you can configure your project to use `systemd`
    as an initialization manager, although `systemd` packs many more features.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `systemd` initialization manager is replacing `sysvinit` and other initialization
    managers in most Linux distributions. It is based on the concepts of units, an
    abstraction of all elements that are relevant for system startup and maintenance,
    and targets, which group units and can be viewed as a runlevel equivalent. Some
    of the units `systemd` defines are:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Services
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Devices
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mount points
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapshots
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timers
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paths
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default targets and their runlevel equivalents are defined in the following
    table:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '| Sysvinit | Runlevel | Systemd target | Notes |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| 0 | `runlevel0.target` | `poweroff.target` | Halt the system. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| 1, s, single | `runlevel1.target` | `rescue.target` | Single user mode. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| 2, 4 | `runlevel2.target`, `runlevel4.target` | `multi-user.target` | User-defined/site-specific
    runlevels. By default, identical to `3`. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| 3 | `runlevel3.target` | `multi-user.target` | Multiuser, non-graphical.
    Users can usually log in via multiple consoles or via the network. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| 5 | `runlevel5.target` | `graphical.target` | Multiuser, graphical. Usually
    has all the services of runlevel 3 plus a graphical login. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| 6 | `runlevel6.target` | `reboot.target` | Reboot the system. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: The `systemd` initialization manager is designed to be compatible with `sysvinit`,
    including using `sysvinit init` scripts.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the features of `systemd` are:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Parallelization capabilities that allow for faster boot times
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service initialization via sockets and D-Bus so that services are only started
    when needed
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process monitoring that allows for process failure recovery
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System state snapshots and restoration
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mount point management
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactional-dependency-based unit control, where units establish dependencies
    between them
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure your system to use `systemd`, you need to add the `systemd` distribution
    feature to your project by adding the following to your distribution''s configuration
    file, under `sources/poky/meta-yocto/conf/distro/poky.conf` for the default `poky`
    distribution, or locally on your project''s `conf/local.conf` file:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the space required after the starting quote.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This configuration example allows you to define a main image with `systemd`
    and a rescue image with `sysvinit`, providing it does not use the `VIRTUAL-RUNTIME_init_manager`
    variable. Hence, the rescue image cannot use the `packagegroup-core-boot` or `packagegroup-core-full-cmdline`
    recipes. As an example, the recipe where the image size has been reduced, which
    we will introduce in the *Reducing the root filesystem image size* recipe in this
    chapter, could be used as the basis for a rescue image.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove `sysvinit` completely from your system, you would do the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Feature backfilling is the automatic extension of machine and distribution features
    to keep backwards compatibility. The `sysvinit` distribution feature is automatically
    filled in, so to remove it, we need to blacklist it by adding it to the `DISTRO_FEATURES_BACKFILL_CONSIDERED`
    variable as shown earlier.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you are using an existing project and you change the `DISTRO_FEATURES`
    variable as explained earlier, you will need to remove the `tmp` directory and
    build with `sstate-cache` or the build will fail.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not only does the root filesystem needs to be configured, but the Linux kernel
    also needs to be specifically configured with all the features required by `systemd`.
    There is an extensive list of kernel configuration variables in the `systemd`
    source README file. As an example, to extend the minimal kernel configuration
    that we will introduce in the *Reducing the Linux kernel image size* recipe later
    on this chapter, for the Wandboard to support `systemd`, we would need to add
    the following configuration changes in the `arch/arm/configs/wandboard-quad_minimal_defconfig`
    file:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The default kernel configuration provided for the Wandboard will launch a `core-image-minimal`
    image of `systemd` just fine.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Installing systemd unit files
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yocto offers the `systemd` class as a helper to install unit files. By default,
    unit files are installed on the `${systemd_unitdir}/system` path on the destination
    directory.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: When using this class, you need to specify the `SYSTEMD_SERVICE_${PN}` variable
    with the name of the unit file to install. You can optionally use the `SYSTEMD_PACKAGES`
    variable to list the packages to contain the unit files. By default, this is the
    main package only, and if multiple packages are provided, the `SYSTEMD_SERVICE`
    variable needs to be specified using overrides.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Services are configured to launch at boot by default, but this can be changed
    with the `SYSTEMD_AUTO_ENABLE` variable.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'An example snippet follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Installing package-installation scripts
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The supported package formats, RPM, ipk, and deb, support the addition of installation
    scripts that can be run at different times during a package installation process.
    In this recipe, we will see how to install them.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different types of installation scripts:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '**Preinstallation scripts** (`pkg_preinst`): These are called before the package
    is unpacked'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postinstallation scripts** (`pkg_postinst`): These are called after the package
    is unpacked, and dependencies will be configured'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preremoval scripts** (`pkg_prerm`): These are called with installed or at
    least partially installed packages'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postremoval scripts** (`pkg_postrm`): These are called after the package''s
    files have been removed or replaced'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example snippet of the installation of a preinstallation script in a recipe
    is as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'All installation scripts work in the same way, with the exception that the
    postinstallation scripts may be run either on the host at root filesystem image
    creation time, on the target (for those actions that cannot be performed on the
    host), or when a package is directly installed on the target. Have a look at the
    following code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the postinstallation script succeeds, the package is marked as installed.
    If the script fails, the package is marked as unpacked and the script is executed
    when the image boots again.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the recipe defines an installation script, the class for the specific package
    type will install it while following the packaging rules of the specific format.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: For postinstallation scripts, when running on the host, `D` is set to the destination
    directory, so the comparison test will fail. But `D` will be empty when running
    on the target.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended to perform postinstallation scripts on the host if possible,
    as we need to take into account that some root filesystems will be read only and
    hence it would not be possible to perform some operations on the target.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the Linux kernel image size
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before or in parallel with the root filesystem customization, embedded projects
    usually require an image size optimization that will reduce the boot time and
    memory usage.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Smaller images mean less storage space, less transmission time, and less programming
    time, which saves money both in manufacturing and field updates.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: By default, the compressed Linux kernel image (**zImage**) for the `wandboard-quad`
    is around 5.2 MB. This recipe will show how we can reduce that.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example of a minimal kernel configuration for a Wandboard that is able to
    boot from a microSD card root filesystem is the `arch/arm/configs/wandboard-quad_minimal_defconfig`
    file that follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This configuration builds an 886 K compressed Linux kernel image (zImage).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from hardware design considerations (such as running the Linux kernel
    from a NOR flash and **execute in place** (**XIP**) to avoid loading the image
    to memory), the first step in kernel size optimization is to review the kernel
    configuration and remove all superfluous features.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'To analyze the sizes of kernel blocks, we may use:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, `vmlinux` is the Linux kernel ELF image, which can be found in the Linux
    `build` directory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the usual things to exclude are:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Remove IPv6 (`CONFIG_IPV6`) and other superfluous networking features
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove block devices (`CONFIG_BLOCK`) if not needed
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove cryptographic features (`CONFIG_CRYPTO`) if unused
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the supported filesystem types and remove the unneeded ones, such as
    flash filesystems on flashless devices
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid modules and remove the module support (`CONFIG_MODULES`) from the kernel
    if possible
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good strategy is to start with a minimal kernel and add the essential stuff
    until you get a working system. Start with the `allnoconfig` GNU make target and
    review the configuration items under `CONFIG_EXPERT` and `CONFIG_EMBEDDED` as
    they are not included in the `allnoconfig` setting.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Some configuration changes that might not be obvious but reduce the image size
    considerably without feature removal are listed here:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Change the default compression method from **Lempel–Ziv–Oberhumer** (**LZO**)
    to XZ (`CONFIG_KERNEL_XZ`). The decompression speed will be a bit lower though.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the allocator from SLUB to **Simple List Of Blocks** (**SLOB**) (`CONFIG_SLOB`)
    for small embedded systems with little memory.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use no high memory (`CONFIG_HIGHMEM`) unless you have 4 GB or more memory.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may also want to have a different configuration for production and development
    systems, so you may remove the following from your production images:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '`printk` support (`CONFIG_PRINTK`)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracing` support (`CONFIG_FTRACE`)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the compilation side of things, optimize for size using `CONFIG_CC_OPTIMIZE_FOR_SIZE`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the basics are covered, we would need to analyze the kernel functions
    to identify further reduction areas. You can print a sorted list of kernel symbols
    with the following:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You would then need to look into the kernel source to find optimizations.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual space used by the uncompressed kernel in memory can be obtained
    from a running Wandboard kernel log as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'From here, the `.text` section contains code and constant data, the `.data`
    section contains the initialization data for variables, and the `.bss` sections
    contains all uninitialized data. The `.init` section contains global variables
    used during Linux initialization only, which are freed afterwards as can be seen
    from the following Linux kernel boot message:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There are ongoing efforts to reduce the size of the Linux kernel, so it is expected
    that newer kernel versions will be smaller and will allow for better customization
    for use in embedded systems.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the root filesystem image size
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the `core-image-minimal` size for the `wandboard-quad` unpacked
    tarball is around 45 MB, and `core-image-sato` is around 150 MB. This recipe will
    explore methods to reduce their size.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example of a small image, `core-image-small`, that does not include the
    `packagegroup-core-boot` recipe and can be used as the base for a root filesystem
    image with reduced size, `recipes-core/images/core-image-small.bb`, is shown next:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This recipe produces an image of about 6.4 MB. You can go even smaller if you
    use the `poky-tiny` distribution by adding the following to your `conf/local.conf`
    file:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `poky-tiny` distribution makes a series of size optimizations that may
    restrict the set of packages you can include in your image. To successfully build
    this image, you have to skip one of the sanity checks that the Yocto build system
    performs, by adding the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: With `poky-tiny`, the size of the image is further reduced to around 4 MB.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: There are further reductions that can be done to the image; for example, we
    could replace `sysvinit` with `tiny-init`, but that is left as an exercise for
    the reader.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Images with reduced sizes are also used alongside production images for tasks
    such as rescue systems and manufacturing test processes. They are also ideal to
    be built as `initramfs` images; that is, images that the Linux kernel mounts from
    memory, and can even be bundled into a single Linux kernel image binary.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start with an appropriate image like `core-image-minimal` and analyze the dependencies
    as shown in the *Debugging the build system* recipe in [Chapter 1](ch01.html "Chapter 1. The
    Build System"), *The Build System*, and decide which of them are not needed. You
    could also use the file sizes listed in the image''s build history, as seen in
    the *Using build history* recipe, also in [Chapter 1](ch01.html "Chapter 1. The
    Build System"), *The Build System*, to detect the biggest files in the filesystem
    and review them. To sort the file sizes, which appear in the fourth column of
    the `files-in-image.txt` file, in reverse order, we could execute:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'From this, we observe that `glic` is the biggest contributor to the filesystem
    size. Some other places where some space on a console-only system can be saved
    are:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Use the IPK package manager, as it is the lightest, or better yet, remove the
    `package-management` feature from your production root filesystem altogether.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use BusyBox''s `mdev` device manager instead of `udev` by specifying it in
    your `conf/local.conf` file as follows:'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that this will only work with core images that include `packagegroup-core-boot`.
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we are running the root filesystem on a block device, use ext2 instead of
    ext3 or ext4 without the journal.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure BusyBox with only the essential applets by providing your own configuration
    file in `bbappend`.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the `glibc` configuration, which can be changed via the `DISTRO_FEATURES_LIBC`
    distribution configuration variable. An example of its usage can be found in the
    `poky-tiny` distribution, which is included in the `poky` source. The `poky-tiny`
    distribution can be used as a template for the distribution customization of small
    systems.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider switching to a lighter `C` library than the default `glibc`. For a
    while, `uclibc` was being used as an alternative, but the library seems to be
    unmaintained for the last couple of years, and the `core-image-minimal` image
    for the Wandboard does not currently build using it.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recently, there has been some activity with **musl** ([http://www.musl-libc.org/](http://www.musl-libc.org/)),
    a new MIT-licensed `C` library. To enable it, you would add the following to your
    `conf/local.conf` file:'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TCLIBC = "musl"
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And you would need to add the `meta-musl` layer ([https://github.com/kraj/meta-musl](https://github.com/kraj/meta-musl))
    to your `conf/bblayers.conf` file.
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It currently builds `core-image-minimal` for QEMU targets, but there is still
    work to be done to use it on real hardware like the Wandboard.
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compile your applications with `-Os` to optimize for size.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing software
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When releasing a product based on the Yocto project, we have to consider that
    we are building on top of a multitude of different open source projects, each
    with different licensing requirements.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: At the minimum, your embedded product will contain a bootloader (probably U-Boot),
    the Linux kernel, and a root filesystem with one or more applications. Both U-Boot
    and the Linux kernel are licensed under the **General Public License version 2**
    (**GPLv2**). And the root filesystem could contain a variety of programs with
    different licenses.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: All open source licenses allow you to sell a commercial product with a mixture
    of proprietary and open licenses as long as they are independent and the product
    complies with all the open source licenses. We will discuss open source and proprietary
    cohabiting in the *Working with open source and proprietary code* recipe later
    on.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand all the licensing implications before releasing
    your product to the public. The Yocto project provides tools to make handling
    licensing requirements an easier job.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first need to specify what requirements we need to comply with to distribute
    a product built with the Yocto project. For the most restrictive open source licenses,
    this usually means:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Source code distribution, including modifications
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: License texts distributions
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution of the tools used to build and run the software
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `archiver` class to provide the deliverables that need to be
    distributed to comply with the licenses. We can configure it to:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Provide the original unpatched source as tarballs
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the patches to apply to the original source
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the recipes used to build the source
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the license text that must sometimes accompany the binary (according
    to some licenses)
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the `archiver` class as specified earlier, we add the following to our
    `conf/local.conf` file:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The sources will be provided in the `tmp/deploy/sources` directory under a license
    subdirectory hierarchy.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `wandboard-quad`, we find the following directories under `tmp/deploy/sources`:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '`allarch-poky-linux`'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arm-poky-linux-gnueabi`'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And looking for what''s distributed for the Linux kernel source, a GPLv2 package,
    we find under `tmp/deploy/sources/arm-poky-linux-gnueabi/linux-wandboard-3.10.17-r0`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '`defconfig`'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`github.com.wandboard-org.linux.git.tar.gz`'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linux-wandboard-3.10.17-r0-recipe.tar.gz`'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So we have the kernel configuration, the source tarball, and the recipes used
    to build it, which include:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '`linux-wandboard_3.10.17.bb`'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linux-dtb.inc`'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linux-wandboard.inc`'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the license text for the root filesystem packages will also be included
    in the root filesystem under `/usr/share/common-licenses`, in a package directory
    hierarchy.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: This configuration will provide deliverables for all build packages, but what
    we really want to do is provide them only for those whose licenses require us
    to.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: For sure, we don't want to blindly distribute all the contents of the `sources`
    directory as is, as it will also contain our proprietary source, which we most
    likely don't want to distribute.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the `archiver` class only to provide the source for GPL and
    LGPL packages with the following:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And also, for an embedded product, we are usually only concerned with the software
    that ships in the product itself, so we can limit the recipe type to be archived
    to target images with the following:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We should obtain legal advice to decide which packages have licenses that make
    source distribution a requirement.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Other configuration options exist, such as providing the patched or configured
    source instead of the separated original source and patches, or source `rpms`
    instead of source tarballs. See the `archiver` class for more details.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also choose to distribute the whole of our build environment. The best
    way to do this is usually to publish our BSP and software layers on a public Git
    repository. Our software layer can then provide `bblayers.conf.sample` and `local.conf.sample`,
    which can be used to set up ready-to-use `build` directories.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other requirements that haven't been discussed here, such as the mechanism
    chosen for distribution. It is recommended to get legal advice before releasing
    a product to ensure all the license obligations have been met.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing your system for compliance
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Yocto build system makes it easy to provide auditing information to our
    legal advisers. This recipe will explain how.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under `tmp/deploy/licenses`, we find a directory list of packages (including
    their corresponding licenses) and an `image` folder with a package and license
    manifest.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'For the example image provided before, `core-image-small`, we have the following:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'And the corresponding `tmp/deploy/licenses/core-image-small-wandboard-quad-<timestamp>/license.manifest`
    file excerpt is as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: These files can be used to analyze all the different packages that form our
    root filesystem. We can also audit them to make sure we comply with the licenses
    when releasing our product to the public.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can instruct the Yocto build system to specifically avoid certain licenses
    by using the `INCOMPATIBLE_LICENSE` configuration variable. The usual way to use
    it is to avoid GPLv3-type licenses by adding the following to your `conf/local.conf`
    file:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This will build `core-image-minimal` and `core-image-base` images as long as
    no extra image features are included.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Working with open source and proprietary code
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common for an embedded product to be built upon an open source system
    like the one built by Yocto, and to include proprietary software that adds value
    and specializes the product. This proprietary part usually is intellectual property
    and needs to be protected, and it's important to understand how it can coexist
    with open source.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will discuss some examples of open source packages commonly found
    on embedded products and will briefly explain how to use proprietary software
    with them.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open source licenses can be broadly divided into two categories based on whether
    they are:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissive**: These are similar to **Internet Software Consortium** (**ISC**),
    MIT, and BSD licenses. They have few requirements attached to them and just require
    us to preserve copyright notices.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restrictive**: These are similar to the GPL, which bind us to not only distribute
    the source code and modifications, either with the binary itself or at a later
    date, but also to distribute tools to build, install, and run the source.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, some licenses might "pollute" modifications and derivative work with
    their own conditions, commonly referred to as *viral licenses*, while others will
    not. For example, if you link your application to GPL-licensed code, your application
    will be bound by the GPL too.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: The virulent nature of the GPL has made some people wary of using GPL-licensed
    software, but it's important to note that proprietary software can run alongside
    GPL software as long as the license terms are understood and respected.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: For example, violating the GPLv2 license would mean losing the right to distribute
    the GPLv2 code in the future, even if further distribution is GPLv2 compliant.
    In this case, the only way to be able to distribute the code again would be to
    ask the copyright holder for permission.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will provide guidance regarding licensing requirements for some open
    source packages commonly used in embedded products. It does not constitute legal
    advice, and as stated before, proper legal auditing of your product should be
    done before public release.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: The U-Boot bootloader
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: U-Boot is licensed under the GPLv2, but any program launched by it does not
    inherit its license. So you are free to use U-Boot to launch a proprietary operating
    system, for example. However, your final product must comply with the GPLv2 with
    regards to U-Boot, so U-Boot source code and modifications must be provided.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linux kernel is also licensed under the GPLv2\. Any application that runs
    in the Linux kernel user space does not inherit its license, so you can run your
    proprietary software in Linux freely. However, Linux kernel modules are part of
    the Linux kernel and as such must comply with the GPLv2\. Also, your final product
    must release the Linux kernel source and modifications, including external modules
    that run in your product.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Glibc
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GNU `C` library is licensed under the **Lesser General Public License**
    (**LGPL**), which allows dynamic linking without license inheritance. So your
    proprietary code can dynamically link with `glibc`, but of course you still have
    to comply with the LGPL with regards to `glibc`. Note, however, that statically
    linking your application would pollute it with the LGPL.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: BusyBox
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BusyBox is also licensed under the GPLv2\. The license allows for non-related
    software to run alongside it, so your proprietary software can run alongside BusyBox
    freely. As before, you have to comply with the GPLv2 with regards to BusyBox and
    distribute its source and modifications.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: The Qt framework
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Qt is licensed under three different licenses, which is common for open source
    projects. You can choose whether you want a commercial license (in which case,
    your proprietary application is protected), a LGPL license (which, as discussed
    before, would also protect your proprietary software by allowing the dynamic linking
    of your application as long as you complied with the LGPL for the Qt framework
    itself), or the GPLv3 (which would be inherited by your application).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: The X Windows system
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `X.Org` source is licensed under permissive MIT-style licenses. As such,
    your proprietary software is free to make any use of it as long as its use is
    stated and copyright notices are preserved.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to integrate our proprietary-licensed code into the Yocto build
    system. When preparing the recipe for our application, we can take several approaches
    to licensing:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark `LICENSE` as closed. This is the usual case for a proprietary application.
    We use the following:'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Mark `LICENSE` as proprietary and include some type of license agreement. This
    is commonly done when releasing binaries with some sort of end user agreement
    that is referenced in the recipe. For example, `meta-fsl-arm` uses this type of
    license to comply with Freescale''s End User License Agreement. An example follows:'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Provide multiple licensing options, such as an open source license and a commercial
    license. In this case, the `LICENSE` variable is used to specify the open licenses,
    and the `LICENSE_FLAGS` variable is used for the commercial licenses. A typical
    example is the `gst-plugins-ugly` package in Poky:'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When the `LICENSE_FLAGS` variable is set on a recipe, the package will not
    be built unless the license appears on the `LICENSE_FLAGS_WHITELIST` variable
    too, typically defined in your `conf/local.conf` file. For the earlier example,
    we would add:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `LICENSE` and `LICENSE_FLAGS_WHITELIST` variables can match exactly for
    a very narrow match or broadly, as in the preceding example, which matches all
    licenses that begin with the word `commercial`. For narrow matches, the package
    name must be appended to the license name; for instance, if we only wanted to
    whitelist the `gst-plugins-ugly` package from the earlier example but nothing
    else, we could use the following:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: See also
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should refer to the specific licenses for a complete understanding of the
    requirements imposed by them. You can find a complete list of open source licenses
    and their documentation at [http://spdx.org/licenses/](http://spdx.org/licenses/).
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
