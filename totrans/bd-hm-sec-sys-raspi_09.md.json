["```\n$ sudo apt-get update\n$ sudo apt-get install bc\n\n```", "```\n#!/bin/bash\n#/etc/pi-alarm/alarm-control.sh\n\nALM_BELL_DURATION=600    #duration in seconds the alarm bell should sound for\nALM_EXIT_DELAY=30    #entry/exit zone delay in seconds\nALM_KEY_ARMED=0    #status of the arm/disarm key switch\nALM_SYS_ARMED=0    #armed status of the system\n\nALM_ZONE_INPUT_READ=\"\"      #this will store the value of the zone inputs read\nALM_ZONE_INPUT_STAT=\"00000000\"    #binary representation of the inputs (b7-b0)\nALM_ZONE_INPUT_PREV=\"\"      #previous zone input status\nALM_ZONE_TRIGGER=0    #this will be set to 1 if one or more zones is triggered\nALM_ZONES_STAT=(0 0 0 0 0 0 0 0)    #dynamic array of normalised zone status (z1 to z8 order) - 1 is triggered\n\nSTAT_RET_VAL=\"\"    #return value from functions\n```", "```\n#This helper function will update the alarm config\n#file with the specified value (alarm.cfg) so that\n#the Web panel can know the latest status\nfunction almUpdateConfigSetting()\n{\n  #$1 - Setting Name\n  #$2 - Setting Value\n  sudo sed -i \"s/^\\($1\\s*= *\\).*/\\1$2/\" /etc/pi-alarm/alarm.cfg\n}\n```", "```\n# GPIO SET UP ###################################\n#Set up the Raspberry Pi GPIO pins\n#Refer to Chapter 2 for info\n#D0 (GPIO17) Arm/Disarm Key Input\nsudo echo 17 > /sys/class/gpio/export\nsudo echo in > /sys/class/gpio/gpio17/direction\n\n#D4 (GPIO23) Armed LED Output\nsudo echo 23 > /sys/class/gpio/export\nsudo echo out > /sys/class/gpio/gpio23/direction\nsudo echo 0 > /sys/class/gpio/gpio23/value\n\n#D5 (GPIO24) Exit Buzzer Output\nsudo echo 24 > /sys/class/gpio/export\nsudo echo out > /sys/class/gpio/gpio24/direction\nsudo echo 0 > /sys/class/gpio/gpio24/value\n\n#D6 (GPIO25) Alarm LED Output\nsudo echo 25 > /sys/class/gpio/export\nsudo echo out > /sys/class/gpio/gpio25/direction\nsudo echo 0 > /sys/class/gpio/gpio25/value\n\n#D7 (GPIO4)  Alarm Bell Output\nsudo echo 4 > /sys/class/gpio/export\nsudo echo out > /sys/class/gpio/gpio4/direction\nsudo echo 0 > /sys/class/gpio/gpio4/value\n```", "```\n#This helper function will switch a specified GPIO output on or off\nfunction almSetGPIOValue()\n{\n  #$1 - GPIO pin number\n  #$2 - Value\n  sudo echo $2 > /sys/class/gpio/gpio$1/value\n}\n#Helper functions to switch on and off the outputs\nfunction almSetArmedLED()\n{\n  #$1 - 0 or 1 (Off or On)\n  almSetGPIOValue 23 $1\n  echo \"[ALM] Armed LED set to $1\"\n}\nfunction almSetExitBuzzer()\n{\n  #$1 - 0 or 1 (Off or On)\n  almSetGPIOValue 24 $1\n  echo \"[ALM] Exit Buzzer set to $1\"\n}\nfunction almSetAlarmLED()\n{\n  #$1 - 0 or 1 (Off or On)\n  almSetGPIOValue 25 $1\n  echo \"[ALM] Alarm Trigger LED set to $1\"\n}\nfunction almSetAlarmBell()\n{\n  #$1 - 0 or 1 (Off or On)\n  almSetGPIOValue 4 $1\n  echo \"[ALM] Alarm Bell set to $1\"\n}\n```", "```\n#this function returns whether the system is armed via\n#either the web console or key switch\nfunction almGetArmedSwitchStatus()\n{\n  STAT_RET_VAL=\"0\"\n  #read arm key switch input from \n  local L_VAL=$(sudo cat /sys/class/gpio/gpio17/value)\n  if [ $L_VAL -eq 1 ]; then\n    #system has been armed with key switch\n    echo \"[ALM] System ARMED with key switch\"\n    ALM_KEY_ARMED=1\n    almUpdateConfigSetting \"SYSTEM_ARMED\" \"1\" #set system armed console flag\n    STAT_RET_VAL=\"1\"\n  else\n    #read system armed value from web console config file\n    if [ $SYSTEM_ARMED == 1 ]; then\n      echo \"[ALM] System ARMED with web console\"\n      STAT_RET_VAL=\"1\"\n    fi\n  fi\n}\n```", "```\n# PORT EXPANDER SET UP ##########################\n#Refer to Chapter 4 for more information about the I2C bus\n\n#We will set up I/O BUS A as all inputs\nsudo i2cset -y 1 0x20 0x00 0xFF\n\n#Whilst we're not using BUS B in our system,\n#we can set that up as all inputs too\nsudo i2cset -y 1 0x20 0x01 0xFF\n```", "```\n#This function will read the port inputs and set the\n#status of each zone\nfunction almReadZoneInputs()\n{\n  #preserve previous zone status\n  ALM_ZONE_INPUT_PREV=$ALM_ZONE_INPUT_STAT\n  #read the 8-bit hex value of port a\n  ALM_ZONE_INPUT_READ=$(sudo i2cget -y 1 0x20 0x12)\n\n  if [[ $ALM_ZONE_INPUT_READ = *\"Error\"* ]]; then\n    #An error occurred reading the I2C bus - set default value\n    ALM_ZONE_INPUT_READ=\"0x00\"\n  fi\n\n  #remove the 0x at the start of the value to get the hex value\n  local L_HEX=${ALM_ZONE_INPUT_READ:2}\n  #convert the hex value to binary\n  local L_BIN=$(echo \"obase=2; ibase=16; $L_HEX\" | bc )\n  #zero pad the binary to represent all 8 bits (b7-b0)\n  ALM_ZONE_INPUT_STAT=$(printf \"%08d\" $L_BIN)\n\n  echo \"[ALM] Zone I/O Status: $ALM_ZONE_INPUT_STAT ($ALM_ZONE_INPUT_READ)\"\n\n  #check each zone input to see if it's in a triggered state\n  #a triggered state may be either 1 or 0 depending on the input's configuration\n  #you'll need to set the logic here accordingly for each input\n  #the ALM_ZONES_STAT array contains the definitive trigger value for each input\n\n  #zone 1 test (bit 0)\n  local L_FLG=${ALM_ZONE_INPUT_STAT:7:1}\n  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[0]=0; else ALM_ZONES_STAT[0]=1; fi\n\n  #zone 2 test (bit 1)\n  local L_FLG=${ALM_ZONE_INPUT_STAT:6:1}\n  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[1]=0; else ALM_ZONES_STAT[1]=1; fi\n  #zone 3 test (bit 2)\n  local L_FLG=${ALM_ZONE_INPUT_STAT:5:1}\n  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[2]=0; else ALM_ZONES_STAT[2]=1; fi\n\n  #zone 4 test (bit 3)\n  local L_FLG=${ALM_ZONE_INPUT_STAT:4:1}\n  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[3]=0; else ALM_ZONES_STAT[3]=1; fi\n\n  #zone 5 test (bit 4)\n  local L_FLG=${ALM_ZONE_INPUT_STAT:3:1}\n  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[4]=0; else ALM_ZONES_STAT[4]=1; fi\n\n  #zone 6 test (bit 5)\n  local L_FLG=${ALM_ZONE_INPUT_STAT:2:1}\n  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[5]=0; else ALM_ZONES_STAT[5]=1; fi\n\n  #zone 7 test (bit 6)\n  local L_FLG=${ALM_ZONE_INPUT_STAT:1:1}\n  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[6]=0; else ALM_ZONES_STAT[6]=1; fi\n\n  #zone 8 test (bit 7)\n  local L_FLG=${ALM_ZONE_INPUT_STAT:0:1}\n  if [ $L_FLG -eq 0 ]; then ALM_ZONES_STAT[7]=0; else ALM_ZONES_STAT[7]=1; fi\n\n  echo \"[ALM] Zone Trigger Status: $ALM_ZONES_STAT[*]\"\n}\n```", "```\n# initialise system #########\necho \"[ALM] Initialising system...\"\nalmUpdateConfigSetting \"SYSTEM_ARMED\" \"0\" #clear system armed console flag\nsleep 1\nsudo cat /etc/pi-alarm/alarm.cfg\nsleep 1\necho \"[ALM] Initialising done\"\n#############################\n```", "```\n# loop continuously###########\nwhile true\ndo\n\n  # wait for system to be armed ###############\n  echo \"[ALM] Alarm now in STAND-BY state - waiting to be armed\"\n  almSetArmedLED 0 #switch off armed LED\n  STAT_RET_VAL=\"0\"\n  while [[ $STAT_RET_VAL = \"0\" ]]; do  \n    sleep 1\n    #read the control panel status file\n    . /etc/pi-alarm/alarm.cfg\n    almGetArmedSwitchStatus #result is returned in STAT_RET_VAL\n    echo -n \"*\" # indicate standby mode\n  done\n  #############################################\n```", "```\n  # perform exit delay ########################\n  echo \"[ALM] Alarm now in EXIT DELAY state\"\n  almSetExitBuzzer 1 #switch on exit buzzer\n  COUNTER=$ALM_EXIT_DELAY\n  while [[ $STAT_RET_VAL = \"1\" && $COUNTER -gt 0 ]]; do\n    sleep 1\n    #read the control panel status file\n    . /etc/pi-alarm/alarm.cfg\n    almGetArmedSwitchStatus #result is returned in STAT_RET_VAL\n    COUNTER-=1\n    echo -n \"X$COUNTER \" # indicate exit mode\n  done\n  almSetExitBuzzer 0 #switch off exit buzzer\n  #############################################\n\n  # system now armed - monitor inputs #########\n  ALM_SYS_ARMED=1\n  echo \"[ALM] Alarm now in ARMED state\"  \n  almSetArmedLED 1 #switch on armed LED\n\n  #read the control panel status file\n  . /etc/pi-alarm/alarm.cfg  \n  almReadZoneInputs  # > ALM_ZONES_STAT[x]\n```", "```\n  #check each zone input to set if it's enable\n  #and has been triggered  \n  #NUM_ZONES setting is stored in alarm.cfg\n\n  while [[ $ALM_SYS_ARMED -eq 1 ]]; do\n    echo -n \"A\" #indicate armed mode\n\n    ALM_ZONE_TRIGGER=0  \n    for (( i=$NUM_ZONES; i>0; i-- )); do  \n      if [[ $ALM_ZONES_STAT[$i-1] -eq 1 ]]; then\n        #zone has been triggered\n        echo \"[ALM] Zone $i TRIGGERED\"\n        E_VAR=\"ZONE_ENABLE_$i\"\n        E_VAL=`echo \"$E_VAR\"` #get zone enabled status loaded from alarm.cfg\n\n        if [[ $E_VAL -eq 1 ]]; then\n          #zone is enabled\n          ALM_ZONE_TRIGGER=1 #set alarm triggered flag\n          echo \"[ALM] Zone $i ENABLED - alarm will be triggered\"\n          almUpdateConfigSetting \"ZONE_STATUS_$i\" \"1\" \n\n          ## YOU CAN INSERT CODE HERE TO TAKE CAMERA IMAGE IF YOU WANT##\n          ## REFER BACK TO CHAPTER 6 ##\n\n        fi\n      fi\n    done\n\n    . /etc/pi-alarm/alarm.cfg\n    almGetArmedSwitchStatus #result is returned in STAT_RET_VAL\n```", "```\n    if [[ $ALM_ZONE_TRIGGER -eq 1 ]]; then\n      # alarm has been triggered    \n      almSetAlarmLED 1\n      echo \"[ALM] A zone has been triggered\"\n\n      #####################################\n      # ZONE 1 is the ENTRY zone - if that's triggered then delay\n      if [[ $ALM_ZONES_STAT[0] -eq 1 ]]; then\n        # perform entry delay ###########\n        echo \"[ALM] Alarm now in ENTRY state\"\n        setExitBuzzer 1 #switch on entry/exit buzzer\n\n        COUNTER=$ALM_EXIT_DELAY  \n        STAT_RET_VAL=\"0\"\n        while [[ $STAT_RET_VAL = \"1\" && $COUNTER -gt 0 ]]; do\n          echo -n \"E$COUNTER \" #indicate entry mode\n          sleep 1\n          #read the control panel status file\n          . /etc/pi-alarm/alarm.cfg\n          almGetArmedSwitchStatus #result is returned in STAT_RET_VAL    \n          COUNTER-=1\n        done\n      fi\n      #####################################\n```", "```\n      #####################################\n      # STAY in TRIGGERED mode until system has been disarmed\n      if [[ $STAT_RET_VAL = \"1\" ]]; then\n        #alarm has not been disabled\n        almSetAlarmBell 1 #switch on alarm bell\n        echo \"[ALM] Alarm now in TRIGGERED state\"\n\n        ## YOU CAN INSERT CODE HERE TO SEND YOU AN EMAIL IF YOU WANT##\n        ## REFER BACK TO CHAPTER 6 ##\n\n        COUNTER=0\n        STAT_RET_VAL=\"0\"\n        while [[ $STAT_RET_VAL = \"1\" ]]; do\n          echo -n \"T$COUNTER \" #indicate triggered mode\n          sleep 1\n          #read the control panel status file\n          . /etc/pi-alarm/alarm.cfg\n          almGetArmedSwitchStatus #result is returned in STAT_RET_VAL    \n\n          COUNTER+=1\n          if [[ $COUNTER -gt $ALM_BELL_DURATION ]]; then\n            almSetAlarmBell 0 #switch off alarm bell            \n            echo \"[ALM] Bell has been switched OFF\"\n          fi          \n        done\n      fi\n      #####################################\n```", "```\n      # alarm has been disarmed ##########\n      echo \"[ALM] Alarm has been DISARMED\"\n      ALM_SYS_ARMED=0\n      almSetAlarmBell 0 #switch off alarm bell\n      almSetExitBuzzer 0 #switch off exit buzzer\n      almSetAlarmLED 0\n      almSetArmedLED 0 #switch off armed LED\n\n      #####################################\n    fi\n\n  done\n  #############################################\n\ndone\n#############################################\n```", "```\n$ sudo chmod 777 /etc/pi-alarm/alarm-control.sh\n\n```", "```\npi@raspberrypi ~ $ ls -1 /etc/pi-alarm\nalarm.cfg\nalarm-control.sh\nupdate-alarm-setting.sh\n```", "```\n$ sudo nano /etc/rc.local\n\n```", "```\nsudo /etc/pi-alarm/alarm-control.sh &\n\n```", "```\n#!/bin/sh -e\n#\n# rc.local\n#\n# This script is executed at the end of each multiuser runlevel.\n# Make sure that the script will \"exit 0\" on success or any other\n# value on error.\n#\n# In order to enable or disable this script just change the execution\n# bits.\n#\n# By default this script does nothing.\n\n# Print the IP address\n_IP=$(hostname -I) || true\nif [ \"$_IP\" ]; then\n  printf \"My IP address is %s\\n\" \"$_IP\"\nfi\n\nsudo /etc/pi-alarm/alarm-control.sh &\nexit 0\n```", "```\n#!/bin/bash\n#/etc/pi-alarm/setup-ramfs.sh\n\nRAM_DISK=\"/ramfs\"\nRAM_DISK_SIZE=64M\n\n# Create RAM Disk ##########################\nif [ ! -z \"$RAM_DISK\" ]; then\n  echo \"[INIT] Creating RAM Disk... $RAM_DISK\"\n  mkdir -p $RAM_DISK\n  chmod 777 $RAM_DISK\n  mount -t tmpfs -o size=$RAM_DISK_SIZE tmpts $RAM_DISK/\n  echo \"[INIT] RAM Disk created at $RAM_DISK\"  \nfi\n############################################\n```", "```\n$ cd /ramfs\n$ ls\n\n```", "```\n. /etc/pi-alarm/setup-ramfs.sh\n```"]