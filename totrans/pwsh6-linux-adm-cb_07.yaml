- en: Flow Control using Branches and Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using If–ElseIf–Else conditions to control script flow
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Switch–Case conditions to control script flow
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learning to use delays
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing a basic looping construct
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing a more complex loop on a predefined array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the For loop construct
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the While loop construct
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning empty directories using the Do–While construct
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning empty directories using the Do–Until construct
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like Working with Strings, this Flow Control is also a favourite part of
    PowerShell to me.
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux administrators and Bash scripters would already be familiar with
    the concepts such as the loops and branches, that cover these recipes. The only
    main difference we would see is that we would deal with objects, and a more readable,
    streamlined process of scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Using If–ElseIf–Else conditions to control script flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how the operators work. Try out more of the operators until it
    sort of becomes a second nature to you. Most of the flow control as well as filtration
    in scripts happen using these operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe we are going to look at conditional script flow, also known
    as *branching*. In essence, branching works on two conditions (correct: `$true`
    and `$false`). And this is generally achieved using two constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: The If–ElseIf–Else construct
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Switch–Case construct
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this recipe, we will give ourselves a simple problem to solve: find if today
    is a weekend.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These recipes require you to try them, in order to understand how they work.
    And these work better on an Integrated Scripting Environment (preferably, Visual
    Studio Code) than at the prompt. To run the scripts in VS Code, use the F5 key. Also,
    these recipes should work identically on Windows PowerShell 3.0+ as well: the
    syntaxes for these constructs are exactly the same in PowerShell and Windows PowerShell.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a new PowerShell file in Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the following in the code pane to simply find if it is a weekend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to get an output on weekdays as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to jazz it up a little, and use the whole of `if`–`elseif`–`else`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In general, `Write-Output` is a better cmdlet to use than `Write-Host`. `Write-Host`
    writes the output *only* to the host; this output cannot be sent to anything else
    without manipulation. Use `Write-Host` only on occasions that need it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple branching could work with just the If statement. The statement checks
    for truth, and executes the code block based on the outcome of the condition.
    In case of either–or, where there are only two conditions, use If–Else. When there
    are more than two possible outcomes, use If–ElseIf–Else. The `else` block is the
    catch-all.
  prefs: []
  type: TYPE_NORMAL
- en: Using Switch–Case conditions to control script flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If–ElseIf–Else work when you have outcomes coming in categories (weekdays being
    five days, weekends being two). When the outcomes are specific and/or too many
    in number, it could be a little tedious to use the  If–ElseIf–Else construct.
    To understand this better, let us give ourselves a scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The dress code at your workplace is decided by a child, who likes everyone wearing
    the colours of the rainbow. Since she doesn't like anyone working weekends, is
    not a big fan of orange, and absolutely hates yellow, she has come up with the
    following scheme (she does not yet know of "Monday Blues"): Red on Mondays, Violet
    on Tuesdays, Indigo on Wednesdays, Blue on Thursdays, Green on Fridays and Orange
    during the weekends.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This situation would require a whole round of If–ElseIf–Else statements to program.
    A more efficient way of handling the situation is to use the Switch–Case construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new PowerShell file and add the following content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would rather omit `Default` and use a wildcard matching for the weekends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like we can see, it is more efficient to write, execute as well as troubleshoot
    a Switch–Case construct in such situations, rather than writing a series of if–elseif–elseif–elseif–...–else
    statements. To define a catch-all action in Switch–Case, use `Default`.
  prefs: []
  type: TYPE_NORMAL
- en: The Switch–Case construct also supports wildcard (`-Wildcard`) and regex (`-Regex`).
    In general, it is not a good practice to omit `Default` unless *all* the possible
    outcomes have been covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The working of Switch–Case is simple: it checks the condition against *all
    the values* among the definitions, and whenever it finds a condition to be true,
    it executes the corresponding script block. Therefore if three conditions among
    five are met, the three script blocks will be executed. This is a little unlike
    If–ElseIf–Else, which exits out of the branching construct the moment the first
    `$true` is met and the script block is executed. Therefore, if you want only one
    outcome from the construct, consider adding the `break` keyword in every script
    block to break out of the construct the moment a `$true` is encountered. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Of course, in this particular situation, it is not necessary, since the outcome
    would be exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to use delays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell usually runs one statement after another; the current statement must
    return the buffer (so to speak) for the next step to begin execution. However,
    in some cases, you still require a wait; situations where the buffer could be
    returned before the desired outcome is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: While setting up something like this may require some manipulation, to keep
    it simple, let us just assume that we need five seconds to register what day it
    is (sure, disbelief works), before being instructed what to wear.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us combine the two scripts from the previous recipe, *Using conditions to
    control script flow*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9586edab-e1bb-444a-a119-28584db1a57b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason this is a separate recipe is that it is part of flow control, and
    is useful in some specific situations. The `Start-Sleep` cmdlet accepts `Seconds`
    or `Milliseconds` as input, and waits for that amount of time before processing
    the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic looping construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Automation is perhaps only half-complete without loops. After all, the point
    of automation in most situations is making the computer do what is repetitive.
    There are six looping constructs in PowerShell in all:'
  prefs: []
  type: TYPE_NORMAL
- en: Looping using `Foreach-Object`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Foreach loop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The For loop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The While loop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Do–While loop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Do-Until loop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Foreach-Object` looping construct is perhaps the simplest of them all.
  prefs: []
  type: TYPE_NORMAL
- en: Let us imagine that we have a list of five guests to a certain event, and you
    would like to greet them each individually.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us assume that the guests are Mr Jain, Mr Jacobs, Ms Sanders, Mr Shah and
    Mr Hugo.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file in Visual Studio Code and, in the script pane, type the following.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script, and at the prompt, type in the names of the guests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You first take in the input through a prompt from the host. The raw guest list
    is taken in. PowerShell then splits the input string based on the commas and a
    regular expression match (necessary so it would work whether the input contains
    a space after the comma or not: not all users are alike). We use the `-split`
    and cast operators for the operation.'
  prefs: []
  type: TYPE_NORMAL
- en: The loop part comes in at `Foreach-Object`. You pass the array object into the
    pipeline. The `Foreach-Object` cmdlet picks up the array, and processes one element
    at a time. When referring to the element within the loop, you use the `$PSItem`
    (a.k.a. `$_`) automatic variable, since the object has been passed through the
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a more complex loop on a predefined array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, Writing a basic loop construct, we wrote a simple loop by
    passing content through the pipeline. Now, let us consider that we have these
    same guests, but specific seats have been allotted to them. We would like to show
    the seats to the guests. You have the following table in a CSV format.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Seat** |'
  prefs: []
  type: TYPE_TB
- en: '| Mr Jain | A-12 |'
  prefs: []
  type: TYPE_TB
- en: '| Mr Jacobs | C-28 |'
  prefs: []
  type: TYPE_TB
- en: '| Ms Sanders | B-17 |'
  prefs: []
  type: TYPE_TB
- en: '| Mr Shah | M-22 |'
  prefs: []
  type: TYPE_TB
- en: '| Mr Hugo | E-08 |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The assumption here is that each row has forty seats, and the aisle goes through
    the centre of the hall.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not cloned the repository, you could create your own CSV file. Either
    copy the comma-separated content from below, or create a CSV using PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a new PowerShell file in Visual Studio Code and type the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/05449802-4f16-462e-a2a1-6ddfb8a26793.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main idea here is the use of `foreach`. When using the Foreach loop construct,
    you refer to each element with a variable; variables are not identified with an
    index in this case. For every iteration, in our case, `$Guest` picks one value
    from `$Guests`, in sequence, so that the current element can be referred using `$Guest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The seat numbers have a pattern: an alpha row identifier, followed by a hyphen,
    followed by the numeric seat identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: The seat number is a string. We split it at `-`, pick the first element in the
    resultant array, convert it to uppercase (in case it already isn't), convert this
    letter to a character, and then, use the `[byte]` cast operator to find its ASCII
    identifier. And yes, we subtract 64 from it (so `A` becomes `1`).
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use the number with switch–case without errors, we convert the
    number back to a string. We make the number friendly for use in a sentence. We
    take the second (numeric) part of the array to see which side of the aisle the
    seat is located on. We combine all these to get the resultant greeting-and-guidance
    strings, which are displayed after a delay of one second each.
  prefs: []
  type: TYPE_NORMAL
- en: Using the For loop construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Foreach loop and the For loop are different in that the latter uses an index
    to perform operations. We need a variable to control the flow, whose values form
    a range. Let us re-implement the same solution as that in *Writing a more complex
    loop on a predefined array*, but with a For loop construct instead.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The assumptions made are the same as that in *Writing a more complex loop on
    a predefined array*.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and paste the following content into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of you might be pointing out that the `foreach` construct was simpler than
    the `for` construct in this case, and you would be right. In my stint as an administrator,
    I may have used the for construct less than ten times over the last three years,
    compared to hundreds of times I used `foreach`. The For construct has its own
    uses; use with a predefined array is of the less-efficient ones.'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, `for` works as long as the object is an array. `$CurrentGuest` is
    the index we use, which ranges from 0 through the total elements in `$Guests` –
    1\. The loop starts with the index being initialised at 0 in this case, and after
    every iteration of the script block, the index is incremented (`$CurrentGuest++`).
  prefs: []
  type: TYPE_NORMAL
- en: One operation where `for` would be more efficient than `foreach` is if every
    *alternate* guest had to be greeted (rude, I know). In that case, the third part
    of the definition of `for` would have been `$CurrentGuest += 2`.
  prefs: []
  type: TYPE_NORMAL
- en: '`$CurrentGuest + 2` instead of `$CurrentGuest += 2` would make this loop infinite,
    since the value of `$CurrentGuest` would not be changed at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the While loop construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We shall create two scripts in this recipe: the first one to establish the
    similarities between For and While, and another to lay the foundation to understanding
    the Do–While and Do–Until constructs. This way, the learning would be incremental,
    and understanding, easier.'
  prefs: []
  type: TYPE_NORMAL
- en: For the first script, the scenario is the same as described in the last recipe,
    *Using the For loop construct*. For the second, the task is to take the year number
    as input and find the date for Mothers’ Day in that year.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, continue with the assumptions you had for the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and paste the following content into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run the script; the output should be the same as that of the last recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a new PowerShell file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run the script. Enter any year and you should get the date for Mothers’ Day
    for that year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every finite looping construct requires three things:'
  prefs: []
  type: TYPE_NORMAL
- en: The starting point
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The stopping point
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The way to proceed towards the stopping point
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In case of the Foreach construct, the entire logic is pre-coded. It takes an
    entire array, finds the starting and stopping points, and moves towards the stopping
    point one step at a time. The For construct has these parameters declared in the
    loop declaration statements itself, each parameter separated by a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: The While loop is not very different. Its starting point is defined outside
    of the loop, the stopping point is the only condition passed, and the operation
    on the index is specified within the loop. These three parameters have been highlighted
    in the scripts. The initialisation should happen outside the loop so it is not
    modified during the course of the loop. The operation on the index should happen
    for every iteration so the loop moves in some direction. Therefore, this operation
    falls within the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Be a little careful with the while loop; you are more prone to getting an infinite
    loop, because it is easy to forget to add the starting point or the operation
    to move towards the stopping point.
  prefs: []
  type: TYPE_NORMAL
- en: Now to Mothers’ Day. We first get the date object for the 1^(st) of May for
    that year, so we can manipulate it using its members. This date is the starting
    point. We then specify the condition, 'keep the loop going if the day is not a
    Sunday.' Then, we add one day, every iteration. After every iteration, the variable
    is checked against the condition. Finally, when the first Sunday is encountered,
    the variable comes out of the loop. We then add a week to it to find the second
    Sunday, and output the long date version of the value of `$MothersDay`.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning empty directories using the Do–While construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, we found the second Sunday of May using the year as input.
    We used a While loop for that. The While loop checks the condition before even
    starting the iteration. If the condition returns $false at the very beginning,
    the loop would not even begin; for instance, if you input the year as `2016`.
  prefs: []
  type: TYPE_NORMAL
- en: Do–While is a little different; the loop is executed once whether the condition
    is true or not. The condition is checked only *after* the first iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The scenario for this recipe is that we want to delete all empty directories
    within a certain directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to work with this recipe, let us create a few empty directories within
    `$HOME/random`. Use the input file that is part of the git repository of this
    book to get the directories created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you run the following recipe within the `random` lab directory, all its empty
    subdirectories will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and paste the following content into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let us add some logging to it so we know what is happening.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c622064b-ee5e-4f8c-8898-3b6fcb535608.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The execution is similar to the While construct, however, as shown by `Iteration
    0`, the Do–While construct executes the script block once without checking the
    condition. In our case, we queried the empty directories within the loop. If we
    had placed this query outside of the loop, we would have had to place it within
    as well, for loop control. That is inefficient programming.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell found nine empty directories during the execution of the script block.
    When the condition check happened after the execution, `9` was evaluated to be
    greater than `0`. The loop ran again. This time, the value of `$EmptyDirectories.Count`
    was evaluated to be `4`. The loop ran again, and this time again, the value was
    `4`, greater than `0`; the condition was still `$true`. During the next run, `$EmptyDirectories.Count`
    was evaluated to be `2`, then `1`, and then, during the last run, `0`. At this
    time, the outcome of the condition became `$false`, and the loop exited. Essentially,
    the loop statement was, 'Go on *while* the count is *more than* zero.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe 5.7: Taking actions on the returned objects'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning empty directories using the Do–Until construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is easy to confuse between Do–While and Do–Until, since they both share
    a lot of similarities. However, the difference between them is in fact, pretty
    clear. The Do–While loop executes as long as the outcome of the condition check
    is `$true`, and exits the moment it becomes `$false`. Do–Until is the opposite:
    the loop continues as long as the condition check returns $false, and stops the
    moment it the condition check returns `$true`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us use the same scenario of cleaning up empty folders, but this time, use
    the Do–Until loop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would need to rerun the command to create those empty directories.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and paste the following content into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice the change in the behaviour this time and compare it with the run of
    Do–While.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/368f892a-96c9-4179-b2aa-56ae1c662904.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time, it was made evident in the interactive output how it works. The first
    run happened without checking for the condition. At the end of the run, the condition
    was checked for. `9` is greater than `0`, and not equal. The outcome was `$false`,
    so the loop continued. It went on this way until the count came down to `0` (making
    the outcome of the condition `$true`), at which point, the loop exited. Essentially,
    the loop statement was, 'Go on *until* the count *becomes* zero.'
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our chapter on flow control. I hope that you had a nice time
    learning the techniques, and that this chapter helps you with a good chunk of
    automation work you wish to carry out after learning to use PowerShell.
  prefs: []
  type: TYPE_NORMAL
