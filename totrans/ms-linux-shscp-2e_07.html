<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating Building Blocks with Functions</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will dive into the wonderful world of functions. We can look at these as modular building blocks creating powerful and adaptive scripts. By creating functions, we add the code in a single building block isolated from the rest of the script. Focusing on improvements of a single function is a lot easier than trying to improve the script as a single object. Without functions, it is difficult to hone in on problem areas and the code is often repeated, which means that updates need to happen in many locations. Functions are named as blocks of code or scripts within scripts and they can overcome many problems associated with more complex code.</p>
<p>As we make our way through the chapter, we will cover the following topics:</p>
<ul>
<li>Introducing functions</li>
<li>Passing parameters to functions</li>
<li>Variable scope</li>
<li>Returning values from functions</li>
<li>Recursive functions</li>
<li>Using functions in menus</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The source code for this chapter can be downloaded from here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter07">https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter07</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing functions</h1>
                </header>
            
            <article>
                
<p>Functions are blocks of code that exist in memory as <strong>named elements</strong>. These elements can be created within the shell environment, as well as within the script execution. When a command is issued at the command line, aliases are checked first and, following this, we check for a matching function name. To display the functions residing in your shell environment, you can use the following command:</p>
<pre><strong>$ declare -F</strong>  </pre>
<p>The output will vary depending on the distribution you are using and the number of functions you have created. On my Linux Mint, the partial output is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-115 image-border" src="assets/6d280f40-0bea-4847-81c0-5b1bf0377f89.png" style="width:38.50em;height:27.67em;"/></div>
<p>Using the small <kbd>-f</kbd> option, you can display the function and the associated definition. However, if we want to see just a single function definition, we can use the <kbd>type</kbd> command:</p>
<pre><strong>$ type quote</strong>  </pre>
<p>The previous code example will display the code block for the <kbd>quote</kbd> function, if it exists within your shell. We can see the output of this command in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-116 image-border" src="assets/6409e11b-7f72-454e-b4a9-2cc2aad5a3fe.png" style="width:20.67em;height:8.08em;"/></div>
<p>The <kbd>quote</kbd> function in bash inserts single quotes around a supplied input parameter. For example, we can expand the <kbd>USER</kbd> variable and display the value as a string literal; this is shown in the following screenshot. The screenshot captures the command and output:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-117 image-border" src="assets/bffd9d56-fb94-4d67-9ec6-0e7ba69d2192.png" style="width:20.75em;height:3.08em;"/></div>
<p>Most code can be represented by a pseudo-code which shows an example layout. Functions are no different and the code to create a function is listed in the following example:</p>
<pre>function-name() { 
&lt;code to execute&gt; 
} </pre>
<p>Also, there is another way of defining functions, like this:</p>
<pre>function &lt;function-name&gt; { 
&lt;code to execute&gt; 
} </pre>
<p>The <kbd>keyword</kbd> function is deprecated for portability with the <strong>Portable Operating System Interface</strong> (<strong>POSIX</strong>) specification, but it is still used by some developers.</p>
<div class="packt_infobox">Note that the <kbd>()</kbd> are not necessary when using the <kbd>keyword</kbd> function, but they are a must if you define the function without the <kbd>keyword</kbd> function.</div>
<p>The function is created without a <kbd>do</kbd> and <kbd>done</kbd> block, as we have used in the previous loops. It is the purpose of the curly brackets to define the code block boundaries.</p>
<p>A simple function to display aggregated system information is shown in the following code. This can be created at the command line and will be resident in your shell. This will not persist the logins and will be lost when the shell is closed or the function is unset. To allow the function to persist, we need to add this to the login script of our user account. The sample code is as follows:</p>
<pre><strong>$ show_system() {</strong>
<strong>echo "The uptime is:"</strong>
<strong>uptime</strong>
<strong>echo</strong>
<strong>echo "CPU Detail"</strong>
<strong>lscpu</strong>
<strong>echo</strong>
<strong>echo "User list"</strong>
<strong>who</strong>
<strong>}</strong>  </pre>
<p>We can print the detail of the function similar to the prior instance using the <kbd>type</kbd> command; this is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-118 image-border" src="assets/d9fabef5-8440-4b12-b440-2edcc07412ef.png" style="width:18.92em;height:14.08em;"/></div>
<p>To execute the function, we simply need to type <kbd>show_system</kbd> and we will see the static text and output from the three commands: <kbd>uptime</kbd>, <kbd>lscpu</kbd>, and <kbd>who</kbd>. This <span>is, </span><span>of course, a very simple function but we can start to add more functionality by allowing parameters to be passed at runtime.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing parameters to functions</h1>
                </header>
            
            <article>
                
<p>Earlier within this chapter, we referred to functions as scripts within scripts and we will still maintain that analogy. Similar to how a script can have input parameters, we can create functions that also accept parameters that can make their operation less static. Before we work on a script, we can look at a useful function in the command line.</p>
<div class="packt_tip"><span>One of my pet peeves is overcommented configuration files, especially where documentation exists to detail the options available.</span></div>
<p>The <strong>GNU's Not Unix</strong> (<strong>GNU</strong>) Linux <kbd>sed</kbd> <span>command </span>can easily edit the file for us and remove commented lines and empty lines. We are introducing the stream editor, <kbd>sed</kbd>, here but we will look at it in more detail in the following chapter.</p>
<p>The <kbd>sed</kbd> command line that runs the in-place edit will be as follows:</p>
<pre><strong>$ sed -i.bak '/^\s*#/d;/^$/d' &lt;filename&gt;</strong>  </pre>
<p>We can run out forensics in the command line by breaking it down element by element. Let's take a deeper look:</p>
<ul>
<li><kbd>sed -i.bak</kbd>: This edits the file and creates a backup with the extension <kbd>.bak</kbd>. The original file will then be accessible as <kbd>&lt;filename&gt;.bak</kbd>.</li>
<li><kbd>/^</kbd>: This caret character (<kbd>^</kbd>) means edit the lines that start with what after the caret. So the caret matches the beginning of a line.</li>
<li><kbd>\s*</kbd>: This means any amount of white space, including no spaces or tabs.</li>
<li><kbd>#/</kbd>: This is a normal <kbd>#</kbd> sign. So the total expression <kbd>^\s*#</kbd> means we are looking for lines that begin with comment or spaces and a comment.</li>
<li><kbd>d</kbd>: This is the delete action to remove matching lines.</li>
<li><kbd>;/^$/d</kbd>: The semicolon is used to separate expressions and the second expression is similar to the first but this time we are preparing to delete empty lines.</li>
</ul>
<p>To move this into a function, we will simply need to think of a great name. I like to build verbs into function names; it helps with the uniqueness and identifies the purpose of the function. We will create the <kbd>clean_file</kbd> function as follows:</p>
<pre><strong>$ function clean_file {</strong>
  <strong>sed -i.bak '/^\s*#/d;/^$/d' "$1"</strong>
<strong>}</strong>  </pre>
<p>As within scripts, we use positional parameters to accept command-line arguments. We can replace the hardcoded filename that we used previously with <kbd>$1</kbd> within the function. We will quote this variable to protect against spaces within the filename. To test the <kbd>clean_file</kbd> function, we will make a copy of a system file and work with the copy. In this way, we can be sure that no harm comes to any system file. We can assure all readers that no system files were harmed during the making of this book. The following are the detailed steps we need to follow to perform the test on the new function:</p>
<ol>
<li>Create the <kbd>clean_file</kbd> function as described</li>
<li>Move to your <kbd>home</kbd> directory using the <kbd>cd</kbd> command without arguments</li>
<li>Copy the time configuration file to your <kbd>home</kbd> directory <kbd>cp /etc/ntp.conf $HOME</kbd></li>
<li>Count the number of lines in the file with the following command: <kbd>wc -l $HOME/ntp.conf</kbd></li>
<li>Now remove the commented and empty lines with <kbd>clean_file $HOME/ntp.conf</kbd></li>
<li>Now recount the lines using <kbd>wc -l $HOME/ntp.conf</kbd></li>
<li>Also, check the count the backup of the original file that we created: <kbd>wc -l $HOME/ntp.conf.bak</kbd></li>
</ol>
<p class="mce-root">The sequence of commands is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-119 image-border" src="assets/f403ad2f-0f83-49c6-ad61-c45577a8042d.png" style="width:53.33em;height:12.67em;"/></div>
<p>We can direct the attention of the function to the required file using the argument that was supplied while executing the function. If we need to persist this function, then we should add it to a login script. However, if we want to test this within a shell script, we can create the following file to do this and practice some of the other elements we have learned. We will need to take notice that the functions should always be created at the start of the script as they need to be stored in memory by the time they are called. Just think that your function needs to be unlocked and loaded before you pull the trigger.</p>
<p>We will create a new shell script, <kbd>$HOME/bin/clean.sh</kbd>, and the execute permission, as always, will need to be set. The code of the script is as follows:</p>
<pre>#!/bin/bash 
# Script will prompt for filename 
# then remove commented and blank lines 
 
is_file() { 
    if [ ! -f "$1" ] ; then 
        echo "$1 does not seem to be a file" 
        exit 2 
    fi 
} 
 
clean_file() { 
    is_file "$1" 
    BEFORE=$(wc -l "$1") 
    echo "The file $1 starts with $BEFORE" 
    sed -i.bak '/^\s*#/d;/^$/d' "$1" 
    AFTER=$(wc -l "$1") 
    echo "The file $1 is now $AFTER" 
} 
 
read -p "Enter a file to clean: " 
clean_file "$REPLY" 
exit 1 </pre>
<p>We have provided two functions within the script. The first, <kbd>is_file</kbd>, simply tests to ensure that the filename we have entered is a regular file. Then we declare the <kbd>clean_file</kbd> function with a little added functionality, displaying the line count of the file before and after the operation. We can also see that functions can be nested and we call the <kbd>is_file</kbd> function with <kbd>clean_file</kbd>.</p>
<p>Without the function definitions, we have only three lines of code at the end of the file, which we can see in the example code laid out in the previous code block that has been saved as <kbd>$HOME/bin/clean.sh</kbd>. We first prompt for the filename and then run the <kbd>clean_file</kbd> function, which in turn calls the <kbd>is_file</kbd> function. The simplicity of the main code is important here. The complexity is in the functions, as each function can be worked on as a standalone unit.</p>
<p>We can now test the script operation, first using a wrong filename, as we can see in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-121 image-border" src="assets/b6df07e9-3208-43a8-9f26-b8cf9e0a4d6e.png" style="width:22.25em;height:5.92em;"/></div>
<p>Now that we have seen the operation with an incorrect file, we can try again using an actual file! We can use the same system file we worked on before. We need to first return the files to their original state:</p>
<pre><strong>$ cd $HOME</strong>
<strong>$ rm $HOME/ntp.conf</strong>
<strong>$ mv ntp.conf.bak ntp.conf</strong>  </pre>
<p>With the file now ready, we can execute the script from the <kbd>$HOME</kbd> directory as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-122 image-border" src="assets/6628efa2-505b-472e-a56a-a836aab2f329.png" style="width:23.75em;height:6.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing arrays</h1>
                </header>
            
            <article>
                
<p>Not all your passed values will be single values; you may need to pass an array to the function. Let's see how to pass an array as a parameter:</p>
<pre>#!/bin/bash 
myfunc() { 
   arr=$@ 
   echo "The array from inside the function: ${arr[*]}" 
} 
 
test_arr=(1 2 3) 
echo "The original array is: ${test_arr[*]}" 
myfunc ${test_arr[*]} </pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-505 image-border" src="assets/290b2825-016a-4ce3-9f8c-bb517a0f05f5.png" style="width:33.33em;height:7.58em;"/></div>
<p>From the result, you can see that the used array is returned the way it is from the function.</p>
<p>Note that we used <kbd>$@</kbd> to get the array inside the function. If you use <kbd>$1</kbd>, it will return the first array element only:</p>
<pre>#!/bin/bash 
myfunc() { 
   arr=$1 
   echo "The array from inside the function: ${arr[*]}" 
} 
 
my_arr=(5 10 15) 
echo "The original array: ${my_arr[*]}" 
myfunc ${my_arr[*]} </pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-504 image-border" src="assets/b4a129d6-1d1d-4e27-8ffc-b329a6b1b92e.png" style="width:34.83em;height:8.00em;"/></div>
<p>Because we used <kbd>$1</kbd>, it returns only the first array element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variable scope</h1>
                </header>
            
            <article>
                
<p>By default, any variable you declare inside a function is a global variable. That means this variable can be used outside and inside the function without problems.</p>
<p>Check out this example:</p>
<pre>#!/bin/bash 
myvar=10 
myfunc() { 
   myvar=50 
} 
myfunc 
echo $myvar 
 </pre>
<p>If you run this script, it will return <kbd>50</kbd>, which is the value changed inside the function.</p>
<p>What if you want to declare a variable that is exclusive to the function? This is called a local variable.</p>
<p>You can declare local variables by using the <kbd>local</kbd> command like this:</p>
<pre>myfunc() { 
   local myvar=10 
} </pre>
<p>To ensure that the variable is used only inside the function, let's check out the following example:</p>
<pre>#!/bin/bash 
myvar=30 
myfunc() { 
   local myvar=10 
} 
myfunc 
echo $myvar </pre>
<p>If you run this script, it will print <kbd>30</kbd>, which means that the local version of the variable is different than the global version.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Returning values from functions</h1>
                </header>
            
            <article>
                
<p>Whenever we have statements that are printed on the screen within the function, we can see their result. However, lots of times we will want the function to populate a variable within the script and not display anything. In this case, we use <kbd>return</kbd> in the function. This is especially important when we are gaining input from users. We may prefer the case to translate the input to a known case to make the condition testing easier. Embedding the code in a function allows it to be used many times within a script.</p>
<p>The following code shows how we can achieve this by creating the <kbd>to_lower</kbd> function:</p>
<pre>to_lower () 
{ 
    input="$1" 
    output=$( echo $input | tr [A-Z] [a-z]) 
return $output 
} </pre>
<p>Stepping through the code, we can begin to understand the operation of this function:</p>
<ul>
<li><kbd>input="$1"</kbd>: This is more for ease than anything else; we assign the first input parameter to a named variable input.</li>
<li><kbd>output=$( echo $input | tr [A-Z] [a-z])</kbd>: This is the main engine of the function, where the translation from uppercase to lowercase occurs. We pipe the input to the <kbd>tr</kbd> command to convert uppercase to lowercase.</li>
<li><kbd>return $output</kbd>: This is how we create the return value.</li>
</ul>
<p>One use of this function will be within a script that reads the user's input and simplifies the test to see whether they choose <kbd>Q</kbd> or <kbd>q</kbd>. This can be seen in the following extract of code:</p>
<pre>to_lower () 
{ 
    input="$1" 
    output=$( echo $input | tr [A-Z] [a-z]) 
return $output 
} 
 
while true 
do 
  read -p "Enter c to continue or q to exit: " 
  $REPLY=$(to_lower "$REPLY") 
  if [ $REPLY = "q" ] ; then 
    break 
  fi 
 
done 
echo "Finished" </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recursive functions</h1>
                </header>
            
            <article>
                
<p>A recursive function is a function that calls itself from inside itself. This function is very useful when you need to call the function to do something again from inside of it. The most famous example for that is calculating factorials.</p>
<p>To calculate the factorial of 4, you multiply the number by the descending numbers. You can do it like this:</p>
<pre>4! = 4*3*2*1</pre>
<p>The <kbd>!</kbd> sign means factorial.</p>
<p>Let's write a recursive function that calculates the factorial of any given number:</p>
<pre>#!/bin/bash 
calc_factorial() { 
if [ $1 -eq 1 ] 
then 
echo 1 
else 
local var=$(( $1 - 1 )) 
local res=$(calc_factorial $var) 
echo $(( $res * $1 )) 
fi 
} 
  
read -p "Enter a number: " val 
factorial=$(calc_factorial $val) 
echo "The factorial of $val is: $factorial" </pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-503 image-border" src="assets/0b71574b-6af6-4bb3-b2e7-7ba140b064f1.png" style="width:38.42em;height:11.83em;"/></div>
<p>First, we define the function which is called <kbd>calc_factorial</kbd> and inside it we check if the number equals 1 and if so, the function will return 1 because the factorial of 1 equals 1.</p>
<p>Then we decrement the number by one and call the function from inside it and that will call the function again.</p>
<p>This will continue to happen until it reaches 1 and then the function will exit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using functions in menus</h1>
                </header>
            
            <article>
                
<p>In <a href="a9bad548-8c76-4e5f-adb1-8cf4e6198c50.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Iterating with Loops</em>, we created the <kbd>menu.sh</kbd> file. Menus are great targets to use functions, as the <kbd>case</kbd> statement is maintained very simply with single-line entries, while the complexity can still be stored in each function. We should consider creating a function for each menu item. If we copy the previous <kbd>$HOME/bin/menu.sh</kbd> to <kbd>$HOME/bin/menu2.sh</kbd>, we can improve the functionality. The new menu should look like the following code:</p>
<pre>#!/bin/bash 
# Author: @likegeeks 
# Web: likegeeks.com 
# Sample menu with functions 
# Last Edited: April 2018 
 
to_lower() { 
    input="$1" 
    output=$( echo $input | tr [A-Z] [a-z]) 
return $output 
} 
 
do_backup() { 
    tar -czvf $HOME/backup.tgz ${HOME}/bin 
} 
 
show_cal() { 
    if [ -x /usr/bin/ncal ] ; then 
      command="/usr/bin/ncal -w" 
    else 
      command="/usr/bin/cal" 
    fi 
    $command 
} 
 
while true 
do 
  clear 
  echo "Choose an item: a, b or c" 
  echo "a: Backup" 
  echo "b: Display Calendar" 
  echo "c: Exit" 
  read -sn1 
  REPLY=$(to_lower "$REPLY") 
  case "$REPLY" in 
    a) do_backup;; 
    b) show_cal;; 
    c) exit 0;; 
  esac 
  read -n1 -p "Press any key to continue" 
done </pre>
<p>As we can see, we still maintain the simplicity of the <kbd>case</kbd> statement; however, we can develop the script to add in more complexity through the functions. For example, when choosing option <kbd>b</kbd> for the calendar, we now check to see whether the <kbd>ncal</kbd> command is available. If it is, we use <kbd>ncal</kbd> and use the <kbd>-w</kbd> option to print the week number. We can see this in the following screenshot, where we have chosen to display the calendar and install <kbd>ncal</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-126 image-border" src="assets/3aa8b650-4e05-4b77-bf93-1064c38aae86.png" style="width:19.50em;height:14.75em;"/></div>
<p>We can also not be concerned about the <em>Caps Lock</em> key as the <kbd>to_lower</kbd> function converts our selection to lowercase. Over time, it would be very easy to add additional elements to the functions, knowing that we only affect that single function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We are still making progress in leaps and bounds in script writing. I hope these ideas stay with you and you find the code examples useful. Functions are very important for the ease of maintenance of your scripts and their ultimate functionality. The easier the scripts are to maintain, the more likely you are to add improvements over time. We can define functions at the command line or within scripts but they need to be included in the script before they are used.</p>
<p>The functions themselves are loaded into memory while the script is running, but as long as the script is forked and not sourced, they will be released from memory once the script is finished. We have touched a little upon <kbd>sed</kbd> in this chapter and we will look more at using the stream editor (<kbd>sed</kbd>) in the next chapter. The <kbd>sed</kbd> command is very powerful and we can make good use of it within scripts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the printed value of the following code?</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
myfunc() { 
arr=$1 
echo "The array: ${arr[*]}" 
} 
 
my_arr=(1 2 3) 
myfunc ${my_arr[*]} </pre>
<ol start="2">
<li>What is the output of the following code?</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
myvar=50 
myfunc() { 
myvar=100 
} 
echo $myvar 
myfunc </pre>
<p style="padding-left: 60px"/>
<ol start="3">
<li>What is the problem with the following code? And how can you fix it?</li>
</ol>
<pre style="padding-left: 60px">clean_file { 
    is_file "$1" 
    BEFORE=$(wc -l "$1") 
    echo "The file $1 starts with $BEFORE" 
    sed -i.bak '/^\s*#/d;/^$/d' "$1" 
    AFTER=$(wc -l "$1") 
    echo "The file $1 is now $AFTER" 
} </pre>
<ol start="4">
<li>What is the problem with the following code? And how can you fix it?</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
myfunc() { 
arr=$@ 
echo "The array from inside the function: ${arr[*]}" 
} 
 
test_arr=(1 2 3) 
echo "The origianl array is: ${test_arr[*]}" 
myfunc (${test_arr[*]}) </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Please see the following for further reading relating to this chapter:</p>
<ul>
<li><a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-8.html"><span class="InternetLink">http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-8.html</span></a></li>
<li><a href="http://tldp.org/LDP/abs/html/functions.html"><span class="InternetLink">http://tldp.org/LDP/abs/html/functions.html</span></a></li>
<li><a href="https://likegeeks.com/bash-functions/"><span class="InternetLink">https://likegeeks.com/bash-functions/</span></a></li>
</ul>


            </article>

            
        </section>
    </body></html>