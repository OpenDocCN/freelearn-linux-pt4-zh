- en: Using Variables and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are discussing the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using environment variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Storing the output of an instance of a .NET Core object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating custom properties to an object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom object from a returned object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding extension of type data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retaining object modifications across sessions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing custom type data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables are important to programming since they act as containers of information
    stored during the program execution. Although piping makes PowerShell highly versatile,
    they still cannot replace variables, because objects passed through the pipeline
    must be consumed immediately, and not all scripts work that way, given our varied
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are all aware of the various data types: `int`, `double`, `string`, `char`,
    `array`, etc. Two other important types of variables in PowerShell are *hashtables*
    and *objects*. A hashtable is a dictionary table formed with key–value pairs.
    An object, as we have seen, could be as complex and as simple as it can get in
    PowerShell, holding values of different kinds.'
  prefs: []
  type: TYPE_NORMAL
- en: In PowerShell, objects can be stored into variables. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: would store all the processes into the variable, `$Processes`.
  prefs: []
  type: TYPE_NORMAL
- en: One more point to remember with variables is the scope. By default, variables
    have a local scope, meaning, they are valid within the function that they are
    specified in. Global variables are valid across the program. In general, it is
    a best practice to use local variables, though.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables are declared and used with the `$Global:` prefix, such as `$Global:MyVariable`.
  prefs: []
  type: TYPE_NORMAL
- en: Using environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about environment variables. When interacting
    with the system through a shell session, there are many pieces of information
    that the Shell requires in order to determine the program access, the available
    resources, default configuration, system properties, etc. Some of these settings
    are configured within the system as variables and these settings are commonly
    called the *EnvironmentVariables*.
  prefs: []
  type: TYPE_NORMAL
- en: While hard-coding this information during installation is one way to go, it
    makes the entire system a monolith that cannot be reconfigured without what is
    known as nuking-and-paving. With environment variables, another layer of flexibility
    is introduced.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us start working with an environment variable using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To Display environment variable, type in `Get-ChildItem env:` or `Get-Item env:`
    and press enter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Env:` is also a PowerShell provider, and works just like a file system. Therefore,
    you could also `Set-Location` at `Env:` and use `Get-ChildItem .` to list out
    the variables available in your system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display the value of the specific environment variable, run the following
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After typing `Get-ChildItem Env:/`,  You can use tab-completion to populate
    all environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Do a `Get-Member` on the `PATH` environment variable to find its type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before changing the environment variable, list the `PATH` variable using `$env:PATH
    | Get-Member`. It is a string. Save the contents someplace safe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, update the `PATH` environment variable by adding the path of `sqlcmd`
    tool executable to $`env: PATH` variable. The operation is a simple addition of
    a string to the existing value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could add any location to `PATH`. If you insist on getting `sqlcmd`, head
    over to [Microsoft docs](https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-setup-tools?view=sql-server-linux-2017) for
    SQL Server 2017 for instructions to get yourself a copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code block is illustrated in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e6b48cb-4403-4d84-aac1-56e43f0a78b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us exit the session, launch a new session,  check the `PATH` variable, and
    run the `sqlcmd` executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in *Listing the various providers in PowerShell*, `Env` is a provider
    that contains environment-specific configuration. Most of these configuration
    options are also exposed to us as environment variables. We are able to use the
    cmdlets `Get-ChildItem` and `Get-Item` to list the values of the available environment
    variables because `Env:` is a drive within the `Env` provider. As environment
    variables do not have child items, `Get-Item` and `Get-ChildItem` return the same
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Since these variables determine how your session behaves with you, changes made
    to these values are ephemeral. In other words, the value of `$env:PATH` is picked
    from the configuration on your Linux computer. The manual change made to `$env:PATH`
    made within a PowerShell session remains as long as the PowerShell session is
    alive. Changes made to $env:PATH does not change the value within the system itself.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to make a certain change permanent, edit the `.bashrc` or
    the **`~/.bash_profile` **configuration files. If you would like to use PowerShell
    instead of Bash, make the change in your PowerShell profile. Instructions on how
    to do that can be found in the recipe, *Enabling automated execution of commands
    for each load*, in the chapter, *Preparing for Administration using PowerShell*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also access environment variables using  .NET type accelerator and its
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'About Environment variables: `Get-Help about_Environment_Variables`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recipe 1.11: Listing the various providers in PowerShell'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recipe 3.4: Enabling automated execution of commands for each load'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Storing the output of an instance of a .NET Core Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET is object-oriented, and works on classes and objects. PowerShell, being
    an extension to this framework, allows you to work with the .NET framework and
    COM interfaces in order to perform many system administration tasks. This way,
    you are not limited only to the tasks that can be performed using cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will define a simple class from within PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We recommend using Visual Studio Code for this recipe. To know how to install
    and configure it, visit the recipe, *Installing Visual Studio Code* from the chapter, *Preparing
    for Administration using PowerShell*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launch Visual Studio Code and address any immediate requirements it asks for.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file in Visual Studio Code and set the file type as PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in the following in the script pane. The file does not have to be saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To find constructors of a class, call the static method, `New`; type in the
    following at the prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This gives us two functions of the same name; these are overload definitions.
    Now, create a new object by passing in the parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/6134d77a-3052-4d39-b0ba-c260b5982fd6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let us invoke the constructor the PowerShell way, which in turn calls the
    .NET constructor. This creates an instance of the Person class (which, by definition,
    is an object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To list the properties of the object (and by extension, the class), run the
    `Get-Member` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8daf5696-50c8-40ac-b1f9-a9114d7c13b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, Let us take a look at the other samples. Let us use system-defined class
    libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let us see another example of password encryption using `System.Management.Automation`
    class objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/6cb687d1-a002-45c1-917f-d2a18d39014e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal of this recipe is to demonstrate how PowerShell works hand-in-hand
    with .NET, and objects that are created the *.NET way* can be called (and stored)
    easily in PowerShell. First, we declare a class with the keyword, `class`. We
    then declare its parameters, and then, create two constructors: one default and
    one parameterised.'
  prefs: []
  type: TYPE_NORMAL
- en: We also create a method called `sal`. We define its return type as `int32`,
    and defined two parameters. Within it, we define what needs to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Back at the PowerShell prompt, we call the static (method of the class, not
    of an object) `New` method. The syntax is to mention the class name, followed
    by two consecutive colons (`::`) to call it in the global namespace, followed
    by the name of the method.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow the steps, you'll also see an example of using the two different
    system class libraries, `System.Net.Mail.SmtpClient` and `System.Net.Mail.MailMessage`,
    and the instantiation of a method by integrating the output of mail-message with
    the SMTP-client object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the system class library `System.Management.Automation.PSCredential`.
    In this example, we send some text to `ConvertTo-SecureString` which takes input
    as plain text and converts it to a secure string. Then, we pass the encrypted
    string to the `PSCrendital` system class to store the user name and the secure
    string into the `$Credentials` variable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe 3.1: Installing Visual Studio Code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding custom properties to an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell cmdlets are capable of allowing the administrators to work with most
    tasks. However, there are some situations where the returned objects don't satisfy
    the administrative needs of a certain script. In such situations, we may need
    to create our own custom objects based on the available .NET classes, or at least,
    add a custom property to the object.
  prefs: []
  type: TYPE_NORMAL
- en: While a string is an object of `System. String` type, the `Get-Process` cmdlet
    returns an object of type `System.Diagnostics.Process`, `Get-ChildItem` returns
    an object with the type `System.IO.FileInfo`, a custom-created object has the
    object type, `PSCustomObject`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now proceed to create a custom object.
  prefs: []
  type: TYPE_NORMAL
- en: To create a custom object, use `New-Object` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That was not of much use to us. Let us add a few properties into it, along with
    their values and store these values in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To add properties to an object, use the `Add-Member` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To remove a property from an object, use the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To access properties, you can use the member access operator (`.`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an object is straightforward. All you have to do is tell PowerShell
    that you are creating a custom object, by calling the `[psobject]` accelerator
    and specifying the properties you would like to add to the object. After the accelerator
    is called, we specify the names of the properties, and assign values to them.
    Records are added one at a time, using the hash literal notation (`Name = 'Prashanth'`).
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to confuse a hashtable with a PSObject at this stage, given that
    we use the hash literal notation when creating the object. Remember that they
    are very different from each other. We will get into the details of what a hashtable
    is in the chapter, *Arrays and Hashtables*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mention three properties in the custom object we have created: `Name`, `Title`
    and `Publisher`. If we would like to add additional properties in the future,
    we can simply use the `Add-Member` cmdlet, where we specify the object (we pass
    the object through the pipeline), we specify the name of the property, and assign
    a value to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a property is a little more complex, since we do not have a `Remove-Member`
    cmdlet, nor are the members we use in the step easily discoverable. For instance, `[PSCustomObject]
    | Get-Member` does not reveal `PsObject` being its member. We call the `Remove`
    method within the `Properties` object, which is within the `PSObject` object of
    the custom object we created. (So many objects!)
  prefs: []
  type: TYPE_NORMAL
- en: Accessing properties in an object is as simple as using the member access operator
    with the property name.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipe: Creating and initialising a simple hashtable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom object from a returned object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to create a custom object from scratch. In this recipe, we will
    use a returned object, and modify the returned object to create a custom object.
    When we look at loops, we will extend this capability to create versatile custom
    objects; in production environments, this capability can be used to do more!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to learning something is to simplify it. Therefore, we will select
    only one instance of an object and work with it.
  prefs: []
  type: TYPE_NORMAL
- en: Get all the processes, select only the name, ID, working set and the start time,
    pick the 5th process in the list, and assign it to a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let us say that we did not like the names of the properties in the object. Let
    us change the names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a42cf4a5-4cb5-4112-9157-fd017a8d4192.png)'
  prefs: []
  type: TYPE_IMG
- en: But that is not the sequence we specified. Let us get them in sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/609d4d23-847e-4300-9453-0071a046f302.png)'
  prefs: []
  type: TYPE_IMG
- en: Recreate the object with information on how long the process has been running
    for instead of when it was started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9708bd11-619f-45c9-8842-7aac2c1ac587.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a custom object (`$CustomProcess`) from an output
    object (`$Process`). The properties within `$Process` can be accessed using the
    member access operator. Values from `$Process` are treated as values for the properties
    in `$CustomObject`, however, the names in `$CustomObject` are different. In this
    recipe, we also used a calculated property, `RunningMins`.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to note here is that the outcome of this recipe can also
    be achieved using calculated properties along with `Select-Object`. However, in
    situations where object versatility is important and the number of instances of
    the objects is significantly larger, it is simpler to use a custom object. We
    will extend this capability in future chapters, after we learn to use looping
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: The other point to note is the use of the `[ordered]` accelerator. More often
    than not, the properties of custom objects do not appear in the sequence we mention
    them in. In this recipe, we separate the hash literal notation from the creation
    of the custom object. We first create an ordered hashtable with the property names
    as well as the property values, and then, specify the created hashtable for the
    `Property` parameter of the `New-Object` cmdlet to create the custom object with
    the properties showing in the sequence we want.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Creating .NET and COM Objects](https://docs.microsoft.com/en-us/powershell/scripting/getting-started/cookbooks/creating-.net-and-com-objects--new-object-?view=powershell-6)
    (Microsoft Docs)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding extension of Type Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipe, *Selecting columns from the output*, we used a hashtable to set
    the name and the expression for a custom-named column. Later, we also used a small
    calculation within the `Select-Object` statement to get a calculated output. If
    you tried to select the column by the new name, that would have worked, too. Technically,
    you have already extended the object. But what is type data anyway? And why do
    we need a recipe to extend it when we can work with `Select-Object`?
  prefs: []
  type: TYPE_NORMAL
- en: Going too deep into what type data is and how to work with them along with .NET
    classes and objects could potentially make the concept an "advanced" one. Historically,
    most of us learners have procrastinated learning "advanced" topics. Therefore,
    we will stick to the simple parts of it, and work only with PowerShell for now.
    This recipe will serve as a launchpad to help you understand what it is by making
    it simple and fun, keeping it away from anything "advanced", in the interest of
    learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options to extend the type data:'
  prefs: []
  type: TYPE_NORMAL
- en: Using PowerShell cmdlets (to understand how it all works)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using an XML file (for portability)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand what we are talking about, here, you need to have read the following
    recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting columns from the output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom object from a returned object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us come back to the question: Why extend type data when we can use `Select-Object`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Efficiency. While you could change the name, add a calculation, and reference
    the calculated property with the new name, that change would have existed only
    in that context. If you added it to a variable,  as in the last recipe, *Creating
    a custom object from a returned object*, where we did some nifty changes to the
    names and also created a custom `NoteProperty`, that would be a long way to go
    about it. Enter: extension of type data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule of the thumb is,  If you do something repetitively, there''s an issue:
    you haven''t considered automating it. For example,  if you run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: and you do it fifteen times a day, you should consider extending the object
    to give you what you care about.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigate to the location where you created files for lab usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, add a property to the variable, `$FilesWithAge`; the property should be
    the age of each file, in days.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Add another property to it, called `ComputerName`, which is the name of your
    local host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Add another property, as an alias to `LastWriteTime`, called `Modified`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To format it like a nice table, use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8be1b9ba-03be-4dd0-825e-63cb802c0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, delete the variable. And query the files within the current directory (because
    that is what the variable actually held).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You do not see the `Age`, the `ComputerName` or the `Modified` properties. Try `Get-Member`
    if you would like.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see how to extend the type data itself, so that every time you run
    `Get-ChildItem`, you also get the three properties we added to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Get what object is returned when you run `Get-ChildItem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You get `System.IO.DirectoryInfo` as well as `System.IO.FileInfo`. We pick `System.IO.FileInfo`.
    Run the following commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Query the contents of the current location and optionally, format the output
    like a table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c5b3b81f-1763-4c48-8193-e924941e8b58.png)'
  prefs: []
  type: TYPE_IMG
- en: Do the same for any directory in the file system, the only condition being that
    the directory should contain at least one file, and not just more directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first section, we added members to the objects within a certain variable.
    This was a command-line-prompt-style extension to the recipe, *Creating a custom
    object from a returned object*, which was, by all means, a little more efficient
    in the context. However, the changes we made to the object remained only while
    the variable, `$FilesWithAge`, was valid. The object returned by `Get-ChildItem`
    was not modified at all.
  prefs: []
  type: TYPE_NORMAL
- en: There is an important point to note here: `$this`. We have come across the automatic
    variable, `$_` (or `$PSItem` after PowerShell V3) when dealing with objects passed
    through the pipeline; the variable holds the current instance of the object in
    the pipeline. However, when we have to perform an object extension, we use the
    automatic variable, `$this`. Why? Because, the property being referred to is being
    referred *within* the parent object (the object returned by `Get-ChildItem`).
    External methods would be able to use `$_`. In a way, `$_` does not even exist
    yet, when performing the member addition. Also, `$this` in fact, refers to the
    object itself, that is returned by `Get-ChildItem`, and not just an instance of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we would like to get a member as part of the object itself, throughout
    the session, irrespective of the validity of a certain variable or the object
    instance, we *extend the type data itself*. Therefore, no matter what context
    you run the cmdlet in, you would get the additional members you added. Of course,
    the formatting rules in PowerShell may still not let those members appear in the
    output by default. You can always call the specific members, though, such as using
    `Select-Object` for properties, or simply using the member access operator on
    the properties: `(Get-ChildItem .).Age`.'
  prefs: []
  type: TYPE_NORMAL
- en: For this, we use the `Update-TypeData` cmdlet. `Update-TypeData`, in this context,
    requires the `TypeName`, which as we have already seen, can be determined using
    `Get-Member` on the returned object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mention four things in the `Update-TypeData` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: The type name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The member type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The member name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The member value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Member type accepts several values, of which we use three:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AliasProperty`, which is simply a reference to another member within the object.
    The new property is just another name to an existing property. Therefore, the
    `Value` parameter can just take the name of the existing member.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NoteProperty`, which is a static value. In our case, we can use the host name
    as the static value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ScriptProperty`, which is essentially a calculation. We calculate the time
    span between the date when it was last modified and the current date. This calculation
    is the `Value` for the member, and accepts a script block.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This modification to the object would be valid as long as the session is valid;
    the change is not persistent across sessions. That brings us to the next recipe,
    making object modifications stick across sessions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe 5.1: Selecting columns from the output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retaining object modifications across sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, Understanding extension of Type Data, we used the `Update-TypeData`
    cmdlet to add members. However, we said that the update was valid as long as the
    session was. Now, there could be two ways by which to make the type data stick
    across sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the PowerShell profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using an XML file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PowerShell profile is straightforward. However, usually, the type data extension
    and formatting rules are packaged as part of PowerShell modules. And adding code
    to the profile is not particularly helpful in that case. In this recipe, we will
    write a simple XML (`.ps1xml`) file that we will load in order to extend the type
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Restart your PowerShell session so that the custom data type extension is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need an XML file. You can either use the `New-Item` cmdlet to create one,
    or simply use your favourite text editor. We use Visual Studio Code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Open your text editor and create a new empty file, and save it as `CustomTypes.ps1xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following content to the XML file. Ensure not to change the case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Save the file at a convenient location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back at the Terminal (or the PowerShell Integrated Console), enter the following
    command to update the type data using the XML. Notice the `PrependPath` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, list out all the files within any directory of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You should see the new properties that you created.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc352f31-1676-4f6f-b492-31380f2aa080.png)'
  prefs: []
  type: TYPE_IMG
- en: It is advised to never modify the PS1XML files in the `$PSHome` directory. They
    are digitally signed by Microsoft and could be replaced with new versions during
    upgrades or patches.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom types and formats are mostly used while creating custom modules. Rarely
    do administrators require modifying the types or formats for stock PowerShell
    modules. And when you do require modifying custom types or formats, create a new
    PS1XML; do not modify the stock files, since they are digitally signed, and modifying
    them would break your setup.
  prefs: []
  type: TYPE_NORMAL
- en: Think of this PS1XML file as a regular XML file. Here is a simpler way of showing
    the structure. Remember that each type and each of the members within, must have
    a name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In essence, using the XML for type extension is not very different from how
    we performed type extension in the last recipe, except this uses an XML file,
    which makes the setup more portable. When we work on creating our custom modules,
    we will look at packaging the types along with the modules, and at that time,
    we will look in detail, how to work the paths. For now, we load the XML by manually
    specifying the exact path to the file. If you would like to load these custom
    types for every session of yours, you can easily call the PS1XML from your profile.
    The portability aspect here is that the XML can easily be shared or deployed;
    only the loading would be manual, or through the profile—much simpler than adding
    cmdlets to profiles.
  prefs: []
  type: TYPE_NORMAL
- en: When updating the type data using cmdlets, we used the parameters `Name` as
    well as `Value`, along with the `MemberType` parameter. PowerShell understood
    the context and set up the types accordingly. In case of XML, though, one must
    remember to use the correct tags for each of the member types. For instance, for
    `AliasProperty`, the tags within should be `Name` and `ReferencedMemberName` (shown
    below); for `ScriptProperty`, they should be `Name` and `GetScriptBlock`; for
    a `NoteProperty`, the tags would be `Name` and `Value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, remember *not* to enclose the entire script block in braces when placing
    the statement within the `GetScriptBlock` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'and not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When loading the XML, we use the `PrependPath` parameter to load our XML *before*
    the built-in types are loaded. To load them after the built-in types, there is
    no need to use the `AppendPath` parameter, unless the situation really needs it,
    since `AppendPath` is the default. Why do the parameters matter? They determine
    the precedence of loading the types.
  prefs: []
  type: TYPE_NORMAL
- en: The XML file shown may *look like* having a large number of items. Use the indent
    guide in Visual Studio Code to guide you through reading the XML. The file, in
    reality, is very simple to read. And reading it will help you understand how the
    properties are defined.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[The Update-TypeData cmdlet](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/update-typedata?view=powershell-6)
    (Microsoft Docs)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Types.ps1xml file](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_types.ps1xml?view=powershell-6)
    (Microsoft Docs)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing custom type data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to create and update type data, the next step for us is
    to learn to remove the type data. And removing the type data requires us to get
    the type data first. In this recipe, we learn the process to remove type data;
    whether it was updated using cmdlets or an XML.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to understand that a cmdlet can output one or more types of
    objects. For instance, in our case, `Get-ChildItem` output `System.IO.DirectoryInfo`
    as well as `System.IO.FileInfo`. Let us learn to work with these guys.
  prefs: []
  type: TYPE_NORMAL
- en: Get the type of the object returned by the cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There are two types returned. We created the custom members in the second type.
    Assign this to a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Get the type data information. Expand its members to see if the custom members
    are shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/cebc3c44-9586-4735-8b2e-b76d90b35c56.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, remove the type data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process is straightforward. If you query the help information for the `TypeName`
    parameter of `Remove-TypeData`, you would notice that it accepts the type name
    accepts input via the pipeline by property value as well as the property name.
    Recall the recipe, *Understanding pipeline-enabled parameters*, and look at the
    object returned by `Get-TypeData`, for more insight.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Remove-TypeData` cmdlet removes the type data from the current session.
    This removal is as ephemeral as the type addition is. Therefore, the *default*
    types and formats are not permanently removed by the cmdlet; the reason why you
    can run this within PowerShell, without administrator privileges. Also remember
    that the underlying XML *files* are not deleted either: custom or stock.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipe 5.8: Understanding pipeline-enabled parameters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That concludes the chapter. It is time to take a break, so it helps you assimilate
    what you learnt. Later, experiment with different data types, create variables,
    see what type of objects they contain, and what members each object contains.
    We did not explicitly talk much about variables in this chapter other than environment
    variables, but we used variables almost in every recipe in the chapter. Ponder
    over (or better yet, practically try out) these questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What can be assigned to a variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the variable contain; the entire object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can I refer to one single property of the object that a variable contains, if
    at all it contains the entire object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can I assign a certain member and not the entire object to a variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What if the member is a whole object in itself? (Hint: Use `Get-Member` on
    the variable to find out.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when I use `Select-Object` with `-ExpandProperty` and assign the
    value to a variable? What type is the variable then?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That would help you understand more about the variables, now that you have used
    them so much.
  prefs: []
  type: TYPE_NORMAL
