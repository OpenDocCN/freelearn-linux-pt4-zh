- en: Chapter 2. Ultrasonic Parking Assistant
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。超声波停车助手
- en: In this chapter, we'll learn how to use the BeagleBone Black to implement a
    park assistant. We're going to use an ultrasonic sensor to detect the distance
    between our car and the garage wall, and some LEDs to give a feedback of the car
    position to the driver in order to avoid collisions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 BeagleBone Black 来实现停车辅助系统。我们将使用超声波传感器来检测汽车与车库墙壁之间的距离，并通过一些 LED
    向驾驶员反馈汽车的位置，以避免碰撞。
- en: We'll see how to set up the ultrasonic range sensor in two different manners,
    using different interfaces to get the data in order to resolve a problem in two
    different ways and obtain two different system configurations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何通过两种不同的方式设置超声波传感器，使用不同的接口来获取数据，以便用两种不同的方法解决问题并获得两种不同的系统配置。
- en: The basic of functioning
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本工作原理
- en: 'The project is really simple, even if it needs some electronic skills in order
    to manage the sensor output. Basically, our BeagleBone Black just needs to periodically
    poll the ultrasonic sensor output and then turn on the LEDs according to the distance
    from the wall: as level indicator lower is the distance and more LEDs are turned
    on.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目非常简单，尽管它需要一些电子技能来管理传感器输出。基本上，我们的 BeagleBone Black 只需要定期轮询超声波传感器的输出，然后根据与墙壁的距离点亮
    LED：距离越短，点亮的 LED 就越多。
- en: Setting up the hardware
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置硬件
- en: 'As just stated, in this project we''re trying to implement two different setups:
    the first one uses the analog output of the ultrasonic sensor and implements a
    circuitry, where all the devices are directly connected with the BeagleBone Black
    (all peripherals are near the board); on the other hand, the second setup allows
    us to remotely manage the ultrasonic sensor by using an USB connection, so we
    can mount the sensor far from the BeagleBone Black board.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所说，在这个项目中，我们尝试实现两种不同的设置：第一种使用超声波传感器的模拟输出并实现电路设计，所有设备都直接连接到 BeagleBone Black（所有外设都靠近主板）；而第二种设置则允许我们通过
    USB 连接远程管理超声波传感器，因此可以将传感器安装在离 BeagleBone Black 主板较远的地方。
- en: 'Simply speaking, we can put the sensor in one place while the LEDs are in a
    different location, maybe in a more visible position, as shown in the following
    image:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以将传感器放在一个地方，而 LED 灯则放在另一个地方，可能放在一个更显眼的位置，如下图所示：
- en: '![Setting up the hardware](img/B00255_02_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![设置硬件](img/B00255_02_01.jpg)'
- en: As you can see, the dotted arrow, which represents the driver's point of view,
    is more clear if the LEDs are in a upper position with respect to the distance
    sensor that should be located near to the floor to better catch the car frontal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，表示驱动视角的虚线箭头，如果 LED 灯位于距离传感器的上方，更容易看清，而传感器应放置在离地面较近的位置，以便更好地捕捉到汽车的前部。
- en: First setup – all devices near the BeagleBone Black
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首次设置 – 所有设备放置在 BeagleBone Black 附近
- en: In this setup, we're going to use an ADC pin of our BeagleBone Black to read
    the analog output of the ultrasonic sensor.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设置中，我们将使用 BeagleBone Black 的一个 ADC 引脚来读取超声波传感器的模拟输出。
- en: Using the analog output of the distance sensor
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用距离传感器的模拟输出
- en: 'The following image shows the ultrasonic sensor that I used on my prototype:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了我在原型中使用的超声波传感器：
- en: '![Using the analog output of the distance sensor](img/B00255_02_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![使用距离传感器的模拟输出](img/B00255_02_02.jpg)'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The devices can be purchased at the following link (or by surfing the Internet):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设备可以通过以下链接购买（或通过上网查找）：
- en: '[http://www.cosino.io/product/ultrasonic-distance-sensor](http://www.cosino.io/product/ultrasonic-distance-sensor).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.cosino.io/product/ultrasonic-distance-sensor](http://www.cosino.io/product/ultrasonic-distance-sensor)。'
- en: The datasheet of this device is available at [http://www.maxbotix.com/documents/XL-MaxSonar-EZ_Datasheet.pdf](http://www.maxbotix.com/documents/XL-MaxSonar-EZ_Datasheet.pdf).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备的数据手册可以在 [http://www.maxbotix.com/documents/XL-MaxSonar-EZ_Datasheet.pdf](http://www.maxbotix.com/documents/XL-MaxSonar-EZ_Datasheet.pdf)
    上找到。
- en: This device is really interesting due to the fact it has several output channels
    useful to retrieve the measured distance. In particular, it can give us the measurement
    via an analog voltage channel and via a serial port; the former communication
    channel is used in this setup, while the latter will be discussed in the second
    setup.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备非常有趣，因为它具有多个输出通道，可以用于获取测量的距离。特别是，它可以通过模拟电压通道和串口给出测量值；前者用于这个设置，后者将在第二个设置中讨论。
- en: 'Looking into the datasheet, we discover that the analog output has a resolution
    of *Vcc/1024 per cm* with a maximum reported range of ~700 mm at 5V and ~600 cm
    at 3.3V. In this setup, we use Vcc set to 3.3V so the maximum output voltage (**VoutMAX**)
    will result as:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅数据手册后，我们发现模拟输出的分辨率为 *Vcc/1024 每厘米*，在5V下最大有效范围约为700毫米，在3.3V下约为600厘米。在这个设置中，我们使用Vcc设置为3.3V，因此最大输出电压（**VoutMAX**）将为：
- en: '*VoutMAX = 3.3V / 1024 * 600 ≈ 1.93V*'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VoutMAX = 3.3V / 1024 * 600 ≈ 1.93V*'
- en: 'Remembering that the BeagleBone Black''s ADCs have a maximum input voltage
    of 1.8V, we have to find a way to scale down this value. A *quick and dirty* trick
    is to use a classic voltage divider, as shown in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 BeagleBone Black 的 ADC 最大输入电压为 1.8V，我们必须找到一种方法来缩小这个值。一个 *快速而简单* 的技巧是使用经典的电压分压器，如下图所示：
- en: '![Using the analog output of the distance sensor](img/B00255_02_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![使用距离传感器的模拟输出](img/B00255_02_03.jpg)'
- en: 'By using the preceding circuit, we simply divide the sensor output by 2\. The
    voltage at ADC in pin is given by the following formula:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述电路，我们只需将传感器输出除以2。ADC 输入引脚的电压可以通过以下公式计算：
- en: '*V[ADCin]* *= R / (R + R) * Vout = R / 2 R * Vout = 1 / 2 * Vout*'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*V[ADCin]* *= R / (R + R) * Vout = R / 2 R * Vout = 1 / 2 * Vout*'
- en: So, the only thing to do is to choose a suitable value for the two resistors
    (**R**). In my prototype, I set this value to *R=6.8KΩ*, which is a reasonable
    value to have to acquire a suitable current flooding out from the sensor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，唯一需要做的就是为两个电阻（**R**）选择一个合适的值。在我的原型中，我将这个值设置为 *R=6.8KΩ*，这是一个合理的值，可以从传感器获得适当的电流。
- en: 'In this situation, our resolution becomes ~1.61mV/cm, and the connections to
    be done on the BeagleBone Black are shown in the following table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的分辨率变为约1.61mV/厘米，连接到 BeagleBone Black 的接线如下面的表格所示：
- en: '| Pin | Distance sensor pin (label) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | 距离传感器引脚（标签） |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| P9.1 - GND | 7 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| P9.1 - GND | 7 |'
- en: '| P9.3 - 3.3V | 6 (Vcc) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| P9.3 - 3.3V | 6 (Vcc) |'
- en: '| P9.39 - AIN0 | 3 (AN) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| P9.39 - AIN0 | 3 (AN) |'
- en: 'Now, to enable the BeagleBone Black''s ADC lines, we can use the following
    command as we already did in [Chapter 1](ch01.html "Chapter 1. Dangerous Gas Sensors"),
    *Dangerous Gas Sensors*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了启用 BeagleBone Black 的 ADC 引脚，我们可以像在[第1章](ch01.html "第1章. 危险气体传感器")中一样使用以下命令，*危险气体传感器*：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If everything works well, we should get the following kernel messages:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们应该看到以下内核信息：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, the `AIN0`, `AIN1`, …, `AIN7` files should become available, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`AIN0`、`AIN1`、…、`AIN7` 文件应该可以访问，如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'These settings can be done by using the `bin/load_firmware.sh` script in the
    book''s example code repository, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置可以通过使用书中示例代码仓库中的 `bin/load_firmware.sh` 脚本完成，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we can read the input data by using the `cat` command, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `cat` 命令读取输入数据，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'As already stated in [Chapter 1](ch01.html "Chapter 1. Dangerous Gas Sensors"),
    *Dangerous Gas Sensors*, the ADC can also be read by using another file''s still
    into the *sysfs* filesystem with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](ch01.html "第1章. 危险气体传感器")中所述，*危险气体传感器*，ADC 也可以通过使用另一个文件仍然位于 *sysfs*
    文件系统中来读取，使用以下命令：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we have to find a way to convert the read values from the ADC into a distance
    measured in meters so that we can decide how to manage the LEDs to give the feedback
    to the driver. Recalling what was just said, the resolution is ~1.61mV/cm, and
    considering that the resolution of the ADC is 12 bits and the maximum voltage
    is 3.3V, the **distance** (**d**) in centimeters between the car and the wall
    is given by the following formula (where the value *n* is the data read from the
    ADC):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须找到一种方法，将从 ADC 读取的值转换为以米为单位的距离，这样我们就能决定如何管理 LED 来给驾驶员提供反馈。回想一下前面提到的，分辨率约为1.61mV/厘米，并且考虑到
    ADC 的分辨率为12位，最大电压为3.3V，**距离**（**d**）与汽车和墙壁之间的厘米数可以通过以下公式给出（其中 *n* 是从 ADC 读取的数据）：
- en: '*d = 3.3V * n / 4095 / 0.00161V/cm*'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d = 3.3V * n / 4095 / 0.00161V/厘米*'
- en: 'Note that these are estimated values, so it is better to do a calibration of
    the sensor in order to have the correct reads at least near the lowest value that
    we wish to measure (in our example, this value is 0.20 m.) To do this, we can
    put something at 20 cm from the sensor, measure the output value from the ADC,
    and then calculate a compensating value *K* in order that the following formula
    will return exactly the value 20:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些是估计值，因此最好对传感器进行校准，以便至少在我们希望测量的最低值附近得到正确的读数（在我们的例子中，这个值是 0.20 米）。为此，我们可以将物体放置在距离传感器
    20 厘米的位置，测量 ADC 输出值，然后计算补偿值 *K*，使得以下公式能够精确返回 20：
- en: '*d[calib] = K * 3.3V * n/4095 / 0.00161V/cm*'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d[calib] = K * 3.3V * n/4095 / 0.00161V/cm*'
- en: Note that in case of no calibration, *K* can be set to `1` (In this case, we
    obtain again the original formula, *d = d[calib]*.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在没有校准的情况下，*K* 可以设置为 `1`（在这种情况下，我们再次得到原始公式，*d = d[calib]*。）
- en: 'On my prototype, putting an object at 20 cm from the sensor, I get the following
    value:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的原型中，将物体放置在距离传感器 20 厘米的位置时，我得到了以下值：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, *K* should be set to `1.38`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，*K* 应设置为 `1.38`。
- en: Connecting the LEDs in the first setup
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一次设置中的 LED 连接
- en: 'The LEDs'' connections are very simple since they can be directly connected
    with the BeagleBone Black''s GPIO pins, as shown the following diagram, which
    shows the schematic of one single LED connection that can be replicated for each
    LED:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: LED 的连接非常简单，因为它们可以直接连接到 BeagleBone Black 的 GPIO 引脚，以下是电路图，显示了单个 LED 连接的示意图，可以为每个
    LED 复制：
- en: '![Connecting the LEDs in the first setup](img/B00255_02_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![第一次设置中的 LED 连接](img/B00255_02_04.jpg)'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I used an *R = 470Ω* resistor for the **LED** (**L**). Again, as in the previous
    chapter, let's remember that the resistor value **R** should be changed according
    to LED color if we wish to have a lighter effect.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个 *R = 470Ω* 的电阻来连接 **LED**（**L**）。同样，如前一章所述，我们需要记住，电阻值 **R** 应根据 LED 的颜色进行调整，如果我们希望达到更亮的效果。
- en: 'We have 5 LEDs, so we need 5 GPIO lines. We can use the following connections:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 5 个 LED，因此需要 5 根 GPIO 引脚。我们可以使用以下连接：
- en: '| Pin | LED color | Activated when distance is under |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | LED 颜色 | 当距离低于时激活 |'
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| P8.45-GPIO44 | White | 5.00 m |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| P8.45-GPIO44 | 白色 | 5.00 米 |'
- en: '| P8.46-GPIO67 | Yellow | 2.00 m |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| P8.46-GPIO67 | 黄色 | 2.00 米 |'
- en: '| P8.7-GPIO69 | Red | 1.00 m |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| P8.7-GPIO69 | 红色 | 1.00 米 |'
- en: '| P8.8-GPIO68 | Red | 0.50 m |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| P8.8-GPIO68 | 红色 | 0.50 米 |'
- en: '| P8.9-GPIO45 | Red | 0.20 m |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| P8.9-GPIO45 | 红色 | 0.20 米 |'
- en: The white LED is used to signal to the user that they are driving at less than
    5 m from the wall; the yellow is used to signal that they are driving at less
    than 2 m from the wall; and the red LED is used to signal that the garage wall
    is approaching at less than 1 m, 0.50 m, and 0.20 m.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 白色 LED 用来提示用户距离墙壁小于 5 米；黄色 LED 用来提示距离墙壁小于 2 米；红色 LED 用来提示车库墙壁距离小于 1 米、0.50 米和
    0.20 米。
- en: 'To test the LEDs'' connection, we can use the same commands used in [Chapter
    1](ch01.html "Chapter 1. Dangerous Gas Sensors"), *Dangerous Gas Sensors*. For
    instance, we can test the LED on GPIO68 by using the following commands to set
    up the GPIO first and then to turn it off and on:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 LED 的连接，我们可以使用与[第1章](ch01.html "第1章. 危险气体传感器")中相同的命令，*危险气体传感器*。例如，我们可以通过以下命令测试
    GPIO68 上的 LED，首先设置 GPIO，然后将其关闭再打开：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Second setup – the distance sensor is remotized
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二次设置 – 距离传感器远程化
- en: In this setup, we're going to use BeagleBone Black's serial port to read the
    measured distance from the ultrasonic sensor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置中，我们将使用 BeagleBone Black 的串行端口读取超声波传感器测得的距离。
- en: Using the serial output of the distance sensor
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用距离传感器的串行输出
- en: 'This time, we are interested at the datasheet section where the serial output
    capability of our sensor is described. In particular, we read:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们关注的是数据表中描述传感器串行输出能力的部分。特别是，我们读到：
- en: '*The Pin 5 output delivers asynchronous serial with an RS232 format, except
    voltages are 0-Vcc. The output is an ASCII capital "R", followed by three ASCII
    character digits representing the range in centimeters up to a maximum of 765,
    followed by a carriage return (ASCII 13). The baud rate is 9600, 8 bits, no parity,
    with one stop bit. Although the voltage of 0-Vcc is outside the RS232 standard,
    most RS232 devices have sufficient margin to read 0-Vcc serial data. If standard
    voltage level RS232 is desired, invert, and connect an RS232 converter.*'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*第 5 引脚输出异步串行 RS232 格式，除了电压是 0-Vcc。输出是 ASCII 大写字母 "R"，后跟三个 ASCII 数字字符，表示最大
    765 厘米的测量范围，最后是回车符（ASCII 13）。波特率为 9600，8 位，无奇偶校验，1 个停止位。虽然 0-Vcc 的电压超出了 RS232
    标准，但大多数 RS232 设备有足够的裕度来读取 0-Vcc 串行数据。如果需要标准电压级别的 RS232，请反转并连接 RS232 转换器。*'
- en: 'This is very interesting for two main reasons:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有趣，主要有两个原因：
- en: The measurement is very precise due to the fact that the sensor gives it to
    us in a digital format and not by using an analog format (so the measurement is
    more immune to disturbs.)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于传感器以数字格式提供数据，而非模拟格式（因此测量对干扰更具免疫力），测量非常精确。
- en: The information can be sent over a **RS-232** line (even if with some electronic
    fixes that will be presented soon), which will allow us to have the system core
    in a different location with respect to the sensor, providing a better usability
    of the whole system.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信息可以通过 **RS-232** 线路发送（即使需要一些即将介绍的电子修正），这将允许我们将系统核心放置在与传感器不同的位置，从而提高整个系统的可用性。
- en: So, by using this new setup, the LEDs are still mounted on the BeagleBone Black,
    while the distance sensor is connected remotely through a RS-232 line. However,
    we cannot use a classic RS-232 line due to the fact that we still have to supply
    power to the sensor, and no power can be transferred via a standard RS-232 cable!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，通过使用这种新的设置，LED 仍然安装在 BeagleBone Black 上，而距离传感器则通过 RS-232 线路远程连接。然而，由于我们仍然需要为传感器供电，并且标准的
    RS-232 电缆无法传输电源，因此我们无法使用经典的 RS-232 线路！
- en: The solution is to use a RS-232 connection over a USB cable. In fact, by using
    a standard USB cable, we are able to send/receive RS-232 data with the needed
    power supply.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是通过 USB 电缆使用 RS-232 连接。实际上，使用标准的 USB 电缆，我们能够发送/接收 RS-232 数据并提供所需的电源。
- en: 'However, some issues are still present:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然存在一些问题：
- en: The USB power voltage is 5V, so we need a *USB-to-serial* converter that can
    manage such voltage level by default, or, is at least 5V tolerant.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USB 的电源电压为 5V，因此我们需要一个能够默认管理此电压级别的 *USB-to-serial* 转换器，或者至少能够耐受 5V。
- en: Reading carefully the preceding snippet of the datasheet, we discover that the
    output level is TLL and inverted! So, before sending the TX signal to the *USB-to-serial*
    converter (to the RX pin), we must electrically invert it. (Okay don't panic!
    I'm going to explain this carefully.)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认真阅读数据手册中的前一段，我们发现输出电平是 TTL 并且是反向的！因此，在将 TX 信号发送到 *USB-to-serial* 转换器（连接到 RX
    引脚）之前，我们必须将其电气反向。（别担心，我会详细解释的。）
- en: The solution for the first problem is to use the following *USB-to-serial* converter,
    which not only works at 3.3V, but also is 5V tolerant.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题的解决方案是使用以下 *USB-to-serial* 转换器，该转换器不仅支持 3.3V 工作，还能耐受 5V。
- en: '![Using the serial output of the distance sensor](img/B00255_02_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用距离传感器的串行输出](img/B00255_02_05.jpg)'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The devices can be purchased at the following link (or by surfing the Internet):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备可以通过以下链接（或在互联网上搜索）购买：
- en: '[http://www.cosino.io/product/usb-to-serial-converter](http://www.cosino.io/product/usb-to-serial-converter).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.cosino.io/product/usb-to-serial-converter](http://www.cosino.io/product/usb-to-serial-converter)'
- en: The datasheet of this device is available at [https://www.silabs.com/Support%20Documents/TechnicalDocs/cp2104.pdf](https://www.silabs.com/Support%20Documents/TechnicalDocs/cp2104.pdf).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备的数据手册可以在 [https://www.silabs.com/Support%20Documents/TechnicalDocs/cp2104.pdf](https://www.silabs.com/Support%20Documents/TechnicalDocs/cp2104.pdf)
    获取。
- en: 'In order to address the second problem, we can use the following circuitry
    to invert the TTL levels of the TX signal of the sensor:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第二个问题，我们可以使用以下电路来反转传感器 TX 信号的 TTL 电平：
- en: '![Using the serial output of the distance sensor](img/B00255_02_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用距离传感器的串行输出](img/B00255_02_06.jpg)'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I used the resistors values **R1**=2,2KΩ, **R2**=10KΩ, and a **BC546 transistor**
    (**T**). The **Vin** is connected with the sensor's pin 5 (TX), while the **Vout**
    is connected with the **RX** pin of a **RS232** converter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了电阻值**R1**=2.2KΩ，**R2**=10KΩ，以及**BC546晶体管**（**T**）。**Vin**与传感器的第5引脚（TX）连接，而**Vout**与**RS232**转换器的**RX**引脚连接。
- en: The functioning is quite simple—it's a logical NOT port with a voltage level
    translator. When a logical 0 (a voltage near 0V) is applied to **Vin**, the **transistor**
    (**T**) doesn't work, so no current can pass through it and there is no voltage
    loss on resistor **R2** and the **Vout** is 5V (a logical 1). On the other hand,
    when a logical 1 (a voltage near 3.3V) is applied to **Vin**, the **transistor**
    (**T**) is turned on and a current can now flow through it, and the **Vout** drops
    down to a voltage near 0V (a logical 0). The following table shows the circuitry
    functioning in a clear manner, which you can see that it works exactly as we expected!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 工作原理非常简单——它是一个逻辑非端口与电平转换器。当逻辑0（接近0V的电压）施加到**Vin**时，**晶体管**（**T**）不工作，因此没有电流通过它，电阻**R2**上没有电压损失，**Vout**为5V（逻辑1）。另一方面，当逻辑1（接近3.3V的电压）施加到**Vin**时，**晶体管**（**T**）被打开，电流可以通过它流动，**Vout**降到接近0V（逻辑0）。下表清晰地显示了电路的工作原理，你可以看到它的工作与我们预期的完全一致！
- en: '| Vin (V)/logical | Vout (V)/logical |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| Vin (V)/逻辑 | Vout (V)/逻辑 |'
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0/0 | 5/1 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 0/0 | 5/1 |'
- en: '| 3.3/1 | 0/0 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 3.3/1 | 0/0 |'
- en: 'In this situation, the connections to be done on the BeagleBone Black are quite
    simple. In fact, we have to connect a normal USB cable to the *USB-to-serial*
    converter and then connect it to the distance sensor, as shown in the following
    table:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，连接到BeagleBone Black的过程非常简单。事实上，我们只需将普通USB电缆连接到*USB-to-serial*转换器，再连接到距离传感器，具体连接方式见下表：
- en: '| USB-to-serial Pin | Distance sensor pin (label) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| USB-to-serial引脚 | 距离传感器引脚（标签） |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GND | 7 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| GND | 7 |'
- en: '| VBUS | 6 (Vcc) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| VBUS | 6 (Vcc) |'
- en: '| RX | 5 (/TX) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| RX | 5 (/TX) |'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that in the table, I used the */TX* electronic notation for the ultrasonic
    sensor's TX pin (in **C**, we can write *!TX*), since, as already stated, its
    output signal must be inverted, so, in reality, the TX pin of the distance sensor
    must be connected with the **Vin** pin of the TTL inverter, while the **Vout**
    is the effective signal */TX* that must be connected to the USB-to-serial RX pin!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在表格中，我使用了*/TX*电子符号表示超声波传感器的TX引脚（在**C**中，我们可以写作*！TX*），因为如前所述，其输出信号必须反转，所以实际上，距离传感器的TX引脚必须连接到TTL反相器的**Vin**引脚，而**Vout**是有效信号*/TX*，必须连接到USB串口的RX引脚！
- en: 'If we decide to use this setup for the distance sensor, the job, from the software
    point of view, is simpler, since no calibration is needed at all due to the fact
    that the sensor will return to us the distance in a digital format, that is, without
    any possible errors due to the analog to digital conversion or voltage scaling,
    as seen in the preceding section. In fact, we can get the distance simply by reading
    it from the serial port over the USB connection; so, if everything works well,
    once we connect the USB cable we should see the following kernel messages:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定使用这个设置来连接距离传感器，从软件的角度来看，工作会更简单，因为不需要任何校准，因为传感器将以数字格式返回给我们距离，也就是说，不会出现由于模拟到数字转换或电压缩放造成的任何错误，正如在前一部分所看到的那样。事实上，我们只需通过USB连接读取串口数据即可获取距离；因此，如果一切正常，一旦我们连接USB电缆，应该会看到以下内核消息：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `/dev/ttyUSB0` device is now available:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/ttyUSB0`设备现在可用：'
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, to read the measurements, we have to configure the serial port as requested
    by the datasheet with the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了读取测量值，我们需要根据数据手册要求配置串口，使用以下命令：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, the data can be displayed in real-time with the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用以下命令实时显示数据：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can stop reading by using the *CTRL* + *C* keys.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按*CTRL* + *C*键来停止读取。
- en: Connecting the LEDs in the second setup
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接第二个设置中的LED
- en: In this second setup, there is nothing special to say regarding LEDs due to
    the fact the connections are pretty the same here as in the first setup.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个设置中，由于连接与第一个设置基本相同，因此没有特别需要说明的LED事项。
- en: Remember that the LEDs are not related to the USB connection, which is used
    only to remotize the distance sensor!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，LED与USB连接无关，USB连接仅用于远程连接距离传感器！
- en: The final picture
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终图片
- en: The following screenshot shows the prototype that I realized to implement this
    project and to test the software.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我实现这个项目并测试软件的原型。
- en: 'Note that I implemented both setups: on the left-half of the breadboard, there
    is the ultrasonic sensor with related circuitry (that is, the part that can be
    remotized); on the right-half, there are the circuitry for the LEDs; while in
    the upper center, there is the inverted voltage translator; and in the lower center,
    there are the two resistors that implement the voltage divider.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我实现了两种配置：面包板的左半部分是超声波传感器及其相关电路（即可以远程操作的部分）；右半部分是LED电路；而上中部是反向电压转换器；下中部是实现电压分压器的两个电阻。
- en: 'Note also the USB-to-serial converter in the center of the screenshot, where
    I connected the USB cable that is put into the USB host port of the BeagleBone
    Black:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意截图中间的USB转串口转换器，我将USB电缆连接到BeagleBone Black的USB主机端口：
- en: '![The final picture](img/B00255_02_07.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![最终图片](img/B00255_02_07.jpg)'
- en: I also used an external power supplier due to the fact that the external circuitry
    and the BeagleBone Black may need more power than what the USB port of your PC
    can supply!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于外部电路和BeagleBone Black可能需要的电力超过了PC的USB端口提供的电量，我还使用了外部电源。
- en: Setting up the software
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置软件
- en: In this project, the software is really simple, since we just need a procedure
    that periodically reads the distance and then turn on and off the LEDs accordingly;
    however, some issues must be pointed out, especially about how to manage the LEDs
    and the differences between the two setups of the ultrasonic sensor.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，软件非常简单，因为我们只需要一个过程来定期读取距离，然后相应地打开和关闭LED；然而，仍然有一些问题需要指出，尤其是关于如何管理LED以及两种超声波传感器配置之间的差异。
- en: Managing the LEDs
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理LED
- en: Despite of what was presented in the previous chapter about the GPIO's management,
    it's important to point out that the Linux kernel has several kinds of devices,
    each one dedicated to a well-defined usage, and one of these special devices are
    the led devices, which is a particular type of devices that can be used to manage
    an LED with different triggers. A **trigger** is a sort of *manager* of the LED
    that can be programmed to work in a specific manner. Ok, it's better doing an
    example instead of trying to explain it!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前一章已介绍GPIO的管理，但需要指出的是，Linux内核有多种设备，每种设备都有特定的用途，其中一种特殊设备是LED设备，这是一种可以用于管理LED并具有不同触发器的设备。**触发器**是LED的某种*管理器*，可以编程使其以特定方式工作。好了，还是做个示例更好，胜过空泛的解释！
- en: 'First of all, we have to define the led devices by using a dedicated device
    tree as reported in the `chapter_02/BB-LEDS-C2-00A0.dts` file in the book''s example
    code repository. The following is a snippet of this file with the relevant code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用专用的设备树来定义LED设备，正如在书籍示例代码库中的`chapter_02/BB-LEDS-C2-00A0.dts`文件中所述。以下是该文件的代码片段：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Further information regarding how to define Linux's **LED devices** can be found
    in Linux's source tree in the `linux/Documentation/devicetree/bindings/leds/leds-gpio.txt`
    file, or online at [https://www.kernel.org/doc/Documentation/devicetree/bindings/leds/leds-gpio.txt](https://www.kernel.org/doc/Documentation/devicetree/bindings/leds/leds-gpio.txt).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何定义Linux **LED设备**的更多信息，可以在Linux的源代码树中找到`linux/Documentation/devicetree/bindings/leds/leds-gpio.txt`文件，或者在线访问[https://www.kernel.org/doc/Documentation/devicetree/bindings/leds/leds-gpio.txt](https://www.kernel.org/doc/Documentation/devicetree/bindings/leds/leds-gpio.txt)。
- en: As you can see, each GPIO is enabled and defined into the kernel as a LED device
    by using the `gpio-leds` driver. The code is quite self-explanatory, and it's
    easy to see that each GPIO definition has a predefined trigger (that is, the default
    trigger `none`) and the predefined status set to `on`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个GPIO都被启用，并通过`gpio-leds`驱动程序定义为LED设备。代码非常易于理解，可以很清楚地看到每个GPIO定义都有一个预定义触发器（即默认触发器为`none`），并且预定义状态设置为`on`。
- en: 'To enable this setting, we have to compile it into its binary form by using
    the `dtc` command as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用此设置，我们必须使用`dtc`命令将其编译成二进制形式，命令如下：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And then, we can load it into the kernel by using the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令将其加载到内核中：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If everything works well, we should see the following kernel activities:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们应该能看到以下内核活动：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If we get the following error then we have to disable the **HDMI** support:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现以下错误，我们需要禁用**HDMI**支持：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This can be done by editing the uboot settings into the `/boot/uboot/uEnv.txt`
    file, and then enabling the following line by uncommenting it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过编辑`/boot/uboot/uEnv.txt`文件中的uboot设置来完成，然后通过取消注释启用以下行：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that on some BeagleBone Black versions, you may find the `uEnv.txt` file
    under the directory `/boot` instead, and the `uboot` settings to modify are as
    follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在某些BeagleBone Black版本中，您可能会在`/boot`目录下找到`uEnv.txt`文件，您需要修改的`uboot`设置如下：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, we only have to reboot the system. Now, if everything was done correctly,
    we should be able to execute the preceding command without errors.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要重新启动系统。如果一切设置正确，我们应该能够无错误地执行前述命令。
- en: 'Note that all the LEDs are now turned on. Now, to manage these new LED devices,
    we can use the sysfs entries under the following directories:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在所有LED都已打开。现在，为了管理这些新的LED设备，我们可以使用以下目录下的sysfs条目：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, all the names we used in the DTS file are present, and we also
    find the following files in each directory:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有在DTS文件中使用的名称都已经存在，我们还会在每个目录中找到以下文件：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The relevant files are `trigger`, `brightness`, and `max_brightness`. The `trigger`
    file is used to discover the current trigger, and, in case, to change it. In fact,
    by reading the file, we see the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的文件有`trigger`、`brightness`和`max_brightness`。`trigger`文件用于查找当前的触发器，并在必要时更改它。实际上，通过读取该文件，我们可以看到以下内容：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we expected, the current trigger is `none` (the one between the square brackets),
    and we can change it simply by writing the new name into the same file (see the
    preceding example).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的，当前触发器是`none`（方括号中的部分），我们可以通过将新名称写入相同的文件来简单地更改它（参见前面的示例）。
- en: 'The `brightness` and `max_brightness` files are specific of the current trigger
    and can be used to set the brightness of the LED from the `0` value to the maximum
    value stored in the `max_brightness` file. Just to test it, we can read the current
    values into these files to verify that the current status is at the maximum brightness:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`brightness`和`max_brightness`文件是当前触发器特有的，可以用来将LED的亮度从`0`值设置到`max_brightness`文件中存储的最大值。为了测试它，我们可以读取这些文件中的当前值，以验证当前状态是否已达到最大亮度：'
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To turn off the LED, we can use the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭LED，我们可以使用以下命令：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that our LEDs are two functional values only, that is, `0` and `255`, due
    to the fact that the LEDs we are using have only two valid states.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的LED只有两个功能值，即`0`和`255`，这是因为我们使用的LED只有两个有效状态。
- en: However, having a flashing capability in our project for when the car is near
    a specific distance from the wall in such a way that gives a better warning about
    the increasing *danger* could be very interesting. In particular, we can do this
    in such a way that when the red LEDs must be turned on, according to what was
    stated in the *Connecting the LEDs in the first setup* section, in this chapter,
    the frequency of the flash will keep increasing as the distance reduces, they
    will stop flashing and remain turned on when the distance is less than 0.10 m.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的项目中，当汽车靠近墙壁并且距离逐渐缩小时，具有闪烁功能，特别是当距离小于0.10米时，红色LED会亮起并停止闪烁，保持开启状态，这将为日益增加的*危险*提供更好的警告，可能非常有趣。具体来说，我们可以以这种方式做到：当根据本章中《第一次设置LED连接》部分的内容，需要打开红色LED时，闪烁的频率将随着距离的减少而不断增加，当距离小于0.10米时，闪烁将停止，LED将保持开启状态。
- en: 'To flash an LED with the desired frequency, we can use the `timer` trigger.
    In order to show how it works, let''s try to enable it on the LED named `red_far`
    by using the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要以所需的频率闪烁LED，我们可以使用`timer`触发器。为了展示其工作原理，尝试通过以下命令在名为`red_far`的LED上启用它：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After executing this command, the LED should start flashing; then looking again
    into the directory, we see that new files are now available:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，LED应该开始闪烁；然后再次查看目录，我们会看到现在有了新的文件：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The new interesting files are `delay_on` and `delay_off`, and they can be used
    to define instead how long the LED must be turned on and how long it must be turned
    off. It''s quite obvious that the LED''s blinking frequencies (F) can now be set
    with the following formula:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 新的有趣文件是`delay_on`和`delay_off`，它们可以用于定义LED必须开启和关闭的时长。显而易见，LED的闪烁频率（F）现在可以通过以下公式设置：
- en: '*F = 1 / T*, where *T = T[delay_on] + T[delay_off]*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*F = 1 / T*，其中*T = T[delay_on] + T[delay_off]*'
- en: 'So, for instance, if we wish that the LED will flash with a frequency of 10Hz,
    we can use the following commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果我们希望LED以10Hz的频率闪烁，我们可以使用以下命令：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The value 50 means: 50ms at *on* state and 50ms at *off* state. So, we have
    *T[delay_on]=50ms* and *T[delay_off]* *=50ms*, so *T=100ms*, and then *F=10Hz*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 值50表示：50ms的*开*状态和50ms的*关*状态。所以，我们有*T[delay_on]=50ms* 和 *T[delay_off]* =50ms，所以
    *T=100ms*，然后 *F=10Hz*。
- en: Considering that the human eye is still sensitive at more or less 25Hz at maximum,
    and that the minimum allowed frequency is 1Hz, the possible values to be written
    into each of the preceding two files are from 500 (ms) for a blinking frequency
    of 1Hz to 20 (ms) for a blinking frequency of 25Hz.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到人眼在最大约25Hz频率下仍然敏感，且允许的最小频率为1Hz，写入上述两个文件的可能值从500（毫秒）用于1Hz的闪烁频率，到20（毫秒）用于25Hz的闪烁频率。
- en: 'A possible implementation of a controlling program for the LEDs is in the `chapter_02/led_set.sh`
    file in the book''s example code repository. The following code is a snippet of
    the relevant code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 控制LED的程序实现可以在书中示例代码库中的`chapter_02/led_set.sh`文件中找到。以下代码是相关代码的片段：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the code turns on the LED addressed by the `name` variable in case the
    `mode` variable is set to `-1`, while it turns it off the same LED when `mode`
    is set to `0`. Also, the code will enable the `timer` trigger with proper settings
    in case the `mode` variable is between the values `1` and `25`(Hz).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当`mode`变量设置为`-1`时，代码将打开`name`变量指定的LED，而当`mode`设置为`0`时，它会关闭同一个LED。此外，代码会在`mode`变量的值在`1`到`25`（Hz）之间时，启用具有适当设置的`timer`触发器。
- en: 'The following is a sample usage:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例用法：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The distance monitor
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 距离监视器
- en: 'Now it''s time to see how our park assistant can work in practice. A possible
    implementation of the code is reported in the `chapter_02/distance_mon.sh` script
    in the book''s example code repository. The following code snippet shows the main
    code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们的停车助手如何在实践中工作了。代码的一个可能实现可以在书中的示例代码库中的`chapter_02/distance_mon.sh`脚本中找到。以下代码片段展示了主要代码：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The functioning is simple—the code periodically reads the distance from the
    sensor by using the function pointed by the `d_fun` variable, and then turns the
    LEDs on and off, according to the value of the distance `d` (in cm) by using the
    `leds_man` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 功能很简单——代码周期性地使用`d_fun`变量指向的函数读取传感器的距离，然后根据距离`d`（以厘米为单位）使用`leds_man`函数打开和关闭LED。
- en: 'The `d_fun` variable holds the name of the function that should read the distance
    by using the ADC, that is, `read_adc`, or the name of the function that uses the
    serial port, that is, `read_tty`. The following are the two functions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`d_fun`变量保存应该通过使用ADC读取距离的函数的名称，即`read_adc`，或者使用串口的函数名称，即`read_tty`。以下是这两个函数：'
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that the `read_adc` file uses the `bc` program to calculate the translation
    formula discussed before, while the `read_tty` uses the Bash's `read` and `while`
    commands to read a complete data line (which is in the form `Rxxx\r`, as reported
    in the datasheet.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`read_adc`文件使用`bc`程序来计算之前讨论的转换公式，而`read_tty`使用Bash的`read`和`while`命令来读取完整的数据行（数据行格式为`Rxxx\r`，如数据手册所述）。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `bc` command may be not installed by default into the BeagleBone Black''s
    distribution, so you can install it by using the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`bc`命令可能不会默认安装在BeagleBone Black的发行版中，因此你可以通过以下命令安装它：'
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `leds_man` function is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`leds_man`函数如下：'
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The function first calculates the blinking frequency in order to respect what
    was stated in the preceding sections, and then it uses a big case to decide which
    LEDs configuration must be used to notify the driver.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先计算闪烁频率，以遵循前述部分的要求，然后使用一个大的case语句决定应使用哪种LED配置来通知驱动程序。
- en: Final test
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终测试
- en: To test the prototype, we must first select one setup and perform the needed
    connections, as stated before. Then we have to turn on the board.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试原型，我们首先必须选择一个设置并进行所需的连接，如之前所述。然后我们需要打开电路板。
- en: After the login, we must setup the system by using the commands discussed before,
    or simply by using the `chapter_02/SYSINIT.sh` command in the book's example code
    repository. Then, we must execute the `distance_mon.sh` command accordingly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，我们必须使用之前讨论过的命令来设置系统，或者直接使用书中示例代码库中的`chapter_02/SYSINIT.sh`命令。然后，我们必须相应地执行`distance_mon.sh`命令。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that looking into the `SYSINIT.sh` file, you can read:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意查看`SYSINIT.sh`文件时，你可以看到：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is if after plugging in the USB cable, you get an error in recognizing
    the `/dev/ttyUSB0` device.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指在插入USB电缆后，设备识别`/dev/ttyUSB0`时出现错误的情况。
- en: 'To test my prototype using the first setup, I used the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用第一种设置测试我的原型，我使用了以下命令：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On the other hand, to test the second one, I used this other command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了测试第二种设置，我使用了这个命令：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can stop the program by using the *CTRL* + *C* keys.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按下*CTRL* + *C*键来停止程序。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we discovered how to manage an ultrasonic sensor in two different
    manners, by using an ADC and by a serial connection over a USB cable, in order
    to have two different setups of the same device: one with all peripherals on the
    BeagleBone Black and one where a sensor is remotized by using a USB connection.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过两种不同的方式管理超声波传感器，一种是使用ADC，另一种是通过USB电缆进行串行连接，从而实现同一设备的两种不同设置：一种是所有外设都连接到BeagleBone
    Black上，另一种是通过USB连接将传感器远程化。
- en: Also, we learned how to manage Linux's LED devices that allow us to have different
    usage of a simple GPIO line by kernel features.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还学习了如何管理Linux的LED设备，这使我们能够通过内核功能对简单的GPIO线路进行不同的使用。
- en: In the next chapter, we'll see how to realize an aquarium monitor in which we'll
    be able to record all the environment data, and then we'll see how to control
    the life of our be loved fishes from a web panel.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将看到如何实现一个水族箱监控系统，在这个系统中，我们能够记录所有环境数据，然后我们将学习如何通过网页面板控制我们心爱的鱼类的生活。
