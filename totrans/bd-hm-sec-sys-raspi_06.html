<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Adding Cameras to Our Security System"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Adding Cameras to Our Security System</h1></div></div></div><p>Until now, we've been putting together the elements that will allow us to connect sensors to our alarm system to detect intrusions using either switches or passive infra-red motion detectors, which in turn will tell our Raspberry Pi that something has happened in a particular zone. These elements will all come together as a whole system later in this book.</p><p>Our system is now going to become a whole lot more sophisticated with the addition of cameras to take pictures and video clips, and e-mail them to us straightaway when it detects something.</p><p>We'll also use e-mail to send us alerts on our smart phone when we're out and about when any of the sensors in the system are triggered.</p><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the Raspberry Pi camera module and learning how to capture stills and video images</li><li class="listitem" style="list-style-type: disc">Learning how to overlay captured images with text and time-stamps</li><li class="listitem" style="list-style-type: disc">Triggering image captures with a motion detector</li><li class="listitem" style="list-style-type: disc">E-mailing the image and video files to us in real time</li><li class="listitem" style="list-style-type: disc">Understanding the differences between capturing images during the day and during the night</li><li class="listitem" style="list-style-type: disc">Switching on and off security lighting and other high-current devices when required</li><li class="listitem" style="list-style-type: disc">Connecting a USB webcam instead of the native camera module</li></ul></div><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Prerequisites</h1></div></div></div><p>You'll need the<a id="id218" class="indexterm"/> following parts for this chapter, on top of the components used in the previous chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Raspberry Pi standard camera module</li><li class="listitem" style="list-style-type: disc">A Raspberry Pi NoIR camera module</li><li class="listitem" style="list-style-type: disc">An Infra-Red LED array and/or visible LED array</li><li class="listitem" style="list-style-type: disc">A USB webcam</li></ul></div></div></div>
<div class="section" title="The Raspberry Pi camera module"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>The Raspberry Pi camera module</h1></div></div></div><p>The Raspberry Pi Camera<a id="id219" class="indexterm"/> Module is an official Raspberry Pi accessory that works with all models of the Pi, and can be used to take high-definition stills and video images. It connects directly to the Pi board's <span class="strong"><strong>camera serial interface</strong></span> (<span class="strong"><strong>CSI</strong></span>) port, which is <a id="id220" class="indexterm"/>dedicated to these modules to enable high-speed operation.</p><p>The camera itself is a 5<a id="id221" class="indexterm"/> megapixel fixed-focus sensor supporting 1080p, 720p, and VGA video modes and still captures.</p><div class="mediaobject"><img src="graphics/B04579_06_01.jpg" alt="The Raspberry Pi camera module"/><div class="caption"><p>The official Raspberry Pi Camera Module</p></div></div><p>You can also obtain housings for the camera modules, which, unless you're going to build your own <a id="id222" class="indexterm"/>enclosure for the camera system, I recommend you use.</p><div class="mediaobject"><img src="graphics/B04579_06_02.jpg" alt="The Raspberry Pi camera module"/><div class="caption"><p>Raspberry Pi camera housings come in various colors and styles</p></div></div><div class="section" title="Connecting the camera module"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Connecting the camera module</h2></div></div></div><p>As previously<a id="id223" class="indexterm"/> mentioned, the module connects directly to the Raspberry Pi board via its dedicated camera interfaces, as shown in the following image. When connecting the camera, the contact side of the ribbon cable is toward the HDMI connector and the blue side of the cable is toward the network connector.</p><div class="mediaobject"><img src="graphics/B04579_06_03.jpg" alt="Connecting the camera module"/><div class="caption"><p>Connect the camera module to the dedicated interface</p></div></div><p>As you can see in the following image, the ribbon connector is not that long, so the camera needs to<a id="id224" class="indexterm"/> be located close to the Raspberry Pi. By using a camera enclosure, you could actually mount the camera directly on top of the Raspberry Pi case itself, if that works for you.</p><div class="mediaobject"><img src="graphics/B04579_06_04.jpg" alt="Connecting the camera module"/><div class="caption"><p>The camera module, housed within an enclosure</p></div></div></div><div class="section" title="Setting up the camera module"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Setting up the camera module</h2></div></div></div><p>Before we can<a id="id225" class="indexterm"/> use the camera module, we need to enable camera support on the Raspberry Pi. To do this, we use the <code class="literal">raspi-config</code> tool, as we did with the I2C bus earlier in our journey.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Connect to your Raspberry Pi the lazy way from your sofa using SSH, or directly using a keyboard and monitor.</li><li class="listitem">Once you've logged in, launch the config tool with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo raspi-config</strong></span>
</pre></div></li><li class="listitem">And then, select <code class="literal">5 Enable Camera</code>.<div class="mediaobject"><img src="graphics/B04579_06_05.jpg" alt="Setting up the camera module"/></div></li><li class="listitem">You'll then be asked to confirm whether you want to enable camera support.<div class="mediaobject"><img src="graphics/B04579_06_06.jpg" alt="Setting up the camera module"/></div></li><li class="listitem">Select <code class="literal">&lt;Enable&gt;</code>.</li><li class="listitem">Then, select<a id="id226" class="indexterm"/> <span class="strong"><strong>Finish</strong></span> and reboot your Pi to enable the camera settings.</li></ol></div><div class="section" title="Testing the camera module"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec11"/>Testing the camera module</h3></div></div></div><p>Once your<a id="id227" class="indexterm"/> Raspberry Pi has rebooted, your camera should be enabled. We can test this by taking a still image using the <code class="literal">raspistill</code> utility:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ raspistill –v -o test.img</strong></span>
</pre></div><p>This will delay for 5 seconds then take a picture, while displaying various pieces of information, such as that shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04579_06_07.jpg" alt="Testing the camera module"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>The camera module needs at least 128 MB of GPU memory to operate properly on Raspian. If you experience any issues, first ensure that the the <code class="literal">gpu_mem</code> setting in the <code class="literal">/boot/config.txt</code> configuration file is set to at least <code class="literal">128</code>.</p></div></div><p>And if all goes well, you should find the file, <code class="literal">test.jpg</code>, in your home folder. As you're connected via the shell, you wouldn't have seen the 5 second preview image displayed when the<a id="id228" class="indexterm"/> command was running.</p><p>If you download the image file to your PC, you should see a nice quality snap taken by the camera module.</p><div class="mediaobject"><img src="graphics/B04579_06_08.jpg" alt="Testing the camera module"/><div class="caption"><p>The test photo taken by the Raspberry Pi Camera Module</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>If you find that<a id="id229" class="indexterm"/> raspistill outputs errors when you run it, ensure that it is connected properly at both ends of the ribbon cable. One other catch is that sometimes the ribbon that connects the actual camera lens component to the tiny connector on the camera board can come loose. Just ensure that this is securely connected too. I've had this issue a couple times after the camera modules have been taken out of my box of random test bits to be used.</p></div></div><p>The <code class="literal">raspistill</code> utility has loads of options for manipulating the images it captures, and we'll use some of them a bit later in our capture script. In the meantime, to see the available options, run <code class="literal">raspistill</code> without any options and they will be listed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ raspistill</strong></span>
</pre></div></div></div></div>
<div class="section" title="Be a video star"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Be a video star</h1></div></div></div><p>Now that we<a id="id230" class="indexterm"/> know our camera module is working, we can try and capture some video. To do this, we'll use the <code class="literal">raspivid</code> utility. The following command will take 5 seconds of high-definition video and save the file to your Raspberry Pi:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ raspivid –o test.h264 –t 5000</strong></span>
</pre></div><p>You'll notice that file is called <code class="literal">test.h264</code>—this is because the video is captured as a raw <span class="strong"><strong>H.264</strong></span> video <a id="id231" class="indexterm"/>stream. Unfortunately, not many media players will handle these files (although VLC player will—it rocks and handles practically anything you throw at it—get it <a id="id232" class="indexterm"/>on your PC at <a class="ulink" href="http://www.videolan.org">www.videolan.org</a>).</p><p>If you want to play the file on smartphones and conventional media players, then we will need to wrap it in a container format, such as MPEG-4, and give the file a <code class="literal">.mp4</code> extension.</p><p>To do this, we'll use the<a id="id233" class="indexterm"/> <span class="strong"><strong>GPAC</strong></span> package, which is an open source multimedia framework. It comes with a<a id="id234" class="indexterm"/> utility <a id="id235" class="indexterm"/>called <span class="strong"><strong>MP4Box</strong></span>, which is a tool we'll use to create an MP4 container for our video file:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, install the GPAC package:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install gpac</strong></span>
</pre></div></li><li class="listitem">Once it's installed, run the command to convert the test video we created:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ MP4Box -fps 30 -add test.h264 test.mp4</strong></span>
</pre></div></li></ol></div><p>You should now have the file, <code class="literal">test.mp4</code>, which you can download and play on your PC or smartphone.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Another popular conversion tool is <span class="strong"><strong>ffmpeg</strong></span>, which I use a lot on Windows to convert video files; however, it <a id="id236" class="indexterm"/>can be quite complex and although there is a package for the Raspberry Pi, I actually couldn't get it to convert properly on the Pi. MP4Box is much more straightforward and fitting for our needs.</p></div></div><div class="section" title="Caught on camera"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Caught on camera</h2></div></div></div><p>So, we now have a method of capturing still images and video, which we can put to use in our security system. If we want to have this running constantly, we could write a script to take video<a id="id237" class="indexterm"/> constantly, but this would soon fill up our memory card and wouldn't be particularly efficient. So, we'll combine our camera system with the motion detectors we connected earlier.</p><p>In the last chapter, we created an alarm zone which had a couple of sensors and a motion detector connected to our system on the input GPA0. So, let's write a script that will take a video clip whenever the motion detector is triggered:</p><div class="informalexample"><pre class="programlisting">#!/bin/bash


#set up port expander 
sudo i2cset –y 1 0x20 0x00 0xFF

# loop forever
while true
do
  # read the GPA inputs
  GPA=$(sudo i2cget –y 1 0x20 0x12)

  # detect the zone on input 0
  if [ $GPA == "0x01" ]
  then
    #circuit normally closed so zone is OK
    #short delay
sleep 0.5

  else
    #zone is activated so take a 20 sec video clip
    
    #filename will be based on current timestamp
    sDate='date +%d%m%y'
    sTime='date +%T'
    echo "Zone 1 Activate at $sDate $sTime"

#take video clip
raspivid –o $sDate$sTime.h264 –t 20000
    
#convert to MP4
MP4Box -fps 30 -add $sDate$sTime.h264 $sDate$sTime.mp4
  fi
done</pre></div></div></div>
<div class="section" title="You have new mail"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>You have new mail</h1></div></div></div><p>Having the images<a id="id238" class="indexterm"/> stored on your Raspberry Pi is not really much use—ideally, you would want the images sent to you straightaway, as soon as they are captured, so that you can view them on your smartphone.</p><p>An easy, quick, and reliable way to do this is to simply have them e-mailed to you. Hence we're going to add an e-mailing functionality to our home security system so that image captures are attached to a message and sent to your e-mail address straightaway, which you can access from your smartphone. The images can then be removed from your Raspberry Pi to prevent the SD card space from being clogged up with these reasonably large files.</p><div class="section" title="Setting up the e-mail sender client"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/>Setting up the e-mail sender client</h2></div></div></div><p>Fortunately, there are <a id="id239" class="indexterm"/>some good packages available that will help us with this. Carry out the following steps to install the email packages we need:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Update the package installer with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get update</strong></span>
</pre></div></li><li class="listitem">Install and set up the SMTP client with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install ssmtp</strong></span>
</pre></div><p>You'll now need to set up the client to send emails through your email account. In the following configuration file, I've assumed that you have a Gmail account. The settings may be different if you use another email provider.</p></li><li class="listitem">Open the <code class="literal">ssmtp</code> configuration file using <span class="strong"><strong>Nano</strong></span> or another text editor:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nano /etc/ssmtp/ssmtp.conf</strong></span>
</pre></div></li><li class="listitem">Replace the entries with the following configuration:<div class="informalexample"><pre class="programlisting">root=&lt;your-username&gt;@gmail.com
mailhub=smtp.gmail.com:587
rewriteDomain=gmail.com
AuthUser=&lt;your-username&gt;@gmail.com
AuthPass=&lt;your-password&gt;
FromLineOverride=YES
UseSTARTTLS=YES</pre></div></li><li class="listitem"><code class="literal">ssmtp</code> can be used on its own but can be a bit of a faff while automatically sending emails (by default, you manually type the email in with the command line, or create a text file), so we're also going to install the <code class="literal">mailutils</code> package:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install mailutils</strong></span>
</pre></div></li><li class="listitem">Once it's installed, we can use the <code class="literal">mail</code> command to send emails more easily. Send a test email through the (G)mail account that we set up earlier, using the following command to make sure your settings are working:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo "Test Email" | mail –s "Test Pi-Mail" me@mydomain.com</strong></span>
</pre></div></li></ol></div><p>If all goes well, you should receive the test email in your mailbox within a few seconds or so.</p></div><div class="section" title="Sending attachments"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Sending attachments</h2></div></div></div><p>Now that we can <a id="id240" class="indexterm"/>send basic emails from our home security system, let's try sending the still image taken from our camera earlier. But first, we need to install yet another package to help us with this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install mpack</strong></span>
</pre></div><p>Once that's<a id="id241" class="indexterm"/> installed, you can send the test image file we took previously by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo mpack –s "Security Photo" test.jpg me@mydomain.com</strong></span>
</pre></div><p>We now have all <a id="id242" class="indexterm"/>of the elements needed to send alerts and images from our home security system directly to our smartphone using email.</p></div><div class="section" title="Where was that taken?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Where was that taken?</h2></div></div></div><p>Ordinarily, you could just annotate the email message with where and when the attached image was taken, but that wouldn't be as cool as actually overlaying the image with some text, would it? So let's do some magic with the help of <code class="literal">imagemagick</code>, which is a popular command-line image<a id="id243" class="indexterm"/> manipulation tool. Install it with the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install imagemagick</strong></span>
</pre></div><p>We'll now use the command line to take the test photo that we took earlier, overlay some text using one of the <code class="literal">imagemagick</code> utilities, and save it to another file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ convert test.jpg –fill red –pointsize 48 annotate +20+60 'Camera 1' annotated.jpg</strong></span>
</pre></div><p>After a few seconds, this will have generated a file called <code class="literal">annotated.jpg</code> containing our image with <span class="strong"><strong>Camera 1</strong></span> written in red in the top corner. When we put all of this together in our final system, we'll also overlay the image with a time stamp.</p><div class="mediaobject"><img src="graphics/B04579_06_09.jpg" alt="Where was that taken?"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>At the moment, the images generated by the <code class="literal">raspistill</code> tool are pretty large, being high resolution photos. This makes manipulating and sending them a bit time-consuming as far as processing time is concerned, so when we build our final system, we'll be using the<a id="id244" class="indexterm"/> <code class="literal">raspistill</code> options, <code class="literal">–w</code>, <code class="literal">–h</code> and, <code class="literal">–q</code>, to reduce the size and quality of the images to make the system more efficient.</p></div></div><p>To capture smaller image<a id="id245" class="indexterm"/> files, try using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ raspistill -o test.img –h 768 –w 1024 –q 25</strong></span>
</pre></div></div></div>
<div class="section" title="Night vision"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Night vision</h1></div></div></div><p>The standard Raspberry Pi camera is great for taking daytime snaps of people walking up the garden path, but <a id="id246" class="indexterm"/>when it comes to night time shots, it's not really suitable. There are two ways of dealing with this: the first is to illuminate the capture area with a bright light when<a id="id247" class="indexterm"/> the PIR detector is triggered, and the second is<a id="id248" class="indexterm"/> to use the Raspberry Pi <span class="strong"><strong>NoIR camera module</strong></span> and an infra-red LED array to let the camera see in the dark. More about that in a minute.</p><div class="mediaobject"><img src="graphics/B04579_06_15.jpg" alt="Night vision"/><div class="caption"><p>The Raspberry Pi NoIR camera module; it looks similar to the standard model</p></div></div><div class="section" title="An illuminating experience"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/>An illuminating experience</h2></div></div></div><p>In order to switch on a light or LED array from the Raspberry Pi GPIO or our port expander circuit, we<a id="id249" class="indexterm"/> need something that will allow us to drive higher currents and voltages than can be provided by the GPIO ports alone.</p><p>A good candidate for this is the <a id="id250" class="indexterm"/>
<span class="strong"><strong>TIP120</strong></span> <span class="strong"><strong>Darlington transistor</strong></span>, which will allow us to switch on and off loads of up to 80V and 5 A from our GPIO pins. In our full system later on, we're going to use Port B of our MCP23017 port expander to control outputs, but the principle stands for any of the GPIO outputs available to us.</p><div class="mediaobject"><img src="graphics/B04579_06_10.jpg" alt="An illuminating experience"/><div class="caption"><p>TIP120 transistors can be bought cheaply but can drive large loads</p></div></div><p>The following circuit shows how we can drive big loads from our GPIO port outputs.</p><div class="mediaobject"><img src="graphics/B04579_06_11.jpg" alt="An illuminating experience"/></div><p>In our example<a id="id251" class="indexterm"/> circuit, we're using a GPIO output pin to control the base of our transistor via a 220 ohm resistor. When the GPIO pin goes high, the transistor is switched on and allows the 12V circuit to flow through the LED array.</p><p>In the preceding circuit, there is no current limiting for the LEDs because they are connected in series, and so with nine of them, each dropping about 1.5V across, this is about right for a 12V supply (yes I know I've only included six LEDs here but it's just for illustration). Remember to adjust for your particular needs. This circuit could easily drive other loads, such as bulbs or sounders.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>If you intend to drive high power loads, you will probably need to attach the TIP120 to a heat sink that will dissipate any heat and prevent it from over-heating and burning out. In our circuit that was demonstrated previously, however, you <a id="id252" class="indexterm"/>probably won't need one as we're only driving a couple of hundred milliwatts at most.</p></div></div></div><div class="section" title="The Elaborate light switch re-visited"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec55"/>The Elaborate light switch re-visited</h2></div></div></div><p>Expanding once again on our elaborate light switch from previous chapters, we can once again write a <a id="id253" class="indexterm"/>Bash script that will switch on our camera light, take a snap with the camera, and e-mail it to us when a PIR detector is triggered.</p><p>For the following script, we're<a id="id254" class="indexterm"/> assuming that the output controlling the TIP120 transistor is the Raspberry PI GPIO17 pin (D0 or pin 11 of our connector), which replaces the LED in our earlier set-up. The input from the PIR trigger is, again, connected to the GPA0 (port A, data pin 0) of our MCP23017 port expander. All the other inputs are tied low, as before, using 10 K resistors:</p><div class="informalexample"><pre class="programlisting">#!/bin/bash

#set up the High Load GPIO pin
sudo echo 17 &gt; /sys/class/gpio/export
sudo echo out &gt; /sys/class/gpio/gpio17/direction

#set up port expander Port A for inputs
sudo i2cset –y 1 0x20 0x00 0xFF

#clear the output by default to switch light off
sudo echo 0 &gt; /sys/class/gpio/gpio17/value


# loop forever
while true
do
  # read the sensor state
  SWITCH=$(sudo i2cget –y 1 0x20 0x12)

  #PIR is normally closed so pin is held high
  if [ $SWITCH != "0x01" ]
  then
    #PIR was triggered – pin taken low

    #switch on lamp driver
    sudo echo 1 &gt; /sys/class/gpio/gpio17/value
    sleep 0.5
    
#take a still image
    sudo raspistill –o –image.jpg –h 768 –w 1024 –q 25
    
    #email the image
    mpack –s "Security Alert Photo" test.jpg me@mydomain.com

    #switch off the lamp driver
    sudo echo 0 &gt; /sys/class/gpio/gpio17/value

  fi
  #short delay
  sleep 0.5
done</pre></div><p>
<code class="literal">pir-camera-trigger.sh</code>
</p><p>You'll now see that <a id="id255" class="indexterm"/>we've started developing the foundations of the software that will control our home <a id="id256" class="indexterm"/>security system.</p></div><div class="section" title="Is that a badger?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Is that a badger?</h2></div></div></div><p>If you don't want to illuminate an area <a id="id257" class="indexterm"/>before capturing an image, you can use <span class="strong"><strong>infra-red lighting</strong></span> in conjunction with a compatible camera. The standard Raspberry Pi camera module won't work with<a id="id258" class="indexterm"/> infra-red lighting because it contains an infra-red filter, but we can use the NoIR version of the camera module instead.</p><p>The Raspberry Pi NoIR<a id="id259" class="indexterm"/> camera module is exactly the same as the standard one, except that it doesn't have an infra-red filter built in, which means it will see in the dark with the aid of infra-red lighting. This makes it good for watching badgers at night as well as for use in our home security system.</p><p>You will need an infra-red LED array or cluster to invisibly illuminate the area you want to capture with the camera. These are readily available in various form factors and intensities, or you can build your own using individual infra-red LEDs purchased from an electronics store.</p><div class="mediaobject"><img src="graphics/B04579_06_12.jpg" alt="Is that a badger?"/><div class="caption"><p>The Kingbright infra-red LED cluster runs from a 6V supply, which means you can connect two in series—one on either side of the camera.</p></div></div><p>Connecting and driving the LED cluster modules works exactly the same as our illuminating light <a id="id260" class="indexterm"/>above, using the TIP120 driver circuit. The only difference is that we humans can't see when the LEDs are on.</p></div></div>
<div class="section" title="Using USB cameras"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Using USB cameras</h1></div></div></div><p>Instead of using the <a id="id261" class="indexterm"/>Raspberry Pi Camera Module, it's also possible to use a standard USB <span class="strong"><strong>webcam</strong></span> to take still images. You should be aware though that the dedicated camera module is far<a id="id262" class="indexterm"/> superior to a USB webcam in terms of image quality. Although, you may<a id="id263" class="indexterm"/> already have a webcam knocking about in your box of bits, so why not try it?</p><div class="section" title="Installing the webcam"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Installing the webcam</h2></div></div></div><p>After you've <a id="id264" class="indexterm"/>connected your webcam to a USB port on your Pi, you can check whether it's been recognized using the <code class="literal">lsusb</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lsusb</strong></span>
</pre></div><p>I'm using a Logitech webcam that gets reported as follows with <code class="literal">lsusb</code> (Device 006):</p><div class="informalexample"><pre class="programlisting">pi@raspberrypi ~ $ lsusb
Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp.
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp.
Bus 001 Device 006: ID 046d:08d8 Logitech, Inc. QuickCam for Notebook Deluxe</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>Not all webcams will work with the Raspberry Pi. Even though it may be recognized as a USB device, it might not actually work properly with the operating system and create a video device (for example, <code class="literal">/dev/video0</code>). For example, an old cheap Trust webcam I had appeared as a USB device but wouldn't capture any images.</p><p>You can check<a id="id265" class="indexterm"/> whether your webcam is likely to work with the Pi by checking your make and model at <a class="ulink" href="http://elinux.org/RPi_USB_Webcams">http://elinux.org/RPi_USB_Webcams</a>.</p></div></div><p>So, now that the Pi knows that we have a webcam device attached, we can use the <code class="literal">fswebcam</code> utility to<a id="id266" class="indexterm"/> capture image frames. You can find out more about <a id="id267" class="indexterm"/>
<code class="literal">fswebcam</code> from the developer's site at <a class="ulink" href="http://www.sanslogic.co.uk/fswebcam">http://www.sanslogic.co.uk/fswebcam</a>.</p><p>Install <code class="literal">fswebcam</code> with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install fswebcam</strong></span>
</pre></div></div><div class="section" title="Taking a snap"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec58"/>Taking a snap</h2></div></div></div><p>You can <a id="id268" class="indexterm"/>now test the webcam by capturing a still image, which can be done by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ fswebcam test.jpg</strong></span>
</pre></div><p>You should expect to see output similar to the following:</p><div class="mediaobject"><img src="graphics/B04579_06_13.jpg" alt="Taking a snap"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>
<code class="literal">fswebcam</code> has lots of options for things like the resolution and quality of the image. Use the <a id="id269" class="indexterm"/>command <code class="literal">fswebcam</code> <code class="literal">-?</code> to get a list of all options.</p></div></div><div class="section" title="Snap snap snap"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec12"/>Snap snap snap</h3></div></div></div><p>
<code class="literal">fswebcam</code> doesn't take video streams, but you can set it up to take a series of <span class="strong"><strong>frames</strong></span> at regular intervals. For <a id="id270" class="indexterm"/>example, to take a snap every 10 seconds, you can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ fswebcam frame.jpg -l 10</strong></span>
</pre></div><p>An example of how this would be useful can be demonstrated by setting the webcam to take a snap every few seconds in the background (the <code class="literal">–q</code> switch runs <code class="literal">fswebcam</code> in the background). When our security system is triggered, we could then take the latest image snapped with the webcam which could be looking down your pathway.</p><p>For the purpose of putting together our entire system later in this book, we'll be focusing on the Raspberry Pi Camera Module, but you can always replace the code with the previous examples if you want to use USB webcams instead.</p><p>You'll notice that <code class="literal">fswebcam</code>, unlike <code class="literal">raspistill</code>, has the ability to overlay the images with timestamp information, so you don't need to worry about overlaying text as we did previously. Look at the <code class="literal">fswebcam</code> command line options for more information.</p></div></div></div>
<div class="section" title="The multicamera setup"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>The multicamera setup</h1></div></div></div><p>It may have occurred to you that the Raspberry Pi has only one camera module input. Now, this is obviously limiting if you want to have multiple cameras around your property that are triggered by motion detectors.</p><p>However, there<a id="id271" class="indexterm"/> is nothing stopping us from building standalone units that have a separate Raspberry Pi board with a PIR detector, Camera Module, and network connection, either using a Wi-Fi dongle or Ethernet.</p><p>Because you only need a single input to the Raspberry Pi to detect when the PIR motion sensor is triggered, you can use the on-board GPIO port to connect the sensor, rather than using a port expander. The Raspberry Pi will email the alert over the network, and could alert the main controller Pi if required—making it a slave sensor device.</p><p>You can readily obtain small PIR detectors, such as the Parallax one shown next, which you can mount onto a Raspberry Pi Case along with the camera module, creating a self-contained unit.</p><div class="mediaobject"><img src="graphics/B04579_06_14.jpg" alt="The multicamera setup"/><div class="caption"><p>A Parallax PIR motion sensor (type 555-28027)</p></div></div><div class="section" title="The Slave driver"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec59"/>The Slave driver</h2></div></div></div><p>While it may seem quite elaborate to have a Raspberry Pi for each camera—think about it—you can actually <a id="id272" class="indexterm"/>build each camera unit with all of the components for around £50, which is significantly cheaper than buying a wireless <span class="emphasis"><em>smart</em></span> camera. If you really want to be clever, you could also use this as a slave device to accept further sensor inputs local to the unit.</p><p>There is nothing to stop you from connecting a GPIO output pin on the slave unit to drive an input on the main controller and control the pin depending on the state of its local sensors. By running a 6-core cable between the units, you could even power the slave unit if your power supply is man enough (you'd need to have a supply of 5V @ 1A for the slave Pi running along the wire).</p><p>I'm not going to go into<a id="id273" class="indexterm"/> any more detail about this configuration at this time, but you could set yourself a challenge to create a fully distributed home security system using multiple Raspberry Pis and the building blocks and concepts learned in this book.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Summary</h1></div></div></div><p>In this chapter, we learned how to connect both Raspberry Pi camera modules and USB cameras to our Pi board in order to take image and video captures when required by our home security system. We also learned how to overlay our images with informative text and have the files immediately emailed to us.</p><p>In order to capture images from our camera at night, we also looked at ways to illuminate the capture area using both visible and infra-red lighting, with the ability to switch the lighting on and off as required by using a high-current Darlington transistor driver.</p><p>In the next chapter, we're going to get down to the business of putting together modules by building a mobile-optimized web-based control panel for our home security system. We'll learn how to set up a Web server on our Raspberry Pi and manipulate files using our Web control panel, which means that we'll start to explore how all of the elements we've encountered so far can come together as part of our final system.</p></div></body></html>