- en: Chapter 5. Troubleshooting Users, Directories, and Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the previous subjects discussed so far, the process of troubleshooting
    users, directories, and files can be seen as a continual process that requires
    constant attention during the life time of the server. It will become an every
    day event, and for this reason, we will start with the basic principles of user
    management with the intention to show you how to restore the default file and
    folder permissions, recover lost files, and take you on a journey through many
    more associated themes in order to prepare you for a variety of issues that any
    professional troubleshooter may encounter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to effectively manage the process of adding, deleting, modifying users,
    and implementing system-wide changes with `login.defs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how to monitor user activity with `utmpdump`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to reset the root password and initiate root-based logging to achieve
    improved command-line security audits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to recover lost data with Scalpel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to restore default permissions and ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover more about the XFS filesystem by discovering how to run ongoing repairs
    and investigate defragmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to audit directories and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how to visualize directories and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User management is a fundamental skill associated with the need to manage a
    server, and in this respect, it will inevitably represent a milestone when troubleshooting
    any system. So, with this in mind, we will quickly analyze the process of managing
    users in order to dispel any confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Adding users and forcing a password change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add a new user (and create a home folder for them) by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can provide the new user with a password like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you would like to force a password reset, thereby implying
    that a user must reset his/her password, then the following command will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, you can null a password for a specific user by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you would like to grant this new user the ability to use `sudo`,
    then type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you would like to know more about a user, using the following command,
    will disclose their current properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Deleting users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The action of deleting a user account is generally straightforward, but it
    can involve a number of stages that can be forgotten. Therefore, to avoid any
    future issues across extensive systems with a large amount of users, prior to
    deleting a user from the system, the account should be locked in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then want to back up the home directory using `tar` before confirming
    if there are any active processes attributed to this account by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done this, you can now proceed to kill any active processes attributed
    to that account by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can remove individual process IDs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By using `pkill`, you are invoking the `SIGTERM` command, which will streamline
    the task of removing any active process associated with that account. So, at this
    stage, you should now consider removing any files, print jobs, and re-assign or
    delete any `cron` jobs associated with that account.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done this, you can safely delete a user with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `-r` option will also remove the home directory associated with that
    account, but if you would like to delete the user, their home directory, and remove
    any `SELinux` mappings, you should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you encounter any difficulties, then you can always use the force
    option in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you will need to consider removing any SSH keys associated with that
    user. Ensure that `sudo` or `su` is not enabled for that account, and then proceed
    to work through your applications and services one at a time (including database,
    e-mail, file sharing, htaccess, web directories, CGI files, and more) while reassigning
    new settings to any common accounts that the system may use.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most useful aspects of user management for a troubleshooter is being
    able to modify an existing user account. There could be many reasons as to why
    this task is required, but the best illustration of this skill would begin with
    changing the default `adduser` attributes in the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: From here, you can redefine what shell is used, the default location of the
    home directories, and whether a default mail spool is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use this technique to change the default location of the
    home directories from `/home` to `/home/<companyname>`. However, if you prefer
    to do this manually (on a case-by-case basis), in order to change the location
    of the home directory, you need to use the `usermod` command in conjunction with
    the `-d` option (the path to the new directory) and the `-m` option (to move the
    contents of the current home directory), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When running the preceding command, it is important to realize that a PID will
    be displayed on the console if the user is currently using the system and this
    must be killed before any modifications can be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, should the need arise to transfer an existing user to a different
    group, then this can be achieved by invoking the `-g` option like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, having done this, and just as you would for deleting a user, you must
    manually change the ownership of any `crontab` files or jobs and complete the
    process by making any relevant changes to any remaining (related/existing) services
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Meet login.defs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to managing users, an alternative or long-term approach is to
    consider altering the default settings found in `/etc/login.defs` so that you
    can alter the behavior of the delete command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider you find the following line commented out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Uncomment this line and it will ensure that all `at/cron/print` jobs are removed.
    Moreover, you can also use the `login.defs` file to determine the default values
    assigned to the user mail directory, password encryption method, password expiry
    period, `userid`, `groupid`, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring user activity with utmpdump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping track of user activity is one of the most essential skills associated
    with any Linux administrator. In situations where user management may be the cause
    of a troubleshooting session, we can make use of `utmpdump`.
  prefs: []
  type: TYPE_NORMAL
- en: 'User histories are typically stored in the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/var/run/utmp`: The purpose of this binary is to record open sessions. You
    can review the contents of this file with `utmpdump /var/run/utmp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var/run/wtmp`: The purpose of this binary is to record connection histories.
    You can review the contents of this file with `utmpdump /var/log/wtmp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var/log/btmp`. The purpose of this binary is to record failed login attempts.
    You can review the contents of this file with `utmpdump /var/log/btmp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taking this one step further, you can also review the current history of logged
    sessions contained within `/var/run/wtmp` by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can review the current history of logged sessions contained within `/var/run/btmp`
    by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as a simple review of these files is slightly redundant for our needs,
    you can read the current status of these files with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these commands may look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, given that binary files cannot be viewed using basic reading commands
    such as `cat`, `less`, and `more`, rather than simply relying on basic commands
    such as `last`, `who`, `lastb`, and others, a different approach is to use the
    `utmpdump` command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as we have already mentioned earlier, in the case of wanting to read `/var/run/utmp`,
    you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'While the remaining files would be accessible with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So, having used all three commands, you will then notice that the output is
    in a familiar format with the most obvious difference being that the results of
    `wtmp` are displayed in reverse order as opposed to both `utmp` and `btmp` which
    are displayed in chronological order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of `utmpdump` are formatted in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The first column displays a session identifier; the value 7 is typically associated
    with a new login event, while the value 8 is associated with a logout event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second column displays a PID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third column can hold a relative variable based on either of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~~`, indicating a run-level or system reboot change'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bw`, or a bootwait process'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A numeric or TTY value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A character/digit that indicates a PTY value (the pseudo terminal).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth column can sometimes remain empty or maintain an associated username,
    runlevel, or reboot value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth column (if this information is available), will display the TTY or
    PTY value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sixth column will display the identity of the remote host. In most local
    cases, you will only see a runlevel message at most, but for remote access, you
    will see an IP address or name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The seventh column will display the remote host's IP address, or it will show
    0.0.0.0 for local access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The eighth, and final column, will indicate the time and date information as
    to when the record was created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should also be aware that columns six and seven will show identical information
    if no DNS resolution is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with the preceding information in mind, with a bit of practice, and using
    the skills we discovered in the previous chapters, `utmpdump` can be used to perform
    a wide range of queries such as displaying general access information like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Further to this, you can use `grep` to show the details of specific records.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you wanted to display the records of a particular user from
    `wtmp`, you will type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking this one step further, you can use `grep` to identify the number of
    logins from a particular IP address in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use the following syntax to check how many times root accessed the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the following command to monitor the number of failed login attempts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, the output of `btmp` should be minimal, given that this binary will
    show a variety of issues related to the use of incorrect passwords being used
    or attempts to log in with an unknown username. The latter of which is particularly
    important when a tty1 was shown to be used, as this will indicate that an unknown
    person had access to a terminal on your machine. Look at it this way, noticing
    such an important issue may inspire you to run a security audit on access privileges
    and keys by creating a basic text-based output file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Resetting the root password and enhancing logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the release of CentOS 7, you may find that the process of resetting the
    root password has changed. So, in the event that you forget the root password,
    you will need to follow these important steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boot the computer and press the *E* key during the kernel screen phase. On
    the next screen, scroll down the text and look for the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, replace the letters `ro` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It should then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When done, press *Control* + *X* or *Ctrl* + *X* to boot into the single user
    mode using the bash shell `/sysroot/bin/sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the single user mode, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After the hash sign (`#`), type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Follow the onscreen instructions and proceed to reset the password, but if you
    do need to update `SELINUX` use the command `touch /.autorelabel` before you do
    anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are ready to finish, type the following command to access the machine
    in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, reboot your system in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Well done! You should now be able to gain full access to the system using the
    new root password. However, if you decide to update the logging for all system
    commands, simply open the following file in your favorite text editor like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll down to the bottom and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done this, you will now find that all the SSH-based command-line activity
    is logged through `/var/log/messages` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Recovering lost or deleted files with Scalpel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a file has been accidentally deleted from the system, you can use a small
    utility called Scalpel to recover it. Scalpel is a faster alternative to Foremost,
    which was originally developed by the United States Air Force Office of Special
    Investigations and The Center for Information Systems Security Studies and Research.
    Today, it is a tool that is generally associated with both digital forensics investigation
    and file recovery, and you can install it by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need the EPEL repository to complete this process (which is discussed
    in a previous chapter), but when you are ready, simply update the following configuration
    file to determine what types of files you would like to search for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done this, you should now create a recovery directory, and then you
    should move to the `/etc` directory in order to use `scalpel.conf` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run a scan on a relevant device by customizing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the preceding command would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Scalpel will begin by creating work queues, but be mindful that the entire operation
    will take some time to complete. In simple terms, the actual time taken to complete
    a scan will depend on the disk size, the number of deleted files, the power of
    the machine in general, and other activities that the system is currently performing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the findings by using the `ls` command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finally, and before you get started, you should be aware that a new recovery
    directory must be created every time you run Scalpel (so you may want to consider
    using an alternative hard disk) as the results will be maintained by a single
    audit file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This particular file can be viewed by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Remember, Scalpel will work with a variety of filesystem formats or raw partitions,
    and in this respect, it can be seen as a very useful tool for any troubleshooter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about Scalpel by reviewing the manual like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Restoring file and directory permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'File and directory permissions are important, and to view the current state
    of all the files in a particular directory, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can target a particular directory by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in a situation where someone has mistakenly changed the permissions
    of a particular system-based file or folder this calamitous situation can be rectified
    with the following RPM-based commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, should it be the case that an entire directory has been
    mistakenly updated with `chown` or the `chmod` commands, the following commands
    will prove more useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the commands shown preceding, the first command will serve to reset
    all the file and folder ownerships values to the default state, while the second
    command will serve to reset the relative file permissions. So having run these
    commands, it is possible that you will see the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry! Regardless of which file or directory is listed, such notices can
    be safely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Working with and extending the XFS filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Originally developed at Silicon Graphics in 1993, the main purpose of XFS is
    to not only support the creation of large filesystems that will allow for metadata
    journaling, but to provide a technology that can be defragmented and enlarged
    while mounted and active. This information may or may not be of much use to you
    as a troubleshooter, but you should be aware that the default filesystem now employed
    by the most recent release of CentOS is known as XFS. If you did not customize
    the partitions to any great extent, then you may find that XFS is the filesystem
    you will be dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can quickly confirm the structure of your system with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command (the disk size and partitions ignored) can result in
    something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The wording `xfs` under the column labeled `type` is what we are looking for.
    If it is found that your server does use the XFS filesystem, then the XFS tools
    and utilities file `xfsprogs.x86_64` can be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Generally speaking, you should be aware that XFS can prove to be the source
    of a subtle loss of performance if the server system is relatively small. In these
    circumstances ext4 tends to be faster with some single threaded and metadata intensive
    workloads. Moreover, as shrinking support is not available to XFS, you should
    know that this technology does not allow the filesystem to be reduced in size
    even when un-mounted. For this reason, you may want to stay with ext4 when big
    filesystems or big files are not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the bigger picture, you will be comforted to know that the basic
    syntax required to create an XFS is similar to other filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: So, no surprises there, and due to the similarities with other filesystems,
    I will assume that you are comfortable completing the rest of this procedure.
    However, before you begin, you should always be aware of the server's hardware
    configuration before starting this operation, as there may be a few notable issues
    you may want to be aware of before concluding this operation.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say the server exceeded 2 TB. So having completed the initial
    `fdisk` operations to build the filesystem layout, (prior to mounting) you may
    decide to benchmark the system because every good troubleshooter knows that XFS
    enables write barriers to ensure filesystem integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can achieve this simple operation by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: By default, write barriers will serve to preserve the filesystem from issues
    relating to power failure, resets, and system crashes, but if your hardware maintains
    a good write cache, then it may seem more prudent to disable the write barrier
    in order to reduce the impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this respect, you can mount the device in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'On completion, you can always request further information about a specific
    volume with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: So as we can see, XFS does come with a lot of good features and tools, but when
    it comes to the process of troubleshooting a server, it is precisely these differences
    that could be the cause of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this respect, and as we will now see, XFS should be treated in a different
    way to a comparable ext3- or ext4-based system. However, if you need to extend
    the filesystem, then you will be happy to know that XFS comes complete with a
    standard tool known as `xfs_growfs` that can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that you have reviewed the man pages, it would be obvious to state
    that your syntax would use the `-d` option in order to grow the filesystem to
    the maximum size supported by the device.
  prefs: []
  type: TYPE_NORMAL
- en: Running repairs on XFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XFS was created with the intention to support extremely large filesystems. It
    performs incredibly well under a heavy load and scales with large files, but as
    a result, it is also susceptible to damage, and it is with this in mind that we
    now consider a set of tools that will enable us to troubleshoot the server and
    restore the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Known as `xfs_repair`, this tool is used to confirm filesystem consistency and
    repair any problems that are found. This process will not restore lost data, but
    it should restore the filesystem on the device in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax used by `xfs_repair` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to avoid any error messages, the procedure will then require that
    you should initially `umount` the device in question. In this respect, the entire
    procedure will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The resulting output will then proceed to run through a series of phases and
    confirm the relevant events. Once complete, simply remount the device in the usual
    way to complete the task. However, on the chance that `xfs_repair` fails, repeat
    this process again but do your research on the respective error messages.
  prefs: []
  type: TYPE_NORMAL
- en: If `xfs_repair` fails to fix the consistency problems on a third occasion, depending
    on the error messages, you may want to consider an alternative rescue plan for
    the server, as it should be assumed that data recovery can only be made from backups.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having said that, it is possible that you can consider additional steps to recover
    the device in question.
  prefs: []
  type: TYPE_NORMAL
- en: At this current stage, you should assume that data recovery can only be made
    from backups and your plan is now based on the recovery of the filesystem only.
    However, having said this, it is important to remember that you should not take
    any action that will impact the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: It may be possible to restore files from the disk by backing up and restoring
    the files on the filesystem. To do this, mount the filesystem in the read-only
    mode and proceed to make a backup with `xfsdump`. From this point onwards, you
    will want to remake the partition and restore the files with `xfsrestore`. Check
    `man xfsdump` and `man xfsrestore` for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if log recovery is unsuccessful, it may be possible to recover
    some of the data by mounting the filesystem in the read-only mode with the `no
    recover` option. This will avoid running the log recovery process but, by using
    this method, the filesystem is unlikely to be consistent, and it is to be expected
    that not all of the data will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `xfs_repair` utility is designed to repair filesystems. It is size independent
    (treating both large and small filesystems equally), but unlike other repair tools,
    it will not run at boot and it will only initiate logging at mount in order to
    ensure a consistent filesystem. In cases where `xfs_repair` encounters a damaged
    log file, it will not be able to repair the filesystem, so in the event that this
    does happen, you will need to clear the relevant log, mount and then un-mount
    the XFS filesystem, which is done by adding the `-L` option to force log zeroing
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Remember, resetting the log can leave the filesystem in an inconsistent state.
    This can, and generally does, result in the loss of data and/or data corruption.
    So, only apply these methods with the intention to restore the filesystem alone.
    Remember, the `xfs_repair` command is not intended to restore the data on that
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating fragmentation on XFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In situations where the filesystem is acting sluggishly, it is possible that
    fragmentation is impacting your server. In this instance, and if you suspect that
    fragmentation has occurred or is occurring, then simply run the following command
    on the relevant device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'By using this command, we are causing `xfs_db` to open the filesystem in a
    read-only mode (`-r` option) and passing a command (`-c` option) to get the file
    fragmentation data (`frag`) for the device in question. When we use the `frag`
    command, it will only return information relevant to the file data in the filesystem
    as opposed to concerning itself with the fragmentation of free space. So, depending
    on the specific nature of your system, the resulting output could look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In a more severe case, it could report the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'By drawing your attention to the fragmentation factor (expressed as a percentage)
    in the preceding examples, you may have found at least one reason as to why your
    server requires troubleshooting. Fixing this situation would be a matter of calling
    the filesystem organizer utility, otherwise known as `xfs_fsr`. We would simply
    require the system to reorganize our partition or device to optimize disk usage
    in a similar way to a Microsoft Windows desktop. In this respect, the most basic
    syntax for using `xfs_fsr` would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas, for a single file, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'However, given that the period of time for these events to complete can be
    quite long, a more succinct use of this command would be to specify a list of
    filesystems to reorganize (`-m`), a time option `-t` calculated in seconds, and
    the verbose option `-v` for a clear indication of what is happening, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding output will then display the number of extents that are both
    before and after the inode. By default, `xfs_fsr` will make ten passes before
    completing the process unless you decide to reduce the number of passes by using
    the option `-p` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be aware that `xfs_fsr` should not be used to defragment the whole
    system as this is generally regarded to be unnecessary as it can give rise to
    free space fragmentation, so you can complete this task in stages in the knowledge
    that the operation can be interrupted cleanly. This will leave the filesystem
    in a consistent state. If you interrupt the process (using *Ctrl* + *C*), `xfs_fsr`
    will save the defragmentation process to the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: However, before you dive in, the real issue here is that this fragmentation
    issue should be approached with caution on a live system, as proceeding to defragment
    a device or partition during periods of high-load will place an unnecessary burden
    on your server. So in this instance, the best course of action is to run `xfs_fsr`
    at a time when the relevant device or partition is not at full load or during
    lighter working periods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, and having completed the process of defragmentation, you can confirm
    the extent of the work performed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: So having completed these simple actions, or necessitated a future (and possibly
    repeat) cron job, you should now notice an immediate improvement with regard to
    the speed at which files and folders can be moved and transferred.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing directories and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important task related to troubleshooting can arise from an understanding
    of activities commonly associated with the action of reading and writing files.
    CentOS 7 provides a simple utility for this. Known as `auditd`, this service (or
    daemon) starts during the boot process. Events are recorded to an associated log
    file found at `/var/log/audit` and as it runs in the background, you can check
    the current service status with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to customize the auditing service and you can have direct access
    to manage the log file size, location, and associated attributes by accessing
    the following file with your favorite text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, if you do not wish to lose any auditing data, you are able to disable
    the machine when an audit cannot be performed. To do this, open the configuration
    file `auditd.conf` and add or modify the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This action is severe and it is not something to jump into without doing your
    homework, but it will serve to remove the default action of rotating log files
    and replace it with an instruction to e-mail the root user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, should you wish to take advantage of the audit service flag for every
    process, simply open `/etc/default/grub` and add the following argument to the
    kernel line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to regenerate grub with the following command and reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that an auditable flag is set for every process after the
    boot sequence has been initiated and, for even greater simplicity, we can then
    consider building a unique set of rules by editing the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this as easy as possible, the best approach is to find your server''s
    `stig.rules` file at `/usr/share/doc/audit-X.X.X/stig.rules` and copy it to `/etc/audit/rules.d/audit.rules`.
    Based on the current package version (in my case), the `stig.rules` file can be
    found at `/usr/share/doc/audit-2.3.3/stig.rules`. Consequently, I ran the following
    command to create a default rule set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'So, having customized the rules and restarted the `auditd` service, you will
    discover that a query can be initiated with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative to this, you can use `aureport` to produce a series of audits
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To monitor unusual behavior, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To build a report on user logins, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'To review access violations, you can try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to review anomalies, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we haven''t covered every aspect of the auditing service, but the
    preceding examples should get you started. Remember, all of the examples shown
    can be added to a cron job and, should you wish to know more, the `aureport` manual
    can always be viewed any time by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Visualizing directories and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good administration starts with good housekeeping, and for this reason, the
    maintenance of detailed records regarding your server's layout is generally considered
    to be a good starting point for any Linux administrator. Such a task not only
    allows you to keep abreast of any changes made to the system as a whole, but it
    can be a useful approach to debugging. Moreover, because you may have inherited
    this system, or shared access with a number of administrators, it is probably
    a good idea to consider running an up-to-date inventory of the changes made.
  prefs: []
  type: TYPE_NORMAL
- en: All directories, folders, and files accessible to a specific Linux-based system
    are arranged in a single tree. Starting from root (`/`), this hierarchy may consist
    of either local or remote files, local or remote filesystem(s), and local or remote
    block devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view this tree, simply ensure that you have installed the following package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `tree` command will begin indexing from your current location,
    so to begin, simply change your location to the boot directory like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tree` command is technically described as *a recursive directory listing
    command* that displays the content of your server in a tree-like format. It is
    highly customizable, so if you prefer to target a specific directory from your
    current location, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that the tree command does not show hidden files by default.
    Therefore, in order to see all files (including all hidden files), use the `-a`
    option like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you would like the tree function to restrict itself to displaying
    folder names only, you should use the `-d` option like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If it all looks a little plain and ordinary, you can add some color to the
    output with the `-C` option like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can combine the preceding options to print the output to a text
    file by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you wanted to maintain a list of files in one or more directories
    showing the current permissions, you can use the `-p` option like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you would prefer to display the output with embedded HTML
    code for export, try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'So, regardless of whether you have adopted a new server, or you are troubled
    by the number of users accessing and writing files to that server, the `tree`
    function provides a relative solution to keeping a visual audit of your server,
    or your devices, by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'So why not combine this with a cron job? Then you can regularly keep an eye
    on the rise of any potential problems or even maintain a visual record of when
    those changes took place. In this respect you could assert that the `tree` package
    is a very useful tool, and to learn more you can review the manual at any time
    by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have approached a number of topics related to users, directories,
    and files, while introducing some related themes associated with the release of
    the XFS filesystem. From forcing password changes to visualizing the directory
    structure, restoring the root password to understanding the need for disk defragmentation,
    our pursuit of troubleshooting CentOS 7 has gone some way to show that the knowledge
    gained from resolving fundamental system-based issues directly relate to the ongoing
    human-based issues. It would be true to say that you can never rehearse a disastrous
    scenario because every event may be unique to one or more systems but, as we have
    seen, regardless of whether you are monitoring users, modifying users, recovering
    data, or maintaining the filesystem as a whole, by following a few simple procedures,
    much of those file, directory, and user-based issues can be solved quickly and
    efficiently; which leads us gently towards the subject of troubleshooting shared
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Red Hat customer portal: [https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Tree Project home page: [http://mama.indstate.edu/users/ice/tree/](http://mama.indstate.edu/users/ice/tree/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'XFS FAQ: [http://xfs.org/index.php/XFS_FAQ](http://xfs.org/index.php/XFS_FAQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The XFS user guide: [http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide//tmp/en-US/html/index.html](http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide//tmp/en-US/html/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Red Hat XFS guide: [https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-xfs.html](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-xfs.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The XFS wiki page: [http://en.wikipedia.org/wiki/XFS](http://en.wikipedia.org/wiki/XFS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
