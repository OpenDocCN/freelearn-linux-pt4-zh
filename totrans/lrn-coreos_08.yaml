- en: Chapter 8. What Next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will touch upon some advanced Docker and Core OS topics
    and we will also discuss what is upcoming in CoreOS. For most of the topics, we
    will not go into the details of using or deploying each of the features mentioned
    in this chapter, but will discuss enough so as to be aware of what else is cooking.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Container security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy upgrade using CoreUpgrade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User authentication using Dex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sysdig
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other container orchestration mechanisms such as Kubernetes, Apache Mesos, and
    Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker data volume management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Container Project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is an important aspect of any deployment. There should be security
    in the applications, devices, and network to disallow any unauthorized access.
    There should also be security in the container/docker deployment so as to disallow
    unauthorized access to system resources reserved for the container. We will understand
    how Docker container ensures network and resource isolation and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker uses the namespaces to isolate the container from other containers running
    on the host. There are three important namespaces that take part in providing
    security:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process namespace**: Each Linux system has a process tree, that is, there
    is an init process with process ID 1, which is also called the root process. This
    root process spawns other daemons and processes as a child process. These daemons
    and processes can then create their own child and so on. It is possible to create
    a child namespace with one of the child as the root process. All the processes
    running in the child namespace don''t have the knowledge of the parent namespace;
    hence, they can''t perform any operations (like signal) on the processes outside
    their namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network namespace**: Each container has its own network interface that is
    different from the host interface''s. They have their own loop-back interface
    as well. The only way containers can talk to the external world is through the
    bridge network at the host. Bridge network enables communication between different
    namespaces running in the same host or to an address in another host. This ensures
    that the network stack is exclusive to the container, thereby running its own
    IP, TCP, UDP stacks, and so on. Docker has an additional layer of security by
    allowing communication with another Docker by exposing ports or by creating links
    to another container explicitly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource namespace**: This ensures that each container has its own resource
    exclusively for its own use. Resource can be dedicated RAM, processors, or a disk
    with its own filesystem. This ensures that the container usage doesn''t cross
    the set limits, thus ensuring that it doesn''t intrude upon the resources being
    allocated to another container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following figure illustrates the isolation provided by the Docker container.
    As we can see, the service running inside container has its own root process,
    filesystem, and interface which an operation system would normally provide. These
    features are present in almost all of the Linux distributions that Docker uses
    to provide isolation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Container security](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After isolation, let's discuss security. Docker starts container in non-privilege
    mode. That means containers or applications running inside the container only
    have permissions to perform actions that don't require root privileges. Some examples
    are using a port less than 1024 (though non-privileged docker can use ports that
    are under and above the 1024 range), modifying a file in `/etc,` mounting a filesystem,
    and so on. This ensures that even services in containers are hacked; they can't
    inflict damage on the host and the impact can be limited to that container instance.
    The allowed privileges can be configured and it can be very restrictive, or very
    relaxed based on the environment (trusted or non-trusted) containers are expected
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: Docker also recommends securing the access to Docker Daemon, which runs as root
    on the host machine. Also, it recommends enabling secure HTTP connections in case
    it is required to administrate a container remotely. Further, the in-built firewalls
    in Linux kernel like `SELinux` can be used to further add restrictions on the
    Docker to set restrictions for using only specific ports and specific protocols
    (only TCP, only UDP, and so on). Also, it is advisable to use other Linux security
    utilities and tools to protect and harden the system.
  prefs: []
  type: TYPE_NORMAL
- en: Update and patches – CoreUpdate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CoreUpdate` is a service available as part of `Premium Manged Service` targeted
    at Enterprise customers who require support and SLA-based support in case they
    face issues with deployment. `CoreUpdate` helps to monitor cluster health, cluster
    software versions, manage updates, and patch deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CoreUpdates` provides a web interface and a command-line interface to view
    the versions running on each of the `CoreOS` instances and to schedule upgrades
    on them. All instances of the `CoreOS` can be logically distributed into multiple
    application groups, and upgrades can be managed individually for those applications.
    For instance, they can be configured to pick the upgrade/patch from different
    channels like stable/beta/alpha. They can be scheduled at different times and
    can have different metadata, like where to pick the package for upgrade/patch.
    During the upgrade process, progress of the upgrade is displayed and any error/information/warnings
    are displayed to take corrective actions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CoreUpdate` also provides a HTTP-based API to integrate software management
    with the developed application.'
  prefs: []
  type: TYPE_NORMAL
- en: Dex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of us have experienced user authentication in multiple ways, like when we
    log in to websites, log in to our computer, log in to social sites, and so on.
    There are a wide variety of authentication systems like local users being managed
    by a system admin for Linux or Microsoft Windows, Enterprise-wide Active Directory,
    or LDAP, or through identity providers such as Google, Outlook, Yahoo!, and Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: As an application developer, **Dex** ([https://github.com/coreos/dex](https://github.com/coreos/dex))
    solves the problem of user authentication by providing a ready-to-use standard-based
    implementation and connectors for various authentication systems including local
    authentication. This makes it easier for the developer to concentrate on their
    business logic and trust that authentication is well taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: Since Dex implementation is based on standard (**OpenID Connect (OIDC) Core
    spec**), it is language independent as the interfaces are well defined. Use a
    client library conforming to OIDC corresponding to the programming language and
    you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: There are different authentication mechanisms that can be used by integrating
    off-the-shelf connectors. If we have to draw a parallel, it is very much like
    a database connector. Currently, two connectors, local and OIDC connector, and
    more are getting developed. With local connector, the user can log in to the system
    using the authentication database maintained by Dex locally, like Linux user IDs
    and passwords. With OIDC connectors, users can be authenticated using another
    OIDC Identity Provider like Google or another `Dex` instance as Dex itself is
    an OIDC identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you have a requirement for authentication in your system, explore Dex.
  prefs: []
  type: TYPE_NORMAL
- en: sysdig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are aware of commonly used debugging tools for Linux to monitor and take
    snapshots of system health. For example, if we want to check whether the machine
    is overloading its CPU or RAM, we use tools like `top` or `vmstat`. If we have
    to capture the packets over the interface, we use `wireshark` or `tcpdump`. Similarly,
    we use `iostat` to monitor the system IO devices.
  prefs: []
  type: TYPE_NORMAL
- en: '`sysdig` provides integrated support for monitoring all the preceding system
    resources along with providing many more features. And most importantly, in our
    context it provides support for containers. We know that containers run in the
    host OS in separate namespaces. So the processes running inside containers are
    also visible to the native tools, say, for example, `ps`. In a container environment,
    the information related to the application is present in two levels: one at the
    host kernel level, for example process ID as the host kernel sees it, and the
    other at the container level, for example, the process ID inside the container.
    All native Linux tools give a host kernel view leaving it to the user to correlate
    information to find out which information pertains to the container and segregate
    information on a per-container basis. To get information as the container application
    sees it, Docker interfaces/commands are to be used. `sysdig` solves this problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a hands-on approach to get a feel of what information `sysdig` provides.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to install and run `sysdig`. After we start the docker container
    for sysdig, we are taken to a shell where we can run the `sysdig` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a Docker container as daemon using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run some example commands to find out container-specific information.
    First, we will list the containers running on the machine both using the `docker
    ps` in another login window and using `sysdig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We see here that there are two containers running on the host machine: one
    container is for `sysdig` and the other is the `busybox` we started. Now, we will
    run the corresponding `sysdig` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command shows the cumulative CPU usage of the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![sysdig](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can see a list of processes, its corresponding containers, and
    process ID (as seen by the host and as seen by the container at the global level)
    by using the following command. Note that the `-pc` flag indicates that the information
    is required in the container context. The same command can also be extended by
    providing a container name, and information is displayed only for that container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![sysdig](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By now, you would have got an idea of the utility of `sysdig`. Similar to the
    process and CPU information, it can provide a host of other features like monitoring
    networks, network IO, disk usage, trace traffic, and so on. And most of the monitoring
    can be done in a container context also by adding the –`pc` switch.
  prefs: []
  type: TYPE_NORMAL
- en: Competitive container orchestration mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to see the other container orchestration mechanism
    currently available in the market. Some of these orchestration mechanisms can
    in fact be complementary to the CoreOS orchestration mechanism. As we have already
    seen in [Chapter 3](part0026_split_000.html#OPEK1-31555e2039a14139a7f00b384a5a2dd8
    "Chapter 3. Creating Your CoreOS Cluster and Managing the Cluster"), *Creating
    Your CoreOS Cluster and Managing the Cluster*, fleet acts as a cluster manager
    in CoreOS and instantiates the docker units/service in any one of the nodes in
    the cluster. Let us discuss the other orchestration mechanisms in detail in this
    chapter. Some of the key container orchestration mechanisms currently available
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Mesos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Kubernetes** is an open source container orchestration infrastructure developed
    by Google for deploying containers or a group of containers in a server cluster.
    Kubernetes provides a way of deploying a group of containers as a single logical
    service. This group of containers has been termed **pod**. Apart from providing
    a mechanism for deploying an application or container, Kubernetes also provides
    way for scheduling, updating, maintaining, and scaling the containers in a cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes operates over the pod rather than containers. A pod can contain
    a single container or a group of logically interrelated containers, as described
    earlier. Kubernetes consists of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes nodes (Minion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the components of Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kubernetes](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Kubernetes components overview
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes master
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name implies, **Kubernetes master** is the master node that controls
    other nodes and pods in the cluster. It is the control plane and provides the
    following services:'
  prefs: []
  type: TYPE_NORMAL
- en: Placement of pods in the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication control of various pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining the state of the containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing the REST API for controlling the nodes, pods, and so on from the external
    world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master Kubernetes runs apiserver, controller manager, and optionally the kubelet
    and proxy servers.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Kubernetes nodes** are also called the minion. User applications are deployed
    as a container or docker containers in the minion. The Kubernetes nodes host important
    services of Kubernetes like kubelet and kube-proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubelet is responsible for managing the pods at the node level. It acts as a
    primary node-agent.
  prefs: []
  type: TYPE_NORMAL
- en: kube-proxy or Kubernetes network proxy is an application that will manage services
    inside the Kubernetes nodes. This is also responsible for providing a kind of
    virtual IP for the application running in the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes pods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Kubernetes pods** are a group of containers that are logically tightly coupled
    with each other and running inside the same Kubernetes nodes. The containers that
    are part of the same pods share resources like storage, networking, and so on.
    The following represents a pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Kubernetes service** is a group of pods that is running inside the cluster.
    Services provide the vital features that are required for any kind of pods in
    the cluster such as load-balancing, application service discovery, easy deployment,
    and so on. A service is described in JSON representation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have seen the basics of Kubernetes. Let us look into how Kubernetes
    can be used as an orchestration framework for CoreOS docker/Rackt containers.
  prefs: []
  type: TYPE_NORMAL
- en: CoreOS and Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes can also be used to provide advanced cluster-wide orchestration in
    CoreOS using an etcd distributed key-value store. As Kubernetes is a powerful
    tool for container orchestration, which provides the essential features of a typical
    deployment such as automatic load-balancing, service discovery, and container
    replication, in a CoreOS environment, Kubernetes can be used as a container orchestration
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: One node inside the CoreOS cluster can act as a Kubernetes master, wherein you
    can run the apiserver and controller manager. All other nodes in the CoreOS cluster
    can act as a minion, wherein you can install and run kubelet and kube-proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes can also be used to provide advanced cluster-wide orchestration in
    CoreOS using an etcd distributed key-value store.
  prefs: []
  type: TYPE_NORMAL
- en: Apache-Mesos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Apache-Mesos** is a container cluster manager developed for very large clusters
    involving thousands of hosts. Mesos provides a distributed kernel that is running
    across different nodes in the cluster and provides APIs for the application to
    manage resources such as memory, CPU, disk, and scheduling these resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The major components of Mesos are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mesos agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ZooKeeper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos frameworks![Apache-Mesos](img/00043.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesos component overview
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mesos master
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Mesos master** daemon runs in the master node that manages all the slave
    nodes or agents and the Mesos frameworks. The master takes care of sharing the
    resource to the frameworks based on the configured scheduling policy, which can
    either be strict priority or fair sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Mesos agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Mesos agent** is responsible for running the actual tasks. The agent reports
    to the master about the availability of the resources, which the master agent
    uses to allocate a particular task or framework to be ran on the agent.'
  prefs: []
  type: TYPE_NORMAL
- en: ZooKeeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a typical Mesos deployment, there will be more than one master available
    to avoid single point of failure. In these cases, **ZooKeeper** is used to elect
    the leader among the available masters.
  prefs: []
  type: TYPE_NORMAL
- en: Mesos frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Mesos frameworks** are the ones that run the tasks in the Mesos agent. The
    framework consists of two components: a scheduler that registers with the master
    and an executor that executes the tasks in the slave node. The master determines
    the number of resources to be allocated for the framework and allocates it to
    the framework. The scheduler picks the resource offered from this list.'
  prefs: []
  type: TYPE_NORMAL
- en: Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Swarm** is a native orchestration mechanism provided by Docker. Like other
    orchestration mechanisms, Swarm also consists of Swarm master and Swarm agent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swarm master** takes care of orchestrating the docker container to different
    Swarm agents. The master will be running in one or two nodes in the cluster whereas
    the **Swarm agent** will be running in all the nodes in the network.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker data volume management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main aspects of the container that we haven't discussed until now
    is the container's data volume management. In this section, we are going to see
    some basic concepts of container data volume management, some of the major problems
    in data volume management, and their solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may be aware, the docker container provides two different ways of managing
    the data volumes as:'
  prefs: []
  type: TYPE_NORMAL
- en: Data volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data volume containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding two mechanisms provide various ways for storing the data in a
    persistent volume, a way to mount a host directory as a data volume, a way to
    mount a host file as a data volume, and so on. This works well until the containers
    are tied to a particular node/server in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker data volume management](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker data volume management
  prefs: []
  type: TYPE_NORMAL
- en: When the container is moving from one server to another server, the data volume
    should also be moved. Typically, the data volume won't be moved when the container
    is moved from one node to another. This is because the docker/orchestration layer
    manages the containers and data volume separately.
  prefs: []
  type: TYPE_NORMAL
- en: Here comes the necessity of managing these two entities together. Flocker provides
    a way of managing both the docker container and docker volume together.
  prefs: []
  type: TYPE_NORMAL
- en: Flocker can be used along with container orchestration mechanisms such as Kubernetes
    and Mesos. Work has been going on to integrate Flocker with CoreOS, though some
    non-production-ready deployments are already available with CoreOS.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Flocker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Flocker** is an open source container data volume manager to manage data
    volumes. In docker, a data volume is tied to a single server. However, in Flocker,
    the data volume, which is also called a dataset, is portable and hence can be
    used with any server in the cluster. Flocker manages the docker container along
    with the data volumes. Hence, when a container is moved from one server to another
    server in the cluster, the corresponding data volume will also be moved.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to Flocker](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Flocker cluster architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flocker cluster architecture consists of the following components/services:'
  prefs: []
  type: TYPE_NORMAL
- en: Flocker control services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flocker agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flocker plugin for Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flocker control services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Kubernetes, we have Kubernetes master, and similarly the **Flocker control
    service** acts as a master and is installed on a single node in the cluster. It
    exposes the REST API to interface with an external application. This is the brain
    of Flocker and enables the user to monitor the state of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Flocker agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Flocker agents** receive the commands from control services and make sure
    that the state of the Flocker agent matches with the desired state. When the local
    state is not matching the desired state, it calculates the actions necessary to
    make the local state match the desired configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Flocker plugin for Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Docker''s Flocker plugin** deploys a container along with the data volume
    without worrying about which server in the cluster the data volume is placed.
    Whenever the container is moved from one server to another, the plugin takes care
    of moving the data volume too. This makes sure that the data volume is running
    in any one node in the Flocker cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: Open Container Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the different container technologies are being developed, there is a necessity
    of having a standard container format in order to provide interoperability and
    define the standard for the containers. In order to achieve this, the CoreOS team
    started working on a container standardization mechanism called *App Container*
    to define the standard container image format, runtime environment, and discovery
    protocol, to work toward the goal of a standard, portable shipping container for
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, the **Open Container Project** (**OCP**) was formed by a large group
    of industry leaders to define the standard. The Open Container Project is hosted
    under Linux Foundation. CoreOS App Container also contributes to OCP and the latest
    specification of the OCP project can be found at the following link: [https://github.com/opencontainers/specs](https://github.com/opencontainers/specs)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As CoreOS is a young and very promising operating system, a lot of developments
    are happening on daily basis. One of the major milestones of CoreOS in the recent
    past was that Google and CoreOS jointly announced a new project called Tectonic
    to offer IT infrastructure, which is completely container-based leveraging both
    CoreOS and Kubernetes. Tectonic is a commercial Kubernetes platform that combines
    the CoreOS stack with Kubernetes to bring a Google-style infrastructure to any
    cloud. Companies such as Rackspace, Salesforce, MemSQL, Atlassian, and Pivotal's
    Cloud Foundry have already deployed CoreOS. The future of CoreOS looks very bright
    as CoreOS is aiming to build next-generation IT infrastructure without increasing
    the complexity. As security is one of the major concerns in current IT infrastructure,
    one of the major goals of CoreOS is to enable the companies to run their applications
    securely and reliably in any environment, bringing a promising future for CoreOS.
  prefs: []
  type: TYPE_NORMAL
