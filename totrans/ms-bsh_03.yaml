- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have stressed so far the importance of giving a structure to our scripts,
    to make them flexible, and to have them react to some conditions and situations
    so that they will help us automate some routine tasks making decisions and performing
    actions on our behalf. What we saw in the previous chapters enables us to assign
    variables, change their values in different ways, and also to preserve them; but
    from the examples shown, it is clear that we need some more and this is what this
    new chapter is all about. We will see how to test, make comparisons, and get to
    react accordingly to the results, and we will give our first structure to a script
    having to make a decision if something happens.
  prefs: []
  type: TYPE_NORMAL
- en: What if...else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take one of our previous examples and examine it in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As an exercise to ease its comprehension, let''s try to write it in natural
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: Print a greeting asking for a number between 10 and 20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the user input and save it in the `user_input` variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of `user_input` is greater or equal to `10` and the value of `user_input`
    is less or equal to `2`, then print an OK message to the user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise (else), if the conditions are not met, print a not OK message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Fi`, end of condition'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are the basics of a conditional statement and it lets you explore on
    condition: if it succeeds, an instruction is executed, if it fails, another block
    of instructions is invoked. We can also make it a bit more flexible, introducing
    an alternative condition to check in case the first fails (`elif`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` the exit code of the condition tested is 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: do something
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elif` the exit code of this other condition tested is 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: do something
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else if` any of the previous conditions returned 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: do something
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fi` we exit from the conditional statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So in this more articulated shape, the condition offers more flexibility and
    keep in mind that you can have as many `elif` blocks as you want and even nest
    `if` into `if`, even though it is not recommended for clarity''s sake. Now, let
    us make a real-life example with return codes, starting with the creation of three
    `test` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us create a small script that will check for the existence of these
    three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run it and have a look at what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened? The first `ls` on `test1` returned `0,` so it was successful
    and the conditional did not proceed testing the other options end exited the statement
    executing the next instruction outside the conditional and this was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to see what happens if the first condition encountered fails,
    so we are going to delete the `test1` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And execute the script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, what happened? The first instruction, `ls test1`, failed since there
    is no `test1` file left to show with `ls` and so the instruction returned `1`.
    The script then proceeded further into the conditional statement to the second
    condition, executing `ls test2`. In this case, since `file2` exists, the command
    returned `0` and the script exited the statement, executing the first instruction
    outside the conditional, again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us go on, deleting `test2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And now invoke the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `test1` and `test2` do not exist, the first two `ls` fail and so the
    first two conditions with them, but not the third `ls` since `test3` still exists.
    The third `ls` then is successful and returns `0`, the script exits the conditional
    and executes the first instruction outside of it, again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Final test, time to remove `test3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be clear now what is going on. All the `if...then` conditions failed
    and so the last resort is the else sections, which report the exit code of the
    `lstest3`. Once this is done, the script exits the conditional and executes the
    first instruction outside of it, which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that the overall exit status of a conditional statement is the one
    belonging to the last instruction executed and the overall exit code of the script
    is the one of the last instruction executed by the script itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What we see here is the script returning a value of `0`, and this is correct
    since the last instruction executed `echo End of the script` was successful. Let''s
    now change the last instruction of the script with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The colon actually means *do nothing,* so let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Again, `0`. Now, let's do an inverse check, modifying the third condition adding
    an `!`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the check is successful if `ls test3` returns `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the message printed is a red herring since the execution of `ls test3`
    is not successful and cannot return `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What returns `0` is actually the check we made on the inverted condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It can be read as the `if` condition is verified if `ls file3` is not verified.
    So, since for us verified is successful and successful is represented by a return
    value of `0`, the condition is verified (`0`) only if the `if ls file3` is not
    verified (`-ne 0`). So, be careful when using such conditions because you could
    incur in some unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just saw how to check a condition one at a time, but we can combine operators
    in a single case check so that we can achieve more interesting results. Have a
    look at the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is testing three different conditions at the same time
    so the `if` will be verified only when the user inputs a number between `10` and
    `20` and it must be even. In other words, it must be divisible by 2 and we test
    it checking that the modulo of the value is `0`. Let''s try some values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This number satisfied both the third and second conditions since it is even
    and lower than 20 but it fails the first since it is not equal to or above 10\.
    So, the `if` condition is not verified and `else` action is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now the number fails the first and third conditions and satisfies the first,
    it is not equal or above `10`, it is not even but it is less than `20`, so the
    else action is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Number `10` is good. It satisfies the first and second conditions because it
    is equal to 10 and less than 20, and it satisfied the third condition because
    it is even, so the action in the `then` block is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the first and second conditions are verified, but the third is
    not. `15` is not even, so the `else` block action is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`20` is good, it is above `10`, equal to `20`, and we can divide it by `2`,
    so all  three conditions are verified and the `if` block action is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This number satisfies the first condition, being above `10`, but fails the
    other two since it is not equal to or below `20` and it is not even. So the else
    block action is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Not even this number is good. It satisfies the first condition, being above
    `10`, but fails the second since it is not equal to or below `20`. The third condition
    is satisfied, but this is not enough. So the else block action is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, when dealing with multiple conditions, we have to be really
    careful about what we write and think about the outcome since sometimes we could
    get something we did not actually want. A rule of thumb, try to keep your conditions
    as simple as you can or take your time to check them thoroughly. Did we say simple?
    Look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using an arithmetic evaluation compound command and negate it to check
    whether a number is even: if it is not true that the modulo operation fails, then
    the condition is verified. But, look, we have no `else` block, we just evaluate
    the `if` condition and exit the conditional because we are not interested in reacting
    to any other cases. This is typical, for instance, counter exit conditions, as
    we saw before: we want to exit the loop if the counter reaches a specific value,
    otherwise we let the cycle run. Let''s have a look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The modulo operation does not give a result. Have a look at the return code
    of this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we are, the return code is `1`, which means it is not OK for us. So
    if a number passed through a modulo operation and gives `0`, the return code is
    failure and this means that dividing the number by two has no reminder. All this
    means that if a number is divisible for `2`; for example, it does not give us
    any reminder from the division, and it is even. Now, let us try an odd number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'No `then` block action is triggered, since this is an odd number. Let us verify
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The operation is successful so we have to get some remainder. Double check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have `12` as a remainder of the division of `25` by `2`. So now the condition
    we saw in the previous script is clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement is fulfilled if the modulo by two arithmetic operation fails.
    So, if a number is not divisible by `2` it is even, simple. Now it is time to
    take a look at how we can test our conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Test command recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen in some of our previous examples, we used the shell `built-in`
    test to perform some checks on variables and files along with the conditional
    `if...then` so that we could make our script react to conditions: if the test
    is successful it returns `0`, if it is not, `1`, and these are the values that
    triggered our reactions so far.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a couple of different notations to execute a test and we already
    saw them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We already spoke about the differences between the two, but let us quickly
    recap them before proceeding:'
  prefs: []
  type: TYPE_NORMAL
- en: The single bracket implements the standard POSIX compliant `test` command and
    it is available in all POSIX shells. `[` is actually a command whose argument
    is `],` and this prevents the single brackets from receiving further arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some Linux versions still have a `/bin/[` command, but the `built-in` version
    has the precedence in execution.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The double brackets is only available in Bash, `zsh`, and `korn` shells.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The double brackets is a keyword, not a program, available from the 2.02 version
    of the Bash and offers some great features, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `=~` operator for regular expression matching
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The `=` or `==` are available for pattern matching
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `<>` without having to escape the `\> \<`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `&&` instead of `-a` and `||` instead of `-o`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You do not need to escape the parenthesis `\( \)` to group expressions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Glob expansion so a `*`can expand to everything, and this comes handy in pattern
    matching
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You do not have to quote variables to keep safe spaces inside them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, it seems that the double brackets gives us a bit of flexibility more than
    the old command, but before using it widely think about the audience of your scripts.
    If you want them available across different shells and, inside the same Bash,
    across different versions try to avoid using commands or built-ins that are only
    available in some of them. Sticking with the POSIX standard will make your scripts
    widely shareable, but as a drawback, they will lack the advanced features that
    some keywords such as double brackets have to offer. So, wisely balance your writing
    style and adopt the strategy that best matches your goals. We, when possible,
    will use the single bracket notation just to be as compatible as we can.
  prefs: []
  type: TYPE_NORMAL
- en: Testing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is quite a lot to say about testing and one of the most common tasks
    is checking files on the filesystem or if a directory is available or has some
    rights. So, imagine a script that has to write some data in a file inside a directory:
    first, we should check whether the directory exists, then if we can write into
    it, and finally if there is no name collision between the file we are going to
    open for writing and an already existing file. So let''s have a look at which
    operators we use to execute some tests on files and devices and remember that
    they return `true` if the condition is met:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-e`: Returns true if a file exists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We just verified that the file `test-files.sh` exists since `ls` shows it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Our test confirms it with a nice message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s verify now that a file named `aaaaa` is not present in our current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, there is no file with such a name; let us do a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, as you can see, we used a semicolon to divide the different parts of
    the statement. In a script, we would have seen the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Each single command must be properly terminated either by a new line or a `;`.
    Each chunk of code delimited by a `;` will be executed before the following without
    the need for a new line.
  prefs: []
  type: TYPE_NORMAL
- en: '`-a`: This has the same purpose of `-e`, but it is deprecated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b`: This checks whether the file is actually a block device, like a disk,
    a CD-ROM, or a tape device:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`-d`: This checks whether a file is actually a directory or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`-f`: This checks whether a file is a regular file and does not represent something
    like a character device or a directory or a block device:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, this is a file that represents a terminal, so it is clearly not a regular
    file as `test.file` could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`-c`: This tests if the argument is a character file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`-s`: This is true if the file is not of `0` size:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we just *touched* the file, so we created it with `0` byte size. Let''s
    fill it with a character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s repeat the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`-g`: This is true if the directory has a `sgid` flag set. As we saw, the set
    group ID imposed on a directory forces the files newly created into it to be owned
    by the group who owns the directory itself:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`-G`: This is true if the group ID is the same as that of yours. Let''s test
    on a file first:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And now on a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s double-check changing the group owner of `test.file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`-O`: This is true if you are the owner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`-N`: This is true if the file was modified since the last read. This can become
    handy when you want to backup a file or just see if new information has been added.
    A typical scenario would be a log file or a data file being fed by a process,
    a service: if in a certain amount of time, the file has not been modified it probably
    means that the process is not running or not working properly so we can probably
    do something like restart it. So, let''s have a look at one of our previous scripts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, the files seems to have not been modified lately, so it is time to modify
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Remember that in all the tests when we say that the test is true
    when the condition is verified, we imply a second condition that is the file must
    exist. So in this case, we would say, it is verified if the file exists and has
    not been modified from last read. Also remember that in Unix everything is a file,
    so a directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`-u`: This is true if the `suid` bit is flagged. This kind of test can become
    quite useful for different reasons related to the fact that when you run an executable
    it usually runs with the privileges of the user who invoked it. With the `suid`
    bit flagged the executable is run with the privileges of the owner of that executable
    file not with the ones of the invoker also not with those of the one who invoked
    it. So, a program owned by root with the `suid` bit flagged can be a real harm
    to the security of a system since whoever invokes it has the root rights over
    the system itself. On the other side of the medal some programs, especially those
    that must have root rights to access a device, need to have the `suid` bit flagged
    because this allows a normal user to access the devices as root without having
    to access the full root environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`-k`: This is true if the `sticky` bit is flagged. This kind of privilege is
    really interesting because if imposed on a file, it will have the file held in
    memory resulting in faster access, but applied to a directory it restricts the
    user rights: only the directory owner of the owner of the file inside a directory
    with a sticky bit set will be able to delete the file itself. This comes really
    handy in a collaborative environment where several users have their working file
    in the same directory, and applying the sticky bit on it will give the file owners
    the right to delete their files only:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`-r`: This is true if the read permission is set for the user executing the
    test:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the user can read the file, let''s check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh, well, the file is owned by root and root has read access, so why was the
    test successful if the read is granted to root? Simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: What happened? The first time we tried the test the owner was root, but the
    user `zarrelli` was still able to read the file through group permission and other
    permission. So, clearing those bits made the file readable only by the root user,
    no one else.
  prefs: []
  type: TYPE_NORMAL
- en: '`-w`: This is true if the write bit is set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Interesting, let''s have a look at the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, only the root user can write to it. Would you like to try and fix the
    issue then run the test again?
  prefs: []
  type: TYPE_NORMAL
- en: '`-x`: This is true if the execution bit is set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the access permissions on the file are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'So no execute bit for the user. Now, let''s test a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Interesting, time to see the permissions on the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'What are those dots and double dots? Let''s have a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind the first column. These are the **inode** numbers related to `.`.
    and`..`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The inode of `.` inside the `test` directory has the value of `5900830`, so
    now we go up one directory, and we can see that the test directory has an inode
    value of `5900830`. So, we can safely say that `.`points to the directory we are
    in. And what about `..`? Look at the value of `.`in the parent directory, it is
    `5899440`. Now look inside the `test` directory to the value of `..`, it is `5899440,`
    and so we can safely say that`..`points to the parent directory since both point
    to the same inode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly, to understand what relates an inode to a file, we can say that in
    a Unix style file system, an inode is a metadata structure describing file and
    directories attributes, such as type timestamp, size, access rights, links count,
    and pointers to the disk block holding the data that make up a file or directory
    content. Each inode number is practically an index that allows the kernel to access
    a file or directory, its content and attributes, such as an index in an array.
    And actually, you can know quite a bit of a file if you know how to look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: So, what we can say is that something pointing to the same inode number is pointing
    to the same data structure, the same file or directory, and that is what links
    the `..` and `.`to the representation of the parent and local directory as we
    proved by following the inode numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '`-h -L`: This is true if a file is a link. A link is a pointer to another file
    and you can have either a soft or hard link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A soft link is a reference to a file that can span across different filesystems.
    It is a special kind of file holding a reference to another file, so when the
    operating system tries to access the link, it recognizes it as a link and redirects
    all the operations to the actual file pointed by it. If the target is removed
    the link remains, but points to nothing. The main limits of a soft link is that
    it creates an overhead in the operations; the OS must redirect all the operations
    from it to the target.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: A hard link is another file pointing to the same inode and because inodes are
    a metastructure of a file system, a hard link cannot span across filesystems.
    Once the original file is deleted, the hard link is not affected since it points
    to a valid inode, which actually remains on the file system even if the file is
    deleted. A limit is that it cannot point to a directory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, to make it easy, we can say that the soft link is a pointer by name to
    a file, whereas a hard link is a pointer by inode. Let''s see some differences
    in play starting with a soft link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s `cat` the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s remove the original file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And verify if we can access the content through the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is clear with `ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The link is still there, but the original file is gone, so when the OS tries
    to reach it, it fails. Let us recreate the original file and the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s link across the `/boot` filesystem. First, let''s check that `/boot`
    is mounted on its own partition and filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, it is really another filesystem, so let''s soft link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'And access the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, something has gone wild. What is happening? Have a look with `ls -lah`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the link points to `test.file` in `/boot` even though we linked from
    another directory. We need an absolute reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'And now it works. Finally, let''s see what happens if we try to link a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We linked `new.test` to the `test` directory and now just check that the `test`
    directory is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a file using the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s see what is in test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here we are; we can reach the data inside test using the `new.test` soft link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to hard link across filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: No way! We cannot reference with a hard link across filesystems; the inode restriction
    is preventing us from doing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to link a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, no good to go. Now, let us try to hard link in the same filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'No problem, but let''s have a look at the inodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The hard link points to the same inode of the original file, the soft link
    does not. Now remove the original file again and try to `cat` the hard and soft
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'As we expected, the soft link failed because there is no filename to point
    to, the hard link succeeded because the inode is still there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick rule of thumb is do not use soft link to reference frequently accessed
    files, such as web pages, use them for `config` files for instance, as they are
    just read at the startup. Soft links are slow. Hard links are good for referencing
    files and preserve their content despite what happens to the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-p`: This is true if the file is a pipe. Recall for a while what we said in
    the first chapter about pipes and named pipes; they are a way to get different
    processes to communicate between each other. If a process is spawned by a parent
    is not a big deal, they share the same environment and the same file descriptors,
    on the open descriptor of the parent process, the child will be able to read data
    in the same order it was written with a buffer kernel to host the bits waiting
    to be read. For processes that do not share a common environment we can use a
    pipe that leverages a file that the processes can cling to: this file can last
    longer than the processes that make use of it, usually until a reboot and can
    be deleted or redirected. These kinds of interprocess communication structures
    are called **named pipes** or **First In First Out** (**FIFO**) pipes, based on
    the order of the data processed. Let us make an example and create a pipe, either
    with `mkfifo` or `mknode`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s open a second terminal and issue, in the same directory, the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The process will hang waiting for something to read. Now, let''s go back to
    the first terminal and write something to the named pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now back to the second terminal to check what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see more on named pipes in one of the next chapters, now we will just
    check if `myfifo` is really a named pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '`-S`: This is true if it is a socket. As we already saw, a socket is an endpoint
    between two devices on the same system or across the network and it allows the
    devices to exchange data, quite as we saw for pipes and named pipes. As you can
    easily guess, a Linux system has quite a bunch of sockets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can double-check looking for and in the property of the file as listed
    by `ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We can see an *s* character at the beginning of the permissions list, and this
    is what tells has that this file is exactly a socket, as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: '`-t`: This is true if a file is linked to a terminal. A classic use for this
    test, as you will find almost in all guides, is to check if a `stdin` or a `stderr`
    in a script is linked to a terminal. Let''s check what the `stdout` of our shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Need to double-check it? Simple, since the output of our command issued in the
    current shell has been printed to our monitor, which is connected to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '`file -ntother_file`: This is true if the file is newer than other files, comparison
    made on their modification dates. Let''s have a look:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what did we do? We simply chained some commands, and since `other_file`
    must be the older piece, we started off creating it. Then, we setup a simple "for"
    loop iterating between `1` and `10` doing nothing, as implied by the double colon,
    since we had to let some time pass before creating the newer file. Passed `10`
    iterations we created a new file and compared the two. One thing that appears
    interesting in this example is the use of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a construct available since Bash newer than 3.0\. Let us quickly set
    up a range writing the starting number and the ending one. From Bash newer than
    4.0, we can also define a range with increments, in the form of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, added few things here: the cycle now goes from `1` to `120` in steps
    of 2 and prints out a message only if the cycle number can be divided by 5, so
    we will not clutter the screen. Finally, we wait for one sec at each cycle using
    the sleep command to ensure that at the end of the cycle we spent 60 seconds before
    creating the last file and making the comparison.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also modify the date of a file using a specific date, even back in the
    past, using touch with the format `-t YYMMDDHHmm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`zarrelli:~$ ls -lahtest.file`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-rw-r--r-- 3 zarrellizarrelli 0 Feb 12 14:56 test.file`'
  prefs: []
  type: TYPE_NORMAL
- en: '`touch -t 8504251328 test.file`'
  prefs: []
  type: TYPE_NORMAL
- en: '`zarrelli:~$ ls -lahtest.file`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-rw-r--r-- 3 zarrellizarrelli 0 Apr 25 1985 test.file`'
  prefs: []
  type: TYPE_NORMAL
- en: '`file -otother_file`: This is true if the file is older than `other_file`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'And indeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Now just touch the `userinput-or.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '`file -efother_file`: This is true if the file and other files share the same
    inode number and device. Have you already heard about files with the same inode
    number and that they cannot be on different devices? Yes, we call them hard links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s double-check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: All three files share the same inode and, since the inode is a metastructure
    of a file system, a single file system.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with the file comparison, but there is some more that we have to
    see, for instance how we can test integers since they are quite a common presence
    in all the script we see around the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Testing integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw with comparisons between files, we can do much the same thing with
    integers using some binary operators. This comes handy in case we want to take
    a decision based on the value a variable has taken, as we saw in earlier examples,
    and it is a type of action widely performed when dealing with scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-eq`: This is true if the first integer is equal to the second:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is quite simple, it does not sports any checks on the input but even
    though it is so bare bones it fits our purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '`-ne`: This is true if the first integer is not equal to the second integer.
    Let''s just modify the previous script a bit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s execute the new bunch of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '`-gt`: This is true if the fist integer is greater than the second integer.
    Again, let''s modify a bunch of lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '`-ge`: This is true if the first integer is greater than or equal to the second
    integer. Here are a few amendments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'And now here are some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '`-lt`: This is true if the first integer is less than the second integer. So,
    another small amendments are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'And now a couple of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '`-le`: This is true if the first integer is less than or equal to the second:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the usual tests are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a bunch of operators that can be used with the double parenthesis
    notation, which performs an arithmetic expansion and evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<`: This is true if the first integer is less than the second. Here is the
    modified code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '`<=`: This is true if the first integer is less than or equal to the second.
    Just a small change to the previous code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'And the usual tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '`>`: This is true if the first integer is greater than the second. Just a small
    change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'And the usual tests because we are testing all we are writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '`>=`: This is true if the first integer is greater than or equal to the second:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s run some checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Testing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just saw some interesting comparisons, but now things start to become more
    interesting because we are going to introduce some tests on strings, and this
    brings us a step forward in what we can do to make our scripts more reactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=`: This is true if the first string is equal to the second string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'And now some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'And now some checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Something weird, isn''t there? We just got rid of spaces around the equal sign
    and now it does not work anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Those spaces are actually more important than you could think. Our comparison
    became an assignment! So, be careful!
  prefs: []
  type: TYPE_NORMAL
- en: '`==`: This is true if the first string is equal to the second string, but it
    has a different behavior than `=` when it comes to double brackets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Matches as long as the first string starts with the character entered for the
    second string, the `*` will match whatever characters in the second string after
    what you entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we match with spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Be careful, with single brackets, the behavior of this operator changes due
    to file globbing and word split being in action.
  prefs: []
  type: TYPE_NORMAL
- en: '`!=`: This is true if the first string is not equal to the second, but keep
    in mind that there is a pattern matching in place; so we are going to change the
    previous script a bit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the tests are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '`<`: This is true if the first string is less than the second in ASCII alphabetical
    order. So, let''s modify the script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here are some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful, with single brackets, the < sign must be escaped, so the condition
    becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if [ ${user_input1} \< ${user_input2} ]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`>`: This is true if the first string is greater than the second in ASCII alphabetical
    order. So, let''s modify the script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'And now some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Well, actually the `@` sign has a value of `40` in the ASCII table and `A` has
    a value of `41`, so `A` is greater than `@`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful, with single brackets, the > sign must be escaped so the condition
    becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if [ ${user_input1} \> ${user_input2} ]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-z`: This is true if the string is null. Here are a bunch of lines to verify
    this condition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'And now a couple of checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in case of a `null` value, nothing is printed on the screen
    when we `echo` the variable value.
  prefs: []
  type: TYPE_NORMAL
- en: '`-n`: This is true if the string is not null. Just a minor change to the previous
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: And now some tests
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you test a variable, quote it! Unquoted variables can lead to weird
    results, especially when dealing with null values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at how the results change with a test with single brackets and
    unquoted variables. Keep in mind that `user_input2` is not instanced, so its value
    is `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Well, as you can see, quoting matters!
  prefs: []
  type: TYPE_NORMAL
- en: More on tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just saw some tests with one condition checked at a time, but we also have
    the equivalent of `&&` and `||`, so we can have compound checks and test more
    conditions at once, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-a`: It is a logical AND, so it is true when both conditions checked are true.
    We use this operator with the test command or in single brackets. Let''s rewrite
    one of the previous scripts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'And now some tests are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '`-o`: It is a logical OR and true if either conditions are true. We use this
    operator with the test command or in single brackets. Let''s rewrite some lines
    from the previous example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'And now some checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now a number is acceptable if it is between `10` and `20` or it is even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We finally got into something interesting. Not that the previous chapters were
    less important, but with the tests, we just saw that we are now able to create
    some conditional statements and let our script react to different situations.
    It is not just an echo of a variable, but we get to its value, work on it, decide
    what to do, and act accordingly. In this chapter, we had a quick bite of what
    flexibility means in a script: it must be a tool and that makes one of the main
    goals of writing a script: it must be a tool that makes decisions on our behalf
    and react as we want it to do based on the conditions that we crafted in advance.'
  prefs: []
  type: TYPE_NORMAL
