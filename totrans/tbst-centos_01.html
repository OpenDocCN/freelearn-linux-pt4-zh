<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Basics of Troubleshooting CentOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Basics of Troubleshooting CentOS</h1></div></div></div><p><span class="strong"><strong>CentOS</strong></span>, the<a id="id0" class="indexterm"/> <span class="strong"><strong>Community Enterprise Operating System</strong></span>, is known to be a robust, stable, and trouble-free platform that is particularly well suited to the role of a server. Used by organizations of all sizes, CentOS can be found in many mission-critical environments the world over. However, as servers are expected to work on demand and without interruption, there will be times when a calm but firm hand is required to restore a service or to make some final adjustments to an existing application in order to ensure that a "working state" can be resumed as quickly as possible:</p><p><span class="emphasis"><em>"The server has gone down and all hell is about to break loose."</em></span></p><p>In a less than perfect world, things can (and inevitably do) go wrong, but it is your overall understanding of CentOS 7 and the confidence it provides that will form the basis of your troubleshooting skills. Remember, troubleshooting is a process of investigation that ultimately leads to a diagnosis. All systems are different and every approach to the same situation can vary depending on the purpose of that system. So, with this in mind, it is important to realize that the premise of this book is not recipe-driven, but more about the tools that are used and the resources you will be expected to encounter and interact with.</p><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn how to install some basic tools on CentOS</li><li class="listitem" style="list-style-type: disc">Discover how to gather hardware-based system information using <code class="literal">lscpu</code> and <code class="literal">lspci</code></li><li class="listitem" style="list-style-type: disc">Learn more about the importance of <code class="literal">dmesg</code> and how it interacts with the kernel</li><li class="listitem" style="list-style-type: disc">Learn about the more common log files and how they affect the log output</li><li class="listitem" style="list-style-type: disc">Learn how to manipulate files of any description using <code class="literal">grep</code>, <code class="literal">tail</code>, <code class="literal">cat</code>, <code class="literal">less</code>, <code class="literal">truncate</code>, and many more command-line functions</li></ul></div><div class="section" title="Installing some basic tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Installing some basic tools</h1></div></div></div><p>During<a id="id1" class="indexterm"/> the course of this book, it is assumed that you will already have access to the basic tools associated with troubleshooting your server. Some of the more obscure tools will be mentioned and instructions will be given; however, for those who may or may not have access to the basic toolbox, as the root user you may want to begin by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum groupinstall "Base" "Development Libraries" "Development Tools"</strong></span>
</pre></div><p>This action, if and when confirmed, will begin to download and install the common development tools, libraries, and base components of a CentOS server system. It also contains the relevant utilities required by RPM, additional text editors, and packages required to compile custom packages.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The practice of installing these packages at the outset is optional and all of these packages can be installed individually (as and when required). However, in an environment where disaster recovery planning has a vital role to play, it is worth considering the notion that a server has everything in place before any issues arise.</p></div></div><p>So, having prepared the system with the necessary tools and utilities, we shall begin in earnest by taking a closer look at the hardware. To do this, it is recommended that you continue with root access to the system in question.</p></div></div>
<div class="section" title="Gathering hardware information"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Gathering hardware information</h1></div></div></div><p>As a matter of<a id="id2" class="indexterm"/> principle, most people will tend to suggest that all system information can be categorized as either hardware-or-software based. This<a id="id3" class="indexterm"/> approach certainly serves to simplify things, but throughout the course of this chapter I will go some way to infer that there are instances in which the interplay of both (hardware and software) can be the reason for the issues at hand.</p><p>So, before you begin troubleshooting a system, always consider that the need gathering information about a system is the recommended approach to gaining additional insight and familiarity. Look at it this way: the practice of gathering hardware information is not necessarily required, but an investigation of this type may assist you in the search for an eventual diagnosis.</p><p>To begin, we will start by running a simple CPU-based hardware report with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /proc/cpuinfo</strong></span>
</pre></div><p>As you will see, the<a id="id4" class="indexterm"/> purpose of this command is to output all information related to the CPU model, family, architecture, the cache, and much more. The <code class="literal">/proc</code> approach <a id="id5" class="indexterm"/>is always a good tradition, but using the following command is generally considered to be a better practice and far easier to use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># lscpu</strong></span>
</pre></div><p>This command will query the system and output all relevant information associated with the CPU in the following manner:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Architecture:          x86_64</strong></span>
<span class="strong"><strong>CPU op-mode(s):        32-bit, 64-bit</strong></span>
<span class="strong"><strong>Byte Order:            Little Endian</strong></span>
<span class="strong"><strong>CPU(s):                2</strong></span>
<span class="strong"><strong>On-line CPU(s) list:   0,1</strong></span>
<span class="strong"><strong>Thread(s) per core:    1</strong></span>
<span class="strong"><strong>Core(s) per socket:    2</strong></span>
<span class="strong"><strong>Socket(s):             1</strong></span>
<span class="strong"><strong>NUMA node(s):          1</strong></span>
<span class="strong"><strong>Vendor ID:             GenuineIntel</strong></span>
<span class="strong"><strong>CPU family:            6</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>On the other hand, rather than querying absolutely everything, you can specify criteria by using <code class="literal">grep</code> (a subject that we will return to a little later in this chapter) in order to obtain any pertinent information, like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># lscpu | grep op-mode</strong></span>
</pre></div><p>So, having done this and recorded the results for future reference, we will now continue our investigation by running a simple hardware report with the <code class="literal">lspci</code> command in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># lspci</strong></span>
</pre></div><p>The result of this command may output something similar to the following information:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>00:00.0 Host bridge: Intel Corporation 82P965/G965 Memory Controller Hub (rev 02)</strong></span>
<span class="strong"><strong>00:01.0 PCI bridge: Intel Corporation 82G35 Express PCI Express Root Port (rev 02)</strong></span>
<span class="strong"><strong>00:05.0 Ethernet controller: Red Hat, Inc Virtio network device</strong></span>
<span class="strong"><strong>00:0a.0 PCI bridge: Digital Equipment Corporation DECchip 21150</strong></span>
<span class="strong"><strong>00:0e.0 RAM memory: Red Hat, Inc Virtio memory balloon</strong></span>
<span class="strong"><strong>00:1d.0 USB controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 02)</strong></span>
<span class="strong"><strong>00:1d.7 USB controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB2 EHCI Controller (rev 02)</strong></span>
<span class="strong"><strong>00:1e.0 PCI bridge: Intel Corporation 82801 PCI Bridge (rev f2)</strong></span>
<span class="strong"><strong>00:1f.0 ISA bridge: Intel Corporation 82801HB/HR (ICH8/R) LPC Interface Controller (rev 02)</strong></span>
</pre></div><p>The <code class="literal">lspci</code> command <a id="id6" class="indexterm"/>provides all the relevant information<a id="id7" class="indexterm"/> concerning the PCI devices of your server, which in turn, can be expanded by employing either the <code class="literal">-v</code> option or the alternative <code class="literal">-vv</code> / <code class="literal">-vvv</code> option(s), depending on the level of detail you require:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># lspci -v</strong></span>
<span class="strong"><strong># lspci -vv</strong></span>
<span class="strong"><strong># lspci -vvv</strong></span>
</pre></div><p>By default, the above commands will provide all the information required by you to confirm whether a device is supported by any of the modules currently installed on your system or not. It is expected that you should only need to do this when hardware upgrades have been implemented, when the system has just been installed, or if you are attempting to familiarize yourself with a new environment. However, in order to simplify this exercise even further, you will be glad to know that a "tree view mode" is also available. The purpose of this facility is to output the associated device ID and show how these values are associated with the relevant bus.</p><p>To do this, type the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># lspci -t</strong></span>
</pre></div><p>As a troubleshooter, you will be aware that every device must maintain a unique identifier as CentOS, like all other operating systems, will use that identifier to bind a driver to that device. The <code class="literal">lspci</code> command works by scanning the <code class="literal">/sys</code> tree for all connected devices, which can also include the connection port, the device type, and class, to name but a few. Having done this, the <code class="literal">lspci</code> command will then consult <code class="literal">/usr/share/hwdata/pci.ids</code> to provide the human-readable entries it displays.</p><p>For example, you can display the kernel drivers/modules by typing the following <code class="literal">lspci</code> command with the <code class="literal">-k</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># lspci -k</strong></span>
</pre></div><p>Naturally, during any hardware-based troubleshooting investigation you will want to review the system logs for additional clues, but as we have seen, both the <code class="literal">lscpu</code> and <code class="literal">lspci</code> commands are particularly useful when attempting to discover more about the necessary hardware information present on your system.</p><p>You can learn more <a id="id8" class="indexterm"/>about these commands by reviewing the respective on-board manuals at any time:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ man lscpu</strong></span>
<span class="strong"><strong>$ man lspci</strong></span>
</pre></div><p>Meanwhile, if you want<a id="id9" class="indexterm"/> to practice more, a simple test would be to insert a USB thumb drive and to analyze the findings yourself by paying close attention to the enumeration found within <code class="literal">/var/log/messages</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Remember, if you do try this, you are looking at how the system reacted once the USB drive was inserted; you are not necessarily looking at the USB drive itself; the information about which can be obtained with <code class="literal">lsusb</code>.</p></div></div><p>On the other hand, in the same way that we can use <code class="literal">grep</code> with <code class="literal">lscpu</code>, if you are already feeling comfortable with this type of investigation, then you may like to know that you can also use <code class="literal">grep</code> with the <code class="literal">lspci</code> command to discover more about your RAID controller in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># lspci | grep -i raid</strong></span>
</pre></div><p>Now, I am sure you will not be surprised to learn that there are many more commands associated with obtaining hardware information. This includes (but is not limited to) <code class="literal">lsmod</code>, <code class="literal">dmidecode</code> <code class="literal">hdparm</code>, <code class="literal">df -h</code>, or even <code class="literal">lsblk</code> and the many others that will be mentioned throughout the course of this book. All of them are useful, but for those who do not want to commit them to memory, a significant amount of information can be found by simply reading the files found within the <code class="literal">/proc</code> and <code class="literal">/sys</code> directories like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># find /proc | less</strong></span>
<span class="strong"><strong># find /sys | less</strong></span>
</pre></div><p>Consequently, and before we move on, you should now be aware that when you are dealing with hardware analysis, perfecting your skills is about practice and exposure to a server over the long term. My reason for stating this is based on the notion that a simple installation procedure can serve to identify these problems almost immediately, but without that luxury, and as time goes by, it is possible that the hardware will need replacing or servicing. RAID Battery packs will fail, memory modules will fail, and, on some occasions, it could be that a particular driver has not fully loaded during the most recent reboot. In this situation, you may find that the kernel is flooding the system with random messages to such an extent that it suggests an entirely different issue is causing the problem. So yes, hardware troubleshooting requires a good measure of patience and observation, and it <a id="id10" class="indexterm"/>is for this reason that a quick review of both the <code class="literal">lscpu</code> and <code class="literal">lspci</code> commands<a id="id11" class="indexterm"/> has formed our introduction to troubleshooting CentOS 7.</p></div>
<div class="section" title="Understanding dmesg"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Understanding dmesg</h1></div></div></div><p>Before we <a id="id12" class="indexterm"/>dive into the subject of log files, I would like to begin by spending a few moments to discuss the importance of the <code class="literal">dmesg</code> command.</p><p>The <code class="literal">dmesg</code> command is <a id="id13" class="indexterm"/>used to record messages from the kernel that are specifically related to the process of hardware detection and configuration. I will not go in too much technical detail at this point, but it is important to realize that these messages are derived from the kernel ring buffer; a condition that can not only prove to be of great assistance because it relates back to the subject of hardware troubleshooting, but one that provides evidence as to why an understanding of the system hardware can reflect in a possible software diagnosis and vice versa.</p><p>The <code class="literal">dmesg</code> file <a id="id14" class="indexterm"/>is located in the <code class="literal">/var/log/</code> directory, but unlike other files that reside in that directory, the basic syntax to view the contents of the <code class="literal">dmesg</code> file is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dmesg | less</strong></span>
</pre></div><p>You can page through the results in the usual way, but if you would like to make the timestamp a little easier to read, you may want to invoke the <code class="literal">-T</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dmesg -T | less</strong></span>
</pre></div><p>These commands will now provide us with information related to all the hardware drivers loaded into the kernel during the boot sequence. This information will include their status (success or failure), and if a failure is recorded, it will even provide an error message describing why a failure took place. However, as this file can be quite overwhelming, you should use <code class="literal">grep</code> to query <code class="literal">dmesg</code> in order to streamline this information and simplify the output.</p><p>To do this, simply customize the following syntax to suit your needs:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dmesg -T | grep -i memory</strong></span>
</pre></div><p>This command will now display all relevant information regarding the total memory available and shared memory details associated with the server. Of course, similar approaches can be made to read the specific information for USB devices, direct memory access (DMA), or even tty.</p><p>For example, you can query <code class="literal">dmesg</code> to display hardware information related to any Ethernet ports in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dmesg –T | grep -i eth0</strong></span>
</pre></div><p>Depending on <a id="id15" class="indexterm"/>your system configuration, the output will look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Sun Apr 19 04:56:57 2015] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready</strong></span>
</pre></div><p>To extend this approach, you<a id="id16" class="indexterm"/> can then modify the previous command in order to discover whether the kernel has detected a specific hard disk. To do this, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dmesg –T | grep sda</strong></span>
</pre></div><p>Alternatively, you can then use the <code class="literal">-i</code> option to ignore the effects of case sensitivity when searching for <code class="literal">tty</code> references:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># dmesg | grep -i tty</strong></span>
</pre></div><p>As you will see, the output of the <code class="literal">dmesg</code> file is verbose and the information contained within it can be used to troubleshoot almost anything from network cards to storage issues. The <code class="literal">demsg</code> file<a id="id17" class="indexterm"/> may not give you the answer you are looking for straightaway, but it does provide you with another piece of the puzzle when it is used in combination with the information found in some of the more common log files associated with the CentOS operating system.</p></div>
<div class="section" title="Understanding log files"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Understanding log files</h1></div></div></div><p>By default, all<a id="id18" class="indexterm"/> CentOS <a id="id19" class="indexterm"/>system log files can be found in <code class="literal">/var/log</code> and a full inventory on your current server can be obtained by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># find /var/log</strong></span>
</pre></div><p>With that said, every system is different, and for overall simplicity, you will find that some of the more common log files (associated with a minimal installation of CentOS 7) will include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/messages</code>: This file <a id="id20" class="indexterm"/>contains information related to the many native services used by CentOS. This includes (but is not limited to) the kernel logger, the network manager, boot process, mail services, <code class="literal">cron</code> jobs, and many other services that do not have their own log files. In many respects, this record can be considered to be a global log file of sorts, and out of habit, it will probably become your first port of call in any troubleshooting process.</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/boot.log</code>: This<a id="id21" class="indexterm"/> file contains information that is reported when the system boots.</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/maillog</code>: This<a id="id22" class="indexterm"/> file contains information that is reported by the default mail server used by the system.</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/secure</code>: This <a id="id23" class="indexterm"/>file contains information that is related to the associated authentication and authorization privileges.</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/wtmp</code>: This <a id="id24" class="indexterm"/>file contains information related to user login records.</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/btmp</code>: This <a id="id25" class="indexterm"/>file contains information related to failed login attempts.</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/cron</code>: This<a id="id26" class="indexterm"/> file contains information related to cron (and anacron).</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/lastlog</code>: This <a id="id27" class="indexterm"/>file contains information related to the binary log that contains all of the last login information.</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/yum.log</code>: This<a id="id28" class="indexterm"/> file contains information related to Yum and reports any activity related to the server's package management tools.</li></ul></div><p>Now, before we continue, I want to draw your attention towards the importance of these files as it is often a good idea to store <code class="literal">/var/log</code> in a separate partition to <code class="literal">/</code> (root).</p><p>A perfect system would maintain a separate partition for <code class="literal">/tmp</code>, <code class="literal">/usr</code>, and others, but yes, there may be situations where storing your log files on the same partition as <code class="literal">/</code> (root) is unavoidable. So remember, if and when the opportunity does arise, you may want to consider storing these directories on a separate filesystem and a separate physical volume (if possible), as this is considered to be good practice with regard to maintaining the overall security, integrity, and performance of the system in question.</p><p>However, and having said that, it is also important to recognize that many other packages will create and store logs in other locations. You may even be required to specify these locations yourself, and for this reason, it should be remembered that not all logs are located in <code class="literal">/var/log</code>.</p><p>For example, if the server in question is hosting one or more websites and storing all the relevant Apache VirtualHost information in a specific <code class="literal">/home</code> directory, then the associated log files may be found in a location like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/path/to/virtualhost/domain1/log/access_log</strong></span>
<span class="strong"><strong>/path/to/virtualhost/domain1/log/error_log</strong></span>
</pre></div><p>The same can be said of many other packages, and this issue arises because the packages may not have the required privileges to write to that directory, while others are designed to maintain all logging activity within their own installation directory. Therefore, and depending on the nature of your system, you may need to spend a few moments analyzing your server's installation structure in order to locate the appropriate log file(s).</p></div>
<div class="section" title="Reading log files and affecting the output"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Reading log files and affecting the output</h1></div></div></div><p>Viewing<a id="id29" class="indexterm"/> or reading a log file is very easy and depending on <a id="id30" class="indexterm"/>your personal preferences, the basic syntax to view any of these files can be expressed in any of the following formats:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># less /var/log/filename</strong></span>
<span class="strong"><strong># more /var/log/filename</strong></span>
<span class="strong"><strong># cat /var/log/filename</strong></span>
<span class="strong"><strong># cat /var/log/filename | less</strong></span>
<span class="strong"><strong># cat /var/log/filename | more</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Remember, depending on the system configuration, you may need root privileges to view a specific log file. The same can be said when you are attempting to make changes to any system files, and for this reason, we will continue as the root user. However, those who use <code class="literal">sudo</code> or <code class="literal">su</code> (switch user) should change the instructions accordingly.</p></div></div><p>Log files can vary between applications and services, but the general purpose of these files is to record the time and date of an event and the security level, and to provide a message or general description. Most messages will be general notices or warnings of one type or another, but on certain occasions, errors will also be trapped.</p><p>For example, you may see something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Dec  4 12:49:05 localhost postfix/postfix-script[1909]: starting the Postfix mail system</strong></span>
</pre></div><p>Messages like this are quite ordinary and merely explain what is happening and when it happened. Yes, you can safely ignore them, but due to the number of messages you see, some may remark or feel that the system is acting a little oversensitive to the extent that a log file is being flooded with low-level information. This information may serve no real purpose to many, but in some circumstances, you may consider that the information supplied isn't sensitive enough, and more information is needed. In the end, only you can decide what best suits <a id="id31" class="indexterm"/>your needs. So, in order to take a case in point, let's increase log sensitivity for the purpose of troubleshooting the system.</p><p>To do this, we will <a id="id32" class="indexterm"/>begin by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /proc/sys/kernel/printk</strong></span>
</pre></div><p>The output of the preceding command enables you to view the current settings for the kernel, which, on a typical system, will look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>4       4       1       7</strong></span>
</pre></div><p>There is a relationship at work here, and it is important that you understand that <code class="literal">printk</code> maintains four numeric values that control a number of settings related to the logging of error messages, while every error message in turn maintains its very own log level in order to define the importance of that message.</p><p>The <a id="id33" class="indexterm"/>log level values can be summarized in the following way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">0</code>: Kernel emergency</li><li class="listitem" style="list-style-type: disc"><code class="literal">1</code>: Kernel alert; action must be taken immediately</li><li class="listitem" style="list-style-type: disc"><code class="literal">2</code>: Condition of the kernel is considered critical</li><li class="listitem" style="list-style-type: disc"><code class="literal">3</code>: General kernel, error condition</li><li class="listitem" style="list-style-type: disc"><code class="literal">4</code>: General kernel, warning condition</li><li class="listitem" style="list-style-type: disc"><code class="literal">5</code>: Kernel notice of a normal but significant condition</li><li class="listitem" style="list-style-type: disc"><code class="literal">6</code>: Kernel informational message</li><li class="listitem" style="list-style-type: disc"><code class="literal">7</code>: Kernel debug-level messages</li></ul></div><p>So, based on the above information, the log level values of <code class="literal">4</code>, <code class="literal">4</code>, <code class="literal">1</code>, and <code class="literal">7</code> tell us that the following is now apparent:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first value (<code class="literal">4</code>) is called the console log level. This numeric value defines the lowest priority of any message printed to the console, thereby implying that the lower the priority, the higher the log level number.</li><li class="listitem" style="list-style-type: disc">The<a id="id34" class="indexterm"/> second value (<code class="literal">4</code>) determines the default log level for all messages that do not maintain an exclusive log level.</li><li class="listitem" style="list-style-type: disc">The third value (<code class="literal">1</code>) determines the lowest possible log level configuration for the overall console log level. The lower the priority, the higher the log level number.</li><li class="listitem" style="list-style-type: disc">The fourth and final value (<code class="literal">7</code>) determines the default value for the overall console log level. Again, the lower the priority, the higher the log level number.</li></ul></div><p>Consequently, you<a id="id35" class="indexterm"/> are now in a position to consider making changes to the log level through a configuration file found at <code class="literal">/etc/sysctl.conf</code>. This file enables you to <a id="id36" class="indexterm"/>make fine adjustments to default settings, and it can be accessed with your favorite text editor in the following manner:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/sysctl.conf</strong></span>
</pre></div><p>To make the required change use the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>kernel.printk = X X X X</strong></span>
</pre></div><p>Here, the actual value of <code class="literal">X</code> is a log level setting taken from the options described earlier.</p><p>For example, you can change the number of messages by adding the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>kernel.printk = 5 4 1 7</strong></span>
</pre></div><p>Of course, such a modification implies a change to the kernel, and for this reason a reboot would be warranted. So, having done this, you will find that the output of running <code class="literal">cat /proc/sys/kernel/printk</code> should now reflect the new values. However, and as a supplementary note of caution, having considered doing this (and yes, you can easily reverse any changes made), it is important to realize that there are many questions based on the validity of changing these settings. Look at it this way: it may not help you at all, so you should always read around the subject before making these changes in order to confirm that making this alteration will suit your general purposes.</p><p>To view the onboard manual, simply use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ man sysctl</strong></span>
</pre></div><p>On the other hand, for the many other services and applications on your server, you will have additional avenues of investigation to consider and these are generally set by the service or application in question.</p><p>A common example <a id="id37" class="indexterm"/>of this is Apache. So, if you are debugging a web-based issue related to this service, you may be inclined to open the <code class="literal">httpd</code> configuration file like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/httpd/conf/httpd.conf</strong></span>
</pre></div><p>Look or search for the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>LogLevel warn</strong></span>
</pre></div><p>Then, replace the instruction with a more appropriate setting (before saving the file and restarting the service). In this case, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>LogLevel debug</strong></span>
</pre></div><p>Fortunately, it is nice to <a id="id38" class="indexterm"/>know that most services and applications do support a form of debugging mode for an improved log output. This will make the log file much more descriptive and easier to work with when troubleshooting the server, but just before we leave this subject, here comes the small print…</p><p>When you are working with log files, you should be aware that the information contained within those log files will not always be enough to help you diagnose the issue at hand or discover the cause of a problem. Log files may not only lack the required information, but they can also contain unknown errors and misleading messages. After all, log files only contain a series of (mainly) predefined messages or break points in a package, and these messages have been designed by programmers to make a remark concerning a known event that could have, or has taken place.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p><span class="strong"><strong>Remember…</strong></span></p><p>When affecting the output of a log file, a verbose and detailed output may raise performance or security issues, while detailed logging can also place an undue burden on the CPU or disk I/O operations.</p></div></div><p>Based on these circumstances, there are no hard and fast rules because we also know that log files have limitations. So, in the end you will rely on a keen eye for detail and a great deal of patience, and for these reasons alone, you must always learn to "listen to the server" as a whole.</p><p>Let's put it this way: the answer is there, but it may not be in the log files. Perseverance and a calm (but firm) hand <a id="id39" class="indexterm"/>will win the day, and it is this point of contention that will <a id="id40" class="indexterm"/>be echoed throughout the pages of this book.</p></div>
<div class="section" title="Using tail to monitor log files"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Using tail to monitor log files</h1></div></div></div><p>So, armed <a id="id41" class="indexterm"/>with the previous information and knowing that log files tend to describe events by specifying the time of occurrence, a level of severity, and a<a id="id42" class="indexterm"/> preordained message, the key to <a id="id43" class="indexterm"/>success in any troubleshooting scenario is based on an ability to work with these records and manipulate them in such a way that they provide us with the information we require to get the job done.</p><p>For the purpose of troubleshooting, one of the most useful commands you will use is known as <code class="literal">tail</code>. A command-line expression that can be used to read the last lines of a log file is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tail -n 100 /var/log/maillog</strong></span>
</pre></div><p>Similarly, <code class="literal">tail</code> can also be used to obtain the most recently added lines like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tail -f /var/log/maillog</strong></span>
</pre></div><p>Using this command not only gives you the most recent view of the log file in question, but also ensures that all updates are displayed immediately, which provides an instant way to read log files in a live environment. This approach can be described as the perfect way to troubleshoot Apache, Postfix, Nginx, MySQL, and the many other applications or services your server may be using.</p><p>For example, you can view the Apache <code class="literal">access_log</code> like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tail -f /var/log/httpd/access_log</strong></span>
</pre></div><p>To take this feature one step further, let's assume that you wanted to get the last 3,000 lines from a log file knowing that it will not fit within your shell window. To account for this requirement, you can pipe the results with the <code class="literal">less</code> command like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tail -n 3000 /var/log/messages | less</strong></span>
</pre></div><p>In this situation, you can now page the results as required, but having used this technique a few times, I think you would agree that this is far more flexible than using the generic <code class="literal">cat</code> command; unless of course, you wanted to do something very specific.</p></div>
<div class="section" title="Using cat, less, and more"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Using cat, less, and more</h1></div></div></div><p>The <a id="id44" class="indexterm"/>
<code class="literal">cat</code> command <a id="id45" class="indexterm"/>has been with us for a long time and, returning to our previous discussion relating to hardware and the contents of the <code class="literal">/proc</code> directory, you can use the <code class="literal">cat</code> command to view detailed information about your server's CPU:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /proc/cpuinfo</strong></span>
</pre></div><p>If you wish to know more about the server's memory, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /proc/meminfo</strong></span>
</pre></div><p>Then, there is always the chance to learn more about your devices by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /proc/devices</strong></span>
</pre></div><p>As useful as <code class="literal">cat</code> is, it is also known for providing a dump of the entire content on the screen, a condition that can seem a little unwieldy if the file is greater than 1,000 lines long. So, in these circumstances, the other option is to use the <code class="literal">less</code> and <code class="literal">more</code> commands in order to page through specific (static) files in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># less /var/log/messages</strong></span>
<span class="strong"><strong># more /var/log/messages</strong></span>
</pre></div><p>However, because <code class="literal">more</code> is relatively old, most will argue that <code class="literal">less</code> is far superior. The <code class="literal">less</code> command is similar to <code class="literal">more</code>, but <code class="literal">less</code> will allow you to navigate back and forth between paged results. So yes, it's an old joke, but from now on, and wherever possible, always know that <code class="literal">less</code> really does mean <code class="literal">more</code>.</p><p>For example, <code class="literal">less</code> allows you to search for a particular string. To do this, simply open the following file using <code class="literal">less</code> like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># less /var/log/messages</strong></span>
</pre></div><p>Now, in the lower left portion of the screen, type <code class="literal">/</code>, followed by a string value like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/error</strong></span>
</pre></div><p>The output will now be adjusted to highlight the search results, and if you are looking for a larger selection of options, simply hit the <span class="emphasis"><em>H</em></span> key while <code class="literal">less</code> is open.</p></div>
<div class="section" title="Using grep"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Using grep</h1></div></div></div><p>Now let's<a id="id46" class="indexterm"/> consider <a id="id47" class="indexterm"/>the need to search the server's log files for specific keywords.</p><p>In this situation, you would use the command known as <code class="literal">grep</code>, which also becomes a very helpful technique to learn when you would like to perform an advanced string-based search of almost any file on your server.</p><p>Let's say you wanted <a id="id48" class="indexterm"/>to search for a specific e-mail address in the mail log file. To do this, you would use <code class="literal">grep</code> in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep "user@domain.tld" /var/log/maillog</strong></span>
</pre></div><p>Taking this one step further, <code class="literal">grep</code> can also be used to search in a recursive pattern across one or more files at the same time.</p><p>For example, in order to search <a id="id49" class="indexterm"/>the log file directory for an IP address (<code class="literal">XXX.XXX.XXX.XXX</code>), you would use the <code class="literal">grep</code> command in combination with the <code class="literal">-R</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep -R "XXX.XXX.XXX.XXX" /var/log/</strong></span>
</pre></div><p>Similarly, you can add line numbers to the output with the <code class="literal">-n</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep -Rn "XXX.XXX.XXX.XXX" /var/log/</strong></span>
</pre></div><p>Moreover, you will also notice that, during a multi-file based search, the filename is made available for each search result, but by employing the <code class="literal">-h</code> option, this can be disabled in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep -Rh "XXX.XXX.XXX.XXX" /var/log/</strong></span>
</pre></div><p>You can<a id="id50" class="indexterm"/> ignore case with the <code class="literal">-i</code> option in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep -Ri "XXX.XXX.XXX.XXX" /var/log/</strong></span>
</pre></div><p>Moving beyond this, <code class="literal">grep</code> can be used to sort the content of a search result by simply calling the <code class="literal">sort</code> command. An alphabetical sort order (a to z) can be achieved by simply adding <code class="literal">sort</code> at the end of your original command like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep -R "XXX.XXX.XXX.XXX" /var/log/ | sort </strong></span>
</pre></div><p>A reverse alphabetical sort order (z to a) can be achieved by adding the <code class="literal">-r</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep -R "XXX.XXX.XXX.XXX" /var/log/ | sort -</strong></span>
</pre></div><p>And finally, if you wish to search for more than one value, you can invoke the <code class="literal">–E</code> argument like this (but do not include unnecessary white spaces between the pipes):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep -E "term 1|term 2|term 3" /var/log/messages</strong></span>
</pre></div><p>Of course, <code class="literal">grep</code> can do so much more, but for the purpose of troubleshooting, I would now like to draw your <a id="id51" class="indexterm"/>attention to one final, but very useful command. Known as <code class="literal">diff</code>, this command can be very useful in determining the differences between two files.</p></div>
<div class="section" title="Using diff"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Using diff</h1></div></div></div><p>The <a id="id52" class="indexterm"/>
<code class="literal">diff</code> command <a id="id53" class="indexterm"/>is not necessarily considered to be a tool that is associated with log files unless you are comparing backups for a specific purpose. However, the <code class="literal">diff</code> command is very useful when comparing changes across an application.</p><p>For example, <code class="literal">diff</code> will <a id="id54" class="indexterm"/>enable you to compare the differences between two Apache configuration files, but by using the <code class="literal">-u</code> option, you will be able to include additional information such as the time and date:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># diff -u /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.backup</strong></span>
</pre></div><p>Now, depending on the size of the files in question and the speed of your server, it may take a few seconds (or even minutes) to complete the task, and yes, I do realize we were digressing from the context of log files, but in time, I think that you will find this command will prove to be very useful.</p><p>For example, you may want to compare the contents of two folders using the <code class="literal">–rq</code> option to make it recursive like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># diff –rq /path/to/folder1 /path/to/folder2</strong></span>
</pre></div><p>To learn more about the <code class="literal">diff</code> command, simply review the manual by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ man diff</strong></span>
</pre></div></div>
<div class="section" title="Using truncation"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Using truncation</h1></div></div></div><p>So, having been <a id="id55" class="indexterm"/>shown how easy it is to work with log files, we should always be mindful that records like this do grow in size, and for this precise reason, they can <a id="id56" class="indexterm"/>become difficult to work with as time passes. In fact, you should be aware, oversized log files can impact the system's performance<a id="id57" class="indexterm"/>. With this in mind, it is a good idea to monitor any log rotation process and adjust it (on a regular basis) according to need.</p><p>Moreover, where log rotation can be critical for a medium- to high-load environment, I would suggest that you manage this solution effectively. However, in situations where the effect of this process proves negligible, the following fail-safe technique will enable you to scrub a log file clean by typing either one of the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /dev/null &gt; /path/to/file</strong></span>
</pre></div><p>Or more appropriately, you can simply use the <code class="literal">truncate</code> command like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># truncate --size 0 /path/to/file</strong></span>
</pre></div><p>This process is <a id="id58" class="indexterm"/>known as truncation, and as mentioned, this should remain something of a last resort, as the preceding command will remove all the data contained within the file in question. So remember, if the file contains important information that you may need to review at some time in the future, back it up before you use <code class="literal">truncate</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Summary</h1></div></div></div><p>This chapter was intended to provide an introduction to the subject of troubleshooting CentOS 7 without the intention of burdening you with yet another list of rules, instructions, or procedures that would ill-suit your circumstances or immediate needs. As we know, troubleshooting is a journey, and where the first chapter has served to introduce you to a selection of concepts and methods, every page that follows will ensure that you are one step closer to being at ease with the server you are about to diagnose and repair. So yes, the journey has just begun, and we will now approach the subject of troubleshooting active processes.</p></div>
<div class="section" title="References"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>References</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Red Hat<a id="id59" class="indexterm"/> customer portal: <a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/</a></li><li class="listitem" style="list-style-type: disc">Syslog Severity Levels: <a class="ulink" href="http://en.wikipedia.org/wiki/Syslog#Severity_levels">http://en.wikipedia.org/wiki/Syslog#Severity_levels</a></li><li class="listitem" style="list-style-type: disc">The Dmesg Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Dmesg">http://en.wikipedia.org/wiki/Dmesg</a></li><li class="listitem" style="list-style-type: disc">The Cat Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Cat_(Unix)">http://en.wikipedia.org/wiki/Cat_(Unix)</a></li><li class="listitem" style="list-style-type: disc">The Grep Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Grep">http://en.wikipedia.org/wiki/Grep</a></li><li class="listitem" style="list-style-type: disc">The Diff Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Diff_utility">http://en.wikipedia.org/wiki/Diff_utility</a></li><li class="listitem" style="list-style-type: disc">The Tail Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Tail">http://en.wikipedia.org/wiki/Tail</a></li><li class="listitem" style="list-style-type: disc">The Less Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Less_(Unix)">http://en.wikipedia.org/wiki/Less_(Unix)</a></li></ul></div></div></body></html>