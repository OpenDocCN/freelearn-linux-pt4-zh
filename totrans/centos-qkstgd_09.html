<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Overview of Essential Advance Utilities</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will learn some advanced and essential concepts related to the system, such as logging, controlling system services, firewalls, and <strong>Security Enhanced Linux</strong><span> (</span><strong>SELinux</strong>). Logging plays a key role in debugging and troubleshooting system applications. A s<span><span><span>olid understanding of logging will make your daily operations easier to handle and will also give you a deep insight into the application's functioning.</span></span></span></p>
<p><span><span><span>I</span></span></span><span><span><span>n this final chapter, we will learn the different logging mechanisms available in CentOS 7, such as journald and rsyslog. By now, you have seen</span></span></span><span><span><span> how to install, update, and remove applications. Now, we will see how to control these applications and system services using the systemd and systemctl utilities. Finally, we will understand the basic usage of firewalld and SELinux to secure running services and harden the security of the system.</span></span></span></p>
<p><span><span>We will cover the following:</span></span></p>
<ul>
<li><span><span>Understanding system logging</span></span></li>
<li><span><span>Working with rsyslogd and journald</span></span></li>
<li><span><span>Understanding control of systems and services</span></span></li>
<li><span><span>Working with systemd and systemctl</span></span></li>
<li><span><span>Understanding SELinux </span></span>concepts</li>
<li><span><span>Working with SELinux</span></span></li>
<li><span><span>Understanding firewall concepts in CentOS 7</span></span></li>
<li><span><span>Working with firewalld</span></span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding system logging</h1>
                </header>
            
            <article>
                
<p><span><span>Most application programs and the kernel write their event information in log files maintained at different locations. It helps in keeping track of activities that are taking place on the system and also forms an essential part of system auditing. Monitoring of log files helps in spotting any unusual activity in the system. Logging also helps in troubleshooting any application problems. By convention, Linux uses the <kbd>/var/log/</kbd> directory for storing logs in the system.</span></span></p>
<p><span><span>Starting with CentOS 7, we have two logging services that exist in the system:</span></span></p>
<ul>
<li><span><span>Rsyslog service </span></span></li>
<li><span><span>Systemd-journald service</span></span></li>
</ul>
<div class="packt_infobox"><span><span><span>System time service should be properly configured before configuring log services, as time is an important component of log files.</span></span></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with rsyslog</h1>
                </header>
            
            <article>
                
<p><span><span>The rsyslog service centrally collects the log messages from different applications running in the Linux system. It collects the logs based on their type and their priorities, and stores them persistently in the <kbd>/var/logfollows:/</kbd> directory.</span></span></p>
<p><span><span>The following table lists some important log files maintained by rsyslog, along with their description:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span>Log file path</span></span></strong></span></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span>Description</span></span></strong></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/messages</span></span></kbd></p>
</td>
<td>
<p><span><span>Most standard log messages are stored here, except authentication logs, email logs, and some application debugging logs.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/secure</span></span></kbd></p>
</td>
<td>
<p><span><span>Authentication logs containing errors and other messages are stored here.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/maillog</span></span></kbd></p>
</td>
<td>
<p><span><span>Mail server logs are stored here.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/boot.log</span></span></kbd></p>
</td>
<td>
<p><span><span>Boot/system startup messages are logged here.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/cron</span></span></kbd></p>
</td>
<td>
<p><span><span>It stores cron job (scheduler) logs.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/wtmp</span></span></kbd></p>
</td>
<td>
<p><span><span>Login activity logs are kept here.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/dmesg</span></span></kbd></p>
</td>
<td>
<p><span><span>Kernel messages are stored here.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/cups</span></span></kbd></p>
</td>
<td>
<p><span><span>Printing service logs are stored here.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/samba</span></span></kbd></p>
</td>
<td>
<p><span><span>Samba service logs are kept here, not managed by rsyslog. The Samba service directly writes logs here.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/httpd</span></span></kbd></p>
</td>
<td>
<p><span><span>This directory contains Apache web server logs, not managed by rsyslog. Apache directly writes logs in these files.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span><span>/var/log/audit/</span></span></kbd></p>
</td>
<td>
<p><span><span>Contains the <kbd>auditd</kbd> service logs and SELinux log files.</span></span></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_infobox"><span><span><span><span><span>Rsyslogd is an application in Linux systems, based on the syslog project that started in 1980. It uses syslog protocol</span></span></span><span><span> </span></span><span><span><span>to log events in the system with certain extended features, such as the RELP protocol and buffered operation support. Sometimes, syslog is also used in the context of rsyslog in Linux.</span></span></span></span></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring rsyslogd sections</h1>
                </header>
            
            <article>
                
<p><span><span>The rsyslogd service is used by most of the applications running in Linux for logging events. The rsyslogd service uses three main components for handling the log messages of various applications in the system:</span></span></p>
<ul>
<li><span><span><strong>Facility</strong>: It represents the type of process</span></span></li>
<li><span><span><strong>Priority or severity</strong>: It represents the severity of the message</span></span></li>
<li><span><span><strong>Destination/location</strong>: It describes the location where the log messages are sent to or logged</span></span></li>
</ul>
<p><span><span>The configuration file for the rsyslogd service is stored in two locations:</span></span></p>
<ul>
<li><span><span>In the main configuration file, <kbd>/etc/rsyslog.conf</kbd></span></span></li>
<li><span><span>In the files stored with <kbd>.conf</kbd> extensions inside the <kbd>/etc/rsyslog.d/</kbd> directory</span></span></li>
</ul>
<p><span><span>The main configuration file, <kbd>/etc/rsyslog.conf</kbd>, contains the information on what is to be logged and where it should be stored. It is divided into three different sections displayed in capital letters, as shown:</span></span></p>
<ul>
<li><kbd><span><span>#### MODULES ####</span></span></kbd><span><span>:</span></span><strong><span><span> </span></span></strong>The modules section is used to configure advanced features of rsyslogd.</li>
</ul>
<ul>
<li><kbd><span><span>#### GLOBAL DIRECTIVES ####</span></span></kbd><span><span>: </span></span>The global directives section is used to specify globally configurable parameters.</li>
</ul>
<ul>
<li><kbd><span><span>#### RULES ####</span></span></kbd><span><span>:</span></span><strong><span><span> </span></span></strong>It is the most important section, and contains the rules to specify what is to be logged and where it is to be logged. We will discuss this more in the <em>Rsyslogd</em> <span><em>rules</em></span> <span>section of this chapter.</span></li>
</ul>
<p><span><span>Documentation for rsyslog can be accessed from the <kbd>man</kbd> command as follows:</span></span></p>
<pre><strong><span><span># man 5 rsyslog.conf</span></span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rsyslogd facilities and priorities</h1>
                </header>
            
            <article>
                
<p><span><span>Facilities<strong> </strong><span>represent</span> <span>the fixed list of internal system processes that</span> <span>produce the log messages.</span></span></span></p>
<p><span><span>The following table lists the common facilities keywords that are available in CentOS 7</span></span><span> </span><span>and their descriptions</span><span>:</span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Facility</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span><kbd>auth</kbd> or <kbd>authpriv</kbd></span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents authentication-related subsystem messages such as login</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>cron</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents the crond service and any scheduled application messages</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>daemon</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Generic name used to represent the various daemon subsystem messages</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>kern</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents kernel messages</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>lpr</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents legacy print service messages</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>mail</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents all mail program messages</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>mark</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It is for internal use and not to be used with any application</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>news</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents the messages generated by NNTP</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>security</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Same as <kbd>authpriv</kbd> and not used anymore</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>syslog</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents the messages of the syslog daemon</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>user</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents the messages generated by the user space</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>uucp</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents the messages generated by the UUCP subsystem</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>local0-local7</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It represents the custom unused facilities provided by the system to the user for sending messages generated by user defined services</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>*</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It matches all the facilities</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Priorities re<span><span><span>present</span> <span>the severity</span> <span>or priority</span> <span>of messages that are logged</span> <span>for any</span> <span>service.</span> <span>There are</span> <span>different priority levels that can be used to determine the type of event that can be logged, such as <kbd>debug</kbd>, <kbd>info</kbd>, <kbd>emerg</kbd>, <kbd>alert</kbd>,</span> and so on, <span>for the specified service.</span></span></span></p>
<p><span><span>The following table lists the severity/priority levels with their description and assigned number for priority:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Assigned number</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Priority</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Severity description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>0</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>emerg</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Generates message when system is unusable</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>1</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>alert</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Action must be taken immediately, available service is about to be discontinued</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>2</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>crit</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Generates message when critical condition occurs</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>3</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>err</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Non-critical error condition</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>4</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>warning</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Warning condition</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>5</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>notice</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Informational message for event that needs attention to prevent future issues</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>6</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>info</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Generates informational messages for normal service operation</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>7</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>debug</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Debugging-level messages for service operation</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span><span>If the wild card <kbd>*</kbd><strong> </strong>is specified in the priority field, then it represents all types of severity (messages). If <kbd>none</kbd> is written in the severity field, then it means none of the messages of the corresponding facility will be added in the specified log files. The <kbd>none</kbd> is used to prevent logging of same message in different log files, as shown in the following diagram:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/07c7bee9-4bf6-4253-95cd-32eba971994c.png" width="686" height="196"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rsyslogd rules</h1>
                </header>
            
            <article>
                
<p><span><span>The <kbd>####RULES####</kbd> section of <kbd>/etc/rsyslog.conf</kbd> contains directives to define the logging of messages. The syntax of the directive used in <kbd>/etc/rsyslog.conf</kbd> file is as follows:</span></span></p>
<pre><strong>facility.priority                        destination</strong></pre>
<p class="CDPAlignCenter CDPAlign"><img src="Images/02d03b21-ee66-46d8-a6cf-d307b5503013.png" style="width:62.00em;height:25.50em;" width="945" height="389"/></p>
<p><strong><span><span>The following are examples that illustrate the usage of directives defined in the /etc/rsyslog.conf file for logging of messages:</span></span></strong></p>
<ul>
<li><span><span>To log all information messages of the kernel, we can specify a different log file as follows:<br/></span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span>$ vi /etc/rsyslog.conf<br/></span></span><span><span>kern.info /var/log/kernel</span></span></strong></pre>
<ul>
<li><span><span>We create a <kbd>debug.log</kbd> file in the <kbd>/var/log/</kbd> directory to collect debugging priority messages from all services as shown in the following command line:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span>$ vi /etc/rsyslog.conf<br/></span></span><span><span>*.debug /var/log/debug.log<br/></span></span></strong></pre>
<ul>
<li>After making the required changes in the <kbd>/etc/rsyslog.conf</kbd> file, restart the rsyslog service to bring changes into effect as shown in the following command line:</li>
</ul>
<pre style="padding-left: 60px"><strong><span><span>$ systemctl restart rsyslog</span></span></strong></pre>
<p style="padding-left: 60px"><span><span>After making the preceding changes, the debugging messages will not appear in the <kbd>/var/log/messages</kbd> file.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Log file rotation</h1>
                </header>
            
            <article>
                
<p><span><span>Log rotation prevents the filling up of the <kbd>/var/log</kbd> directory. Old log files are renamed with <kbd>filename-datestamp</kbd> on rotation. The <kbd>datestamp</kbd> indicates the date on which it was rotated (archived) as shown in the following table:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Existing log</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Archived log</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>/var/log/messages</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span><kbd>/var/log/messages-20180530</kbd> </span></span></span></span><span><span><span><span>(rotated on May 30, 2018)</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span><span><strong>Logrotate</strong> <span>is the utility that takes care of rotating the log files periodically. A cron job is run nightly with the script named <kbd>/etc/cron.daily/logrotate</kbd> for log rotation. The rotation of log files is carried out as per the configuration of log rotation program stored in the following two locations:</span></span></span></p>
<ul>
<li><kbd><span><span>/etc/logrotate.conf</span></span></kbd></li>
<li><span><span><kbd>/etc/logrotate.d/*</kbd> (any file inside this directory)</span></span></li>
</ul>
<p><span><span>Most log files are rotated weekly; however, the <kbd>logrotate</kbd> command rotates some logs faster or slower or on certain conditions, such as on reaching a certain size.</span></span></p>
<p><span><span>After rotation of logs, the log watch program discards the old archive of log files to conserve disk space (typically 4 weeks or after a certain number of rotations). A new log file is created during rotation and the service is notified. On installation of a new application, the application adds its log file to <kbd>logrotate</kbd> management by dropping its logging configuration file inside the <kbd>/etc/logrotate.d/</kbd> directory.</span></span></p>
<p><span><span><span>An example of creating a custom log file is as follows</span>:</span></span></p>
<pre><strong><span><span># vi / etc/logrotate.d/&lt;application_name&gt;<br/></span></span><span><span>/var/log/path_to_log_file {<br/></span></span><span><span>rotate 3<br/></span></span><span><span>size 2M<br/></span></span><span><span>monthly<br/></span></span><span><span>postrotate<br/></span></span><span><span>/bin/systemctl reload httpd<br/></span></span><span><span>endscript<br/></span></span><span><span>}</span></span></strong></pre>
<p><span><span>These are the important commands used in the <kbd>log rotation</kbd> file:</span></span></p>
<ul>
<li><span><span><kbd>rotate 3</kbd>: Keeps the last three versions of the file and deletes the oldest</span></span></li>
<li><span><span><kbd>size 2M</kbd>: Rotates the log file on reaching 2 MB in size</span></span></li>
<li><span><span><kbd>monthly</kbd>: It is another alternative to size; if size has not reached 2 MB, then rotate the file on a monthly basis</span></span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Analyzing syslog entries</h1>
                </header>
            
            <article>
                
<p><span><span>The system logs generated by the rsyslogd service are stored in the <kbd>/var/log/</kbd> directory in various files. The oldest message is kept at the top of the log and new log entries are appended at the bottom of the log file in a standard format, as shown in the following diagram:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a0fa6d55-8257-44dd-9566-63759a253adc.png" width="646" height="293"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monitoring live log file traffic using the tail command</h1>
                </header>
            
            <article>
                
<p><span><span>While performing troubleshooting, it is required to view the logs being generated by an application when it is being run. Using the <kbd>tail</kbd> command with the <kbd>-f</kbd> option does this. In one Terminal, we will execute the application we want to troubleshoot, and in another Terminal, we will execute the <kbd>tail</kbd> command as shown in the following:</span></span></p>
<pre><strong><span><span># tail -f &lt;/path_of_log_file&gt;</span></span></strong></pre>
<p><span><span>It displays the 10 lines from the bottom of the filename specified, and keeps the file open to view the new lines that are being written to it. Once we are done viewing logs, we can close the log file by pressing <em>Ctrl</em> + <em>C</em>.</span></span></p>
<p><span><span>For example, to monitor the failed login attempts on the system, on one Terminal, open <kbd>/var/log/secure</kbd>, and in another Terminal, execute the <kbd>ssh</kbd> command on the same system as shown in the following screenshot:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9d054892-adfc-4444-b4a0-f1d7a6968767.png" width="1237" height="479"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the logger command</h1>
                </header>
            
            <article>
                
<p><span><span>Although most applications are configured to write logs in the log file automatically, we can use the <kbd>logger</kbd> command to write messages to rsyslogd also. The <kbd>logger</kbd> command writes the log messages in the log file as per the facility and priority specified with the <kbd>logger</kbd> command. By default, it sends the logs to the facility named as user with priority named as notice (<kbd>user.notice</kbd>). The <kbd>logger</kbd> command can be used inside a shell script to create logs, as shown in the following examples:</span></span></p>
<ul>
<li><span><span>If we send a log message of information priority to the <kbd>rsyslog</kbd> program, then it will get stored in the <kbd>/var/log/boot.log</kbd> file as shown in the following command line:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># logger -p local7.info  "Sample log entry using logger command"</span></span></strong></pre>
<ul>
<li><span><span>We can send any log message to the default log file,</span></span> <kbd>/var/log/messages</kbd>, by using <kbd>logger</kbd> command as shown in the following command line:</li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># logger "Log file entry using logger"</span></span></strong></pre>
<div class="packt_infobox"><span><span>For more information on logging, refer to th</span></span>e man pages of the <kbd>logger</kbd>, <kbd>tail</kbd>, <span><span><kbd>rsyslog.conf</kbd>, and <kbd>logrotate</kbd> commands.</span></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with systemd-journald</h1>
                </header>
            
            <article>
                
<p><span><span>This daemon provides a non-persistent method of advanced log management for collecting and displaying messages from the kernel, boot programs, and other services running in CentOS 7. The journald stores these messages in a journal maintained in binary format, which can be accessed using the <kbd>journalctl</kbd> command. The default behavior of the journal is non-persistent across reboot. It forwards the messages to rsyslogd for permanent central storage and processing.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding events with the journalctl command</h1>
                </header>
            
            <article>
                
<p><span><span>In CentOS 7, the <kbd>systemd-journal</kbd> is stored in the <kbd>/run/log/journal/</kbd> directory, as shown in the following screenshot:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e065ee12-3fc6-45ff-b866-bcf33f8b9070.png" style="width:43.50em;height:4.00em;" width="943" height="87"/></p>
<p><span><span>When we execute the <kbd>journalctl</kbd> command as root without any options, then it shows the full system journal, from the oldest log entry to the latest as shown in the following command line:</span></span></p>
<pre><strong><span><span># journalctl</span></span></strong></pre>
<p>The <kbd>journalctl</kbd> command uses color coding to highlight the severity of messages, as shown in <span>the </span>following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Priority</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description of text highlighting used in logs</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span><kbd>Error</kbd>, <kbd>crit</kbd>, <kbd>alert</kbd> or <kbd>emerg</kbd></span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Text is red</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span><kbd>Notice</kbd> or <kbd>warning</kbd></span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Text is bold</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span><kbd>Info</kbd> or <kbd>debug</kbd></span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Regular text</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span><span>Different options are used with the <kbd>journalctl</kbd> command to limit the searches of the journal to the desired output:</span></span></p>
<ul>
<li><kbd><span><span>Journalctl -n</span></span></kbd>: By default, using <span>the </span><kbd>-n</kbd> option with <kbd>journalctl</kbd> will display the last 10 log entries. We can also specify the number of log entries to be displayed in <span>the </span>output as shown in the following screenshot:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ca2fe7b1-1868-4897-97b8-4269d03a9c8e.png" style="width:47.17em;height:8.42em;" width="1241" height="222"/></p>
<ul>
<li><kbd>Journalctl -p</kbd>: <span><span>We can filter the output of the journal by specifying the priority of the log entries using the <kbd>-p</kbd> option. We can specify either name or number of the priority level to display the log entries of the specified or higher-level priority, as shown in the following screenshot:</span></span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8323e099-37cd-4c35-b200-9c97c029cb5e.png" style="width:49.50em;height:6.83em;" width="1247" height="173"/></p>
<ul>
<li><kbd>Journalctl -f</kbd>: T<span><span>he <kbd>-f</kbd> option is similar to the <kbd>-f</kbd> option used with the <kbd>tail</kbd> command; it displays the last 10 lines of the journal and keeps it open to display the new entries as they are written in the journal, until you press</span></span> <em>Ctrl</em> + <em>C</em> <span><span>as shown in the following screenshot:</span></span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e0e227c1-2d70-48b5-bea6-8a43ead2a391.png" style="width:46.58em;height:12.33em;" width="1237" height="327"/></p>
<p><strong>Limiting journalctl output to a specific time</strong>: The <span><span><kbd>journalctl</kbd> command can be used to with two more options, <kbd>--since</kbd> and <kbd>--untill</kbd>, to specify a time range and display the log messages of that duration. The following <kbd>journalctl</kbd> query shows all logs recorded between <kbd>18:05:00</kbd> and</span></span> <kbd>18:10:00</kbd>:</p>
<pre style="padding-left: 30px"><strong><span><span># journalctl --since 18:05:00 --until 18:10:00</span></span></strong></pre>
<p><span><span>We can use the <kbd>journalctl</kbd> command to display today's journal entries only as shown in the following command line:</span></span></p>
<pre style="padding-left: 30px"><span><span><strong># journalctl --since today</strong> </span></span></pre>
<p><span><span>We can also use the <kbd>journalctl</kbd> command to display extra fields attached to the log entries by enabling the verbose output on the journal as shown in the following command line:</span></span></p>
<pre style="padding-left: 30px"><strong><span><span># journalctl -o verbose</span></span></strong></pre>
<p><span><span>The following table lists some of the important fields of the<kbd> journalctl</kbd> command that are used to filter the query:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Field name</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>_COMM</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It filters the journal based on the name of the command</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>_EXE</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It is used to filter the query based on the path of the executable for the process</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>_PID</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It filters the journal based on the PID of the process</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>_UID</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It filters the journal based on the UID of the user running the process</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>_SYSTEMD_UNIT</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>It filters the journal based on the systemd unit that started the process</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span><span>For example, for listing the journal messages that originated from a</span></span> systemd <span><span>process with PID 1 can be filtered using the following command:</span></span></p>
<pre><strong><span><span># journalctl _PID=1</span></span></strong></pre>
<p><span><span>The <kbd>journalctl</kbd> command can also be used to list all the journal messages send by</span></span> <span>the </span><kbd>sshd</kbd> <span><span>service, as shown in the following command line:</span></span></p>
<pre><span><span><strong># journalctl _SYSTEMD_UNIT=sshd.service</strong> </span></span></pre>
<p>The <kbd>journalctl</kbd> command can also be used to view <span><span>the journal log messages since last boot as shown in the following command line:</span></span></p>
<pre><strong><span><span># journalctl -b</span></span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring systemd-journald to store logs persistently</h1>
                </header>
            
            <article>
                
<p><span><span><kbd>systemd-journal</kbd> is stored in the </span></span><kbd>/run/log/journal</kbd> <span>directory</span><span>, which is cleared on system reboot. Its configuration file is</span> <kbd>/etc/systemd/journald.conf</kbd><span>, which can be used to fine-tune journal parameters such as the amount of filesystem to be used for storing <span>the </span>journal (default value is 10%).</span></p>
<p><span><span><kbd>systemd-journal</kbd> is configured in such a way that if the <kbd>/var/log/journal/</kbd></span></span><span> </span><span>directory </span><span>exists in the system, then it logs journal entries in that directory instead of</span> <kbd>/run/log/journal/</kbd><span>. The same concept is used to made</span> <kbd>systemd-journal</kbd> <span>storage persistent across reboot. The following steps are to be taken to make</span> <kbd>systemd-journal</kbd> <span>persistent:</span></p>
<ol>
<li><span><span>Create the <kbd>/var/log/journal/</kbd> directory as root user as shown in the following command line:</span></span></li>
</ol>
<pre style="padding-left: 60px"><span><span><strong># mkdir /var/log/journal</strong><br/></span></span></pre>
<ol start="2">
<li>Make <span>the </span>owner of the directory created as root and group as <kbd>systemd-journal</kbd> with permissions <kbd>2755</kbd> as shown in the following command line:</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># chown root:systemd-journal /var/log/journal<br/></span></span><span><span># chmod 2755 /var/log/journal</span></span></strong></pre>
<ol start="3">
<li>
<p>Reboot your system or send the <kbd>USR1</kbd> signal to <kbd>systemd-journald</kbd> as shown in the following command line:</p>
</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># killall -USR1 systemd-journald</span></span></strong></pre>
<ol start="4">
<li class="mce-root">Make sure <kbd>systemd-journal</kbd> is persistent after reboot by listing a new directory containing journal log files inside the <kbd>/var/log/journal</kbd> directory as shown in following command line:</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># ls /var/log/journal</span></span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding how to control the system and services</h1>
                </header>
            
            <article>
                
<p><span><span>From a user or system administrator point of view, it is essential to understand how to manage various services installed on your system. A user should be able to enable a service at boot time and start or stop it when required.</span></span></p>
<p><span><span>Earlier, the Linux system and services were managed by SysV init or BSD init. Later on, their management was further improvised by adding utilities such as service and chkconfig, in addition to shell scripts. More recently, starting with CentOS 7, system and service management is now done with systemd. Systemd has replaced initd as the first process of CentOS 7.</span></span></p>
<p><span><span>In the next section, you will learn how to manage services</span></span><span> </span><span>running</span><span> on your system. You will learn how to use</span> systemd <span>and its components, responsible for switching the system from the kernel space to the user space and managing system processes thereafter.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining essential terms</h1>
                </header>
            
            <article>
                
<p><span><span>This section we will define the essential terms related to system and services management.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a daemon?</h1>
                </header>
            
            <article>
                
<p><span><span>A daemon is a process that waits or runs in the background, executing several tasks. It listens for connections using a network socket.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a socket?</h1>
                </header>
            
            <article>
                
<p><span><span>When a client connection is established, a socket is created and passed by systemd to a daemon or it creates a daemon for itself. In Linux, sockets are used mainly to establish client communication with the daemon.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is systemd?</h1>
                </header>
            
            <article>
                
<p><span><span>From CentOS 7 onward, systemd has replaced the init process as the first process (PID=1) that is started by the kernel when Linux boots up. It manages the system and services in the system for the Linux kernel by providing an interface between applications and the kernel. After starting systemd, it starts logging activities, mounting the filesystem and devices, starts other services, and finally provides the user with a login shell. These tasks are carried out by systemd with the help of different libraries and utilities such as <kbd>systemctl</kbd>, <kbd>journalctl</kbd>, <kbd>hostenamectl</kbd>, <kbd>localectl</kbd>, <kbd>timedatectl</kbd>, <kbd>systemd-cgls</kbd>, and so on, which it installs with itself. It manages the various system resources through objects known as units.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What are units?</h1>
                </header>
            
            <article>
                
<p><span><span>In systemd, units are objects that systemd knows how to manage and operate. They represent different system resources and they are defined using configuration files called unit files. These unit files are are kept in the <kbd>/usr/lib/systemd/system/</kbd> directory by default. Only those units whose unit files are stored in the <kbd>/lib/systemd/system</kbd> directory can be started or stopped during a session. These files are installed in the system by the application's RPM files. Units are the replacement of old init scripts that were used before CentOS 7.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is systemctl?</h1>
                </header>
            
            <article>
                
<p><span><span>It is a replacement for the service and <kbd>chkconfig</kbd> command in CentOS 7. The <kbd>systemctl</kbd> command is used to manage the different types of systemd objects (units). Systemd has 12 unit types, which can be listed with the command shown in the following screenshot:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/20cb22de-f428-4e6d-bcaf-4cdf4f7dc5fb.png" style="width:19.08em;height:15.92em;" width="418" height="350"/></p>
<p><span><span>The following table lists some popular units and their descriptions:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Unit types</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>Service</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>These types of units have a <kbd>.service</kbd> extension and represent the system services. This unit is used to start daemons such as the web server. If no unit name is specified with <kbd>systemctl</kbd>, then the service is assumed as the default unit.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>Socket</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>These types of units have a <kbd>.socket</kbd> extension and represent <strong>inter-process communication</strong> (<strong>IPC</strong>) sockets.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>Path</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>These type of units have a <kbd>.path</kbd> extension and are used to delay the activation of a service until a specific filesystem change occurs.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>Target</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>These types of units have a <kbd>.target</kbd> extension and represent a group of units.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>Slice</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>These types of units have a <kbd>.slice</kbd> extension and they represent a management unit of processes.</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with systemd and systemctl</h1>
                </header>
            
            <article>
                
<p><span><span>This section describes how systemd and systemctl are organized and how important objects (units) are managed using systemd.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Viewing states of service with systemctl</h1>
                </header>
            
            <article>
                
<p><span><span>The service unit is one of the most important units of <kbd>systemd</kbd>, which is managed using <kbd>systemctl</kbd>. If no unit type is specified, <kbd>systemctl</kbd> shows the status of the service unit, if it exists. The following is the syntax to view any unit:</span></span></p>
<pre><strong># systemctl     status    name.type</strong></pre>
<p><span><span>Here, name is the service name and type is the unit type, such as service, socket, path, and so on. The example in the following screenshot illustrates the usage of the <kbd>systemctl</kbd> command for viewing the status of a service:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0b9859fb-55b6-4c45-8d1d-94ed85b16b13.png" width="854" height="441"/></p>
<p><span><span>The following table lists the various statuses of services, along with their descriptions:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Status</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>Loaded</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Unit configuration file is processed successfully</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>Active (running)</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Running with one or more active processes</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>Active (exited)</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Successfully completed a one-time configuration</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>Active (waiting)</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Running and waiting for an event to take place</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>Inactive</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Not running currently</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>Enabled</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Will get started at boot time</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>Disabled</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Will not get started at boot time</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>Static</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Cannot be enabled directly, but may be started by another enabled unit automatically</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Viewing unit files with systemctl</h1>
                </header>
            
            <article>
                
<p><span><span>As a system administrator or user, sometimes it is necessary to find out the current status of systemd unit files. This helps in fine-tuning of system. We can configure services to be in active and loaded state or in an inactive state after booting of system, using the <kbd>systemctl</kbd> command.<br/></span></span></p>
<p><span><span>The following table lists the commands used to view the unit files and their descriptions:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent;width: 269.8px">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Command</span></span></span></strong></span></p>
</td>
<td style="background: transparent;width: 446.2px">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 269.8px">
<p><kbd><span><span><span><span># systemctl</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 446.2px">
<p><span><span><span><span>Displays the state of all the different units that are active and loaded on startup</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 269.8px">
<p><span><span><span><span><kbd># systemctl --type=service</kbd> or</span></span></span></span></p>
<p><span><span><span><span><kbd># systemctl list-units --type=service</kbd></span></span></span></span></p>
</td>
<td style="background: transparent;width: 446.2px">
<p><span><span><span><span>Displays the state of only service units that are active</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 269.8px">
<p><span><span><span><span><kbd># systemctl --type=service –all</kbd> or</span></span></span></span></p>
<p><kbd><span><span><span><span># systemctl list-units --type=service --all</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 446.2px">
<p><span>Displays</span><span><span><span><span> the state of all service units loaded, whether active or inactive</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 269.8px">
<p><kbd><span><span><span><span># systemctl --failed --type=service</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 446.2px">
<p><span><span><span><span>Displays all services that failed</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 269.8px">
<p><kbd><span><span><span><span># systemctl is-active sshd</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 446.2px">
<p><span><span><span><span>Displays whether the particular service is currently active or not</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 269.8px">
<p><kbd><span><span><span><span># systemctl is-enabled sshd</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 446.2px">
<p><span><span><span><span>Displays whether the particular service in enabled to start at boot time or not</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 269.8px">
<p><kbd><span><span><span><span># systemctl list-unit-files --type=service</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 446.2px">
<p><span><span><span><span>Displays the enabled, disabled, or static settings of all units of the specified type</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 269.8px">
<p><kbd><span><span><span><span># systemctl status sshd.servisystemctlce -l</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 446.2px">
<p><span><span><span><span>Displays detailed status information about the specified service</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Unit dependencies and unit file structure</h1>
                </header>
            
            <article>
                
<p><span><span>Services are started as standalone, or sometimes as dependencies of other services. For example, let's assume a socket unit is enabled, but the service unit with the same socket name is not, then the service will automatically get started when a request is made on the network socket. Similarly, the service can also be triggered by the path unit when a filesystem path condition is met. The following command is used to list the dependency tree of the specified unit:</span></span></p>
<pre><strong><span><span># systemctl list-dependencies sshd</span></span></strong></pre>
<p><span><span>Starting with CentOS 7, <kbd>systemd</kbd> provides a uniform interface to start unit files from their storage loaction. The locations of the unit file stored in the system are as follows:</span></span></p>
<ul>
<li><span><span><kbd>/usr/lib/systemd/system/</kbd>: It contains system default unit files</span></span></li>
<li><span><span><kbd>/etc/systemd/system</kbd>: It contains system-specific parameters to modify the default behavior of systemd</span></span></li>
<li><span><span><kbd>/run/systemd/system/</kbd>: It contains the runtime configuration of unit files</span></span></li>
</ul>
<p><span><span>The structure of a unit file is shown in the following screenshot:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/be642904-0aaa-4b69-9f3a-62dc2d13515f.png" style="width:32.58em;height:12.50em;" width="692" height="266"/></p>
<p><span><span>The preceding unit file can be broken down into following three sections:</span></span></p>
<ul>
<li><span><span><strong>Unit</strong>: This section describe the unit type and its dependencies, if any. It also contains the <kbd>After</kbd> statement and the <kbd>Before</kbd> statement. These statements define the dependencies of the unit. The <kbd>Before</kbd> statement says that this unit should be started before the specified unit. The <kbd>After</kbd> statement says that this unit should be started after starting the specified units.</span></span></li>
<li><span><span><strong>Service</strong>: This section contains a description of how to start and stop the service. The line beginning with the <kbd>ExecStart</kbd> parameter describes how to start the unit and the line beginning with</span></span> <span>the </span><kbd>ExecStop</kbd> <span><span><span>parameter describes how to stop the unit.</span></span></span></li>
<li><span><span><strong>Install</strong>: This section contains a line beginning with the <kbd>WantedBy</kbd> parameter, which states the target of this application. Target units are the equivalent of runlevels, which we had in CentOS 6 and earlier versions.</span></span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing daemons using systemctl</h1>
                </header>
            
            <article>
                
<p><span><span>Services can be started at boot time by creating a link to the unit files in the systemd configuration directory using the <kbd>systemctl</kbd> command. Earlier enabling of a service to start it automatically at boot time was managed using</span></span> <kbd>chkconfig</kbd>. An example to illustrate the usage of <kbd>systemctl</kbd> command to disable or enable a unit file is shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e8f40384-7822-44a8-bf15-d6930d7b35b2.png" width="693" height="79"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Masking services</h1>
                </header>
            
            <article>
                
<p><span><span>To prevent conflict between similar types of services that perform a certain function, masking is used. For example, for a firewall, CentOS 7 has </span></span><span>both </span><kbd>iptables</kbd> <span>and</span> <kbd>firewalld</kbd> <span>services; however, it is recommended to use only one at a time. Hence, one of the two firewall services is masked to prevent conflict between the two services. Masks prevent <span>the </span>accidental startup of a service by creating a <kbd>symlink</kbd> of <span>the </span>service file to</span> <kbd>/dev/null</kbd> <span>as shown in the following screenshot:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fad155a8-ac99-4fc7-8405-d91b54d155cb.png" style="width:35.83em;height:5.08em;" width="791" height="112"/></p>
<div class="packt_tip"><span><span><span>If a service is disabled, it will not get started automatically at boot even by other unit files; however, a user can still start that service manually.</span> A m<span>ask service has the advantage here, as it cannot be started manually or automatically.</span></span></span></div>
<p><span><span>The following table lists the different <kbd>systemctl</kbd> commands used to manage a service:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent;width: 227.4px">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Command</span></span></span></strong></span></p>
</td>
<td style="background: transparent;width: 488.6px">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl status &lt;unit&gt;</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span><span><span><span>Displays detailed information of unit state</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl stop &lt;unit&gt;</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span><span><span><span>Stops the running service</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl start &lt;unit&gt;</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span><span><span><span>Starts the stopped service</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl restart &lt;unit&gt;</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span><span><span><span>Restarts (stop and then start) a service</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl reload &lt;unit&gt;</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span><span><span><span>Reloads configuration of a running service by rereading its config file</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl mask &lt;unit&gt;</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span><span><span><span>Completely disables a service from starting at boot time automatically, or manually any time</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl unmask &lt;unit&gt;</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span><span><span><span>Unmasks a masked service, making it available for the user to enable it or start manually</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl enable &lt;unit&gt;</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span><span><span><span>Sets the service to start automatically at boot time</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl disable &lt;unit&gt;</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span><span><span><span>Disables a service from starting automatically at boot time</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl poweroff</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span>Shuts down the system</span></p>
</td>
</tr>
<tr>
<td style="background: transparent;width: 227.4px">
<p><kbd><span><span><span><span># systemctl reboot</span></span></span></span></kbd></p>
</td>
<td style="background: transparent;width: 488.6px">
<p><span>Restarts the system</span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling the boot process using systemd</h1>
                </header>
            
            <article>
                
<p><span><span>During the boot process, when the kernel image and initramfs image get loaded, initramfs starts the first process on the system, which is systemd with </span></span><span>the</span><span> </span><span>process ID</span> <span>1</span><span>. This systemd process further takes over control in the final stages of system booting and performs the following operations:</span></p>
<ul>
<li><span><span>Reads the configuration files from the <kbd>/etc/systemd/</kbd> directory</span></span></li>
<li><span><span>Reads the files linked by <kbd>/etc/systemd/system/default.target</kbd></span></span></li>
<li><span><span>Executes the <kbd>/etc/rc.local file</kbd></span></span></li>
</ul>
<p><span><span>Systemd target units are responsible for determining and starting the services automatically on the system after booting up. In this section, we will learn how to control the execution of a set of services on startup. These services will collectively define the state of our system such as it is in single user mode or multi-user mode with networking enabled, and so on.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What are systemd targets?</h1>
                </header>
            
            <article>
                
<p><span><span>Target units are used for grouping and ordering other units. <kbd>systemd</kbd> manages starting several related process at the same time with the help of target units. Some targets, such as <kbd>multi-user.target</kbd>, define a specific state of the system and can be considered as more robust and flexible equivalents of SysV runlevels. At the same time, other targets do not offer any additional functionality except grouping units to manage dependencies effectively. The target unit configuration files are stored in the <kbd>/usr/lib/systemd/system</kbd> directory.</span></span></p>
<p>The following table lists important targets, along with their equivalent runlevels and their descriptions:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Equivalent runlevel</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Target unit</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>0</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>poweroff.target</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Shuts down and powers off the system</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>1</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>rescue.target</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Sulogin prompt with basic system initialization</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>2, 3, 4</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>multi-user.target</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Non-graphical multi-user text-based login only</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>5</span></span></span></span></p>
</td>
<td>
<p><kbd>Graphical.target</kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Graphical multi-user and text-based login</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>6</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><kbd><span><span><span><span>Reboot.target</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Shuts down and reboots system</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span><span>Some targets are part of another target: <kbd>graphical.target</kbd> includes <kbd>multi-user.target</kbd>, which in its turn depends on <kbd>basic.target</kbd> and others. We can view these dependencies from the command line by executing the command line shown in the following screenshot:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3eb870ed-a995-4c28-942f-2f97c25d8b06.png" style="width:39.58em;height:20.08em;" width="873" height="442"/></p>
<p><span><span>We can view the available targets that are currently loaded on the running system by using the following command line:</span></span></p>
<pre style="padding-left: 60px"><strong><span><span># systemctl list-units --type=target --all</span></span></strong></pre>
<p><span><span>We can view all the targets that are installed on the system by using the following command line:</span></span></p>
<pre style="padding-left: 60px"><strong><span><span># systemctl list-unit-files --type=target --all</span></span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Switching your targets at runtime</h1>
                </header>
            
            <article>
                
<p><span><span>In CentOS 7, an administrator can switch to different target (runlevel) at runtime by using the <kbd>systemctl isolate</kbd> command, which was done using the <kbd>telinit</kbd> command in CentOS 6. We can only isolate to those targets that have <kbd>AllowIsolate=yes</kbd> set in their unit files. For example, we can switch to <kbd>multi-user.target</kbd> from <kbd>graphical.target</kbd> with the following command:</span></span></p>
<pre><strong><span><span># systemctl isolate multi-user.target</span></span></strong></pre>
<p><span><span>The preceding command will bring the user to runlevel 3. To switch back to runlevel 5, execute the following command:</span></span></p>
<pre><strong><span><span># systemctl isolate graphical.target</span></span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Changing the default target of the system</h1>
                </header>
            
            <article>
                
<p><span><span>During the booting up of the system, systemd activates <kbd>default.target</kbd>, which is generally a symbolic link in the <kbd>/etc/systemd/system/</kbd> directory to either <kbd>graphical.target</kbd> or <kbd>multi-user.target</kbd>. It is equivalent to the default runlevel, which the system administrator used to set in the <kbd>/etc/inittab</kbd> file.</span></span></p>
<p><span><span>The following table lists the <kbd>systemctl</kbd> commands that are used to manage default targets along with their description:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Command</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span># systemctl get-default</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Views the existing default target</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span># systemctl set-default graphical.target</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Sets the default target to <kbd>graphical.target</kbd> (graphical shell)</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span># systemctl set-default multi-user.target</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Sets the default target to <kbd>multi-user.target</kbd> (text-based shell)</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>
<p>An example to change the default target by using the <kbd>systemctl</kbd> command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/11935dc5-4958-4cc5-b269-8ffd3372baa8.png" width="1138" height="130"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding SELinux concepts</h1>
                </header>
            
            <article>
                
<p><span><span>SELinux is an additional layer of security to protect the system. The permission set by users manually is a kind of security control that works at the user's discretion, while SELinux is a mandatory access control for securing the system. Its main role is to protect data when a system service is compromised. SELinux consists of a set of security rules that determine which process can access which files, directories, or ports.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SELinux contexts</h1>
                </header>
            
            <article>
                
<p><span><span><span>When SELinux is</span> <span>enforced in the system</span><span>, it check for rules on which process can access which files, directories, and ports. Every file, process, directory, and port has a special security label known as an SELinux context, which is a name used to determine whether a process can access a file, directory, or port. By default, the policy does not allow any interaction unless an explicit rule grants access.</span></span></span></p>
<p><span><span><span>S</span><span>ELinux labels have different contexts: user, role, type, and sensitivity. The targeted policy is the default policy enabled in CentOS 7, which defines its rules based on the third context, which is the type context.</span> T<span>ype context name</span><span>s</span> <span>generally end with <kbd>_t</kbd>.</span></span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Viewing SELinux context</h1>
                </header>
            
            <article>
                
<p><span><span>Most of the Linux commands have the <kbd>-Z</kbd> </span></span><span>option</span><span> </span><span>to display SELinux contexts. For example,</span> <kbd>ps</kbd><span>,</span> <kbd>ls</kbd><span>,</span> <kbd>cp</kbd><span>, and </span><kbd>mkdir</kbd> <span>all use <span>the </span></span><kbd>-Z</kbd> <span>option to display or set SELinux contexts of a file, directory, process, or port.</span></p>
<p><strong><span>The following are examples that illustrate the usage of -Z option with several commands for displaying the SELinux context:</span></strong></p>
<ul>
<li><span><span>The <kbd>ps</kbd> command can be used to view processes along with their SELinux contexts:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># ps axZ</span></span></strong></pre>
<ul>
<li><span><span>The <kbd>ps</kbd> command can also be used with option <kbd>-ZC</kbd>, to view the SELinux context of a process specified as an argument as shown in the following example:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># ps -ZC sleep</span></span></strong></pre>
<ul>
<li><span><span>The <kbd>ls</kbd> command can be used with <kbd>-Z</kbd> option to view the SELinux context of files in a directory as shown in the following command line:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># ls -Z /home<br/></span></span><span><span># ls -Z /var/www</span></span></strong></pre>
<ul>
<li><span><span>The <kbd>cp</kbd> command can be used with the <kbd>-A</kbd> option to preserve the SELinux context of a file or directory while performing the copy operation as shown in the following command line:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># cp -A /tmp/demo /var/www/html/</span></span></strong></pre>
<p><span>Generally, the context of the parent directory is assigned to the child, when we create a new file with the <kbd>vim</kbd>, <kbd>cp</kbd>, <span><span>or</span></span> <kbd>touch</kbd> command.</span></p>
<p><span><span>To get a clearer and deeper insight into SELinux concepts, let's consider the workings of an Apache web server in the absence and presence of SELinux controls:</span></span></p>
<ul>
<li><span><span><strong>In the absence of SELinux</strong>: In this case, the web server is running on port <kbd>80</kbd>, which is opened in the firewall to allow access for service web pages. Let's assume the attacker has compromised the Apache service due to a vulnerability in it. After compromising it, the attacker will gain access to the document root with the permissions of the Apache user and Apache group. Hence, an attacker can create and write files in the <kbd>/var/www/html/</kbd>,</span></span> <kbd>/tmp</kbd>, <span><span>and <kbd>/var/tmp</kbd> directories.</span></span></li>
<li><span><span><strong>In the presence of SELinux enforcing mode</strong>: In this case, SELinux checks for the rules given in the targeted policy, which are based on type context. The SELinux context type for Apache web server process is <kbd>httpd_t</kbd> and SELinux context type of files and directories in <kbd>/var/www/html</kbd> is <kbd>httpd_sys_content_t</kbd><strong>.</strong> The SELinux context type of files and directories in <kbd>/tmp</kbd> and <kbd>/var/tmp</kbd> is <kbd>tmp_t</kbd><strong> </strong>in enforcing mode.</span></span></li>
</ul>
<p><span><span>The targeted policy rule permits the process running as <kbd>httpd_t</kbd> to access files and directories with the context <kbd>httpd_sys_content_t</kbd>, so access to files or directories in <kbd>/tmp/</kbd> and <kbd>/var/tmp/</kbd> is not permitted. Thus, even if a malicious user compromises the web server, they cannot create or write a file in the <kbd>/tmp/</kbd> or <kbd>/var/tmp</kbd> directories. The damage caused by the user will remain restricted to the <kbd>/var/www/html</kbd> folder as shown in the following diagram:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/35807258-cc5d-48b5-bb38-8e098a93ba4f.png" style="width:91.17em;height:37.25em;" width="971" height="397"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with SELinux</h1>
                </header>
            
            <article>
                
<p><span><span>This section deals with various commands used to manage the SELinux context and enforced policies applied on files, directories, processes, and ports.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Changing SELinux modes</h1>
                </header>
            
            <article>
                
<p><span><span>SELinux has three modes of operation, mentioned in the following table:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>SELinux mode</span></span></span></strong></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>Enforcing</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>In this mode, rules are available and applied. SELinux logs the activities and protects the system.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>Permissive</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>In this mode, rules are available but not applied. This mode is mainly used for troubleshooting. This mode is used to temporarily allow access to content that SELinux was restricting in enforcing mode. In this mode, SELinux logs the denied actions. System reboot is not required to switch from enforcing to permissive mode and vice versa.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><span><span><span><span>Disabled</span></span></span></span></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>In this mode, rules are not available. It completely disables SELinux. A system reboot is required to disable or switch from enforcing or permissive mode to disabled mode, as it completely relabels the files.</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using setenforce for runtime changes</h1>
                </header>
            
            <article>
                
<p><span><span>We can change the SELinux modes from enforcing to permissive and vice versa during runtime by using the <kbd>setenforce</kbd> command. Before and after changing the SELinux mode, we must ensure the current mode by using the <kbd>getenforce</kbd> command.</span></span></p>
<p><strong><span><span>The following are examples that illustrate the usage of the setenforce and getenforce commands:</span></span></strong></p>
<ul>
<li><span><span>To display the current SELinux mode, use the following command:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># getenforce</span></span></strong></pre>
<ul>
<li><span><span>To change the current SELinux mode from enforcing to permissive, use either of the following commands:</span></span></li>
</ul>
<pre style="padding-left: 60px"><span><span><strong># setenforce 0<br/></strong>or<br/></span></span><strong># setenforce Permissive</strong><span><span><br/></span></span></pre>
<ul>
<li><span><span>To change the current SELinux mode from permissive to enforcing, use either of the following commands:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># setenforce 1<br/></span></span></strong><span><span>or</span></span><strong><span><span> <br/></span></span></strong><strong># setenforce Enforcing</strong></pre>
<ul>
<li><span><span>To view detailed SELinux information, use the following command:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># sestatus</span></span></strong></pre>
<div class="packt_tip"><span><span><span>Another way to temporarily change the SELinux mode is by passing a parameter to the kernel at boot time. Passing a kernel argument of <kbd>enforcing=0</kbd> will boot the system in permissive mode for that instance and <kbd>selinux=1</kbd> will boot the system in enforcing mode.</span></span></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting default modes of SELinux</h1>
                </header>
            
            <article>
                
<p><span><span>The configuration file of SELinux is <kbd>/etc/selinux/config</kbd>. It determines the mode and policy of SELinux at boot time. We can modify the <kbd>/etc/selinux/config</kbd> file and set the <kbd>SELINUX=permissive</kbd> </span></span><span>parameter </span><span>to change the default mode of SELinux, as shown in the following diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b6ca328a-276e-4e4a-b43c-74542b11ce5e.png" width="732" height="274"/></p>
<div class="packt_infobox"><span><span>In previous releases of CentOS, the SELinux configuration file was stored at <kbd>/etc/sysconfig/selinux</kbd>. Now, in CentOS 7, this file is a <kbd>symlink</kbd> of <kbd>/etc/selinux/confg</kbd>.</span></span></div>
<p><span><span>If any kernel argument of <kbd>enforcing=0</kbd> for permissive mode or <kbd>selinux=0</kbd> for disabling SELinux is passed at boot, then it will override the current configuration set in <kbd>/etc/selinux/config</kbd>.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modifying file context</h1>
                </header>
            
            <article>
                
<p><span><span>As mentioned earlier, generally, the parent directory SELinux context is assigned to the newly created file, if it is created using the <kbd>vim</kbd>,</span></span> <kbd>cp</kbd>, or<span><span> <kbd>touch</kbd> command.</span></span></p>
<p><span><span>If a file is moved using the <kbd>mv</kbd> command, or copied using the <kbd>cp -a</kbd> command, the original SELinux context will remain unchanged.</span></span></p>
<p><span><span>Often, we need to modify the file context as per the destination directory, so that a process can access the file object when required. In the following sections, we discuss the different utilities that can be used to achieve this.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using restorecon for restoring the default context</h1>
                </header>
            
            <article>
                
<p><span><span>Using the <kbd>restorecon</kbd> command is the most popular and preferred way of modifying the SELinux context of a file or directory. As is visible from the name of the <kbd>restorecon</kbd> command, it is used to restore the default context of a file or directory by reading the default rules set in the SELinux policy. If the wrong context is applied, <kbd>restorecon</kbd> automatically corrects it from the policy of the filesystem.</span></span></p>
<p><span><span>In the following example, we simulate a problem scenario, in which a file has incorrect syntax and we correct it using the <kbd>restorecon</kbd> command:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/050bd30d-9268-49b6-bd13-0d28dada3106.png" width="881" height="191"/></p>
<p><span><span>The <kbd>restorecon</kbd> command is a part of the <kbd>policycoreutil</kbd> package, so in order to use this command, this package should be installed on the system.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using chon for context management</h1>
                </header>
            
            <article>
                
<p><span><span>The <kbd>chcon</kbd> command can also be used with the <kbd>_t</kbd> option to change the context of the file. This method of modifying the context of the file is not recommended, as errors can happen while using it. The <kbd>chcon</kbd> command, when used, writes the new context to the filesystem, but the policy remains unchanged. Hence, changes made using this command get overwritten on relabeling the SELinux context on the filesystem.</span></span></p>
<p><span><span>An example of <kbd>chcon</kbd> command usage is shown in the following diagram:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/cffee1d0-5d92-47b7-bf04-bdbeea07255f.png" style="width:45.83em;height:13.83em;" width="779" height="235"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using semanage for context management</h1>
                </header>
            
            <article>
                
<p><span><span>The <kbd>semanage</kbd> command writes the new context to the SELinux policy, which is used to apply the file context at the relabeling of the file labels or while setting the default file context using <kbd>restorecon</kbd>. It uses an extended regular expression to specify the path and filenames for applying those rules (new file context). The most commonly used extended regular expression with <kbd>semanage fcontext</kbd> is <kbd>(/.*)?</kbd>. This expression matches the directory listed before the expression and everything in that directory recursively.</span></span></p>
<p><span><span>An example of <kbd>semanage</kbd> command usage is shown in the following diagram:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/43e888d3-696f-4e23-90dc-93becf4b59fe.png" width="855" height="223"/></p>
<p><span><span>The <kbd>semange</kbd> command is a part of the <kbd>policycoreutil-python</kbd> package. In order to use</span></span> <span>the </span><kbd>semanage</kbd> <span><span>command, make sure this package is installed in the system.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modifying port context</h1>
                </header>
            
            <article>
                
<p><span><span>SELinux does much more than just restricting the access of processes to files based on SELinux labels. It can also control the network traffic by restricting access to unauthorized ports for a service. By default, the SELinux policy allows the <kbd>ssh</kbd></span></span> service to access port, <kbd>22</kbd>/TCP . In the following example, we allow <kbd>ssh</kbd> to run on another port <kbd>2525</kbd>/TCP, in addition to its default port, as shown in the following steps:</p>
<ol>
<li><span><span>The</span></span> <kbd>semanage</kbd> <span><span>command can be used with</span></span> <span>the </span><kbd>port</kbd> sub-command <span><span>to list the current port assigned to a service as shown in the following screenshot:</span></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e12d5039-89dd-49c8-b19d-71e6aece8808.png" style="width:24.33em;height:3.25em;" width="545" height="72"/></p>
<ul>
<li><span><span>We can also use the <kbd>semanage</kbd> command for granting access to any custom port for a particular service. In the following screenshot, the <kbd>semanage</kbd> command is used to add the selected port to the access list of a particular service:</span></span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ef47cc4b-d00a-41dc-a45b-4c8aedf0225c.png" style="width:34.00em;height:6.75em;" width="687" height="136"/></p>
<ul>
<li><span><span>The <kbd>semanage</kbd> command can also be used to remove an association of a port to a particular service as shown in the following screenshot:</span></span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6b06f18a-b18e-4e41-9b8e-7ca0b0998741.png" style="width:32.67em;height:6.58em;" width="687" height="138"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing SELinux Booleans</h1>
                </header>
            
            <article>
                
<p><span><span>SELinux Booleans are switches that contains a set of rules to make a selective adjustment in behavior to an SELinux policy. SELinux Booleans provide an easy interface to change the behavior of an SELinux policy rule.</span></span></p>
<p><span><span><strong>The following are examples that illustrate the usage of the getsebool and setsebool commands for managing SELinux Booleans:</strong></span></span></p>
<ul>
<li><span><span>The <kbd>getsebool</kbd> command can be used with the <kbd>-a</kbd> option to display the list of all SELinux Booleans and their current values as shown in the following command line. The output of this command is passed to a grep filter to narrow down the results:</span></span></li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># getsebool -a</span></span></strong></pre>
<ul>
<li>
<p>The output of the <kbd>getsebool -a</kbd> command can be filtered down using <kbd>grep</kbd> as shown in the following command line:</p>
</li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># getsebool -a | grep ftp</span></span></strong></pre>
<ul>
<li>The <kbd>setsebool</kbd> command can be used to modify (switch on or off) the value of a SELinux Boolean at runtime as shown in following command line:</li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># setsebool ftp_home_dir on</span></span></strong></pre>
<ul>
<li>Modify runtime value as well as the default values of the SELinux Boolean simultaneously by using the <kbd>setsebool</kbd> command with the <kbd>-P</kbd> option as shown in the following command line:</li>
</ul>
<pre style="padding-left: 60px"><strong><span><span># setsebool -P ftp_home_dir on</span></span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing SELinux troubleshooting</h1>
                </header>
            
            <article>
                
<p><span><span>SELinux provides an essential layer of security beyond the discretionary access control set by the user. It prevents any unauthorized attempt to access a resource such as a file by a running process. Here, the process that attempt to access a resource could be a genuine process or it could be a compromised process. Disabling SELinux is not considered good practice. Sometimes, when a binary or application is installed from a third party, it does not contain any appropriate SELinux context, which may lead to restrictions in running that service properly. In those circumstances, SELinux is run in permissive mode and new rules are created based on the denial of service messages captured in log files. In most cases of SELinux troubleshooting, it has been observed that access control restrictions are applied by SELinux due to incorrect type context on a file. This issue can be easily resolved using the <kbd>restorecon</kbd> command, which sets the default context on files from SELinux rules given in a policy. Using this method, we can keep our SELinux in enforcing mode and the security of our systems intact.</span></span></p>
<p><span><span>Modifying the mode of SELinux Booleans by turning their values on and off is also used sometimes to relax or harden the SELinux controls for running a service. For making an appropriate change in SELinux rules or policies, the primary requirement is to understand the problem correctly. In this, the monitoring of SELinux violations by going through logs plays an important role. For logging SELinux messages to <kbd>/var/log/messages</kbd> and <kbd>/var/log/audit/audit.log</kbd> in an easily understandable format, the</span></span> <kbd>setroubleshoot-server</kbd><span><span> package should be installed on the system with the following command:</span></span></p>
<pre style="padding-left: 30px"><strong><span><span># yum install setroubleshoot-server -y</span></span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using sealert for troubleshooting</h1>
                </header>
            
            <article>
                
<p><span><span>Each SELinux violation is assigned a <strong>unique</strong> <strong>identifier</strong> (<strong>UUID</strong>). This UUID is used with the <kbd>sealert</kbd> command to produce a summary of a report for a specific incident.</span></span></p>
<p><span><span>For example, let's create a file in root's home directory and move this file into <kbd>/var/www/html/</kbd>. Now, try to access that file through the web browser or from the command line using <kbd>curl</kbd> as shown in the following diagram:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8f16bb7d-acef-41bb-bbc5-23312d367c8b.png" width="986" height="420"/></p>
<p><span><span>The error report of the SELinux violation can be viewed now, using the UUID and <kbd>sealert</kbd> command, as shown in the following screenshot:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/82906200-6c23-483f-a6c0-49ba61183f76.png" width="1012" height="521"/></p>
<p><span><span>On applying the suggestions of the SELinux violation given in</span></span> <span>the </span><kbd>sealert</kbd> <span><span>report, it will remove the error and allow access to the file using the <kbd>curl</kbd> command as shown in the following screenshot:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3e16bbda-1112-4f07-bf12-b40e9ad60dbd.png" width="983" height="118"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding firewall concepts in CentOS 7</h1>
                </header>
            
            <article>
                
<p><span><span>Operating system security generally follows a defense in depth model, where security is implemented at different layers in the system. Starting from policies and procedure, physical controls, network perimeter security, host security, application security, and so on, several elements are secured to harden the security of a system. In this, a firewall helps in securing the system, as well as applications, by limiting access to the system. Firewall rules filter packets based on specific criteria, such as IP addresses, port and protocol, and so on.</span></span></p>
<p><span><span>In Linux, firewall rules are managed by the network filtering subsystem available in the kernel and known as <strong>netfilter.</strong> The netfilter framework enables the system to inspect, modify, drop, or reject any incoming, outgoing, or forwarded network packet programmatically.</span></span></p>
<p><span><span>The <kbd>iptables</kbd> command is the most popular tool used to interact with netfilter and manage the firewall. The <kbd>iptables</kbd> command only manages the IPv4 rules in the firewall. For management of IPv6 rules, the <kbd>ip6tables</kbd> command is used, and for software bridges, the <kbd>ebtables</kbd> utility is used. However, managing the firewall using the <kbd>iptables</kbd> utility is not user friendly and requires a good understanding of </span></span><span>both <span>the </span></span><span>firewall and</span> <kbd>iptables</kbd> <span>command. Thus, to overcome the complexity of</span> <kbd>iptables</kbd> <span>and incorporate some advanced features, a new utility, </span><kbd>firewalld</kbd>, <span>was designed.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Firewalld concepts</h1>
                </header>
            
            <article>
                
<p><span><span>In CentOS 7, a new utility called <strong>firewalld</strong> has been introduced to interact with netfilter. It can be used to configure and monitor the firewall rules for IPv4, IPv6, and for software bridges. Furthermore, applications can interact with <kbd>firewalld</kbd> to add or change firewall rules, such as a requesting for a port opening with the help of the D-bus messaging system. firewalld supports both runtime configuration and persistence configuration. It is installed by default in the CentOS Base installation, but if it is not available, then user can install it is using the following command lines:</span></span></p>
<pre><strong><span><span># yum install firewalld -y<br/></span></span><span><span># systemctl start firewalld <br/></span></span><span><span># systemctl enable firewalld</span></span></strong></pre>
<p><span><span>firewalld is not compatible with the <kbd>iptables</kbd> service, so it is strongly recommended to not use them simultaneously on the same system. Either use <kbd>firewalld</kbd> and disable <kbd>iptables</kbd> (<kbd>iptables</kbd>, <kbd>ip6tables</kbd>, and <kbd>ebtables</kbd>), or use <kbd>iptables</kbd> and disable <kbd>firewalld</kbd>.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Firewalld zones</h1>
                </header>
            
            <article>
                
<p><span><span>The firewalld segregates incoming traffic into zones. Each zone is a collection of rules. To select which zone is to be used for an incoming connection, firewalld uses the following three rules to match in the given order:</span></span></p>
<ul>
<li><span><span><span><strong>The source address</strong> on the incoming packet is matched with the source address rule configured for the zone. If the source address matches, the packet is routed through that zone.</span></span></span></li>
<li><span><span>If the source address does not match, then the <strong>incoming interface</strong> for a packet is matched with the interface set up for the zone and that zone is used.</span></span></li>
<li><span><span>If neither the incoming interface of the packet nor the source address of a packet matches, then the rules given in the <strong>default zone</strong> are applied on that packet. The default zone is one of the other zones defined by the system or user. By default, the public zone is set as the default zone. The example of <kbd>firewall-cmd</kbd> to list the available zones and default zone is shown in the following screenshot</span></span><span><span>:</span></span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b0ac9f56-60a9-4da7-82aa-6f91c115f2d6.png" style="width:30.42em;height:5.08em;" width="659" height="110"/></p>
<p><span><span>The following table lists the predefined zones available in</span></span> <kbd>firewalld</kbd> <span><span>and their descriptions:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><span><span><span><strong>Zone</strong></span></span></span></span></p>
</td>
<td style="background: transparent">
<p class="CDPAlignCenter CDPAlign"><span><strong><span><span><span>Description</span></span></span></strong></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>trusted</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Allows all incoming traffic.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>home</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>This zone is used for home networks. In this zone, incoming traffic is rejected unless it is related to outgoing traffic or it matches the predefined services of zone, such as <kbd>ssh</kbd>, <kbd>mdns</kbd>, <kbd>ipp-client</kbd>, <kbd>samba-client</kbd>, or <kbd>dhcpv6-client</kbd>.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>internal</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>This zone has the same rules as defined in the home zone. It is generally used for internal networks.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>work</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>In this zone, all incoming traffic is rejected, unless it is related to outgoing traffic or it matches some predefined services of the zone, such as, <kbd>ssh</kbd>, <kbd>mdns</kbd>, <kbd>ipp-client</kbd>, or <kbd>dhcpv6-client</kbd>:</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>public</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>In this zone, all incoming traffic is rejected, unless it is related to outgoing traffic or it matches some predefined services of the zone, such as <kbd>ssh</kbd> or <kbd>dhcpv6-client</kbd>.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>external</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>In this zone, all incoming traffic is rejected, unless it is related to outgoing traffic or it matches some predefined services of zone, such as <kbd>ssh</kbd>. Outgoing IPv4 traffic forwarded from this zone is masqueraded (NAT) to make it originate from the outgoing network interface.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>dmz</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span><kbd>dmz</kbd> is the demilitarized zone. Only selected incoming connections with limited access to the internal network are allowed. All other traffic is rejected.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>block</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>Reject all incoming traffic with an <kbd>icmp-host-prohibited</kbd> message. Only incoming traffic related to connections originating from the outgoing traffic of the system is allowed.</span></span></span></span></p>
</td>
</tr>
<tr>
<td style="background: transparent">
<p><kbd><span><span><span><span>drop</span></span></span></span></kbd></p>
</td>
<td style="background: transparent">
<p><span><span><span><span>In this zone, all incoming traffic is dropped (without any ICMP errors) unless it is related to outgoing traffic.</span></span></span></span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Firewalld services</h1>
                </header>
            
            <article>
                
<p><span><span>The other main component of firewalld is services. There are certain default services that are used to allow or deny access to traffic on specific ports, for a particular network service in the firewall. Each service has got a configuration file that describes its requirements, such as what TCP or UDP ports are required for service operation. Users can list all the available services in</span></span> firewalld <span><span>with the command shown in the following screenshot:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/35287e48-5931-432c-bc54-8bce532880b3.png" width="1055" height="287"/></p>
<p><span><span>For the secure configuration of</span></span> firewalld<span><span>, each service should be allowed access in the correct zone.</span></span></p>
<p><span><span>The services configuration file is stored in the following two directories:</span></span></p>
<ul>
<li><kbd><span><span>/usr/lib/firewalld/services</span></span></kbd></li>
<li><kbd><span><span>/etc/firewalld/services</span></span></kbd></li>
</ul>
<p><span><span>These services files are configured in XML format. An example of the <kbd>ftp.xml</kbd> file is shown in the following screenshot:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e707c6af-6c80-40bd-8733-5e5c2ae33d2f.png" style="width:53.92em;height:12.33em;" width="1058" height="242"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing firewalld</h1>
                </header>
            
            <article>
                
<p><span><span>Firewalld can be managed in the following two ways.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the firewalld-cmd command-line tool</h1>
                </header>
            
            <article>
                
<p><span><span>This is the most common method of managing</span></span> firewalld <span><span>configurations (both running as well as permanent). In this section, we have described the management of firewalld with this tool. It can perform all the jobs that are performed using the firewalld-config</span></span><span> GUI tool</span><span>. This tool is a part of <span>the </span></span><kbd>firewalld</kbd> <span>package.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the firewalld-config graphical tool</h1>
                </header>
            
            <article>
                
<p><span><span>Firewall-config is a graphical tool that is used to modify and view the running (in-memory) configuration of firewalld, as well as permanent (on hard disk) configuration. This tool is a part of the firewall-config package. It is invoked from the command line by typing <kbd>firewall-config</kbd>.</span></span></p>
<p><span><span>The configuration files of firewalld are stored inside the <kbd>/etc/firewalld/</kbd> directory. Firewalld supports two types of configurations:</span></span></p>
<ul>
<li><span><strong><span><span>Runtime or in-memory configurations</span></span></strong><span><span>:</span></span><strong><span><span> </span></span></strong></span><span><span>The in-memory configurations of</span></span> firewalld <span><span>are lost on reloading</span></span> firewalld <span><span>or after rebooting of system.</span></span></li>
<li><span><strong><span><span>Permanent or on-disk configurations</span></span></strong><span><span>: </span></span></span><span><span>This configuration remains after reboot and is applied on reloading</span></span> firewalld.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with firewalld</h1>
                </header>
            
            <article>
                
<p><span><span>Before starting</span></span> firewalld<span><span>, we need to ensure that <kbd>iptables</kbd>, <kbd>ip6tables</kbd>, and <kbd>ebtables</kbd> are not running, as they conflict with</span></span> firewalld.</p>
<p><strong>The following are examples that illustrate the usage of firewalld-cmd command:</strong></p>
<ol>
<li><span><span>Stop the conflicting service of <kbd>iptables</kbd>, <kbd>ip6tables</kbd>, and <kbd>ebtables</kbd> using the following command:</span></span></li>
</ol>
<pre style="padding-left: 60px" class="western"><strong><span><span># systemctl stop iptables</span></span>
<span><span># systemctl mask iptbales<br/></span></span><span><span># systemctl stop ip6tables<br/></span></span><span><span># systemctl mask ip6tables<br/></span></span><span><span># systemctl stop ebtables<br/></span></span><span><span># systemctl mask ebtables</span></span></strong></pre>
<ol start="2">
<li>The following command is used to <kbd>start</kbd> and enable <kbd>firewalld</kbd> in CentOS 7: </li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># systemctl start firewalld<br/></span></span><span><span># systemctl enable firewalld<br/></span></span><span><span># systemctl status firewalld</span></span></strong></pre>
<ol start="3">
<li>Now, the first step in configuring <kbd>firewalld</kbd> should be to check the existing zones and services that are configured by default and the zones and services that the user has not configured:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li><span><span>List all the zones in <kbd>firewalld</kbd> by using the following command line:</span></span></li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px"><span><span><strong># firewall-cmd --get-zones</strong> </span></span></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>List only active zon<span><span>es of</span></span> <kbd>firewalld</kbd> <span>by using the following command line:</span></li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px"><strong><span><span># firewall-cmd --get-active-zones</span></span></strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li><span><span>List the current default zone by using the following command line:</span></span></li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px"><strong><span><span># firewall-cmd --get-default-zone</span></span></strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li><span><span>List the services available for configuration with</span></span> <kbd>firewalld</kbd> <span>by using the following command line:</span></li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px"><strong><span><span># firewall-cmd --get-services</span></span></strong></pre>
<ol start="4">
<li>After making any changes in <span>the </span><kbd>firewalld</kbd> configuration, it is mandatory to reload it to bring the applied changes into effect. By default, all changes made are runtime changes only. We can make them permanent by using <span>the </span><kbd>--</kbd>permanent option. It will preserve the configuration changes across reboot. Now, let's change the default zone using the <kbd>firewalld-cmd</kbd> command as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --set-default-zone=internal</span></span></strong></pre>
<p style="padding-left: 60px"><span><span>After updating the default zone, we should confirm the setting of the current default zone by using the following command line:</span></span></p>
<pre><strong><span><span># firewall-cmd --get-default-zone</span></span></strong></pre>
<ol start="5">
<li><span><span> </span></span>Now, let's add a port to <span>the </span>public zone using <kbd>firewall-cmd</kbd> permanently by using the following command line:</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --permanent --zone=internal --add-port=80/tcp --permanent</span></span></strong></pre>
<p style="padding-left: 60px"><span><span>In the preceding command, if we don't add the <kbd>--permanent</kbd> option, then changes will get lost after reloading the <kbd>firewalld</kbd> configuration. We can reload the <kbd>firewalld</kbd> configuration by using the following command line:</span></span></p>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --reload</span></span></strong></pre>
<p style="padding-left: 60px"><span><span>Now, see the status of recently added TCP port <kbd>80</kbd> in <kbd>firewalld</kbd>:</span></span></p>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --zone=internal --list-ports</span></span></strong></pre>
<p style="padding-left: 60px"><span><span>We can also use the <kbd>firewall-cmd</kbd> command to view the complete configuration for a zone. In the following example, we list the complete configuration of the internal zone:</span></span></p>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --zone=internal --list-all</span></span></strong></pre>
<ol start="6">
<li>In the following example, we use the <kbd>firewall-cmd</kbd> command to remove TCP port <kbd>80</kbd> from the internal zone as shown in the following command line:</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --zone=internal --remove-port=80/tcp</span></span></strong></pre>
<ol start="7">
<li>Add a service to a zone in <kbd>firewalld</kbd>. The following example shows how to add an <kbd>ftp</kbd> service in <span>the </span><kbd>firewalld</kbd> internal zone:</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --zone=internal --add-service=ftp</span></span></strong></pre>
<ol start="8">
<li>List the services in a zone by using the following command line:</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --list-services --zone=internal</span></span></strong></pre>
<ol start="9">
<li>Remove a service from a zone in <kbd>firewalld</kbd> by using the following command line:</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --zone=internal --remove-service=ftp</span></span></strong></pre>
<ol start="10">
<li>The user can drop all incoming and outgoing packets of an active connection when there is a breach in <span>the </span>network by using the panic options of <kbd>firewall-cmd</kbd> as shown in the following command line:</li>
</ol>
<pre style="padding-left: 60px"><strong><span><span># firewall-cmd --panic-on</span></span></strong></pre>
<p style="padding-left: 60px"><span><span>On execution of the preceding command, any ping, <kbd>ssh</kbd>, or web-related activity on the system will be blocked. To turn off this feature, execute the following command:</span></span></p>
<pre style="padding-left: 60px"><strong><span><span># firewall --panic-off</span></span></strong></pre>
<div class="packt_tip packt_infobox"><span><span><span>Besides the <kbd>firewall-cmd</kbd> configuration rules that we have discussed in this section, firewalld has two more options for adding firewall rules, direct rules and rich rules.</span></span></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span><span>In this chapter, we began by learning what the different types of logging in the Linux system </span></span><span>are,</span><span> </span><span>and how to use them effectively for debugging and troubleshooting Linux systems. Then, we learned about managing </span><span>system services to optimize system performance. This was followed by understanding SELinux concepts to harden the security of applications and <span>the </span>system. Finally, we looked at how to filter the incoming and outgoing packets in the system using</span> <span><span>the </span>firewalld</span> <span>framework.</span></p>
<p><span><span>Linux is all about learning by doing. If you have practiced the commands given in each chapter, together with the theoretical part, you will feel more comfortable while working on Linux. This book is written for novice Linux users, yet a seasoned Linux user will also have something to take away from each chapter. With this, our fascinating journey of kick-starting Linux with the CentOS 7 operating system comes to an end.</span></span> <span>If you have any queries, I would like to hear it from you. You can reach me at <kbd>shiwangkalkhanda@outlook.com</kbd>.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>