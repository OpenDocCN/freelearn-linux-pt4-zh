- en: Alternative Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the scripting journey, we have seen that we can use the `test` command
    to determine a conditional status. We have taken this a little further and discovered
    that we can also make use of the single square bracket. Here, we will recap the
    `test` command and look at the single square bracket in more detail. After having
    learned more about the square bracket, we will move onto more advanced variable
    or parameter management, thus providing defaults and understating quoting issues.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are going to see that within advanced shells such as bash, Korn,
    and Zsh, we can go with double brackets! Making use of the double round parenthesis
    and double square bracket can simplify the overall syntax and allow the standardization
    of the use of mathematical symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Recapping `test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing parameter defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in doubt – quote!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced tests using `[[`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operations using `((`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: Recapping the test command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have used the built-in `test` command to drive our conditional statements.
    Using other options with `test`, we can look at the returned value to determine
    the status of files in the filesystem. Running the `test` command without any
    options will return a false output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Testing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Commonly, we can use `test` to check the conditions based around files. For
    example, to test whether a file is present or not, we can use the `-e` option.
    The following command will test the existence of the `/etc/hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run this `test` again, but this time check that the file not only exists
    but is a regular file as opposed to having some special purpose. Specific file
    types can be directories, pipes, and links, among others. The option for a regular
    file is `-f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adding logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we need to open a file from within our script, we test that the file is
    both a regular file and has the read permission set. To achieve this with `test`,
    we can also include the `-a` option to `AND` multiple conditions together. In
    the following example command, we will use the `-r` condition to check that the
    file is readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the use of `-o` is supported to `OR` two conditions within an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Square brackets as not seen before
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an alternative to the `test` command, we can implement the same conditional
    tests using the single square bracket. Repeating the previous conditional `test`
    and omitting the command itself. We will rewrite this, as shown in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Many times, even as experienced administrators, we are used to language elements
    and we accept them as they are. I feel many Linux administrators will be surprised
    to learn that `[` is a command for both a shell built-in and a standalone file.
    Using the `type` command, we can verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the output of this command in the following screenshot confirming
    its existence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af5fd18f-715b-4990-8093-d42b9adefdcb.png)'
  prefs: []
  type: TYPE_IMG
- en: The built-in `[` command imitates the `test` command but it requires a closing
    bracket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know a little more about the `[` command, which is found in bash and
    the earlier Bourne shell, we can now continue to add a little command-line list
    syntax. In addition to the command-line list, we can see the desired functionality
    working in the following command sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Having set the parameter `FILE` variable, we can test that it is both a regular
    file and is readable by the user before attempting to list the file contents.
    In this way, the script becomes more robust without the need for a complex script
    logic. We can see the code in use in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c04243c-1855-4723-b90a-44d825d28e77.png)'
  prefs: []
  type: TYPE_IMG
- en: This type of abbreviation is quite common and is easily recognizable. We should
    always be cautious of using abbreviations if they do not add readability. Our
    aim in scripting should be to write clear and understandable code and avoid shortcuts
    if they do not add to this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Providing parameter defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within bash parameters, there are named spaces in the memory that allow us
    access to stored values. There are two types of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already described what variables are and how to define them in Chapter 1,
    *The What and Why of Scripting with Bash*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to refresh your memory, you can define a variable by assigning a value
    with an equals sign and without any spaces like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So nothing new here.
  prefs: []
  type: TYPE_NORMAL
- en: Special parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Special parameters are the second parameter type and are managed by the shell
    itself and are presented as read-only. We have come across these before in parameters
    such as `$0` but let''s take a look at another `$-`. We can expand these parameters
    to gain an understanding of their use, using the `echo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the annotated text that I have added, we can understand that the `$-` option
    represents the shell options that are configured. These can be displayed using
    the set `-o` command but it can be read programmatically using `$-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4b7bb52-bd42-4f29-acf6-01839cf6d812.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The options set here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`h`: This is short for hashall; it allows for programs to be found using the `PATH`
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i`: This shows that this is an interactive shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: This is short for monitor; it allows the use of the `bg` and `fg` commands
    to bring commands in and out of the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`B`: This allows the brace expansion or `mkdirdir{1,2}`, where we create `dir1`
    and `dir2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H`: This allows history expansion of running commands, such as `!501` to repeat
    commands from history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using either the `test` command or the brackets, we can provide default values
    for variables, including command-line parameters. Taking the `hello4.sh` script
    we worked with earlier, we can modify it and set the `name` parameter if it is
    zero bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is functional but it is our choice how we code in the default value.
    We can, alternatively, assign a default value directly to the parameter. Consider
    the following command, where a default assignment is made directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In bash, this is known as **parameter substitution** and can be written in
    the following pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wherever a variable (`parameter`) has not been declared and has a null value,
    the default value will be used. If the parameter has been explicitly declared
    with a null value, we will use the `:-` syntax, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By editing the script now, we can create `hello8.sh` to make use of bash parameter
    substitution to provide the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This script and its output, both with and without a supplied value, are shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22032c85-3f5a-457b-bf7f-e7307cb9988e.png)'
  prefs: []
  type: TYPE_IMG
- en: The `hello8.sh` script provides the functionality that we need, with the logic
    built directly into the parameter assignment. The logic and assignment are now a
    single line of code within the script and this is a major step in keeping the
    script simple and maintaining the readability.
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt – quote!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having established that variables are a type of parameter, we should always
    keep this in mind, especially when reading manuals and *HOWTOs*. Often the documentation
    refers to parameters and, in doing so, they include variables, as well as the
    bash special parameters, such as `$1` and so on. In keeping with this, we will
    look at why it is advisable to quote the parameters when we use them on the command
    line or within scripts. Learning this now can save us a lot of pain and heartache
    later, especially when we start looking at loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the correct term that we should use for reading the value of variables
    is **parameter expansion**. To you and me, this is reading a variable, but to
    bash this would be too simple. The assignment of a correct name, such as parameter
    expansion, reduces any ambiguity to its meaning but adds complexity at the same
    time. In the following example, the first line of command assigns the value of
    `fred` to the `name` parameter. The second line of command uses parameter expansion
    to print the stored value from memory. The `$` symbol is used to allow the expansion
    of the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we have used the double quotes to allow `echo` to print the
    single string as we have used spaces. Without the use of quotes, `echo` might
    have seen this as multiple arguments, the space being the default field separator
    in most shells, including bash. Often, when we do not think to use quotes, we
    do not see the spaces directly. Consider the following extract of command-line
    code that we made use of earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though this worked, we may have been a little fortunate, especially if
    we were populating the `FILE` parameter from a list of files that we had not created
    ourselves. It is quite conceivable that a file can have spaces within its name.
    Let''s now replay this command using a different file. Consider the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Even though, structurally, there has been no change to the code, it now fails.
    This is because we are providing too many arguments to the `[` command. The failing
    result will be the same even if we use the `test` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we have correctly quoted the assignment of the filename to the
    parameter `FILE`, we have not protected the spaces when the parameter is expanded.
    We can see the code failing, as it is captured in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93d92de0-8e42-4c20-99b3-575ecdcf2121.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that this will not be ready for our scripts. Alas, what we once thought
    of as robust is now in tatters and, like the Titanic, our code has sunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a simple solution is to revert to quoting parameter expansion unless
    specifically not desired. We can make this ship unsinkable with a simple edit
    to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now proudly stand on the White Star Line dock, as we see the Titanic
    II get launched in the following code example, which is captured in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c81415b8-5644-400f-8caf-8364adcd5986.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is truly amazing and sometimes just a little unbelievable what effect these
    tiny quotes can have. We should never ignore the quotes when expanding variables.
    To ensure that we drill home this point, we can highlight this phenomenon in another,
    even simpler, example. Let''s take the scenario where we now just want to remove
    the file. In the first example, we do not use quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce failures as the parameter expansion will lead to the
    following perceived command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The code will fail because it is unable to find the `my` file or the `file`
    file. Even worse, we could potentially be deleting incorrect files if any of the
    names could be resolved accidentally. However, quoting the parameter expansion
    will save the day, as we see in the second example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is correctly expanded to the desired command that we illustrate in the
    following command example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: I certainly hope that these examples demonstrate the need for care when expanding
    parameters and make you aware of the pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced tests using [[
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The use of the double brackets `[[ condition ]]` allows us to do more advanced
    condition testing but it is not compatible with the Bourne shell. The double brackets
    were first introduced as a defined keyword in the KornShell and are also available
    in bash and Zsh. Unlike the single bracket, this is not a command but a keyword.
    The use of the `type` command can confirm this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: White space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fact that `[[` is not a command is significant where white space is concerned.
    As a keyword, `[[` parses its arguments before bash expands them. As such, a single
    parameter will always be represented as a single argument. Even though it goes
    against best practice, `[[` can alleviate some of the issues associated with white
    space within parameter values. Reconsidering the condition we tested earlier,
    we can omit the quotes when using `[[`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We still need to quote the parameter when using `cat`, as you can see, and we
    can use quotes within the double brackets but they become optional. Note that
    we can also use the more traditional `&&` and `||` to represent `-a` and `-o`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Other advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are some of the extra features that we can include with the double brackets.
    Even if we lose portability in using them, there are some great features that
    overcome the loss. Remember that if we only use bash, then we can use the double
    brackets but can't run our scripts in the Bourne shell. The advanced features
    that we gain, which are covered in the following sections, include pattern matching
    and regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the double brackets, we can do more than just match strings, we can use
    pattern matching. For example, we may need to work exclusively with Perl scripts,
    files that end with `.pl`. We will be able to implement this easily within a condition
    by including the pattern as a match, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will talk in dept about regular expressions in a [Chapter 11](165453d1-d266-4144-882a-11ded6d1dd98.xhtml),
    *Regular Expressions*, but let's take a small glimpse now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the last example using a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As the single dot or period has a special meaning in regular expressions, we
    need to escape it with `\`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the regular expression matching working with
    a file called `my.pl` and another called `my.apl`. The match correctly shows for
    the file that ends in `.pl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84268ff7-79fb-4aa0-8205-1edb1d9f5a3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Regular expression script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another simple demonstration of conditional testing using regular expressions
    will be to expose the US and UK spelling of *color*, being *color* and *colour*
    respectively. We may prompt the user if they want a color or mono output for the
    script but at the same time cater for both spellings. The line that will do the
    work in the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The regular expression caters to both spellings of *color* by making the `u`
    optional: `u?`. Furthermore, we can disable case sensitivity allowing for *COLOR*
    and *color* by setting a shell option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This option can be disabled again at the end of the script with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When we use the variable parameters that we have named `$GREEN` and `$RESET`,
    we affect the color of the output. The color green will only be shown where we
    have sourced the color definition file. This is set when we choose the color display.
    Selecting mono will ensure that the variable parameters are null and have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete script is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75571831-e4dd-4318-bd61-47d8dd661620.png)'
  prefs: []
  type: TYPE_IMG
- en: Arithmetic operations using ((
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using bash and some other advanced shells, we can make use of the `(( ))`
    notation to simplify mathematical operations with scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Simple math
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The double parenthesis construct in bash allows for arithmetic expansion. Using
    this in the simplest format, we can easily carry out integer arithmetic. This
    becomes a replacement for the `let` built-in. The following examples show the
    use of the `let` command and the double parenthesis to achieve the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the `a` parameter is populated with the sum of `2 + 3`. If you
    want to write it on a shell script, you need to add a dollar sign before the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Parameter manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps a little more useful to us in scripting is the C-style parameter manipulation
    that we can include using the double parenthesis. We can often use this to increment
    a counter within a loop and also put a limit on the number of times the loop iterates.
    Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this example, we first set `COUNT` to `1` and then we increment it with
    the `++` operator. When it is echoed in the final line, the parameter will have
    a value of `2`. We can see the results in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cf03547-dc20-44b4-8601-79f0c49c00ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can achieve the same result in longhand by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This of course allows for any increment of the `COUNT` parameter and not just
    a single unit increase. Similarly, we can count down using the `--` operator,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We start using a value of `10`, reducing the value by `1` within the double
    parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we do not use the `$` to expand the parameters within the parentheses.
    They are used for parameter manipulation and, as such, we do not need to expand
    parameters explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Standard arithmetic tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another advantage that we can gain from these double parentheses is with the
    tests. Rather than having to use `-gt` for greater than, we can simply use `>`.
    We can demonstrate this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65fa7cb8-2ece-45dd-abaf-9d71392808d6.png)'
  prefs: []
  type: TYPE_IMG
- en: It is this standardization, both in the C-style manipulation and tests, that
    makes the double parenthesis so useful to us. This use extends to both the command
    line and scripts. We will use this feature extensively when we look at looping
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this chapter, I really hope that we have introduced many new and interesting
    choices to you. This was an area with a wide range where we began by recapping the
    use of `test` and discovered that the `[` is a command not a syntax construct.
    The main effect that it is a command is on white space and we looked at the need
    to quote variables.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we may commonly call variables variables, we have also seen that
    their correct name, especially in documentation, is parameters. Reading a variable
    is a parameter expansion. Understanding parameter expansion can help us understand
    the use of the keyword `[[`. The double square brackets are not commands and do
    not expand the parameters. This means that we do not need to quote variables even
    if they do contain white space. Moreover, we can use advanced tests with double
    square brackets, such as pattern matching or regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at arithmetic expansion and parameter manipulation using
    the double parenthesis notation. The biggest feature this delivers is the possibility
    to easily increment and decrement counters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move onto the looping constructs found in bash
    and make use of some of our new-found skills from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you subtract 8 from 25 using shell scripting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is wrong with the following code? And how can you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: What is the problem with the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/abs/html/arithexp.html](http://tldp.org/LDP/abs/html/arithexp.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://wiki.bash-hackers.org/commands/classictest](http://wiki.bash-hackers.org/commands/classictest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
