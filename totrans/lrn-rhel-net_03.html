<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Configuring Key Network Services"><div class="titlepage" id="aid-PNV62"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Configuring Key Network Services</h1></div></div></div><p>It must be said that having a network is great and most fulfilling; however, the reasons for using that network must be challenged and understood. No one has a network for the sake of having a network, so we must bring services to our network to give it a purpose, meaning, and reason to exist.</p><p>Of course, there are many and varied services that we can add, many of which are covered during the course of this book. To begin with, we will look at the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">DNS (the name resolution)</li><li class="listitem">DHCP (the IP address assignment)</li><li class="listitem">NTP / PTP (time services)</li><li class="listitem">SMTP (e-mail)</li></ul></div><div class="section" title="Domain Name System"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Domain Name System</h1></div></div></div><p>
<span class="strong"><strong>Domain Name System</strong></span> (<span class="strong"><strong>DNS</strong></span>) servers help us to resolve friendly computer names, such as <a class="ulink" href="http://www.packtpub.com">www.packtpub.com</a>, to a less <a id="id73" class="indexterm"/>human-friendly IP address, such as <code class="literal">83.166.169.231</code>. In this way, mere humans can access many computer systems by guessing the address or the DNS name. In the early days of UNIX computers, where access was limited to a few academic systems, hostnames were distributed by <span class="strong"><strong>Network Information Service</strong></span> (<span class="strong"><strong>NIS</strong></span>); a central computer maintained <a id="id74" class="indexterm"/>a single file that mapped hostnames to IP <a id="id75" class="indexterm"/>addresses. This file was then pushed out to client subscribers. Although this worked, it was clearly not scalable.</p><p>In 1988, the first release <a id="id76" class="indexterm"/>of the DNS server was developed by four graduates from UCB (the University of California, Berkeley). This software in now maintained by the <span class="strong"><strong>ISC</strong></span> (<span class="strong"><strong>Internet Systems Consortium</strong></span>). Even today, it's still known as <span class="strong"><strong>Berkeley Internet Name Domain</strong></span> (<span class="strong"><strong>BIND</strong></span>).</p><p>On Red Hat Enterprise <a id="id77" class="indexterm"/>Linux 7.1, the version of the DNS server or bind that is shipped is 9.9.4. Once installed, the version can be verified entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ named -V</strong></span>
</pre></div><p>The DNS server can be installed and run without changes to the configuration. In this mode, it will operate as a <span class="emphasis"><em>Local Caching Only</em></span> server. When operated in this manner, a server can resolve names on the Internet, but it does not host any of its own records. Additionally, in a setup without configuration changes, only localhost can query the server. In its simplest form, a caching-only server is still useful, but you will want to at least open the access control <a id="id78" class="indexterm"/>list to allow queries from your own network for it to be useful. In this way, computers on a local network can resolve names from a local server. Only the single server needs access to the Internet for name resolution, decreasing the Internet footprint of the organization.</p><div class="section" title="Installing and configuring a Caching Only DNS server"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Installing and configuring a Caching Only DNS server</h2></div></div></div><p>To begin <a id="id79" class="indexterm"/>with, we will install the <code class="literal">bind</code> package <a id="id80" class="indexterm"/>on our system and configure it to resolve names for hosts on the local network. There is little to do here other than a simple change to the configuration file, but it will get us started.</p><p>To install <code class="literal">bind</code> from console, enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo yum install bind</strong></span>
</pre></div><p>With the package installed, we will now need to edit the <code class="literal">/etc/named.conf</code> configuration file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo vi /etc/named.conf</strong></span>
</pre></div><p>We will edit three existing lines as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">listen-on port 53 { 127.0.0.1; };</code> changes to the following:<div class="informalexample"><pre class="programlisting">listen-on port 53 { any; };</pre></div></li><li class="listitem"><code class="literal">listen-on-v6 port 53 { ::1; };</code> changes to the following:<div class="informalexample"><pre class="programlisting">listen-on-v6 port 53 { none; };</pre></div></li><li class="listitem"><code class="literal">allow-query { localhost; };</code> changes to the following:<div class="informalexample"><pre class="programlisting">allow-query { localhost; 192.168.40.0/24; };</pre></div></li></ul></div><p>The changes that we have made are explained here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Allows the DNS server to listen on all IPv4 interfaces</li><li class="listitem">Disallow the DNS server to listen on IPv6, unless you need it to listen on IPv6</li><li class="listitem">Allows queries from my local network</li><li class="listitem">Adjusts the address range to match your network and the subnet mask</li></ul></div><p>With the changes in place, we will be able to save them. We can test the changes before we start the server. To do so, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo named-checkconf</strong></span>
</pre></div><p>The output should <a id="id81" class="indexterm"/>be silent. The only output will occur if <a id="id82" class="indexterm"/>there are errors in the configuration. If you prefer an output, then you can make use of the <code class="literal">-p</code> option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo named-checkconf -p</strong></span>
</pre></div><p>Using this option, we will be presented with configuration options as they are interpreted by the service. If there are errors, we will only see errors and not the configuration.</p><p>We can now start and enable the DNS service with the <code class="literal">systemctl</code> command; the order in which commands are executed is not important:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl start named</strong></span>
<span class="strong"><strong>$ sudo systemctl enable named</strong></span>
</pre></div><p>For the purpose of these labs, we will not run the firewall at present. You can check this on your system using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl status firewalld</strong></span>
</pre></div><p>If it's running, then either stop the firewall if it's not required or enable the DNS traffic on UDP and the TCP port <code class="literal">53</code> to pass into the system. To stop and disable the firewall, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl stop firewalld</strong></span>
<span class="strong"><strong>$ sudo systemctl disable firewalld</strong></span>
</pre></div><p>From the local system, we can test the name resolution using our DNS server; we will use the IP address of our server to prove that it's accessible from the network, rather than just from the localhost alias. You can use the same command and make sure that the <code class="literal">@address</code> at the end of the sequence points to the address of your server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ dig www.packtpub.com @192.168.40.3</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip08"/>Tip</h3><p>Here, use the IP address of your DNS server in place of the address we use.</p></div><p>You should now see the <span class="strong"><strong>ANSWER</strong></span> section in your output, detailing the address of the Packt server.</p><p>If you have another system on the same network, you can use the identical command to verify that it does indeed work for any host on your network.</p><p>At this stage, we <a id="id83" class="indexterm"/>will have a working DNS configured <a id="id84" class="indexterm"/>in the caching-only mode.</p></div><div class="section" title="Configuring clients to use this server"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Configuring clients to use this server</h2></div></div></div><p>When we <a id="id85" class="indexterm"/>were using the <code class="literal">dig</code> command before to test our DNS lookups, we had hardcoded the name server that we used, ignoring the client configuration. Traditionally, the client configuration file was <code class="literal">/etc/resolv.conf</code>. We can still use this, but more often in more modern Linux systems, this is overwritten by the NetworkManager service, which will read the name server from the interface configuration. In this way, we can use different DNS servers for different connection profiles. Of course, DNS will work with other operating systems as well, including your Microsoft Windows desktops and Apple iPhones. Very <a id="id86" class="indexterm"/>often, the DNS server list is handed out to the <span class="strong"><strong>DHCP</strong></span> service (<span class="strong"><strong>Dynamic Host Configuration Protocol</strong></span>), affecting the configuration across all DHCP clients. We will look at DHCP a little later in this chapter.</p><p>On RHEL 7.1, we can use the following command to display an active connection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nmcli con show active</strong></span>
</pre></div><p>My active connection shows <code class="literal">eno16777736</code>; this is the same system that we worked with in the <a class="link" title="Chapter 2. Configuring Network Settings" href="part0019.xhtml#aid-I3QM1">Chapter 2</a>, <span class="emphasis"><em>Configuring Network Settings</em></span>, where we looked at the consistent network device name that we find on modern Linux systems.</p><p>We can modify DNS servers for this configuration using the <code class="literal">nmcli</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nmcli con modify eno16777736 ipv4.dns "192.168.40.3"</strong></span>
</pre></div><p>If the connection that is being modified relates to a traditional <code class="literal">ifcfg-</code> script, the corresponding file is also edited with the previous <code class="literal">nmcli</code> command. This is the case with the connection that we have modified. We can view the changes by looking at the file that <code class="literal">nmcli</code> modified:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo cat /etc/sysconfig/network-scripts/ifcfg-eno16777736</strong></span>
</pre></div><p>To implement changes, we can restart the <code class="literal">NetworkManger</code> service as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl restart NetworkManager</strong></span>
</pre></div><p>We can now perform the DNS lookup with dig without the need to specify the address of our server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ dig www.packtpub.com</strong></span>
</pre></div><p>Here, we have been able to configure the local client to resolve hostnames from the locally configured <a id="id87" class="indexterm"/>DNS server.</p><div class="note" title="Note"><h3 class="title"><a id="tip09"/>Tip</h3><p>As a quick solution, editing the <code class="literal">/etc/resolv.conf</code> file will work, but it may be overwritten if the changes are not made with the NetworkManager service.</p></div></div><div class="section" title="Configuring the DNS zone"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Configuring the DNS zone</h2></div></div></div><p>One reason to <a id="id88" class="indexterm"/>configure a local DNS server is to provide a centralized configuration for name lookups for your local servers. We will now look at how to configure a DNS zone to provide a name resolution for local servers. We will configure a zone called <code class="literal">tup.local.</code>; using the local suffix will ensure that the zone is configured locally and only available to DNS servers we configure with this zone.</p><p>As a caching-only DNS server, we have not hosted DNS zones thus far. A DNS zone is simply a text file that houses hostnames to IP address mappings. We can see? which zones we host in the <code class="literal">/etc/named.conf</code> file. Zone files are stored in the <code class="literal">/var/named</code> directory.</p><div class="section" title="Referencing the zone from /etc/named.conf"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec01"/>Referencing the zone from /etc/named.conf</h3></div></div></div><p>Within the <a id="id89" class="indexterm"/>bind configuration file, we must point to the zone file. The following example illustrates how this can be achieved:</p><p>Open <code class="literal">named.conf</code> using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo vi /etc/named.conf</strong></span>
</pre></div><p>Add the following section at the end of the file:</p><div class="informalexample"><pre class="programlisting">zone "tup.local." IN {
  type master;
  file "named.tup";
};</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip10"/>Tip</h3><p>Do not forget the dot after the domain name: <code class="literal">tup.local</code>.</p></div><p>With the file configured and saved, we can check the configuration file as before:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo named-checkconf</strong></span>
</pre></div></div><div class="section" title="Creating the zone file"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec02"/>Creating the zone file</h3></div></div></div><p>We have configured the <a id="id90" class="indexterm"/>DNS server to point to the <code class="literal">named.tup</code> file. By default, this file needs to exist within the <code class="literal">/var/named/</code> directory on RHEL 7.1. This directory location is dictated by the directory directive in the main options of the <code class="literal">named.conf</code> file. This extract is taken from the <code class="literal">/etc/named.conf</code> file and shows the configuration of the directory root:</p><div class="informalexample"><pre class="programlisting">directory       "/var/named";</pre></div><p>First, create an empty zone file and set the permissions so that it can be read by the DNS server. The <code class="literal">touch</code> command will create an empty file. We set the permissions to be readable/writable by the user owner and only readable by the group owner. Finally, we set the permissions for the <a id="id91" class="indexterm"/>group owner of the file to named (the group used by the DNS server):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo touch /var/named/named.tup</strong></span>
<span class="strong"><strong>$ sudo chmod 640 /var/named/named.tup</strong></span>
<span class="strong"><strong>$ sudo chgrp named /var/named/named.tup</strong></span>
</pre></div><p>With the file and permissions in place, we can edit the file as root using <code class="literal">sudo</code>, so it reads similar to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00206.jpeg" alt="Creating the zone file"/></div><p style="clear:both; height: 1em;"> </p><p>We can interpret the preceding screenshot line by line as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">$ORIGIN tup.local.</code>: This sets the name of the DNS domain to be appended to all names not ending in a dot.</li><li class="listitem"><code class="literal">$TTL 1D</code>: This directive sets the default time that records may be retrieved from cache <span class="strong"><strong>TTL</strong></span> (<span class="strong"><strong>Time To Live</strong></span>). The value is normally in seconds, but we can use letters defining larger units, such as <code class="literal">H</code> for hours, <code class="literal">D</code> for days, or even <code class="literal">W</code> for weeks. It's <a id="id92" class="indexterm"/>possible to overwrite this default value within an individual DNS record. The larger the value assigned to TTL, the longer it will take to propagate changes on the Internet because records may still be served from cache for the TTL time period. The shorter the TTL is set, shorter the time to propagate changes, but more lookups will be performed on the server.</li><li class="listitem"><code class="literal">@ IN SOA ns1 root ( … )</code>: This sets the <span class="strong"><strong>Start Of Authority</strong></span> (<span class="strong"><strong>SOA</strong></span>) record for the <a id="id93" class="indexterm"/><code class="literal">tup.local.</code> DNS domain. The <code class="literal">@</code> symbol represents this domain and the SOA record is set to the <code class="literal">ns1.tup.local</code> computer<code class="literal">.</code> Remember<code class="literal">$ORIGIN</code> and the e-mail contact is <code class="literal">root@tup.local.</code>. The brackets contain the serial number and timeouts used in the domain. The expiry record is overwritten by the <code class="literal">$TTL</code> directive where it's used.</li><li class="listitem"><code class="literal">NS ns1</code>: This sets the name server record for the domain. If we have additional slave servers, we can add more NS records in the zone.</li><li class="listitem"><code class="literal">ns1 A 192.168.40.3</code>: This sets the IP address mapping for the <code class="literal">ns1.tup.local.</code> server to the IP address we have set on the system. A single <code class="literal">A</code> represents an IPv4 address mapping, while <code class="literal">AAAA</code> will represent on IPv6 mapping.</li></ul></div><p>When we complete the edit, we can check the zone syntax and integrity. In the command line, we enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo named-checkzone tup.local. /var/named/named.tup</strong></span>
</pre></div><p>The output should be similar <a id="id94" class="indexterm"/>to the following screenshot from the demonstration system:</p><div class="mediaobject"><img src="../Images/image00207.jpeg" alt="Creating the zone file"/></div><p style="clear:both; height: 1em;"> </p><p>Having edited the <code class="literal">/etc/named.conf</code> file and implemented the new zone <code class="literal">/var/named/named.tup</code> database file, we are now ready to restart the service. We have also checked <code class="literal">named.conf</code> with the <code class="literal">named-checkconf</code> command and the zone file with the <code class="literal">named-checkzone</code> command, so we can be reassured of the integrity of the changes we have made; with this in mind, we will restart the service with <code class="literal">systemctl</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl restart named</strong></span>
</pre></div><p>We can use <code class="literal">dig</code> or even just <code class="literal">ping</code> to check the operation of the zone now:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ping ns1.tup.local</strong></span>
<span class="strong"><strong>$ dig ns1.tup.local</strong></span>
</pre></div><p>Although we have only added a single record, there is nothing stopping us from adding more records as required. The serial number is normally incremented after zone changes, but it's used more to indicate when the changes have been made. Slave servers should synchronize these changes. If you have only the master server, there is no need to increment the serial <a id="id95" class="indexterm"/>number. Later in this chapter, we will add an <span class="strong"><strong>MX</strong></span> or <span class="strong"><strong>Mail Exchange</strong></span> record to support the use of e-mail delivery in the out domain.</p></div></div></div></div>
<div class="section" title="Configuring a DHCP server" id="aid-QMFO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Configuring a DHCP server</h1></div></div></div><p>The <span class="strong"><strong>DHCP</strong></span> (<span class="strong"><strong>Dynamic Host Configuration Protocol</strong></span>) server is used to assign IP addresses to <a id="id96" class="indexterm"/>network hosts, rather than having to statically assign records to each host. This is, of course, particularly useful where guest devices—such as mobile phones and tablets—connect to you network.</p><p>On Red Hat Enterprise Linux 7, a single DHCP server can supply IPv4 and IPv6 configurations. Each configuration has its own separate file: <code class="literal">/etc/dhcp/dhcpd.conf</code> for IPv4 configurations and <code class="literal">/etc/dhcpd/dhcpd6.conf</code> for IPv6 configurations. Additionally, if you are used to the previous editions of Red Hat, there is no longer any need to configure the interface in <code class="literal">/etc/sysconfig/dhcp</code>. RHEL 7 will automatically listen on all interfaces <a id="id97" class="indexterm"/>that match a subnet definition in the <code class="literal">dhcpd.conf</code> or <code class="literal">dhcpd6.conf</code> file. In other words, interfaces that the DHCP server will listen for DHCP requests will match those interfaces that have addresses within the defined DHCP subnet.</p><div class="note" title="Note"><h3 class="title"><a id="tip11"/>Tip</h3><p>If you have not configured the DNS server on the same system, you will need to create an empty lease file before the service will start, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo touch /var/lib/dhcpd/dhcpd.leases</strong></span>
</pre></div><p>You can install the DHCP Server using the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo yum install dhcp</strong></span>
</pre></div></div><p>In this example, we will configure the server to issue the IPv4 address configuration by editing the <code class="literal">/etc/dhcp/dhcpd.conf</code> file. The configuration file will be empty, except for a few comments. A simple configuration that is shown as follows, will match the configuration that we have been using on our demo system:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo vi /etc/dhcp/dhcpd.conf</strong></span>
</pre></div><p>The resulting file should be similar to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00208.jpeg" alt="Configuring a DHCP server"/></div><p style="clear:both; height: 1em;"> </p><p>Let's interpret the preceding screenshot line by line as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">option domain-name "tup.local";</code>: This configures the domain name to append to the client name.</li><li class="listitem"><code class="literal">option domain-name-servers 192.168.40.3;</code>: This sets the DNS server or servers. If more than one server is used, addresses are separated by spaces.</li><li class="listitem"><code class="literal">default-lease-time 86400;</code>: This is a value specified in seconds, where we set the DHCP lease time. The value of <code class="literal">86400</code> is one day. The maximum lease time is similar, but it's used only if a client requests a lease time.</li><li class="listitem"><code class="literal">ddns-update-style none;</code>: This disables the dynamic DNS, according to which the DHCP server will <a id="id98" class="indexterm"/>create DNS entries for clients that are issued with an IP address.</li><li class="listitem"><code class="literal">log-facility local7;</code>: This sets the syslog facility that is used by DHCP. Entries in log files will be shown as coming from the <code class="literal">local7</code> facility. DHCP does not have its own facility entry.</li><li class="listitem">Then follows subnet definitions, where we describe the network, subnet mask, address, and options that will be issued for the subnet.</li></ul></div><p>With this, we should now be familiar with the next step. Here, we start and enable the service using system:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl enable dhcpd</strong></span>
<span class="strong"><strong>$ sudo systemctl start dhcpd</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip13"/>Tip</h3><p>If you are running on a network where a DHCP server is already present, you will need to ensure that it's stopped before stating your own server. This includes the VMware Player and Virtual Box applications that can issue addresses on their private networks through their own DHCP service. Refer to your virtualization software for more help if required.</p></div><p>If you have additional RHEL 7 clients on a network, they can be forced to renew their DHCP leases with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo dhclient -r &lt;interface&gt;</strong></span>
</pre></div><p>Here is an example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo dhclient -r enp12s0</strong></span>
</pre></div><p>The preceding command will renew the DHCP lease on the Ethernet PCI card plugged in to the PCI bus address <code class="literal">12</code> and slot <code class="literal">0</code>. If a lease or leases have been issued by your server, you can check the leases file. This can be read as a standard user with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat /var/lib/dhcpd/dhcpd.leases</strong></span>
</pre></div><p>The following screenshot <a id="id99" class="indexterm"/>shows a lease from the demonstration RHEL 7.1 system and the lease for the host named <code class="literal">trusty</code>:</p><div class="mediaobject"><img src="../Images/image00209.jpeg" alt="Configuring a DHCP server"/></div><p style="clear:both; height: 1em;"> </p><p>With the DHCP server in place, we will move on to how to configure our basic networking services with a DNS and DHCP server. We will make this a little better by looking at time services.</p></div>
<div class="section" title="Configuring time services on RHEL 7"><div class="titlepage" id="aid-RL0A2"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Configuring time services on RHEL 7</h1></div></div></div><p>One of the essential <a id="id100" class="indexterm"/>services on your network is the supply of accurate time. This is required for authentication with Active Directory or other Kerberos-based mechanisms and to make timestamps useful in log files.</p><p>
<span class="strong"><strong>Network Time Protocol</strong></span> (<span class="strong"><strong>NTP</strong></span>) uses UDP and the traditional port <code class="literal">123</code>. This protocol dictates the number of <a id="id101" class="indexterm"/>seconds that have elapsed since midnight on January 1, 1900. NTP is 32 bit, which means that the maximum time <a id="id102" class="indexterm"/>will be reached in 2036; however, as only the difference in timestamps is used rather than the actual time, the date does not present an issue unlike UNIX time ending in 2038, which is a little more serious.</p><p>Once the time service is started and synchronized with another time source, the client time can be changed to match the server's time as long as the time is said to be sane. Insane time is said to be a server, offering a time with more than 1000 seconds offset to the client. Using this level of sanity, a client is prevented from synchronizing with a rogue time source.</p><p>It's also possible to deploy <span class="strong"><strong>Precision Time Protocol</strong></span> (<span class="strong"><strong>PTP</strong></span>). This works with a hardware or software support on your <span class="strong"><strong>Network Interface Card</strong></span> (<span class="strong"><strong>NIC</strong></span>). Firstly, we will look at common NTP implementations and then look at PTP.</p><p>The provision of NTP on RHEL 7 can be done via the <code class="literal">chronyd</code> or <code class="literal">ntpd</code> daemon itself. The <code class="literal">chronyd</code> daemon is enabled by default; however, this is really designed for desktops and machines that are often disconnected from networks. Synchronization of time with <code class="literal">chronyd</code> is much quicker than <code class="literal">ntpd</code> and is therefore suitable for machines that are booted frequently or often suspended. The <code class="literal">ntpd</code> daemon is still preferred for servers because it supports more authentication options and can broadcast time over the network.</p><p>To help maintain accurate time even when the time server may not be available, both <code class="literal">chronyd</code> and <code class="literal">ntpd</code> can implement a drift file. The drift file is maintained on the client and shows the offset in the frequency of the local hardware clock and the frequency of the remote time source.</p><p>NTP is based on a hierarchy of servers. Each server is assigned a stratum number. The possible start values range from 0 to 15. Stratum 16 indicates that time services are not available. A time server with a stratum value of 0 gets its time from a physical time source (such as a GPS clock or an atomic clock). A stratum 1 server retrieves its time from a stratum 0 server, and so on.</p><div class="section" title="Implementing chronyd"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Implementing chronyd</h2></div></div></div><p>As mentioned in the <a id="id103" class="indexterm"/>introduction of this section, <code class="literal">chronyd</code> is enabled by <a id="id104" class="indexterm"/>default on the RHEL 7.1 system we are using for this book. We can see the output of the status subcommand for this service with <code class="literal">systemctl</code> in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00210.jpeg" alt="Implementing chronyd"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see from the preceding output of <code class="literal">sudo systemctl status</code>, <code class="literal">chronyd</code> is described as an NTP client/server. This is similar to what we expect from the traditional <code class="literal">ntpd</code> daemon. If <code class="literal">chronyd</code> acts as a service as well, then we should listen on port <code class="literal">123</code>. We can use the <code class="literal">netstat</code> command to display this. If we use the command with root privileges, we also see that <a id="id105" class="indexterm"/>the service holding the port open is <code class="literal">chronyd</code>. The <code class="literal">-p</code> <a id="id106" class="indexterm"/>option displays this, but requires root privileges.</p><p>We run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo netstat -aunp | grep 123</strong></span>
</pre></div><p>The output is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00211.jpeg" alt="Implementing chronyd"/></div><p style="clear:both; height: 1em;"> </p><p>Going beyond what the output of <code class="literal">systemctl status</code> can display to use, we can see more detail on the synchronization status of <code class="literal">chronyd</code> using the <code class="literal">chronyc</code> command-line tool. Hopefully, you can see the pattern in the names now: <code class="literal">chronyd</code> for the service or daemon and <code class="literal">chronyc</code> for the command-line tool.</p><p>To show which server has been selected and the status of synchronization, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ chronyc tracking</strong></span>
</pre></div><p>The following screenshot <a id="id107" class="indexterm"/>shows the output of the <code class="literal">chronyc</code> command. If you look carefully at the output, you will see the command and then the output that follows the issuance of the same:</p><div class="mediaobject"><img src="../Images/image00212.jpeg" alt="Implementing chronyd"/></div><p style="clear:both; height: 1em;"> </p><p>
<code class="literal">Reference ID</code> shows the current server that we use to synchronize time with. <code class="literal">Frequency</code> shows as <code class="literal">ppm</code> (parts per million). This indicates the rate at which the system clock can become wrong if it was not synchronized. The value here of <code class="literal">0.8</code> means that after 1,000,000 seconds of not synchronizing, the clock will have an inaccuracy of <code class="literal">0.8</code> seconds; not at all bad. <code class="literal">Update Interval</code> shows how frequently we are currently synchronizing This expands to a much larger value than possible with <code class="literal">ntpd</code> being limited to 2 ^ 10 seconds (1024). This interval is quite permissible, given the accuracy of our clock.</p><p>With the following command, we <a id="id108" class="indexterm"/>can display all servers that we have configured to synchronize with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ chronyc sources</strong></span>
</pre></div><p>If we want an on screen display of the meaning of columns, we can use the <code class="literal">-v</code> option. The output is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00213.jpeg" alt="Implementing chronyd"/></div><p style="clear:both; height: 1em;"> </p><p>If we want to synchronize ourselves with one of our own local time servers, we can edit the <code class="literal">/etc/chrony.conf</code> configuration file. It will seem reasonable to allocate one server on your network as a time server and use this server as a time reference for the network. The single server then can <a id="id109" class="indexterm"/>synchronize with external time sources. This ensures accurate time to all servers on the network while maintaining a small Internet footprint, thus limiting servers that need to access the time servers on the Internet.</p><p>The <code class="literal">server</code> directive within the <a id="id110" class="indexterm"/>configuration file defines potential synchronization partners. To set a bias towards your local server, the <code class="literal">prefer</code> option can be used. The following screenshot shows my edited file, where I leave just one of the original entries and add my own local time source:</p><div class="mediaobject"><img src="../Images/image00214.jpeg" alt="Implementing chronyd"/></div><p style="clear:both; height: 1em;"> </p><p>For any changes to take effect, the <code class="literal">chronyd</code> service should be restarted:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl restart chronyd</strong></span>
</pre></div><p>The frequency of <a id="id111" class="indexterm"/>synchronization will start slowly and gradually rise to match the <a id="id112" class="indexterm"/>accuracy of the offset frequency. Checking the output of <code class="literal">chronyc</code> tracking soon after the restart will show a value of 64 seconds for <code class="literal">Update Frequency</code>; however, this will increase to a larger interval over time.</p></div><div class="section" title="Implementing ntpd"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Implementing ntpd</h2></div></div></div><p>If you want to revert to <a id="id113" class="indexterm"/>the traditional <code class="literal">ntpd</code> daemon for time services, you can install the <code class="literal">ntp</code> package. The main advantage of the traditional package is the option of broadcast <a id="id114" class="indexterm"/>and stronger <span class="strong"><strong>ACL</strong></span> (<span class="strong"><strong>Access Control List</strong></span>). To install the package, you can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo yum install ntp</strong></span>
</pre></div><p>The configuration file is located at <code class="literal">/etc/ntp.conf</code> and is not similar to the <code class="literal">chrony</code> file. When we edit <code class="literal">ntp.conf</code> in a similar way to <code class="literal">chrony.conf</code>, we will be able to configure a local server as before, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00215.jpeg" alt="Implementing ntpd"/></div><p style="clear:both; height: 1em;"> </p><p>The additional ACLs that we find here are defined using the <code class="literal">restrict</code> keyword. The local host address is not restricted at all, although everyone else is affected by the default restriction.</p><p>The default restriction is explained here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">nomodify</code>: This <a id="id115" class="indexterm"/>prevents any changes to the configuration via the NTP protocol.</li><li class="listitem"><code class="literal">notrap</code> : This prevents <code class="literal">ntpdc</code> control traps that are designed for use by the remote logging program.</li><li class="listitem"><code class="literal">nopeer</code> :This prevents <a id="id116" class="indexterm"/>peer associations from being created, where 50 percent adjustments are made by each peer.</li><li class="listitem"><code class="literal">noquery</code> :This prevents information on the status of the time server being accessed. Do not confuse this with preventing access to a time server. This option will still allow normal NTP time queries from clients. Should you want to restrict access to the time service, use <code class="literal">noserve</code>.</li></ul></div><p>When you are comfortable with the changes made to your <code class="literal">/etc/ntp.conf</code> file, we will need first to stop and disable the <code class="literal">chronyd</code> service and then enable and start the <code class="literal">ntpd</code> service:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl stop chronyd</strong></span>
<span class="strong"><strong>$ sudo systemctl disable chronyd</strong></span>
<span class="strong"><strong>$ sudo systemctl enable ntpd</strong></span>
<span class="strong"><strong>$ sudo systemctl start ntpd</strong></span>
</pre></div><p>To query the status of a service, we will use the <code class="literal">ntpq -p</code> command. The output is shown in the following screenshot, indicating on my system that the server being used to synchronize with is <code class="literal">192.168.0.3</code> (indicated by asterix):</p><div class="mediaobject"><img src="../Images/image00216.jpeg" alt="Implementing ntpd"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Implementing PTP on RHEL 7"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Implementing PTP on RHEL 7</h2></div></div></div><p>
<span class="strong"><strong>Precision Time Protocol</strong></span> (<span class="strong"><strong>PTP</strong></span>) like NTP is used to synchronize clocks on a network, but unlike NTP, if <a id="id117" class="indexterm"/>PTP is used with hardware support that can achieve sub-microsecond accuracy; support for PTP comes from your NIC in either software or hardware forms. The <code class="literal">linuxptp</code> package provides <code class="literal">ptp4l</code> and <code class="literal">phc2sys</code> programs (PTP for <a id="id118" class="indexterm"/>Linux and physical clock to system clock). However, <code class="literal">phc2sys</code> is only needed for hardware timestamping. Although implemented within NICs, many networking components (including switches) support PTP in software or hardware modes, thus enabling servers to synchronize time with their switch. The process is far more automated than traditional NTP and more accurate with each clock running the best master software that can select the best master to synchronize with. It's best suited to Enterprise networks because switches will often provide time to devices they serve.</p><p>Many NICs support software timestamping, but to query your own interface, use the following command, which will display the timestamping capabilities of your selected interface:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ethtool -T eno16777736</strong></span>
</pre></div><p>Adjust the preceding command to match the interface that you wish to interrogate. For the software support, we need to find the following lines in the output:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">SOF_TIMESTAMPING_SOFTWARE</code></li><li class="listitem"><code class="literal">SOF_TIMESTAMPING_TX_SOFTWARE</code></li><li class="listitem"><code class="literal">SOF_TIMESTAMPING_RX_SOFTWARE</code></li></ul></div><p>For the hardware support, we will need the following options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">SOF_TIMESTAMPING_RAW_HARDWARE</code></li><li class="listitem"><code class="literal">SOF_TIMESTAMPING_TX_HARDWARE</code></li><li class="listitem"><code class="literal">SOF_TIMESTAMPING_RX_HARDWARE</code></li></ul></div><p>The output from my system is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00217.jpeg" alt="Implementing PTP on RHEL 7"/></div><p style="clear:both; height: 1em;"> </p><p>To install <code class="literal">linuxptp</code> on the system, we can use the following command to install from standard Red Hat repositories:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo yum install linuxptp</strong></span>
</pre></div><p>The services can be run <a id="id119" class="indexterm"/>from the command line as a simple test. However, prior to this, we should stop NTP if it's running. This is shown in the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl disable ntpd</strong></span>
<span class="strong"><strong>$ sudo systemctl stop ntpd</strong></span>
</pre></div><p>To start a service from <a id="id120" class="indexterm"/>the command line rather than as a daemon, we can verify that it works using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo ptp4l -i eno16777736 -m -S</strong></span>
</pre></div><p>This starts the service using the interface we specify using the <code class="literal">-i</code> option, we ask output to go to the screen with the <code class="literal">-m</code> option and we set the software mode with the <code class="literal">-S</code> option.</p><p>The service will listen on UDP ports <code class="literal">319</code> and <code class="literal">320</code>. The output of the command is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00218.jpeg" alt="Implementing PTP on RHEL 7"/></div><p style="clear:both; height: 1em;"> </p><p>Once we are happy with our configuration, we can create the startup configuration file and adjust the <code class="literal">sysconfig</code> file. We will start with the <code class="literal">sysconfig</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo vi /etc/sysconfig/ptp4l</strong></span>
</pre></div><p>Remove the interface option at the end of the line. The file should read the same as the following screenshot:</p><div class="mediaobject"><img src="../Images/image00219.jpeg" alt="Implementing PTP on RHEL 7"/></div><p style="clear:both; height: 1em;"> </p><p>Next, we will rename the existing configuration and create a minimal configuration that supports the same options that we used from the command line as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo mv /etc/ptp4l.conf /etc/ptp4l.conf.orig</strong></span>
<span class="strong"><strong>$ sudo vi /etc/ptp4l.conf</strong></span>
</pre></div><p>The <code class="literal">ptp4l.conf</code> file <a id="id121" class="indexterm"/>should be similar to adjusting the interface in <a id="id122" class="indexterm"/>order to match the interface on your own system. The following screenshot shows the <code class="literal">ptp4l.conf</code> file on my system:</p><div class="mediaobject"><img src="../Images/image00220.jpeg" alt="Implementing PTP on RHEL 7"/></div><p style="clear:both; height: 1em;"> </p><p>We are now ready to implement <code class="literal">ptp4l</code> as a service. With the <code class="literal">systemctl</code> command, we will be able to enable and start the service, as shown in the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl enable ptp4l</strong></span>
<span class="strong"><strong>$ sudo systemctl start ptp4l</strong></span>
</pre></div><p>Using the <code class="literal">status</code> subcommand to <code class="literal">systemctl</code> as in the previous commands, we will see the output similar to the following, indicating that the service has started and looking for clock announcements:</p><div class="mediaobject"><img src="../Images/image00221.jpeg" alt="Implementing PTP on RHEL 7"/></div><p style="clear:both; height: 1em;"> </p><p>When the server is <a id="id123" class="indexterm"/>running, it may listen for other clock announcements and then negotiate as to which will be the grand master. In the following screenshot taken from the demonstration system, we can view the output of the <code class="literal">systemctl status</code> command. From the log extract, we can see the election of the new grand master:</p><div class="mediaobject"><img src="../Images/image00222.jpeg" alt="Implementing PTP on RHEL 7"/></div><p style="clear:both; height: 1em;"> </p><p>We have now seen how to <a id="id124" class="indexterm"/>implement time services on Linux using either NTP, Cronyd, or PTP. With accurate time, we can now move forward to e-mail <a id="id125" class="indexterm"/>and <span class="strong"><strong>SMTP</strong></span> (<span class="strong"><strong>Simple Mail Transfer Protocol</strong></span>).</p></div></div>
<div class="section" title="Implementing e-mail delivery on RHEL 7" id="aid-SJGS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Implementing e-mail delivery on RHEL 7</h1></div></div></div><p>The default SMTP <a id="id126" class="indexterm"/>server used in the current release of <a id="id127" class="indexterm"/>RHEL is Postfix; the original Sendmail package is still available, but is no longer the default.</p><p>It's normal for the e-mail server to listen on the localhost or loopback address only when using default settings. In this way, local e-mail delivery is possible out of the box. This is used by many services, including the <code class="literal">crond</code> job schedule manager. If we wanted to enable Postfix to listen on all interfaces and receive messages from remote systems, there is a little configuration required.</p><p>Firstly, we will back up and tidy the main configuration file. There is a tendency for many software packages to over comment their configurations. This can cause issues where you think that you have implemented a change; however, it was also set later on and you may not have noticed it. There are 679 lines in the default configuration file: <code class="literal">/etc/postfix/main.cf</code>. We will back up the file so that we do not lose comments and documentations, but we will also have a new working file with less than 10 percent of the number of lines. The following command shows how this is done:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo sed -i.bak '/^#/d;/^$/d' /etc/postfix/main.cf</strong></span>
</pre></div><p>This reduces the file from 679 lines to 25 lines and is far easier to work with. We can now edit this file without any distractions. We will add two new lines and edit two existing lines to the <code class="literal">/etc/postfix/main.cf</code> file. This will need to be edited as root.</p><p>We will edit the <code class="literal">inet_interfaces = localhost</code> line so that it reads as follows:</p><div class="informalexample"><pre class="programlisting">inet_interfaces = all</pre></div><p>This will enable the SMTP service to listen on all interfaces, rather than just the loopback addresses.</p><p>We also need to make sure that we receive e-mails for the correct host and domain. This is controlled through the <a id="id128" class="indexterm"/>
<code class="literal">mydestination</code> <a id="id129" class="indexterm"/>directive; however, we have to add the <code class="literal">myhostname</code> and <code class="literal">mydomain</code> directives before the <code class="literal">mydestination</code> line. These are the two lines that we add. We also need to add <code class="literal">$mydomain</code> to the existing <code class="literal">mydestination</code> line. On my system, these lines are set as follows:</p><div class="informalexample"><pre class="programlisting">myhostname = ns1.tup.local
mydomain = tup.local
mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain</pre></div><p>The following screenshot shows the top few lines of the file where these changes have been implemented:</p><div class="mediaobject"><img src="../Images/image00223.jpeg" alt="Implementing e-mail delivery on RHEL 7"/></div><p style="clear:both; height: 1em;"> </p><p>With these edits is place, we can save the file and restart the SMTP service. The following command <a id="id130" class="indexterm"/>shows how to restart the Postfix <a id="id131" class="indexterm"/>SMTP service:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo systemctl restart postfix</strong></span>
</pre></div><div class="section" title="Adding an MX record to the DNS server"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Adding an MX record to the DNS server</h2></div></div></div><p>If we are to <a id="id132" class="indexterm"/>receive an e-mail for the domain, we will need an MX <a id="id133" class="indexterm"/>record (e-mail exchange) to the DNS database that we created earlier in this section. The file that was used earlier for the <code class="literal">tup.local.</code> DNS domain was /<code class="literal">var/named/named.tup</code>. The record that we add for the MX or Mail Exchange record should be similar to the following line:</p><div class="informalexample"><pre class="programlisting">tup.local.  MX  10  ns1</pre></div><p>With this setting, we configure the MX or Mail Exchange priority to 10. The lowest priority MX Record is the e-mail server that is used first if more than one e-mail server record exists.</p><p>The updated zone file is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00224.jpeg" alt="Adding an MX record to the DNS server"/></div><p style="clear:both; height: 1em;"> </p><p>With these updates in place, we can check the zone and restart the server. For convenience, the commands are listed here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo named-checkzone tup.local /var/named/named.tup</strong></span>
<span class="strong"><strong>$ sudo systemctl restart named</strong></span>
</pre></div><p>We can verify that DNS is working with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ dig -t MX tup.local</strong></span>
</pre></div><p>To test the e-mail delivery, we should be able to send e-mails to the domain:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mail root@tup.local</strong></span>
</pre></div><p>We will be prompted for the <code class="literal">Subject</code> message and then we can enter the e-mail we wish. To end an e-mail, we will include a line with just the period or a dot character and nothing else. This should be delivered to the root on your system being recognized as the e-mail server for the domain.</p><p>To view the message system working in more detail, we can take a look at the log files. To see the recent activity, we <a id="id134" class="indexterm"/>can use the tail command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo tail /var/log/maillog</strong></span>
</pre></div><p>We now have a simple <a id="id135" class="indexterm"/>e-mail server to go with time, DNS, and DHCP services.</p></div></div>
<div class="section" title="Summary" id="aid-TI1E1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, you learned how to configure some of the fundamental network services often associated with Linux. We started off with how to set up the name resolution using DNS and ended up finishing on the same topic as we added e-mail server records to DNS. Having looked at DNS, we stayed alliteratively with D and studied DHCP, thus allowing a supply of IP configuration to the network. This took us to the complexities of the different time services that are on offer with <code class="literal">chronyd</code>, <code class="literal">ntpd</code>, and <code class="literal">ptp4l</code>. At the end of the chapter, we looked at a simple configuration of the Postfix SMTP server on RHEL 7. This should give you a simple overview of services that you can expect to work with on a day-to-day basis with Enterprise Linux.</p><p>In the next chapter, we will see what is new on RHEL 7 and 7.1 and how to set up iSCSI storage services. You will find that the ISCSI target is now kernel-based and works very differently to the previous iSCSI target service on RHEL 6.</p></div></body></html>