<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Troubleshooting Active Processes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Troubleshooting Active Processes</h1></div></div></div><p>A deeper understanding of the underlying active processes in CentOS 7 is an essential skill for any troubleshooter. From <a id="id60" class="indexterm"/>high load averages to slow response times, system overloads to dead and dying processes, there comes a time when every server may start to feel sluggish, act impoverished, or fail to respond, and as a consequence, it will require your immediate attention.</p><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn about memory management, swap, swappiness, and thrashing</li><li class="listitem" style="list-style-type: disc">Learn how to analyze active processes using the <code class="literal">vmstat</code>, <code class="literal">top</code>, and <code class="literal">ps</code> commands</li><li class="listitem" style="list-style-type: disc">Learn how to monitor the server with <code class="literal">iotop</code>, <code class="literal">iostat</code>, and <code class="literal">lsof</code></li><li class="listitem" style="list-style-type: disc">Learn about system load and <code class="literal">systemd</code></li><li class="listitem" style="list-style-type: disc">Learn how to find process IDs, identify parent process IDs and orphaned processes, and initiate the various forms of the <code class="literal">kill</code> signal</li></ul></div><div class="section" title="Tuning server performance with memory management and swap"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Tuning server performance with memory management and swap</h1></div></div></div><p>Regardless<a id="id61" class="indexterm"/> of how you look at it, the question of memory usage remains critical to the life cycle of a <a id="id62" class="indexterm"/>system, and whether you are maintaining system health or troubleshooting a particular service or application, you will always need to remember that the use of memory is a critical resource to your system. For this reason, we will begin by calling the <code class="literal">free</code> command in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># free -m</strong></span>
</pre></div><p>The main elements of the preceding command will look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>         Total    used    free    shared    buffers    cached</strong></span>
<span class="strong"><strong>Mem:      1837     274    1563         8          0       108</strong></span>
<span class="strong"><strong>-/+ buffers/cache: 164    1673</strong></span>
<span class="strong"><strong>Swap:     2063       0    2063</strong></span>
</pre></div><p>In the example <a id="id63" class="indexterm"/>shown, I have used the <code class="literal">-m</code> option to ensure that the output is formatted in megabytes. This makes it easier to read, but for the sake of troubleshooting, rather than trying to understand every numeric value shown, let's reduce the scope of the original output to highlight the relevant area of concern:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>-/+ buffers/cache: 164    1673</strong></span>
</pre></div><p>The importance <a id="id64" class="indexterm"/>of this line is based on the fact that it accounts for the associated buffers and caches to illustrate what memory is currently being used and what is held in reserve. Where the first value indicates how much memory is being used, the second value tells us how much memory is available to our applications. In the example shown, this instance translates into 164 MB of used memory and 1673 MB of available memory.</p><p>Bearing this in mind, let me draw your attention to the final line in order that we can examine the importance of swap:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Swap:     2063       0    2063</strong></span>
</pre></div><p>Swapping typically occurs when memory usage is impacting performance. As we can see from the preceding example, the first value tells us that there is a total amount of system swap set at 2063 MB, with the second value indicating how much swap is being used (0 MB), while the third value shows the amount of swap that is still available to the system as a whole (2063 MB). So yes, based on the example data shown here, we can conclude that this is a healthy system, and no swap is being used, but while we are here, let's use this time to discover more about the swap space on your system.</p><p>To begin, we will revisit the contents of the <code class="literal">proc</code> directory and reveal the total and used swap size by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /proc/swaps</strong></span>
</pre></div><p>Assuming that you understand the output shown, you should then investigate the level of swappiness used by your system with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /proc/sys/vm/swappiness</strong></span>
</pre></div><p>Having done this, you will now see a numeric value between the ranges of 0-100. The numeric value is a percentage and it implies that, if your system has a value of 30, for example, it will begin to use swap memory at 70 percent occupation of RAM.</p><p>The default for all Linux systems is usually set with a notional value between 30 to 60, but you can use either of the following commands to temporarily change and modify the swappiness of your system.</p><p>This can be <a id="id65" class="indexterm"/>achieved by replacing the value of <code class="literal">X</code> with a numeric value from 1-100 by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># echo X &gt; /proc/sys/vm/swappiness</strong></span>
</pre></div><p>Or more specifically, this can also be achieved with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sysctl -w vm.swappiness=X</strong></span>
</pre></div><p>If you change <a id="id66" class="indexterm"/>your mind at any point, then you have two options in order to ensure that no permanent changes have been made. You can either repeat one of the preceding two commands and return the original values, or issue a full system reboot.</p><p>On the other hand, if you want to make the change persist, then you should edit the <code class="literal">/etc/sysctl.conf</code> file and add your swappiness preferences in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>vm.swappiness=X</strong></span>
</pre></div><p>When complete, simply save and close the file to ensure that the changes take effect.</p><p>The level of swappiness controls the tendency of the kernel to move a process out of the physical RAM on to a swap disk. This is memory management at work, but it is important to realize that swapping will not occur immediately, as the level of swappiness is actually expressed as a percentage value. For this reason, the process of swapping should be viewed more as a measurement of preference when using the cache, and as every administrator will know, there is an option for you to clear the swap by using the commands <code class="literal">swapoff -a</code> and <code class="literal">swapon -a</code> to achieve the desired result.</p><p>The golden rule is to realize that a system displaying a level of swappiness close to the maximum value (100) will prefer to begin swapping inactive pages. This is because a value of 100 is a representative of 0 percent occupation of RAM. By comparison, the closer your system is to the lowest value (0), the less likely swapping is to occur as 0 is representative of 100 percent occupation of RAM.</p><p>Generally speaking, we would all probably agree that systems with a very large pool of RAM would not benefit from aggressive swapping. However, and just to confuse things further, let's look at it in a different way. We all know that a desktop computer will benefit from a low swappiness value, but in certain situations, you may also find that a system with a large pool of RAM (running batch jobs) may also benefit from a moderate to aggressive swap in a fashion similar to a system that attempts to do a lot but only uses small amounts of RAM. So, in reality, there are no hard and fast rules; the use of swap should be based on the needs of the system in question rather than looking for a single solution that can be applied across the board.</p><p>Taking this further, special <a id="id67" class="indexterm"/>care and consideration should be taken while making changes to the swapping values as RAM that is not used by an application is used as disk cache. In <a id="id68" class="indexterm"/>this situation, by decreasing swappiness, you are actually increasing the chance of that application not being swapped-out, and you are thereby decreasing the overall size of the disk cache. This can make disk access slower. However, if you do increase the preference to swap, then because hard disks are slower than memory modules, it can lead to a slower response time across the overall system. Swapping can be confusing, but by knowing this, we can also appreciate the hidden irony of swappiness. As Newton's third law of motion states, <span class="emphasis"><em>for every action, there is an equal and opposite reaction</em></span>, and finding the optimum swappiness value may require some additional experimentation.</p></div></div>
<div class="section" title="Managing memory with vmstat"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Managing memory with vmstat</h1></div></div></div><p>A different<a id="id69" class="indexterm"/> aspect of <a id="id70" class="indexterm"/>memory management can be achieved by using the <code class="literal">vmstat</code> command. Considered to be<a id="id71" class="indexterm"/> a summary reporting feature associated with memory, processes, and paging, <code class="literal">vmstat</code> can be seen in action by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vmstat -a</strong></span>
</pre></div><p>Having used the <code class="literal">-a</code> option to call on all active and inactive memory, the most endearing columns shown under vmstat's output are best described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">si</code>: This column shows the value swapped in from disk</li><li class="listitem" style="list-style-type: disc"><code class="literal">so</code>: This column shows the value swapped out to disk</li><li class="listitem" style="list-style-type: disc"><code class="literal">bi</code>: This column shows the value sent to block devices</li><li class="listitem" style="list-style-type: disc"><code class="literal">bo</code>: This column shows the value received from block devices</li><li class="listitem" style="list-style-type: disc"><code class="literal">us</code>: This column shows the user time</li><li class="listitem" style="list-style-type: disc"><code class="literal">sy</code>: This column shows the system time</li><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: This column shows the idle time</li></ul></div><p>The display does look quite confusing to begin with, but for our purposes, we want to concentrate on the following columns contained under the swap column:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>free           si   so</strong></span>
<span class="strong"><strong>1645452          0    0</strong></span>
</pre></div><p>Where<a id="id72" class="indexterm"/> <code class="literal">free</code> shows the current allocation of free memory, <code class="literal">si</code> shows page-ins while <code class="literal">so</code> provides page-outs. Sadly, viewing<a id="id73" class="indexterm"/> it by this method alone can be seen to be a<a id="id74" class="indexterm"/> little too restrictive for our needs, and so the most effective way to look at this is by managing the output with a delay option being added to the original command like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vmstat X N</strong></span>
</pre></div><p>Here, <code class="literal">X</code> is a numeric time value expressed in seconds and <code class="literal">N</code> indicates the number of times we would like to call <code class="literal">vmstat</code> itself; a working demonstration of this code format would be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vmstat 3 5</strong></span>
</pre></div><p>In this example, I have added the values <code class="literal">3</code> and <code class="literal">5</code>, in which the first number indicates a delay in seconds followed by the second number calling the number of results. In this instance, <code class="literal">vmstat 3 5</code> will run <code class="literal">vmstat</code> with a <code class="literal">3</code>-second delay, and it will show a total of <code class="literal">5</code> updates like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>free        si    so</strong></span>
<span class="strong"><strong>1645452       0     0</strong></span>
<span class="strong"><strong>1645452       0     0</strong></span>
<span class="strong"><strong>1645452       0     0</strong></span>
<span class="strong"><strong>1645452       0     0</strong></span>
<span class="strong"><strong>1645452       0     0</strong></span>
</pre></div><p>Alternatively, you can keep <code class="literal">vmstat</code> running at intervals of <code class="literal">N</code> number of seconds by reducing the complexity of the command format to:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vmstat N</strong></span>
</pre></div><p>So, by running <code class="literal">vmstat 10</code>, <code class="literal">vmstat</code> will continue to refresh its report of all activity every <code class="literal">10</code> seconds. However, for more details regarding the time of occurrence, you can use the <code class="literal">-t</code> option like this in order to call a similar report with a timestamp:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vmstat -t X N</strong></span>
</pre></div><p>Finally, as the default <code class="literal">vmstat</code> command will make a report in kilobytes, to avoid confusion it is often better to ask <code class="literal">vmstat</code> to display a report using megabytes with the following expression:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vmstat -S M X N</strong></span>
</pre></div><p>Page-ins (<code class="literal">si</code>) are generally expected when you have started an application and the information is "paged-in". However, occasional or intermittent page outs (<code class="literal">so</code>) also happen, and this is particularly so during periods when the kernel is freeing up memory. Occurrence of regular page <a id="id75" class="indexterm"/>outs (<code class="literal">so</code>), or the growth of regular page outs is not wanted. Eventually, should the regularity of these events increase exponentially, then the event will adopt a behavior that is generally referred to as thrashing.</p><p>Thrashing is <a id="id76" class="indexterm"/>an event that happens when a system is seen to be spending more time managing paging than providing applications or services. It is not necessarily a dire event in itself, but it does indicate that the<a id="id77" class="indexterm"/> troubleshooter should re-evaluate the value of particular operations and consider trying to spread them out over different periods of the working day. You can always buy more RAM for your system and this may assist you in the short term, but this will not narrow down the cause, nor will it stop the event from repeating. So, in order to make our lives a little easier, the next step is to use the <code class="literal">top</code> command.</p></div>
<div class="section" title="Checking the system load with the top command"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Checking the system load with the top command</h1></div></div></div><p>The top command can be called at any time by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># top</strong></span>
</pre></div><p>The <code class="literal">top</code> command<a id="id78" class="indexterm"/> is the standard <a id="id79" class="indexterm"/>command for checking system load (RAM/MEM and CPU). It contains a lot of information related to tasks associated with the kernel; the display is updated in real-time and the highest load factors are expressed as a percentage of CPU or MEM. However, it is important to realize that <code class="literal">top</code> may take these values above the expected percentile range. This is because all individual cores are expressed as a percentage and multiple instances of these cores are totaled. For example, a dual core system may have the first core at 70 percent and the second core at 60 percent, and in this instance, <code class="literal">top</code> may show a combined result of 130 percent, but you will not know the individual values.</p><p>You can use the <span class="emphasis"><em>M</em></span> key to sort <code class="literal">top</code> by memory, but as you will see, rather than simply showing the amount of free memory (as seen with the <code class="literal">free</code> command), <code class="literal">top</code> will provide the swap details you may need in order to make a judgment call against certain operations and tasks. Moreover, you can also extend the functionality of <code class="literal">top</code> by customizing the output to show a particular user like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># top -u &lt;username&gt;</strong></span>
</pre></div><p>As you will notice, <code class="literal">top</code> will automatically refresh; therefore, try to observe it for a few minutes before making any decisions. To assist in this process, you can request that <code class="literal">top</code> exits after <code class="literal">10</code> cycles like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># top -n 10</strong></span>
</pre></div><p>When <a id="id80" class="indexterm"/>using <code class="literal">top</code>, you should always be aware that certain processes are spawned. Known as <code class="literal">child-processes</code> they <a id="id81" class="indexterm"/>will have a tendency to be displayed individually (<code class="literal">httpd</code> and <code class="literal">php-fpm</code> are good examples of this), and you can expect that it is these services that will be consuming the most amount of memory.</p><p>Having said<a id="id82" class="indexterm"/> that, even though a series of child-processes can be seen using a significant amount of RAM, you should avoid the habit of adding the <code class="literal">%MEM</code> column together as these processes often use shared memory. So, in many respects, you should be aware that the values shown can be misleading, and for this reason, the results provided by <code class="literal">top</code> should not form the only body of evidence you will want to review before making a final decision.</p><p>You can learn more about the top command by reviewing the manual like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ man top</strong></span>
</pre></div></div>
<div class="section" title="Monitoring disk I/O with iotop"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Monitoring disk I/O with iotop</h1></div></div></div><p>Every<a id="id83" class="indexterm"/> administrator<a id="id84" class="indexterm"/> knows that a system can begin to slow down as a result of heavy disk I/O activities. However, in the role of a troubleshooter you <a id="id85" class="indexterm"/>will probably want to know which processes or (in the case of multi-user systems) which users are the culprits that and it is for this reason, you will want to turn to <code class="literal">iotop</code>—a tool that shows a list of the most I/O intensive processes in real time in a top-like interface.</p><p>To begin with, you will need to install <code class="literal">iotop</code> by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install iotop</strong></span>
</pre></div><p>The download is only small, and to start a discovery session, simply use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># iotop</strong></span>
</pre></div><p>Running <code class="literal">iotop</code> without any arguments will result in a list of all existing processes regardless of their disk I/O activities, so if you want <code class="literal">iotop</code> to only report on processes that are committed to disk I/O activity, you should use the following instead:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># iotop –o</strong></span>
</pre></div><p>The output is verbose as it works in a way similar to the <code class="literal">top</code> command, so familiarity should make you <a id="id86" class="indexterm"/>feel at home. However, unlike <code class="literal">top</code>, <code class="literal">iotop</code> displays a list of all processes and threads and a<a id="id87" class="indexterm"/> measurement of disk activity (total disk read and actual disk read) in order so that you can quickly identify what is impacting any <a id="id88" class="indexterm"/>current I/O activity across the server.</p><p>You can learn more about <code class="literal">iotop</code> by reviewing the manual like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ man iotop</strong></span>
</pre></div></div>
<div class="section" title="Checking processes with the ps command"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Checking processes with the ps command</h1></div></div></div><p>For <a id="id89" class="indexterm"/>most <a id="id90" class="indexterm"/>troubleshooters who want a more complete picture of the <a id="id91" class="indexterm"/>processes running on their system, we can employ the <code class="literal">ps</code> command in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps aux | less</strong></span>
</pre></div><p>Alternatively, the information can be displayed in a user-friendly, tree-view mode like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps axjf | less</strong></span>
</pre></div><p>If you prefer a little less detail, try:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps auxf | less</strong></span>
</pre></div><p>Of course, there are always a lot more options that we can use with <code class="literal">ps</code>. For example, the command can be piped and applied with <code class="literal">grep</code> or <code class="literal">tail</code>, and you can use explicit statements such as <code class="literal">ps -e</code> (to show every process on the system). Alternatively, you can target a specific process by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps aux | grep &lt;process_name&gt;</strong></span>
</pre></div><p>Moreover, you can even extend its usage to show every process (except those running as root) with the following variation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps -U root -u root -N</strong></span>
</pre></div><p>For a specific user, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps -u &lt;username&gt; u</strong></span>
</pre></div><p>Finally, you can then obtain additional security information and output the results to a text file in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps axZ &gt; /path/to/filename.txt</strong></span>
</pre></div><p>Based on this, I think <a id="id92" class="indexterm"/>you would agree in saying that <code class="literal">ps</code> is not only useful but also its flexibility and <a id="id93" class="indexterm"/>customization <a id="id94" class="indexterm"/>do make it an important tool in the troubleshooter's kitbag. The <code class="literal">ps</code> command can be used to display a snapshot of the current processes on the system, but for the purpose of this chapter, our interest lies in the fact that the <code class="literal">ps</code> command will also provide us with the relevant process ID. Otherwise referred to in its simpler form as the <code class="literal">PID</code>, this essential piece of information will be revisited in just a few moments after we digress a little, to learn a little more about system load.</p></div>
<div class="section" title="Checking performance with iostat and lsof"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Checking performance with iostat and lsof</h1></div></div></div><p>Having<a id="id95" class="indexterm"/> already discovered how <code class="literal">vmstat</code> can be used to provide statistics related to memory <a id="id96" class="indexterm"/>management, when troubleshooting performance-related issues an overburdened CPU is yet another area of concern. For this purpose, we can use the<a id="id97" class="indexterm"/> <code class="literal">iostat</code> command like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># iostat</strong></span>
</pre></div><p>However, to display a more interactive CPU utilization report, you can use the <code class="literal">–c</code> option (and provide a numeric value measured in seconds, such as 5 seconds) like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># iostat –c 5</strong></span>
</pre></div><p>Most of the columns should be self-explanatory, but if the system is getting busy, you will see an increase in <code class="literal">%iowait</code>, which is used to report on an increase in waiting time for any I/O requests to be completed. Based on this, if the server is transferring or copying a large amount of files, you may also notice additional time being spent at the system level as files will be moved in and out of relevant disk partitions. A feature that is particularly useful when attempting to monitor storage devices in your search for possible bottlenecks is using <code class="literal">iostat</code> with a numeric value as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># iostat 5</strong></span>
</pre></div><p>As you can see, to check on the read/write operations we have simply added a polling option to <code class="literal">iostat</code>. Of course, you <a id="id98" class="indexterm"/>can combine this knowledge with the insights gained from running either <code class="literal">vmstat –d</code> or <code class="literal">vmstat –p &lt;partition_name&gt;</code>, but this command can also be improved with a timestamp by using the <code class="literal">–t</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># iostat –t 5</strong></span>
</pre></div><p>You should be<a id="id99" class="indexterm"/> aware that <code class="literal">iostat</code> reports run continuously until the process is cancelled. However, from these observations, it should now make your use of <code class="literal">top</code> and all the other commands much more satisfying. The technique of using the following command is particularly welcomed <a id="id100" class="indexterm"/>by the fact that you can review a list of <a id="id101" class="indexterm"/>open files with the <code class="literal">lsof</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># lsof | less</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>When using <code class="literal">lsof</code>, it is important to note that the first column will show you which command is using the file in question, the process ID (<code class="literal">PID</code>) of that command, the user, and the name of the file that is open.</p></div></div><p>So, with that in mind, and realizing how every command discussed in this chapter is connected, let's return to the important subject of system load.</p></div>
<div class="section" title="Calculating the system load"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Calculating the system load</h1></div></div></div><p>The <a id="id102" class="indexterm"/>system load<a id="id103" class="indexterm"/> is a measure of the amount of processing a computer <a id="id104" class="indexterm"/>system is currently performing. It is not the perfect way to measure computer performance, but it does provide the troubleshooter with the additional evidence they need to fix a system.</p><p>The expression most commonly associated with calculating load is:</p><p><span class="emphasis"><em>Actual Load = Total Load (uptime) / Number of CPUs</em></span></p><p>As you probably know the number of CPUs, you can calculate the uptime by reviewing the results of the <code class="literal">top</code> command or by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># uptime</strong></span>
</pre></div><p>The output of the preceding command may look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>09:59:41 up  2:36,  1 user,  load average: 0.01, 0.02, 0.05</strong></span>
</pre></div><p>The server load <a id="id105" class="indexterm"/>is expressed as a value based on 1 minute, 5 minute, and 15 minute read times. So, by looking at the final three values in the preceding output, we can see that, for this system, the average load was <code class="literal">0.01</code> (at 1 minute), <code class="literal">0.02</code> (at 5 minutes), and <code class="literal">0.05</code> (at 15 minutes).</p><p>At this current time, the example system shows no sign of fatigue, but as the cause of high-load can vary, this is not to say that the current state of this machine will not alter during the course of a working day. High-load can be the result of database connectivity, disk input and output, poor coding, visitor frequencies for websites, power-hungry applications or e-commerce sites, scripted attacks, spam, batch jobs, and much more. Should you encounter this situation, simply run the <code class="literal">top</code> command and begin troubleshooting your system in the usual way. In most cases, a short-term solution can be found (especially if your website is receiving a lot of visitors during peak intervals), but only a long-term plan will stop this from happening again.</p><p>When troubleshooting<a id="id106" class="indexterm"/> load, it is important to know that, when load increases, processors are queued, and if there are multiple processors, the load is evenly distributed across the server's cores to balance the work. The ideal load for a server is generally agreed to be set at a value of 1. This does not mean you should hit the panic button as soon as this value is reached or exceeded, but if you do begin to see double-digit responses for some period of time, then yes, expect that a sluggish server (load value &gt; 1) may now begin to crack under the weight of its workload (load value &gt; 10).</p><p>So with this in mind, let's return to the subject of process IDs.</p></div>
<div class="section" title="Discovering process IDs with pgrep and systemctl"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Discovering process IDs with pgrep and systemctl</h1></div></div></div><p>Rather<a id="id107" class="indexterm"/> than using <code class="literal">ps</code>, another way of discovering a specific process ID is to use the <code class="literal">pgrep</code> command like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># pgrep &lt;servicename&gt;</strong></span>
</pre></div><p>In most<a id="id108" class="indexterm"/> cases, the use of this command will <a id="id109" class="indexterm"/>reveal the process ID or <code class="literal">PID</code>. However, by using this approach, it is also possible that the output will provide more than one value. So remember, if an application (such as <code class="literal">httpd</code> or <code class="literal">ssh</code>) provides one or more process IDs, you can safely assume that the lowest number (which represents the first <code class="literal">PID</code> generated by the system) is the most important. This value is known as the <code class="literal">PPID</code> or parent process ID.</p><p>On the other <a id="id110" class="indexterm"/>hand, a <a id="id111" class="indexterm"/>more succinct method could be based on taking advantage of <code class="literal">systemd</code> by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl status &lt;service_name&gt;.service</strong></span>
</pre></div><p>The output of the preceding command will look similar to the following sample, and as we can see, the main <code class="literal">PID</code> for Apache is <code class="literal">2413</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>httpd.service - The Apache HTTP Server</strong></span>
<span class="strong"><strong>   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled)</strong></span>
<span class="strong"><strong>   Active: active (running) since Sun 2014-12-14 01:26:37 GMT; 2min 56s ago</strong></span>
<span class="strong"><strong> Main PID: 2413 (httpd)</strong></span>
<span class="strong"><strong>   Status: "Total requests: 0; Current requests/sec: 0; Current traffic:   0 B/sec"</strong></span>
<span class="strong"><strong>   CGroup: /system.slice/httpd.service</strong></span>
<span class="strong"><strong>           ├─2413 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>           ├─2414 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>           ├─2415 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>           ├─2416 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>           ├─2417 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>           └─2418 /usr/sbin/httpd -DFOREGROUND</strong></span>
</pre></div><p>Linux is all about <a id="id112" class="indexterm"/>options, and yes, there are many more ways to obtain the required process ID (<code class="literal">PID</code>) or parent process ID (<code class="literal">PPID</code>), but we will not wade through all the options (both old and new). Based on speed alone, I think you will agree that taking advantage of the <code class="literal">systemd</code> command has its own advantages.</p></div>
<div class="section" title="More about systemd"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>More about systemd</h1></div></div></div><p>The <a id="id113" class="indexterm"/>
<code class="literal">systemd</code> system and service manager is responsible for controlling <a id="id114" class="indexterm"/>how services are managed on CentOS 7. Things are very different now, and the consequence of this is to appreciate that, not only have the locations of the scripts changed to <code class="literal">/usr/lib/systemd/systemd</code>, but the older commands are to be depreciated to such an extent that (eventually) they will be expunged.</p><p>For example, when using <code class="literal">systemd</code> to check the status or start or stop a service, you can use one of the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl status &lt;service_name&gt;.service</strong></span>
<span class="strong"><strong># systemctl stop &lt;service_name&gt;.service</strong></span>
<span class="strong"><strong># systemctl start &lt;service_name&gt;.service</strong></span>
</pre></div><p>Moreover, rather than using <code class="literal">chkconfig</code>, to enable and disable a service during the boot sequence, you should now use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl enable &lt;service_name&gt;.service</strong></span>
<span class="strong"><strong># systemctl disable &lt;service_name&gt;.service</strong></span>
</pre></div><p>You may be in two minds about this approach, but rather than dwelling on the subject of change, let's consider how we can use the new commands to make troubleshooting an active process a little easier. To do this, we shall begin with a simple approach: listing all current services with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl list-units --type service</strong></span>
</pre></div><p>Everything is <a id="id115" class="indexterm"/>now known as a unit, and by realizing this, the same command can be modified to show all mounts as well:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl list-units --type mount</strong></span>
</pre></div><p>Meanwhile, invoking the following command can be used to list all service dependencies:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl list-dependencies &lt;service_name&gt;.service</strong></span>
</pre></div><p>Furthermore, <code class="literal">systemd</code> also<a id="id116" class="indexterm"/> comes with its own version of <code class="literal">top</code>, and in order to view the processes that are associated with a particular service, you can use the <code class="literal">system-cgtop</code> command like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemd-cgtop</strong></span>
</pre></div><p>As you will notice, this command provides a summary of all associated processes and indicates the path, number of tasks, percentage of CPU used, memory allocation, and the relative inputs and outputs. It works in a way similar to <code class="literal">top</code>, but it is different and its use can be modified to output a recursive list of service content as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemd-cgls</strong></span>
</pre></div><p>The output will look something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  ├─smb.service</strong></span>
<span class="strong"><strong>  │ ├─2472 /usr/sbin/smbd</strong></span>
<span class="strong"><strong>  │ └─2473 /usr/sbin/smbd</strong></span>
<span class="strong"><strong>  ├─httpd.service</strong></span>
<span class="strong"><strong>  │ ├─2394 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>  │ ├─2395 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>  │ ├─2396 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>  │ ├─2397 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>  │ ├─2398 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>  │ └─2399 /usr/sbin/httpd -DFOREGROUND</strong></span>
<span class="strong"><strong>  ├─polkit.service</strong></span>
<span class="strong"><strong>  │ └─875 /usr/lib/polkit-1/polkitd --no-debug</strong></span>
<span class="strong"><strong>  ├─auditd.service</strong></span>
<span class="strong"><strong>  │ └─672 /sbin/auditd -n</strong></span>
</pre></div><p>So, as we can see, in many <a id="id117" class="indexterm"/>respects <code class="literal">systemd</code> is verbose but it does <a id="id118" class="indexterm"/>save us time when attempting to retrieve certain information regarding an active process. At this stage, it is important to realize that we have only scratched the surface of <code class="literal">systemd</code>, but, for the purpose of this chapter, I am sure your continued experience of using it will be both productive and enjoyable.</p></div>
<div class="section" title="Issuing the kill signal"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Issuing the kill signal</h1></div></div></div><p>The most <a id="id119" class="indexterm"/>common reason behind wanting to know a process ID is to pass this<a id="id120" class="indexterm"/> information to the <code class="literal">kill</code> command. The process ID does have other uses, but our primary concern is to remove a problematic service or application by issuing a termination signal (<code class="literal">SIGTERM</code>) to the relevant daemon as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># kill pid_of_process</strong></span>
</pre></div><p>The <code class="literal">kill</code> signal instructs the process to terminate, thereby enabling the process in question to perform some basic cleanup operations and exit in an orderly fashion. This approach is known as a "safe kill". However, depending on your situation, a better solution can be to force a service or application to hang up, and thereby enable an automatic reload of the daemon as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># kill -1 pid_of_process</strong></span>
</pre></div><p>This command is known as a <code class="literal">SIGHUP</code> or <code class="literal">hangover</code> command. On the other hand, if the process has seemingly crashed, and a safe kill or reload operation fails to make any difference, then by passing the following command, you will be able to literally kill the process in question:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># kill -9 pid_of_process</strong></span>
</pre></div><p>The use of option <code class="literal">9</code> in this command infers a signal kill (<code class="literal">SIGKILL</code>), and unlike the original kill order (<code class="literal">SIGTERM</code>), this alternative version is issued to the kernel directly, thereby killing the process in a far more abrupt manner. There are no cleanup operations or safe exits with this command, and as a consequence, it is known as a "forced kill".</p><p>Finally, to take the <a id="id121" class="indexterm"/>issue of a "forced kill" one stage further, it is also quite proper to use the <code class="literal">pkill</code> command with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># pkill -9 httpd</strong></span>
</pre></div><p>Alternatively, you <a id="id122" class="indexterm"/>can use the <code class="literal">pgrep</code> command to ensure that all processes associated with the relevant search term are removed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># pgrep httpd</strong></span>
</pre></div><p>So, having covered the most common usage of the <code class="literal">kill</code> command, one technique that remains is based on the need to deal with an orphaned process.</p></div>
<div class="section" title="Dealing with an orphaned process"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Dealing with an orphaned process</h1></div></div></div><p>Orphaned processes<a id="id123" class="indexterm"/> are not common issues, but they do arise, and in <a id="id124" class="indexterm"/>order to deal with them, we must begin by matching the displayed <code class="literal">PID</code> or <code class="literal">PPID</code> with the ID used by the <code class="literal">init</code> process itself. Using <code class="literal">ps</code> will reveal that both have a <code class="literal">PPID</code> equal to <code class="literal">1</code> and being honest, you will probably realize that there is little difference between an orphaned process and a daemon process with the exception that an orphaned process arises out of error. So, the golden rule here is to remember that an orphaned process can be spotted using a relatively simple technique, and it can be killed in the standard way.</p><p>Orphans can arise for a number of reasons and, though they have been adopted by <code class="literal">init</code>, you will find that they are still executing commands. For this reason, orphaned processes are potentially dangerous as they continue to starve your system of resources. In some instances, having too many orphans can overload the <code class="literal">init</code> process and cause a system hang. This is not common, but the removal of such erroneous daemons is an important task for the troubleshooter, and should your system be prone to such instances, this is something you should keep a constant eye on.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Summary</h1></div></div></div><p>The purpose of this chapter was to elucidate some concepts with regards to troubleshooting active processes and in this respect we have managed to sweep through the hallways of <code class="literal">swap</code>, <code class="literal">vmstat</code>, <code class="literal">top</code>, <code class="literal">ps</code>, process IDs, <code class="literal">kill</code>, and <code class="literal">pkill</code>. Of course, there are many more utilities at your disposal but for most troubleshooters (beginner and experienced alike), knowing how to monitor and measure memory usage; determining server load; watching for power-greedy applications, services, or users; removing orphaned processes; and using <code class="literal">systemd</code> will easily serve you well before we move forward and consider an approach to troubleshoot the network.</p></div>
<div class="section" title="References"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>References</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Red Hat Enterprise Linux 7 System Administrators guide: <a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/chap-Managing_Services_with_systemd.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/chap-Managing_Services_with_systemd.html</a></li><li class="listitem" style="list-style-type: disc">The Swappiness Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Swappiness">http://en.wikipedia.org/wiki/Swappiness</a></li><li class="listitem" style="list-style-type: disc">The <code class="literal">vmstat</code> command Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Vmstat">http://en.wikipedia.org/wiki/Vmstat</a></li><li class="listitem" style="list-style-type: disc">The <code class="literal">iostat</code> command Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Iostat">http://en.wikipedia.org/wiki/Iostat</a></li><li class="listitem" style="list-style-type: disc">The <code class="literal">lsof</code> command Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Lsof">http://en.wikipedia.org/wiki/Lsof</a></li><li class="listitem" style="list-style-type: disc">The <code class="literal">kill</code> command Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Kill_(command)">http://en.wikipedia.org/wiki/Kill_(command)</a></li><li class="listitem" style="list-style-type: disc">The <code class="literal">pkill</code> command Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Pkill">http://en.wikipedia.org/wiki/Pkill</a></li><li class="listitem" style="list-style-type: disc">SysVinit to Systemd Cheatsheet: <a class="ulink" href="https://fedoraproject.org/wiki/SysVinit_to_Systemd_Cheatsheet">https://fedoraproject.org/wiki/SysVinit_to_Systemd_Cheatsheet</a></li><li class="listitem" style="list-style-type: disc">The Orphans Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Orphan_process">http://en.wikipedia.org/wiki/Orphan_process</a></li></ul></div></div></body></html>