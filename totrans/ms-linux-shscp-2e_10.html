<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">AWK Fundamentals</h1>
                </header>
            
            <article>
                
<p>The stream editor is not alone in its family and has a big brother, AWK. In this chapter, we will run through the basics of AWK and explore the power of the AWK programming language. We will learn why we need and love AWK and how we can make use of some of the basic features before we start putting AWK to practical use in the next two chapters. As we work our way through this, we will cover the following topics:</p>
<ul>
<li>The history behind AWK</li>
<li>Displaying and filtering content from files</li>
<li>AWK variables</li>
<li>Conditional statements</li>
<li>Formatting output</li>
<li>Further filtering to display users by UID</li>
<li>AWK control files</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The source code for this chapter can be downloaded here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter10">https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter10</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The history behind AWK</h1>
                </header>
            
            <article>
                
<p>The <kbd>awk</kbd> command is a command suite mainstay in both UNIX and Linux. The UNIX <kbd>awk</kbd> command was first developed by Bell Labs in the 1970s and is named after the surnames of the main authors: Alfred Aho, Peter Weinberger, and Brian Kernighan. The <kbd>awk</kbd> command allows access to the AWK programming language, which is designed to process data within text streams.</p>
<p>There are many implementations of AWK:</p>
<ul>
<li><strong>gawk</strong>: Also known as GNU AWK, it is a free version of AWK and used by many developers; we will use it in this book.</li>
<li><strong>mawk</strong><span>: Another implementation made by a guy named Mike Brennan. This implementation only includes a few gawk features; it was designed for speed and performance.</span></li>
<li><strong>tawk</strong><span>: Or Thompson AWK, is an implementation that works on Solaris, DOS, and Windows.</span></li>
<li><strong>BWK awk</strong><span>: Also known as nawk, it is used by OpenBSD and macOS.</span></li>
</ul>
<p>Note that the <kbd>awk</kbd> interpreter that we will use in this book is <kbd>gawk</kbd> but there is a symbolic link for it with the name <kbd>awk</kbd>. So <kbd>awk</kbd> and <kbd>gawk</kbd> are the same command.</p>
<p>You can ensure this by listing the <kbd>awk</kbd> binary to see where it points to:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6d405e0c-371f-412a-8d9a-f1e2c554d4d5.png" style="width:39.00em;height:7.58em;"/></div>
<p>To demonstrate the programming language that is provided with <kbd>awk</kbd>, we should create a <kbd>Hello World</kbd> program. We know this is compulsory for all languages:</p>
<pre><strong>$ awk 'BEGIN { print "Hello World!" }'</strong>  </pre>
<p>Not only can we see that this code will print the ubiquitous hello message, we can also generate header information with the <kbd>BEGIN</kbd> block. Later, we will see that we<br/>
can create summary information with an <kbd>END</kbd> code block by allowing for a main<br/>
code block.</p>
<p>We can see the output of this basic command in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-313 image-border" src="assets/757972a8-7d3e-4d0f-a5a1-fd273419035c.png" style="width:30.25em;height:4.17em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying and filtering content from files</h1>
                </header>
            
            <article>
                
<p>Now, of course we all want to be able to print a little more than just <kbd>Hello World</kbd>. The <kbd>awk</kbd> command can be used to filter content from files and, if needed, very large files. We should begin by printing the complete file before filtering it. In this way, we will get a feel for the syntax of the command. Later, we will see how we can add this control information into <kbd>awk</kbd> files to ease the command line. Using the following command, we will print all the lines from the <kbd>/etc/passwd</kbd> file:</p>
<pre><strong>$ awk ' { print } ' /etc/passwd</strong>  </pre>
<p>This is equivalent to using the <kbd>$0</kbd> variable with the <kbd>print</kbd> statement:</p>
<pre><strong>$ awk ' { print $0 }' /etc/passwd</strong> </pre>
<p>AWK provides us with some ready-to-use variables to extract data such as:</p>
<ul>
<li><kbd>$0</kbd> for the entire line</li>
<li><kbd>$1</kbd> for the first field</li>
<li><kbd>$2</kbd> for the second field</li>
<li><kbd>$3</kbd> for the third field and so on</li>
</ul>
<p>However, we will need to specify that in this file the field separator used is a colon, since it's the field separator in <kbd>/etc/passwd</kbd> file. The <kbd>awk</kbd> default delimiter is a space or any amount of spaces or tabs and newlines. There are two ways to specify the input delimiter; these are displayed in the following examples.</p>
<p>The first example is easy and simple to use. The <kbd>-F</kbd> option works well, especially where we do not need any additional header information:</p>
<pre><strong>$ awk -F":" '{ print $1 }' /etc/passwd</strong>  </pre>
<p>We could also do this within the <kbd>BEGIN</kbd> block; this is useful when we want to use the <kbd>BEGIN</kbd> block to display header information:</p>
<pre><strong>$ awk ' BEGIN { FS=":" } { print $1 } ' /etc/passwd</strong>  </pre>
<p>We can see this clearly in the preceding example, in which we named the <kbd>BEGIN</kbd> block and all of the code within it is corralled by the brace brackets. The main block has no name and is enclosed within the brace brackets.</p>
<p>After seeing the <kbd>BEGIN</kbd> block and the main code blocks, we will now look at the <kbd>END</kbd> code block. This is often used to display summary data. For example, if we want to print the total lines in the <kbd>passwd</kbd> file, we can make use of the <kbd>END</kbd> block. The code with the <kbd>BEGIN</kbd> and <kbd>END</kbd> blocks is processed just once, whereas the main block is processed for each line. The following example adds to the code we have written so far to include the total line count:</p>
<pre><strong>$ awk ' BEGIN { FS=":" } { print $1 } END { print NR } ' /etc/passwd</strong>  </pre>
<p>The <kbd>awk</kbd> internal variable <kbd>NR</kbd> maintains the number of processed lines. If we want, we can add some additional text to this. This can be used to annotate the summary data. We can also make use of the single quotes that are used with the AWK language; they will allow us to spread the code across multiple lines. Once we have opened the single quotes, we can add newlines to the command line right until we close the quote. This is demonstrated in the next example where we have extended the summary information:</p>
<pre><strong>$ awk ' BEGIN { FS=":" }</strong>
<strong>&gt; { print $1 }</strong>
<strong>&gt; END { print "Total:",NR } ' /etc/passwd</strong> </pre>
<p>If we do not wish to end our AWK experience here, we can easily display a running line count with each line, as well as the final total. This is shown in the following example:</p>
<pre><strong>$ awk ' BEGIN { FS=":" }</strong>
<strong>&gt; { print NR,$1 }</strong>
<strong>&gt; END { print "Total:",NR } ' /etc/passwd</strong>  </pre>
<p>The following screenshot captures this command and shows a partial output:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-314 image-border" src="assets/2719bbfb-dc6e-4bbe-9eed-82ab0735eb19.png" style="width:24.92em;height:9.67em;"/></div>
<p>In the first example with <kbd>BEGIN</kbd>, we saw that there is no reason why we cannot use the <kbd>END</kbd> code block in isolation without a main code block. If we need to emulate the <kbd>wc -l</kbd> command, we can use the following <kbd>awk</kbd> statement:</p>
<pre><strong>$ awk ' END { print NR }' /etc/passwd</strong> </pre>
<p>The output will be the line count from the file. The following screenshot shows both the use of the <kbd>awk</kbd> command and the <kbd>wc</kbd> command to count the lines in the <kbd>/etc/passwd</kbd> file:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-315 image-border" src="assets/f32eb6df-a407-48aa-a1ec-4bcca857381c.png" style="width:30.83em;height:5.08em;"/></div>
<p>As we can see, the output does tally with <kbd>28</kbd> lines and our code has worked.</p>
<p>Another feature that we can practice with is working on selected lines only. For example, if we want to print only the first five lines, we will use the following statement:</p>
<pre><strong>$ awk ' NR &lt; 6 ' /etc/passwd</strong>  </pre>
<p>If we want to print lines <kbd>8</kbd> through to <kbd>12</kbd>, we can use the following code:</p>
<pre><strong>$ awk ' NR==8,NR==12 ' /etc/passwd</strong></pre>
<p>We can also use regular expressions to match the text in the lines. Take a look at the following example where we look at the lines that end in the word <kbd>bash</kbd>:</p>
<pre><strong>$ awk ' /bash$/ ' /etc/passwd</strong> </pre>
<p>The example and the output it produces are shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-316 image-border" src="assets/c9950942-4576-4d57-9e76-00db300f4232.png" style="width:27.17em;height:8.00em;"/></div>
<p>So if you want to use a regex pattern, you should use two slashes and write the pattern between them, <kbd>/bash$/</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWK variables</h1>
                </header>
            
            <article>
                
<p>We saw how to use data fields such as <kbd>$1</kbd> and <kbd>$2</kbd>. Also, we saw the <kbd>NR</kbd> field, which holds the number of processed lines, but there are more built-in variables that AWK offers to simplify work more and more.</p>
<ul>
<li><kbd>FIELDWIDTHS</kbd>: Specifies the field width</li>
<li><kbd>RS</kbd>: Specifies the record separator</li>
<li><kbd>FS</kbd>: Specifies the field separator</li>
<li><kbd>OFS</kbd>: Specifies the output separator, which is a space by default</li>
<li><kbd>ORS</kbd>: Specifies the output separator</li>
<li><kbd>FILENAME</kbd>: Holds the processed file name</li>
<li><kbd>NF</kbd>: Holds the line being processed</li>
<li><kbd>FNR</kbd>: Holds the record which is processed</li>
<li><kbd>IGNORECASE</kbd>: Ignores character case</li>
</ul>
<p>These variables can help you a lot in many cases. Let's assume that we have the following file:</p>
<pre>John Doe
15 back street
(123) 455-3584
    
Mokhtar Ebrahim
10 Museum street
(456) 352-3541  </pre>
<p>We can say that we have two records for two persons and each record contains three fields. Let's assume that we need to print the name and the phone number. So how do we make AWK process them correctly?</p>
<p>In this case, the fields are separated by a newline (<kbd>\n</kbd>) and the records are separated by empty lines.</p>
<p>So if we set the <kbd>FS</kbd> to (<kbd>\n</kbd>) and the <kbd>RS</kbd> to empty text, the fields will be identified correctly:</p>
<pre><strong>$ awk 'BEGIN{FS="\n"; RS=""} {print $1,$3}' myfile</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/361093cf-f70e-4c2d-8ce3-648beef07edb.png" style="width:52.25em;height:7.67em;"/></div>
<p>The result appears valid and appropriate.</p>
<p>In the same way, you can use the <kbd>OFS</kbd> and <kbd>ORS</kbd> for the output report:</p>
<pre><strong>$ awk 'BEGIN{FS="\n"; RS=""; OFS="*"} {print $1,$3}' myfile</strong>  </pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b76f1ab8-5aa2-4e3d-b1fa-bc8c7ea452d2.png" style="width:53.67em;height:7.42em;"/></div>
<p>You can use any text that fits your needs.</p>
<p>We know that <kbd>NR</kbd> holds the number of the processed line and <kbd>FNR</kbd> looks the same from the definition, but let's explore the following example to see the difference:</p>
<p>Assume that we have the following file:</p>
<pre>Welcome to AWK programming
This is a test line
And this is one more </pre>
<p>Let's process this file using AWK:</p>
<pre><strong>$ awk 'BEGIN{FS="\n"}{print $1,"FNR="FNR}' myfile myfile</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/11a00d9b-6945-4e95-a407-1cf18b195699.png" style="width:52.42em;height:11.08em;"/></div>
<p>Here we processed the file twice for testing purposes only to see what the value of the FNR variable is.</p>
<p>As you can see, the value starts from 1 for every processing cycle.</p>
<p>Let's see the whether <kbd>NR</kbd> variable is used in the same way:</p>
<pre><strong>$ awk 'BEGIN {FS="\n"} {print $1,"FNR="FNR,"NR="NR} END{print "Total lines: ",NR}' myfile myfile</strong>  </pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c86fa85a-2ff9-47c0-bf4b-305d06baacd6.png" style="width:52.83em;height:13.08em;"/></div>
<p>The <kbd>NR</kbd> variable preserves its value during the entire processing while <kbd>FNR</kbd> started from 1.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User-defined variables</h1>
                </header>
            
            <article>
                
<p>You can define your own variables to use in AWK programming, as with any programming language.</p>
<p>You can define the variable using any text, but it <strong>MUST</strong> not start with numbers:</p>
<pre><strong>$ awk '</strong>
<strong>BEGIN{</strong>
<strong>var="Welcome to AWk programming"</strong>
<strong>print var</strong>
<strong>}'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-317 image-border" src="assets/7fc7426a-2318-4abe-9a6d-9fefe5f77c3d.png" style="width:32.83em;height:9.25em;"/></div>
<p>You can define any type of variables and use it the same way.</p>
<p>You can define numbers like this:</p>
<pre><strong>$ awk '</strong>
<strong>BEGIN{</strong>
<strong>var1=2</strong>
<strong>var2=3</strong>
<strong>var3=var1+var2</strong>
<strong>print var3</strong>
<strong>}'</strong>  </pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-318 image-border" src="assets/df63184b-d9ca-4954-a84e-1b50e59f3e07.png" style="width:19.92em;height:12.42em;"/></div>
<p>Or perform string concatenation like this:</p>
<pre><strong>$ awk '</strong>
<strong>BEGIN{</strong>
<strong>str1="Welcome "</strong>
<strong>str2=" To shell scripting"</strong>
<strong>str3=str1 str2</strong>
<strong>print str3</strong>
<strong>}'</strong>  </pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-319 image-border" src="assets/16df7c1c-1c6e-47d4-80d3-7c4212e44a0e.png" style="width:19.58em;height:12.17em;"/></div>
<p>As you can see, AWK is a powerful scripting language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conditional statements</h1>
                </header>
            
            <article>
                
<p>AWK supports conditional statements such as <kbd>if</kbd> and <kbd>while</kbd> loops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The if command</h1>
                </header>
            
            <article>
                
<p>Assume you have the following file:</p>
<pre><strong>50</strong>
<strong>30</strong>
<strong>80</strong>
<strong>70</strong>
<strong>20</strong>
<strong>90</strong> </pre>
<p>Now, let's filter the values:</p>
<pre><strong>$ awk '{if ($1 &gt; 50) print $1}' myfile</strong>  </pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/298b58b8-5aa1-410f-adfc-52221e3062e9.png" style="width:45.17em;height:8.67em;"/></div>
<p>The <kbd>if</kbd> statement checks every value and, if it's greater than <kbd>50</kbd>, it will print it.</p>
<p>You can use <kbd>else</kbd> clauses like this:</p>
<pre><strong>$ awk '{</strong>
<strong>if ($1 &gt; 50)</strong>
<strong>{</strong>
<strong>x = $1 * 2</strong>
<strong>print x</strong>
<strong>} else</strong>
<strong>{</strong>
<strong>x = $1 * 3</strong>
<strong>print x</strong>
<strong>}}' myfile</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-320 image-border" src="assets/046f7d64-582c-4377-b9fd-cc5fbbcf910b.png" style="width:29.17em;height:19.00em;"/></div>
<p>If you don't use brackets <kbd>{}</kbd> to enclose your statements, you can type them on the same line with a semicolon:</p>
<pre><strong>$ awk '{if ($1 &gt; 50) print $1 * 2;  else print $1 * 3}' myfile</strong>  </pre>
<div class="packt_infobox">Note that you can save this code into a file and assign it to the <kbd>awk</kbd> command using the <kbd>-f</kbd> option, as we will see later on this chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">while loops</h1>
                </header>
            
            <article>
                
<p>AWK processes every line of your file, but what if you want to iterate over the fields of each line itself?</p>
<p>You can iterate over fields using a <kbd>while</kbd> loop when using AWK.</p>
<p>Assume we have the following file:</p>
<pre>321 524 124
174 185 254
195 273 345 </pre>
<p>Now let's iterate over the fields using a <kbd>while</kbd> loop.</p>
<pre><strong>$ awk '{</strong>
<strong>total = 0</strong>
<strong>i = 1</strong>
<strong>while (i &lt; 4)</strong>
<strong>{</strong>
<strong>total += $i</strong>
<strong>i++</strong>
<strong>}</strong>
<strong>mean = total / 3</strong>
<strong>print "Mean value:",mean</strong>
<strong>}' myfile</strong>  </pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-322 image-border" src="assets/0d7658dd-f966-4a9c-9f9c-1a2ccebdc975.png" style="width:21.25em;height:17.83em;"/></div>
<p>The <kbd>while</kbd> loop iterates over the fields; we get the mean value for every row and print it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">for loops</h1>
                </header>
            
            <article>
                
<p>You can use <kbd>for</kbd> loops to iterate over values when using AWK like this:</p>
<pre><strong>$ awk '{</strong>
<strong>total = 0</strong>
<strong>for (var = 1; var &lt; 4; var++)</strong>
<strong>{</strong>
<strong>total += $var</strong>
<strong>}</strong>
<strong>mean = total / 3</strong>
<strong>print "Mean value:",mean</strong>
<strong>}' myfile</strong>  </pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-323 image-border" src="assets/a3f8945c-372b-47c5-9299-864315bba4a2.png" style="width:20.17em;height:15.17em;"/></div>
<p>We achieved the same result but using the <kbd>for</kbd> loop this time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Formatting output</h1>
                </header>
            
            <article>
                
<p>We have remained faithful to the <kbd>print</kbd> command so far, as we have been limited in what we require from the output. If we want to print out, say, the username, UID, and default shell, we need to start formatting the output just a little. In this case, we can organize the output in well-shaped columns. Without formatting, the command we use will look similar to the following example, where we use commas to separate the field that we want to print:</p>
<pre><strong>$ awk ' BEGIN { FS=":" } { print $1,$3,$7 } ' /etc/passwd</strong>  </pre>
<p>We use the <kbd>BEGIN</kbd> block here, as we can make use of it to print column headers later.</p>
<p>To understand the problem a little better, take a look at the following screenshot, which illustrates uneven column widths:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-324 image-border" src="assets/4bf6ec22-7ba9-47e6-a607-20d508c24e25.png" style="width:34.42em;height:6.33em;"/></div>
<p>The issue that we have in the output is that the columns do not align, as the username is an inconsistent length. To improve on this, we can use the <kbd>printf</kbd> function where we can specify the column width. The syntax for the <kbd>awk</kbd> statements will be similar to the following example:</p>
<pre><strong>$ awk ' BEGIN { FS=":" }</strong>
<strong>&gt; { printf "%10s %4d %17s\n",$1,$3,$7 } ' /etc/passwd</strong>  </pre>
<p>The <kbd>printf</kbd> formatting is included within double quotes. We also need to include the newline with the <kbd>\n</kbd>. The <kbd>printf</kbd> function does not add a newline automatically, whereas the <kbd>print</kbd> function does. We print the three fields; the first accepts string values and is set to <kbd>10</kbd> characters wide. The middle field accepts up to 4 numbers and we finish with the default shell field where we allow up to <kbd>17</kbd> string characters.</p>
<p>The following screenshot shows how the output can be improved:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-325 image-border" src="assets/97206a9b-bc3b-48e5-8680-e5ab77c9d1dc.png" style="width:28.50em;height:10.25em;"/></div>
<p>We can further enhance this by adding header information. Although the code starts to look untidy at this stage, we will later see how we can resolve this with AWK control files. The following example shows the header information being added to the <kbd>Begin</kbd> block. The semicolon is used to separate the two statements in the <kbd>BEGIN</kbd> block:</p>
<pre><strong>$ awk 'BEGIN {FS=":" ;printf "%10s %4s %17s\n","Name","UID","Shell" }</strong>
<strong>&gt; { printf "%10s %4d %17s\n",$1,$3,$7 } ' /etc/passwd</strong></pre>
<p>In the following screenshot, we can see how this improves the output even further:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-326 image-border" src="assets/2b0843bd-5e5c-4978-86d2-cd2dfb8dbf4c.png" style="width:41.50em;height:8.33em;"/></div>
<p>In the previous chapter, we saw how we can augment the output with the use of colors in the shell. We may also use color from within AWK by adding our own functions. In the next code example, you will see that AWK allows us to define our own functions to facilitate more complex operations and isolate the code. We will now modify the previous code to include green output in the header:</p>
<pre><strong>$ awk 'function green(s) {</strong>
<strong>&gt; printf "\033[1;32m" s "\033[0m\n"</strong>
<strong>&gt; }</strong>
<strong>&gt; BEGIN {FS=":"; <br/>green("   Name:  UID:    Shell:") }</strong>
<strong>&gt; { printf "%10s %4d %17s\n",$1,$3,$7 } ' /etc/passwd</strong></pre>
<p>Creating the function within <kbd>awk</kbd> allows color to be added where we require, in this case, green text. It is easy to create functions to define other colors. The code and output are included in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-327 image-border" src="assets/bbbf8c9f-4f3b-4285-8792-ce9d95340d39.png" style="width:29.67em;height:12.75em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further filtering to display users by UID</h1>
                </header>
            
            <article>
                
<p>We have been able to build our skills with AWK, piece by piece, and what we have learned has been useful. We can take these tiny steps and add them to start creating something a little more usable. Perhaps we want to print just standard users; these are usually users higher than 500 or 1,000 depending on your particular distribution.</p>
<p>On the Linux Mint distribution that I am using for this book, standard users start with UID <kbd>1000</kbd>. The UID is the third field. This is really a simple matter of using the value of the third field as the range operator. We can see this in the following example:</p>
<pre><strong>$ awk -F":" '$3 &gt; 999 ' /etc/passwd</strong>  </pre>
<p>We can show users whose UID is <kbd>101</kbd> or lower with the following command:</p>
<pre><strong>$ awk -F":" '$3 &lt; 101 ' /etc/passwd</strong></pre>
<p>These just give you an idea of some of the possibilities available with AWK. The reality is that we can play all day with our arithmetic comparison operators.</p>
<p>We have also seen that, with some of these examples, the <kbd>awk</kbd> statements become a little long. This is where we can implement the <kbd>awk</kbd> control files. Let's take a look at these straightaway before we get lost in a morass of syntax.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWK control files</h1>
                </header>
            
            <article>
                
<p>Just as with <kbd>sed</kbd>, we can simplify the command line by creating and including control files. This also makes editing the command later more easily achievable. The control files contain all the statements that we want <kbd>awk</kbd> to execute. The main thing that we must consider with <kbd>sed</kbd>, <kbd>awk</kbd>, and shell scripts is modularization; creating reusable elements that can be used to isolate and reuse the codes. This saves us time and work and we get more time for the tasks that we enjoy.</p>
<p>To see an example of an <kbd>awk</kbd> control file, we should revisit the formatting of the <kbd>passwd</kbd> file. Creating the following file will encapsulate the <kbd>awk</kbd> statements:</p>
<pre>function green(s) { 
    printf "\033[1;32m" s "\033[0m\n" 
} 
BEGIN { 
    FS=":" 
    green("   Name:   UID:       Shell:") 
} 
{ 
    printf "%10s %4d %17s\n",$1,$3,$7 
} </pre>
<p>We can save this file as <kbd>passwd.awk</kbd>.</p>
<p>Being able to encompass all <kbd>awk</kbd> statements in the one file is very convenient and the execution becomes clean and tidy:</p>
<pre><strong>$ awk -f passwd.awk /etc/passwd</strong> </pre>
<p>This certainly encourages more complex <kbd>awk</kbd> statements and allows you to extend more functionality to your code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Built-in functions</h1>
                </header>
            
            <article>
                
<p>In the previous example, we defined a function called <kbd>green</kbd>. This leads into taking about some built-in functions that come with <kbd>awk</kbd>.</p>
<p>AWK comes with many built-in functions such as mathematical functions:</p>
<ul>
<li><kbd>sin(x)</kbd></li>
<li><kbd>cos(x)</kbd></li>
<li><kbd>sqrt(x)</kbd></li>
<li><kbd>exp(x)</kbd></li>
<li><kbd>log(x)</kbd></li>
<li><kbd>rand()</kbd></li>
</ul>
<p>You can use them like this:</p>
<pre><strong>$ awk 'BEGIN{x=sqrt(5); print x}'</strong> </pre>
<p>Also, there are built-in functions that can be used in string manipulation:</p>
<pre><strong>$ awk 'BEGIN{x = "welcome"; print toupper(x)}'</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>I hope that you have a better and clearer understanding of what you can use the AWK tool for. This is a data-processing tool that runs through text files, line by line, and processes the code you add. The main block runs for each line that matches the row criteria, whereas the <kbd>BEGIN</kbd> and <kbd>END</kbd> block code is executed just once.</p>
<p>You've learned how to use AWK built-in variables and how to define your own variables and use them.</p>
<p>Also, you have learned how to use the <kbd>if</kbd>, <kbd>while</kbd> , and <kbd>for</kbd> loop to iterate over data fields.</p>
<p>In the next chapter, we will discuss regular expressions and how to use them in <kbd>sed</kbd> and AWK to gain a lot of power.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the output of the following command?</li>
</ol>
<pre style="padding-left: 60px"><strong>$ awk '</strong>
<strong>BEGIN{</strong>
<strong>var="I love AWK tool"</strong>
<strong>print $var</strong> <br/><strong>}'</strong></pre>
<p style="padding-left: 60px"/>
<ol start="2">
<li>Assume you have the following file:</li>
</ol>
<pre style="padding-left: 60px"><strong>13</strong><br/><strong>15</strong><br/><strong>22</strong><br/><strong>18</strong><br/><strong>35</strong><br/><strong>27</strong></pre>
<p style="padding-left: 60px">Then you run the following command against this file:</p>
<pre style="padding-left: 60px"><strong>$ awk '{if ($1 &gt; 30) print $2}' myfile</strong> </pre>
<p style="padding-left: 60px">How many numbers will be printed?</p>
<ol start="3">
<li>Assume that you have the following file:</li>
</ol>
<pre style="padding-left: 60px">135 325 142<br/>215 325 152<br/>147 254 327</pre>
<p style="padding-left: 60px">And you run the following command:</p>
<pre style="padding-left: 60px"><strong>$ awk '{</strong>
<strong>total = 0</strong>
<strong>i = 1</strong>
<strong>while (i &lt; 3)</strong>
<strong>{</strong>
<strong>total += $i</strong>
<strong>i++</strong>
<strong>}</strong>
<strong>mean = total / 3</strong>
<strong>print "Mean value:",mean</strong>  <br/><strong>}' myfile</strong></pre>
<p style="padding-left: 60px">What is wrong with the previous code?</p>
<ol start="4">
<li>How many lines will be printed from the following command?</li>
</ol>
<pre style="padding-left: 60px"><strong>$ awk -F":" '$3 &lt; 1 ' /etc/passwd</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>Please see the following for further reading relating to this chapter:</span></p>
<ul>
<li><a href="https://likegeeks.com/awk-command/"><span class="URLPACKT">https://likegeeks.com/awk-command/</span></a></li>
<li><a href="https://www.gnu.org/software/gawk/manual/gawk.html"><span class="URLPACKT">https://www.gnu.org/software/gawk/manual/gawk.html</span></a></li>
</ul>


            </article>

            
        </section>
    </body></html>