- en: Chapter 2. The BSP Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。BSP层
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Creating a custom BSP layer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建定制的BSP层
- en: Introducing system development workflows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍系统开发工作流
- en: Adding a custom kernel and bootloader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义内核和引导加载程序
- en: Building the U-Boot bootloader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建U-Boot引导加载程序
- en: Explaining Yocto's Linux kernel support
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Yocto对Linux内核的支持
- en: Describing Linux's build system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Linux的构建系统
- en: Configuring the Linux kernel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Linux内核
- en: Building the Linux source
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Linux源代码
- en: Building external kernel modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建外部内核模块
- en: Debugging the Linux kernel and modules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Linux内核和模块
- en: Debugging the Linux kernel booting process
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Linux内核引导过程
- en: Using the kernel tracing system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核追踪系统
- en: Managing the device tree
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理设备树
- en: Debugging device tree issues
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试设备树问题
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Once we have our build environment ready with the Yocto project, it's time to
    think about beginning development work on our embedded Linux project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的构建环境准备好并且Yocto项目已经就绪，就可以开始考虑开始开发我们的嵌入式Linux项目。
- en: Most of the embedded Linux projects require both custom hardware and software.
    An early task in the development process is to test different hardware reference
    boards and the selection of one to base our design on. We have chosen the Wandboard,
    a Freescale i.MX6-based platform, as it is an affordable and open board, which
    makes it perfect for our needs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式Linux项目都需要定制硬件和软件。开发过程中的一项早期任务是测试不同的硬件参考板，并选择一个作为我们设计的基础。我们选择了Wandboard，这是一个基于Freescale
    i.MX6的开发平台，它价格实惠且开源，非常适合我们的需求。
- en: On an embedded project, it is usually a good idea to start working on the software
    as soon as possible, probably before the hardware prototypes are ready, so that
    it is possible to start working directly with the reference design.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式项目中，通常最好尽早开始软件开发，可能在硬件原型准备好之前，这样就可以直接开始与参考设计一起工作。
- en: But at some point, the hardware prototypes will be ready and changes will need
    to be introduced into Yocto to support the new hardware.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在某个阶段，硬件原型将准备就绪，需要在Yocto中引入更改以支持新硬件。
- en: This chapter will explain how to create a BSP layer to contain those hardware-specific
    changes, as well as show how to work with the U-Boot bootloader and the Linux
    kernel, components which are likely to take most of the customization work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何创建一个BSP层来包含这些硬件特定的更改，并展示如何与U-Boot引导加载程序和Linux内核进行工作，这些组件可能需要进行最多的定制工作。
- en: Creating a custom BSP layer
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建定制的BSP层
- en: These custom changes are kept on a separate Yocto layer, called a **Board Support
    Package** (**BSP**) layer. This separation is best for future updates and patches
    to the system. A BSP layer can support any number of new machines and any new
    software feature that is linked to the hardware itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定制更改保存在一个单独的Yocto层中，称为**板支持包**（**BSP**）层。这种分离方式对系统的未来更新和补丁是最有利的。一个BSP层可以支持任意数量的新机器和任何与硬件相关的新软件功能。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: By convention, Yocto layer names start with `meta`, short for metadata. A BSP
    layer may then add a `bsp` keyword, and finally a unique name. We will call our
    layer `meta-bsp-custom`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，Yocto层的名称以`meta`开头，表示元数据。BSP层可以添加`bsp`关键字，最后加上一个唯一的名称。我们将把我们的层命名为`meta-bsp-custom`。
- en: 'There are several ways to create a new layer:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以创建一个新层：
- en: Manually, once you know what is required
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动操作，一旦你知道需要做什么
- en: By copying the `meta-skeleton` layer included in Poky
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过复制Poky中包含的`meta-skeleton`层
- en: By using the `yocto-layer` command-line tool
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`yocto-layer`命令行工具
- en: 'You can have a look at the `meta-skeleton` layer in Poky and see that it includes
    the following elements:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看Poky中的`meta-skeleton`层，看到它包含以下元素：
- en: A `layer.conf` file, where the layer configuration variables are set
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`layer.conf`文件，用于设置层的配置变量
- en: A `COPYING.MIT` license file
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`COPYING.MIT`许可证文件
- en: Several directories named with the `recipes` prefix with example recipes for
    BusyBox, the Linux kernel and an example module, an example service recipe, an
    example user management recipe, and a multilib example.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多名为`recipes`前缀的目录，其中包含BusyBox、Linux内核和示例模块的配方，示例服务配方，示例用户管理配方以及多库示例。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will cover some of the use cases that appear in the available examples in
    the next few recipes, so for our needs, we will use the `yocto-layer` tool, which
    allows us to create a minimal layer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal and change to the `fsl-community-bsp` directory. Then set
    up the environment as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that once the `build` directory has been created, the `MACHINE` variable
    has already been configured in the `conf/local.conf` file and can be omitted from
    the command line.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the `sources` directory and run:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the `yocto-layer` tool will add the `meta` prefix to your layer,
    so you don''t need to. It will prompt a few questions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The layer priority which is used to decide the layer precedence in cases where
    the same recipe (with the same name) exists in several layers simultaneously.
    It is also used to decide in what order `bbappends` are applied if several layers
    append the same recipe. Leave the default value of 6\. This will be stored in
    the layer's `conf/layer.conf` file as `BBFILE_PRIORITY`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether to create example recipes and append files. Let's leave the default
    *no* for the time being.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our new layer has the following structure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is to add this new layer to your project''s `conf/bblayer.conf`
    file. It is a good idea to add it to your template conf directory''s `bblayers.conf.sample`
    file too, so that it is correctly appended when creating new projects. The highlighted
    line in the following code shows the addition of the layer to the `conf/bblayers.conf`
    file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, BitBake will parse the `bblayers.conf` file and find the `conf/layers.conf`
    file from your layer. In it, we find the following line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It tells BitBake which directories to parse for recipes and append files. You
    need to make sure your directory and file hierarchy in this new layer matches
    the given pattern, or you will need to modify it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'BitBake will also find the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `BBPATH` variable is used to locate the `bbclass` files and the configuration
    and files included with the `include` and `require` directives. The search finishes
    with the first match, so it is best to keep filenames unique.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other variables we might consider defining in our `conf/layer.conf` file
    are:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `LAYERDEPENDS` literal is a space-separated list of other layers your layer
    depends on, and the `LAYERVERSION` literal specifies the version of your layer
    in case other layers want to add a dependency to a specific version.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The `COPYING.MIT` file specifies the license for the metadata contained in the
    layer. The Yocto project is licensed under the *MIT* license, which is also compatible
    with the **General Public License** (**GPL**). This license applies only to the
    metadata, as every package included in your build will have its own license.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The `README` file will need to be modified for your specific layer. It is usual
    to describe the layer and provide any other layer dependencies and usage instructions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new machine
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When customizing your BSP, it is usually a good idea to introduce a new machine
    for your hardware. These are kept under the `conf/machine` directory in your BSP
    layer. The usual thing to do is to base it on the reference design. For example,
    `wandboard-quad` has the following machine configuration file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当自定义你的 BSP 时，通常是为你的硬件引入一个新的机器配置。这些配置文件保存在你的 BSP 层中的`conf/machine`目录下。通常做法是基于参考设计。例如，`wandboard-quad`有如下的机器配置文件：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A machine based on the Wandboard design could define its own machine configuration
    file, `wandboard-quad-custom.conf`, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Wandboard 设计的机器可以定义自己的机器配置文件，`wandboard-quad-custom.conf`，内容如下：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `wandboard.inc` file now resides on a different layer, so in order for BitBake
    to find it, we need to specify the full path from the `BBPATH` variable in the
    corresponding layer. This machine defines its own U-Boot configuration file and
    Linux kernel device tree in addition to defining its own set of machine features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`wandboard.inc`文件位于一个不同的层中，因此为了让 BitBake 找到它，我们需要在相应层中从`BBPATH`变量指定完整路径。此机器除定义自己的
    U-Boot 配置文件和 Linux 内核设备树外，还定义了自己的一组机器特性。
- en: Adding a custom device tree to the Linux kernel
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向 Linux 内核添加自定义设备树
- en: 'To add this device tree file to the Linux kernel, we need to add the device
    tree file to the `arch/arm/boot/dts` directory under the Linux kernel source and
    also modify the Linux build system''s `arch/arm/boot/dts/Makefile` file to build
    it as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个设备树文件添加到 Linux 内核中，我们需要将设备树文件添加到 Linux 内核源代码下的`arch/arm/boot/dts`目录，并且还需要修改
    Linux 构建系统中的`arch/arm/boot/dts/Makefile`文件，以便像下面这样构建它：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code uses diff formatting, where the lines with a minus prefix are removed,
    the ones with a plus sign are added, and the ones without a prefix are left as
    reference.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了 diff 格式，其中带有减号前缀的行是删除的，带有加号前缀的行是新增的，而没有前缀的行作为参考保留。
- en: 'Once the patch is prepared, it can be added to the `meta-bsp-custom/recipes-kernel/linux/linux-wandboard-3.10.17/`
    directory and the Linux kernel recipe appended adding a `meta-bsp-custom/recipes-kernel/linux/linux-wandboard_3.10.17.bbappend`
    file with the following content:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦补丁准备好，它可以被添加到`meta-bsp-custom/recipes-kernel/linux/linux-wandboard-3.10.17/`目录，并且
    Linux 内核配方会附加一个`meta-bsp-custom/recipes-kernel/linux/linux-wandboard_3.10.17.bbappend`文件，内容如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An example patch that adds a custom device tree to the Linux kernel can be found
    in the source code that accompanies the book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义设备树到 Linux 内核的示例补丁可以在随书籍附带的源代码中找到。
- en: Adding a custom U-Boot machine
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义的 U-Boot 机器
- en: 'In the same way, the U-Boot source may be patched to add a new custom machine.
    Bootloader modifications are not as likely to be needed as kernel modifications
    though, and most custom platforms will leave the bootloader unchanged. The patch
    would be added to the `meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/`
    directory and the U-Boot recipe appended with a `meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend`
    file with the following content:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，可以对 U-Boot 源代码进行补丁，以添加一个新的自定义机器。然而，启动加载程序的修改不像内核修改那样常见，大多数自定义平台将保持启动加载程序不变。补丁将被添加到`meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/`目录，并且
    U-Boot 配方会附加一个`meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend`文件，内容如下：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An example patch that adds a custom machine to U-Boot can be found in the source
    code that accompanies the book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将自定义机器添加到 U-Boot 的示例补丁可以在随书籍附带的源代码中找到。
- en: Adding a custom formfactor file
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义的 formfactor 文件
- en: 'Custom platforms can also define their own `formfactor` file with information
    that the build system cannot obtain from other sources, such as defining whether
    a touchscreen is available or defining the screen orientation. These are defined
    in the `recipes-bsp/formfactor/` directory in our `meta-bsp-custom` layer. For
    our new machine, we could define a `meta-bsp-custom/recipes-bsp/formfactor/formfactor_0.0.bbappend`
    file to include a `formfactor` file as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义平台还可以定义自己的`formfactor`文件，包含构建系统无法从其他来源获取的信息，例如定义是否有触摸屏或定义屏幕方向。这些文件在我们的`meta-bsp-custom`层中的`recipes-bsp/formfactor/`目录下定义。对于我们的新机器，我们可以定义一个`meta-bsp-custom/recipes-bsp/formfactor/formfactor_0.0.bbappend`文件，内容如下：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the machine-specific `meta-bsp-custom/recipes-bsp/formfactor/formfactor/wandboard-quadcustom/machconfig`
    file would be as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 而与机器相关的`meta-bsp-custom/recipes-bsp/formfactor/formfactor/wandboard-quadcustom/machconfig`文件将如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Introducing system development workflows
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入系统开发工作流
- en: When customizing the software, there are some system development workflows that
    are commonly used, and we will introduce them in this recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义软件时，有一些常用的系统开发工作流，我们将在这个配方中介绍它们。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will see an overview of the following development workflows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将概述以下开发工作流：
- en: External development
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部开发
- en: Working directory development
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: External source development
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部源代码开发
- en: They are all used under different scenarios.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在不同的场景下使用。
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's understand what the use of each of these development workflows is individually.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别理解这些开发工作流的用途。
- en: External development
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部开发
- en: In this workflow, we don't use the Yocto build system to build our packages,
    just a Yocto toolchain and the package's own build system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作流中，我们不使用 Yocto 构建系统来构建我们的包，只使用 Yocto 工具链和包的自有构建系统。
- en: 'The resulting source can be integrated into Yocto in the following ways:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的源代码可以通过以下方式集成到 Yocto 中：
- en: With a recipe that fetches a released tarball.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个从发布的 tarball 获取的配方。
- en: With a recipe that fetches directly from a source-controlled repository.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个直接从源代码控制仓库获取的配方。
- en: External development is usually the preferred method for U-Boot and Linux kernel
    development, as they can be easily cross-compiled. Third-party packages in Yocto
    are also developed in this way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 外部开发通常是 U-Boot 和 Linux 内核开发的首选方法，因为它们可以轻松交叉编译。Yocto 中的第三方包也是以这种方式开发的。
- en: However, third-party packages can be tricky to cross-compile, and that is just
    what the Yocto build system makes easy. So, if we are not the main developers
    of the package and we only want to introduce some fixes or modifications, we can
    use Yocto to help us. The two workflows explained in the following sections use
    the Yocto build system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第三方包可能很难交叉编译，而 Yocto 构建系统正是让这变得容易。所以，如果我们不是包的主要开发者，只是想引入一些修复或修改，我们可以使用 Yocto
    来帮助我们。接下来将解释的两个工作流都使用了 Yocto 构建系统。
- en: Working directory development
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: In this workflow, we use the working directory inside the `build` directory,
    `tmp/work`. As we know, when Yocto builds a package, it uses the working directory
    to extract, patch, configure, build, and package the source. We can directly modify
    the source in this directory and use the Yocto system to build it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作流中，我们使用 `build` 目录中的工作目录，`tmp/work`。正如我们所知，当 Yocto 构建一个包时，它使用工作目录来提取、修补、配置、构建和打包源代码。我们可以直接在这个目录中修改源代码，并使用
    Yocto 系统来构建它。
- en: This methodology is commonly used when sporadically debugging third-party packages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常用于偶尔调试第三方包时。
- en: 'The workflow is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流如下：
- en: 'Remove the package''s `build` directory to start from scratch:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除包的 `build` 目录以从头开始：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Tell BitBake to fetch, unpack, and patch the package, but stop there:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 BitBake 获取、解压并修补包，但在此停止：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Enter the package's source directory and modify the source. Usually, we would
    create a temporary local Git directory to help us with our development and to
    extract the patches easily.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入包的源代码目录并修改源代码。通常，我们会创建一个临时的本地 Git 目录来帮助我们开发，并轻松提取补丁。
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Build it without losing our changes:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不丢失我们修改的情况下构建它：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note the capital `C`. This instructs BitBake to run the compile task and all
    the tasks that follow it. This is the same as running:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意大写的`C`。这指示 BitBake 执行编译任务以及后续的所有任务。这与运行以下命令是一样的：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Test it by copying the package to a running system and installing it with the
    target''s package management system. When you run your system from an NFS root
    filesystem, it''s as easy as to copy it there and run the following command (assuming
    the default RPM package format):'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将包复制到运行中的系统并使用目标的包管理系统安装来测试它。当你从 NFS 根文件系统运行系统时，只需将它复制到那里并运行以下命令（假设使用默认的 RPM
    包格式）：
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Optionally, you can also use a package feed as we saw in the *Setting up a
    package feed* recipe in [Chapter 1](ch01.html "Chapter 1. The Build System"),
    *The Build System*, in which case you would rebuild the index with the following:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选地，你也可以像在 [第 1 章](ch01.html "第 1 章 构建系统") *构建系统* 中的 *设置包源* 配方中看到的那样使用包源，在这种情况下，你将重新构建索引，命令如下：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And then use the smart package management utility on the target to install the
    package as previously shown.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后使用目标上的智能包管理工具安装包，如之前所示。
- en: Extract the patches and add them to the recipe's `bbappend` file.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取补丁并将其添加到配方的 `bbappend` 文件中。
- en: External source development
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部源代码开发
- en: In this workflow, we will use the Yocto build system to build an external directory
    containing the source. This external directory is usually source controlled to
    help us in our development.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种工作流程中，我们将使用Yocto构建系统来构建包含源码的外部目录。这个外部目录通常是受版本控制的，以帮助我们进行开发。
- en: This is the usual methodology to follow for extensive package development once
    the source has already been integrated with the Yocto build system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在源码已经与Yocto构建系统集成后进行广泛包开发的常用方法。
- en: 'The workflow is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程如下：
- en: We perform our development on this external-version-controlled directory and
    commit our changes locally.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个外部版本控制的目录上进行开发，并在本地提交我们的更改。
- en: We configure the Yocto build system to use a directory in our host system to
    fetch the source from, and optionally also to build in. This guarantees that our
    changes cannot be lost by any action of the Yocto build system. We will see some
    examples of this later on.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们配置Yocto构建系统，以使用主机系统中的一个目录来获取源码，并可选择在其中构建。这保证了我们的任何操作都不会使Yocto构建系统中的更改丢失。稍后我们将看到一些例子。
- en: 'Build it using Yocto:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Yocto构建它：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Test it by copying the package to a running system and installing it with the
    target's package management system.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将包复制到运行中的系统并使用目标的软件包管理系统进行安装来进行测试。
- en: Extract the patches and add them to the recipe's `bbappend` file.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取补丁并添加到配方的`bbappend`文件中。
- en: Adding a custom kernel and bootloader
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义内核和引导程序
- en: Development in U-Boot and the Linux kernel is usually done externally to Yocto,
    as they are easy to build using a toolchain, like the one provided by Yocto.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在U-Boot和Linux内核中的开发通常是在Yocto之外进行的，因为它们很容易使用工具链进行构建，比如Yocto提供的工具链。
- en: 'The development work is then integrated into Yocto in one of two ways:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将开发工作集成到Yocto中的一种方法：
- en: With patches added to the kernel and U-Boot `bbappend` files. This method will
    build the same source as the reference design board we are using as base, and
    apply our changes over it.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用添加到内核和U-Boot `bbappend`文件的补丁。这种方法将构建与我们正在使用的基础参考设计板相同的源，并对其应用我们的更改。
- en: Using a different Git repository, forked from the Linux kernel and U-Boot Git
    repositories being used by the reference design, and using a `bbappend` file to
    point the recipe to it. This way, we can directly commit the changes to the repository
    and the Yocto build system will build them.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的Git存储库，从Linux内核和U-Boot Git存储库分叉，并使用`bbappend`文件将配方指向它。这样，我们可以直接提交更改到存储库，而Yocto构建系统将会构建它们。
- en: Usually a forked Git repository is only needed when the hardware changes are
    substantial and the work in the Linux kernel and bootloader is going to be extensive.
    The recommendation is to start with patches, and only use a forked repository
    when they become difficult to manage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只有在硬件更改非常重大并且Linux内核和引导加载程序的工作将非常广泛时，才需要分叉Git存储库。建议的做法是从补丁开始，只有当它们难以管理时才使用分叉存储库。
- en: Getting Ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The first question when starting work on the Linux kernel and U-Boot modifications
    is how do you find which of the several available recipes are being used for your
    build.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始对Linux内核和U-Boot进行修改的工作时，第一个问题是如何找出哪些可用的配方正在为您的构建使用。
- en: Finding the Linux kernel source
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 找到Linux内核源码
- en: 'To find the Linux kernel source, we might use several methods. As we are aware
    we are building for a `wandboard-quad` machine, the first thing to do is find
    a machine configuration file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到Linux内核源码，我们可以使用几种方法。因为我们知道正在为`wandboard-quad`机器进行构建，所以要做的第一件事是找到机器配置文件：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The machine configuration file above in turn includes a `wandboard.inc` file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述机器配置文件反过来包括一个`wandboard.inc`文件：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we find a Linux kernel recipe being specified as the preferred provider
    for virtual/kernel. Virtual packages like this are used when a feature or element
    is provided by more than one recipe. It allows us to choose which of all those
    recipes will finally be used. Virtual packages will be further explained in the
    *Selecting a specific package versions and providers* recipe in [Chapter 3](ch03.html
    "Chapter 3. The Software Layer"), *The Software Layer*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发现一个Linux内核配方被指定为虚拟/kernel的首选提供者。像这样的虚拟包在一个功能或元素由多个配方提供时使用。这允许我们选择最终使用的所有配方中的哪一个。关于*选择特定软件版本和提供者*配方的详细解释将在[第3章](ch03.html
    "第3章。软件层")的*软件层*中进一步说明。
- en: 'We could check the actual output from our previous `core-image-minimal` build:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查之前`core-image-minimal`构建的实际输出：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As the `linux-wanboard` directory exists in our `work` folder, we can be sure
    the recipe has been used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check what the available Linux recipes are with:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have lots of options, but we can use some of our acquired knowledge to filter
    them out. Let''s exclude the `poky` and `meta-openembedded` directories, as we
    know the BSP support is included in the Freescale community BSP layers:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we can also use the `bitbake-layers` script included in Poky:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Not all those kernels support the Wandboard machine completely, but they all
    support Freescale ARM machines, so they are useful for comparisons.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Finding the U-Boot source
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we continue to pull the include chain, we have `imx-base.inc`, which itself
    includes `fsl-default-providers.inc`, where we find:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So `u-boot-fslc` is the U-Boot recipe we are looking for.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Developing using a Git repository fork
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will show how to append a recipe to use a forked repository to work from
    it. We will use the Linux kernel as an example, but the concept works just as
    well for U-Boot or any other package, although the specifics will change.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We will fork or branch the repository used in the reference design and use it
    to specify `SRC_URI` for the recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this example, I have forked the repository to [https://github.com/yoctocookbook/linux](https://github.com/yoctocookbook/linux),
    so my `recipes-kernel/linux/linux-wandboard_3.10.17.bbappend` file would have
    the following changes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note how the URL needs to start with `git://`. This is so that BitBake can recognize
    it as a Git source. Now we can clean and build the Linux kernel and the source
    will be fetched from the forked repository.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `linux-wandboard_3.10.17.bb` recipe:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first interesting thing is the inclusion of both `linux-wandboard.inc` and
    `linux-dtb.inc`. We will look at the first later on, and the other is a class
    that allows us to compile Linux kernel device trees. We will discuss device trees
    in the *Managing the device tree* recipe later in this chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Then it declares two package dependencies, `lzop-native` and `bc-native`. The
    `native` part tells us that these are used in the host system, so they are used
    during the Linux kernel build process. The `lzop` tool is used to create the `cpio`
    compressed files needed in the `initramfs` system, which is a system that boots
    from a memory-based root filesystem, and `bc` was introduced to avoid a Perl kernel
    dependency when generating certain kernel files.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Then it sets the branch and revision, and finally it sets `COMPATIBLE_MACHINE`
    to `wandboard`. We will speak about machine compatibility in the *Adding new packages*
    recipe of [Chapter 3](ch03.html "Chapter 3. The Software Layer"), *The Software
    Layer*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now have a look at the `linux-wandboard.inc` include file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is actually the file we were looking for. Initially, it specifies the license
    for the kernel source and points to it, sets a default branch and local version
    kernel string, and sets up the `SCR_URI` variable, which is the place where the
    source code is fetched from.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: It then offers the `WANDBOARD_GITHUB_MIRROR` variable, which we can modify in
    our `bbappend` file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: So the logical setup would be to create a GitHub account and fork the provided
    `wandboard-org` Linux repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Once the fork is in place, we need to modify the `WANDBOARD_GITHUB_MIRROR` variable.
    But as we saw before, the recipe configures a specific revision and branch. We
    want to develop here, so we want to change this to a new development branch we
    have created. Let's call it `wandboard_imx_3.10.17_1.0.2_ga-dev` and set the revision
    to automatically fetch the newest point in the branch.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Building the U-Boot bootloader
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will go through the several development workflows described
    previously using the U-Boot bootloader as an example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how the following development workflows are applied to U-Boot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: External development
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External source development
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working directory development
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explain the three workflows, previously mentioned, in detail.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: External development
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use a Yocto toolchain to build the U-Boot source externally from the
    Yocto build system.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install a Yocto project cross-compilation toolchain for your host
    by going to the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/)'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose either the 32- or 64-bit version and execute the installation script,
    accepting the default installation location. It is recommended not to change the
    default location to avoid relocation issues.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Find the upstream Git repository:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Clone the U-Boot''s source from its upstream repository:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The default branch should be `patches-2014.10`, but if it''s not, you can change
    it with the following:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set up the environment using the script provided with the toolchain:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Configure U-Boot for `wandboard-quad`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you try to build U-Boot, it will fail. This is because the default Yocto
    environment setup does not cater to U-Boot''s needs. A quick look at the U-Boot
    recipe shows that it clears some flags before building, so let''s do that:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we are ready to build. The U-Boot recipe also passes `CC` to the `make`
    utility in the `EXTRA_OEMAKE` flags as U-Boot does not read it from the environment,
    so we also need to run:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can optionally pass a `-jN` argument for multithreaded compilation. Here,
    `N` is the number of CPU cores.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The U-Boot `Makefile` looks for `libgcc` using the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If we don't define `CC`, the expression does not correctly expand to the location
    of the `libgcc` library in the toolchain, as the `sysroot` option is not passed
    to the compiler.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Newer versions of U-Boot have already fixed this issue, but we decided to leave
    the instruction as the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 更新版本的U-Boot已经修复了这个问题，但我们决定将指令保留如下：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That works for older versions of U-Boot too.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于旧版本的U-Boot同样有效。
- en: Another way to avoid the problem would be to define the `USE_PRIVATE_LIBGCC`
    U-Boot configuration variable, but that would use an internal `libgcc` library
    to U-Boot, which may not be what we want.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个避免问题的方法是定义`USE_PRIVATE_LIBGCC` U-Boot配置变量，但这将使用内部的`libgcc`库到U-Boot，这可能不是我们想要的。
- en: We would then need to copy the image to the target to test our changes, as we
    will see soon.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将镜像复制到目标设备以测试我们的更改，这很快就会看到。
- en: External source development
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部源开发
- en: We will use the Yocto build system from a local directory by cloning a local
    copy of the source used in the reference design and configuring our project to
    use it as an external source. We will then develop from it, extract the patches,
    and add them to a `bbappend` file on our BSP layer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个本地目录中使用Yocto构建系统，通过克隆参考设计中使用的源代码的本地副本，并配置我们的项目以使用它作为外部源。然后，我们将从中开发，提取补丁，并将其添加到我们的BSP层中的`bbappend`文件中。
- en: We will use the U-Boot source cloned in the example beforehand.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前克隆的U-Boot源码。
- en: 'To configure our `conf/local.conf` file to work from the cloned source, modify
    it as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的`conf/local.conf`文件以从克隆源码工作，按以下方式修改它：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `EXTERNALSRC` variable defines the source location (`S`), while the `EXTERNALSRC_BUILD`
    variable defines the build location (`B`). This code will also build on the external
    source location as the `u-boot-fslc` recipe does not currently support the separation
    of the source and `build` directories.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXTERNALSRC`变量定义了源代码位置(`S`)，而`EXTERNALSRC_BUILD`变量定义了构建位置(`B`)。这段代码也将在外部源位置上构建，因为`u-boot-fslc`配方目前不支持源代码和构建目录的分离。'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to remove the aforementioned configuration when trying the working
    directory development methodology explained next in this recipe.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在尝试下一个方法时删除前述的配置，该方法在接下来的这个配方中解释了工作目录开发方法。
- en: 'Now we can build on a new shell with:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在新的shell上进行构建：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When building from an external source, the expansion of `SRCPV` fails with
    an error. Recipes need to be temporarily modified to use static versioning while
    the external source compilation is enabled. In the case of U-Boot, we would make
    the following change in the `meta-fsl-arm/recipes-bsp/u-boot/u-boot-fslc_2014.10.bb`
    file:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在从外部源构建时，`SRCPV`的扩展会失败并显示错误。在启用外部源编译时，需要暂时修改配方以使用静态版本控制。对于U-Boot，我们会在`meta-fsl-arm/recipes-bsp/u-boot/u-boot-fslc_2014.10.bb`文件中进行以下更改：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This uses diff formatting, where the lines with a minus prefix are removed and
    the ones with a plus sign are added.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用差异格式，带有减号前缀的行将被删除，带有加号前缀的行将被添加。
- en: An example patch to U-Boot that allows us to perform external source development
    can be found in the source code that accompanies the book.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在附带书籍的源代码中找到一个允许我们执行外部源开发的U-Boot示例补丁。
- en: 'Development work can now be committed in the local Git repository, and patches
    can be generated with `git format-patch`. For example, we could change the board
    information for the Wandboard with the `0001-wandboard-Change-board-info.patch`
    file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 开发工作现在可以提交到本地Git存储库，并可以使用`git format-patch`生成补丁。例如，我们可以为Wandboard更改板信息并创建`0001-wandboard-Change-board-info.patch`文件：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To add this patch to Yocto''s U-Boot recipe, we create a `meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend`
    file with the following content:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此补丁添加到Yocto的U-Boot配方中，我们创建一个`meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend`文件，内容如下：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The patch needs to be placed under `meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/`,
    as specified in the `FILESEXTRAPATHS` variable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁需放置在`meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/`下，正如`FILESEXTRAPATHS`变量中指定的。
- en: Files added to the `SRC_URI` variable that end in the `patch` or `diff` prefixes
    will be applied in the order they are found. You can also force a file to be treated
    as `patch` by specifying an `apply=yes` property to it in `SRC_URI`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 被添加到`SRC_URI`变量的以`patch`或`diff`前缀结尾的文件将按照它们被发现的顺序应用。您也可以通过在`SRC_URI`中指定`apply=yes`属性来强制将文件视为`patch`。
- en: Working directory development
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: 'A typical workflow when working on a small modification would be:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行小修改时的典型工作流程将会是：
- en: 'Start the U-Boot package compilation from scratch:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从头开始编译U-Boot包：
- en: '[PRE46]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will erase the `build` folder, shared state cache, and downloaded package
    source.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start a development shell:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will fetch, unpack, and patch the U-Boot sources and spawn a new shell
    with the environment ready for U-Boot compilation. The new shell will change to
    the U-Boot `build` directory, which contains a local Git repository.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Perform your modifications on the local Git repository.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leave the devshell open and use a different terminal to compile the source
    without erasing our modifications:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the capital `C`. This invokes the compile task but also all the tasks that
    follow it.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The newly compiled U-Boot image is available under `tmp/deploy/images/wandboard-quad`.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Test your changes. Typically, this means that we need to reprogram the bootloader
    into the microSD card (as is the case with the Wandboard) or the internal `emmc`
    (if available) at the correct offset. We can do it both from the target or from
    your host computer.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the host computer, we would use `dd` to copy the new U-Boot image to an
    offset of 0x400, which is where the i.MX6 bootrom expects to find it.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This writes with an offset of 2 blocks, which, given a 512-byte block size,
    is 0x400 (1024) bytes.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when running the `dd` command, as it could harm your machine. You
    need to be absolutely sure that the sdN device corresponds to your microSD card
    and not a drive on your development machine.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From the device itself, we can use U-Boot''s `mmc` command as follows:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Load the U-Boot image to memory:'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The hexadecimal file size of the TFTP transfer is kept in the filesize environment
    variable, which we will use later on.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the MMC device to operate on. You can use the `mmc` part to discover
    which is the correct device.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can see that partition `1` starts at sector `8192`, leaving enough space
    to program U-Boot.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With a 512-byte block size, we calculate the number of blocks as follows:'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We then write to an offset of two blocks with the numbers of blocks occupied
    by our image.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Go back to the devshell and commit your change to the local Git repository.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Generate a patch into the U-Boot recipe patch directory as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finally, add the patch to the U-Boot recipe as explained before.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explaining Yocto's Linux kernel support
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Yocto project offers a kernel framework that allows us to work with the
    Linux kernel in different ways:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the source from a Git repository and applying patches to it. This is
    the path taken by the Freescale community BSP-supported kernels, as we saw previously.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `linux-yocto` style kernels that generate the kernel source from a set of
    Git branches and leafs. Specific features are developed in branches, and a leaf
    is followed for a complete set of features.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will show how to work with a `linux-yocto` style kernel.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use a `linux-yocto` style kernel, the kernel recipe inherits the `linux-yocto.inc`
    file. A Git repository for a `linux-yocto` style kernel contains metadata either
    in the recipe or inside the kernel Git tree, in branches named with the `meta`
    prefix.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The `linux-yocto` style kernel recipes are all named `linux-yocto` and follow
    the upstream kernel development, rooted in the `kernel.org` repository. Once a
    new Yocto release cycle starts, a recent upstream kernel version is chosen, and
    the kernel version from the previous Yocto release is maintained. Older versions
    are updated inline with the **Long Term Support Initiative** (**LTSI**) releases.
    There is also a `linux-yocto-dev` package, which always follows the latest upstream
    kernel development.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Yocto kernels are maintained separately from the upstream kernel sources, and
    add features and BSPs to cater to embedded system developers.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Although the Freescale community BSP does not include `linux-yocto` style kernels,
    some other BSP layers do.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Metadata variables that are used to define the build include:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '`KMACHINE`: This is usually the same as the `MACHINE` variable, but not always.
    It defines the kernel''s machine type.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KBRANCH`: This explicitly sets the kernel branch to build. It is optional.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KBRANCH_DEFAULT`: This is the default value for KBRANCH, initially `master`.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KERNEL_FEATURES`: This adds additional metadata that is used to specify configuration
    and patches. It appears above the defined `KMACHINE` and `KBRANCH`. It is defined
    in **Series Configuration Control** (**SCC**) files as described soon.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LINUX_KERNEL_TYPE`: This defaults to standard, but may also be `tiny` or `preempt-rt`.
    It is defined in its own SCC description files, or explicitly defined using the
    `KTYPE` variable in the SCC files.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The metadata included in the Linux kernel manages the configuration and source
    selection to support multiple BSPs and kernel types. The tools that manage this
    metadata are built in the `kern-tools` package.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The metadata can be set either in recipes, for small changes or if you are
    using a kernel repository you do not have access to, or most usually inside the
    kernel Git repository in `meta` branches. The `meta` branch that is to be used
    defaults to a `meta` directory in the same repository branch as the sources, but
    can be specified using the `KMETA` variable in your kernel recipe. If it does
    not reside in the same branch as the kernel source, it is kept in an orphan branch;
    that is, a branch with its own history. To create an orphan branch, use the following
    commands:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Your recipe must then include `SRCREV_meta` to point to the revision of the
    `meta` branch to use.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The metadata is described in SCC files, which can include a series of commands:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '`kconf`: This command applies a configuration fragment to the kernel configuration.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch`: This command applies the specified patch.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`define`: This introduces the variable definitions.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: This includes another SCC file.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git merge`: This merges the specified branch into the current branch.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`branch`: This creates a new branch relative to the current branch, usually
    `KTYPE` or as specified.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SCC files are broadly divided into the following logical groupings:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**configuration (**`cfg`**)**: This contains one or more kernel configuration
    fragments and an SCC file to describe them. For example:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**patches**: This contains one or more kernel patches and an SCC file to describe
    them. For example:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**features**: This contains mix configurations and patches to define complex
    features. It can also include other description files. For example:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**kernel types**: This contains features that define a high-level kernel policy.
    By default, three kernel types are defined in SCC files:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**standard**: This is a generic kernel definition policy'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tiny**: This is a bare minimum kernel definition policy and is independent
    of the standard type'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**preempt-rt**: This inherits from the standard type to define a real-time
    kernel where the `PREEMTP-RT` patches are applied'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other kernel types can be defined by using the `KTYPE` variable on an SCC file.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Board Support Packages** (**BSP**): A combination of kernel types and hardware
    features. BSP types should include KMACHINE for the kernel machine and KARCH for
    the kernel architecture.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detailed information regarding `linux-yocto` style kernels can be found in the
    *Yocto Project Linux Kernel Development Manual* at [http://www.yoctoproject.org/docs/1.7.1/kernel-dev/kernel-dev.html](http://www.yoctoproject.org/docs/1.7.1/kernel-dev/kernel-dev.html)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing Linux's build system
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel is a monolithic kernel and as such shares the same address
    space. Although it has the ability to load modules at runtime, the kernel must
    contain all the symbols the module uses at compilation time. Once the module is
    loaded, it will share the kernel's address space.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The kernel build system, or **kbuild**, uses conditional compilation to decide
    which parts of the kernel are compiled. The kernel build system is independent
    of the Yocto build system.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explain how the kernel's build system works.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kernel configuration is stored in a `.config` text file in the kernel root
    directory. The kbuild system reads this configuration to build the kernel. The
    `.config` file is referred to as the kernel configuration file. There are multiple
    ways to define a kernel configuration file:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Manually editing the `.config` file, although this is not recommended.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using one of the user interfaces the kernel offers (type the make help command
    for other options):'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`menuconfig`: An ncurses menu-based interface (`make menuconfig`)'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xconfig`: A Qt-based interface (`make xconfig`)'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gconfig`: A GTK-based interface (`make gconfig`)'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that to build and use these interfaces, your Linux host needs to have the
    appropriate dependencies.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Automatically via a build system such as Yocto.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each machine also defines a default configuration in the kernel tree. For ARM
    platforms, these are stored in the `arch/arm/configs` directory. To configure
    an ARM kernel, that is, to produce a `.config` file from a default configuration,
    you run:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For example we can build a default configuration for Freescale i.MX6 processors
    by running:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kbuild uses `Makefile` and `Kconfig` files to build the kernel source. Kconfig
    files define configuration symbols and attributes, and `Makefile` file match configuration
    symbols to source files.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'The kbuild system options and targets can be seen by running:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There's more...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In recent kernels, a default configuration contains all the information needed
    to expand to a full configuration file. It is a minimal kernel configuration file
    where all dependencies are removed. To create a default configuration file from
    a current `.config` file, you run:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This creates a `defconfig` file in the current kernel directory. This `make`
    target can be seen as the opposite of the `<platform>_defconfig` target explained
    before. The former creates a configuration file from a minimal configuration,
    and the other expands the minimal configuration into a full configuration file.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Linux kernel
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explain how to configure a Linux kernel using the Yocto
    build system.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before configuring the kernel, we need to provide a default configuration for
    our machine, which is the one the Yocto project uses to configure a kernel. When
    defining a new machine in your BSP layer, you need to provide a `defconfig` file.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The Wandboard's `defconfig` file is stored under `sources/meta-fsl-arm-extra/recipes-kernel/linux/linux-wandboard-3.10.17/defconfig`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'This would be the base `defconfig` file for our custom hardware, so we copy
    it to our BSP layer:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We then add it to our kernel using `meta-bsp-custom/recipes-kernel/linux/linux-wandboard_3.10.17.bbappend`
    as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Kernel configuration changes to your platform can be made directly in this `defconfig`
    file.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a `.config` file from the machine `defconfig` file, execute the following
    command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This will also run the oldconfig kernel `make` target to validate the configuration
    against the Linux source.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then configure the Linux kernel from the BitBake command line using
    the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The menuconfig user interface, as well as other kernel configuration user interfaces,
    has a search functionality that allows you to locate configuration variables by
    name. Have a look at the following screenshot:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_02_01.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following chapters, we will mention specific kernel configuration variables,
    like `CONFIG_PRINTK`, without specifying the whole path to the configuration variable.
    The search interface of the different UIs can be used to locate the configuration
    variable path.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'When you save your changes, a new `.config` file is created on the kernel''s
    `build` directory, which you can find using the following command:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You can also modify the configuration using a graphical UI, but not from the
    BitBake command line. This is because graphical UIs need host dependencies, which
    are not natively built by Yocto.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure your Ubuntu system has the needed dependencies, execute the following
    command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then change to the kernel `build` directory, which you found before, with:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, run the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you encounter compilation errors, attempt to run from a new terminal that
    has not had the environment configured with the `setup-environment` script.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'A new window will open with the graphical configuration user interface shown
    in the next screenshot:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_02_02.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: When you save your changes, the `.config` file will be updated.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: To use an updated configuration, you need to take care that BitBake does not
    revert your changes when building. Refer to the *Building the Linux kernel* recipe
    in this chapter for additional details.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can make your kernel changes permanent with the following steps:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a default configuration from your `.config` file from the kernel source
    directory and a clean environment (not configured with the `setup-environment`
    script) by running:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Copy the `defconfig` file from your kernel `build` folder to your kernel recipe''s
    `defconfig` file as follows:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Alternatively, you may use BitBake from the `build` directory as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This also creates a `defconfig` file in the Linux kernel's source directory,
    which needs to be copied to your recipe.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Using configuration fragments
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `linux-yocto` style kernels can also apply isolated kernel configuration
    changes defined in the kernel configuration fragments; for example:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Kernel configuration fragments are appended to `SRC_URI` in the same way, and
    are applied over the `defconfig` file.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'The `linux-yocto` style kernels (not the one for the Wandboard though) also
    provide a set of tools to manage kernel configuration:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the kernel from the `defconfig` file and the supplied configuration
    fragments, execute:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To create a configuration fragment with your changes, execute:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To validate the kernel configuration, you may run:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Building the Linux kernel
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will go through the development workflows described earlier
    using the Linux kernel as an example.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how the following development workflows are applied to the Linux
    kernel:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: External development
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working directory development
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External source development
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explain the three methodologies listed previously in detail.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: External development
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When compiling outside of the Yocto build environment, we can still use the
    Yocto-provided toolchain to build. The process is as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Yocto project cross-compilation toolchain already installed
    in your host.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the `wandboard-org linux-wandboard` repository locally:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Go to the branch specified in the `linux-wandboard_3.10.17.bb` recipe:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Compile the kernel source as follows:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Prepare the environment as follows:'
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Configure the kernel with the default machine configuration:'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Compile the kernel image, modules, and the device tree file with:'
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You can optionally pass a `-jN` argument to make to build multithreaded.
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This will build the kernel's zImage, modules, and device tree files.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Older Yocto environment setup scripts set the `LD` variable to use `gcc`, but
    the Linux kernel uses `ld` instead. If your compilation is failing, try the following
    before running `make`:'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To build only modules, you may run:'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And to build only device tree files, you may run:'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Copy the kernel image and device tree file to the TFTP root to test using network
    booting:'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Some other embedded Linux targets might need to compile a uImage if the U-Boot
    bootloader is not compiled with zImage booting support:'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mkimage` tool is part of the Yocto toolchain when built with the FSL community
    BSP. We will see how to build and install an SDK in the *Preparing and using an
    SDK* recipe in [Chapter 4](ch04.html "Chapter 4. Application Development"), *Application
    Development*.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If it is not included in your toolchain, you can install the tool in your host
    using the following command:'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`LOADADDR` is the U-Boot entry point; that is, the address where U-Boot will
    place the kernel in memory. It is defined in the `meta-fsl-arm imx-base.inc` file:'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: External source development
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we did with U-Boot before, we will use the Yocto build system, pointing it
    to a local directory with a clone of the Linux source repository. We will use
    the local Git repository cloned in the earlier section.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'We configure for external development in our `conf/local.conf` file using the
    following code:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Tip
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to remove this configuration when using the working directory development
    methodology explained next in this recipe.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: But, just as before, the compilation fails with U-Boot. In this case, the linux-wandboard
    recipe, not being a `linux-yocto` style recipe, is not prepared for external source
    compilation and it fails in the configuration task.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Kernel developers prefer to compile the kernel externally as we saw earlier,
    so this scenario is not likely to be fixed soon.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Working directory development
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically we work with patches and use this development workflow when we have
    a small amount of changes or we don't own the source repository.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical workflow when working on a modification would be:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the kernel package compilation from scratch:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This will erase the `build` folder, shared state cache, and downloaded package
    source.
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Configure the kernel as follows:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This will convert the machine `defconfig` file into a `.config` file and call
    `oldconfig` to validate the configuration with the kernel source.
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can optionally add your own configuration changes with:'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Start a development shell on the kernel:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This will fetch, unpack, and patch the kernel sources and spawn a new shell
    with the environment ready for kernel compilation. The new shell will change to
    the kernel `build` directory which contains a local Git repository.
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Perform our modifications, including kernel configuration changes.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leave the devshell open and go back to the terminal with the sourced Yocto
    environment to compile the source without erasing our modifications as follows:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note the capital `C`. This invokes the compile task but also all the tasks that
    follow it.
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The newly compiled kernel image is available under `tmp/deploy/images/wandboard-quad`.
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test your changes. Typically, we would work from a network-booted system, so
    we would copy the kernel image and the device tree file to the TFTP server root
    and boot the target with them using the following command:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Refer to the *Configuring network booting for a development setup* recipe in
    [Chapter 1](ch01.html "Chapter 1. The Build System"), *The Build System* for details.
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alternatively, the U-Boot bootloader can boot a Linux zImage kernel from memory
    with its corresponding device tree using the following syntax:'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'For example, we can fetch images from TFTP and boot the Wandboard images as
    follows:'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: If we were using an initramdisk, we would pass it as the second argument. Since
    we aren't, we use a dash instead.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The command to boot a uImage Linux kernel image from memory would use `bootm`
    instead, as in:'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Go back to the devshell and commit your change to the local Git repository:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Generate a patch into the kernel recipe patch directory:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Finally, add the patch to the kernel recipe as previously described.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building external kernel modules
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel has the ability to load modules at runtime that extend the
    kernel functionality. Kernel modules share the kernel's address space and have
    to be linked against the kernel they are going to be loaded onto. Most device
    drivers in the Linux kernel can either be compiled into the kernel itself (built-in)
    or as loadable kernel modules that need to be placed in the root filesystem under
    the `/lib/modules` directory.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: The recommended approach to develop and distribute a kernel module is to do
    it with the kernel source. A module in the kernel tree uses the kernel's kbuild
    system to build itself, so as long as it is selected as module in the kernel configuration
    and the kernel has module support enabled, Yocto will build it.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: However, it is not always possible to develop a module in the kernel. Common
    examples are hardware manufacturers who provide Linux drivers for a wide variety
    of kernel versions and have an internal development process separated from the
    kernel community. The internal development work is usually released first as an
    external out-of-tree module, although it is common for some or all of these internal
    developments to finish up in the mainstream kernel eventually. However, upstreaming
    is a slow process and hardware companies will therefore prefer to develop internally
    first.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: It's worth remembering that the Linux kernel is covered under a GPLv2 license,
    so Linux kernel modules should be released with a compatible license. We will
    cover licenses in more detail in the following chapters.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compile an external kernel module with Yocto, we first need to know how
    we would link the module source with the kernel itself. An external kernel module
    is also built using the kbuild system of the Linux kernel it is going to be linked
    against, so the first thing we need is a `Makefile`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The `Makefile` file just wraps the `make` command used to compile a module
    on a Linux system:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Here, `make` is instructed to build in the location of the kernel source, and
    the `M` argument tells kbuild it is building a module at the specified location.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'And then we code the source of the module itself (`hello_world.c`):'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'It''s worth remembering that we need to compile against a kernel source that
    has already been built. Use the following steps for compilation:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'We prepare the environment using the Yocto toolchain environment setup script:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Next we build the module. We execute the following from the module source directory:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: How to do it...
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we know how to compile the module externally, we are ready to prepare a
    Linux kernel module Yocto recipe for it.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'We place the module source file and `Makefile` in `recipes-kernel/hello-world/files/`
    inside our `meta-bsp-custom` layer. We then create a `recipes-kernel/hello-world/hello-world.bb`
    file with the following content:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The recipe defines the source directory and the two module files after inheriting
    the `module` class, which takes care of everything. The `KERNEL_SRC` argument
    in our `Makefile` is set by the module class to `STAGING_KERNEL_DIR`, the location
    where the kernel class places the Linux kernel headers needed for external module
    compilation.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'We build it with the following command:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The resulting module is called `hello_world.ko`, with the `kernel-module` prefix
    being added to the package name by the module `bbclass` automatically.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous instructions will build the module but will not install it in the
    root filesystem. For that, we need to add a dependency to the root filesystem.
    This is usually done in machine configuration files using `MACHINE_ESSENTIAL`
    (for modules that are needed to boot) or `MACHINE_EXTRA` (if they are not essential
    for boot but needed otherwise), variables.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependencies that are essential to boot are:'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MACHINE_ESSENTIAL_EXTRA_RDEPENDS`: The build will fail if they can''t be found'
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS`: The build will not fail if they can''t
    be found'
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The dependencies that are not essential to boot are:'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MACHINE_EXTRA_RDEPENDS`: The build will fail if they can''t be found'
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS`: The build will not fail if they can''t
    be found'
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the Linux kernel and modules
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will highlight some of the most common methods employed by kernel developers
    to debug kernel issues.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Above all, debugging the Linux kernel remains a manual process, and the most
    important developer tool is the ability to print debug messages.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: The kernel uses the `printk` function, which is very similar syntactically to
    the `printf` function call from standard C libraries, with the addition of an
    optional log level. The allowed formats are documented in the kernel source under
    `Documentation/printk-formats.txt`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: The `printk` functionality needs to be compiled into the kernel with the `CONFIG_PRINTK`
    configuration variable. You can also configure the Linux kernel to prepend a precise
    timestamp to every message with the `CONFIG_PRINTK_TIME` configuration variable,
    or even better, with the `printk.time` kernel command-line argument or through
    sysfs under `/sys/module/printk/parameters`. Usually all kernels contain `printk`
    support, and the Wandboard kernel does too, although it is commonly removed on
    production kernels for small embedded systems.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: The `printk` function can be used in any context, interrupt, **non-maskable
    interrupt** (**NMI**), or scheduler. Note that using it inside interrupt context
    is not recommended.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful debug statement to be used during development could be:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The first thing to note is that there is no comma between the log level macro
    and the print format. We then print the function and line where the debug statement
    is placed and then the parent function. Finally, we print the variables we are
    actually interested in.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The available log levels in `printk` are presented in the following table:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Symbol | Description |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
- en: '| Emergency | `KERN_EMERG` | System is unstable and about to crash |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
- en: '| Alert | `KERN_ALERT` | Immediate action is needed |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
- en: '| Critical | `KERN_CRIT` | Critical software or hardware failure |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
- en: '| Error | `KERN_ERR` | Error condition |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
- en: '| Warning | `KERN_WARNING` | Nothing serious, but might indicate a problem
    |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
- en: '| Notice | `KERN_NOTICE` | Nothing serious, but user should take note |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
- en: '| Information | `KERN_INFO` | System information |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
- en: '| Debug | `KERN_DEBUG` | Debug messages |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
- en: If no log level is specified, the default log message as configured in the kernel
    configuration is used. By default, this is `KERN_WARNING`.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: All `printk` statements go to the kernel log buffer, which may wrap around,
    except debug statements, which only appear if the `DEBUG` symbol is defined. We
    will see how to enable kernel debug messages soon. The `printk` log buffer must
    be a power of two, and its size should be set in the `CONFIG_LOG_BUF_SHIFT` kernel
    configuration variable. You may modify it with the `log_buf_len` kernel command-line
    parameter.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: We print the kernel log buffer with the `dmesg` command. Also, a Yocto user
    space will have a kernel log daemon running that will log kernel messages to disk
    under `/var/log/messages`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Messages above the current console log level will also appear on the console
    immediately. The `ignore_loglevel` kernel command-line argument, also available
    under `/sys/module/printk/parameters`, may be used to print all kernel messages
    to the console independently of the log level.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also change the log level at runtime via the `proc` filesystem. The
    `/proc/sys/kernel/printk` file contains the current, default, minimum, and boot
    time default log levels. To change the current log level to the maximum, execute:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'You can also set the console log level with the `dmesg` tool as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: To make the change persistent, you can pass a log level command-line parameter
    to the kernel, or on some Yocto root filesystem images, you could also use a `/etc/sysctl.conf`
    file (those that install the `procps` package).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux drivers do not use the `printk` function directly. They use, in order
    of preference, subsystem-specific messages (such as `netdev` or `v4l)` or the
    `dev_*` and `pr_*` family of functions. The latter are described in the following
    table:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '| Device message | Generic message | Printk symbol |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
- en: '| `dev_emerg` | `pr_emerg` | `KERN_EMERG` |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
- en: '| `dev_alert` | `pr_alert` | `KERN_ALERT` |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
- en: '| `dev_crit` | `pr_crit` | `KERN_CRIT` |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
- en: '| `dev_err` | `pr_err` | `KERN_ERR` |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
- en: '| `dev_warn` | `pr_warn` | `KERN_WARNING` |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
- en: '| `dev_notice` | `pr_notice` | `KERN_NOTICE` |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
- en: '| `dev_info` | `pr_info` | `KERN_INFO` |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
- en: '| `dev_dbg` | `pr_debug` | `KERN_DEBUG` |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
- en: 'To enable the debug messages within a driver, you may do either of these:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'Define `DEBUG` in a macro before any other header file in your driver source,
    as follows:'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Use the dynamic debug kernel feature. You can then enable/disable all `dev_dbg`
    and `pr_debug` debug messages with granularity through `debugfs`.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dynamic debug
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use the dynamic debug functionality in the Linux kernel, follow these steps:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your kernel is compiled with dynamic debugging (`CONFIG_DYNAMIC_DEBUG`).
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mount the debug filesystem if it hasn''t already been mounted:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Configure the debug though the `dynamic_debug/control` folder. It accepts a
    whitespace-separated sequence of words:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`func <function name>`'
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file <filename>`'
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module <module name>`'
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format <pattern>`'
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`line <line or line range>`'
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+ <flag>`: This adds the specified flag'
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- <flag>`: This one removes the specified flag'
  id: totrans-575
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`= <flag>`: This sets the specified flag'
  id: totrans-576
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flags are defined as follows:'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`f`: This flag includes the function name in the message'
  id: totrans-578
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l`: This flag includes the line number in the message'
  id: totrans-579
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: This flag includes the module name in the message'
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p`: This flag enables the debug message'
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t`: This flag includes the thread ID in non-interrupt context messages'
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By default all debug messages are disabled. The control file contains all the
    available debug points, and by default they have no flags enabled (marked as `=`_).
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we will enable the debug as follows:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable all debug statements in a file:'
  id: totrans-585
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Optionally, you could run a specific debug statement:'
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-588
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To list all enabled debug statements, we use the following command:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: To make the debug changes persistent, we can pass `dyndbg="<query>"` or `module.dyndbg="<query>"`
    to the kernel in the command-line arguments.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Note that the query string needs to be passed surrounded by quotes so that it
    is correctly parsed. You can concatenate more than one query in the command-line
    argument by using a semicolon to separate them; for example, `dyndbg="file mxc_v4l2_capture.c
    +pfl; file ipu_bg_overlay_sdc.c +pfl"`
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Rate-limiting debug messages
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are rate-limiting and one-shot extensions to the `dev_*`, `pr_*`, and
    `printk` family of functions:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '`printk_ratelimited()`, `pr_*_ratelimited()`, and `dev_*_ratelimited()` print
    no more than 10 times in a 5 * HZ interval'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printk_once()`, `pr_*_once()`, and `dev_*_once()` will print only once.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And you also have utility functions to dump a buffer in hexadecimal; for example,
    `print_hex_dump_bytes()`.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dynamic debug is documented in the Linux kernel source under `Documentation/dynamic-debug-howto.txt`
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the Linux kernel booting process
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the most general techniques for debugging the Linux kernel. However,
    some special scenarios require the use of different methods. One of the most common
    scenarios in embedded Linux development is the debugging of the booting process.
    This recipe will explain some of the techniques used to debug the kernel's booting
    process.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A kernel crashing on boot usually provides no output whatsoever on the console.
    As daunting as that may seem, there are techniques we can use to extract debug
    information. Early crashes usually happen before the serial console has been initialized,
    so even if there were log messages, we would not see them. The first thing we
    will show is how to enable early log messages that do not need the serial driver.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: In case that is not enough, we will also show techniques to access the log buffer
    in memory.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging booting problems have two distinctive phases, before and after the
    serial console is initialized. After the serial is initialized and we can see
    serial output from the kernel, debugging can use the techniques described earlier.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Before the serial is initialized, however, there is a basic **UART** support
    in ARM kernels that allows you to use the serial from early boot. This support
    is compiled in with the `CONFIG_DEBUG_LL` configuration variable.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: This adds supports for a debug-only series of assembly functions that allow
    you to output data to a UART. The low-level support is platform specific, and
    for the i.MX6, it can be found under `arch/arm/include/debug/imx.S`. The code
    allows for this low-level UART to be configured through the `CONFIG_DEBUG_IMX_UART_PORT`
    configuration variable.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this support directly by using the `printascii` function as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'However, much more preferred would be to use the `early_print` function, which
    makes use of the function explained previously and accepts formatted input in
    `printf` style; for example:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Dumping the kernel's printk buffer from the bootloader
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another useful technique to debug Linux kernel crashes at boot is to analyze
    the kernel log after the crash. This is only possible if the RAM memory is persistent
    across reboots and does not get initialized by the bootloader.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: As U-Boot keeps the memory intact, we can use this method to peek at the kernel
    login memory in search of clues.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the kernel source, we can see how the log ring buffer is set up in
    `kernel/printk/printk.c` and also note that it is stored in `__log_buf`.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the location of the kernel buffer, we will use the `System.map` file
    created by the Linux build process, which maps symbols with virtual addresses
    using the following command:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To convert the virtual address to physical address, we look at how `__virt_to_phys()`
    is defined for ARM:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `PAGE_OFFSET` variable is defined in the kernel configuration as:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Some of the ARM platforms, like the i.MX6, will dynamically patch the `__virt_to_phys()`
    translation at runtime, so `PHYS_OFFSET` will depend on where the kernel is loaded
    into memory. As this can vary, the calculation we just saw is platform specific.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: For the Wandboard, the physical address for 0x80f450c0 is 0x10f450c0.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then force a reboot using a magic *SysRq* key, which needs to be enabled
    in the kernel configuration with `CONFIG_MAGIC_SYSRQ`, but is enabled in the Wandboard
    by default:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We then dump that memory address from U-Boot as follows:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: There's more...
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another method is to store the kernel log messages and kernel panics or oops
    into persistent storage. The Linux kernel's persistent store support (`CONFIG_PSTORE`)
    allows you to log in to the persistent memory kept across reboots.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: To log panic and oops messages into persistent memory, we need to configure
    the kernel with the `CONFIG_PSTORE_RAM` configuration variable, and to log kernel
    messages, we need to configure the kernel with `CONFIG_PSTORE_CONSOLE`.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to configure the location of the persistent storage on an unused
    memory location, but keep the last 1 MB of memory free. For example, we could
    pass the following kernel command-line arguments to reserve a 128 KB region starting
    at 0x30000000:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We would then mount the persistent storage by adding it to `/etc/fstab` so
    that it is available on the next boot as well:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We then mount it as follows:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Next, we force a reboot with the magic *SysRq* key:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'On reboot, we will see a file inside `/pstore`:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'This will have contents such as the following:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We should move it out of `/pstore` or remove it completely so that it doesn't
    occupy memory.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: Using the kernel function tracing system
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recent versions of the Linux kernel contain a set of tracers that, by instrumenting
    the kernel, allow you to analyze different areas like:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt latency
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preemption latency
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling latency
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process context switches
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event tracing
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syscalls
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum stack
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block layer
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tracers have no performance overhead when not enabled.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tracing system can be used in a wide variety of debugging scenarios, but
    one of the most common tracers used is the function tracer. It instruments every
    kernel function with a NOP call that is replaced and used to trace the kernel
    functions when a trace point is enabled.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: To enable the function tracer in the kernel, use the `CONFIG_FUNCTION_TRACER`
    and `CONFIG_FUNCTION_GRAPH_TRACER` configuration variables.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel tracing system is controlled via a `tracing` file in the `debug`
    filesystem, which is mounted by default on Yocto''s default images. If not, you
    can mount it with:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We can list the available tracers in our kernel by executing:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: How to do it...
  id: totrans-664
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can enable a tracer by echoing its name to the `current_tracer` file. No
    tracers are enabled by default:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'You can disable all tracers by executing the following command:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We use `echo -n` to avoid the trailing newline when echoing to files in `sysfs`.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the function tracer, you would execute:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'A prettier graph can be obtained by using the function graph tracer as follows:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: How it works...
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can look at the captured trace in human-readable format via the `trace`
    and `trace_pipe` files, with the latter blocking on `read` and consuming the data.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: 'The function tracer provides the following output:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The format for the function tracer output is:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The graphical function tracer output is as follows:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The format for the grapical function tracer output is:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: There's more...
  id: totrans-684
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The kernel tracing system allows us to insert traces in the code by using the
    `trace_printk` function call. It has the same syntax as `printk` and can be used
    in the same scenarios, interrupts, NMI, or scheduler contexts.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: Its advantage is that as it prints to the tracing buffer in memory and not to
    the console, it has much lower delays than `printk`, so it is useful to debug
    scenarios where `printk` is affecting the system's behavior; for example, when
    masking a timing bug.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: 'Tracing is enabled once a tracer is configured, but whether the trace writes
    to the ring buffer or not can be controlled. To disable the writing to the buffer,
    use the following command:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'And to re-enable it, use the following command:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: You can also enable and disable the tracing from kernel space by using the `tracing_on`
    and `tracing_off` functions.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: Inserted traces will appear in any tracer, including the `function` tracer,
    in which case it will appear as a comment.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: Filtering function traces
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get finer granularity in the functions being traced by using the dynamic
    tracer, which can be enabled with the `CONFIG_DYNAMIC_FTRACE` configuration variable.
    This is enabled with the tracing functionality by default. This adds two more
    files, `set_ftrace_filter` and `set_ftrace_notrace`. Adding functions to `set_ftrace_filter`
    will trace only those functions, and adding them to `set_ftrace_notrace` will
    not trace them, even if they are also added to `set_ftrace_filter`.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of available function names that can be filtered may be obtained by
    executing the following command:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Functions can be added with:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Note that we use the concatenation operator (`>>`) so that the new function
    is appended to the existing ones.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: 'And functions can also be removed with:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'To remove all functions, just echo a blank line into the file:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'There is a special syntax that adds extra flexibility to the filtering: `<function>:<command>:[<parameter>]`'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain each of the components individually:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '`function`: This specifies the function name. Wildcards are allowed.'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command`: This has the following attributes:'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mod`: This enables the given function name only in the module specified in
    the parameter'
  id: totrans-708
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traceon/traceoff`: This enables or disables tracing when the specified function
    is hit the numbers of times given in the parameter, or always if no parameter
    is given.'
  id: totrans-709
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dump`: Dump the contents of the tracing buffer when the given function is
    hit.'
  id: totrans-710
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Enabling trace options
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Traces have a set of options that can be individually enabled in the `/sys/kernel/debug/tracing/options`
    directory. Some of the most useful options include:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '`print-parent`: This option displays the caller function too'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace_printk`: This option disables `trace_printk` writing'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the function tracer on oops
  id: totrans-717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another alternative to log the kernel messages on oops or panic is to configure
    the function tracer to dump its buffer contents to the console so that the events
    leading up to the crash can be analyzed. Use the following command:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The `sysrq-z` combination will also dump the contents of the tracing buffer
    to the console, as does calling `ftrace_dump()` from the kernel code.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: Getting a stack trace for a given function
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tracing code can create a backtrace for every function called. However,
    this is a dangerous feature and should only be used with a filtered selection
    of functions. Have a look at the following commands:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Configuring the function tracer at boot
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function tracer can be configured in the kernel command-line arguments
    and started as early as possible in the boot process. For example, to configure
    the graphic function tracer and filter some functions, we would pass the following
    arguments from the U-Boot bootloader to the kernel:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: See also
  id: totrans-727
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More details can be found in the kernel source documentation folder at `Documentation/trace/ftrace.txt`
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the device tree
  id: totrans-729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The device tree is a data structure that is passed to the Linux kernel to describe
    the physical devices in a system.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explain how to work with device trees.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Devices that cannot be discovered by the CPU are handled by the platform devices
    API on the Linux kernel. The device tree replaces the legacy platform data where
    hardware characteristics were hardcoded in the kernel source so that platform
    devices can be instantiated. Before device trees came into use, the bootloader
    (for example, U-Boot) had to tell the kernel what machine type it was booting.
    Moreover, it had to pass other information such as memory size and location, kernel
    command line, and more.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: The device tree should not be confused with the Linux kernel configuration.
    The device tree specifies what devices are available and how they are accessed,
    not whether the hardware is used.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: The device tree was first used by the PowerPC architecture and was adopted later
    on by ARM and all others, except x86\. It was defined by the Open Firmware specification,
    which defined the flattened device tree format in **Power.org Standard for Embedded
    Power Architecture Platform Requirements** (**ePAPR**), which describes an interface
    between a boot program and a client.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: Platform customization changes will usually happen in the device tree without
    the need to modify the kernel source.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A device tree is defined in a human-readable device tree syntax (`.dts`) text
    file. Every board has one or several DTS files that correspond to different hardware
    configurations.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 'These DTS files are compiled into **Device Tree Binary** (**DTB**) blobs, which
    have the following properties:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: They are relocatable, so pointers are never used internally
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They allow for dynamic node insertion and removal
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are small in size
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device tree blobs can either be attached to the kernel binary (for legacy compatibility)
    or, as is more commonly done, passed to the kernel by a bootloader like U-Boot.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: To compile them, we use a **Device Tree Compiler** (**DTC**), which is included
    in the kernel source inside `scripts/dtc` and is compiled along with the kernel
    itself, or we could alternatively install it as part of your distribution. It
    is recommended to use the DTC compiler included in the kernel tree.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: The device trees can be compiled independently or with the Linux kernel kbuild
    system, as we saw previously. However, when compiling independently, modern device
    trees will need to be preprocessed by the C preprocessor first.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the DTC currently performs syntax checking but no
    binding checking, so invalid DTS files may be compiled, and the resulting DTB
    file may result in a non-booting kernel. Invalid DTB files usually hang the Linux
    kernel very early on so there will be no serial output.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: The bootloader might also modify the device tree before passing it to the kernel.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-748
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The DTS file for the `wandboard-quad` variant is under `arch/arm/boot/dts/imx6q-wandboard.dts`
    and looks as follows:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'What we see here is the device tree root node that has no parents. The rest
    of the nodes will have a parent. The structure of a node can be represented as
    follows:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The node properties can be:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: Empty
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contain one or more strings
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contain one or more unsigned 32-bit numbers, called **cells**
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contain a binary byte stream
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be a reference to another node, called a **phandle**
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The device tree is initially parsed by the C preprocessor and it can include
    other DTS files. These `include` files have the same syntax and are usually appended
    with the `dtsi` suffix. File inclusion can also be performed with the device tree
    `/include/` operator, although `#include` is recommended, and they should not
    be mixed. In this case, both `imx6q.dtsi` and `imx6qdl-wandboard.dtsi` are overlaid
    with the contents of `imx6q-wandboard.dts`.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: Device tree nodes are documented in bindings contained in the `Documentation/devicetree/bindings/`
    directory of the kernel source. New nodes must include the corresponding bindings,
    and these must be reviewed and accepted by the device tree maintainers. Theoretically,
    all bindings need to be maintained, although it is likely this will be relaxed
    in the future.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: The compatible property
  id: totrans-761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most important property in a device tree node is the `compatible` property.
    In the root node, it defines the machine types the device tree is compatible with.
    The DTS file we just saw is compatible in order of precedence with the `wand,imx6q-wandboard`
    and `fsl,imx6q` machine types.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: 'On a non-root node, it will define the driver match for the device tree node,
    binding a device with the driver. For example, a platform driver that binds with
    a node that defines a property that is compatible with `fsl,imx6q-tempmon` would
    contain the following excerpt:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The Wandboard device tree file
  id: totrans-765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, the first DTSI file to be included is `skeleton.dtsi`, which is the
    minimum device tree needed to boot, once a compatible property is added.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Here are the other common top nodes:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: '**chosen**: This node defines fixed parameters set at boot, such as the Linux
    kernel command line or the `initramfs` memory location. It replaces the information
    traditionally passed in ARM tags (`ATAGS`).'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**memory**: This node is used to define the location and size of RAM. This
    is usually filled in by the bootloader.'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**aliases**: This defines shortcuts to other nodes.'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**address-cells** and **size-cells**: These are used for memory addressability
    and will be discussed later on.'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A summary representation of the `imx6q-wandboard.dts` file showing only the
    selected buses and devices follows:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: On this DTS, we can find several nodes defining **system on chip** (**SoC**)
    buses and several other nodes defining on-board devices.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: Defining buses and memory-addressable devices
  id: totrans-776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Buses are typically defined by the `compatible` property or the `simple-bus`
    property (to define a memory-mapped bus with no specific driver binding) or both.
    The `simple-bus` property is needed so that children nodes to the bus are registered
    as platform devices.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `soc` node is defined as follows:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The properties on the `soc` node are used to specify the memory addressability
    of the children nodes.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '`address-cells`: This property indicates how many base address cells are needed
    in the `reg` property.'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size-cells`: This property indicates how many size cells are needed in the
    `reg` property.'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ranges`: This one describes an address translation between parent and child
    buses. In here, there is no translation and parent and child addressing is identical.'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, any child of `soc` needs to define its memory addressing with
    a `reg` property that contains one cell for the address and one cell for the size.
    The `aips-bus` node does that with the following property:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: There's more...
  id: totrans-786
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the device tree binary blob is loaded in memory by the Linux kernel, it
    is expanded into a flattened device tree that is accessed by offset. The `fdt_*`
    kernel functions are used to access the flattened device tree. This `fdt` is then
    parsed and transformed into a tree memory structure that can be efficiently accessed
    with the `of_*` family of functions (the prefix comes from Open Firmware).
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: Modifying and compiling the device tree in Yocto
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To modify the device tree in the Yocto build system, we execute the following
    set of commands:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We then edit `arch/arm/boot/dts/imx6q-wandboard.dts` and compile the changes
    with:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'If we want to create a device tree with extra space, let''s say 1024 bytes
    (for example, to add nodes dynamically as explained in the next recipe), we need
    to specify it with a DTC flag as follows:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'To deploy it, we exit the devshell and build the kernel from the project''s
    `build` directory:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: See also
  id: totrans-797
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information regarding device trees can be found at [http://www.devicetree.org](http://www.devicetree.org)
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging device tree issues
  id: totrans-799
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show some techniques to debug common problems with the device
    tree.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-801
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, problems with the syntax of device tree files usually result
    in the kernel crashing early in the boot process. Other type of problems are more
    subtle and usually appear once a driver is making use of the information provided
    by the device tree. For both types of problems, it is helpful to be able to look
    not only at the device tree syntax file, but also at the device tree blob, as
    it is read by both U-Boot and the Linux kernel. It may also be helpful to modify
    the device tree on the fly using the tools that U-Boot offers.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-803
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking at the device tree from U-Boot
  id: totrans-804
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The U-Boot bootloader offers the `fdt` command to interact with a device tree
    blob. On the Wandboard''s default environment, there are two variables related
    to the device tree:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '`fdt_file`: This variable contains the name of the device tree file used'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fdt_addr`: This variable contains the location in memory to load the device
    tree'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To fetch the Wandboard''s device tree from the TFTP server location and place
    it in memory, we use the following command:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Once we have the device tree blob in memory, we tell U-Boot where it is located:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'And then we can inspect nodes from the device tree using the full path to them
    from the root node. To inspect the selected levels, we use the `list` command,
    and to print complete subtrees, we use the `print` command:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'U-Boot can also attach new nodes to the tree assuming there is extra space
    in the device tree:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'It can also create or remove properties:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: For example, it can be useful to modify the kernel command line through the
    chosen node.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the device tree from the Linux kernel
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the Linux kernel is booted, it can be useful to expose the device tree
    to user space so that it can be explored. You can do this by configuring the Linux
    kernel with the `CONFIG_PROC_DEVICETREE` configuration variable. The Wandboard
    Linux kernel comes preconfigured to expose the device tree in `/proc/device-tree`
    as follows:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
