<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Troubleshooting Users, Directories, and Files"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Troubleshooting Users, Directories, and Files</h1></div></div></div><p>Unlike the previous subjects discussed so far, the process of troubleshooting users, directories, and files can be seen as a continual process that requires constant attention during the life time of the server. It will become an every day event, and for this reason, we will start with the basic principles of user management with the intention to show you how to restore the default file and folder permissions, recover lost files, and take you on a journey through many more associated themes in order to prepare you for a variety of issues that any professional troubleshooter may encounter.</p><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn how to effectively manage the process of adding, deleting, modifying users, and implementing system-wide changes with <code class="literal">login.defs</code></li><li class="listitem" style="list-style-type: disc">Discover how to monitor user activity with <code class="literal">utmpdump</code></li><li class="listitem" style="list-style-type: disc">Learn how to reset the root password and initiate root-based logging to achieve improved command-line security audits</li><li class="listitem" style="list-style-type: disc">Learn how to recover lost data with Scalpel</li><li class="listitem" style="list-style-type: disc">Learn how to restore default permissions and ownership</li><li class="listitem" style="list-style-type: disc">Discover more about the XFS filesystem by discovering how to run ongoing repairs and investigate defragmentation</li><li class="listitem" style="list-style-type: disc">Learn how to audit directories and files</li><li class="listitem" style="list-style-type: disc">Discover how to visualize directories and files</li></ul></div><div class="section" title="Users"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Users</h1></div></div></div><p>User management <a id="id202" class="indexterm"/>is a fundamental skill associated with the need to manage a server, and in this respect, it will inevitably represent a milestone when troubleshooting any system. So, with this in mind, we will quickly analyze the process of <a id="id203" class="indexterm"/>managing users in order to dispel any confusion.</p><div class="section" title="Adding users and forcing a password change"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec13"/>Adding users and forcing a password change</h2></div></div></div><p>You can <a id="id204" class="indexterm"/>add a new user (and create a home folder for them) by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># adduser &lt;username&gt;</strong></span>
</pre></div><p>You can provide the new user with a password like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># passwd &lt;username&gt;</strong></span>
</pre></div><p>Alternatively, if you would like to force a password reset, thereby implying that a user must reset his/her password, then the following command will suffice:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># chage -d 0 &lt;username&gt;</strong></span>
</pre></div><p>In addition, you<a id="id205" class="indexterm"/> can null a password for a specific user by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># usermod -p "" &lt;username&gt;</strong></span>
</pre></div><p>However, if you would like to grant this new user the ability to use <code class="literal">sudo</code>, then type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># gpasswd -a &lt;username&gt; wheel</strong></span>
</pre></div><p>Finally, if you would like to know more about a user, using the following command, will disclose their current properties:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># id &lt;username&gt;</strong></span>
</pre></div></div><div class="section" title="Deleting users"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec14"/>Deleting users</h2></div></div></div><p>The action of deleting<a id="id206" class="indexterm"/> a user account is generally straightforward, but it can involve a number of stages that can be forgotten. Therefore, to avoid any future issues across extensive systems with a large amount of users, prior to deleting a user from the system, the account should be locked in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># passwd -l &lt;username&gt;</strong></span>
</pre></div><p>You will then want to back up the home directory using <code class="literal">tar</code> before confirming if there are any active processes attributed to this account by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps aux | grep -i &lt;username&gt;</strong></span>
</pre></div><p>Having done this, you can now proceed to kill any active processes attributed to that account by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># pkill -u &lt;username&gt;</strong></span>
</pre></div><p>Or, you can remove individual process IDs like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># kill -9 &lt;pid&gt;</strong></span>
</pre></div><p>By using <code class="literal">pkill</code>, you <a id="id207" class="indexterm"/>are invoking the <code class="literal">SIGTERM</code> command, which will streamline the task of removing any active process associated with that account. So, at this stage, you should now consider removing any files, print jobs, and re-assign or delete any <code class="literal">cron</code> jobs associated with that account.</p><p>You can do this by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># find / -user &lt;username&gt; -print</strong></span>
</pre></div><p>Having done this, you can safely delete a user with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># userdel -r &lt;username&gt;</strong></span>
</pre></div><p>Using the <code class="literal">-r</code> option will also remove the home directory associated with that account, but if you would like to delete the user, their home directory, and remove any <code class="literal">SELinux</code> mappings, you should use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># userdel -rZ &lt;username&gt;</strong></span>
</pre></div><p>However, if you encounter any difficulties, then you can always use the force option in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># userdel -rfZ &lt;username&gt;</strong></span>
</pre></div><p>Finally, you will need to consider removing any SSH keys associated with that user. Ensure that <code class="literal">sudo</code> or <code class="literal">su</code> is not enabled for that account, and then proceed to work through your applications and services one at a time (including database, e-mail, file sharing, htaccess, web directories, CGI files, and more) while reassigning new settings to any common accounts that the system may use.</p></div><div class="section" title="Modifying a user"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec15"/>Modifying a user</h2></div></div></div><p>One <a id="id208" class="indexterm"/>of the most useful aspects of user management for a troubleshooter is being able to modify an existing user account. There could be many reasons as to why this task is required, but the best illustration of this skill would begin with changing the default <code class="literal">adduser</code> attributes in the following file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/default/useradd</strong></span>
</pre></div><p>From here, you can redefine what shell is used, the default location of the home directories, and whether a default mail spool is set.</p><p>For example, you can use this technique to change the default location of the home directories from <code class="literal">/home</code> to <code class="literal">/home/&lt;companyname&gt;</code>. However, if you prefer to do this manually (on a case-by-case basis), in order to change the location of the home directory, you need to use the <code class="literal">usermod</code> command in conjunction with the <code class="literal">-d</code> option (the path to the new directory) and the <code class="literal">-m</code> option (to move the contents of the current home directory), like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># usermod -m -d /path/to/new/home/directory &lt;username&gt;</strong></span>
</pre></div><p>When <a id="id209" class="indexterm"/>running the preceding command, it is important to realize that a PID will be displayed on the console if the user is currently using the system and this must be killed before any modifications can be made.</p><p>Finally, should the need arise to transfer an existing user to a different group, then this can be achieved by invoking the <code class="literal">-g</code> option like so:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># usermod -g &lt;new_group_name&gt; &lt;username&gt;</strong></span>
</pre></div><p>However, having done this, and just as you would for deleting a user, you must manually change the ownership of any <code class="literal">crontab</code> files or jobs and complete the process by making any relevant changes to any remaining (related/existing) services as well.</p></div><div class="section" title="Meet login.defs"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec16"/>Meet login.defs</h2></div></div></div><p>When it <a id="id210" class="indexterm"/>comes to managing users, an alternative or long-term approach is to consider altering the default settings found in <code class="literal">/etc/login.defs</code> so that you can alter the behavior of the delete command.</p><p>For example, consider you find the following line commented out like this:</p><div class="informalexample"><pre class="programlisting">#USERDEL_CMD     /usr/sbin/userdel_local</pre></div><p>Uncomment this line and it will ensure that all <code class="literal">at/cron/print</code> jobs are removed. Moreover, you can also use the <code class="literal">login.defs</code> file to determine the default values assigned to the user mail directory, password encryption method, password expiry period, <code class="literal">userid</code>, <code class="literal">groupid</code>, and many more.</p></div></div></div>
<div class="section" title="Monitoring user activity with utmpdump"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Monitoring user activity with utmpdump</h1></div></div></div><p>Keeping <a id="id211" class="indexterm"/>track of user activity is one of the most essential skills associated with any Linux administrator. In situations where user management may be the cause of a troubleshooting session, we can make use of <a id="id212" class="indexterm"/>
<code class="literal">utmpdump</code>.</p><p>User histories are typically stored in the following locations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/var/run/utmp</code>: The purpose of this binary is to record open sessions. You can review the contents of this file with <code class="literal">utmpdump /var/run/utmp</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/run/wtmp</code>: The purpose of this binary is to record connection histories. You can review the contents of this file with <code class="literal">utmpdump /var/log/wtmp</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">/var/log/btmp</code>. The purpose of this binary is to record failed login attempts. You can review the contents of this file with <code class="literal">utmpdump /var/log/btmp</code>.</li></ul></div><p>Taking <a id="id213" class="indexterm"/>this one step further, you can also review the current history of logged sessions contained within <code class="literal">/var/run/wtmp</code> by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># last</strong></span>
</pre></div><p>You can review the current history of logged sessions contained within <code class="literal">/var/run/btmp</code> by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># lastb</strong></span>
</pre></div><p>However, as a simple review of these files is slightly redundant for our needs, you can read the current status of these files with the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># stat /var/run/utmp</strong></span>
<span class="strong"><strong># stat /var/log/wtmp</strong></span>
<span class="strong"><strong># stat /var/log/btmp</strong></span>
</pre></div><p>The output of these commands may look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Access: 2015-04-26 07:29:13.143818061 -0400</strong></span>
<span class="strong"><strong>Modify: 2015-04-26 06:24:02.444728081 -0400</strong></span>
<span class="strong"><strong>Change: 2015-04-26 06:24:02.444728081 -0400</strong></span>
</pre></div><p>Now, given that binary files cannot be viewed using basic reading commands such as <code class="literal">cat</code>, <code class="literal">less</code>, and <code class="literal">more</code>, rather than simply relying on basic commands such as <code class="literal">last</code>, <code class="literal">who</code>, <code class="literal">lastb</code>, and others, a different approach is to use the <code class="literal">utmpdump</code> command like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utmpdump /path/to/binary</strong></span>
</pre></div><p>So, as we have already mentioned earlier, in the case of wanting to read <code class="literal">/var/run/utmp</code>, you can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utmpdump /var/run/utmp</strong></span>
</pre></div><p>While the remaining files would be accessible with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utmpdump /var/log/wtmp</strong></span>
<span class="strong"><strong># utmpdump /var/log/btmp</strong></span>
</pre></div><p>So, having <a id="id214" class="indexterm"/>used all three commands, you will then notice that the output is in a familiar format with the most obvious difference being that the results of <code class="literal">wtmp</code> are displayed in reverse order as opposed to both <code class="literal">utmp</code> and <code class="literal">btmp</code> which are displayed in chronological order.</p><p>The results of <code class="literal">utmpdump</code> are formatted in the following way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first column displays a session identifier; the value 7 is typically associated with a new login event, while the value 8 is associated with a logout event.</li><li class="listitem" style="list-style-type: disc">The second column displays a PID.</li><li class="listitem" style="list-style-type: disc">The third column can hold a relative variable based on either of the following:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">~~</code>, indicating a run-level or system reboot change</li><li class="listitem" style="list-style-type: disc"><code class="literal">bw</code>, or a bootwait process</li><li class="listitem" style="list-style-type: disc">A numeric or TTY value</li><li class="listitem" style="list-style-type: disc">A character/digit that indicates a PTY value (the pseudo terminal).</li></ul></div></li><li class="listitem" style="list-style-type: disc">The fourth column can sometimes remain empty or maintain an associated username, runlevel, or reboot value.</li><li class="listitem" style="list-style-type: disc">The fifth column (if this information is available), will display the TTY or PTY value.</li><li class="listitem" style="list-style-type: disc">The sixth column will display the identity of the remote host. In most local cases, you will only see a runlevel message at most, but for remote access, you will see an IP address or name.</li><li class="listitem" style="list-style-type: disc">The seventh column will display the remote host's IP address, or it will show 0.0.0.0 for local access.</li><li class="listitem" style="list-style-type: disc">The eighth, and final column, will indicate the time and date information as to when the record was created.</li></ul></div><p>You should also be aware that columns six and seven will show identical information if no DNS resolution is performed.</p><p>So, with the preceding information in mind, with a bit of practice, and using the skills we discovered in the previous chapters, <code class="literal">utmpdump</code> can be used to perform a wide range of queries such as displaying general access information like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utmpdump /var/log/wtmp</strong></span>
</pre></div><p>Further to this, you can use <code class="literal">grep</code> to show the details of specific records.</p><p>For example, if <a id="id215" class="indexterm"/>you wanted to display the records of a particular user from <code class="literal">wtmp</code>, you will type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utmpdump /var/log/wtmp | grep &lt;username&gt;</strong></span>
</pre></div><p>Taking this one step further, you can use <code class="literal">grep</code> to identify the number of logins from a particular IP address in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utmpdump /var/log/wtmp | grep XXX.XXX.XXX.XXX</strong></span>
</pre></div><p>Or use the following syntax to check how many times root accessed the system:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utmpdump /var/log/wtmp | grep root</strong></span>
</pre></div><p>Then use the following command to monitor the number of failed login attempts:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utmpdump /var/log/btmp</strong></span>
</pre></div><p>Remember, the output of <code class="literal">btmp</code> should be minimal, given that this binary will show a variety of issues related to the use of incorrect passwords being used or attempts to log in with an unknown username. The latter of which is particularly important when a tty1 was shown to be used, as this will indicate that an unknown person had access to a terminal on your machine. Look at it this way, noticing such an important issue may inspire you to run a security audit on access privileges and keys by creating a basic text-based output file with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># utmpdump /var/log/btmp &gt; btmp-YYYY-MM-DD.txt</strong></span>
</pre></div></div>
<div class="section" title="Resetting the root password and enhancing logging"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Resetting the root password and enhancing logging</h1></div></div></div><p>With the<a id="id216" class="indexterm"/> release of CentOS 7, you may find that the process of resetting the root password has changed. So, in the event that you forget the root password, you will need to follow these important steps.</p><p>Boot the computer and press the <span class="emphasis"><em>E</em></span> key during the kernel screen phase. On the next screen, scroll down the text and look for the following line:</p><div class="informalexample"><pre class="programlisting">root=/dev/mapper/centos-root ro</pre></div><p>Now, replace the letters <code class="literal">ro</code> with the following:</p><div class="informalexample"><pre class="programlisting">rw init=/sysroot/bin/sh</pre></div><p>It should then look like this:</p><div class="informalexample"><pre class="programlisting">root=/dev/mapper/centos-root rw init=/sysroot/bin/sh</pre></div><p>When done, press <span class="emphasis"><em>Control</em></span> + <span class="emphasis"><em>X</em></span> or <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>X</em></span> to boot into the single user mode using the bash shell <code class="literal">/sysroot/bin/sh</code>.</p><p>In the single user mode, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># chroot /sysroot</strong></span>
</pre></div><p>After the hash sign (<code class="literal">#</code>), type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># passwd root</strong></span>
</pre></div><p>Follow the <a id="id217" class="indexterm"/>onscreen instructions and proceed to reset the password, but if you do need to update <code class="literal">SELINUX</code> use the command <code class="literal">touch /.autorelabel</code> before you do anything else.</p><p>When you are ready to finish, type the following command to access the machine in the usual way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># exit</strong></span>
</pre></div><p>Now, reboot your system in the usual way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># reboot</strong></span>
</pre></div><p>Well done! You should now be able to gain full access to the system using the new root password. However, if you decide to update the logging for all system commands, simply open the following file in your favorite text editor like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/bashrc</strong></span>
</pre></div><p>Scroll down to the bottom and add the following line:</p><div class="informalexample"><pre class="programlisting">readonly PROMPT_COMMAND='history -a &gt;(logger -t "$USER[$PWD] $SSH_CONNECTION")'</pre></div><p>Having done this, you will now find that all the SSH-based command-line activity is logged through <code class="literal">/var/log/messages</code> like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Jan 11 11:38:14 centurion1 journal: root[/root] 192.168.1.17 53421 192.168.1.183 22: last</strong></span>
<span class="strong"><strong>Jan 11 11:38:26 centurion1 journal: root[/var/log] 192.168.1.17 53421 192.168.1.183 22: cd /var/log</strong></span>
<span class="strong"><strong>Jan 11 11:38:32 centurion1 journal: root[/var/log] 192.168.1.17 53421 192.168.1.183 22: cat messages</strong></span>
<span class="strong"><strong>Jan 11 11:38:49 centurion1 journal: root[/var/log] 192.168.1.17 53421 192.168.1.183 22: last</strong></span>
</pre></div></div>
<div class="section" title="Recovering lost or deleted files with Scalpel"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Recovering lost or deleted files with Scalpel</h1></div></div></div><p>If a file<a id="id218" class="indexterm"/> has been accidentally deleted from the system, you can use a small utility called Scalpel to recover it. Scalpel is a faster alternative to Foremost, which <a id="id219" class="indexterm"/>was originally developed by the United States Air Force Office of Special Investigations and The Center for Information Systems Security<a id="id220" class="indexterm"/> Studies and Research. Today, it is a tool that is generally associated with both digital forensics investigation and file recovery, and you can install it by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install scalpel</strong></span>
</pre></div><p>You will need the EPEL repository to complete this process (which is discussed in a previous chapter), but when you are ready, simply update the following configuration file to determine what types of files you would like to search for:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/scalpel.conf</strong></span>
</pre></div><p>Having done this, you should now create a recovery directory, and then you should move to the <code class="literal">/etc</code> directory in order to use <code class="literal">scalpel.conf</code> like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /etc</strong></span>
</pre></div><p>You can run a scan on a relevant device by customizing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># scalpel /path/to/device -o /path/to/recovery/directory</strong></span>
</pre></div><p>An example of the preceding command would look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># scalpel /dev/sda1 -o /tmp/recovery-session1</strong></span>
</pre></div><p>Scalpel will begin by creating work queues, but be mindful that the entire operation will take some time to complete. In simple terms, the actual time taken to complete a scan will depend on the disk size, the number of deleted files, the power of the machine in general, and other activities that the system is currently performing.</p><p>You can view the findings by using the <code class="literal">ls</code> command like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ls -la /path/to/recovery/directory</strong></span>
</pre></div><p>Finally, and before you get started, you should be aware that a new recovery directory must be created every time you run Scalpel (so you may want to consider using an alternative hard disk) as the results will be maintained by a single audit file.</p><p>This particular file can be viewed by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># less /path/to/recovery/directory/audit.txt</strong></span>
</pre></div><p>Remember, Scalpel will work with a variety of filesystem formats or raw partitions, and in this respect, it can be seen as a very useful tool for any troubleshooter.</p><p>You <a id="id221" class="indexterm"/>can learn<a id="id222" class="indexterm"/> more about Scalpel by reviewing the manual like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># man scalpel</strong></span>
</pre></div></div>
<div class="section" title="Restoring file and directory permissions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Restoring file and directory permissions</h1></div></div></div><p>File <a id="id223" class="indexterm"/>and directory permissions are important, and to view the current state of all the files<a id="id224" class="indexterm"/> in a particular directory, you can run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ll</strong></span>
</pre></div><p>Alternatively, you can target a particular directory by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ll /path/to/directory</strong></span>
</pre></div><p>However, in a situation where someone has mistakenly changed the permissions of a particular system-based file or folder this calamitous situation can be rectified with the following RPM-based commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># rpm --setugids PACKAGENAME</strong></span>
<span class="strong"><strong># rpm --setperms PACKAGENAME</strong></span>
</pre></div><p>On the other hand, should it be the case that an entire directory has been mistakenly updated with <code class="literal">chown</code> or the <code class="literal">chmod</code> commands, the following commands will prove more useful:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># for package in $(rpm -qa); do rpm --setugids $package; done</strong></span>
<span class="strong"><strong># for package in $(rpm -qa); do rpm --setperms $package; done</strong></span>
</pre></div><p>Based on the commands shown preceding, the first command will serve to reset all the file and folder ownerships values to the default state, while the second command will serve to reset the relative file permissions. So having run these commands, it is possible that you will see the following messages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>chgrp: cannot access '/usr/share/man/zh_TW/man5x': No such file or directory</strong></span>
<span class="strong"><strong>chown: cannot access '/usr/share/man/zh_TW/man6': No such file or directory</strong></span>
<span class="strong"><strong>chgrp: cannot access '/usr/share/man/zh_TW/man6': No such file or directory</strong></span>
<span class="strong"><strong>chown: cannot access '/usr/share/man/zh_TW/man6x': No such file or directory</strong></span>
</pre></div><p>Don't worry! Regardless of which file or directory is listed, such notices can be safely ignored.</p></div>
<div class="section" title="Working with and extending the XFS filesystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Working with and extending the XFS filesystem</h1></div></div></div><p>Originally<a id="id225" class="indexterm"/> developed at Silicon Graphics in 1993, the main purpose of XFS is to not only support the creation of large filesystems that will allow for metadata journaling, but to provide a technology that can be defragmented and enlarged while mounted and active. This information may or may not be of much use to you as a troubleshooter, but you should be aware that the default filesystem now employed by the most recent release of CentOS is known as XFS. If you did not customize the partitions to any great extent, then you may find that XFS is the filesystem you will be dealing with.</p><p>You can quickly confirm the structure of your system with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># df -Th</strong></span>
</pre></div><p>The preceding command (the disk size and partitions ignored) can result in something similar to the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Filesystem              Type      Size  Used Avail Use% Mounted on</strong></span>
<span class="strong"><strong>/dev/mapper/centos-root xfs        42G  1.5G   40G   4% /</strong></span>
<span class="strong"><strong>devtmpfs                devtmpfs  913M     0  913M   0% /dev</strong></span>
<span class="strong"><strong>tmpfs                   tmpfs     919M     0  919M   0% /dev/shm</strong></span>
<span class="strong"><strong>tmpfs                   tmpfs     919M  8.4M  911M   1% /run</strong></span>
<span class="strong"><strong>tmpfs                   tmpfs     919M     0  919M   0% /sys/fs/cgroup</strong></span>
<span class="strong"><strong>/dev/sda1               xfs       494M  139M  356M  29% /boot</strong></span>
<span class="strong"><strong>/dev/mapper/centos-home xfs        21G   33M   21G   1% /home</strong></span>
</pre></div><p>The <a id="id226" class="indexterm"/>wording <code class="literal">xfs</code> under the column labeled <code class="literal">type</code> is what we are looking for. If it is found that your server does use the XFS filesystem, then the XFS tools and utilities file <code class="literal">xfsprogs.x86_64</code> can be installed with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install xfsprogs</strong></span>
</pre></div><p>Generally speaking, you should be aware that XFS can prove to be the source of a subtle loss of performance if the server system is relatively small. In these circumstances ext4 tends to be faster with some single threaded and metadata intensive workloads. Moreover, as shrinking support is not available to XFS, you should know that this technology does not allow the filesystem to be reduced in size even when un-mounted. For this reason, you may want to stay with ext4 when big filesystems or big files are not required.</p><p>Looking at the bigger picture, you will be comforted to know that the basic syntax required to create an XFS is similar to other filesystems:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mkfs.xfs /dev/device</strong></span>
</pre></div><p>So, no <a id="id227" class="indexterm"/>surprises there, and due to the similarities with other filesystems, I will assume that you are comfortable completing the rest of this procedure. However, before you begin, you should always be aware of the server's hardware configuration before starting this operation, as there may be a few notable issues you may want to be aware of before concluding this operation.</p><p>For example, let's <a id="id228" class="indexterm"/>say the server exceeded 2 TB. So having completed the initial <code class="literal">fdisk</code> operations to build the filesystem layout, (prior to mounting) you may decide to benchmark the system because every good troubleshooter knows that XFS enables write barriers to ensure filesystem integrity.</p><p>You can achieve this simple operation by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mount -o inode64 /dev/device /mount/point</strong></span>
</pre></div><p>By default, write barriers will serve to preserve the filesystem from issues relating to power failure, resets, and system crashes, but if your hardware maintains a good write cache, then it may seem more prudent to disable the write barrier in order to reduce the impact on performance.</p><p>In this respect, you can mount the device in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mount -o nobarrier /dev/device /mount/point</strong></span>
</pre></div><p>On completion, you can always request further information about a specific volume with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_info /mount/point</strong></span>
</pre></div><p>So as we can see, XFS does come with a lot of good features and tools, but when it comes to the process of troubleshooting a server, it is precisely these differences that could be the cause of the problem.</p><p>In this respect, and as we will now see, XFS should be treated in a different way to a comparable ext3- or ext4-based system. However, if you need to extend the filesystem, then you will be happy to know that XFS comes complete with a standard tool known as <code class="literal">xfs_growfs</code> that can be used in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_growfs -d /mount/point</strong></span>
</pre></div><p>Assuming that you have reviewed the man pages, it would be obvious to state that your syntax would use the <code class="literal">-d</code> option in order to grow the filesystem to the maximum size supported by the device.</p></div>
<div class="section" title="Running repairs on XFS"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Running repairs on XFS</h1></div></div></div><p>XFS was <a id="id229" class="indexterm"/>created with the intention to support extremely large filesystems. It performs incredibly well under a heavy load and scales with large files, but as a result, it is also susceptible to damage, and it is with this in mind that we now consider a set of tools that will enable us to troubleshoot the server and restore the filesystem.</p><p>Known<a id="id230" class="indexterm"/> as <code class="literal">xfs_repair</code>, this tool is used to confirm filesystem consistency and repair any problems that are found. This process will not restore lost data, but it should restore the filesystem on the device in question.</p><p>The basic syntax used by <code class="literal">xfs_repair</code> is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_repair /mount/point</strong></span>
</pre></div><p>However, to avoid any error messages, the procedure will then require that you should initially <code class="literal">umount</code> the device in question. In this respect, the entire procedure will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># umount /mount/point</strong></span>
<span class="strong"><strong># xfs_repair /mount/point</strong></span>
</pre></div><p>The resulting output will then proceed to run through a series of phases and confirm the relevant events. Once complete, simply remount the device in the usual way to complete the task. However, on the chance that <code class="literal">xfs_repair</code> fails, repeat this process again but do your research on the respective error messages.</p><p>If <code class="literal">xfs_repair</code> fails to fix the consistency problems on a third occasion, depending on the error messages, you may want to consider an alternative rescue plan for the server, as it should be assumed that data recovery can only be made from backups.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Having said that, it is possible that you can consider additional steps to recover the device in question.</p><p>At this current stage, you should assume that data recovery can only be made from backups and your plan is now based on the recovery of the filesystem only. However, having said this, it is important to remember that you should not take any action that will impact the production environment.</p><p>It may be possible to restore files from the disk by backing up and restoring the files on the filesystem. To do this, mount the filesystem in the read-only mode and proceed to make a backup with <code class="literal">xfsdump</code>. From this point onwards, you will want to remake the partition and restore the files with <code class="literal">xfsrestore</code>. Check <code class="literal">man xfsdump</code> and <code class="literal">man xfsrestore</code> for further details.</p><p>Alternatively, if log recovery is unsuccessful, it may be possible to recover some of the data by mounting the filesystem in the read-only mode with the <code class="literal">no recover</code> option. This will avoid running the log recovery process but, by using this method, the filesystem is unlikely to be consistent, and it is to be expected that not all of the data will be returned.</p></div></div><p>The <a id="id231" class="indexterm"/>
<code class="literal">xfs_repair</code> utility is designed to repair filesystems. It is size independent (treating both large and small filesystems equally), but unlike other repair tools, it will not run at boot and it will only initiate logging at mount in order to ensure a consistent<a id="id232" class="indexterm"/> filesystem. In cases where <code class="literal">xfs_repair</code> encounters a damaged log file, it will not be able to repair the filesystem, so in the event that this does happen, you will need to clear the relevant log, mount and then un-mount the XFS filesystem, which is done by adding the <code class="literal">-L</code> option to force log zeroing like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_repair -L /mount/point</strong></span>
</pre></div><p>Remember, resetting the log can leave the filesystem in an inconsistent state. This can, and generally does, result in the loss of data and/or data corruption. So, only apply these methods with the intention to restore the filesystem alone. Remember, the <code class="literal">xfs_repair</code> command is not intended to restore the data on that filesystem.</p></div>
<div class="section" title="Investigating fragmentation on XFS"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Investigating fragmentation on XFS</h1></div></div></div><p>In situations <a id="id233" class="indexterm"/>where the filesystem is acting sluggishly, it is possible that fragmentation is impacting your server. In this instance, and if you suspect that fragmentation has occurred or is occurring, then simply run the following command on the relevant device:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_db -c frag -r /mount/point</strong></span>
</pre></div><p>By using<a id="id234" class="indexterm"/> this command, we are causing <code class="literal">xfs_db</code> to open the filesystem in a read-only mode (<code class="literal">-r</code> option) and passing a command (<code class="literal">-c</code> option) to get the file fragmentation data (<code class="literal">frag</code>) for the device in question. When we use the <code class="literal">frag</code> command, it will only return information relevant to the file data in the filesystem as opposed to concerning itself with the fragmentation of free space. So, depending on the specific nature of your system, the resulting output could look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>fragmentation factor 0.31%</strong></span>
</pre></div><p>In a more severe case, it could report the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>fragmentation factor 93.39%</strong></span>
</pre></div><p>By<a id="id235" class="indexterm"/> drawing <a id="id236" class="indexterm"/>your attention to the fragmentation factor (expressed as a percentage) in the preceding examples, you may have found at least one reason as to why your server requires troubleshooting. Fixing this situation would be a matter of calling the filesystem organizer utility, otherwise known as <code class="literal">xfs_fsr</code>. We would simply require the system to reorganize our partition or device to optimize disk usage in a similar way to a Microsoft Windows desktop. In this respect, the most basic syntax for using <code class="literal">xfs_fsr</code> would be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_fsr /path/to/device</strong></span>
</pre></div><p>Whereas, for a single file, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_fsr /path/to/file</strong></span>
</pre></div><p>However, given that the period of time for these events to complete can be quite long, a more succinct use of this command would be to specify a list of filesystems to reorganize (<code class="literal">-m</code>), a time option <code class="literal">-t</code> calculated in seconds, and the verbose option <code class="literal">-v</code> for a clear indication of what is happening, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_fsr -m /etc/mtab -t 7200 -v</strong></span>
</pre></div><p>The corresponding output will then display the number of extents that are both before and after the inode. By default, <code class="literal">xfs_fsr</code> will make ten passes before completing the process unless you decide to reduce the number of passes by using the option <code class="literal">-p</code> like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_fsr -m /etc/mtab -t 7200 -v -p 2</strong></span>
</pre></div><p>You should be aware that <code class="literal">xfs_fsr</code> should not be used to defragment the whole system as this is generally regarded to be unnecessary as it can give rise to free space fragmentation, so you can complete this task in stages in the knowledge that the operation can be interrupted cleanly. This will leave the filesystem in a consistent state. If you interrupt the process (using <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span>), <code class="literal">xfs_fsr</code> will save the defragmentation process to the following location:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /var/tmp/.fsrlast_xfs</strong></span>
</pre></div><p>However, before you dive in, the real issue here is that this fragmentation issue should be approached with caution on a live system, as proceeding to defragment a device or partition during periods of high-load will place an unnecessary burden on your server. So in this instance, the best course of action is to run <code class="literal">xfs_fsr</code> at a time when the relevant device or partition is not at full load or during lighter working periods.</p><p>Finally, and having <a id="id237" class="indexterm"/>completed the process of defragmentation, you can confirm the extent of the work performed with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># xfs_db -c frag -r /mount/point</strong></span>
</pre></div><p>So having <a id="id238" class="indexterm"/>completed these simple actions, or necessitated a future (and possibly repeat) cron job, you should now notice an immediate improvement with regard to the speed at which files and folders can be moved and transferred.</p></div>
<div class="section" title="Auditing directories and files"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Auditing directories and files</h1></div></div></div><p>An important task <a id="id239" class="indexterm"/>related to troubleshooting can arise from an understanding of activities commonly associated with the action of reading and writing files. CentOS 7 provides a simple utility for this. Known as <code class="literal">auditd</code>, this service (or daemon) starts during the boot process. Events are recorded to an associated log file found at <code class="literal">/var/log/audit</code> and as it runs in the background, you can check the current service status with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl status | grep audit</strong></span>
</pre></div><p>It is possible to<a id="id240" class="indexterm"/> customize the auditing service and you can have direct access to manage the log file size, location, and associated attributes by accessing the following file with your favorite text editor:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/audit/auditd.conf</strong></span>
</pre></div><p>Moreover, if you do not wish to lose any auditing data, you are able to disable the machine when an audit cannot be performed. To do this, open the configuration file <code class="literal">auditd.conf</code> and add or modify the following lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>max_log_file_action = keep_logs</strong></span>
<span class="strong"><strong>space_left_action = email</strong></span>
<span class="strong"><strong>action_mail_acct = root</strong></span>
<span class="strong"><strong>admin_space_left_action = halt</strong></span>
</pre></div><p>This action is severe and it is not something to jump into without doing your homework, but it will serve to remove the default action of rotating log files and replace it with an instruction to e-mail the root user.</p><p>Finally, should<a id="id241" class="indexterm"/> you wish to take advantage of the audit service flag for every process, simply open <code class="literal">/etc/default/grub</code> and add the following argument to the kernel line:</p><div class="informalexample"><pre class="programlisting">audit=1</pre></div><p>Remember<a id="id242" class="indexterm"/> to regenerate grub with the following command and reboot:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grub2-mkconfig -o /boot/grub2/grub.cfg</strong></span>
</pre></div><p>This will ensure that an auditable flag is set for every process after the boot sequence has been initiated and, for even greater simplicity, we can then consider building a unique set of rules by editing the following file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/audit/rules.d/audit.rules</strong></span>
</pre></div><p>To make this as easy as possible, the best approach is to find your server's <code class="literal">stig.rules</code> file at <code class="literal">/usr/share/doc/audit-X.X.X/stig.rules</code> and copy it to <code class="literal">/etc/audit/rules.d/audit.rules</code>. Based on the current package version (in my case), the <code class="literal">stig.rules</code> file can be found at <code class="literal">/usr/share/doc/audit-2.3.3/stig.rules</code>. Consequently, I ran the following command to create a default rule set:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cp /usr/share/doc/audit-2.3.3/stig.rules /etc/audit/rules.d/audit.rules</strong></span>
</pre></div><p>So, having customized the rules and restarted the <code class="literal">auditd</code> service, you will discover that a query can be initiated with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ausearch -f /path/to/directory/or/file</strong></span>
<span class="strong"><strong># ausearch -f /path/to/directory/or/file | less</strong></span>
<span class="strong"><strong># ausearch -f /path/to/directory/or/file -i | less</strong></span>
</pre></div><p>As an alternative to this, you can use <code class="literal">aureport</code> to produce a series of audits in the following way:</p><p>To monitor unusual behavior, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># aureport --key --summary</strong></span>
</pre></div><p>To build a report on user logins, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># aureport -l -i -ts yesterday -te today</strong></span>
</pre></div><p>To review access violations, you can try:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ausearch --key access --raw | aureport --file --summary</strong></span>
</pre></div><p>Finally, to review anomalies, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># aureport --anomaly</strong></span>
</pre></div><p>Of course, we <a id="id243" class="indexterm"/>haven't covered every aspect of the auditing service, but the preceding<a id="id244" class="indexterm"/> examples should get you started. Remember, all of the examples shown can be added to a cron job and, should you wish to know more, the <code class="literal">aureport</code> manual can always be viewed any time by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># man ausearch</strong></span>
<span class="strong"><strong># man aureport</strong></span>
</pre></div></div>
<div class="section" title="Visualizing directories and files"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Visualizing directories and files</h1></div></div></div><p>Good<a id="id245" class="indexterm"/> administration starts with good housekeeping, and for this reason, the maintenance of detailed records regarding your server's layout is generally considered to be a good starting point for any Linux administrator. Such a task not only allows you to keep abreast of any changes made to the system as a whole, but it can be a useful approach to debugging. Moreover, because you may have inherited this system, or shared access with a number of administrators, it is probably a good idea to consider running an up-to-date inventory of the changes made.</p><p>All <a id="id246" class="indexterm"/>directories, folders, and files accessible to a specific Linux-based system are arranged in a single tree. Starting from root (<code class="literal">/</code>), this hierarchy may consist of either local or remote files, local or remote filesystem(s), and local or remote block devices.</p><p>To view this tree, simply ensure that you have installed the following package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install tree</strong></span>
</pre></div><p>By default, the <code class="literal">tree</code> command will begin indexing from your current location, so to begin, simply change your location to the boot directory like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /boot</strong></span>
</pre></div><p>Now, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tree</strong></span>
</pre></div><p>The <code class="literal">tree</code> command is technically described as <span class="emphasis"><em>a recursive directory listing command</em></span> that displays the content of your server in a tree-like format. It is highly customizable, so if you prefer to target a specific directory from your current location, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tree /path/to/folder</strong></span>
</pre></div><p>You may have noticed that the tree command does not show hidden files by default. Therefore, in order to see all files (including all hidden files), use the <code class="literal">-a</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tree -a /path/to/folder</strong></span>
</pre></div><p>However, if you <a id="id247" class="indexterm"/>would like the tree function to restrict itself to displaying folder names only, you should use the <code class="literal">-d</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tree -d /path/to/folder</strong></span>
</pre></div><p>If it all <a id="id248" class="indexterm"/>looks a little plain and ordinary, you can add some color to the output with the <code class="literal">-C</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tree -C /path/to/folder</strong></span>
</pre></div><p>Finally, you can combine the preceding options to print the output to a text file by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tree &gt; /folder/name/filename.txt</strong></span>
</pre></div><p>For example, if you wanted to maintain a list of files in one or more directories showing the current permissions, you can use the <code class="literal">-p</code> option like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tree -p &gt; /folder/name/filename.txt</strong></span>
</pre></div><p>Alternatively, if you would prefer to display the output with embedded HTML code for export, try:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tree -H /path/to/folder</strong></span>
</pre></div><p>So, regardless of whether you have adopted a new server, or you are troubled by the number of users accessing and writing files to that server, the <code class="literal">tree</code> function provides a relative solution to keeping a visual audit of your server, or your devices, by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tree -d /sys/devices</strong></span>
</pre></div><p>So why not combine this with a cron job? Then you can regularly keep an eye on the rise of any potential problems or even maintain a visual record of when those changes took place. In this respect you could assert that the <code class="literal">tree</code> package is a very useful tool, and to learn more you can review the manual at any time by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># man tree</strong></span>
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, we have approached a number of topics related to users, directories, and files, while introducing some related themes associated with the release of the XFS filesystem. From forcing password changes to visualizing the directory structure, restoring the root password to understanding the need for disk defragmentation, our pursuit of troubleshooting CentOS 7 has gone some way to show that the knowledge gained from resolving fundamental system-based issues directly relate to the ongoing human-based issues. It would be true to say that you can never rehearse a disastrous scenario because every event may be unique to one or more systems but, as we have seen, regardless of whether you are monitoring users, modifying users, recovering data, or maintaining the filesystem as a whole, by following a few simple procedures, much of those file, directory, and user-based issues can be solved quickly and efficiently; which leads us gently towards the subject of troubleshooting shared resources.</p></div>
<div class="section" title="References"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>References</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Red Hat customer portal: <a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/</a></li><li class="listitem" style="list-style-type: disc">The Tree Project home page: <a class="ulink" href="http://mama.indstate.edu/users/ice/tree/">http://mama.indstate.edu/users/ice/tree/</a></li><li class="listitem" style="list-style-type: disc">XFS FAQ: <a class="ulink" href="http://xfs.org/index.php/XFS_FAQ">http://xfs.org/index.php/XFS_FAQ</a></li><li class="listitem" style="list-style-type: disc">The XFS user guide: <a class="ulink" href="http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide//tmp/en-US/html/index.html">http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide//tmp/en-US/html/index.html</a></li><li class="listitem" style="list-style-type: disc">The Red Hat XFS guide: <a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-xfs.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-xfs.html</a></li><li class="listitem" style="list-style-type: disc">The XFS wiki page: <a class="ulink" href="http://en.wikipedia.org/wiki/XFS">http://en.wikipedia.org/wiki/XFS</a></li></ul></div></div></body></html>