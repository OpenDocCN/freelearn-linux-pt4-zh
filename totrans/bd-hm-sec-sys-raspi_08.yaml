- en: Chapter 8. A Miscellany of Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have provided us with the foundation and elements to design
    and put together our entire home security system, which we will do in the next
    chapter. I hope that I've guided you through this journey in a fairly structured
    and logical way so that you are ready to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Beforehand, though, I'm including this chapter dubbed a *Miscellany of Things*,
    as that's exactly what it is. It comprises a few optional, but useful, extras
    that we should consider for our system, but that don't really warrant a whole
    chapter in their own right. I guess you could refer to them as footnotes to previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Ways to arm and disarm the system without the web-based panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driving inductive loads safely from our GPIO outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an escaped water sensor input to our system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a temperature sensor input to our system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How carbon monoxide detectors could be added to our system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remotely managing our Raspberry Pi using Webmin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arming and disarming the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've included a switch on our Web-based control panel so that you can arm and
    disarm the system from your smartphone. However, this is probably not the most
    convenient way of doing it, especially when you're rushing out of the house, or
    you've returned home with a phone whose battery is flat. So, we need to find an
    additional way of arming and disarming our system at the entry and exit point
    of our property.
  prefs: []
  type: TYPE_NORMAL
- en: In the zone list table in the previous chapter, you'll notice that I assigned
    input GP0 on the Raspberry Pi GPIO as our arm/disarm switch input. This input
    will work in conjunction with our control panel switch.
  prefs: []
  type: TYPE_NORMAL
- en: This input can as be a simple as a toggle switch, or a bit more secure, such
    as a **key switch** or **electronic keypad**. Either way, it will be wired to
    ground GP0 (GPIO17) on our Raspberry Pi when the system is armed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arming and disarming the system](img/B04579_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The circuit diagram for our arm/disarm switch
  prefs: []
  type: TYPE_NORMAL
- en: If you have switches or other such devices that will be outside and exposed
    to the elements, you'll need to ensure that they are suitable for outdoor use
    so that they don't get damaged and compromise the integrity of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arming and disarming the system](img/B04579_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The IP67-rated key switch, suitable for outdoor use (type Lorlin WRL-5-E-S-2-B)
  prefs: []
  type: TYPE_NORMAL
- en: By using a standalone **security keypad**, you can allow each user to have their
    own code to arm and disarm the system. For example, the CDVI ECO 100 is a low-cost
    keypad that allows up to a 100 users. When the correct code is entered, it will
    arm the system by closing an internal switch. When the code is entered again,
    the keypad will disarm the system by opening the switch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arming and disarming the system](img/B04579_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The CDVI ECO 100 programmable keypad
  prefs: []
  type: TYPE_NORMAL
- en: Driving inductive loads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I talked about driving large loads in [Chapter 6](ch06.html "Chapter 6. Adding
    Cameras to Our Security System"), *Adding Cameras to Our Security System*, but
    now is probably a good time to expand on this a bit and talk about driving **inductive
    loads** such as **bells** and incandescent **lamps**. In the previous circuit
    example, I used the TIP120 Darlington transistor to drive an LED array that was
    not inductive. With inductive loads, you need to add a bit of diode protection
    to protect the circuit against spikes generated by the coils within relays and
    bells as they switch on and off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the modified circuit for our digital load driver with a 1N4007 **rectifier
    diode** for protection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Driving inductive loads](img/B04579_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The digital load driver with diode protection
  prefs: []
  type: TYPE_NORMAL
- en: Beyond intrusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Home security is not just about protecting our property against intrusion, it's
    also about protecting against other risks too, such as flood, fire, carbon monoxide
    leaks, and so on. So, it makes sense to extend our home security system to detect
    these other risks too.
  prefs: []
  type: TYPE_NORMAL
- en: You may choose to set up the system so that certain types of alerts only come
    to your phone as emails, rather than triggering all of the outside bells, lights,
    and whistles. This can be done by adapting the scripts in the next chapter so
    that they operate how you want them to.
  prefs: []
  type: TYPE_NORMAL
- en: A simple water detector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's nothing worse than being away for a few days and coming home to a flooded
    kitchen because a leak has developed under the sink. Our simple circuit will detect
    the presence of water and trigger an input on our home security system, which
    can then alert you. You can also buy kits and ready-built modules to do this,
    but the following circuit is cheap and features our opto-isolator as we're going
    to have a different voltage for our actual detector.
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple water detector](img/B04579_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The circuit for a simple water detector, isolated from our GPIO input
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When water is placed across the probes, current flows through the water, and
    so, through the R3/R4 potential divider on the base of transistor Q1\. When the
    current at the base is high enough to saturate it, the transistor will switch
    on fully, allowing the LED inside the opto-coupler to switch on. This in turn
    will pull down the input pin to our system to ground via the photo-transistor
    inside the optocoupler.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the trimmer, R4, to calibrate the sensor by adjusting its sensitivity.
    Any generic NPN bipolar transistor should work here, but obviously, they all have
    different operating parameters, so choose a suitable one.
  prefs: []
  type: TYPE_NORMAL
- en: A simple temperature sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to be alerted when the ambient temperature reaches a certain threshold,
    then we can build a circuit using the commonly used LM34/LM35 temperature sensors.
    It''s a simple device with just three pins: power, ground, and output, providing
    a voltage proportional to the temperature. The difference between the LM34 and
    LM35 is that the LM34 produces an output of 10mV/°F, whereas the LM35 produces
    10mV/°C. There is also an LM335 variant that produces an output of 100mV/°K.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple temperature sensor](img/B04579_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pinout taken from the Texas Instruments LM35DZ datasheet
  prefs: []
  type: TYPE_NORMAL
- en: It may have occurred to you at this point that this is an analogue device—so
    how do we interface that with our wholly digital system? One way is to incorporate
    an analogue-to-digital interface onto our input control board and read the data
    coming in from that so that we know the exact temperature, but that's probably
    a bit beyond the scope of this book. So, we're going to implement a circuit that
    will alert us when the temperature exceeds a pre-defined threshold, which is probably
    all we need in the context of our home security system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're interested in building an analogue-to-digital module to extend your
    home security, then take a look at something such as the PCF8591 chip from NXP,
    which is an I2C-based analogue-to-digital converter. This will connect to the
    I2C bus that we're already using, and so it is effectively just an add-on.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/NXPPCF8591T](http://bit.ly/NXPPCF8591T)'
  prefs: []
  type: TYPE_NORMAL
- en: For our temperature detector circuit, we will use an operational amplifier configured
    as a comparator that will trigger our opto-coupler input when the pre-set temperature
    is reached. So, for fire detection, we might want to detect when the ambient temperature
    has exceeded 50°C.
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple temperature sensor](img/B04579_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The temperature threshold sensor to drive our digital input
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reference voltage is set by the variable resistor, R4, which forms a voltage
    divider between the 12V and the ground. This essentially means that the reference
    voltage on the +ve input of the op-amp comparator can be between 0 and 12V. Assuming
    that we want to detect when 50° is reached, we will need the op-amp to trigger
    when the –ve is 500mV (10mV/°C).
  prefs: []
  type: TYPE_NORMAL
- en: In our circuit, the output of the op-amp is high in its normal state, which
    keeps the opto-coupler on. However, when the threshold is reached, the output
    of the op-amp is driven low, switching off the transistor Q1, and hence, the opto-coupler.
    This pulls our alarm input high via resistor R2.
  prefs: []
  type: TYPE_NORMAL
- en: A carbon monoxide detector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's entirely possible to build smoke and carbon-monoxide detectors that we
    can connect to our home security system in a similar way to the previous sensors,
    although they are a little bit more complex as they can require special handling.
    The SparkFun MQ-7 **Carbon Monoxide** (**CO**) detector (which is actually made
    by Winsen Electronics) can be implemented in a similar way to our temperature
    sensor, triggering an alarm input when a particular threshold is reached.
  prefs: []
  type: TYPE_NORMAL
- en: '![A carbon monoxide detector](img/B04579_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Winsen MQ-7 carbon monoxide gas detector, available from SparkFun.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The maximum safe continuous exposure to carbon monoxide (CO) is 9ppm (parts-per-million)
    according to ASHRAE ([www.ashrae.org](http://www.ashrae.org)), and you should
    certainly not be exposed to CO higher than this for prolonged periods of time,
    with 35ppm being the absolute maximum for a normal 8-hour working day.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MQ-7 detector has a sensitivity of between 10 and 500ppm, so in my mind,
    I''d want to be alerted as soon as it picks up anything, therefore we should set
    our comparator''s reference voltage to the lower end of the scale, in accordance
    with the sensitivity curve taken from the datasheet, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A carbon monoxide detector](img/B04579_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The sensitivity curve taken from the Winsen MQ-7 manufacturer's datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Warning**'
  prefs: []
  type: TYPE_NORMAL
- en: I've included this section on carbon monoxide detection more for interest than
    anything else. It's nasty stuff, and while rolling out your own detector is OK
    for interest's sake, please keep it just for that. It's useful to have this in
    our home security system to alert us when we're out of the house as an addition,
    but this *should not* be a replacement for a commercially available one that sits
    next to your boiler with all of the certifications, standards, and so on, and
    makes a very loud noise when we're in the house.
  prefs: []
  type: TYPE_NORMAL
- en: Remote administration for our Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to set up our system and home network
    so that we can remotely access the alarm control panel from wherever we are. I'm
    now going to show you how to extend this to be able to administer and monitor
    our entire Raspberry Pi system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Webmin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Webmin** is a rather fine and well established web-based interface for administering
    Unix/Linux systems. You can find everything about Webmin on its website at [www.webmin.com](http://www.webmin.com).
    I''m assuming, as throughout this book, that you are using the Raspbian distribution
    on our Pi when it comes to installing Webmin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to install Webmin: either by manually downloading
    and unpacking it, or by updating our repository sources so that we can use `apt-get`.
    I''m going to opt for the latter, so any dependencies are automatically installed
    and updates can be managed more easily in the future. There are a few steps, but
    it''s pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the repository sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we need to do is update our repository sources to include the
    Webmin repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following two lines to the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and exit Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing the signing key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to download and import the repository''s signing key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have everything we need, we can update the package installer and
    install Webmin. It can take a while, so you might want to go and make yourself
    a cup of tea or coffee:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once it's installed, you should see the following message in the shell window:![Importing
    the signing key](img/B04579_08_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Webmin installation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accessing Webmin locally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Webmin, by default, runs on port 10000 and uses the secure HTTP**S** protocol;
    so, to access it, you need to enter the following URL in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://<my-ip>:10000`'
  prefs: []
  type: TYPE_NORMAL
- en: Where `<my-ip>` is the IP address of your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we set up a static IP address on our system; in my
    case, I set up the address as 192.168.0.99\. So, to access Webmin on my system,
    I would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://192.168.0.99:10000`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**HTTPS Privacy Errors**'
  prefs: []
  type: TYPE_NORMAL
- en: In some browsers, such as Google Chrome, you might see a privacy error as you
    try to access the Webmin Web page. This is because the SSL certificate behind
    the HTTPS connection is not signed by a known authority. This is fine—just tell
    your browser that you want to accept this and proceed (in Chrome, you need to
    click on the **Advanced** link first to access that option).
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing Webmin locally](img/B04579_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can log into Webmin using the **root** or **pi** user account, or any other
    account that has **sudo** rights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing Webmin locally](img/B04579_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Webmin login
  prefs: []
  type: TYPE_NORMAL
- en: Once logged in, you'll be presented with the main system information page. Have
    a good poke around in it because there's lots of useful stuff you can see and
    do.
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing Webmin locally](img/B04579_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Webmin system information view
  prefs: []
  type: TYPE_NORMAL
- en: Webmin comes with a lot of modules, and not all of them are installed; therefore,
    you might want to explore the **Un-used Modules** section of the panel to see
    if there is anything you want to add to Webmin.
  prefs: []
  type: TYPE_NORMAL
- en: Remotely accessing Webmin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the same way that we set up remote access for our alarm control panel in
    the previous chapter, you can do it with Webmin—just set up port-forwarding on
    your router for port 10000\. You can then access Webmin from anywhere using `https://<my-public-ip>:10000`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, this has been a bit of a mix-and-match of various topics to end on before
    we put together our home security system framework. I hope you enjoyed these various
    footnotes to previous chapters, and that it's given you some ideas on how far
    you can take your home security system.
  prefs: []
  type: TYPE_NORMAL
- en: We started by looking at ways we can arm and disarm our system without having
    to access the Web-based control panel, by adding a mechanical or digital switch
    to an arm/disarm input.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at adding analogue-type sensors to our system, which can alert
    us when a threshold has been reached by using operational amplifiers set up as
    voltage comparators. The idea behind these comparator circuits can be implemented
    for different types of sensors where you want to know when a certain voltage threshold
    has been reached at the analogue sensor output.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to install Webmin on our Raspberry Pi so that we can
    monitor and configure many aspects of the Linux operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is the moment we've all been waiting for; we're going to take
    all of the elements and concepts from the previous chapters and put together our
    full system comprising the elements we want to feature. The star of the show will
    be our Bash scripts, which will glue together all of these elements and provide
    the control logic for the entire system.
  prefs: []
  type: TYPE_NORMAL
