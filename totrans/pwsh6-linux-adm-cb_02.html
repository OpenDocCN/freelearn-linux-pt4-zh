<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing the Core and its Capabilities</h1>
                </header>
            
            <article>
                
<p>In this chapter, we cover the following topics:</p>
<ol>
<li>Dissecting a .NET Core object</li>
<li>Breaking down an output into different objects</li>
<li>Parsing input from text to object</li>
<li>Comparing the outputs of Bash and PowerShell</li>
<li>Comparing Windows PowerShell and PowerShell</li>
<li>Listing out the aliases and using them in place of cmdlets</li>
<li>Creating a custom alias</li>
<li>Importing/Exporting custom aliases for future use</li>
<li>Listing out the execution policies and setting a suitable one</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p class="mce-root">Microsoft's announcement of "open sourcing" .NET in 2014 almost stirred a storm. Many rushed to the stands (so to speak) to read about the unbelievable—how could Microsoft possibly open-source the core of their operating system? Some were cynical, others rejoiced. Then came the announcement a little louder and clearer that .NET Core was open source, not the .NET Framework. Many said .NET Core was a subset of .NET Framework.</p>
<p>.NET was first announced in 2000, as a new platform based on Internet standards. Along with it, by the end of the year, Microsoft published the <strong>Common Language Infrastructure</strong> as a standard, so that anyone who wanted, could write their own .NET framework based on those standards. .NET Framework has been the basis of Windows since the noughties.</p>
<p>Windows PowerShell was released to the general market in 2006, as an implementation of .NET Framework, focussed on system administrators (or sysadmins, to enable them to better manage their Windows workloads and automate tasks.</p>
<p>In June of 2016, Microsoft released a collaboratively refactored, more modern and efficient .NET. The .NET Core was officially born. While .NET Framework continues to rule the Windows arena, .NET Core, which is open source and cross-platform, has picked up great momentum and continues to grow. And .NET Core seems to be the way forward.</p>
<p>PowerShell (not <em>Windows</em> PowerShell) is based on .NET Core, and therefore, is open source, with the same vision as .NET Core to be cross-platform.</p>
<p>In this chapter, we will look at a very simple implementation of .NET Core and compare it to the output of PowerShell to prove that PowerShell is nothing but encapsulated .NET Core code. Along with it, we shall look at the general behaviour of PowerShell as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dissecting a .NET Core Object</h1>
                </header>
            
            <article>
                
<p>.NET Core works on a cross-platform standard Common Language Infrastructure. Therefore, it has been possible to encapsulate the internal workings of Linux using .NET Core. As we would see in the future chapters, PowerShell is object-oriented, just like .NET Core. For this demonstration, we would pick a simple system class, called <kbd>System.IO.DirectoryInfo</kbd> to show information about a certain directory. We will also compare the output .NET Core object to the output of a PowerShell cmdlet which also shows information about a certain directory.</p>
<div class="mce-root packt_tip">You do not have to remember the names of the .NET Core classes, methods or their syntaxes to work with PowerShell; that's the whole point of the existence of PowerShell.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>If you followed along the last chapter, you should already have PowerShell installed on your Linux computer; open a terminal window and type in <kbd>pwsh</kbd> to invoke PowerShell.</p>
<p class="mce-root">Every <strong>object</strong> has members—<strong>properties</strong> and <strong>methods</strong>. In case you're new to the concepts of Object Oriented Programming, properties are qualities of an object (what the object has), and methods are the capabilities of an object (what the object can do). Therefore, to quote (arguably) the most overused example of properties and methods: If a horse is an object, its height, its colour, etc. would be its properties; galloping, eating, etc. would be the methods that the object supports.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>With PowerShell, .NET Core is also installed as a dependency. Let us create an object in PowerShell, which would call a .NET class and its default constructor. This constructor requires an argument.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; New-Object -TypeName System.IO.DirectoryInfo -ArgumentList '/home/ram'</pre>
<ol start="2">
<li>This gives us information on the directory specified, like so:</li>
</ol>
<pre style="padding-left: 90px">Mode                LastWriteTime         Length Name            <br/>----                -------------         ------ ----            <br/>d-----          5/16/18  11:03 AM                ram</pre>
<ol start="3">
<li>There is a cmdlet in PowerShell,  called, <kbd>Get-Item</kbd>, which gives us details about a directory. Let us call this cmdlet with the same argument as before, and see what we get.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Item '/home/ram'<br/><br/>    Directory: /home<br/><br/>Mode                LastWriteTime         Length Name            <br/>----                -------------         ------ ----            <br/>d-----          5/16/18  11:03 AM                ram</pre>
<ol start="4">
<li>Close! Let us now look at the <em>details</em> of the output object we just received, using the <kbd>Get-Member</kbd> cmdlet on the output of <kbd>Get-Item</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Item '/home/ram' | Get-Member</pre>
<div class="mce-root packt_tip"><kbd>Get-Member</kbd> shows all the members available in the output object (most PowerShell cmdlets return objects as output, not plain text). For more information, run <kbd>Get-Help Get-Member</kbd>.</div>
<div>
<p style="padding-left: 60px">This would list a series of members that are part of the output. We're primarily concerned about the very first line for now.</p>
<pre style="padding-left: 90px">PS&gt; Get-Item '/home/ram' | Get-Member<br/><br/>   TypeName: System.IO.DirectoryInfo<br/><br/>Name                      MemberType     Definition<br/>----                      ----------     ----------<br/>LinkType                  CodeProperty   System.String LinkType{get=GetLinkType;}<br/>Mode                      CodeProperty   System.String Mode{get=Mode;}<br/>.<br/>.<br/>.</pre></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Notice the very first line of the output, <kbd>TypeName: System.IO.DirectoryInfo</kbd>. That is the exact type name we used when creating the .NET object.</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/c1e7e64f-6963-4c88-9e96-ee87651fba00.png" width="2312" height="1334"/></div>
<p>This proves that the same task of showing information on the current working directory can be achieved by calling a .NET constructor, or by running a PowerShell cmdlet. Therefore, we infer that PowerShell cmdlets are simply encapsulated .NET code, simplified to enable administrators to work with computers, without having to worry about the underlying .NET code.</p>
<p>In essence, <kbd>Get-Item</kbd> calls the <kbd>System.IO.DirectoryInfo</kbd> class under the hood, with the arguments passed along with the cmdlet.</p>
<div class="packt_tip"><kbd>Get-Item</kbd> can be used with any location in your file system. As long as you are authorised to access the location, PowerShell would return information about the location you pass as the argument.</div>
<p class="mce-root">Like they say:</p>
<p class="mce-root">If the C# guys can do it, so can you.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Read the output of the <kbd>Get-Item | Get-Member</kbd> command to understand what more information you can get about the directory you specify. Also, after we are comfortable using the <kbd>Select-Object</kbd> cmdlet, we should be able to call specific fields from the returned objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>The .NET class, <a href="https://msdn.microsoft.com/en-us/library/system.io.directoryinfo(v=vs.110).aspx" target="_blank">System.IO.DirectoryInfo</a> (Microsoft Developer Network)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Breaking down an output into different objects</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw that an object can have properties as well as methods. These properties and methods are known as members. In the object oriented approach to programming (and by extension, administration using PowerShell), it is possible to reference these properties as well as methods of an object using the <strong>member access operator</strong>, which is a single dot (<kbd>.</kbd>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Ideally, this recipe should be an extension to the previous. If you did not run the previous commands, it is suggested that you do, and then proceed with the steps below.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Look at the output of the following command from the previous recipe:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Item '/home/ram' | Get-Member</pre>
<p style="padding-left: 60px">The output table contains the name of the member, the type and the definition. Take a look at the <kbd>MemberType</kbd> column; you have <kbd>Method</kbd>, and different kinds of properties such as <kbd>CodeProperty</kbd> and <kbd>Property</kbd>.</p>
<ol start="2">
<li>Assume that we would like to see when my home directory was last written to. We would refer to this property using the member access operator. To do this, simply enclose in parenthesis the <kbd>Get-Item</kbd> command along with its argument and refer to the property using the dot operator.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Item /home/ram).LastWriteTime<br/><br/>Wednesday, 18 May 2018 11:01:02</pre>
<ol start="3">
<li>Next, let us pick the property, <kbd>Parent</kbd>, of the object. This should give us the details of the directory which my home directory resides in.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Item /home/ram).Parent<br/><br/>Mode                LastWriteTime         Length Name<br/>----                -------------         ------ ----<br/>d-r---       03/05/2018     17:07                home</pre>
<p style="padding-left: 60px">This output in itself is an object, which means that we can fetch last write time and other details of this returned object, just like how we did for <kbd>/home/ram</kbd>. How do we see when the parent folder (<kbd>/home</kbd>) was created?</p>
<ol start="4">
<li>First, let us use the <kbd>Get-Member</kbd> cmdlet on this object and see the <kbd>TypeName</kbd> of the returned object.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Item /home/ram).Parent | Get-Member<br/><br/>   TypeName: System.IO.DirectoryInfo</pre>
<p style="padding-left: 60px">It is the same as <kbd>Get-Item</kbd> itself. Therefore, any of the members of <kbd>Get-Item /home/ram</kbd> apply to <kbd>(Get-Item /home/ram).Parent</kbd> as well.</p>
<ol start="5">
<li>Now call the <kbd>CreationTime</kbd> property on the parent object. Simply add a dot next to <kbd>Parent</kbd>, and call the <kbd>CreationTime</kbd> property.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Item /home/ram).Parent.CreationTime<br/><br/>Thursday, 3 May 2018 17:07:38</pre>
<p style="padding-left: 60px">The <kbd>CreationTime</kbd> property is an object in itself, of the type, <kbd>DateTime</kbd>. Therefore, you can perform date and time operations on this object.</p>
<div class="packt_tip">PowerShell is not case-sensitive most of the time. However, it is recommended we stick to the conventions in order to minimise errors. Especially since case sensitivity is a convention in Linux. Properties could be of different data types. The data type can be seen in the <kbd>Definition</kbd> column.</div>
<ol start="6">
<li>Let us look at the members of the <kbd>CreationTime</kbd> object to see if we can further filter the output.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Item /home/ram).Parent.CreationTime | Get-Member<br/><br/>   TypeName: System.DateTime</pre>
<ol start="7">
<li>Let us pick only the year property from this object.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Item /home/ram).Parent.CreationTime.Year<br/>2018</pre>
<p>This concludes picking properties from within the returned objects. Next, let us use a method from within the returned object and create a sub-directory under <kbd>/home/ram</kbd>.</p>
<ol>
<li>First, list out the existing directories under the directory. This is done using the cmdlet, <kbd>Get-ChildItem</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem /home/ram<br/><br/><br/>    Directory: /home/ram<br/><br/><br/>Mode                LastWriteTime         Length Name<br/>----                -------------         ------ ----<br/>d-----       06/04/2018     13:05                Desktop<br/>d-----       18/05/2018     16:01                Documents<br/>d-----       18/05/2018     16:01                Downloads<br/>d-----       06/04/2018     13:05                Music<br/>d-----       19/05/2018     11:07                Pictures<br/>d-----       06/04/2018     13:05                Public<br/>d-----       06/04/2018     13:05                Templates<br/>d-----       10/04/2018     03:41                Videos</pre>
<div class="packt_tip"><kbd>Get-Item</kbd> gives you details about the directory itself. In essence, this cmdlet deals with the current item at hand. Therefore, you have properties and methods that align with that intention. Child items, on the other hand, mean the files and directories that are <em>within</em> the said item.</div>
<ol start="2">
<li>That is a list of standard directories in a user profile. Let us now create a sub-directory within this profile folder, using a method in <kbd>Get-Item</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Item /home/ram).CreateSubdirectory('test-directory')</pre>
<div class="packt_tip">To know what argument a certain method accepts, look in the <kbd>Definition</kbd> column of the output of <kbd>Get-Member</kbd>. In case of <kbd>CreateSubdirectory</kbd>, the definition is <kbd>System.IO.DirectoryInfo CreateSubdirectory(string path)</kbd>.</div>
<p style="padding-left: 60px">You should now get a confirmation.</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d5608bd8-b8e8-471a-8413-8002dc6cf776.png" width="2312" height="1284"/></div>
<ol start="3">
<li>Excellent. Now, list out the directories under the home directory.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem /home/ram<br/><br/><br/>    Directory: /home/ram<br/><br/><br/>Mode                LastWriteTime         Length Name<br/>----                -------------         ------ ----<br/>d-----       06/04/2018     13:05                Desktop<br/>d-----       18/05/2018     16:01                Documents<br/>d-----       18/05/2018     16:01                Downloads<br/>d-----       06/04/2018     13:05                Music<br/>d-----       19/05/2018     11:07                Pictures<br/>d-----       06/04/2018     13:05                Public<br/>d-----       06/04/2018     13:05                Templates<br/>d-----       19/05/2018     13:31                test-directory<br/>d-----       10/04/2018     03:41                Videos</pre>
<p style="padding-left: 60px" class="mce-root">We can now see the new directory that we created using the <kbd>CreateSubdirectory</kbd> method.</p>
<div class="packt_infobox">Running <kbd>Get-ChildItem</kbd>, as you may notice, is similar to running the <kbd>GetDirectories</kbd> and <kbd>GetFiles</kbd> methods of the object returned by <kbd>Get-Item</kbd>. This is another example of encapsulation in .NET Core.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Using the properties and methods within a returned object is simple. Objects from within the output returned by a cmdlet can be called using the member access operator directly on the command (cmdlet including the parameter).</p>
<p>Calling properties after the member access operator fetches the data that's held within the property. In our case, it was the <kbd>LastWriteTime</kbd>.</p>
<p>Methods are functions. They may or may not require an argument. The <kbd>CreateSubdirectory</kbd> method requires a string argument, which is the name (or path) of the sub-directory we wish to create—whatever we enter in the parenthesis essentially forms the path we wish to create. In case of methods that can run without an argument, they need to be called with empty parenthesis following the name of the method, like <kbd>ToString()</kbd>, for example.</p>
<p>When we pass the string argument into <kbd>CreateSubdirectory</kbd>, the method runs a .NET Core routine and creates a sub-directory within the directory we specify with <kbd>Get-Item</kbd>. The internal workings of the .NET Core is beyond the scope of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe: Selecting objects via the pipeline</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Parsing input from text to object</h1>
                </header>
            
            <article>
                
<p>Moving to the object model from text could seem a little daunting at first. However, with PowerShell, it is not very hard to switch to the new model, especially given that PowerShell can convert text into objects given the right tools. In this recipe, we would look at two of the ways that PowerShell converts textual data into objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Before we dive into the recipe, let us give ourselves a little introduction on how text-to-object parsing is handled. One way is to use .NET's built-in functionality, and the second one that we discuss involves using a cmdlet to perform the conversion based on a delimiter.</p>
<p>The basic requirement for this recipe is simple: you simply need PowerShell installed on your computer. We will edit the file within PowerShell. If you would be comfortable using a text editor instead, that works as well. Most Linux distributions pack a text editor. If not, use your package manager to install Vim, Nano, Gedit, Visual Studio Code, Atom or any other text/code editor.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We shall first look at converting text into an object from plain text input at the terminal. This involves using what is known as a <strong>PowerShell Type Accelerator</strong>. A PowerShell Type Accelerator is a an alias for .NET classes. Using these, we can call .NET classes and use many of their functionalities within PowerShell.</p>
<ol>
<li>Let us take plain text as input and convert the text into a date object. To check what sort of object your input is, use the <kbd>Get-Member</kbd> cmdlet.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; '21 June 2018' | Get-Member</pre>
<div class="packt_tip">Enclosing any text within single quotes defines the text as a <strong>non-expanding literal string</strong>. No explicit definition is required in this case, in PowerShell.</div>
<ol start="2">
<li>The <kbd>TypeName</kbd> says, <kbd>System.String</kbd>. This confirms that what we entered was plain text. Let us now use a Type Accelerator and convert this text into a <kbd>DateTime</kbd> object. The accelerator for this purpose is <kbd>[DateTime]</kbd>; place this accelerator before the literal string.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; [DateTime]'21 June 2018'<br/><br/>Thursday, 21 June 2018 00:00:00</pre>
<ol start="3">
<li>Next, find the <kbd>TypeName</kbd> of the object that was returned.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; [DateTime]'21 June 2018' | Get-Member<br/><br/>   TypeName: System.DateTime</pre>
<p style="padding-left: 60px">Voila, the string has been successfully parsed into date and time!</p>
<ol start="4">
<li>It is also possible to achieve the same result with the cmdlet, <kbd>Get-Date</kbd>, when it is called with the text argument.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date '21 June 2018'<br/><br/>Thursday, 21 June 2018 00:00:00</pre>
<ol start="5">
<li>Similarly, the <kbd>TypeName</kbd> would be:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date '21 June 2018' | Get-Member<br/><br/>   TypeName: System.DateTime</pre>
<ol start="6">
<li>Just like we did in the previous recipe, we can now manipulate the object to show information in a more meaningful way. For instance, if you care only about the year, you would write:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Date '21 June 2018').Year<br/>2018</pre>
<p>The other way of converting text into an object is to use cmdlets that perform such tasks. PowerShell packs a few converter cmdlets, one of which is <kbd>Import-Csv</kbd>. You may have noticed that PowerShell usually sends out output in a tabular format. This is a simple representation of objects. And <kbd>Import-Csv</kbd> converts data in delimited row-and-column structure into objects, where each row is an instance of the object itself, and each column is a property of the object.</p>
<ol>
<li>To demonstrate this, let us create a CSV file with the following content in it. At the PowerShell prompt, type:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; @'</pre>
<ol start="2">
<li>This would take you to the next line; PowerShell is expecting input. Paste the following sample content at the prompt.</li>
</ol>
<pre style="padding-left: 90px">WS,CPU,Id,SI,ProcessName<br/>161226752,23.42,1914,1566,io.elementary.a<br/>199598080,77.84,1050,1040,gnome-shell<br/>216113152,0.67,19250,1566,atom<br/>474685440,619.05,1568,1566,Xorg<br/>1387864064,1890.29,15720,1566,firefox</pre>
<ol start="3">
<li>Go to the next line and enter the following at the <kbd>&gt;&gt;</kbd> prompt:</li>
</ol>
<pre style="padding-left: 90px">'@ | Out-File sample.csv</pre>
<div class="packt_tip">You could perform the same operation using the <kbd>touch</kbd> command and the text editor of your choice. The goal is to get the content into the sample file.</div>
<ol start="4">
<li>Next, read the contents of the file using PowerShell.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Content ./sample.csv<br/>WS,CPU,Id,SI,ProcessName<br/>161226752,23.42,1914,1566,io.elementary.a<br/>199598080,77.84,1050,1040,gnome-shell<br/>216113152,0.67,19250,1566,atom<br/>474685440,619.05,1568,1566,Xorg<br/>1387864064,1890.29,15720,1566,firefox</pre>
<ol start="5">
<li>That looks like simple text. Let us look at the type name of the object to confirm that this is indeed plain text. Type in:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Content ./sample.csv | Get-Member<br/><br/>   TypeName: System.String</pre>
<ol start="6">
<li>That is plain and simple string. Let us now convert the content into a simple object. This is done using <kbd>Import-Csv</kbd>.</li>
</ol>
<pre style="padding-left: 90px">Import-Csv ./sample.csv</pre>
<p style="padding-left: 60px">That should give you a list-like output.</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/421790f7-a304-47d2-8a53-8d8b24057760.png" width="2312" height="1284"/></div>
<ol start="7">
<li>To confirm the output is objects, list out its members.</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/2ce2642a-5e63-4f99-85ca-3dcba5ee4bcb.png" width="2312" height="1284"/></div>
<p style="padding-left: 60px">In general, the content is a custom object, as denoted by <kbd>PSCustomObject</kbd>. The columns we had in the CSV are of type <kbd>NoteProperty</kbd>, as shown by <kbd>MemberType</kbd>.</p>
<p style="padding-left: 60px">A <kbd>NoteProperty</kbd> is a generic property, whose characteristics are similar to string. While most properties are inherited from .NET, <kbd>NoteProperty</kbd> is custom-created within PowerShell, as a name-value pair.</p>
<ol start="8">
<li>If you would rather look at the content as a table, format the content as a table.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Import-Csv ./sample.csv | Format-Table</pre>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/653c86b0-0db0-4230-9e4d-86c4a23a5109.png" width="2312" height="1284"/></div>
<p>That brings us to the end of this recipe. We have successfully converted text into an object. However, note that this is just a simple conversion, and that the output of <kbd>Import-Csv</kbd> is still string-like. Although, all of the content is now objects, which are easier to handle in PowerShell.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Type Accelerators are another form of encapsulation of .NET code in PowerShell. Remember the first recipe in this chapter wherein we created a .NET object within PowerShell. We used the PowerShell command, <kbd>New-Object -TypeName System.IO.DirectoryInfo -ArgumentList '/home/ram'</kbd> to get information on a home directory: we created a new instance of <kbd>System.IO.DirectoryInfo</kbd>, and passed an argument to it. That was a lot of code to write. To accelerate the process, we could use, <kbd>[IO.DirectoryInfo]'/home/ram'</kbd>, (<kbd>System</kbd> is the default namespace; PowerShell would understand it without us explicitly mentioning it when calling accelerators) which outputs the same object as the former command.</p>
<p>With <kbd>Import-Csv</kbd> on the other hand, the process was a simple conversion of data from text into name-value pairs. This is similar to using <kbd>ConvertFrom-Text</kbd> with a <kbd>Delimiter</kbd> parameter. This way, we instruct PowerShell to convert each row of text into instances of the object: The first row in the row-column structure is taken as the property name, and the rest of the rows are data. The cells are separated using  delimiter, which was a comma, in case of the CSV file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Look for more conversion cmdlets built into PowerShell. This can be done using the command, <kbd>Get-Command -Verb ConvertFrom</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>More about Type Accelerators in the <a href="https://blogs.technet.microsoft.com/heyscriptingguy/2013/07/08/use-powershell-to-find-powershell-type-accelerators/" target="_blank">Hey, Scripting Guy! Blog</a>.</li>
<li>Recipe: Using Here strings.</li>
<li>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.psmembertypes?view=pscore-6.0.0" target="_blank">different kinds of members</a> in PowerShell.</li>
<li>Best Practices Roundup: Formatting only in the end.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Comparing the outputs of Bash and PowerShell</h1>
                </header>
            
            <article>
                
<p>PowerShell and Bash are both shells, and are capable of interacting with the kernel. Just like how Bash can run on Windows, PowerShell can now run on Linux. While almost all of the aspects of which shell is better than the other is debatable, and the choice of shell is simply a matter of personal preference today, it is true that PowerShell is as powerful as .NET Core can get.</p>
<p>The primary difference between the two shells is, like we have seen before, that PowerShell outputs objects, while Bash returns text. Manipulation of the output in Bash involves manipulating text first, and then running further commands on the manipulated text to fetch the desirable output. PowerShell, on the other hand, handles content as objects and by design, requires comparatively less manipulation.</p>
<p>Structured data, as noted by Jeffrey Snover (the inventor of Windows PowerShell), is getting popular as days pass, and structured data is where PowerShell shines the most.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we are going to pick one example to show how simple and efficient it is to handle file metadata using PowerShell, primarily since the output is an object. We will list the files and folders within our home directory, along with the date and time of modification using both, <kbd>ls</kbd> in Bash and <kbd>Get-ChildItem</kbd> in PowerShell.</p>
<p>Open up two instances of the terminal if you would so like: launch <kbd>pwsh</kbd> on one.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>At the Bash prompt, enter <kbd>ls -l</kbd> to list out all the files along with the metadata that the command shows by default.</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/eaf2fd5f-b91c-43ce-8e94-a7f1d764df1e.png" width="1812" height="1004"/></div>
<ol start="2">
<li>Go to the terminal that has PowerShell running, and type in <kbd>Get-ChildItem</kbd> at the prompt.</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/b2226dc9-7aae-4763-a1ec-249384383e49.png" width="1812" height="1004"/></div>
<ol start="3">
<li>Now, let us pick only the name of the folders and the last-modified date and time. This is done in Bash by passing the output of <kbd>ls -l</kbd> to <kbd>awk</kbd>.</li>
</ol>
<pre style="padding-left: 90px">ls -l | awk '{print $6, $7, $8, $9}'</pre>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f56c057d-072d-4881-a844-5885d5270466.png" width="1812" height="1094"/></div>
<ol start="4">
<li>Next, let us pick the same information on PowerShell as well.</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem | select LastWriteTime, Name</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/94508b98-e2da-4f79-b637-8753329401cf.png" width="1812" height="1004"/></div>
<p style="padding-left: 60px">If you notice, the output is very similar in both the cases, however, with PowerShell, you see the names of the columns as well, which means that you don't have to look for further documentation. Also, the selection of columns is simpler in PowerShell; no text manipulation is required. On the other hand, in Bash, we use the <kbd>awk</kbd> command to manipulate the text output.</p>
<ol start="5">
<li>Let's go one step further and create a sub-directory with a space in the name.</li>
</ol>
<pre style="padding-left: 90px">$ mkdir 'test subdirectory'<br/>$ ls -l | awk '{print $6, $7, $8, $9}'</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/60488ba8-6c4c-45d1-b5bf-145f2fc1134f.png" width="1812" height="1094"/></div>
<p style="padding-left: 60px">Notice that what should have been <kbd>test subdirectory</kbd>, appears as <kbd>test</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>PowerShell reads content from the file system as objects, not as text. Therefore, you perform a selection of the desired columns (or as we shall later see, properties) directly. Bash, on the other hand, outputs text, columns from which are manipulated using a delimiter.</p>
<p>To demonstrate that this is the case, we created a new subdirectory with a space in its name, and we performed the column selection same as before, only in this case, we did not get the complete name of the new subdirectory, because the name contained a white space, which is a delimiter in <kbd>awk</kbd>.</p>
<div class="packt_tip">Comparing Bash and PowerShell is like comparing apples and oranges—in more ways than one. However, understanding the differences helps us leverage each of the tools to our benefit.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe: Selecting objects via the pipeline.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Comparing Windows PowerShell and PowerShell</h1>
                </header>
            
            <article>
                
<p>PowerShell and Windows PowerShell are two different implementations. The former is based on a larger framework, the .NET Framework. The latter, on the other hand is a more modern framework, the .NET Core. PowerShell is cross-platform since its parent is. Windows PowerShell, on the other hand, is Windows-only, but has more capabilities than PowerShell, as of writing this chapter.</p>
<div class="packt_tip">The PowerShell that this book talks about is the cross-platform PowerShell Core. This is referred to as <em>PowerShell</em>. The PowerShell that is Windows-specific is referred to as <em>Windows PowerShell</em>.</div>
<p>Windows PowerShell leverages the internal components and the architectural model of Windows with its capabilities enhanced by WinRM as well as Windows Management Instrumentation. In fact, most of the differences exist because of the inherent differences between Windows and Unix-like operating systems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Support for snap-ins</h1>
                </header>
            
            <article>
                
<p>PowerShell will not support the legacy version of modules, called <strong>Snap-ins</strong>. Many of the snap-ins of old have been repackaged to be binary modules, and therefore, this should not be much of a concern, because future development of these should in theory work on either PowerShell, provided the system calls in the binaries can work on the system the binary is running on. For example, even if the Windows Active Directory module were repackaged into a binary PowerShell module, it would run on Windows PowerShell as well as PowerShell on Windows, but not on PowerShell on Linux because Windows Active Directory does not run on Linux.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Convenience aliases</h1>
                </header>
            
            <article>
                
<p>One important point to note is that commands like <kbd>ls</kbd> and <kbd>mkdir</kbd> are aliases in Windows PowerShell, which means, running <kbd>ls</kbd> on Windows PowerShell would run <kbd>Get-ChildItem</kbd> in the background (this is also true for PowerShell on Windows). In Linux, however, running <kbd>ls</kbd> from within PowerShell would run the actual <kbd>ls</kbd> command; <kbd>ls</kbd> is not an alias in PowerShell on Linux, it is the command itself, whose output would be plain text. You can validate this by running <kbd>ls | Get-Member</kbd> on PowerShell on Linux, and compare it with PowerShell on Windows as well as Windows PowerShell. (It is, therefore, good to stick to the best practice of not using aliases in scripts.)</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f38b4dcd-f484-4673-9559-92e752c14a42.png" width="1812" height="1014"/></div>
<div class="packt_infobox">PowerShell knows whether it is running on Linux, Windows or Mac OS by means of the values of the automatic variables, <kbd>IsLinux</kbd>, <kbd>IsWindows</kbd> and <kbd>IsMacOS</kbd>. On any system, only one of these variables has the value, <kbd>True</kbd>. When PowerShell sees that <kbd>IsLinux</kbd> is <kbd>True</kbd>, it would run Linux commands instead of the convenience aliases that were initially created to facilitate Linux administrators. For more information on these automatic variables, read the recipe, <em>Configure built-in variables</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PowerShell Workflows</h1>
                </header>
            
            <article>
                
<p>Windows administrators who are used to PowerShell Workflows in Windows PowerShell need to note that they are absent in PowerShell. PowerShell Workflows were a little advanced, (to put it nicely), and were used in specific scenarios, where multiple cmdlets were to be run in parallel, or activities had to, say, survive a reboot. Workflows work on the Windows Workflow Foundation, which isn't cross-platform. Therefore, PowerShell Workflows will not run on PowerShell. Understand, though, that this is no loss at all.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PowerShell Desired State Configuration</h1>
                </header>
            
            <article>
                
<p>Desired State Configuration is work-in-progress as of writing this chapter. As of now, there are two codebases of DSC resources: LCM for Linux, which is managed by Microsoft's Unix team, and the other, DSC Resources for Windows PowerShell written by the PowerShell team. It would be some time before the DSC codebase becomes cross-platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Listing out the aliases and using them in place of cmdlets</h1>
                </header>
            
            <article>
                
<p>Aliases, as the meaning goes, are alternative names to cmdlets. They serve two purposes:</p>
<ol>
<li>Reduce the number of keystrokes</li>
<li>Make the transition to PowerShell smoother</li>
</ol>
<p>Traditionally, aliases were created in PowerShell so that Windows and Linux administrators did not find the new framework intimidating to work with. Regardless, aliases are best used only on the command line, and not in scripts, because some aliases are not aliases in Linux, and in general, aliases affect readability. (For instance, it would take conscious effort to realise that <kbd>gbp</kbd> stands for <kbd>Get-PSBreakPoint</kbd>.)</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Now that the best practice has been looked at, let us now look at listing out all the aliases in the system. Like already mentioned, it is simple to think in PowerShell. When we know that the verb to fetch any information is <kbd>Get</kbd>, and the noun in this case would be <kbd>Alias</kbd>, the cmdlet could be <kbd>Get-Alias</kbd>.</p>
<ol>
<li>Running a quick <kbd>Get-Command</kbd> on <kbd>Get-Alias</kbd> would tell us whether there indeed is such a cmdlet.</li>
</ol>
<pre style="padding-left: 90px">Get-Command Get-Alias</pre>
<ol start="2">
<li>Let us now run <kbd>Get-Help</kbd> to understand how to use the cmdlet.</li>
</ol>
<pre style="padding-left: 90px">Get-Help Get-Alias</pre>
<div class="packt_tip">If you're unsure about any command, or would like to reduce keystrokes without involving aliases, use tab-completion. Write a part of the cmdlet or parameter, and press the Tab key. PowerShell will complete the command for you, or show you suggestions, based on which platform you're doing this on.</div>
<ol start="3">
<li>According to the help documentation, all the parameters for <kbd>Get-Alias</kbd> are optional (they are all enclosed in <kbd>[]</kbd>). Therefore, simply running <kbd>Get-Alias</kbd> would give us a list of all the aliases available in the current instance of PowerShell.</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/1365c009-4f5b-4083-9ee8-257073c8a995.png" width="1812" height="1014"/></div>
<ol start="4">
<li>Let us now try to resolve the alias, <kbd>gbp</kbd> to the PowerShell cmdlet that it actually runs.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Alias gbp<br/><br/>CommandType     Name                                               Version    Source<br/>-----------     ----                                               -------    ------<br/>Alias           gbp -&gt; Get-PSBreakpoint</pre>
<ol start="5">
<li>Let us now look at how to do the opposite: get the alias for a certain cmdlet. If you read the help documentation for this cmdlet, you'd see a parameter called <kbd>Definition</kbd> in the second parameter set. This is the actual PowerShell cmdlet that runs when an alias is called.</li>
</ol>
<pre style="padding-left: 90px">PS /home/ram&gt; Get-Alias -Definition Get-ChildItem<br/><br/>CommandType     Name                                               Version    Source<br/>-----------     ----                                               -------    ------<br/>Alias           dir -&gt; Get-ChildItem                                          <br/>Alias           gci -&gt; Get-ChildItem</pre>
<ol start="6">
<li>We can see two aliases as output, both of which run <kbd>Get-ChildItem</kbd> under the hood. Let us now run <kbd>dir</kbd> as well as <kbd>Get-ChildItem</kbd> and compare their outputs.</li>
</ol>
<pre style="padding-left: 90px">PS /home/ram&gt; dir<br/><br/>    Directory: /home/ram<br/><br/>Mode                LastWriteTime         Length Name<br/>----                -------------         ------ ----<br/>d-----       06/04/2018     13:05                Desktop<br/>d-----       18/05/2018     16:01                Documents<br/>d-----       18/05/2018     16:01                Downloads<br/>d-----       06/04/2018     13:05                Music<br/>d-----       20/05/2018     02:17                Pictures<br/>d-----       06/04/2018     13:05                Public<br/>d-----       06/04/2018     13:05                Templates<br/>d-----       10/04/2018     03:41                Videos<br/>PS /home/ram&gt; Get-ChildItem<br/><br/>    Directory: /home/ram<br/><br/><br/>Mode                LastWriteTime         Length Name<br/>----                -------------         ------ ----<br/>d-----       06/04/2018     13:05                Desktop<br/>d-----       18/05/2018     16:01                Documents<br/>d-----       18/05/2018     16:01                Downloads<br/>d-----       06/04/2018     13:05                Music<br/>d-----       20/05/2018     02:20                Pictures<br/>d-----       06/04/2018     13:05                Public<br/>d-----       06/04/2018     13:05                Templates<br/>d-----       10/04/2018     03:41                Videos</pre>
<ol start="7">
<li>The two outputs are identical. Let us now look at what type of object the commands return.</li>
</ol>
<pre style="padding-left: 90px">PS /home/ram&gt; dir | Get-Member<br/><br/>   TypeName: System.IO.DirectoryInfo<br/><br/>Name                      MemberType     Definition<br/>----                      ----------     ----------<br/>LinkType                  CodeProperty   System.String LinkType{get=GetLinkType;}<br/>Mode                      CodeProperty   System.String Mode{get=Mode;}<br/>...<br/>PS /home/ram&gt; Get-ChildItem | Get-Member<br/><br/>   TypeName: System.IO.DirectoryInfo<br/><br/>Name                      MemberType     Definition<br/>----                      ----------     ----------<br/>LinkType                  CodeProperty   System.String LinkType{get=GetLinkType;}<br/>Mode                      CodeProperty   System.String Mode{get=Mode;}<br/>...</pre>
<p style="padding-left: 60px">They returned the same object as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Aliases are nothing but mappings done within PowerShell. The short words are mapped to PowerShell cmdlets, identified by the <kbd>Definition</kbd> property in each of the aliases. Therefore, you can use the aliases to in place of full cmdlets. Aliases also support the same parameters as the cmdlet as well, since aliases are merely pointers to the right cmdlet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Best Practices Roundup</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a Custom Alias</h1>
                </header>
            
            <article>
                
<p>Aliases, as we saw in the previous recipe, are simply pointers to actual PowerShell cmdlets, and therefore, creating custom alias simply involves identifying a word for the alias you'd like to create, and map it to the PowerShell cmdlet that you'd like to call.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, identify a word that you'd like to use as the alias. For example, let us consider <kbd>listdir</kbd>.</li>
<li>Run listdir on PowerShell to ensure such a cmdlet (or a Linux command) does not already exist.</li>
<li>List out the cmdlets that deal with aliases, by running:</li>
</ol>
<pre style="padding-left: 90px">Get-Command -Noun Alias</pre>
<div class="packt_tip">Remember that the nouns in PowerShell are singular. Therefore, there would be no first-party cmdlet that contains <kbd>Aliases</kbd>. If third party modules give you <kbd>Aliases</kbd> as a noun in them, they are not following the PowerShell best practice of using only singular nouns.</div>
<ol start="4">
<li><kbd>New-Alias</kbd> is the cmdlet we are looking for, since it creates a new alias. (<kbd>Set-Alias</kbd> is used to modify an alias that already exists.)</li>
<li>Read the help documentation for <kbd>New-Alias</kbd> by running:</li>
</ol>
<pre style="padding-left: 90px">Get-Help New-Alias</pre>
<p style="padding-left: 60px">The help document indicates that only the Name and the Value parameters are mandatory. We shall use only the two to create this simple alias.</p>
<ol start="6">
<li>Run the following to create the custom alias:</li>
</ol>
<pre style="padding-left: 90px">New-Alias listdir Get-ChildItem</pre>
<ol start="7">
<li>See whether the alias was created as desired or not.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Alias listdir<br/><br/>CommandType     Name                                               Version    Source<br/>-----------     ----                                               -------    ------<br/>Alias           listdir -&gt; Get-ChildItem</pre>
<ol start="8">
<li>Also, run the alias to see what output it gives.</li>
</ol>
<pre style="padding-left: 90px">PS /home/ram&gt; listdir<br/><br/>    Directory: /home/ram<br/><br/>Mode                LastWriteTime         Length Name<br/>----                -------------         ------ ----<br/>d-----          4/20/18   6:36 AM                Desktop<br/>d-----          5/10/18   1:05 PM                Documents<br/>d-----          5/16/18  11:03 AM                Downloads<br/>d-----          4/20/18   6:36 AM                Music<br/>d-----           5/1/18   2:19 PM                Pictures<br/>d-----          4/20/18   6:36 AM                Public<br/>d-----          4/20/18   6:36 AM                Templates<br/>d-----          4/20/18   6:36 AM                Videos</pre>
<p style="padding-left: 60px">That is the output that we are familiar with–the output of <kbd>Get-ChildItem</kbd>.</p>
<div class="packt_infobox">Aliases are ephemeral by default. They exist only as long as your PowerShell session exists. To use custom aliases without having to recreate them each time, export these aliases (the instructions for which are in the next recipe) and import them using your PowerShell profile. We will understand profiles in a later chapter.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Aliases, as already mentioned, are pointers to cmdlets. Using <kbd>New-Alias</kbd>, you create a pointer with a custom name, that points to the desired PowerShell cmdlet. This is simply a Name–Value pair.</p>
<p>When you run anything on PowerShell, PowerShell checks its list of cmdlets and aliases (among other definitions) to understand what you are asking for. When PowerShell encounters an alias, it looks for which cmdlet it points to, and runs the cmdlet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can add more content to your aliases, such as descriptions. Refer the help documentation for <kbd>Get-Alias</kbd> to see what more you can do with aliases.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 3.8: Understanding cmdlets and parameters</li>
<li>Recipe 2.8: Importing/Exporting custom aliases for future use</li>
<li>Recipe 3.4: Enabling automated execution of commands for each load</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Export/Import Custom Aliases for Future Use</h1>
                </header>
            
            <article>
                
<p>Aliases being ephemeral, in spite of its advantages and the intended use of aliases, could be seen as an inconvenience. In order that aliases can be reused, they need to be exported to a file and later, imported when needed. This recipe will show you how to export and import the aliases you may have created.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>You need custom aliases already created for this process to be effective. If you don't have custom aliases created, the export action would only export the default aliases, which would be loaded with PowerShell anyway.</p>
<p>Go to the previous recipe to create at least one custom alias.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Ensure that your custom alias exists and runs properly. One way of doing this is to get details about the alias you created.</li>
</ol>
<pre style="padding-left: 90px">Get-Alias listdir</pre>
<ol start="2">
<li>Export all of the aliases loaded on your session to a file.</li>
</ol>
<pre style="padding-left: 90px">Export-Alias aliases.csv</pre>
<p style="padding-left: 60px">CSV is the default file type. The import that we would see in the coming steps understands CSV and make the necessary associations.</p>
<ol start="3">
<li>It is also possible to export the aliases as a script. This way, PowerShell will create a script that would contain the New-Alias cmdlet for each of the aliases in the export.</li>
</ol>
<pre style="padding-left: 90px">Export-Alias aliases.ps1 -As Script</pre>
<ol start="4">
<li>Look at the contents of each of the files created; the CSV file first, and then the script.</li>
</ol>
<pre style="padding-left: 90px">Get-Content ./aliases.csv</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/56717d30-2937-4bac-89c4-634503efc8e8.png" width="1812" height="1044"/></div>
<pre style="padding-left: 90px">Get-Content ./aliases.ps1</pre>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img src="Images/bdf72b32-a228-470f-ac21-ad35d4e8013a.png" width="1812" height="1044"/></div>
<ol start="5">
<li>Optionally, edit the file to remove all the aliases except the ones you created. The custom aliases can be found at the bottom of the list.</li>
</ol>
<p>This concludes exporting aliases.</p>
<p>Let us now import aliases into our PowerShell session.</p>
<ol>
<li>Restart PowerShell.</li>
<li>See if the alias, <kbd>listdir</kbd>, that you created exists.</li>
</ol>
<pre style="padding-left: 90px">Get-Alias listdir</pre>
<ol start="3">
<li>Now, import the aliases.</li>
</ol>
<pre style="padding-left: 90px">Import-Alias ./aliases.csv</pre>
<div class="packt_tip">You may receive several errors, each saying that the new alias could not be created since the alias already existed. There are two ways to handle this: the first is to remove the default aliases from the export file (which is recommended), and the second is to use the <kbd>-Force</kbd> parameter (this may still result in errors, but they would be significantly fewer).</div>
<p style="padding-left: 60px">If you exported the aliases as a script, simply call the script.</p>
<pre style="padding-left: 90px">./aliases.ps1</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The script way is straight-forward: the cmdlets are run one after the other and the aliases are created in the system just like how you created them manually.</p>
<p>With the CSV import, PowerShell parses the input into the Name–Value pairs (and add other parameters based on what you exported) and add them to its alias reference for the current process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 3.4: Enabling automated execution of commands for each load</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Listing out the execution policies and setting a suitable one</h1>
                </header>
            
            <article>
                
<p>There was a time when running scripts on Windows computers was a piece of cake. Windows computers were highly prone to remote script executions. With PowerShell, Microsoft added a safety belt that allowed the user some control over how PowerShell scripts were loaded. Some specific models of script executions got restricted, which plugged some holes in the system.</p>
<div class="packt_infobox">It is important to remember that execution policies are <strong>not</strong> a security feature. There are ways to circumvent this fence and still run scripts. Execution policies are in place to ensure users don't accidentally run scripts without awareness.</div>
<p>PowerShell on Windows and Windows PowerShell contain the configuration. Running PowerShell scripts on Windows is still restricted by default. On PowerShell on Linux, this doesn't work at the moment, and based on the interactions in the community, it is uncertain whether this feature would make it to PowerShell on Linux.</p>
<p>An execution policy determines what type of execution of scripts is allowed. Here are the six execution policies (excluding Default):</p>
<ol>
<li>AllSigned</li>
<li>RemoteSigned</li>
<li>Restricted</li>
<li>Unrestricted</li>
<li>Bypass</li>
<li>Undefined</li>
</ol>
<p>There are three scopes as well:</p>
<ol>
<li>Process</li>
<li>CurrentUser</li>
<li>LocalMachine</li>
</ol>
<p>A combination of an execution policy and a scope are what determine the condition which scripts can be loaded under. Microsoft has documented in detail what each of the policies is. In general, AllSigned requires that all the scripts that run on the computer are signed using a code signing certificate by a trusted certification authority. If this policy is set, PowerShell will not run unsigned scripts even if you were the one to create them.</p>
<p><strong>Restricted</strong> is the default policy: Commands can be run, but not scripts. <strong>RemoteSigned</strong> allows scripts created on your own computer to run. Scripts that are downloaded from the Internet cannot be run.</p>
<p><strong>Bypass</strong> is similar to unrestricted, however, is used in specific scenarios such as when PowerShell forms the basis of a certain application, and the application has its own security implementation.</p>
<p><strong>Unrestricted</strong> means that all scripts and commands can run after a simple confirmation. <strong>Undefined</strong> means that no policy has been defined for a particular scope. Let us try to understand the concepts using the following recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>This recipe needs Windows to work. If you're running a pure Linux environment, you cannot work with this recipe. You may run the commands, but you would see the Unrestricted policy set at all levels.</p>
<p>If you can get your hands on a Windows computer, you can proceed with this recipe regardless of whether it has PowerShell or Windows PowerShell.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Open a PowerShell window  by running <kbd>pwsh</kbd> or <kbd>powershell</kbd>. The <kbd>pwsh</kbd> command calls PowerShell, and <kbd>powershell</kbd> calls Windows PowerShell.</p>
<p>Windows PowerShell comes preinstalled on all modern Windows products; PowerShell, on the other hand, has to be installed. Note that all of the current PowerShell cmdlets will run as well on Windows PowerShell.</p>
<ol>
<li>First, run the Get-Command cmdlet to know how to work with execution policies.</li>
</ol>
<pre style="padding-left: 90px">Get-Command -Noun Execution*</pre>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img src="Images/ad67d754-eabc-404d-bf92-3014549f8ff6.png" width="2327" height="1274"/></div>
<ol start="2">
<li>Let us now get help on running the cmdlet.</li>
</ol>
<pre style="padding-left: 90px">Get-Help Get-ExecutionPolicy</pre>
<ol start="3">
<li>We want to know the execution policy set on the machine, therefore, we would run:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ExecutionPolicy</pre>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img src="Images/69fa2f0d-8c11-4129-9c73-e4967f4357b5.png" width="2327" height="1274"/></div>
<p style="padding-left: 60px">This shows the execution policy currently effective on the current PowerShell session.</p>
<ol start="4">
<li>To list out the policies set at various scopes, run the following command:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ExecutionPolicy -List</pre>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img src="Images/5db273a2-fe7e-4915-b9ad-c590063310a7.png" width="2327" height="1274"/></div>
<p style="padding-left: 60px">We see that the policy is only set at the LocalMachine level, and it is set at RemoteSigned, which is the same as that reflected in the previous step. The policy at the LocalUser and the Process scopes is Undefined, which made the session pick the execution policy from LocalMachine.</p>
<p style="padding-left: 60px">Let us now set the execution policy for the local machine to be Undefined and see what our session picks up.</p>
<ol start="5">
<li>For this to work, close the current PowerShell session and open a new session as the administrator.</li>
<li>Next, run the command:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Help Set-ExecutionPolicy</pre>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img src="Images/e039790c-5185-4b1d-96be-38b1391f12e3.png" width="2327" height="1274"/></div>
<ol start="7">
<li>The help document shows that the value of the ExecutionPolicy parameter is mandatory, and that Undefined is one of the valid values it would accept. We want to set the policy at the LocalMachine scope, therefore,</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Set-ExecutionPolicy Undefined -Scope LocalMachine</pre>
<ol start="8">
<li>Now, list out the execution policies at the various scopes:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ExecutionPolicy -List</pre>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img src="Images/7a2cad04-6a65-480e-9d9f-14d60b2a8e9b.png" width="2327" height="1274"/></div>
<ol start="9">
<li>Now, let us check the currently-effective execution policy:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ExecutionPolicy</pre>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img src="Images/91d88fe3-665a-4ea8-b9c7-1e3ab057e777.png" width="2327" height="1274"/></div>
<ol start="10">
<li>Let us now set the execution policy back to how it was before we began the recipe. You may want to change the policy to suit your needs, based on what authority you have on the computer.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Set-ExecutionPolicy RemoteSigned -Scope LocalMachine</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Execution policies are nothing but conditions set on the system to avoid accidental script runs. They work at different scopes.</p>
<p>There are three scopes in PowerShell, as noted already. The <strong>LocalSystem</strong> scope is at the end of the chain. Right above it is the <strong>CurrentUser</strong> scope. At the top, is the <strong>Process</strong> scope. The level of precedence is Process &gt; CurrentUser &gt; LocalMachine. Therefore, if any policy other than Undefined is set at the Process scope, the session would use the policy set on the process. In case it's Undefined, it would look for the policy set on the CurrrentUser scope. If CurrentUser has the policy marked as Undefined as well, the session would apply the policy applied at the LocalMachine level. If LocalMachine has Undefined set, the session would pick the Default policy, which is based on what PowerShell has defined as the policy, which may vary based on the version of operating system. On Windows 2016, for instance, the default policy is RemoteSigned.</p>
<p>The policies set at the CurrentUser and LocalMachine levels are stored in the Windows Registry. The policy set on the Process scope is stored in the ephemeral environment variable, <kbd>$env:PSExecutionPolicyPreference</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6" target="_blank">About_Execution_Policies</a> (Microsoft)</li>
</ol>


            </article>

            
        </section>
    </div>



  </body></html>