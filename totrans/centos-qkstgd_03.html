<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing Text Files</h1>
                </header>
            
            <article>
                
<p>Computer systems are mostly used for editing, manipulating, or managing data. On Linux systems, this data is very often in the form of text files. In general, everything in Linux is a file, and having a solid understanding of working with text files is important. All important information in Linux is stored in text format files.</p>
<p>In this chapter, our objective is to learn how to work with text files on the command line, using the most popular default text-based editor, vi, and other text file manipulation utilities. Then, we will learn how input/output redirection is executed in files and programs for further processing.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Different methods to create a text file</li>
<li>Editing files with the vi editor</li>
<li>Using text file manipulation tools</li>
<li>Redirecting output to files and programs</li>
<li>Using grep for text matching</li>
<li>Finding a file using the locate and find command</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Different methods to create a text file</h1>
                </header>
            
            <article>
                
<p>Text files can be viewed and edited using any text editor that exists in Linux. However, before learning the editing part, we must have a basic understanding of different ways that can be used to create plain text files. Depending on the requirement, different methods can be used for text file creation. The most popular ones are described next.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Create a text file using the cat command</h1>
                </header>
            
            <article>
                
<p>The <kbd>cat</kbd> command can be used to create a text file if we immediately want to add some text to a new blank file. The syntax of the <kbd>cat</kbd> command to create a file is as follows:</p>
<pre><strong>$ cat &gt; demo.txt</strong></pre>
<p>After pressing <em>Enter</em>, we will return to the prompt and we can directly start inserting text into our file. Once you are done entering text in <span>the </span>file, press <em>Ctrl</em> + <em>D</em> to mark the end of <span>the </span>file and return to the prompt, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9a6af930-f006-4417-9b4c-3694ed84c25b.png" style="width:19.67em;height:8.08em;" width="482" height="197"/></p>
<p>If you want to use <span>the </span><kbd>cat</kbd> command to create a file from a bash script, we have to use an operator known as a here document. It can be any arbitrary string that can be used to mark the beginning of a file and end when repeated in a new line, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/64ee8f74-e47e-45ec-807c-2385638dbacf.png" style="width:19.25em;height:9.75em;" width="513" height="261"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Create an empty text file using the touch command</h1>
                </header>
            
            <article>
                
<p>The original purpose of the <kbd>touch</kbd> command is to update a file's timestamp to the current date and time without modifying it. The <kbd>touch</kbd> command can also be used to create an empty file of size 0 bytes. We cannot enter any text in <span>the </span>file with <span>the </span><kbd>touch</kbd> command, but we can create multiple new files with a single command. It is quite often used to create files that are intended to be used in future. The syntax of the <kbd>touch</kbd> command is as follows:</p>
<pre><strong>$ touch &lt;path_for_empty_file&gt;</strong></pre>
<p>Examples of the <kbd>touch</kbd> command are shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e68599fa-72dc-4e5b-b6f0-c6f689e822b9.png" style="width:31.33em;height:8.25em;" width="665" height="175"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Create a text file using the redirection symbol (&gt;)</h1>
                </header>
            
            <article>
                
<p>We can also create a text file using <span>the </span>redirection symbol (<kbd>&gt;</kbd>), which is used to redirect the output of a command to a file. If we use <span>the </span>redirection symbol alone without prefixing it with any command, then it will create an empty file of 0 bytes and remove the file's content if a file already exists with the given name, as shown in the following command line:</p>
<pre><strong>$ &gt; demo.txt</strong></pre>
<p><span>If we prefix the redirection symbol (<kbd>&gt;</kbd>) with any command, then it creates a new file, which contains the output of the command preceding the redirection symbol, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9fc28d53-3275-458f-9cbe-7bf65110478f.png" style="width:18.25em;height:9.42em;" width="425" height="219"/></p>
<p>We can create one file at a time with <span>the </span>redirection symbol.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Create a text file using the echo or printf command</h1>
                </header>
            
            <article>
                
<p>Sometimes, it is necessary to create a short file that doesn't require us to invoke <span>the </span>full text editor. In those scenarios, <span>the </span><kbd>echo</kbd> or <kbd>printf</kbd> command is used with the redirection operator to create an empty file, or a file with a single line. This method of creating a file can be used in scripts also. Use the <kbd>echo</kbd> and <kbd>printf</kbd> command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/af920f38-673b-41be-b93b-d609dc6f43f1.png" style="width:20.75em;height:10.42em;" width="485" height="243"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Create a text file using the vi editor </h1>
                </header>
            
            <article>
                
<p>The vi editor is <span>the </span>most popular command-line editor and is the default editor in most Linux distributions. It has three modes of operation, which will be discussed later on in this chapter. To create a file with <span>the </span>vi editor, follow these steps:</p>
<ol>
<li><kbd>vi</kbd> &lt;filename&gt; and press <em>Enter</em></li>
<li>Press <em>I</em> to enter Insert Mode and add your text</li>
<li><span>Keep on adding the custom text to the file until you are done with it</span></li>
<li>Press <span>the </span><em>Esc</em> key to enter Command Mode</li>
<li>Type <kbd>:wq</kbd> and press <em>Enter</em> to save and exit</li>
</ol>
<p>The following screenshot displays a file being created in vi editor:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/aa6c4258-47f0-4374-80ba-299593649e9d.png" style="width:5.75em;height:5.83em;" width="134" height="137"/></p>
<p>Besides this method, there are other ways of creating a text file, such as using <kbd>nano</kbd>, <kbd>ed</kbd>, <kbd>joe</kbd>, <kbd>emacs</kbd>, or <kbd>pico</kbd> editors. You can try your hand at using them too.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Editing files with the vi editor</h1>
                </header>
            
            <article>
                
<p>The vi editor is the most popular editor used to edit or create new files from a shell prompt. It comes in text-based as well graphical interface form, with extended features. This text-based editor is used to write a script, edit system configuration files, or develop the source code of a programming language. The name vi is pronounced as vee-eye.</p>
<p>The <strong>vim</strong> (short for <strong>vi improved</strong>) version of the vi editor comes with many enhancements to make working with the vi editor easier. It supports extended features, such as syntax highlighting for many configuration files and programming languages. Whatever we learn about vi editor is applicable to vim also, so we will learn about <span>the </span>vi editor in this section.</p>
<p>There are three modes of operation of <span>the </span>vi editor, as follows:</p>
<ul>
<li><strong>Command Mode</strong></li>
<li><strong>Insert Mode</strong></li>
<li><strong>Line Mode</strong></li>
</ul>
<p>The following diagram shows the different modes of vi editor, along with the keys used to switch between them:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e25e9699-866d-417c-8805-2f2fb470c7de.png" style="width:48.75em;height:20.33em;" width="1027" height="429"/></p>
<p>When working with <span>the </span>vi editor, it is essential to keep track of <span>the </span>mode you are working in. Many commands and keystrokes behave differently in different modes. The following table describes the different modes and their features in brief:</p>
<table style="border-collapse: collapse;width: 733px;height: 1106px" border="1">
<tbody>
<tr>
<td style="width: 82px">
<p class="CDPAlignCenter CDPAlign"><strong>Mode</strong></p>
</td>
<td style="width: 644px">
<p class="CDPAlignCenter CDPAlign"><strong>Feature</strong></p>
</td>
</tr>
<tr>
<td style="width: 82px">Command Mode</td>
<td style="width: 644px">
<ul>
<li>By default, <kbd>vi</kbd> editor starts in Command Mode</li>
<li>Keystrokes in Command Mode are interpreted as commands to modify content</li>
<li>In this mode, you can give commands <span>to perform cut, delete, copy, and paste operations, and also use keystrokes to navigate in the file</span></li>
<li>Editing and the insertion of text are not possible in this mode</li>
</ul>
</td>
</tr>
<tr>
<td style="width: 82px">Insert Mode</td>
<td style="width: 644px">
<ul>
<li>Press the <em>I</em><span> key to switch to Insert</span> Mode <span>from Command Mode (pressing the</span> <em>I</em><span> key to get into Insert Mode is the most commonly used option; however, there are other keys too that can be pressed to get into Insert Mode from Command Mode)</span></li>
<li><span>Insert Mode is used to modify or insert text into a file</span></li>
<li>Insert Mode is indicated by<kbd>- - INSERT - -</kbd><strong> </strong><span>at the bottom of the screen</span></li>
<li><span>Press</span> <span>the </span><em>Esc</em> <span>key to exit Insert Mode and return to Command Mode</span></li>
</ul>
</td>
</tr>
<tr>
<td style="width: 82px">Line Mode</td>
<td style="width: 644px">
<ul>
<li>Press <span>the </span><em>:</em> key to switch to Line Mode from Command Mode only (we cannot switch to Line Mode from Insert Mode directly)</li>
<li>Line Mode is indicated by <span>the </span><em>:</em><strong> </strong><span>colon key at the beginning of the last line of the vi editor and the cursor is placed immediately after this colon</span></li>
<li>We can use line editing commands inherited from older line editors, such as saving the contents of a file to disk, executing shell commands, and reading other files' contents, and so on</li>
<li><span>Requires pressing</span> <span>the </span><em>Enter</em><span> key after the command for execution</span></li>
<li><span>Press</span> <span>the </span><em>Esc</em> <span>key to exit Line Mode and return to Command Mode</span></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="packt_tip">When you are in doubt and don't know your current working mode, press <span>the </span><em>Esc</em> key twice and you will be back in Command Mode.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with files in vi editor</h1>
                </header>
            
            <article>
                
<p>To start the <kbd>vi</kbd> editor and edit the file, use the following syntax:</p>
<pre><strong>$ vi &lt;filename&gt;</strong></pre>
<p>If the file exits with the specified filename, it will be opened and its contents are displayed in Command Mode. If the file does not exist, <kbd>vi</kbd> creates the file when it is saved on the disk for the first time. By default, <kbd>vi</kbd> uses an unnamed temporary buffer where <span>the </span>file is edited, until its contents are saved to disk. Now, let's understand the workings of <kbd>vi</kbd> in different modes in detail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Insert Mode</h1>
                </header>
            
            <article>
                
<p>This mode is used to enter new text in a file or modify the existing text in the file. There are multiple ways to get into Insert Mode, as described in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 43.8px">
<p class="CDPAlignCenter CDPAlign"><strong>Key</strong></p>
</td>
<td style="width: 672.2px">
<p class="CDPAlignCenter CDPAlign"><strong>Usage</strong></p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>a</em></p>
</td>
<td style="width: 672.2px">
<p>Insert the text after <span>the </span>current cursor location, until the <em>Esc</em> key is pressed</p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>A</em></p>
</td>
<td style="width: 672.2px">
<p>Insert the text at the end of <span>the </span>line, until the <em>Esc</em> key is pressed</p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>i</em></p>
</td>
<td style="width: 672.2px">
<p>Insert the text before <span>the </span>current cursor location, until the <em>Esc</em> key is pressed</p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>I</em></p>
</td>
<td style="width: 672.2px">
<p>Insert the text at the beginning of <span>the </span>line, until the <em>Esc</em> key is pressed</p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>o</em></p>
</td>
<td style="width: 672.2px">
<p>Insert a new line following <span>the </span>current cursor location for entering text, until the <em>Esc</em> key is pressed</p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>O</em></p>
</td>
<td style="width: 672.2px">
<p>Insert a new line preceding <span>the </span>current cursor location for entering text, until the <em>Esc</em> key is pressed</p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>s</em></p>
</td>
<td style="width: 672.2px">
<p>Delete the character at the current cursor location and remain in Insert Mode, until the <em>Esc</em> key is pressed</p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>S</em></p>
</td>
<td style="width: 672.2px">
<p>Delete the line with <span>the </span>current cursor location and get into Insert Mode, until the <em>Esc</em> key is pressed</p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>r</em></p>
</td>
<td style="width: 672.2px">
<p>Replace <span>the </span>character at <span>the </span>current cursor position</p>
</td>
</tr>
<tr>
<td style="width: 43.8px">
<p><em>R</em></p>
</td>
<td style="width: 672.2px">
<p>Begin replacing text at <span>the </span>current cursor position until the <em>Esc</em> key is pressed</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Line Mode</h1>
                </header>
            
            <article>
                
<p>This mode is used to execute editing commands. The most popular operations performed in this mode include saving a file to disk, closing a file, and exiting vi editor without saving a file to disk. Line Mode operations require the <em>Enter</em> key to be pressed after the command is typed. Some of the most popular operations performed in Line Mode are described in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Operations</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>USAGE</strong></p>
</td>
</tr>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Save and exit operations</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:q</kbd></p>
</td>
<td>
<p>Quits the vi editor only if no changes have been made to the file being edited</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:q!</kbd></p>
</td>
<td>
<p>Quits <span>the </span>vi editor without saving the current changes in the opened file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:wq</kbd></p>
</td>
<td>
<p>Writes/saves the contents of <span>the </span>file to disk and exits the vi editor</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:x</kbd></p>
</td>
<td>
<p>Writes/saves the contents of <span>the </span>file to disk and exits <span>the </span>vi editor</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ZZ</kbd></p>
</td>
<td>
<p>Writes/saves the contents of <span>the </span>file to disk and exits <span>the </span>vi editor from Command Mode</p>
</td>
</tr>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Write/save to file operations</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:w</kbd></p>
</td>
<td>
<p>Writes/saves the contents of <span>the </span>file to disk</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:w demo</kbd></p>
</td>
<td>
<p>Writes/saves the contents of <span>the </span>file to the disk with <span>the </span>filename <kbd>demo</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:w! demo2</kbd></p>
</td>
<td>
<p>Overwrites the file with <span>the </span>filename <kbd>demo2</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:f demo3</kbd></p>
</td>
<td>
<p>Renames the current file to the filename <kbd>demo3</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:w &gt;&gt; demo4</kbd></p>
</td>
<td>
<p>Appends the current file to the filename <kbd>demo4</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:5,10w demo5</kbd></p>
</td>
<td>
<p>Writes lines 5 through 10 to the filename <kbd>demo5</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:5,10w &gt;&gt;demo6</kbd></p>
</td>
<td>
<p>Appends lines 5 through 10 to the filename <kbd>demo6</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:r demo7</kbd></p>
</td>
<td>
<p>Reads the contents of <span>the </span>file with the filename <kbd>demo7</kbd> at <span>the </span>current cursor position</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:e demo8</kbd></p>
</td>
<td>
<p>Opens another file with <span>the </span>filename <kbd>demo8</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:e#</kbd></p>
</td>
<td>
<p>Switches between opened vi windows (note: this works only if you have saved the file once on disk using <kbd>:w</kbd>)</p>
</td>
</tr>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Search file contents</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>/&lt;pattern&gt;</kbd></p>
</td>
<td>
<p>Searches the occurrence of specified patterns of text, inside buffers, in a forward direction.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>?</kbd></p>
</td>
<td>
<p>Searches the occurrence of specified patterns of text, inside buffers, in a backward direction.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>n</kbd></p>
</td>
<td>
<p>Repeats the last search command in a forward direction</p>
</td>
</tr>
<tr>
<td>
<p><kbd>N</kbd></p>
</td>
<td>
<p>Repeats the search command in the opposite direction</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We can perform substitution in Line Mode. By default, it performs substitution on <span>the </span>current line only; however, we can prefix the substitution command <kbd>s</kbd> with <span>the </span>address option to perform substitution on multiple lines, as shown in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignLeft CDPAlign"><strong>Line Mode command</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Substitution on current line</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:s/file/book</kbd></p>
</td>
<td>
<p>Substitutes the first occurrence of file with book on the current line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:s/file/book/g</kbd></p>
</td>
<td>
<p>Substitute all occurrences of file with book on the current line</p>
</td>
</tr>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Substitution between address range (x,y) specified</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:1,5s/cat/dog/</kbd></p>
</td>
<td>
<p>Substitutes the first occurrence of cat with dog between lines 1 and 5</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:1,5s/cat/dog/g</kbd></p>
</td>
<td>
<p>Substitutes all occurrences of cat with dog between lines 1 and 5</p>
</td>
</tr>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Substitution in current file (%)</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:%s/cat/dog/</kbd></p>
</td>
<td>
<p>Substitutes the first occurrence of cat with dog throughout the file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:%s/cat/dog/g</kbd></p>
</td>
<td>
<p>Substitutes all occurrences of cat with dog in whole file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:%s/cat/dog/gc</kbd></p>
</td>
<td>
<p>Prompts before each substitution and substitutes all occurrences of cat with dog throughout the file</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Determining line numbers in Line Mode of vi editor</h1>
                </header>
            
            <article>
                
<p>Line Mode has <span>the </span>ability to determine the line number of <span>the </span>current line, or the total number of lines in a file being edited.</p>
<p>The following table lists the commands that are used to determine line numbers:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr style="height: 63px">
<td style="height: 63px">
<p class="CDPAlignLeft CDPAlign"><strong>Command</strong></p>
</td>
<td style="height: 63px">
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr style="height: 92px">
<td style="height: 92px">
<p><kbd>:.=</kbd></p>
</td>
<td style="height: 92px">
<p>This returns the line number of <span>the </span>current line at the last line of <span>the </span>screen</p>
</td>
</tr>
<tr style="height: 61px">
<td style="height: 61px">
<p><kbd>:=</kbd></p>
</td>
<td style="height: 61px">
<p>This returns the total number of lines at the last line of <span>the </span>screen</p>
</td>
</tr>
<tr style="height: 114.918px">
<td style="height: 114.918px">
<p><em>Ctrl</em> + <em>g</em></p>
</td>
<td style="height: 114.918px">
<p>This tells the current line number, along with the total number of lines in the file at the last line of <span>the </span>screen (Command Mode keystroke combination)</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to execute external commands in Line Mode</h1>
                </header>
            
            <article>
                
<p>Being able to execute shell commands from within <span>the </span>vi editor is sometimes quite useful. The following table lists some examples of shell command execution from Line Mode:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Line Mode command</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>:! &lt;shell command&gt;</kbd></p>
</td>
<td>
<p>Executes a shell command (press <em>Enter</em> to return to vi editor)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:!wc %</kbd></p>
</td>
<td>
<p>Executes <span>the </span><kbd>wc</kbd> command on the file opened in vi editor (<kbd>%</kbd> represents the file currently being edited)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:sh</kbd></p>
</td>
<td>
<p>Temporarily returns to the shell prompt (type <em>Exit</em> to return to vi editor)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>:r !&lt;shell command&gt;</kbd></p>
</td>
<td>
<p>Reads the output from a shell command into <span>the </span>opened file at <span>the </span>current cursor position</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Command Mode</h1>
                </header>
            
            <article>
                
<p>This is <span>the </span>default mode of vi editor. In this mode, most navigation and browsing of file content is performed. Besides the navigation of file content, we also perform cut, delete, copy, and paste operations in Command Mode. The following table describes the popular navigation operations of Command Mode:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 35.5565%">
<p class="CDPAlignCenter CDPAlign"><strong>KEY</strong></p>
</td>
<td style="width: 62.4435%">
<p class="CDPAlignCenter CDPAlign"><strong>USAGE</strong></p>
</td>
</tr>
<tr>
<td style="width: 98%" colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Move by character</strong></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><span>Arrow keys</span></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving the cursor up, down, left, and right<br/></span></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><span><kbd>j</kbd> or <kbd>&lt;enter&gt;</kbd></span></p>
</td>
<td style="width: 62.4435%">
<p><span>For move the cursor one line down<br/></span></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd><span>k</span></kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For move the cursor one line up<br/></span></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><span><kbd>h</kbd> or Backspace<br/></span></p>
</td>
<td style="width: 62.4435%">
<p><span>For move the cursor one character left<br/></span></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><span><kbd>l</kbd> or Space<br/></span></p>
</td>
<td style="width: 62.4435%">
<p><span>For move the cursor one character right<br/></span></p>
</td>
</tr>
<tr>
<td style="width: 98%" colspan="2">
<p class="CDPAlignCenter CDPAlign"><span><strong>Move by word</strong></span></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>w</kbd></p>
</td>
<td style="width: 62.4435%">
<p>For moving the cursor to the beginning of the next word</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>b</kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving the cursor to the previous word</span></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>e</kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving the cursor to the end of </span><span>the </span><span>current word</span></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%" colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Move by line</strong></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>0</kbd> or <kbd>^</kbd></p>
</td>
<td style="width: 62.4435%">
<p>For moving the cursor to the beginning of <span>the </span>line</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd><span>$</span></kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span><span> the cursor to the end of </span><span>the </span><span>line</span></p>
</td>
</tr>
<tr>
<td style="width: 98%" colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Move by sentence</strong></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>(</kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> the cursor to the beginning of <span>the </span>previous sentence</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>)</kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> the cursor to the end of <span>the </span>next sentence</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%" class="CDPAlignCenter CDPAlign" colspan="2"><strong>Move by paragraph</strong></td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>{</kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> the cursor to the beginning of <span>the </span>previous paragraph</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>}</kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> the cursor to the end of <span>the </span>next paragraph</p>
</td>
</tr>
<tr>
<td style="width: 98%;height: 50px" colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Move by screen</strong></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><em>Ctrl</em> + <em>F</em> or Page Down</p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> forward one screen</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><em>Ctrl</em> + <em>B</em> or Page Up</p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> backward one screen</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><em>Ctrl</em> + <em>D</em></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> down half a screen</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><em>Ctrl</em> + <em>U</em></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> up half a screen</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><em>H</em></p>
</td>
<td style="width: 62.4435%">
<p>First line on screen</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><em>M</em></p>
</td>
<td style="width: 62.4435%">
<p>Middle line on screen</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><em>L</em></p>
</td>
<td style="width: 62.4435%">
<p>Last line on screen</p>
</td>
</tr>
<tr>
<td style="width: 98%" colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Move inside whole document</strong></p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>:0</kbd> or <kbd>1G</kbd> or <kbd>gg</kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> to the beginning of a file</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>:$</kbd> or <kbd>G</kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> to the last line of a file</p>
</td>
</tr>
<tr>
<td style="width: 35.5565%">
<p><kbd>:n</kbd> or <kbd>nG</kbd></p>
</td>
<td style="width: 62.4435%">
<p><span>For moving</span> to <span>the </span>nth line</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Next, we will see how we to perform cut, delete, copy, and paste operations in Command Mode. The deletion of a character puts the text in an unnamed temporary buffer. The deleted character stored in a temporary buffer can be pasted at other places. Hence, we can say that a delete and paste operation is similar to a cut and paste operation.</p>
<p>The copying of character is known as yanking in context of vi editor. Copying (yanking) is performed using <span>the </span>yank <kbd>y</kbd> command. The following table describes various cut, copy, delete, and paste operations in vi editor:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>KEY</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>USAGE</strong></td>
</tr>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Deleting/cutting single characters</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>x</kbd></p>
</td>
<td>
<p>Deletes a character at the current cursor position</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Nx</kbd></p>
</td>
<td>
<p>Deletes the N-1 character on <span>the </span>right-hand side, starting at <span>the </span>current cursor position</p>
</td>
</tr>
<tr>
<td>
<p><kbd>3x</kbd></p>
</td>
<td>
<p>Deletes a total of three characters, starting with the character currently under <span>the </span>cursor position, followed by <span>the </span>next two on <span>the </span>right-hand side</p>
</td>
</tr>
<tr>
<td>
<p><kbd>X</kbd></p>
</td>
<td>
<p>Deletes a character to the left of <span>the </span>cursor</p>
</td>
</tr>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Deleting/cutting larger chunks</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>dw</kbd></p>
</td>
<td>
<p>Deletes the word at the current position up to the next space or next punctuation</p>
</td>
</tr>
<tr>
<td>
<p><kbd>db</kbd></p>
</td>
<td>
<p>Deletes one word backward</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d$</kbd></p>
</td>
<td>
<p>Deletes <span>the </span>line from <span>the </span>current cursor position to the end of <span>the </span>line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d^</kbd> or <kbd>d0</kbd></p>
</td>
<td>
<p>Deletes <span>the </span>line from <span>the </span>current cursor position to the beginning of <span>the </span>line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>dG</kbd></p>
</td>
<td>
<p>Deletes from <span>the </span>current line to the end of <span>the </span>file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>dgg</kbd></p>
</td>
<td>
<p>Deletes from <span>the </span>current line to the beginning of <span>the </span>file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>D</kbd></p>
</td>
<td>
<p>Deletes the rest of <span>the </span>current line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>dd</kbd></p>
</td>
<td>
<p>Deletes the current line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Ndd</kbd> or <kbd>dNd</kbd></p>
</td>
<td>
<p>Deletes N lines from <span>the </span>current line</p>
</td>
</tr>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>Copying/yanking text (puts text into a temporary buffer)</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>yw</kbd></p>
</td>
<td>
<p>Yanks (copies) a word forward</p>
</td>
</tr>
<tr>
<td>
<p><kbd>yb</kbd></p>
</td>
<td>
<p>Yanks (copies) a word backward</p>
</td>
</tr>
<tr>
<td>
<p><kbd>y$</kbd></p>
</td>
<td>
<p>Yanks (copies) <span>the </span>line from <span>the </span>current cursor position to the end of <span>the </span>line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>y^</kbd> or <kbd>y0</kbd></p>
</td>
<td>
<p>Yanks (copies) <span>the </span>line from <span>the </span>current cursor position to the beginning of <span>the </span>line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>yy</kbd></p>
</td>
<td>
<p>Yanks (copies) the current line and puts it in a buffer</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Nyy</kbd> or <kbd>yNy</kbd></p>
</td>
<td>
<p>Yanks (copies) N lines and puts them in a buffer</p>
</td>
</tr>
<tr>
<td>
<p><kbd>p</kbd></p>
</td>
<td>
<p>Pastes the contents below the current line (the yanked line or lines from the buffer)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>P</kbd></p>
</td>
<td>
<p>Pastes the contents above the current line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>u</kbd></p>
</td>
<td>
<p>Undoes the previous operation</p>
</td>
</tr>
<tr>
<td>
<p><em>Ctrl</em> + <em>R</em></p>
</td>
<td>
<p>Redoes the last undo operation</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_tip">Typing <kbd>vimtutor</kbd> at the prompt launches a concise, yet comprehensive, tutorial for beginners. This tutorial is short and to the point, to make beginners proficient in using vi editor.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using text file manipulation tools</h1>
                </header>
            
            <article>
                
<p>System administrators, developers, and users need to work with text files, configuration files, and log files when working on Linux. Some of these files are large; some of them are small or medium. The data contained in these files frequently needs to be viewed, updated, or extracted. In this section, we will learn how to manage and manipulate text files on Linux.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Different types of editor used to view file content </h1>
                </header>
            
            <article>
                
<p>There are different types of editor used to view the content of files. Some editors, such as vim or nano, require the whole file to be loaded into memory first. These types of editors are not suitable for working on or viewing the contents of large log files, such as banking database log files, since as opening such large files can cause issues due to high memory utilization. However, in such scenarios, you can use <span>the </span><kbd>less</kbd> command to view the contents of a large file, page by page, by scrolling up or down without the system having to place the entire file in memory at the beginning. This is much faster then a text editor, such as vi or nano.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">less command</h1>
                </header>
            
            <article>
                
<p>This is used to view larger files because it is a paging program; it displays the content page by page with scroll-back capabilities. We can also perform search operations and navigate inside the files:</p>
<ul>
<li><kbd>/&lt;string&gt;</kbd>: To search for the <kbd>&lt;string&gt;</kbd> in a forward direction</li>
<li><kbd>?&lt;string&gt;</kbd>: To search for the <kbd>&lt;string&gt;</kbd> in a backward direction</li>
<li><kbd>q</kbd>: To quit the less editor</li>
</ul>
<p>Examples of the <kbd>less</kbd> command are as follows:</p>
<pre><strong>$ less /var/log/messages or</strong><br/><strong>$ cat /var/log/messages | less</strong></pre>
<p>Main pages are displayed using <span>the </span>less utility.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">more command</h1>
                </header>
            
            <article>
                
<p>This program is also used to view larger files as it is also a paging program. It is an older utility with fewer options. The example of the <kbd>more</kbd> command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1cd997c4-4d42-4fc1-ac9a-9fd2ad99fed3.png" style="width:36.08em;height:5.08em;" width="808" height="113"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">cat command</h1>
                </header>
            
            <article>
                
<p><span><strong>Concatenate</strong> (</span><strong>cat</strong><span>) is one of the most frequently used Linux command-line utilities. It is most commonly used to view the contents of a</span> <span>single</span> <span>file</span> <span>or concatenate the contents of multiple files</span> <span>that are not very long. It does not provide scroll-back functionality.</span></p>
<p><span>The following screenshot demonstrates utilization of <kbd>cat</kbd> command with single file:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/29985cd9-f8d5-49fe-9534-9dbba8d186cc.png" style="width:38.50em;height:6.42em;" width="804" height="133"/></p>
<p>The following<span> screenshot demonstrates utilization</span> of the <kbd>cat</kbd> command with multiple files:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/68ab6bc2-b468-4853-ac90-3e3e36da5930.png" style="width:38.58em;height:9.33em;" width="808" height="195"/></p>
<p>We can perform multiple tasks using <span>the </span><kbd>cat</kbd> command, as listed in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Command</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>cat file1 file2</kbd></p>
</td>
<td>
<p>Concatenate <kbd>file1</kbd> and <kbd>file2</kbd> and display the output. The entire contents of <kbd>file1</kbd> is followed by the contents of <kbd>file2</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>cat file1 file2 &gt; file3</kbd></p>
</td>
<td>
<p>Combine the contents of <kbd>file1</kbd> and <kbd>file2</kbd> and save the output into a new <kbd>file</kbd>, <kbd>file3</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>cat demo1 &gt;&gt; demo2</kbd></p>
</td>
<td>
<p>Append the contents of <span>the </span><kbd>demo1</kbd> <span>file</span><span> </span><span>to the end of</span> <span>the </span><span>existing file, <kbd>demo2</kbd></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd>cat &gt; demo</kbd></p>
</td>
<td>
<p>Any subsequent lines typed in the Terminal will go into the <kbd>demo</kbd><span> </span><span>file</span><span>, until</span> <em>Ctrl</em> <span>+</span> <em>D</em> <span>is pressed</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd>cat &gt;&gt; demo</kbd></p>
</td>
<td>
<p>Any subsequent lines typed are appended to the <kbd>demo</kbd><span> </span><span>file</span><span>, until</span> <em>Ctrl</em> <span>+</span> <em>D</em> <span>is pressed</span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">tac command</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>tac</kbd> command is used to view the contents of a file backward from bottom to top, starting from the last line.</span> <span>The syntax of <kbd>tac</kbd> is exactly same as that of the <kbd>cat</kbd> command, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d55336f6-77f1-402f-b167-09b41240d8b5.png" style="width:21.92em;height:5.25em;" width="471" height="112"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">head command</h1>
                </header>
            
            <article>
                
<p>The <kbd>head</kbd> command is used to print <span>the </span>first 10 lines of a file by default. However, it can be used with <span>the </span><kbd>-n</kbd> option, or just <kbd>-&lt;number&gt;,</kbd> to display a different number of lines as specified. The filename whose contents are to be displayed is passed as an argument to the <kbd>head</kbd> command as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0e2ed9df-e6fd-42bc-b29c-bec7f7552193.png" style="width:26.00em;height:19.25em;" width="563" height="416"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">tail command</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>tail</kbd> command is used to print last 10 lines of a file by default. However, like the <kbd>head</kbd> command, we can change the number number of lines to be displayed by using the <kbd>-n</kbd> option, or just <kbd>-&lt;number&gt;</kbd></span>, <span>to display a different number of lines as specified. The filename whose contents are to be displayed is passed as an argument to the <kbd>tail</kbd> command, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8ec7febc-84bc-4754-bd72-e179e3b8fbc5.png" style="width:35.83em;height:19.83em;" width="803" height="445"/></p>
<p>The <span><kbd>tail</kbd> command is more useful when we are troubleshooting issues using log files. It enables us to see the most recent lines of output by continuously displaying the addition of any new lines in the log file as soon as they appear. Thus, it enables us to monitor any current activity that is being reported or recorded, as shown in the following command line:</span></p>
<pre><strong>$ tail -f /var/log/messages</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">wc command</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>wc</kbd> command is used to count the lines, words, and characters in a file by default. It can accept <kbd>-l</kbd>, <kbd>-w</kbd>, or <kbd>-c</kbd> options to display only the lines, words, or characters respectively. The filename is passed as an argument to the <kbd>wc</kbd> command, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/45ff5d83-6de4-4cfd-aa08-d87ab6a16435.png" style="width:24.08em;height:9.92em;" width="592" height="243"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">file command</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>file</kbd> command scans the header of a file and tells us what kind of file it</span> <span>is</span><span>. The file type to be identified is passed as an argument to the <kbd>file</kbd> command, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/69e4de76-10e3-4d55-af7d-2fcd28659dd7.png" style="width:35.75em;height:10.67em;" width="809" height="242"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Viewing compressed files</h1>
                </header>
            
            <article>
                
<p>In Linux, we can view the contents of a compressed file without decompressing it. It is a good option to view large log files, which are compressed using this utility. There are multiple utilities that have the letter <kbd>z</kbd> prefixed to their name for working with <kbd>.gzip</kbd> compressed files.</p>
<p>This table lists some <kbd>z</kbd> family commands:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 46.8264%">
<p class="CDPAlignCenter CDPAlign"><strong>Command</strong></p>
</td>
<td style="width: 51.1736%">
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 46.8264%">
<p><kbd>zcat demo.gz</kbd></p>
</td>
<td style="width: 51.1736%">
<p>To view a compressed <kbd>demo.gz</kbd> file</p>
</td>
</tr>
<tr>
<td style="width: 46.8264%">
<p><kbd>zless demo.gz</kbd> or <kbd>zmore demo.gz</kbd></p>
</td>
<td style="width: 51.1736%">
<p>To view a compressed <kbd>demo.gz</kbd> <span>file</span><span> </span><span>page by page</span></p>
</td>
</tr>
<tr>
<td style="width: 46.8264%">
<p><kbd>zgrep -i host demo.gz</kbd></p>
</td>
<td style="width: 51.1736%">
<p>To search inside a compressed <kbd>demo.gz</kbd><span> </span><span>file</span></p>
</td>
</tr>
<tr>
<td style="width: 46.8264%">
<p><kbd>zdiff file1.gz file2.gz</kbd></p>
</td>
<td style="width: 51.1736%">
<p>To compare two compressed files, <kbd>file1.gz</kbd>, and <kbd>file2.gz</kbd>, <span>using the <kbd>diff</kbd> command</span></p>
</td>
</tr>
<tr>
<td style="width: 46.8264%">
<p><kbd>zcmp file1.gz file2.gz</kbd></p>
</td>
<td style="width: 51.1736%">
<p>To compare two compressed files, <kbd>file1.gz</kbd> and <kbd>file2.gz</kbd> using the <kbd>cmp</kbd> command</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Similarly, for other text manipulation, utilities can also be clubbed with other compression methods, such as <kbd>bzip2</kbd> and <kbd>xz</kbd>. To display the contents of the file inside the <kbd>bzip2</kbd> compressed archive, we can use <kbd>bzcat</kbd>, <kbd>bzless</kbd> command and, to display the contents of the file inside the <kbd>xz</kbd> archive, we can use the <kbd>xzcat</kbd> and <kbd>xzless</kbd> respectively. </p>
<p>Utilization of the <kbd>zcat</kbd> command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ecdb7299-13f2-40a2-a5c8-d9794ef84988.png" style="width:61.75em;height:11.33em;" width="1440" height="264"/></p>
<p>Utilization of the <kbd>zgrep</kbd> command is shown in the following <span>screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1e886fc2-7107-4863-a9d3-51253d9fde10.png" style="width:61.75em;height:4.00em;" width="1429" height="92"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">cut command</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>cut</kbd> command is used to</span> <span>display only</span> <span>specific columns or characters from a text file</span> <span>or from other command outputs. For example, in the following command, we display the login names from the <kbd>/etc/passwd</kbd> file:</span></p>
<pre class="mce-root"><strong>$ cut -d: -f1 /etc/passwd</strong></pre>
<p class="mce-root">Output upon execution of the preceding command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0a1d02dc-6d37-44b3-927e-aec39ebf3aa6.png" style="width:12.58em;height:8.08em;" width="272" height="175"/></p>
<p><span>The following command line displays the first</span> <span>and third</span> <span>fields from a colon-delimited file</span> <span>(extra lines stripped from output):</span></p>
<pre class="mce-root"><strong>$ cut -d: -f1,3 /etc/passwd<br/></strong></pre>
<p><span>Output upon execution of the preceding command is shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3b844038-ae6c-4462-a22e-151352be7de0.png" style="width:13.58em;height:8.17em;" width="330" height="198"/></p>
<p>The following command line display only the first four characters of every line in the <kbd>/etc/passwd</kbd> file:</p>
<pre><strong>$ cut -c 1-4 /etc/passwd</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">sort command</h1>
                </header>
            
            <article>
                
<p>The <span><kbd>sort</kbd> command is used to sort the lines of a text file</span> <span>in ascending or descending order, or sort as per a specified key</span><span>.</span> <span>The following example illustrates the working of the <kbd>sort</kbd> command.</span></p>
<p>An example of the <kbd>sort</kbd> command to sort the <kbd>/etc/passwd</kbd> <span>file</span><span> </span><span>in ascending order is shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/18920c26-af7d-4bef-8de3-6a170cbe9c16.png" style="width:35.08em;height:19.00em;" width="804" height="436"/></p>
<p><span>An example of the <kbd>sort</kbd> command to sort the <kbd>/etc/passwd</kbd> </span><span>file</span><span> </span><span>by the third</span><span> </span><span>field numerically is shown in the following screenshot. Here, the <kbd>-t</kbd> option specifies a delimiter and <span>the </span><kbd>-k</kbd> option specifies a field to be used for sorting:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/98722473-905d-454b-972e-f5cee5ea7456.png" style="width:33.17em;height:18.00em;" width="690" height="374"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">uniq command</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>uniq</kbd> command is</span> <span>used to remove duplicate lines from a sorted file. It requires the</span> <span>duplicate entries to be in the adjacent lines</span> <span>and, hence, it is</span> <span>mostly used in combination with the <kbd>sort</kbd> command,</span> <span>which is used to sort the file contents first.</span> The<span> syntax of the <kbd>uniq</kbd> command is as follows:</span></p>
<pre><strong>$ sort &lt;filename&gt; | uniq</strong><br/> or<br/><strong>$ sort -u &lt;filename&gt;</strong></pre>
<p>To count duplicate lines in the file, execute the command line, shown as follows :</p>
<pre><strong>$ sort &lt;filename&gt; | uniq -c</strong></pre>
<p>To display only the entries that are duplicates, execute the command line, shown as follows:</p>
<pre><strong>$ sort &lt;filename&gt; | uniq -cd</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">paste command</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>paste</kbd> command is used to combine fields from different files, or combine lines from multiple files. For example, we have two files, <kbd>f1</kbd> containing the employee name, and <kbd>f2</kbd> containing their employee ID and</span> <span>phone number.</span></p>
<p><span>T</span><span>o paste content from <kbd>f1</kbd> and <kbd>f2</kbd>, execute the steps in the command line, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fa7d676b-b80a-4f63-b632-17b6ffe57aed.png" style="width:23.08em;height:18.17em;" width="535" height="420"/></p>
<p>To paste the contents separated with a delimiter, execute the <kbd>paste</kbd> command, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ecdc1ca5-1e7e-4e2a-bc42-5e97625a91f1.png" style="width:21.25em;height:6.42em;" width="521" height="157"/></p>
<p><span>The commonly used delimiters with the <kbd>-d</kbd> option are space, Tab, |, :, and comma.</span> An e<span>nhanced version of the <kbd>paste</kbd> command is <kbd>join</kbd>, which can work on files that have similar columns.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Redirecting output to files and programs</h1>
                </header>
            
            <article>
                
<p>When we execute any program, by default, its output or error is displayed on the screen. We can redirect the text output of a program to a file using <span>the input</span>/output redirection operator or to another program using pipes. For this, when any command is executed, there are three standard file streams (file descriptors) created and opened by the operating system. The streams are known as standard input (<kbd>stdin</kbd>), standard output (<kbd>stdout</kbd>), and standard error (<kbd>stderr</kbd>).</p>
<p>The first stream is associated with <kbd>stdin</kbd> (numbered as 0) used to read input from keyboard. The second file stream is associated to <kbd>stdout</kbd> (numbered as 1) used by program to print output on screen, and the last file stream is <kbd>stderr</kbd> (numbered as 2), used by our program to print errors onscreen.</p>
<p>The following table list the different file descriptors (also known as channel) along with their numeric value, default connection and symbolic name:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Channel description</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Channel symbolic name</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Default connection</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Descriptor value</strong></p>
</td>
</tr>
<tr>
<td>
<p>Standard input</p>
</td>
<td>
<p><kbd>stdin</kbd></p>
</td>
<td>
<p>Keyboard</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>Standard output</p>
</td>
<td>
<p><kbd>stdout</kbd></p>
</td>
<td>
<p>Terminal</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p>Standard error</p>
</td>
<td>
<p><kbd>stderr</kbd></p>
</td>
<td>
<p>Terminal</p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p>Other files</p>
</td>
<td>
<p><kbd>filename</kbd></p>
</td>
<td>
<p>Other files</p>
</td>
<td>
<p>3+</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Redirecting <kbd>stdout</kbd>/<kbd>stderr</kbd> to a file prevents any process output from appearing on the Terminal. Linux has got a special file such as <kbd>/dev/null</kbd> which discards any channel output redirected to it. The less than symbol (<kbd>&lt;</kbd>) is used for input redirection from a file, the greater than symbol (<kbd>&gt;</kbd>) is used for output redirection to a file, and if we repeat the use of <span>the </span>output redirection symbol (<kbd>&gt;&gt;</kbd>) twice instead of once, then it appends the contents to the filename suffixed to it.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following table explains the use of input/output redirection operators:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Operator usage</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Explanation</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Cmd &gt; file</kbd></p>
</td>
<td>
<p>Redirects the command output to a file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Cmd &gt;&gt; file</kbd></p>
</td>
<td>
<p>Redirects and append the command output to <span>the </span>current file content</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Cmd 2&gt; file</kbd></p>
</td>
<td>
<p>Redirects the command standard error to a file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Cmd 2&gt;&gt; file</kbd></p>
</td>
<td>
<p>Appends the command standard error to <span>the </span>current file contents</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Cmd 2&gt; /dev/null</kbd></p>
</td>
<td>
<p>Discards standard error messages by redirecting them to <kbd>/dev/null</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Cmd &amp;&gt; file</kbd> or</p>
<p><kbd>Cmd &gt;file 2&gt;&amp;1</kbd></p>
</td>
<td>
<p>Redirects both standard output and standard error messages to one file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Cmd &gt;&gt;file 2&gt;&amp;1</kbd></p>
</td>
<td>
<p>Appends both standard output and standard error messages to one file</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Here are some examples of output redirection:</p>
<ul>
<li>
<p>Save the last 10 lines of <kbd>/var/log/messages</kbd> to <kbd>f1</kbd> by executing following command:</p>
<pre><strong>$ tail -n 10 /var/log/message &gt; f1</strong></pre></li>
<li>
<p>Append the <kbd>date</kbd> to the file named <kbd>f1</kbd> by executing following command:</p>
<pre><strong>$ date &gt;&gt; f1</strong></pre></li>
<li>
<p>Save the errors in a file named <kbd>error</kbd> and display the output onscreen <span>by executing following command:</span></p>
<pre><strong>$ find /etc/ -name passwd 2&gt; error</strong></pre></li>
<li>
<p>Save the output in a file named <kbd>result</kbd> and the error in a file named <kbd>error</kbd>:</p>
<pre><strong>$ find /etc/ -name passwd &gt; result 2&gt; error</strong></pre></li>
<li>
<p>Save the output or error received upon execution of the <kbd>find</kbd> command in the common file named as <kbd>both</kbd>, as shown in the following command line:</p>
<pre><strong>$ find /etc/ -name passwd &amp;&gt; both or</strong></pre>
<pre><strong>$ find /etc/ -name passwd &gt; both 2&gt;&amp;1</strong></pre></li>
<li>
<p>Save the output in a file named <kbd>result</kbd> and discard the error messages by executing the following command:</p>
<pre><strong>$ find /etc/ -name passwd &gt; result 2&gt; /dev/null</strong></pre></li>
<li>
<p>Read from a file using input redirection by executing the following command:</p>
<pre><strong>$ wc -l &lt; /etc/hosts</strong></pre></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pipes</h1>
                </header>
            
            <article>
                
<p><span>The Unix philosophy is to have simple and short programs (commands) used together to solve a complex problem, instead of having a complex program with several options. To accomplish this goal, pipes were created, which fetch the output of one command as input to another command. The symbol used for pipes is a vertical bar (<kbd>|</kbd>) between two or more commands, as follows:</span></p>
<pre><strong>$ command1 | command2 | command3 ..</strong></pre>
<p>Here are a few example showing the usage of pipes (redirecting the output from one program as an input to another program):</p>
<ul>
<li>
<p>Paginate the long output of any command using pipes, as shown in the following example:</p>
<pre><strong><span>$ </span><span>ls -l /bin | less</span></strong></pre></li>
<li>
<p>Pipe multiple commands together as shown in the following example:</p>
<pre><strong>$ ls | head -3 | tail -1</strong></pre></li>
<li>
<p>Combine piping and redirection, as shown in the following example:</p>
<pre><strong>$ ls | head -3 | tail -1 &gt; output</strong></pre></li>
<li>
<p>Send standard output, as well as standard errors from the command, through a pipe to another process, as shown in the following example:</p>
<pre><strong>find /etc -name passwd |&amp; wc -l or find /etc -name passwd 2&gt;&amp;1 | wc -l</strong></pre></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">tee command</h1>
                </header>
            
            <article>
                
<p><span>The advantage of using pipes is that you don't have to save the output of a command in temporary files before passing it to another subsequent command for processing. This saves disk space and improves the time of execution, since reading and writing to disk are generally the slowest bottlenecks in the system. And, if you require the input to be saved in a file before passing it to a subsequent command, Linux has another beautiful command, known as</span> <kbd>tee</kbd>. The syntax of the <kbd>tee</kbd> command is as follows<span>:</span></p>
<pre class="mce-root"><strong>$ command1 | tee &lt;log_filename&gt; | command2 ......</strong></pre>
<p>Here is an example of <kbd>tee</kbd> command usage:</p>
<ul>
<li>
<p>Send the output of the <kbd>ls</kbd> command to the <kbd>wc</kbd> command and to a file named <kbd>listoffile</kbd>:</p>
<pre><strong>$ ls | tee listoffile | wc</strong></pre></li>
<li>
<p>Send standard output, as well as standard errors from <span>the </span>command, through a pipe-through tee to another file and then to a subsequent command:</p>
<pre><strong>$ find /etc -name passwd |&amp; tee logfile | wc -l</strong></pre></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using grep for text matching</h1>
                </header>
            
            <article>
                
<p><span><strong>Grep</strong> (short for <strong>Global</strong> <strong>Regular Expression Print</strong>) is a</span><span> command that is used extensively to as a text search tool in text files. It searches for a pattern in a file and prints the corresponding line, which contains the matching pattern. It</span> <span>scans files for specified patterns and can be used with regular expressions, as well as text strings.</span> <span>Its syntax is as follows:</span></p>
<pre><strong>$ grep [options] pattern [files]</strong></pre>
<p>The following table demonstrates when the <kbd>grep</kbd> command is used:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Command</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Usage</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep 'student' /etc/passwd</kbd></p>
</td>
<td>
<p>Search for a string, <kbd>student</kbd>, in a file, <kbd>/etc/passwd</kbd>, and print all matching lines</p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -v 'student' /etc/passwd</kbd></p>
</td>
<td>
<p>Print all lines that do not contain the string <kbd>student</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -i 'STUDENT' /etc/passwd</kbd></p>
</td>
<td>
<p>Search for a string, <kbd>STUDENT</kbd>, in a case-insensitive manner and print all matching lines (<kbd>-i</kbd> ignore case)</p>
</td>
</tr>
<tr>
<td>
<p>grep -c 'student' /etc/passwd</p>
</td>
<td>
<p>Print the total number of lines that contain the text <kbd>student</kbd> in <span>the </span><kbd>/etc/passwd</kbd> file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -rl 'student' /etc/</kbd></p>
</td>
<td>
<p>Search the directory recursively and print the filenames that have the string <kbd>student</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -rL ‘student’ /etc/</kbd></p>
</td>
<td>
<p>Search the directory recursively and print the filenames that don't have the string <kbd>student</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -n 'student' /etc/passwd</kbd></p>
</td>
<td>
<p>Print the line number, along with the line containing <span>the </span>pattern <kbd>student</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -A1 'student' /etc/passwd</kbd></p>
</td>
<td>
<p>Print an additional one line after the match</p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -B1 'student' /etc/passwd</kbd></p>
</td>
<td>
<p>Print an additional one line before the match</p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -C1 'student' /etc/passwd</kbd></p>
</td>
<td>
<p>Print an additional one line after, and one line before, the match</p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -a 'dir' /bin/mkdir</kbd></p>
</td>
<td>
<p>Search inside the <kbd>/bin/mkdir</kbd><span> </span><span>binary file</span><span> and print the line containing <span>the </span>string <kbd>dir</kbd></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep 'root' /etc/passwd</kbd></p>
</td>
<td>
<p>Print the line containing <span>the </span>string <kbd>root</kbd> anywhere on a line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep '^root' /etc/passwd</kbd></p>
</td>
<td>
<p>Print the line that begins with the string <kbd>root</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep 'bash$' /etc/passwd</kbd></p>
</td>
<td>
<p>Print the line that ends with <span>the </span>string <kbd>bash</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep '^$' &lt;filename&gt;</kbd></p>
</td>
<td>
<p>Print the empty lines from the file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep -v '^$' &lt;filename&gt;</kbd></p>
</td>
<td>
<p>Print only non-empty lines from the file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>grep '[br]oot' /etc/passwd</kbd></p>
</td>
<td>
<p>Print the lines that contain either string beginning with the characters <kbd>b</kbd> or <kbd>r</kbd>, and followed by the string <kbd>oot</kbd>, anywhere on a line in the <kbd>/etc/passwd</kbd> file</p>
</td>
</tr>
<tr>
<td>
<p><kbd>who | grep 'student'</kbd></p>
</td>
<td>
<p>Print the line containing <span>the </span>string <kbd>student</kbd> by reading input from <kbd>stdin</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>An example of matching a string in a file using <kbd>grep</kbd> is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/25d40cce-e273-419c-8cbd-a655d978e66a.png" style="width:25.00em;height:4.25em;" width="524" height="90"/></p>
<p>An example of printing those lines that do not contain the specified string using <kbd>grep</kbd> is shown in the following screenshot (some output stripped):</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/58f82d23-389a-4c69-925a-34bc1b8f2e5c.png" style="width:25.33em;height:8.58em;" width="524" height="178"/></p>
<p><span><span><span>The</span> <kbd>grep</kbd> <span>command can be used with the <kbd>-c</kbd> option to count the occurrence of a specified pattern. The following example shows how to count the number of CPU cores in a system using</span> <kbd>grep</kbd> <span>command:</span></span></span></p>
<pre><strong>$ grep -c name /proc/cpuinfo (count the number of cpu cores in </strong><br/><strong>system)</strong></pre>
<p>The following screenshot shows how to use <kbd>grep</kbd> command to count the occurrence of <kbd>root</kbd> string in the <kbd>/etc/passwd</kbd> file:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/77ac5c7d-9031-41ab-b013-a5343940422e.png" style="width:22.00em;height:2.83em;" width="506" height="65"/></p>
<p>An example of printing the line number, along with the matching lines using the <kbd>grep</kbd>, is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c2dc99ff-c5f7-4919-a5d9-1c03ff28c0ad.png" style="width:25.33em;height:4.17em;" width="555" height="92"/></p>
<p><span>An example of printing</span> the lines that begin with a specified string is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/293574db-f06c-4a0e-9bc1-41a005fee116.png" style="width:22.67em;height:3.00em;" width="489" height="65"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Text extraction using sed and awk </h1>
                </header>
            
            <article>
                
<p><span>It is very often necessary to extract the same text repeatedly from a file. For such an operation, where we need to edit a file at the same place, or extract the same text from multiple files, we use <kbd>sed</kbd> and <kbd>awk</kbd>.</span> There are multiple text extraction utilities. H<span>owever, these utilities use fewer system resources, execute faster, and are simpler to</span><span> use.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">sed</h1>
                </header>
            
            <article>
                
<p><span>This is one of the oldest and most popular Unix text processing tools. It is a non-interactive</span> s<span>tream</span> ed<span>itor. It</span> <span>is typically used for</span> <span>filtering text, as well as performing</span> <span>text</span> <span>substitution</span> <span>and the non-interactive editing of text files</span><span>.</span> <span>There are two main ways of invoking the <kbd>sed</kbd> command, as follows:</span></p>
<ul>
<li><kbd>sed -e command &lt;filename&gt;</kbd>: Specify editing commands at the command line, operate on the filename specified, and display the output on the Terminal. Here, the <kbd>-e</kbd> command option allows us to specify multiple editing commands simultaneously at the command line.</li>
<li><kbd>sed -f scriptfile &lt;filename&gt;</kbd>: Specify a script file containing <kbd>sed</kbd> commands to operate on a specified filename and display the output on the Terminal.</li>
</ul>
<p>Now, we discuss the most popular operations performed using <kbd>sed</kbd>, for example, substitution. The following table lists the basic syntax for substitution operations:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 331px">
<p class="CDPAlignCenter CDPAlign"><strong>Command</strong></p>
</td>
<td style="width: 333px">
<p class="CDPAlignCenter CDPAlign"><strong>Usage</strong></p>
</td>
</tr>
<tr>
<td style="width: 331px">
<p><kbd>sed 's/original_string/new_string/s file</kbd></p>
</td>
<td style="width: 333px">
<p>Substitute the first occurrence of the original string in each line with a new string</p>
</td>
</tr>
<tr>
<td style="width: 331px">
<p><kbd>sed 's/original_string/new_string/g' file</kbd></p>
</td>
<td style="width: 333px">
<p>Substitute all occurrences of the original string in each line with a new string specified</p>
</td>
</tr>
<tr>
<td style="width: 331px">
<p><kbd>sed '1,3s/original_string/new_string/g' file</kbd></p>
</td>
<td style="width: 333px">
<p>Substitute all occurrences of the original string in each line with a new string from line one to line three in the same file</p>
</td>
</tr>
<tr>
<td style="width: 331px">
<p><kbd>sed -i 's/original_string/new_string/g' file</kbd></p>
</td>
<td style="width: 333px">
<p>Substitute all occurrences of the original string with a new string in each line in the same file</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Using the <kbd><span><span>sed</span></span></kbd> utility with the print command</strong>:</p>
<p>The <kbd>p</kbd> <span>command</span><span> </span><span>will print the matching lines and the</span> <kbd>-n</kbd> <span>option suppresses standard output so that only matching lines are displayed, as shown in the following example:</span></p>
<pre><strong>$ sed -n '1,3' /etc/passwd</strong><br/><strong>$ sed -n '/^root/' /etc/passwd</strong></pre>
<p><strong>Using the <kbd>sed</kbd> utility with the substitute</strong> <strong>command</strong>:</p>
<p>The <kbd>s</kbd> command<span> will replace the matching string with a new string. The</span> <kbd><span><span>s</span></span></kbd><span> </span><span>option</span><span> </span><span>can be prefixed with a range to restrict the replacement to a specified number of lines, as shown in the following example:</span></p>
<pre><strong>$ sed '/^student/s/bash/sh/' /etc/passwd</strong></pre>
<p><strong>Using the <kbd>sed</kbd> utility with delete command</strong>:</p>
<p>In the following example, the <kbd>sed d</kbd> command will delete the empty and commented lines from <kbd>ntp.conf</kbd> and create a backup file of <kbd>ntp.conf</kbd> with the extension backup as <kbd>ntp.conf.backup</kbd>, as shown in the following command line:</p>
<pre><strong>$ sed -i.backup '/^#/d;/^$/d' /etc/ntp.conf</strong></pre>
<div class="packt_tip">Use the <kbd>-i</kbd> option with caution, because the changes, once made inside the file, are not reversible. It is always a better way to first use <kbd>sed</kbd> without the <kbd>-i</kbd> option and then redirect the output to a new file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">awk</h1>
                </header>
            
            <article>
                
<p>The <kbd>awk</kbd> command is used to extract data from a file and print specific contents. It is quite often used to restructure the data and construct reports. Its name is derived from the last names of its creators: Alfred Aho, Peter Weinberger, and Brian Kernighan. Its main features include the following:</p>
<ul>
<li>It is an interpreted programming language similar to C</li>
<li>It is used for data manipulation in files, and for retrieving and processing text from files</li>
<li>It views files as records and fields</li>
<li><span>It has arithmetic and string operators</span></li>
<li><span>It has variables, conditional statements, </span>and loops</li>
<li>It reads from a file or from a standard input device and outputs to a standard output device such as a Terminal</li>
</ul>
<p>Its general invoking syntax is as follows:</p>
<pre><strong>$ awk   '/pattern/{command}'   &lt;filename&gt;</strong></pre>
<p>The printing of a selected column or row from a file is the basic task generally performed using <kbd>awk</kbd>.</p>
<p>In the following example, the <kbd>awk</kbd> command is used to print the contents of a file line by line until the end of the file is reached:</p>
<pre><strong>$ awk '{ print $0}' /etc/passwd</strong></pre>
<p>In the following example, <kbd>awk</kbd> command is used to print the first field (column) of the line containing the username <kbd>student</kbd>. Here <kbd>-F</kbd> <span>option</span><span> is used</span> <span>to set the field separator as <kbd>:</kbd>.</span></p>
<pre><strong>$ awk -F:  '/student/{ print $1}' /etc/passwd</strong></pre>
<p>In the following example, the <kbd>awk</kbd> command is used to print selective fields from the line containing the matching pattern in file <kbd>/etc/passwd</kbd>:</p>
<pre><strong>$ awk -F: '/student/{print "Username :", $1, "Shell :", $7}' /etc/passwd</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding a file (locate and find commands)</h1>
                </header>
            
            <article>
                
<p>If we can quickly find the files we are looking for, it will definitely make us happier Linux users. We can search any directory or multiple directories for a file in a Linux system as and when needed. CentOS 7 has two popular utilities that are used to search for files:</p>
<ul>
<li>The <kbd>locate</kbd> command</li>
<li>The <kbd>find</kbd> command</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Locate</h1>
                </header>
            
            <article>
                
<p>This utility performs a search through a previously created database of files and directories available on our system. It matches all entries that contain a specified character string. This sometimes returns a very long list of matching results, which can be further filtered using the <kbd>grep</kbd> command, as shown in the following command line:</p>
<pre><strong>$ locate zip | grep bin</strong><br/><strong>$ locate iproute2</strong></pre>
<p>The <kbd>locate</kbd> command uses a database created by another program, <kbd>updatedb</kbd>. Most Linux systems run this program automatically once a day using a scheduler. However, we can update the <kbd>locate</kbd> command database any time by running the <kbd>updatedb</kbd> command on a Terminal.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Find</h1>
                </header>
            
            <article>
                
<p><span>Find is the most useful and often used utility in a Linux system. It</span> <span>traverses through the filesystem directory tree from any location to search for a file on a specified condition. Its general syntax is as follows:</span></p>
<pre><strong>$ find  [pathnames]   [conditions]</strong></pre>
<p>We can search for a file in the <kbd>/var</kbd> directory containing a specific string in its name, as shown in the following command line:</p>
<pre><strong>$ find /var -name "*.log"</strong></pre>
<div class="packt_tip">When no argument (path) is given, it searches for a file in the current directory and its sub-directories only.</div>
<p class="mce-root"/>
<p><span>We can use the <kbd>find</kbd> command to search a file or directory in the </span><kbd>/usr</kbd><span> directory having the name <kbd>gcc</kbd></span>, <span>as shown in the following command line:</span></p>
<pre><strong>$ find /usr -name gcc</strong></pre>
<p>We can narrow down our search by specifying the type of file to search for, such as by using <kbd>d</kbd> for directories and <kbd>f</kbd> for files, as shown in the following command line:</p>
<pre><strong>$ find /usr -type f -name gcc</strong><br/><strong>$ find /usr -type d -name gcc</strong></pre>
<p><strong>Search for files above a particular size:</strong></p>
<ul>
<li>The following <kbd>find</kbd> command line is used to list the files with a size of <kbd>0</kbd> KB in <span>the </span><kbd>/var</kbd> directory:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ find /var -type f -size 0</strong></pre>
<ul>
<li>The following<span> </span><kbd>find</kbd><span> </span>command line is used to list files with a size of more than <kbd>2</kbd> MB in the <kbd>/var/log</kbd> directory:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"><strong>$ find /var/log -type f -size +2M</strong></pre>
<ul>
<li>The following<span> </span><kbd>find</kbd><span> </span>command line is used to <span>f</span>ind a file with the name messages, and then compress it using the <kbd>gzip</kbd> utility with <kbd>xargs</kbd>:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ find /var/log -type f -name messages | xargs gzip</strong></pre>
<ul>
<li>Find all the <kbd>.jpg</kbd> images and archive them with <kbd>xargs</kbd> and <kbd>tar</kbd>, as shown in the following command line:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we began with learning various methods for creating a text file. This was followed by taking a walk through the different text manipulation utilities that are helpful in performing daily operations. These utilities mainly included tools such as <kbd>head</kbd>, <kbd>tail</kbd>, <kbd>wc</kbd>, <kbd>sort</kbd>, <kbd>less</kbd> and <kbd>more</kbd>. Then, we learned the various techniques of input-output redirection into files and programs. After that, we had a quick tour of text filtering and extraction tools, such as <kbd>grep</kbd>, <kbd>sed</kbd>, and <kbd>awk</kbd>. Finally, we saw how to search files in CentOS 7 using the find and locate commands.</p>
<p>In our next chapter, we will learn about managing users and groups in CentOS 7.</p>


            </article>

            
        </section>
    </div>



  </body></html>