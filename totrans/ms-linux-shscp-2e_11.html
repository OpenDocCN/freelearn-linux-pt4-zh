<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Regular Expressions</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will talk about the most mysterious part of using <strong>stream editor</strong><span> (</span><strong>sed</strong><span>)</span> and AWK. They are regular expressions, or regexes for short. In the previous chapters, we discussed some regular expressions shyly and that's because we don't need to dig into them without a good understanding.</p>
<p>If you understand how regular expressions are written, you will save a lot of time and effort. With regular expressions, you will unleash the real power behind sed and AWK and will use them professionally. </p>
<p>This chapter will cover the following aspects:</p>
<ul>
<li>Regular expression engines</li>
<li>Defining BRE patterns</li>
<li>Defining ERE patterns</li>
<li>Using <kbd>grep</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The source code for this chapter can be downloaded here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter11">https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter11</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regular expression engines</h1>
                </header>
            
            <article>
                
<p>To start with, what are regular expressions?</p>
<p>Regular expressions are strings that the regex engine interprets to match a specific text. It's like an advanced way of searching.</p>
<p>Assume that you want to search a file for lines starting with any small letters, or you want to search for lines that contain a number, or maybe search for lines starting with specific text. The normal search can't be generic: the only way to do that is to use regular expressions.</p>
<p>And what is the regex engine?</p>
<p>The regex engine is the piece of software that understands these strings and translates them to find the matched text.</p>
<p>There are many regex engines out there; for example, the engines that are shipped with programming languages such as Java, Perl, and Python. Also, the engines that Linux tools use are sed and AWK, and the important thing for us now is to learn the types of regex engine in Linux.</p>
<p>There are two types of regex engine in Linux:</p>
<ul>
<li>The <strong>Basic Regular Expression</strong> (<strong>BRE</strong>) engine</li>
<li>The <strong>Extended Regular Expression</strong> (<strong>ERE</strong>) engine</li>
</ul>
<p>Most Linux binaries understand both engines, such as sed and AWK.</p>
<p><kbd>grep</kbd> also can understand ERE, but you have to use the <kbd>-E</kbd> option, which is equivalent to using <kbd>egrep</kbd>.   </p>
<p>We will see how to define a regex pattern for sed and AWK. We will start by defining BRE patterns, so let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining BRE patterns</h1>
                </header>
            
            <article>
                
<p>To define a regex pattern, you can type the following:</p>
<pre><strong>$ echo "Welcome to shell scripting" | sed -n '/shell/p'</strong><br/><strong>$ echo "Welcome to shell scripting" | awk '/shell/{print $0}'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><br/>
<img src="assets/0b72a10f-089f-49d4-abd9-31b3e728cf5b.png" style="width:48.75em;height:8.83em;"/></div>
<p>A very important thing you need to know about regex patterns in general is they are case sensitive:</p>
<pre><strong>$ echo "Welcome to shell scripting" | awk '/shell/{print $0}'</strong><br/><strong>$ echo "Welcome to SHELL scripting" | awk '/shell/{print $0}'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-548 image-border" src="assets/3672126e-36f9-4e1c-8260-a225ade9dd96.png" style="width:52.92em;height:9.58em;"/></div>
<div>
<div class="packt_infobox">
<p>Say you want to match any of the following characters:</p>
<p><kbd>.*[]^${}\+?|()</kbd></p>
<p>You must escape them with a backslash because these characters are special characters for the regex engines.</p>
</div>
</div>
<p>Now you know how to define a BRE pattern. Let's use the common BRE characters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Anchor characters</h1>
                </header>
            
            <article>
                
<p>Anchor characters are used to match the beginning or the end of a line. There are two anchor characters: the caret (<kbd>^</kbd>) and the dollar sign (<kbd>$</kbd>).</p>
<p>The caret character is used to match the beginning of a line:</p>
<pre class="CommandLineEndPACKT"><strong><span class="CodeHighlightedPACKT"><span>$ echo "Welcome to shell scripting" | awk '/^Welcome/{print $0}'<br/></span></span><span class="CodeHighlightedPACKT"><span>$ echo "SHELL scripting" | awk '/^Welcome/{print $0}'<br/></span></span><span class="CodeHighlightedPACKT"><span>$ echo "Welcome to shell scripting" | sed -n '/^Welcome/p'</span></span></strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-549 image-border" src="assets/d8f1ea73-b463-4950-9c52-83b5072c813d.png" style="width:55.33em;height:9.25em;"/></div>
<p>So, the caret character is used to check whether the specified text is at the beginning of the line.</p>
<p>If you want to search for the caret as a character, you should escape it with a backslash if you use AWK.</p>
<p>However, if you use <kbd>sed</kbd>, you don't need to escape it:</p>
<pre><strong>$ echo "Welcome ^ is a test" | awk '/\^/{print $0}'</strong><br/><strong>$ echo "Welcome ^ to shell scripting" | sed -n '/^/p'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-550 image-border" src="assets/3b7e3143-dce9-44fb-8c75-74d909d6c774.png" style="width:59.42em;height:8.92em;"/></div>
<p>To match the end of the text, you can use the dollar sign character (<kbd>$</kbd>):</p>
<pre><strong>$ echo "Welcome to shell scripting" | awk '/scripting$/{print $0}'</strong><br/><strong>$ echo "Welcome to shell scripting" | sed -n '/scripting$/p'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-551 image-border" src="assets/33bcc23d-2001-4748-b36c-abe7823253c9.png" style="width:54.25em;height:7.92em;"/></div>
<p>You can use both characters (<kbd>^</kbd>) and (<kbd>$</kbd>) in the same pattern to specify text.</p>
<p>You can use these characters to do something useful, such as search for empty lines and trim them:</p>
<pre><strong>$ awk '!/^$/{print $0}' myfile</strong></pre>
<p>The exclamation mark (<kbd>!</kbd>) is called the negation character, which negates what's after it.</p>
<p>The pattern searches for <kbd>^$</kbd> where the caret (<kbd>^</kbd>) refers to the beginning of a line and the dollar sign (<kbd>$</kbd>) refers to the end of a line, which means search for lines that have nothing between the beginning and the end which means empty lines. Then we negate that with the exclamation mark (<kbd>!</kbd>) to get the other lines that are not empty. </p>
<p>Let's apply it to the following file:</p>
<pre>Lorem Ipsum is simply dummy text .<br/>Lorem Ipsum has been the industry's standard dummy.<br/>It has survived not only five centuries<br/>It is a long established fact that a reader will be distracted.</pre>
<p>Now, let's see the magic:</p>
<pre><strong>$ awk '!/^$/{print $0}' myfile</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-552 image-border" src="assets/c5be77fb-44be-46be-a43a-315f2b15ae9b.png" style="width:41.67em;height:9.17em;"/></div>
<p>The lines are printed without the empty lines.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The dot character</h1>
                </header>
            
            <article>
                
<p>The dot character matches any character except the new line (<kbd>\n</kbd>). Let's use it against the following file:</p>
<pre>Welcome to shell scripting.<br/>I love shell scripting.<br/>shell scripting is awesome.</pre>
<p>Say we use the following commands:</p>
<pre><strong>$ awk '/.sh/{print $0}' myfile</strong><br/><strong>$ sed -n '/.sh/p' myfile</strong></pre>
<p>This pattern matches any line containing <kbd>sh</kbd> and any text before it:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-553 image-border" src="assets/c8a32a75-3f95-4a96-869f-2d85c23a0a56.png" style="width:39.83em;height:10.50em;"/></div>
<p>As you can see, it matches the first two lines only because the third line starts with <kbd>sh</kbd>, so no match for the third line.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The character class</h1>
                </header>
            
            <article>
                
<p>We saw how to match any character using the dot character. What if you want to match a specific set of characters only?</p>
<p>You can pass the characters you want to match between square brackets <kbd>[]</kbd> to match them, and this is the character class.</p>
<p>Let's take the following file as an example:</p>
<pre>I love bash scripting.<br/>I hope it works without a crash.<br/>Or I'll smash it.</pre>
<p>Let's see how the character class works:</p>
<pre><strong>$ awk '/[mbr]ash/{print $0}' myfile</strong><br/><strong><span class="CodeHighlightedPACKT"><span>$ sed -n '/[mbr]ash/p' myfile</span></span></strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-554 image-border" src="assets/28fb6091-3614-4e70-91ef-7239f1fdf206.png" style="width:42.75em;height:12.25em;"/></div>
<p>The character class <kbd>[mbr]</kbd> matches any of the included characters followed by ash, so this matches the three lines.</p>
<p>You can employ it in something useful, such as matching an uppercase or a lower case character:</p>
<pre><strong>$ echo "Welcome to shell scripting" | awk '/^[Ww]elcome/{print $0}'</strong><br/><strong>$ echo "welcome to shell scripting" | awk '/^[Ww]elcome/{print $0}'</strong></pre>
<p>The character class is negated using the caret character like this:</p>
<pre><strong>$ awk '/[^br]ash/{print $0}' myfile  </strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-555 image-border" src="assets/34670994-fa8c-4609-9d6c-6e9cdf6c2eeb.png" style="width:47.50em;height:7.00em;"/></div>
<p>Here, we match any line that contains ash and starts neither with <kbd>b</kbd> nor <kbd>r</kbd>.</p>
<div class="packt_infobox">
<p>Remember that using the caret character (<kbd>^</kbd>) outside the square brackets means the beginning of a line.</p>
</div>
<p>Using character class, you specify your characters. What if you have a long range of characters?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ranges of characters</h1>
                </header>
            
            <article>
                
<p>You can specify a range of characters to match between square brackets as follows:</p>
<pre>[a-d]</pre>
<p>This means the range of characters from <kbd>a</kbd> to <kbd>d</kbd>, so <kbd>a</kbd>, <kbd>b</kbd>, <kbd>c</kbd>, and <kbd>d</kbd> are included.</p>
<p>Let's use the same previous example file:</p>
<pre><strong>$ awk '/[a-m]ash/{print $0}' myfile</strong><br/><strong>$ sed -n '/[a-m]ash/p' myfile</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-556 image-border" src="assets/6f93ec93-4c27-433a-a297-5f0e63776824.png" style="width:41.92em;height:9.92em;"/></div>
<p>The character range from <kbd>a</kbd> to <kbd>m</kbd> is selected. The third line contains <kbd>r</kbd> before ash, which is not in our range, so only the second line doesn't match.</p>
<p>You can use numbers ranges as well:</p>
<pre><strong>$ awk '/[0-9]/'</strong></pre>
<p>This pattern means from <kbd>0</kbd> to <kbd>9</kbd> is matched.</p>
<p>You can write multiple ranges in the same bracket:</p>
<pre><strong>$ awk '/[d-hm-z]ash/{print $0}' myfile<br/></strong><strong>$ sed -n '/[d-hm-z]ash/p' myfile</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-557 image-border" src="assets/27ed86b0-52da-4632-b4ae-626b7b772dfd.png" style="width:42.42em;height:10.00em;"/></div>
<p>In this pattern, from <kbd>d</kbd> to <kbd>h</kbd> and from <kbd>m</kbd> to <kbd>z</kbd> are selected and since the first line contains <kbd>b</kbd> before ash, only the first line doesn't match.</p>
<p>You can use the ranges to select all uppercase and lowercase characters as follows:</p>
<pre><strong>$ awk '/[a-zA-Z]/'</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Special character classes</h1>
                </header>
            
            <article>
                
<p>We saw how to match a set of characters using the character class, then we saw how to match a range of characters using character ranges.</p>
<p>Actually, the ERE engine offers ready-to-use classes to match some common sets of characters as follows:</p>
<table>
<tbody>
<tr>
<td><kbd><span>[[:alpha:]]</span></kbd></td>
<td>
<p class="mce-root"><span>Matches any alphabetical character</span></p>
</td>
</tr>
<tr>
<td><span><kbd>[[:upper:]]</kbd></span>  <span>      </span></td>
<td>
<p class="mce-root"><span>Matches A–Z uppercase only</span></p>
</td>
</tr>
<tr>
<td><span><kbd>[[:lower:]]</kbd> </span></td>
<td>
<p>Matches a–z lowercase only</p>
</td>
</tr>
<tr>
<td><kbd>[[:alnum:]]</kbd>        </td>
<td>
<p class="mce-root"><span>Matches 0–9, A–Z, or a–z</span></p>
</td>
</tr>
<tr>
<td><kbd>[[:blank:]] </kbd>       </td>
<td>
<p class="mce-root"><span>Matches space or Tab only</span></p>
</td>
</tr>
<tr>
<td><kbd>[[:space:]]</kbd>        </td>
<td>
<p class="mce-root"><span>Matches any whitespace character: space, Tab, CR</span></p>
</td>
</tr>
<tr>
<td><kbd>[[:digit:]]</kbd>       </td>
<td>
<p class="mce-root"><span>Matches from <kbd>0</kbd> to <kbd>9</kbd></span></p>
</td>
</tr>
<tr>
<td><kbd>[[:print:]]</kbd>         </td>
<td>
<p class="mce-root"><span>Matches any printable character</span></p>
</td>
</tr>
<tr>
<td><kbd>[[:punct:]]</kbd>        </td>
<td>
<p class="mce-root"><span>Matches any punctuation character</span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>So, if you want to match uppercase characters, you can use <kbd>[[:upper:]]</kbd> and it will work exactly as the character range [A-Z].</p>
<p>Let's test one of them against the following example file:</p>
<pre>checking special character classes.<br/>This LINE contains upper case.<br/>ALSO this one.</pre>
<p>We will match the uppercase characters to see how it works:</p>
<pre><strong>$ awk '/[[:upper:]]/{print $0}' myfile<br/></strong><strong>$ sed -n '/[[:upper:]]/p' myfile</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-558 image-border" src="assets/e84ecdd0-f595-4b80-b87a-ca8b9be0b072.png" style="width:42.25em;height:10.17em;"/></div>
<p>The uppercase special class makes it easy to match any line that contains uppercase letters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The asterisk</h1>
                </header>
            
            <article>
                
<p>The asterisk is used to match the existence of a character or a character class zero or more times.</p>
<p>This can be useful when searching for a word with multiple variations or that has been misspelled:</p>
<pre><strong>$ echo "Checking colors" | awk '/colou*rs/{print $0}'<br/></strong><strong>$ echo "Checking colours" | awk '/colou*rs/{print $0}'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-559 image-border" src="assets/eb7e9eba-4b9a-4a35-beac-2b997b5fe68f.png" style="width:49.00em;height:8.08em;"/></div>
<p>If the character <kbd>u</kbd> doesn't exist at all or exists, that will match the pattern.</p>
<p>We can benefit from the asterisk character by using it with the dot character to match any number of characters.</p>
<p>Let's see how to use them against the following example file:</p>
<pre>This is a sample line<br/>And this is another one<br/>This is one more<br/>Finally, the last line is this</pre>
<p>Let's write a pattern that matches any line that contains the word <kbd>this</kbd> and anything after it:</p>
<pre><strong>$ awk '/this.*/{print $0}' myfile<br/></strong><strong>$ sed -n '/ this.*/p' myfile</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-560 image-border" src="assets/4287e60f-8f82-4e9c-8833-85373ef9401f.png" style="width:43.33em;height:10.67em;"/></div>
<p>The fourth line contains the word <kbd>this</kbd>, but the first and third lines contain a capital <kbd>T</kbd>, so that it doesn't match.</p>
<p>The second line contains the word and text after it, whereas the fourth line contains the word and nothing after it, and in both cases, the asterisk matches zero or more instances.</p>
<p>You can use the asterisk with the character class to match the existence of any character inside the character class for one time or none at all.</p>
<pre><strong>$ echo "toot" | awk '/t[aeor]*t/{print $0}'<br/></strong><strong>$ echo "tent" | awk '/t[aeor]*t/{print $0}'<br/></strong><strong>$ echo "tart" | awk '/t[aeor]*t/{print $0}'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-562 image-border" src="assets/077b53df-f18a-4cd9-9711-aa066c304951.png" style="width:45.92em;height:9.42em;"/></div>
<p>The first line contains the character <kbd>o</kbd> two times, so it matches.</p>
<p>The second line contains the <kbd>n</kbd> character, which doesn't exist in the character class, so there is no match.</p>
<p>The third line contains the characters <kbd>a</kbd> and <kbd>r</kbd>, once for each, and they exist in the character class, so that line matches the pattern too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining ERE patterns</h1>
                </header>
            
            <article>
                
<p>We saw how easy it is to define BRE patterns. Now, we will see some ERE patterns, which are more powerful.</p>
<p>ERE engines understand the following patterns besides BRE patterns:</p>
<ul>
<li>Question marks</li>
<li>Plus signs</li>
<li>Curly braces</li>
<li>Pipe characters</li>
<li>Expression grouping</li>
</ul>
<p>By default, AWK supports ERE patterns, and sed needs <kbd>-r</kbd> to understand these patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The question mark</h1>
                </header>
            
            <article>
                
<p>The question mark matches the existence of the preceding character or character class zero or one time only:</p>
<pre><strong>$ echo "tt" | awk '/to?t/{print $0}'<br/></strong><strong>$ echo "tot" | awk '/to?t/{print $0}'<br/></strong><strong>$ echo "toot" | awk '/to?t/{print $0}'<br/></strong><strong>$ echo "tt" | sed -r -n '/to?t/p'<br/></strong><strong>$ echo "tot" | sed -r -n '/to?t/p'<br/></strong><strong>$ echo "toot" | sed -r -n '/to?t/p'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-563 image-border" src="assets/7bcf636d-ba4a-4cb1-bbea-e8e2c994bb96.png" style="width:48.17em;height:14.75em;"/></div>
<p>In the first two examples, the character <kbd>o</kbd> exists zero and one time, whereas in the third example, it exists two times, which doesn't match the pattern</p>
<p>In the same way, you can use the question mark with the character class:</p>
<pre><strong>$ echo "tt" | awk '/t[oa]?t/{print $0}'<br/></strong><strong>$ echo "tot" | awk '/t[oa]?t/{print $0}'<br/></strong><strong>$ echo "toot" | awk '/t[oa]?t/{print $0}'<br/></strong><strong>$ echo "tt" | sed -r -n '/t[oa]?t/p'<br/></strong><strong>$ echo "tot" | sed -r -n '/t[oa]?t/p'<br/></strong><strong>$ echo "toot" | sed -r -n '/t[oa]?t/p'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-565 image-border" src="assets/0e811e77-6ec6-43b0-afb4-e1208a15dcc5.png" style="width:50.58em;height:15.50em;"/></div>
<p class="NormalPACKT">The third example only doesn't match because it contains the <kbd>o</kbd> character two times.</p>
<p class="NormalPACKT">Note that when using the question mark with the character class, it doesn't need to have all of character class in the text; one is enough to pass the pattern</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The plus sign</h1>
                </header>
            
            <article>
                
<p>The plus sign matches the existence of the preceding character or character class one time or more, so it must exist at least once:</p>
<pre><strong>$ echo "tt" | awk '/to+t/{print $0}'<br/></strong><strong>$ echo "tot" | awk '/to+t/{print $0}'<br/></strong><strong>$ echo "toot" | awk '/to+t/{print $0}'<br/></strong><strong>$ echo "tt" | sed -r -n '/to+t/p'<br/></strong><strong>$ echo "tot" | sed -r -n '/to+t/p'<br/></strong><strong>$ echo "toot" | sed -r -n '/to+t/p'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-566 image-border" src="assets/5064634c-3d63-494c-bb9a-c73b222dcb2f.png" style="width:47.42em;height:14.58em;"/></div>
<p class="NormalPACKT">The first example doesn't have an <kbd>o</kbd> character, and that's why it's the only example that has no match.</p>
<p class="NormalPACKT">Also, we can use the plus sign with the character class:</p>
<pre class="NormalPACKT"><strong><span class="CodeHighlightedPACKT"><span>$ echo "tt" | awk '/t[oa]+t/{print $0}'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "tot" | awk '/t[oa]+t/{print $0}'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "toot" | awk '/t[oa]+t/{print $0}<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "tt" | sed -r -n '/t[oa]+t/p'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "tot" | sed -r -n '/t[oa]+t/p'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "toot" | sed -r -n '/t[oa]+t/p'</span></span></strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-567 image-border" src="assets/1f9349ec-3cf3-4421-8205-0687c94763f9.png" style="width:45.08em;height:13.83em;"/></div>
<p class="NormalPACKT">The first example only doesn't match because it contains no <kbd>o</kbd> character at all. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Curly braces</h1>
                </header>
            
            <article>
                
<p class="NormalPACKT">The curly braces define the number of existence of the preceding character or character class:</p>
<pre class="NormalPACKT"><strong><span class="CodeHighlightedPACKT"><span>$ echo "tt" | awk '/to{1}t/{print $0}'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "tot" | awk '/to{1}t/{print $0}'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "toot" | awk '/to{1}t/{print $0}'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "tt" | sed -r -n '/to{1}t/p'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "tot" | sed -r -n '/to{1}t/p'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "toot" | sed -r -n '/to{1}t/p'</span></span></strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-568 image-border" src="assets/26941951-26af-4be6-a3b5-a6590b37a572.png" style="width:45.25em;height:11.92em;"/></div>
<p class="NormalPACKT">The third example doesn't contain any matches because the <kbd>o</kbd> character exists two times. So, what if you want to specify a more flexible number?</p>
<p class="NormalPACKT">You can specify a range inside the curly braces:</p>
<pre class="NormalPACKT"><strong><span class="CodeHighlightedPACKT"><span>$ echo "toot" | awk '/to{1,2}t/{print $0}'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "toot" | sed -r -n '/to{1,2}t/p'</span></span></strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-570 image-border" src="assets/4077696d-7328-4b22-9f81-a9181f03e081.png" style="width:48.58em;height:8.67em;"/></div>
<p class="NormalPACKT">Here, we match the <kbd>o</kbd> character if it exists one or two times.</p>
<p class="NormalPACKT">Also, you can use the curly braces with the character class:</p>
<pre class="NormalPACKT"><strong><span class="CodeHighlightedPACKT"><span>$ echo "tt" | awk '/t[oa]{1}t/{print $0}'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "tot" | awk '/t[oa]{1}t/{print $0}'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "toot" | awk '/t[oa]{1}t/{print $0}'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "tt" | sed -r -n '/t[oa]{1}t/p'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "tot" | sed -r -n '/t[oa]{1}t/p'<br/></span></span></strong><strong><span class="CodeHighlightedPACKT"><span>$ echo "toot" | sed -r -n '/t[oa]{1}t/p'</span></span></strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-571 image-border" src="assets/8c3c15cb-3de6-4cf6-a140-3fac0523afdd.png" style="width:40.92em;height:10.83em;"/></div>
<p>As expected, if any of the characters <kbd>[oa]</kbd> exists for one time, the pattern will match.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pipe character</h1>
                </header>
            
            <article>
                
<p>The pipe character (<kbd>|</kbd>) tells the regex engine to match any of the passed strings. So, if one of them exists, that is enough for the pattern to match. It's like a logical <kbd>OR</kbd> between the passed strings:</p>
<pre><strong>$ echo "welcome to shell scripting" | awk '/Linux|bash|shell/{print $0}'<br/></strong><strong>$ echo "welcome to bash scripting" | awk '/Linux|bash|shell/{print $0}'<br/></strong><strong>$ echo "welcome to Linux scripting" | awk '/Linux|bash|shell/{print $0}'<br/></strong><strong>$ echo "welcome to shell scripting" | sed -r -n '/Linux|bash|shell/p'<br/></strong><strong>$ echo "welcome to bash scripting" | sed -r -n '/Linux|bash|shell/p'<br/></strong><strong>$ echo "welcome to Linux scripting" | sed -r -n '/Linux|bash|shell/p'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-572 image-border" src="assets/34c4b0fa-ea04-4185-a4ae-607b9b44fdc2.png" style="width:47.25em;height:20.75em;"/></div>
<div>
<p class="NormalPACKT">All the previous examples have a match, since any of the three words exists in each example.</p>
<div class="packt_infobox">
<p>There are no spaces between the pipes and the words. </p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Expression grouping</h1>
                </header>
            
            <article>
                
<p>You can use parentheses <kbd>()</kbd> to group characters or words to make them one piece in the eyes of the regex engine:</p>
<pre><strong>$ echo "welcome to shell scripting" | awk '/(shell scripting)/{print $0}'<br/></strong><strong>$ echo "welcome to bash scripting" | awk '/(shell scripting)/{print $0}'<br/></strong><strong>$ echo "welcome to shell scripting" | sed -r -n '/(shell scripting)/p'<br/></strong><strong>$ echo "welcome to bash scripting" | sed -r -n '/(shell scripting)/p'</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-573 image-border" src="assets/65059931-7d4e-4bec-a292-51b6ec6273fe.png" style="width:48.92em;height:13.83em;"/></div>
<div>
<p>Since the <kbd>shell scripting</kbd> string is grouped with parentheses, it will be treated as a single piece.</p>
<p>So, if the entire sentence doesn't exist, the pattern will fail.</p>
<p>You may have realized that you can achieve that without parentheses like this:</p>
<pre><strong>$ echo "welcome to shell scripting" | sed -r -n '/shell scripting/p'</strong></pre>
<p>So, what is the benefit of using parentheses or expression grouping? Check the following examples to know the difference.</p>
<p>You can use any of the ERE characters with the grouping parentheses:</p>
<pre><strong>$ echo "welcome to shell scripting" | awk '/(bash scripting)?/{print $0}'<br/></strong><strong>$ echo "welcome to shell scripting" | awk '/(bash scripting)+/{print $0}'<br/></strong><strong>$ echo "welcome to shell scripting" | sed -r -n '/(bash scripting)?/p'<br/></strong><strong>$ echo "welcome to shell scripting" | sed -r -n '/(bash scripting)+/p'<br/></strong></pre></div>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-575 image-border" src="assets/d3416465-eb77-481c-8153-f1fc151c952c.png" style="width:49.42em;height:14.00em;"/></div>
<p class="NormalPACKT">In the first example, we search for the whole sentence <kbd>bash scripting</kbd> for zero or one time using the question mark, and because the whole sentence doesn't exist, the pattern succeeds.</p>
<p class="NormalPACKT">Without expression grouping, you won't get the same result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using grep</h1>
                </header>
            
            <article>
                
<p class="NormalPACKT">If we wanted to talk properly about <kbd>grep</kbd>, an entire book would not be enough. <kbd>grep</kbd> supports many engines along with BRE and ERE. It supports engines such as <strong>Perl-compatible regular expression</strong> (<strong>PCRE</strong>).</p>
<p class="NormalPACKT">The <kbd>grep</kbd> is a very powerful tool that most system administrators use every day. We just want to enlighten the point of using BRE and ERE patterns as we did with sed and AWK.</p>
<p class="NormalPACKT"><kbd>grep</kbd> tool understands BRE patterns by default, and if you want to use ERE patterns, you should use the <kbd>-E</kbd> option.</p>
<p class="NormalPACKT">Let's work with the following example file and use a BRE pattern:</p>
<pre class="CommandLineEndPACKT"><span class="CodeHighlightedPACKT"><span>Welcome to shell scripting.<br/></span></span><span class="CodeHighlightedPACKT"><span>love shell scripting.<br/></span></span><span class="CodeHighlightedPACKT"><span>shell scripting is awesome.</span></span></pre>
<p class="NormalPACKT">Let's test a BRE pattern:</p>
<pre class="CommandLineEndPACKT"><strong><span class="CodeHighlightedPACKT"><span>$ grep '.sh' myfile</span></span></strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-576 image-border" src="assets/87d4985b-8e2b-40ad-bc18-c3d8db1d2c91.png" style="width:40.33em;height:7.00em;"/></div>
<p class="NormalPACKT">The results are colored in red.</p>
<p class="NormalPACKT">Let's test an ERE pattern:</p>
<pre class="CommandLineEndPACKT"><strong><span class="CodeHighlightedPACKT"><span>$ grep -E 'to+' myfile</span></span></strong></pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-577 image-border" src="assets/a6b3f540-f2f8-47d9-ac20-e41e0ef8d74c.png" style="width:41.08em;height:6.17em;"/></div>
<p class="NormalPACKT">All other ERE characters can be used in the same way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="NormalPACKT">In this chapter, we covered regular expressions and the regex engines BRE and ERE. We learned how to define patterns for them.</p>
<p class="NormalPACKT">We learned how to write these patterns for sed, AWK, and <kbd>grep</kbd>.</p>
<p class="NormalPACKT">Also, we saw how the special character classes make it easy to match sets of characters.</p>
<p class="NormalPACKT">We saw how to use the powerful ERE patterns and how to group expressions.</p>
<p class="NormalPACKT">Finally, we saw how to use the <kbd>grep</kbd> tool and how to define BRE and ERE patterns.</p>
<p class="NormalPACKT">In the next two chapters, we will see some practical examples for AWK.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="NormalPACKT">Assume that you have the following file:</li>
</ol>
<pre class="CommandLineEndPACKT" style="padding-left: 60px"><span class="CodeHighlightedPACKT"><span>Welcome to shell scripting.<br/></span></span><span class="CodeHighlightedPACKT"><span>I love shell scripting.<br/></span></span><span class="CodeHighlightedPACKT"><span>shell scripting is awesome.</span></span></pre>
<p class="NormalPACKT" style="padding-left: 60px">Say you run the following command:</p>
<pre class="NormalPACKT" style="padding-left: 60px"><strong><span class="CodeHighlightedPACKT"><span>$ awk '/awesome$/{print $0}' myfile</span></span></strong></pre>
<p class="NormalPACKT" style="padding-left: 60px">How many lines will be printed in the output?</p>
<ol start="2">
<li class="NormalPACKT">How many lines will be printed if we use the following command against the previous file?</li>
</ol>
<pre class="NormalPACKT" style="padding-left: 60px"><strong><span class="CodeHighlightedPACKT"><span>$ awk '/scripting\..*/{print $0}' myfile</span></span></strong></pre>
<ol start="3">
<li>How many lines will be printed if we use the following command against the previous sample file?</li>
</ol>
<pre style="padding-left: 60px"><strong>$ awk '/^[Ww]?/{print $0}' myfile</strong></pre>
<ol start="4">
<li class="NormalPACKT">What is the output of the following command?</li>
</ol>
<pre class="NormalPACKT" style="padding-left: 60px"><strong><span class="CodeHighlightedPACKT"><span>$ echo "welcome to shell scripting" | sed -n '/Linux|bash|shell/p'</span></span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>Please see the following for further reading related to this chapter:</span></p>
<ul>
<li><a href="https://www.regular-expressions.info/engine.html">https://www.regular-expressions.info/engine.html</a></li>
<li><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_04.html">http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_04.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>