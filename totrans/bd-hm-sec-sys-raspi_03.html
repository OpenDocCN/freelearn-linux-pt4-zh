<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Extending Your Pi to Connect More Things"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Extending Your Pi to Connect More Things</h1></div></div></div><p>We're now going to look at ways to expand the number of things we can connect to our Raspberry Pi, overcoming the limitation of having just the 8 digital pins available. We're going to do this by building our own expansion board to give us what could in theory be an unlimited number of digital inputs and outputs.</p><p>We're also going to overcome the limitations of the +3.3V power available to us by building our own +3.3V power supply that taps off the Raspberry Pi's +5V supply.</p><p>In this chapter, we will cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Looking at the I<sup>2</sup>C bus in detail</li><li class="listitem" style="list-style-type: disc">Learning about serial-to-parallel and parallel-to-serial conversions</li><li class="listitem" style="list-style-type: disc">Building a +3.3V power supply</li><li class="listitem" style="list-style-type: disc">Building an I2C-based port expander to give us more inputs and outputs</li><li class="listitem" style="list-style-type: disc">Looking at alternative ready-made expansion boards</li></ul></div><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Prerequisites</h1></div></div></div><p>Along with your <a id="id92" class="indexterm"/>Raspberry Pi, you'll need the following parts for the projects in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A copper strip board (or Veroboard®)</li><li class="listitem" style="list-style-type: disc">An LD1117V33 voltage regulator</li><li class="listitem" style="list-style-type: disc">A 2 x 100nF, 16V ceramic capacitor</li><li class="listitem" style="list-style-type: disc">A 10uF, 16V electrolytic capacitor</li><li class="listitem" style="list-style-type: disc">A 1 x MCP23017 16-bit port expander IC</li><li class="listitem" style="list-style-type: disc">A 4 x 10K-ohm resistor</li><li class="listitem" style="list-style-type: disc">A hook-up wire</li></ul></div></div></div>
<div class="section" title="The I2C bus"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>The I2C bus</h1></div></div></div><p>In the previous chapter, we briefly touched on the I2C bus (or Inter-Integrated Circuit bus), which is a way to connect multiple devices together using just two wires. I2C was invented in the early 1980s by Philips as a way to link computer peripherals together using a common <a id="id93" class="indexterm"/>protocol. You can think of I2C as a kind of early form of USB.</p><p>I2C typically operates at relatively low speeds of up to 100kbit/s, compared to much faster interfaces such as Ethernet, which typically operates at up to 1Gbit/s, or USB, which can operate at up to 480Mbit/s. However, this is fast enough to connect basic sensors, display devices, or other peripherals such as real-time clocks—in fact; there are faster versions of the protocol that some devices will support.</p><div class="section" title="Just 2 wires"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Just 2 wires</h2></div></div></div><p>I2C is a bi-directional serial communication protocol that operates over two wires:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id94" class="indexterm"/><span class="strong"><strong>Serial Data Line</strong></span> (<span class="strong"><strong>SDA</strong></span>) wire transmits the data to and from the master device. Referring back to the GPIO reference in Chapter 2, <span class="emphasis"><em>Connecting Things to Your Pi with GPIO</em></span>, this is pin 3 of the GPIO connector.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Serial Clock Line</strong></span> (<span class="strong"><strong>SCL</strong></span>) wire<a id="id95" class="indexterm"/> handles all timing and flow control for the data on the bus. This is pin 5 of the GPIO connector.</li></ul></div><p>You'll remember that we spoke about pull-up resistors, in the previous chapter, which ensure that the GPIO digital inputs are pulled to a known state. Well, this is required for the two lines on the I2C bus, and by default the lines should be pulled high with resistors. However, on the Raspberry Pi, this has already been done for us, so we don't need to worry about it in our case.</p></div><div class="section" title="What's your address?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>What's your address?</h2></div></div></div><p>So, if we can use just two wires to communicate with multiple devices, how does our Raspberry Pi know which device to talk to? This is where the I2C protocol comes into its own. Each <a id="id96" class="indexterm"/>device connected to the bus has its own unique ID, or address, made up of 7-bits or 10-bits. Some devices will allow you to set the address to ensure that it's unique within your system, but other devices have their addresses hardcoded by the manufacturer.</p><p>The two addressing methods (7- and 10-bit) are interoperable and you can have devices on the same bus that use either method, since the Raspberry Pi itself supports both methods. So, with a 10-bit addressing scheme, you can see that we can connect a lot of things to our Raspberry<a id="id97" class="indexterm"/> Pi using the I2C bus, as compared to the limited number of digital pins on the GPIO!</p></div><div class="section" title="There is a parallel universe"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>There is a parallel universe</h2></div></div></div><p>Data is normally transmitted in serial mode or parallel mode, depending on things such as the required data speed, cable distance, and functionality. Most data communication <span class="emphasis"><em>between</em></span> systems is transmitted in serial mode over a couple of wires, such as the I2C bus mentioned earlier, but this also includes things such as the Ethernet, RS232/422, and USB.</p><p>Within a <a id="id98" class="indexterm"/>computer system, data is transmitted in parallel mode using <span class="emphasis"><em>buses</em></span> whose width matches the word size of the digital system communicating between chips. In parallel mode, all bits of the data word are transmitted simultaneously over their respective data lines within the bus, rather than as sequential bits along a single line.</p><p>The digital I/O pins we've been talking about (including the ones on the Raspberry Pi's GPIO connector) are usually grouped together as a parallel bus. On our system, we'll be using parallel buses (groups of digital I/O pins) that are 8-bits wide. That is, the bus has 8 wires that can be set or read using 8-bit binary values (our word size).</p><div class="mediaobject"><img src="graphics/B04579_03_08.jpg" alt="There is a parallel universe"/><div class="caption"><p>A representation of an 8-bit data bus</p></div></div><p>So, in the preceding diagram we have the 8 digital I/O wires on our bus. If we wanted to make the bits (or wires) 0, 1, and 4 <span class="emphasis"><em>high</em></span> or <span class="emphasis"><em>on</em></span>, with the rest <span class="emphasis"><em>low</em></span> or <span class="emphasis"><em>off</em></span>, then we'd address the bus and set it to the following values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In binary, this would be 00010011</li><li class="listitem" style="list-style-type: disc">In hex, this would be <span class="emphasis"><em>0x13</em></span></li><li class="listitem" style="list-style-type: disc">In decimal, this would be 19 (represented by <span class="emphasis"><em>16+2+1</em></span>)</li></ul></div><p>So, in other <a id="id99" class="indexterm"/>words, to switch on data lines 0, 1, and 4, we send the byte value, 19, to the bus's address.</p><div class="section" title="Serial-to-parallel conversion"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Serial-to-parallel conversion</h3></div></div></div><p>So, now that we<a id="id100" class="indexterm"/> know what numbers to send to our bus to switch on or switch off certain digital outputs, or read certain digital inputs, how do we do this using our I2C bus, which is a serial interface?</p><p>Fortunately, there are <a id="id101" class="indexterm"/>many <span class="strong"><strong>integrated circuits</strong></span> (<span class="strong"><strong>ICs</strong></span>) available that allow us to do this simply and easily. These ICs <a id="id102" class="indexterm"/>are called <span class="strong"><strong>shift registers</strong></span> and perform <a id="id103" class="indexterm"/>
<span class="strong"><strong>serial-to-parallel conversions</strong></span>, taking the data from the serial I2C bus and converting the incoming bits to a parallel representation by setting each of the parallel bus outputs.</p><p>When reading the parallel bus data lines as inputs, the reverse happens, converting the bits into a serial form on<a id="id104" class="indexterm"/> the I2C bus; this is known as <span class="strong"><strong>parallel-to-serial</strong></span> conversion.</p><p>This is quite a simplistic overview and there are many resources available that explain these operations; we'll see this in action later in the chapter, but first…</p></div></div></div>
<div class="section" title="Give me power"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Give me power</h1></div></div></div><p>You'll remember from the previous chapter that most things to do with the GPIO operate on a +3.3V level, rather than the +5V level that is often associated with digital circuits. This is the same with our I2C-based shift registers—they need to operate on +3.3V levels as well, in order to work <a id="id105" class="indexterm"/>with the Raspberry Pi.</p><p>You'll also recall, however, that there's not much +3.3V juice available directly from the Raspberry Pi—in fact, just 50mA. This is really not enough for our interface. So, before we go any further, we're going to build our own +3.3V power supply, which is sufficient for our system.</p><p>For our power supply, we're <a id="id106" class="indexterm"/>going to use a basic 3.3V <span class="strong"><strong>voltage regulator</strong></span> (type<span class="strong"><strong> LD1117V33</strong></span>) that will take our slightly more plentiful +5V supply from the Raspberry Pi and regulate it to a nice smooth +3.3V supply. We should be able to draw a few hundred milliamps from this supply—enough for the I/O circuitry on our security system.</p><p>The parts required for our power supply are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A LD1117V33 voltage regulator</li><li class="listitem" style="list-style-type: disc">A 100nF, 16V ceramic capacitor</li><li class="listitem" style="list-style-type: disc">A 10uF, 16V electrolytic capacitor</li></ul></div><p>Here's<a id="id107" class="indexterm"/> the circuit <a id="id108" class="indexterm"/>diagram for our +3.3V power supply:</p><div class="mediaobject"><img src="graphics/B04579_03_01.jpg" alt="Give me power"/></div><p>As with all our components, the LD1117V33 regulator is widely available from many electronic component suppliers.</p><p>Our power supply can be easily built on a small piece of strip board like this:</p><div class="mediaobject"><img src="graphics/B04579_03_02.jpg" alt="Give me power"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>The strip board is<a id="id109" class="indexterm"/> shown from the top in the preceding layout. That is, the copper tracks are on the underside of the board and the components are inserted from the plain top-side and soldered to the strips underneath. In this layout, it's not necessary to cut any of the tracks on the strip board.</p></div></div></div>
<div class="section" title="Building an I2C expander"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Building an I2C expander</h1></div></div></div><p>Right, now that <a id="id110" class="indexterm"/>we've worked out what we need to do to give us more digital I/O pins, and built our power supply for it, we can build our expansion port.</p><p>To do this, we're going to use a <a id="id111" class="indexterm"/>chip designed exactly for the job: the <span class="strong"><strong>MCP23017</strong></span>, manufactured by Microchip and widely available from electronic suppliers.</p><p>The MCP23017 is an integrated circuit that connects directly to the I2C bus (the SDA and SCL pins we talked about earlier) and gives us 16 bi-directional input and output pins. If required, we can connect up to 8 of these chips to the same bus, giving us up to 128 inputs and outputs (yes, I know that I said "virtually unlimited" previously, but I'll explain later).</p><div class="mediaobject"><img src="graphics/B04579_03_03.jpg" alt="Building an I2C expander"/><div class="caption"><p>An MCP23017 integrated circuit pinout</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>The full datasheet for the MCP23017 is available on Microchip's site, which can<a id="id112" class="indexterm"/> be found at <a class="ulink" href="http://www.microchip.com/MCP23017">www.microchip.com/MCP23017</a>.</p></div></div><div class="section" title="The I2C port expander circuit"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>The I2C port expander circuit</h2></div></div></div><p>The basic parts <a id="id113" class="indexterm"/>you will need to build your port expander are as<a id="id114" class="indexterm"/> follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A 1 x MCP23017 16-bit port expander IC</li><li class="listitem" style="list-style-type: disc">A 4 x 10K-ohm resistor</li><li class="listitem" style="list-style-type: disc">A 1 x 100nF, 16V ceramic capacitor</li><li class="listitem" style="list-style-type: disc">A copper strip board (or Veroboard®)</li><li class="listitem" style="list-style-type: disc">A hook-up wire</li></ul></div><p>Here's the circuit diagram for our I2C port expander circuit. It looks complicated, but actually most of the lines are for connections to the outside world:</p><div class="mediaobject"><img src="graphics/B04579_03_04.jpg" alt="The I2C port expander circuit"/></div><div class="section" title="Let's walk through the circuit"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>Let's walk through the circuit</h3></div></div></div><p>On the right-hand<a id="id115" class="indexterm"/> side, the connector, CN1, is our Raspberry Pi GPIO connector—note that we're only using four of the pins:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The +5V Output (Pin 2)</li><li class="listitem" style="list-style-type: disc">The I2C SDA (Pin 3)</li><li class="listitem" style="list-style-type: disc">The I2C SCL (Pin 5)</li><li class="listitem" style="list-style-type: disc">The 0V/GND (Pin 6)</li></ul></div><p>You'll see my friend, the +3.3V regulator (U1, C1, and C2), discussed earlier. This takes the +5V output from the Raspberry Pi and gives us our +3.3V for use by the rest of the circuit.</p><p>The main<a id="id116" class="indexterm"/> component is U2—our <span class="strong"><strong>MCP23017</strong></span> <span class="strong"><strong>port expander</strong></span> chip. Pins 9 and 10 on the chip are connected to the +3.3V supply and the GND, respectively, and C3 is used as a discoupling capacitor close to the chip to reduce any noise on the power supply.</p><p>The MCP23017 can be used as a 16-bit expander, or as 2 x 8-bit expanders. In our circuit, we have split the device to give us 2 x 8-bit busses: I/O Bus A and I/O Bus B. Each pin on the busses can be programmed to work as an input or output.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>
<span class="strong"><strong>Connecting things to the input/output pins</strong></span>
</p><p>The input and output pins on our busses can't usually be connected to things directly—they provide limited current and need to be interfaced correctly to things such as buzzers and lights; they must also be protected against damaging input signals. In the next chapter, we'll learn how to connect safely to our I/O ports.</p></div></div><p>The I2C SDA/SCL lines <a id="id117" class="indexterm"/>from the Raspberry Pi are connected to pins 12 and 13 of the chip. You'll see that there are also additional I2C outputs (PL1 to PL3) to illustrate that we can connect other devices to the I2C bus, such as another MCP23017 chip to give us a further 16 digital I/Os.</p><p>Resistor R1 is used to hold the RESET pin (18) high. By bringing this pin low, you can reset the chip.</p><p>Resistors R2 to R4 are used to hold the address pins A0 to A2 (pins 15-17) low.</p><p>
<span class="strong"><strong>Highs and lows</strong></span>
</p><p>When we use the terms <span class="emphasis"><em>high</em></span> and <span class="emphasis"><em>low</em></span> in respect to digital pins or inputs, we are simply describing whether <a id="id118" class="indexterm"/>the logic level of the pin is at a binary 1 or 0, respectively. Digital pins don't like to be left <span class="emphasis"><em>floating</em></span>—whereby they are neither high nor low—as this can cause unpredictable operations. Therefore, we always make sure they are held at a determined logic level. In general, connecting the pin to 0V (or ground) ensures<a id="id119" class="indexterm"/> that it's held at logic level 0, and connecting to the positive supply (e.g. 3.3V) ensures that it's held at logic level 1.</p><p>Remember I <a id="id120" class="indexterm"/>mentioned earlier that you can connect a large number of devices to the I2C bus in order to give us a virtually unlimited number of I/O pins? Well, actually in many cases, this is not strictly true. This is because of the addressing scheme for I2C devices, which makes all devices identifiable when they are all connected to the same two wires (their unique address). The address of each device is agreed upon in advance by manufacturers to make sure that everyone's devices will work together on the same bus without creating conflicts. As such, the address is pre-programmed into the device.</p><p>The MCP23017 has been given its unique base address, but can be modified by changing the address pins A0-A2 high or low; thus, in effect, it can be configured to be one of 8 addresses. This is why you can only have a maximum of 8 of these chips on the same I2C bus, giving us a theoretical maximum of 128 I/O pins (that is, 16 I/Os x 8 chips).</p></div></div><div class="section" title="Building your expansion board"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Building your expansion board</h2></div></div></div><p>This circuit can <a id="id121" class="indexterm"/>easily be built on a small piece of stripboard. The following image shows an example of the layout, which looks a bit simpler than the circuit diagram. In the next chapter, we'll learn how to connect up our board and program it so we can check that it works.</p><div class="mediaobject"><img src="graphics/B04579_03_05.jpg" alt="Building your expansion board"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>When using stripboard, make sure that you cut the tracks between the two rows of pins on the MCP23017 so that they aren't shorted together. You can buy track cutters, which make this task easy, from many electronic suppliers. Again, on the preceding layout, the copper strips are underneath the board with the components on the plain side.</p></div></div><p>You might want to add the +3.3V power supply circuit to the same piece of stripboard too, to keep everything contained together.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>In the next chapter, we will learn how to program the device so that we can use it in our home security system.</p></div></div></div></div>
<div class="section" title="Using ready-made expansion boards"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Using ready-made expansion boards</h1></div></div></div><p>While it's much more satisfying to build your own stuff, you might want to look at buying some readily available expansion boards for your home security system if you're not yet confident with your soldering iron, or if you just simply don't have the time.</p><p>Following are <a id="id122" class="indexterm"/>some ready-made expansion boards that you<a id="id123" class="indexterm"/> can obtain; they should work as part of our home security system with a bit of modification to our scripts to support the libraries that are required by the hardware.</p><div class="section" title="Hobbytronics MCP23017 expander port kit"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Hobbytronics MCP23017 expander port kit</h2></div></div></div><p>This kit is almost identical to our own circuit in the previous section of this chapter. The kit comes with an <a id="id124" class="indexterm"/>MCP23017, a PCB, and various connectors. The boards are designed to be daisy-chained together so that you can have multiple expanders to give you more input/output ports. Note<a id="id125" class="indexterm"/> that this kit is not pre-built and requires soldering, but I thought I'd include it because it's the board that I use<a id="id126" class="indexterm"/> to build such systems when prototyping. You can get it directly from Hobbytronics at <a class="ulink" href="http://bit.ly/mcp23017">http://bit.ly/mcp23017</a>.</p></div><div class="section" title="PiFace Digital I/O expansion board"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>PiFace Digital I/O expansion board</h2></div></div></div><p>The <span class="strong"><strong>PiFace Digital I/O expansion board</strong></span> is a pre-built version of our board, but it uses the <span class="strong"><strong>MSP23S17</strong></span> chip variant that operates over the <span class="strong"><strong>SPI bus</strong></span> instead of the I2C bus. The board is designed <a id="id127" class="indexterm"/>with 8 inputs<a id="id128" class="indexterm"/> and 8 outputs, as well as several additional pieces of hardware including a couple of relays, some LEDs, and some switches. Note that the code in this book for our system will <a id="id129" class="indexterm"/>need to be modified to work with this board, since it uses a different interface and different libraries. It's available from Farnell element14 at <a class="ulink" href="http://bit.ly/2434230">http://bit.ly/2434230</a>.</p><div class="mediaobject"><img src="graphics/B04579_03_06.jpg" alt="PiFace Digital I/O expansion board"/><div class="caption"><p>The PiFace Digital I/O Expansion Board</p></div></div></div><div class="section" title="Gertboard"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Gertboard</h2></div></div></div><p>The <span class="strong"><strong>Gertboard</strong></span> is a Raspberry Pi add-on board designed by Gert van Loo—one of the hardware engineers involved in the original design of the Raspberry Pi.</p><p>It's a very capable <a id="id130" class="indexterm"/>and reasonably-priced board that comes fully assembled and features 12 buffered input/output lines, open collector drivers for switching on devices that need a fair bit of current (such as sounders and lights), plus a digital-to-analog converter.</p><p>You can only <a id="id131" class="indexterm"/>connect one of these boards to your Raspberry Pi, so if you need more I/O lines you'll need to use something else as well. But<a id="id132" class="indexterm"/> it's a great board to experiment with. Interestingly, it features an <span class="strong"><strong>ATmega microcontroller</strong></span>, which is the same as the one that the Arduino uses, and you <a id="id133" class="indexterm"/>can, in fact, use the <span class="strong"><strong>Arduino</strong></span> development environment for the device.</p><p>Once again, the code in this book for our system will need to be modified to work with this board.</p><p>The Gertboard is <a id="id134" class="indexterm"/>available from Farnell element14 at <a class="ulink" href="http://bit.ly/2250034">http://bit.ly/2250034</a>.</p><div class="mediaobject"><img src="graphics/B04579_03_07.jpg" alt="Gertboard"/><div class="caption"><p>Assembled Gertboard</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>We've now looked at the I2C bus in detail, and learned how to build an expansion port using this interface so that we can connect many more things to our Raspberry Pi, rather than being restricted to just the 8 digital I/O pins offered by the Raspberry Pi's GPIO port. In addition to that, we explored other ready-made boards that can be used to connect lots of things to our Raspberry Pi. We have also built a power supply that will give us more +3.3V power than we can obtain from the Raspberry Pi directly.</p><p>In the next chapter, we'll start to actually connect things to our home security system, such as magnetic sensors and other types of contact devices, and learn how to program our I2C expansion port using Bash scripts so that we can read the state of our sensors and switch on warning LEDs. We'll also start developing the control scripts for our system, which will allow us to arm and disarm the system and add delay timers.</p></div></body></html>