["```\n[@] start_value:end_value\n\n```", "```\n./my_plugin -h hostaddress|hostname -w value -c value\n\n```", "```\n# 'check_ssh' command definition define command{ command_name check_ssh command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$' }\n\n```", "```\n# check that ssh services are running define service { use generic-service host_name localhost service_description SSH check_command check_ssh }\n\n```", "```\n# generic service template definition define service{ name generic-service ; The 'name' of this service template active_checks_enabled 1 ; Active service checks are enabled passive_checks_enabled 1 ; Passive service checks are enabled/accepted parallelize_check 1 ; Active service checks should be parallelized (disabling this can lead to major performance problems) obsess_over_service 1 ; We should obsess over this service (if necessary) check_freshness 0 ; Default is to NOT check service 'freshness' notifications_enabled 1 ; Service notifications are enabled event_handler_enabled 1 ; Service event handler is enabled flap_detection_enabled 1 ; Flap detection is enabled failure_prediction_enabled 1 ; Failure prediction is enabled process_perf_data 1 ; Process performance data retain_status_information 1 ; Retain status information across program restarts retain_nonstatus_information 1 ; Retain non-status information across program restarts\n notification_interval 0 ; Only send notifications on status change by default. is_volatile 0 check_period 24x7 normal_check_interval 5 retry_check_interval 1 max_check_attempts 4 notification_period 24x7 notification_options w,u,c,r contact_groups admins register 0 ; \nDONT REGISTER THIS DEFINITION - ITS NOT A REAL SERVICE, JUST A TEMPLATE! }\n\n```", "```\ncheck_command check_ssh\n\n```", "```\ndefine object { definitions_1 definitions_2 definitions_n }\n\n```", "```\ncommand_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$'\n\n```", "```\nroot:~$ /usr/lib/nagios/plugins/check_ssh check_ssh: Could not parse arguments Usage: check_ssh [-4|-6] [-t <timeout>] [-r <remote version>] [-p <port>] <host>\n\n```", "```\nroot:~$ /usr/lib/nagios/plugins/check_ssh -h check_ssh v2.1.1 (monitoring-plugins 2.1.1) Copyright (c) 1999 Remi Paulmier <remi@sinfomic.fr> Copyright (c) 2000-2007 Monitoring Plugins Development Team <devel@monitoring-plugins.org> Try to connect to an SSH server at specified server and port Usage: check_ssh [-4|-6] [-t <timeout>] [-r <remote version>] [-p <port>] <host> Options: -h, --help Print detailed help screen -V, --version Print version information --extra-opts=[section][@file] Read options from an ini file. See https://www.monitoring-plugins.org/doc/extra-opts.html for usage and examples. -H, --hostname=ADDRESS Host name, IP Address, or unix socket (must be an absolute path) -p, --port=INTEGER Port number (default: 22) -4, --use-ipv4 Use IPv4 connection -6, --use-ipv6 Use IPv6 connection -t, --timeout=INTEGER Seconds before connection times out (default: 10) -r, --remote-version=STRING Warn if string doesn't match expected server version (ex: OpenSSH_3.9p1) -P, --remote-protocol=STRING Warn if protocol doesn't match expected protocol version (ex: 2.0) -v, --verbose Show details for command-line debugging (output may be truncated by the monitoring system) Send email to help@monitoring-plugins.org if you have questions regarding use of this software. To submit patches or suggest improvements, send email to devel@monitoring-plugins.org\n\n```", "```\nroot:~$ netstat -tapn | grep ssh tcp 0 0 0.0.0.0:1472 0.0.0.0:* LISTEN 685/sshd tcp6 0 0 :::1472 \n\n```", "```\nroot:~$ /usr/lib/nagios/plugins/check_ssh -H localhost -p 1472 SSH OK - OpenSSH_6.7p1 Debian-5+deb8u3 (protocol 2.0) | time=0.011048s;;;0.000000;10.000000\n\n```", "```\nSSH OK - OpenSSH_6.7p1 Debian-5+deb8u3 (protocol 2.0) | time=0.011048s;;;0.000000;10.000000\n\n```", "```\n| time=0.011048s;;;0.000000;10.000000\n\n```", "```\n# 'check_ssh' command definition define command{ command_name check_ssh command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$' }\n\n```", "```\n# 'check_ssh' command definition define command{ command_name check_ssh command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$' -p $ARG1$ }\n\n```", "```\n# check that ssh services are running define service { use generic-service host_name localhost service_description SSH check_command check_ssh }\n\n```", "```\n# check that ssh services are running define service { use generic-service host_name localhost service_description SSH check_command check_ssh!1472 }\n\n```", "```\n-p 1472 -4 -P 2.0 -t 30\n\n```", "```\n# 'check_ssh' command definition define command{ command_name check_ssh command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$' -p $ARG1$ -$ARG2$ -r $ARG3$ -P $ARG4$ -t $ARG5$ }\n\n```", "```\n# check that ssh services are running define service { use generic-service host_name localhost service_description SSH check_command check_ssh!1472!4!2.0!30 }\n\n```", "```\nroot:~$ ps ax | grep nagios 803 ? SNs 0:02 /usr/sbin/nagios3 -d /etc/nagios3/nagios.cfg 2502 pts/1 S+ 0:00 grep nagios\n\n```", "```\n# Commands definitions cfg_file=/etc/nagios3/commands.cfg # Debian also defaults to using the check commands defined by the debian # nagios-plugins package cfg_dir=/etc/nagios-plugins/config # Debian uses by default a configuration directory where nagios3-common, # other packages and the local admin can dump or link configuration # files into. cfg_dir=/etc/nagios3/conf.d # OBJECT CONFIGURATION FILE(S) # These are the object configuration files in which you define hosts, # host groups, contacts, contact groups, services, etc. # You can split your object definitions across several config files # if you wish (as shown below), or keep them all in a single config file. # You can specify individual object config files as shown below: #cfg_file=/etc/nagios3/objects/commands.cfg #cfg_file=/etc/nagios3/objects/contacts.cfg #cfg_file=/etc/nagios3/objects/timeperiods.cfg #cfg_file=/etc/nagios3/objects/templates.cfg # Definitions for monitoring a Windows machine #cfg_file=/etc/nagios3/objects/windows.cfg # Definitions for monitoring a router/switch #cfg_file=/etc/nagios3/objects/switch.cfg # Definitions for monitoring a network printer #cfg_file=/etc/nagios3/objects/printer.cfg # You can also tell Nagios to process all config files (with a .cfg # extension) in a particular directory by using the cfg_dir # directive as shown below: #cfg_dir=/etc/nagios3/servers #cfg_dir=/etc/nagios3/printers #cfg_dir=/etc/nagios3/switches #cfg_dir=/etc/nagios3/routers\n\n```", "```\n# Commands definitions cfg_file=/etc/nagios3/commands.cfg # Debian also defaults to using the check commands defined by the debian # nagios-plugins package cfg_dir=/etc/nagios-plugins/config # Debian uses by default a configuration directory where nagios3-common, # other packages and the local admin can dump or link configuration # files into. cfg_dir=/etc/nagios3/conf.d\n\n```", "```\nroot:~$ egrep -lr ssh * disk.cfg ssh.cfg\n\n```", "```\ndefine command{ command_name check_ssh_arguments command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$' -p $ARG1$ -$ARG2$ -P $ARG3$ -t $ARG4$ }\n\n```", "```\nroot:~$ egrep -lr ssh * hostgroups_nagios2.cfg services_nagios2.cfg\n\n```", "```\nroot:~$ egrep -ir ssh * hostgroups_nagios2.cfg:# A list of your ssh-accessible servers hostgroups_nagios2.cfg: hostgroup_name ssh-servers hostgroups_nagios2.cfg: alias SSH servers services_nagios2.cfg:# check that ssh services are running services_nagios2.cfg: hostgroup_name ssh-servers services_nagios2.cfg: service_description SSH services_nagios2.cfg: check_command check_ssh\n\n```", "```\n# check that ssh services are running define service { hostgroup_name ssh-servers service_description SSH check_command check_ssh use generic-service notification_interval 0 ; set > 0 if you want to be re-notified }\n\n```", "```\n# check that ssh services are running define service { hostgroup_name ssh-servers service_description SSH check_command check_ssh_arguments!1472!4!2.0!30 use generic-service notification_interval 0 ; set > 0 if you want to be renotified }\n\n```", "```\nservice nagios3 reload\n\n```", "```\ncheck_external_commands=1\n\n```", "```\nservice nagios3 stop dpkg-statoverride --update --add nagios www-data 2710 /var/lib/nagios3/rw dpkg-statoverride --update --add nagios nagios 751 /var/lib/nagios3 service nagios3 start\n\n```", "```\ndebug_level=-1 debug_verbosity=2\n\n```", "```\n[1489655900.213562] [016.0] [pid=13954] Checking service 'SSH' on host 'localhost'... [1489655900.213602] [2320.2] [pid=13954] Raw Command Input: /usr/lib/nagios/plugins/check_ssh -p $ARG1$ -$ARG2$ -P $ARG3$ -t $ARG4$ '$HOSTADDRESS$' [1489655900.213787] [2320.2] [pid=13954] Expanded Command Output: /usr/lib/nagios/plugins/check_ssh -p $ARG1$ -$ARG2$ -P $ARG3$ -t $ARG4$ '$HOSTADDRESS$' [1489655900.213825] [2048.1] [pid=13954] Processing: '/usr/lib/nagios/plugins/check_ssh -p $ARG1$ -$ARG2$ -P $ARG3$ -t $ARG4$ '$HOSTADDRESS$'' [1489655900.213839] [2048.2] [pid=13954] Processing part: '/usr/lib/nagios/plugins/check_ssh -p ' [1489655900.213846] [2048.2] [pid=13954] Not currently in macro. Running output (37): '/usr/lib/nagios/plugins/check_ssh -p ' [1489655900.213906] [2048.2] [pid=13954] Uncleaned macro. Running output (41): '/usr/lib/nagios/plugins/check_ssh -p 1472' [1489655900.213911] [2048.2] [pid=13954] Just finished macro. Running output (41): '/usr/lib/nagios/plugins/check_ssh -p 1472' [1489655900.213921] [2048.2] [pid=13954] Not currently in macro. Running output (43): '/usr/lib/nagios/plugins/check_ssh -p 1472 -' [1489655900.214051] [2048.2] [pid=13954] Uncleaned macro. Running output (44): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4' [1489655900.214064] [2048.2] [pid=13954] Just finished macro. Running output (44): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4' [1489655900.214074] [2048.2] [pid=13954] Not currently in macro. Running output (48): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P ' [1489655900.214109] [2048.2] [pid=13954] Uncleaned macro. Running output (51): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0' [1489655900.214114] [2048.2] [pid=13954] Just finished macro. Running output (51): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0' [1489655900.214123] [2048.2] [pid=13954] Not currently in macro. Running output (55): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t ' [1489655900.214161] [2048.2] [pid=13954] Uncleaned macro. Running output (57): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30' [1489655900.214175] [2048.2] [pid=13954] Just finished macro. Running output (57): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30' [1489655900.214200] [2048.2] [pid=13954] Not currently in macro. Running output (59): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '' [1489655900.214263] [2048.2] [pid=13954] Uncleaned macro. Running output (68): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1' [1489655900.214276] [2048.2] [pid=13954] Just finished macro. Running output (68): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1' [1489655900.214299] [2048.2] [pid=13954] Not currently in macro. Running output (69): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1'' [1489655900.214310] [2048.1] [pid=13954] Done. Final output: '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1''\n\n```", "```\n/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1' SSH OK - OpenSSH_6.7p1 Debian-5+deb8u3 (protocol 2.0) | time=0.015731s;;;0.000000;30.000000\n\n```", "```\nprocess_performance_data=1 host_perfdata_command=process-host-perfdata service_perfdata_command=process-service-perfdata\n\n```", "```\n# ‘process-host-perfdata' command definition define command{ command_name process-host-perfdata command_line /usr/bin/perl /usr/lib/pnp4nagios/libexec/process_perfdata.pl -d HOSTPERFDATA } # ‘process-service-perfdata' command definition define command{ command_name process-service-perfdata command_line /usr/bin/perl /usr/lib/pnp4nagios/libexec/process_perfdata.pl }\n\n```", "```\n# check that ssh services are running define service { hostgroup_name ssh-servers service_description SSH check_command check_ssh_arguments!1967!4!2.0!30 action_url /pnp4nagios/index.php/graph?host=$HOSTNAME$&srv=$SERVICEDESC$ use generic-service notification_interval 0 ; set > 0 if you want to be renotified }\n\n```", "```\nzarrelli:~$ lsblk -d sda 8:0 0 119.2G 0 disk sr0 11:0 1 1024M 0 rom\n\n```", "```\nroot:~$ hwinfo --disk 27: IDE 00.0: 10600 Disk [Created at block.245] Unique ID: 3OOL.eNwxL8uda61 Parent ID: w7Y8.FuT6qrC8mT0 SysFS ID: /class/block/sda SysFS BusID: 0:0:0:0 SysFS Device Link: /devices/pci0000:00/0000:00:1f.2/ata1/host0/target0:0:0/0:0:0:0 Hardware Class: disk Model: \"TS128GSSD720\" Device: \"TS128GSSD720\" Revision: \"2\" Serial ID: \"REDACTED\" Driver: \"ahci\", \"sd\" Driver Modules: \"ahci\" Device File: /dev/sda Device Files: /dev/sda, /dev/disk/by-id/ata-TS128GSSD720_REDACTED Device Number: block 8:0-8:15 BIOS id: 0x80 Geometry (Logical): CHS 15566/255/63 Size: 250069680 sectors a 512 bytes Capacity: 119 GB (128035676160 bytes) Config Status: cfg=new, avail=yes, need=no, active=unknown Attached to: #20 (SATA controller)\n\n```", "```\nroot:~$ smartctl --all /dev/sda smartctl 6.4 2014-10-07 r4002 [x86_64-linux-3.16.0-4-amd64] (local build) Copyright (C) 2002-14, Bruce Allen, Christian Franke, www.smartmontools.org === START OF INFORMATION SECTION === Model Family: SandForce Driven SSDs Device Model: TS128GSSD720 Serial Number: REDACTED LU WWN Device Id: 0 023280 000000000 Firmware Version: 5.0.2 User Capacity: 128,035,676,160 bytes [128 GB] Sector Size: 512 bytes logical/physical Rotation Rate: Solid State Device Device is: In smartctl database [for details use: -P show] ATA Version is: ATA8-ACS, ACS-2 T13/2015-D revision 3 SATA Version is: SATA 3.0, 6.0 Gb/s (current: 3.0 Gb/s) Local Time is: Fri Mar 17 16:34:30 2017 GMT SMART support is: Available - device has SMART capability. SMART support is: Enabled === START OF READ SMART DATA SECTION === SMART overall-health self-assessment test result: PASSED General SMART Values: ...Self-test execution status: (0) The previous self-test routine completed without error or no self-test has ever been run. ...SMART Attributes Data Structure revision number: 10 Vendor Specific SMART Attributes with Thresholds: ID# ATTRIBUTE_NAME FLAG VALUE WORST THRESH TYPE UPDATED WHEN_FAILED RAW_VALUE ...SMART Error Log not supported SMART Self-test Log not supported SMART Selective self-test log data structure revision number 1 SPAN MIN_LBA MAX_LBA CURRENT_TEST_STATUS ... Selective self-test flags (0x0): After scanning selected spans, do NOT read-scan remainder of disk. If Selective self-test is pending on power-up, resume after 0 minute delay.\n\n```", "```\nSMART overall-health self-assessment test result: PASSED 194 Temperature_Celsius 0x0022 036 060 000 Old_age Always - 36 (Min/Max 12/60) Self-test execution status: ( 0) The previous self-test routine completed\n\n```", "```\nroot:~$ smartctl --all /dev/sda | grep -i overall-health | awk '{print $6}' PASSED\n\n```", "```\nroot:~$ H_CHECK=$(smartctl --all /dev/sda | grep -i overall-health | awk '{print $6}')\n\n```", "```\nroot:~$ H_CHECK=$(smartctl --all /dev/sda | grep overall-health | awk '{print $6}') ; echo $H_CHECK PASSED\n\n```", "```\nroot:~$ smartctl --all /dev/sda | grep -i Temperature | awk '{print $10}' 35\n\n```", "```\nroot:~$ T_CHECK=$(smartctl --all /dev/sda | grep -i Temperature | awk '{print $10}') ; echo $T_CHECK 35\n\n```", "```\nroot:~$ smartctl --all /dev/sda | grep -i \"Self-test execution status\" | awk '{print $5}' | tr -d \")\"\n\n```", "```\nS_CHECK=$(smartctl --all /dev/sda | grep -i \"Self-test execution status\" | awk '{print $5}' | tr -d \")\") ; echo $S_CHECK 0\n\n```", "```\n#!/bin/bash # License: GPL # # Author: Giorgio Zarrelli <zarrelli@linux.it> # # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License version 2 as # published by the Free Software Foundation. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the # GNU General Public License for more details. # # You should have received a copy of the GNU General Public License # along with this program. If not, see <http://www.gnu.org/licenses/>. #\n\n```", "```\nSMARTCTL=\"/usr/sbin/smartctl\"\n\n```", "```\n# Nagios return codes STATE_OK=0 STATE_WARNING=1 STATE_CRITICAL=2 STATE_UNKNOWN=3\n\n```", "```\n# Default WARNING and CRITICAL values WARNING_THRESHOLD=${WARNING_THRESHOLD:=41} CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=50}\n\n```", "```\n# Check if we have all the system tools we need path_exists() { for i in \"$@\" do if [ -e \"$i\" ]; then echo \"$i is a valid path\" else echo \"$i is not reachable, is this the correct path?\" exit 1 fi done } path_exists \"$SMARTCTL\"\n\n```", "```\nzarrelli:~$ ./check_my_smart.sh /bin/echo is a valid path /usr/sbin/smartctl is a valid path\n\n```", "```\nTEST1=\"\" TEST2=\"/blah/blah\"\n\n```", "```\npath_exists \"$SMARTCTL\" \"TEST1\" \"TEST2\"\n\n```", "```\nzarrelli:~$ ./check_my_smart.sh /bin/echo is a valid path /usr/sbin/smartctl is a valid path TEST1 is not reachable, is this the correct path?\n\n```", "```\nzarrelli:~$ ./check_my_smart.sh ; echo $? /bin/echo is a valid path /usr/sbin/smartctl is a valid path TEST2 is not reachable, is this the correct path? 1\n\n```", "```\n# Disk to check DISK=${DISK:=\"/dev/sda\"}\n\n```", "```\n# Check for the path to bring us to a block device with SMART capability disk_exists() { if [ -b \"$DISK\" ] then echo \"$DISK is a block device\" else echo \"$DISK does not point a block device\" fi }\n\n```", "```\n# Enable verbose; 0 for disabled, 1 for enabled VERB=${VERB:=1}\n\n```", "```\npath_exists()\n{\nfor i in \"$@\"\ndo\nif [ -e \"$i\" ];\nthen \n(( VERB )) && echo \"$i is a valid path\"\n:\nelse\nif (( VERB ));\nthen\necho \"$i is not reachable, is this the correct path?\"\nexit 1\nfi\nfi\ndone\n}\n\n```", "```\nzarrelli:~$ ./check_my_smart.sh /bin/echo is a valid path /usr/sbin/smartctl is a valid path /dev/sda is a block device\n\n```", "```\nzarrelli:~$ ./check_my_smart.sh /dev/sda is a block device\n\n```", "```\n(( VERB )) && echo \"$i is a valid path\"\n\n```", "```\nif (( VERB )); then echo \"$i is not reachable, is this the correct path?\" command_2 command_n fi\n\n```", "```\nif (( VERB )); then echo \"$i is not reachable, is this the correct path?\" fi\n\n```", "```\ndisk_exists() { if [ -b \"$DISK\" ] then (( VERB )) && echo \"$DISK is a block device\" : else echo \"$DISK does not point a block device\" exit 1 fi }\n\n```", "```\nroot:~$ smartctl -a /dev/sda | grep \"^SMART support is:\" SMART support is: Available - device has SMART capability. SMART support is: Enabled\n\n```", "```\nroot:~$ SMART=$(smartctl -a /dev/sda | grep \"^SMART support is:\" | awk '{print $4}') ; echo $SMART Available Enabled\n\n```", "```\nAvailable Enabled\n\n```", "```\n# Retrieve the full path to the system utilities AWK=$(which awk) ECHO=$(which echo) GREP=$(which grep) SMARTCTL=\"/usr/sbin/smartctl\" # AWK field to print A_FIELD='{print $4}'\n\n```", "```\nsmart_enabled() {\n SMART=($($SMARTCTL -a \"$1\" | \"$GREP\" \"$IS_SMART\" | \"$AWK\" \"$A_FIELD\")) }\n\n```", "```\npath_exists \"$SMARTCTL\" disk_exists \"$DISK\" smart_enabled \"$DISK\"\n\n```", "```\n# SMART CAPABILITY INDICATOR IS_SMART=\"^SMART support is:\" SMART_IND=(Available Enabled)\n\n```", "```\nsmart_enabled() { SMART=($($SMARTCTL -a \"$1\" | \"$GREP\" \"$IS_SMART\" | \"$AWK\" \"$A_FIELD\")) for i in \"${SMART[@]}\" do for j in \"${SMART_IND[@]}\" do if [[ \"$i\" == \"$j\" ]]; then (( COUNTER++ )) fi done done if (( COUNTER != ${#SMART_IND[@]} )) then ALT_SMART=\"$($SMARTCTL -a \"$1\" | \"$GREP\" \"$ALT_IS_SMART\")\" if ! [[ -z $ALT_SMART ]] then (( VERB )) && echo \"$DISK has SMART capability\" smart_check \"$B_SEL\" \"$DISK\" else (( VERB )) && echo \"Check the device, it seems it does not support SMART\" (( VERB )) && echo \"The counter matched: $COUNTER times\" echo exit \"$STATE_UNKNOWN\" fi else (( VERB )) && echo \"$DISK has SMART capability\" smart_check \"$B_SEL\" \"$DISK\" fi }\n\n```", "```\nALT_IS_SMART=\"=== START OF SMART DATA SECTION ===\"\n\n```", "```\nroot:~$ ./check_my_smart.sh /bin/echo is a valid path /usr/sbin/smartctl is a valid path /dev/sda is a block device Check the device, it seems it does not support SMART The counter matched: 0 times\n\n```", "```\ndisk_exists() { if [ -b \"$DISK\" ] then (( VERB )) && echo \"$DISK is a block device\" smart_enabled \"$DISK\" else echo \"$DISK does not point a block device\" exit 1 fi }\n\n```", "```\n# AWK field to print A_FIELD='{print $4}' H_FIELD='{print $6}' # SMART check keywords H_KEY=\"overall-health\" # SMART matches H_MATCH=\"PASSED\" Now, just before the smart_enabled function, let's create a new function: smart_check() { H_CHECK=$($SMARTCTL -a \"$1\" | \"$GREP\" \"$H_KEY\" | \"$AWK\" \"$H_FIELD\") if [[ \"$H_CHECK\" == \"$H_MATCH\" ]]; then echo \"SMART OK: Overall-health check $H_MATCH\" exit \"$STATE_OK\" else echo \"SMART CRITICAL: Overall-health check NOT $H_MATCH\" exit \"$STATE_CRITICAL\" fi }\n\n```", "```\nroot:~$ ./check_my_smart.sh SMART OK: Overall-health check PASSED\n\n```", "```\necho “SMART UNKNOWN: Please check the plugin” exit “$STATE_UNKNOWN”\n\n```", "```\npath_exists() { for i in \"$@\" do if [ -e \"$i\" ]; then (( VERB )) && echo \"$i is a valid path\" disk_exists \"$DISK\" else (( VERB )) && echo \"$i is not reachable, is this the correct path?\" echo “SMART UNKNOWN: Please check the plugin” echo “SMART UNKNOWN: Please check the plugin” exit “$STATE_UNKNOWN” fi done } \n\n```", "```\n# BRANCH selector B_SEL=${B_SEL:=\"HEALTH\"}\n\n```", "```\nsmart_check()\n{\nif ((\"$#\" != 2));\nthen\necho\nexit \"$STATE_UNKNOWN\"\nelse\nif [[ \"$1\" == \"HEALTH\" ]];\nthen\nH_CHECK=$($SMARTCTL -a \"$2\" | \"$GREP\" \"$H_KEY\" | \"$AWK\" \"$H_FIELD\")    if [[ \"$H_CHECK\" == \"$H_MATCH\" ]];\nthen\necho \"SMART OK: Overall-health check $H_MATCH\"\nexit \"$STATE_OK\"\nelse\necho \"SMART CRITICAL: Overall-health check NOT $H_MATCH\"\nexit \"$STATE_CRITICAL\"\nfi\nelif [[ \"$1\" == \"TEMPERATURE\" ]];\nthen\nif (( $(echo \"scale=2; \"$WARNING_THRESHOLD\" >= \"$CRITICAL_THRESHOLD\"\" | $BC ) )) ;\nthen\necho \"SMART UNKNOWN: The value of WARNING ($WARNING_THRESHOLD) must be lower than CRITICAL ($CRITICAL_THRESHOLD)\"                            exit \"$STATE_UNKNOWN\"\nelse\nT_CHECK=$($SMARTCTL -a \"$2\" | \"$GREP\" \"$T_KEY\" | \"$AWK\" \"$T_FIELD\")   if ! [[ \"$T_CHECK\" = *[[:digit:]]* ]];\nthen\necho \"SMART UNKNOWN: The $T_KEY check is not available on $DISK\"\nexit \"$STATE_UNKNOWN\"\nfi\nif (( T_CHECK < WARNING_THRESHOLD ));\nthen\necho \"SMART OK: Temperature is $T_CHECK | TEMP=$T_CHECK\"\nexit \"$STATE_OK\"\nelif (( T_CHECK < CRITICAL_THRESHOLD ));\nthen\necho \"SMART WARNING: Temperature is $T_CHECK | TEMP=$T_CHECK\"\nexit \"$STATE_WARNING\"\nelse\necho \"SMART CRITICAL: Temperature is $T_CHECK | TEMP=$T_CHECK\"\nexit \"$STATE_CRITICAL\"\nfi\nfi\nelif [[ \"$1\" == \"SELFCHECK\" ]];\nthen\nS_CHECK=$($SMARTCTL -a \"$2\" | \"$GREP\" \"$S_KEY\" | \"$AWK\" \"$S_FIELD\" | \"$TR\" -d \"$S_DEL\")\nif ! [[ \"$S_CHECK\" = *[[:digit:]]* ]];                               then\necho \"SMART UNKNOWN: The $S_KEY check is not available on $DISK\"\nexit \"$STATE_UNKNOWN\"\nfi\nif (( S_CHECK == S_MATCH ));\nthen\necho \"SMART OK: Overall-health check $S_MATCH\"\nexit \"$STATE_OK\"\nelse\necho \"SMART CRITICAL: Overall-health check NOT $S_MATCH\"\nexit \"$STATE_CRITICAL\"\nfi\nelse\necho\nexit \"$STATE_UNKNOWN\"\nfi\nfi\n}\n\n```", "```\nTR=$(which tr) S_FIELD='{print $5}' S_KEY=\"Self-test execution status\" S_MATCH=0\n\n```", "```\neelif [[ \"$1\" == \"SELFCHECK\" ]]; then S_CHECK=$($SMARTCTL -a \"$2\" | \"$GREP\" \"$S_KEY\" | \"$AWK\" \"$S_FIELD\" | \"$TR\" -d \"$S_DEL\") if ! [[ \"$S_CHECK\" = *[[:digit:]]* ]]; then echo \"SMART UNKNOWN: The $S_KEY check is not available on $DISK\" exit \"$STATE_UNKNOWN\" fi if (( S_CHECK == S_MATCH )); then echo \"SMART OK: Overall-health check $S_MATCH\" exit \"$STATE_OK\" else echo \"SMART CRITICAL: Overall-health check NOT $S_MATCH\" exit \"$STATE_CRITICAL\" fi\n\n```", "```\nroot:~$ ./check_my_smart.sh SMART OK: Overall-health check 0\n\n```", "```\nBC=$(which bc) T_FIELD='{print $10}' T_KEY=\"Temperature\" \n\n```", "```\nelif [[ \"$1\" == \"TEMPERATURE\" ]]; then if (( $(echo \"scale=2; \"$WARNING_THRESHOLD\" >= \"$CRITICAL_THRESHOLD\"\" | $BC ) )) ; then echo \"SMART UNKNOWN: The value of WARNING ($WARNING_THRESHOLD) must be lower than CRITICAL ($CRITICAL_THRESHOLD)\" exit \"$STATE_UNKNOWN\" else T_CHECK=$($SMARTCTL -a \"$2\" | \"$GREP\" \"$T_KEY\" | \"$AWK\" \"$T_FIELD\") if ! [[ \"$T_CHECK\" = *[[:digit:]]* ]]; then echo \"SMART UNKNOWN: The $T_KEY check is not available on $DISK\" exit \"$STATE_UNKNOWN\" fi if (( T_CHECK < WARNING_THRESHOLD )); then echo \"SMART OK: Temperature is $T_CHECK | TEMP=$T_CHECK\" exit \"$STATE_OK\" elif (( T_CHECK < CRITICAL_THRESHOLD )); then echo \"SMART WARNING: Temperature is $T_CHECK | TEMP=$T_CHECK\" exit \"$STATE_WARNING\" else echo \"SMART CRITICAL: Temperature is $T_CHECK | TEMP=$T_CHECK\" exit \"$STATE_CRITICAL\" fi fi fi fi \n\n```", "```\n$T_CHECK < $WARNING_THRESHOLD IS OK $T_CHECK < $CRITICAL_THRESHOLD IS WARNING EVERYTHING ELSE IS CRITICAL\n\n```", "```\nWARNING_THRESHOLD=${WARNING_THRESHOLD:=41} CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=50}ro\not:~$ ./check_my_smart.sh SMART WARNING: Temperature is 41 | TEMP=41 WARNING_THRESHOLD=${WARNING_THRESHOLD:=45} CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=50} root:~$ ./check_my_smart.sh SMART OK: Temperature is 41 | TEMP=41 WARNING_THRESHOLD=${WARNING_THRESHOLD:=35} CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=40} root:~$ ./check_my_smart.sh SMART CRITICAL: Temperature is 41 | TEMP=41 WARNING_THRESHOLD=${WARNING_THRESHOLD:=50} CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=40} root:~$ ./check_my_smart.sh SMART UNKNOWN: The value of WARNING (50) must be lower than CRITICAL (40)\n\n```", "```\n# Print help and usage print_help() { cat << HERE MY SMART CHECK v1.0 ------------------- Please enter one or more of the following options: -d | --disk eg. /dev/sda -t | --test HEALTH TEMPERATURE SELFCHECK -w | --warning eg. -w 41 -c | --critical eg. -c 50 HERE }\n\n```", "```\nroot:~$ ./check_my_smart.sh -T ITISWRONG Unknown argument: -T\n\n MY SMART CHECK v1.0 ------------------- Please enter one or more of the following options: -d | --disk eg. /dev/sda -m | --module HEALTH TEMPERATURE SELFCHECK -w | --warning eg. -w 41 -c | --critical eg. -c 50\n\n```", "```\n# Parse parameters on the command line while (( $# > 0 )) do case \"$1\" in -h | --help) print_help exit \"${STATE_OK}\" ;; -d | --disk) shift DISK=\"$1\" ;; -m | --module) shift B_SEL=\"$1\" ;; -w | --warning) shift WARNING_THRESHOLD=\"$1\" ;; -c | --critical) shift CRITICAL_THRESHOLD=\"$1\" ;; *) echo \"Unknown argument: $1\" print_help exit \"$STATE_UNKNOWN\" ;; esac shift done\n\n```", "```\nroot:~$ cd /usr/lib/nagios/plugins/ root:~$ ls -lah check_my_smart.sh -rwxr-xr-x 1 root root 6.2K Mar 22 09:32 check_my_smart.sh\n\n```", "```\n# 'check_my_smart' command definition define command{ command_name check_my_smart command_line /usr/lib/nagios/plugins/check_my_smart.sh -d $ARG1$ -m $ARG2$ $ARG3$ $ARG4$ }\n\n```", "```\n# SMART Nagios plugin sudo nagios ALL=(root) NOPASSWD: /usr/sbin/smartctl\n\n```", "```\nSUDO=$(which sudo) SMARTCTL=\"$SUDO /usr/sbin/smartctl\"\n\n```", "```\n# SMART - Check overall-health define service{ use generic-service host_name localhost service_description SMART - oveall-health check_command check_my_smart!/dev/sda!HEALTH } # SMART - Check self-test define service{ use generic-service host_name localhost service_description SMART - self-test check_command check_my_smart!/dev/sda!SELFCHECK } # SMART - Check temperature define service{ use generic-service host_name localhost service_description SMART - temperature action_url /pnp4nagios/index.php/graph?host=$HOSTNAME$&srv=$SERVICEDESC$ check_command check_my_smart!/dev/sda!TEMPERATURE!-w 41!-c 50 }\n\n```"]