- en: Server Operating Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A computer system has five major components: hardware, software, people, documentation,
    and data. Without any one of these components, there would be little or no purpose
    of the system. Of course, there is another version that identifies the **input–process–output**
    (**IPOS**) model, which consists of inputs, processing, outputs, and storage (referring
    to main memory, not disk drives). In either of these models, software and processing,
    while equally important to the other components of their respective models, represent
    the catalyst that allows us to accomplish something on a computer.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first three chapters of this book, we looked at the typical hardware
    of a network server, including its external and internal hardware and the hardware
    that's used for storing data. In this chapter, we will move on and look at the
    primary software of all computer systems—the operating system and, in particular,
    **network operating systems** (**NOSes**). In this chapter, we will focus on the
    three most popular (and the ones you'll encounter in the Server+ exam)—Windows
    Server, Linux Enterprise, and macOS Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The network server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS and hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boot sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NOS optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, let's agree on what a network server is and what its functions
    may be. As we discussed in [Chapter 1](79e86743-32d3-4ae6-bc33-83018f475c12.xhtml),
    *Server Hardware*, a server is technically a software package running on a network
    computer that processes, responds to requests from hosts, and provides resources
    to fulfill requests from network clients. There are many different types of servers,
    each with its own purpose and function. In the following sections, we will look
    at the various servers you may encounter in the Server+ exam.
  prefs: []
  type: TYPE_NORMAL
- en: Server functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The general function of a network server is to provide services to network clients.
    At its most basic level, a server, just like those in a restaurant, serves the
    needs of its clients. And just like the servers in a restaurant, there are specialized
    servers for different responsibilities, such as the wine steward, the cook, and
    the bus person, focused on one purpose or group of related purposes.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we expand the definition of a network server to also include the
    hardware, operating system, management utilities, protocols, data stores, and
    communications, its function will include the provisions of administration, security,
    resources, and other services to network clients. A network server may support
    a single role, function, or application. A network-connected computer may support
    several server roles and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the server software running on the server hardware and the roles
    the server fulfils on a network, one thing is constant on every server—the NOS.
    Not every network node that supports one type of server software or another requires
    an NOS, but those servers that administer user accounts, access, and security
    certainly do.
  prefs: []
  type: TYPE_NORMAL
- en: Network server operating systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several differences between what we call an *operating system* and
    a *network operating system*. The differences go beyond, but are directly related
    to, the inclusion of *network* in the title. Like nearly all computer operating
    systems, such as Windows, Linux, and macOS, an NOS provides system control and
    management functions, but to multiple workstations.
  prefs: []
  type: TYPE_NORMAL
- en: Operating system (OS) functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A computer's OS is the system software that provides the means for a user to
    make use of the computer hardware. An OS manages, controls, secures, and administers
    the physical electronics of a computer. For the most part, we tend to take the
    OS on our computers for granted, with little thought to how it works or just what
    it does. After all, it only makes everything we do possible!
  prefs: []
  type: TYPE_NORMAL
- en: 'An OS has five primary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: User/computer communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control and coordination of hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal and network file management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User, data, application, and resource security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User/computer communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users communicate with an OS or an application through a **graphical user interface**
    (**GUI**) or a **command-line interface** (**CLI**). The facilitation of this
    communication is a primary function of any OS. The following screenshot illustrates
    both a GUI and a CLI through which users select or enter requests or commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f40aa1b-068c-4064-a990-d0052bfe6d11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Examples of a GUI (left) and a CLI (right)
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An OS, network or otherwise, has the responsibility of allocating memory to
    user or system-initiated programs. When a user starts a process or program that's
    not a part of the OS kernel, which means it's already in memory (more than likely),
    it's copied from secondary storage into an allocated space in main memory. The
    allocated memory space serves as a holding area for the program's instructions
    and data, before and after passing this to cache memory and the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic loading and linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OS typically loads smaller programs, those consisting of only one module,
    and data blocks often load to memory completely. However, larger programs, especially
    those with several modules, can't fit into the available memory to be allocated,
    so the OS uses a process called dynamic loading. **Dynamic loading** loads the
    first module of a program, the one with the first instruction, and then loads
    other modules into the same space when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to memory management is **dynamic linking**. Many programs,
    especially those developed as **object-oriented programming** (**OOP**), have
    an associated library of definitions, methods, and functions. As the program executes,
    the OS creates a link to any object invoked in a module to its definition in the
    library for execution. This avoids the need to load the entire library into memory.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory allocation is the process that''s used by the OS to allocate and assign
    memory space to a program. Generally, there are four approaches to the allocation
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First fit**: The first memory space block in the memory available table that
    is large enough to fit the needs of the program or module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next fit**: The next memory space block immediately after the last memory
    block allocated that fits the needs of the program or module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best fit**: The smallest available block of memory large enough to meet the
    needs of the program or module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worst fit**: Any available block of memory that is larger than the needs
    of the program or module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memory management function of an OS may use any of the preceding memory
    allocation approaches. In any case, allocations are either static or a dynamic.
    Compilers often determine the **static allocations** of a program and its modules.
    **Dynamic allocations** are fluid. Dynamic loading and linking are two types of
    dynamic memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Control and coordination of hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OS is able to communicate with some devices, such as the keyboard, through
    the computer's BIOS, since there are standard devices that use a simple, standard
    command set. However, many devices and components have unique sets of commands
    and instructions that are typically not compatible with other devices. It's virtually
    impossible for an OS to include the commands needed to communicate with every
    possible make and model of internal and external devices installed on a computer.
    For this reason, device driver software, which is unique to a particular device
    make or model, acts as a go-between for the OS and the device controller. Device
    drivers make it possible for the OS to coordinate the actions of hardware components
    and devices.
  prefs: []
  type: TYPE_NORMAL
- en: Some hardware device drivers are in the OS, while some are in the **Basic Input
    Output System** (**BIOS**) and **Complementary Metal Oxide Semiconductor** (**CMOS**)
    and others are on the motherboard chipset. However, for the most part, device
    driver installation occurs either before or after the installation of the associated
    device on a computer. There are device software programs that assist the configuration
    of a device and the installation of the device driver.
  prefs: []
  type: TYPE_NORMAL
- en: The use of system resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OS's communication with a device driver is a bit more involved than just
    passing data back and forth. *How does the device driver or the OS know that an
    action is need by either?* *How do they communicate to each other to say that
    a requested action is complete and if data is involved, where is it?*
  prefs: []
  type: TYPE_NORMAL
- en: The most common answer to these questions involves **system resources**. A system
    resource is actually any addressable element of a computer. System resources are
    a portion of main memory (RAM) that is set aside for OS/device interactions. System
    resources can also be provided by the CPU, motherboard, chipset, and other system
    components. However, the system resources involved with device control and communication
    are those that are found in RAM.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four categories of system resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interrupt requests (IRQs)**: In a classroom or a group meeting, if you wish
    to ask a question, you might raise your hand above your head and wait for recognition.
    An IRQ works essentially the same way—when a device or the OS needs the CPU to
    perform a task, it *raises its hand* by setting an assigned *IRQ on*. The CPU
    frequently checks the IRQs and if one is set to on, the CPU *interrupts* what
    it''s doing to take care of the request, hence the name. After completing the
    task, the IRQ is set to *off*. The following screenshot shows the IRQs on a Windows
    system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ad60a361-0857-4936-9303-415eadb33e48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The IRQ assignments of a Windows system
  prefs: []
  type: TYPE_NORMAL
- en: '**I/O addresses**: Each installed I/O device on a computer has one or more
    addresses assigned to it. This address, which has several names, including I/O
    port, port address, or simply *port*, designates a device specifically and is
    not an address in memory. This address is like the street address on a house.
    The motherboard''s address bus toggles between I/O addresses and memory addresses.
    When the bus is set to I/O addresses, the hardware device controllers monitor
    the bus for their individual addresses. If a device sees its I/O address, it responds
    to the request as appropriate. The following screenshot shows the I/O address
    assignments of a Windows system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f57769b5-fd99-4e3a-988f-a1d43044f7bb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The I/O address assignments of a Windows system
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory addresses**: Along with its I/O address, an I/O device may also be
    assigned a block of memory to use as a data buffer or as a scratchpad space. Not
    every device gets a memory address, and the space that is assigned is not all
    that large. As you can see in the following screenshot, some devices, both physical
    and logical, have more than one memory address assignment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/9190957a-4285-4b16-94ce-ee3988a27445.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Memory address assignments of a Windows system
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct memory access (DMA) addresses**: A DMA device is a computer I/O or
    storage device that is able to read and write data directly from or to main memory.
    DMA transfers don''t involve the CPU, which can then take care of other tasks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/92fe3acc-8a82-4991-9196-9c7850dc0479.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Properties dialog box for a DMA device on a Windows system
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an open source utility program that can be used
    to examine the systems information, including the system resources, of a Linux
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5a1cc6e-1a5b-468a-835f-97c9eca23db5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: KInfocenter provides information about a Linux system, including the system
    resources
  prefs: []
  type: TYPE_NORMAL
- en: Internal and network file management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The management of data files, whether on an internal storage device or a NAS
    or SAN, is a primary function of an OS. File management involves the creation,
    modification, transfer, and removal of data units that are stored as a complete
    block. In performing file management, an OS interfaces with hardware controllers,
    driver software, and perhaps a data management system, such as a DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tasks performed by the file management functions of an OS include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating new data files and recording their placement on the storage medium
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing for the modification of a data file and, if necessary, its relocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing the removal of a data file and any references to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing data files into a filesystem, directory, or folder to facilitate
    its accessibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitating access to a data file by multiple users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User, data, application, and resource security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The security provisions of an OS encompass the rules, functions, processes,
    and settings that the OS applies to implement and maintain the **confidentiality,
    integrity, and availability** (**CIA**) of its computer system. Organizational
    security policies must include the protection of the OS and its physical and environmental
    safety, including theft, damage, or destruction. However, the primary focus of
    OS security must be to enforce the rules and perform the tasks that prevent unauthorized
    intrusion or interference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The security of an OS requires that certain activities are a part of normal
    operations, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing patch and update management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying antivirus and malware updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining all network traffic, inbound or outbound, through a firewall and/or
    other security appliances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly reviewing and managing user and group account permissions and rights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the relationship between an OS and the configuration settings
    and specifications of the hardware, you need to understand that, by nature, an
    OS is sleek, and hardware is klutzy. A large part of an OS job is to make the
    hardware appear sleeker than it may actually be.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, we look at the OS, its parts, and a look at its
    relationship with hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The primary parts of an OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An operating system has three primary parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel**: Modern operating systems are modular, meaning that most essential
    services, such as memory management, I/O handling, and CPU interactions, are in
    the module that loads at startup and remains in memory—the **kernel**. Other functions
    and utilities load to memory as needed. As shown in the following diagram, there
    are two types of OS kernels—**monolithic** and **microkernel**. A monolithic OS,
    such as Windows, macOS, and Linux, includes the functions that are needed for
    the basic functions of the computer and user-initiated software. As you can see
    in the following diagram, a microkernel OS pushes support for user-initiated programs
    into the user space. At the present time, there are no microkernel systems being
    widely used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4bcc5f0f-f33e-4431-af3f-1ba2305c3f1c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The two types of OS kernels
  prefs: []
  type: TYPE_NORMAL
- en: '**Shell**: An OS shell is a program that the OS starts to provide a user interface,
    commonly as a CLI, as shown in the following screenshot. In UNIX/Linux systems,
    there are several shells, each with their own command set and functions, such
    as the **Bourne-Again Shell** (**Bash**), the C shell, and the Korn shell. On
    a Windows system, the GUI displayed on the desktop represents a shell. The Windows
    Command Prompt also represents a shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8b4bc43d-2063-46be-b4e4-b84cd268b14b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Commands entered at the command prompt of a Linux shell
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystem**: When you create a file and store it on a hard disk, you assume
    that you''ll be able to find in the future. A filesystem maintains the physical
    placement of a file or data block on a disk drive and keeps a cross-reference
    of the location and the filename in an index. Filesystems organize data storage
    in directories, folders, files, and objects. Commonly used filesystems are NTFS
    on Windows and ext3 and ext4 on Linux systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OS and hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The configuration of a computer's hardware, software, and firmware specifies
    the parameters and settings for its functions and operations. The hardware configuration
    settings in a computer's BIOS or **Unified Extensible Firmware Interface** (**UEFI**),
    OS, and support systems, define its startup, the installed devices, and several
    performance and operation parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not every program or application uses every hardware component available on
    a computer.  The hardware any program uses will depend on its function and purpose.
    If a program only accepts two numbers from the user, adds them together, and prints
    the result to a display device without storing the result, the requirements of
    the program and the actions of the user affected the hardware used. In this particular
    case, the hardware involved was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HDD**: The program loaded to RAM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAM**: The program was assigned an allocated space and instructions were
    passed to the CPU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU**: The instructions were executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display**: The results were passed to the controller and displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the OS was the catalyst that guided this sequence, but in doing so,
    the OS involved only the hardware required to complete the task. So, *how does
    the OS know what hardware it has at its disposal?* That's what the BIOS/UEFI stores
    in CMOS. This information provides the OS with a list of the hardware devices
    it can use, and also how and where it can access each.
  prefs: []
  type: TYPE_NORMAL
- en: Boot sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A major part of the system startup of a computer, that is, its boot up, is
    loading the OS kernel into RAM so that the CPU can turn control over to the OS.
    To perform this process, the boot program must know where to look for the OS,
    which could be an HDD, a CD, a flash drive, or any bootable device. In the BIOS/UEFI
    settings, the sequence of devices that the boot process should look onto locate
    the **master boot record** (**MBR**) can be set. The boot utility will look at
    each of the devices in the order of priority and boot the computer from the first
    one it encounters with the boot information. The following screenshot shows a
    simple UEFI boot sequence list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c52eeda2-4832-43d9-90dc-0776dec6acaa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The boot priorities dialog box of a UEFI configuration
  prefs: []
  type: TYPE_NORMAL
- en: Firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the beginning of computer time, we have classified computer instructions
    and components by where they reside or their general characteristics. The components
    that we can touch and feel are *hardware*. Those we can't actually touch, feel,
    or hold, but can change, we call *software*. However, in computer systems, there
    is a component we can't touch, feel, or change, especially in older systems. This
    component exists somewhere between hardware and software, and we call it *firmware*.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we refer to as firmware today can be one of two general technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BIOS**: A legacy technology that uses data and instructions that are permanently
    loaded (*burned*) into a semiconductor during manufacturing. These instructions
    initiate the BIOS to begin the startup process and load the bootloader to complete
    the boot process. This low-level form of firmware is a part of the motherboard
    as a **read-only memory** (**ROM**)/**programmable read-only memory** (**PROM**),
    **one-time programmable** (**OTP**), and **programmable logic array** (**PLA**)
    chips.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UEFI**: This newer technology is replacing most BIOS on computers, but performs
    essentially the same functions. In fact, UEFI relies on BIOS for the **power-on
    self-test** (**POST**) function and the configuration specifications (commonly
    referred to as CMOS). Virtually all computers produced after 2010 have UEFI, with
    some also including BIOS. The following screenshot shows System Information with
    the BIOS/UEFI settings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c85710a9-94c4-4625-9a07-2e9c629092e7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The BIOS/UEFI settings on the System Information dialog box
  prefs: []
  type: TYPE_NORMAL
- en: 'In spite of its *permanent* nature, the firmware on most computer systems is
    upgradeable. The exact procedure varies with the motherboard manufacturer, operating
    system, or the age of the system, but the following steps are generally the process
    that''s used to update system firmware:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that you are actually installing a newer version of the UEFI/BIOS. On
    a Windows system, run `MSINFO32`. On a Linux system, if the `/sys/firmware/efi` directory
    exists, the system is using UEFI. If that directory doesn't exist, the system
    is using BIOS. Record the version number and date and compare it to the information
    on the motherboard manufacturer's website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boot the computer and when the display informs you of which key to press to
    access the UEFI/BIOS settings, press it. Some systems include a firmware update
    function in the UEFI/BIOS utility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no update utility is available, download and decompress the update file and
    store it on a USB flash drive or external disk drive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the system and access the firmware update or flashing utility on the
    UEFI/BIOS settings page. Back up the existing firmware to an external drive, just
    in case something goes wrong in the update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the firmware update utility, select the newer version image and start
    the update. The upgrade should only take a few minutes, but, in any case, absolutely
    don't restart, shut down, or power off the computer until the upgrade process
    completes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preparing a disk for the OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two approaches to installing a new version of your existing OS or
    replacing it with another OS altogether. If you are staying with the same OS and
    just installing a newer version, such as upgrading Windows 10 to Windows Whatever,
    you have the choice of performing an update, or what's called a **clean install**.
    Essentially, a clean install removes any obsolete or out-of-date elements of the
    old version and replaces them with the newer versions. A clean install can also
    mean that the HDD is new and that the installation is on a *clean* disk drive.
    An upgrade from one version to another means that a clean install isn't necessary
    and that the installation will use an installer or setup program from the publisher.
    On the other hand, if you are replacing one OS with another, such as replacing
    Windows with Linux, there are things you should know about and a few steps you
    should take before installing the new OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method that''s used to prepare an HDD depends on the system configuration
    and boot process in use. BIOS creates a MBR and UEFI creates a **GUID partition
    table** (**GPT**). An MBR creates legacy BIOS partition tables and a GPT creates
    UEFI partition tables. GUID is a Microsoft term for **Globally Unique Identifier**
    and is applicable only to its systems. The remainder of the OS world uses the
    term **Universally Unique Identifier** (**UUID**) for essentially the same structures.
    A GPT (UEFI) system is able to define and create more than four partitions on
    an HDD and is a must if the disk drive is 4 TB or more. Below those thresholds,
    the MBR (BIOS) system will work, if present. The following screenshot shows the
    partition table type for a Windows system HDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c36018bf-7baf-4652-bc2d-240341e5b943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Properties dialog box showing the partition style of an HDD
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are for the general process of preparing a disk for the
    installation of an OS:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the computer on which the installation will occur meets or exceeds
    the system requirements published by the OS publisher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the HDD has data on it that you wish to preserve, take a total system backup
    to an external medium, such as an external HDD or a cloud service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wish to remove all previous data and content from the HDD on a Windows
    system, use the Disk Management format option. On a Linux system, use the `fdisk`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the disk partitions needed for the installation using either the Disk
    Management utility or the `DISKPART.EXE` command at the Windows Command Prompt.
    The following screenshot shows an example of the `DISKPART` commands. The `fdisk`
    command is used on a Linux system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After creating the partitions, format them to the appropriate partition table
    standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2be3917c-b9dd-4aa9-b78d-286b90dea60e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The display of the DISKPART.EXE command
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you store data on an HDD, USB-connected storage, or any other data storage
    device, it needs to have an organizational scheme so that individual files can
    be located in the future. A filesystem organizes and structures a storage medium
    and tracks the files stored on it. Along with location, a filesystem also catalogs
    identifying data for each file, including filename, size, status, creation and
    modification dates, access permissions, ownership, file type, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The placement of a filesystem on a data storage device, which may have several
    partitions or just one big one, happens through the process of formatting. Each
    partition may have a different filesystem. Formatting a drive generally does three
    things: recognizes a partition as a bounded structure; removes (erases) all existing
    data and indexing, if any, from the partition; and initiates a filesystem and
    its indexing in the partition. Each of the major operating systems has a utility
    to format a disk drive partition: **Windows Disk Management**, **Linux''s GParted**,
    and **Mac OS Disk Utility**.'
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems by OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Server+ exam, you will encounter questions and references about filesystems
    of Windows, Linux, and macOS. The filesystems that are included are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File Allocation Table 32 (FAT32)**: At one time, this was the default standard
    for Windows systems. It was used primarily for the format of flash memory drives.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New Technology Filesystem (NTFS)**: The default filesystem for Windows systems.
    The Windows system partition must be NTFS.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux/Unix:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better Filesystem (Btrfs)**: Adds pooling, snapshots, checksums, and other
    features to Linux.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extended Filesystem versions 2, 3, and 4 (ext2, ext3, and ext4)**: A filesystem
    based on the **Unix Filesystem** (**UFS**) that tracks individual files.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reiser Filesystem (ReiserFS)**: A journaling filesystem for Linux.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z File System (ZFS)**: Originally developed for the Solaris OS, it is common
    for Linux systems to support NAS.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mac OS:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apple File System (APFS)**: Replaces the HFS+ operating system on later Mac
    OS X systems.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hierarchical File System Plus (HFS+)**: The de facto standard filesystem
    of older Mac OS systems.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Journaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are filesystems that perform journaling and some that don't, though most
    of those are legacy filesystems. A journaling filesystem records filesystem changes
    before applying them to the medium of a *journal*, which is essentially a filesystem
    activity log. Typically, a journal is on a separate device to the filesystem.
    The journal file provides recovery data should the filesystem be damaged. Examples
    of journaling filesystems are NTFS, ReiserFS, ext3, and ext4.
  prefs: []
  type: TYPE_NORMAL
- en: Special function filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a filesystem really isn't a filesystem, but may perform some filesystem
    functions. The **Virtual Machine File System** (**VMFS**) works with a virtualized
    system's hypervisor to store and manage virtual machine snapshots and images.
    Swap, also known as **swap space**, is a space in a dedicated partition of a secondary
    storage device that the OS uses to store inactive memory pages to free up memory
    resources, as needed. The **Flash-Friendly File System** (**F2FS**) is an open
    source flash drive filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Network configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An essential part of installing and activating any NOS is configuring it for
    the network it's to support. In the following sections and steps, we will look
    at the processes that are used to configure a Windows Server system and a Linux
    system for some important settings and values.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the hostname
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hostname of a server (or any node on a network) identifies the node to a
    computer network in communication and access to other nodes and off-network devices
    and services. In effect, the hostname of a device is its nickname.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a hostname on Windows Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set the hostname of a Windows Server installation, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Windows icon to display the Start menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the This PC option to display the System window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the right-hand side of the System window, click on the Change settings button
    to display the System Properties dialog box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ce56b90-ba81-4c85-b90c-a054ec88b02f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Properties window of the This PC selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the name you wish to assign to the server in the Computer name textbox.
    The only hard rule is there can be no spaces in the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a820c0d-ed04-471b-ba36-0c405dd8de0f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Assigning a hostname to a system
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a hostname on a Linux server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a Linux server, there are two hostnames to configure: a network-related
    hostname and a local hostname. The steps used to set the hostnames are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Log on to the system as the root administrator (the superuser).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move to the `/etc/sysconfig` directory to locate the network file and display
    its contents, which should look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` command displays the contents of the file network. Notice that the
    last line of the file contains the hostname setting.
  prefs: []
  type: TYPE_NORMAL
- en: Use a Linux editor (vi or edit) to change the `HOSTNAME` value to the hostname
    you wish to use. After you've completed the edit, save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The edited file should now contain the revised hostname value. For example,
    the network file may now contain something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The hostname in the `localhosts` file also needs to be set. Move to the `/etc`
    directory to find the `hosts` file. Its contents should be along the lines of
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using an editor, replace the `localhost.localdomain localhost` value with the
    new hostname and save the file. After the change, the hosts file should contain
    something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You may want to also set the Terminal identity to the hostname of the server.
    The local network uses the Terminal name to address the server. To change the
    Terminal''s hostname, use the `hostname` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To verify the change, use the `hostname` command with no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: User accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a Windows Server system, a user may have one or two account types: a local
    account or a domain user account. A **local user account** limits the user to
    only the resources for which file and folder permissions grant access to the individual
    or to any group the individual is a member on a single network node. A **domain
    user account** can access either local or network (or both) resources, according
    to the access permissions assigned to the individual or to the groups the individual
    is a member of.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a local user account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up a local user account on a Windows Server, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the Start icon or press the Windows key + *x* to open the Start
    right-click menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Computer Management option to display its window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the left-hand navigation pane, click on Users under the Local Users and
    Groups option. The view shown in the following screenshot will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/212ac20a-6b44-4fa2-95eb-af30a974a8e0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new user through the Computer Management window
  prefs: []
  type: TYPE_NORMAL
- en: 'In the right-hand Actions pane, click on More... to open an options list. From
    that list, click on New User... to open the New User dialog box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f40ad9ff-d779-4ac8-935b-58252e84b22f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The New User dialog box
  prefs: []
  type: TYPE_NORMAL
- en: Fill in the new user's information and click on the Create button. The dialog
    box will clear and be ready to use so that you can add additional users. If finished,
    click on Close. Notice that the new user is now in the list of users in the Computer
    Management window. Remember that there's no way to recover a password on a local
    user account. so you may want to warn the user about using a password they will
    remember.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the new user is to have administrator privileges or belong to any other
    group, use the following steps to add the user to the applicable groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the name of the new user in the center pane of the Computer Management
    window and choose Properties from the option list that appears to display the
    Properties dialog box for the user:'
  prefs:
  - PREF_UL
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7168b1dd-17a1-4623-8ac5-5721d6dc6ec2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a user to a group on the user's Properties dialog box
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on a group name, in this case, Administrators, from the Member of: list
    and click Add. You can repeat this action to add the user to more groups.'
  prefs:
  - PREF_UL
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a domain user account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The creation of a domain user account assumes that at least one domain exists
    on a network. In the Windows world, a **domain** is a network where a database
    on a central domain controller contains information on all domain user accounts,
    security configuration, and the hardware devices on the network. The network''s
    **Active Directory** (**AD**) service manages domain user accounts. To create
    a new domain user account on a Windows Server system, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Start menu, open **Server Manager** and pull down the Tools menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Tools menu, select the Active Directory Users and Computer option to
    display its dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the left-hand navigation pane, click on the Users folder. On the option
    list that appears, click on New. On its option list, click on User to display
    the New Object - User dialog box, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b8a4cd9-d274-4011-ab66-bf8cee3cf704.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The New Object – User dialog box
  prefs: []
  type: TYPE_NORMAL
- en: After filling in the new user's information, click the Next button to move to
    another New Object – User dialog box and enter the user's password. Click Next
    to move to the New Object – User summary dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all of the information that's shown is correct, click on the Finish button.
    If you need to make corrections, use the Back button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a workstation to a domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To communicate on any network, a PC must join the network, which means that
    the network interface in the PC must connect to and join a network server''s administrative
    systems. On a Windows system, the PC joins a domain. The process to add a PC to
    a domain is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On the Control Panel, click on the System option and choose About from the options
    in the left-hand side pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the Join a domain button opens the first of the domain identification
    dialog boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see three or four Join a domain dialog boxes in the next step. The
    first dialog box, as shown in the following screenshot, asks you for the name
    of the domain to which you wish to add the PC. If the domain name is valid, enter
    the username and password that you (personally) use to log on to the domain. While
    the system is authenticating the information you''ve entered, a blank copy of
    the first screen may be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b1b3ea0-3a82-4ca5-8cad-637099647f5c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The domain name dialog box
  prefs: []
  type: TYPE_NORMAL
- en: If the information that you've entered is valid, the next dialog box asks for
    the username of the person that will use this PC and the account type for the
    user, such as administrator, user, standard, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connecting to a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's one thing to add a PC to a network domain and quite another to actually
    connect a PC to the network for active communication. Once a PC is in a domain,
    the next step is to verify that the electronics all synchronize and interoperate.
    In other words, *can the PC talk to the network?*
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the medium used to communicate over a network does have an impact
    on the setup of network communications, as you might expect. However, you'd be
    surprised at how little of a difference this actually makes. Both physical cable
    and **radio frequency** (**RF**) communications are predominantly Ethernet networks.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a PC to a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ensure that a PC will connect to a network, there are a few steps to verify
    that the necessary elements are active before testing its communications. The
    first element to check is its connection service. A cable-connected network needs
    the Wired AutoConfig service''s startup type, as shown in the following screenshot,
    set to automatic. If the workstation is connecting to a wireless local network,
    the WLAN AutoConfig service is set, or if the workstation is connecting to a wireless
    wide area network, configure the WWAN AutoConfig service. Whichever one of these
    three network services is activated, the other two should be deactivated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9bdc7c7-8066-4d94-8a43-a6e11cead33d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Windows Services maintenance window
  prefs: []
  type: TYPE_NORMAL
- en: Adding server roles and features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A server role is one or more programs or sets of utilities that a server can
    use to provide a specific feature or function to a user, group of computers, or
    an application. Server roles and features set the purpose or role of a server.
    For example, a Windows server may have only a single role or be configured as
    an AD domain server, or it may have several different roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add or remove roles and features from a Windows Server system, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: On a Windows Server system, open Server Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Manage menu option and select Add Roles and Features, as shown
    in the following screenshot, to open the Before you begin page of the Add Roles
    and Features Wizard. This page lists a series of tasks you should consider doing
    before adding, changing, or removing server roles and features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2de2b98a-86b0-46b3-9fd8-794c6f52dfb0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Server Manager page of a Windows 2012 R2 system
  prefs: []
  type: TYPE_NORMAL
- en: Click Next to move to the Select installation type page. Select the Role-based
    or feature-based installation option. Click the Next button to advance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Select destination server page, click on the Server Selection option
    in the left-hand navigation pane and then select either a server or a virtual
    hard disk from the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Next to advance to the Select server roles page, as shown in the following
    screenshot. In the main area of this page is a list of the roles and features
    to assign to the server or virtual disk chosen in the previous step. After you''ve
    completed your selections, click Next to move to the Select features page. Depending
    on the roles selected, a Roles services page may display first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/99a70897-468e-4d31-b3db-2cad2decec40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Select server roles page of the Add Roles and Features Wizard
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Select features page, select any features you wish to add to the target
    server. When you''ve finished, click the Next button to display the Installation
    progress page, which includes a summary of the roles and features selected, as
    shown in the following screenshot. If the list is correct, click the Next button
    to move to the Install page and begin the installation process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/31585084-535d-43d8-8669-e5d370ecf56a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Installation progress page of the Add Roles and Features Wizard
  prefs: []
  type: TYPE_NORMAL
- en: When the installation completes, click on Close to return to the Server Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unattended and remote installations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network administrators often need to access a remote computer for a variety
    of reasons. One of the more common tasks facing network administrators is the
    upgrade of software, including the OS, or running diagnostic utilities. In the
    past, these tasks required what the communication industry calls *a truck roll*,
    or a physical visit to the remote location. If remote means only across the building,
    there isn't usually too much of a problem. However, if remote means in another
    state, country, or continent, the time and cost required to affect changes can
    really grow. A number of different standards, software, and technologies are available
    to allow the network administrator to make these changes without the need to travel
    any further than from his or her desk to a network workstation.
  prefs: []
  type: TYPE_NORMAL
- en: The first of these tools is Intel's **Wired for Management** (**WfM**) specification,
    which allows a network administrator to create an automatic procedure to accomplish
    client maintenance and management over a network. You can also work with other
    tools, such as the **LANDesk Client Manager** (**LDCM**), a software tool that
    monitors network clients for hardware issues, and the **Desktop Management Interface**
    (**DMI**), which is an **application programming interface** (**API**) that allows
    software to inventory a network client, such as the details of which motherboard,
    expansion bus cards, and application software it has.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that WfM works with is the **Preboot Execution Environment** (**PXE**), pronounced *pixi*.
    PXE enables a network administrator to boot a network client from a server by
    interfacing only with the client's PXE-enabled **network interface card** (**NIC**)
    or network adapter. PXE clients connect through their NICs to a network, even
    when the PC's power is off. The PXE client need not have an operating system,
    nor any other software for this remote boot to take place, even if it's on the
    client. The network administrator can then use a tool such as **Trivial File Transport
    Protocol** (**TFTP**) to transfer software or data to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Windows systems and Linux systems, for the most part, provide a PXE **network
    boot program** (**NBP**). Windows systems provide the **Remote Installation Service**
    (**RIS**), which incorporates the PXE standard. Linux systems support the **PXELINUX**
    and the **gPXE** utilities.
  prefs: []
  type: TYPE_NORMAL
- en: NOS optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network users expect the network to meet their individual needs in terms of
    bandwidth, speed, and responsiveness. These three expectations are parts of the
    same whole to the user—a network that performs consistently to provide the service
    that's expected. A network administrator can use a variety of processes, techniques,
    and methods to promote efficiency and effectiveness on a network at any level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the ways that the network administrator can ensure a network always
    meets its users'' needs include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bandwidth**: Network administrators fully understand that a 10 Gbps network
    doesn''t mean that users, individually or collectively, will realize that much
    bandwidth. Every network must consider the bandwidth loss from just providing
    a working network. To users, the network administrator''s primary job is to keep
    bandwidth high for everyone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High availability and fault tolerance**: As we discussed earlier in this
    chapter, HA and fault tolerance can be the key characteristics of a network that
    users depend upon. How much of the 525,600 minutes of uptime possible in a year
    a system is designed to achieve is an important design goal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: On larger networks and data centers in which servers are
    clustered or distributed, load balancing can accept multiple input sources and
    distribute them to multiple processors, evening out the processing of the load
    and the outbound traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality of Service (QoS)**: Although its name reflects how users measure
    a network''s performance, QoS is the ability of a network to provide a variety
    of services over a variety of communication methods at a level that meets the
    needs of the organization. A network that supports data, voice, and video consistently
    has QoS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An NOS provides system control and management functions to network clients
    and resources and provide administration, security, resources, and other services
    to network clients. An OS has five primary functions: user/computer communications,
    memory management; control and coordinate hardware; internal and network file
    management; and user, data, application, and resource security. There are four
    categories of system resources; IRQs, I/O addresses, memory addresses, and **direct
    memory access** (**DMA**) addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file management functions of an OS include creating new files, providing
    for file modification, performing file removal, organizing files for accessibility,
    and facilitating access for multiple users. The security of an OS requires patch
    and update management, antivirus and malware updates, the examination of all traffic
    by a security appliance, and the regular review of user and group account permissions
    and rights. An operating system has three primary parts: the kernel, the shell,
    and the filesystem. A filesystem organizes a storage medium and tracks the files
    stored on it. It also catalogs identifying file data for each file. Formatting
    a drive recognizes a partition as a bounded structure, removes existing data and
    indexing, and initiates a filesystem and its indexing in the partition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hardware configuration settings in BIOS or UEFI, OS, and support systems,
    define startup, installed devices, and performance and operation parameters. Firmware
    is one of two general technologies: BIOS and UEFI. WfM allows an automatic procedure
    to do client maintenance and management over a network. DMI allows software to
    make an inventory of the hardware and software of a network client. PXE enables
    a network administrator to boot a network client remotely. TFTP transfers software
    or data to a remote client.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the basic function of a network server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Communicating with the internet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing services to network clients
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Intrusion detection and prevention
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing proxy server functions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is not a function of a network server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Administration
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resource allocation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is not a system resource that's managed by an operating
    system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IRQ
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: I/O address
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Device driver
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DMA address
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The file management functions of an OS include the creation, modification, and
    removal of data files and what else?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: File accessibility
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limiting access to only a single user
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Applying encryption to all files
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Converting filenames
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An operating system has three primary parts. Which of the following is not one
    of those parts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Device drivers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kernel
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Shell
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Filesystem
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two most common firmware system configuration systems? (Choose
    two)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CMOS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: BIOS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: FAT32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: UEFI
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: APFS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A filesystem configured on a Linux system could be which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NTFS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: APFS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: BTRFS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: HFS+
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which identification identifies a server for the purposes of communication and
    access to network resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User account name
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hostname
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Server name
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Group account name
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On a Windows Server network, the network administrator may grant a domain user
    which access level? (Choose all that apply)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local computer resources
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Server-based resources
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Network-attached resources
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: WAN resources
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A network administrator wishes to power up and boot a remote PC attached to
    an organization's network. Which of the following services will enable this action?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QoS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DMI
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PXE
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: TFTP
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
