# 使用 AWK 改进 lastlog

我们已经在第十二章《使用 AWK 汇总日志》中看到了如何从大量纯文本文件中挖掘的数据创建复杂报告。类似地，我们可以使用标准命令行工具的输出创建广泛的报告，比如`lastlog`工具。`lastlog`本身可以报告所有用户的最后登录时间。然而，我们通常可能希望过滤`lastlog`的输出。也许你需要排除那些从未用于登录系统的用户账户。报告`root`账户也可能不相关，因为该账户可能主要用于`sudo`，并没有用于常规登录时记录数据。

在本章中，我们将使用`lastlog`并格式化 XML 数据。由于这是我们研究 AWK 的最后一章，我们将配置记录分隔符。我们已经看过 AWK 中字段分隔符的使用，但我们可以将默认的记录分隔符从换行符更改为更符合我们需求的内容。本章将具体介绍：

+   使用 AWK 范围来排除数据

+   基于字段数量的条件

+   操控 AWK 记录分隔符来报告 XML 数据

# 技术要求

本章的源代码可以在这里下载：

[`github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter13`](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter13)

# 使用 AWK 范围来排除数据

到目前为止，在本书中，我们主要关注的是如何在`sed`或`awk`中使用范围来包含数据。对于这两个工具，我们可以否定范围，从而排除指定的行。为了更好地解释这一点，我们将使用`lastlog`命令的输出。它将打印所有用户的登录数据，包括那些从未登录的账户。这些从未登录的账户可能是服务账户，或者是那些至今没有登录系统的新用户。

# lastlog 命令

如果我们查看`lastlog`的输出，在没有任何选项的情况下使用时，我们可以开始理解这个问题。从命令行执行该命令时，作为标准用户执行即可。没有要求必须以 root 账户运行。命令示例如下：

```
$ lastlog 
```

以下截图显示了部分输出：

![](img/e5e1aa3f-c1b1-4ff9-91c6-4ab01b427a3e.png)

即使从这个有限的输出中，我们也能看到由于未登录的账户产生的虚拟噪声，我们得到了杂乱的输出。可以使用 `lastlog` 的选项在某种程度上缓解这个问题，但它可能无法完全解决。为了演示这一点，我们可以为 `lastlog` 添加一个选项，仅显示标准用户，并过滤掉其他系统和服务用户。这在你的系统上可能有所不同，但在我使用的 CentOS 6 示例主机上，第一个用户的 UID 为 500。在 CentOS 7 中，标准用户的 UID 从 1000 开始。

如果我们使用 `lastlog -u 500-5000` 命令，我们将只打印 UID 在此范围内的用户数据。在这个简单的演示系统中，我们只有三个用户账户，因此输出是可以接受的。然而，我们也可以理解，由于这些尚未使用的账户，可能仍然会有一些杂乱。这在以下截图中得到了展示：

![](img/a5d841e5-a646-4048-be7b-b7342e77a971.png)

除了从 `Never logged in` 账户打印出来的冗余数据外，我们可能只对 `Username` 和 `Latest` 字段感兴趣。这也是支持使用 AWK 作为数据过滤工具的另一个原因。这样，我们可以提供水平和垂直的数据过滤，过滤行和列。

# 使用 AWK 进行水平行过滤

为了使用 AWK 进行过滤，我们将直接通过管道将 `lastlog` 的数据传递给 `awk`。我们将使用一个简单的控制文件，最初提供水平过滤或减少我们看到的行数。首先，命令管道将像下面的命令示例一样简单：

```
$ lastlog | awk -f lastlog.awk  
```

当然，复杂性已经从命令行中抽象出来，并隐藏在我们使用的控制文件中。最初，控制文件保持简单，内容如下：

```
!(/Never logged in/ || /^Username/ || /^root/) { 
  print $0; 
} 
```

范围设置如我们之前所见，位于主代码块之前。在括号前加上感叹号会否定或反转所选范围。双竖线作为逻辑 `OR`。我们不包括包含 `Never logged in` 的行，也不包括以 `Username` 开头的行。这会去掉 `lastlog` 打印出的表头行。最后，我们排除了 root 账户的显示。这启动了我们处理的行，主代码块将打印出这些行。

# 计算匹配的行数

我们可能还希望计算过滤器返回的行数。例如，使用内部的 `NR` 变量将显示所有行，而不仅仅是匹配的行；为了能够报告已登录的用户数量，我们必须使用自己的变量。以下代码将保持计数在我们命名为 `cnt` 的变量中。每次主代码块迭代时，我们使用 C 风格的 `++` 来递增它。

我们可以使用 `END` 代码块来显示这个变量的最终值：

```
!(/Never logged in/ || /^Username/ || /^root/) { 
  cnt++ 
  print $0; 
} 
END { 
  print "========================" 
  print "Total Number of Users Processed: ", cnt 
} 
```

从以下代码和输出中，我们可以看到它在我的系统上是如何表现的：

![](img/5e652e26-f2d1-4e8d-bc1a-6cce1fc1e14f.png)

从显示输出中，我们现在可以看到，我们只显示已登录的用户，而在这种情况下，只有单个用户。然而，我们也可以决定进一步抽象数据，并仅显示匹配行中的某些字段。这应该是一个简单的任务，但事实并非如此，因为登录执行的字段数量将不同。

# 基于字段数量的条件

如果用户直接登录到服务器的物理控制台而不是通过远程或图形伪终端登录，则 `lastlog` 输出将不显示主机字段。为了演示这一点，我已经直接登录到我的 CentOS 主机上的 `tty1` 控制台，并避免使用图形界面。来自先前 AWK 控制文件的输出显示，我们现在有用户 `tux` 和 `bob`；但是 `bob` 缺少主机字段，因为他连接到控制台：

![](img/03832b05-a56d-4a9b-afd8-32169cf5ca23.png)

尽管本身没有问题，但如果我们想要过滤字段，并且两行的字段编号将因一些行中省略了字段而有所不同，则会有问题。对于 `lastlog`，对于大多数连接，我们将有 `9` 个字段，而对于直接连接到服务器控制台的连接，只有 `8` 个字段。应用程序的目标是打印用户名和日期，但不打印最后登录时间。我们还将在 `BEGIN` 块中打印我们自己的标题。为了确保我们使用正确的位置，我们将需要使用 `NF` 内部变量来计算每行的字段数。

对于具有 `8` 个字段的行，我们希望打印字段 `1`、`4`、`5` 和 `8`；对于具有额外主机信息的更长行，我们将使用字段 `1`、`5`、`6` 和 `9`。我们还将使用 `printf` 以便能够正确对齐列数据。控制文件应如下例所示进行编辑：

```
BEGIN { 
printf "%8s %11s\n","Username","Login date" 
print "====================" 
} 
!(/Never logged in/ || /^Username/ || /^root/) { 
cnt++ 
if ( NF == 8 ) 
    printf "%8s %2s %3s %4s\n", $1,$5,$4,$8 

else 
    printf "%8s %2s %3s %4s\n", $1,$6,$5,$9 
} 
END { 
print "====================" 
print "Total Number of Users Processed: ", cnt 
} 
```

我们可以在下面的屏幕截图中看到命令及其产生的输出。我们可以看到如何根据我们想要关注的信息创建一个更合适的显示：

![](img/4470b002-4a96-43a5-b3e6-bae9bce56b27.png)

如果我们查看输出，我选择显示日期在月份之前，以便不按数字顺序显示字段。当然，这是个人选择，并可根据您希望显示数据的方式进行定制。

我们可以利用我们在 `lastlog` 控制文件中看到的原理来处理来自任何命令的输出，并且您应该使用您希望从中过滤数据的命令进行实践。

# 操纵 AWK 记录分隔符以报告 XML 数据

到目前为止，虽然我们一直在使用 AWK 处理单独的行，每一行都代表一个新记录。尽管这通常是我们想要的情况，但在处理标记数据（例如 XML，其中一个单独记录可能跨越多行）时，我们可能需要设置 `RS` 或记录分隔符内部变量。

# Apache 虚拟主机

在第九章，*自动化 Apache 虚拟主机*，我们使用了**Apache 虚拟主机**。这使用了标记数据，定义了每个虚拟主机的开始和结束。即使我们更倾向于将每个虚拟主机存储在自己的文件中，它们也可以合并到一个文件中。考虑以下存储可能的虚拟主机定义的文件；它可以存储为`virtualhost.conf`文件，如下所示：

```
<VirtualHost *:80> 
DocumentRoot /www/example 
ServerName www.example.org 
# Other directives here 
</VirtualHost> 

<VirtualHost *:80> 
DocumentRoot /www/theurbanpenguin 
ServerName www.theurbanpenguin.com 
# Other directives here 
</VirtualHost> 

<VirtualHost *:80> 
DocumentRoot /www/packt 
ServerName www.packtpub.com 
# Other directives here 
</VirtualHost> 
```

我们将三个虚拟主机存储在一个文件中。每个记录由一个空行分隔，这意味着我们有两个换行符，它们在逻辑上分隔了每个条目。我们可以通过将`RS`变量设置为以下方式来向 AWK 解释这一点：`RS="\n\n"`。设置好后，我们可以打印所需的虚拟主机记录。这将被设置在控制文件的`BEGIN`代码块中。

我们还需要动态地在命令行中搜索所需的主机配置。我们将其构建到控制文件中。控制文件应类似于以下代码：

```
BEGIN { RS="\n\n" ; } 
$0 ~ search { print } 
```

`BEGIN`块设置了变量，然后我们进入了范围部分。这个范围设置使得记录（`$0`）与`search`变量匹配（`~`）。我们必须在执行`awk`时设置该变量。以下命令演示了命令行执行，其中控制文件和配置文件位于我们的工作目录中：

```
$ awk -f vh.awk search=packt virtualhost.conf 
```

我们可以通过查看下面截图中的命令和输出结果，清楚地看到这一点：

![](img/44905680-8349-437a-b642-1cda2008fa5b.png)

# XML 目录

我们还可以将这个概念扩展到 XML 文件中，在这些文件中，我们可能不想显示完整的记录，而只是某些特定的字段。考虑以下产品`catalog`：

```
<products>
<product> 
<name>drill</name> 
<price>99</price> 
<stock>5</stock> 
</product> 

<product> 
<name>hammer</name> 
<price>10</price> 
<stock>50</stock> 
</product> 

<product> 
<name>screwdriver</name> 
<price>5</price> 
<stock>51</stock> 
</product> 

<product> 
<name>table saw</name> 
<price>1099.99</price> 
<stock>5</stock> 
</product> 
</products>
```

从逻辑上讲，每个记录像之前一样以空行分隔。然而，每个字段的细节更加详细，我们需要使用以下分隔符：`FS="[><]"`。我们将开括号或闭括号定义为字段分隔符。

为了帮助分析，我们可以按照如下方式打印一个单独的记录：

```
<product><name>top</name><price>9</price><stock>5</stock></product> 
```

每个尖括号是一个字段分隔符，这意味着我们将有一些空字段。我们可以将这一行重写为 CSV 文件：

```
,product,,name,top,/name,,price,9,/price,,stock,5,/stock,,/product, 
```

我们只需将每个尖括号替换为逗号；这样更容易被我们读取。我们可以看到字段`5`的内容是`top`值。

当然，我们不会编辑 XML 文件，我们会保持其 XML 格式。这里的转换只是为了突出显示字段分隔符是如何读取的。

用于从 XML 文件中提取数据的控制文件示例如下：

```
BEGIN { FS="[><]"; RS="\n\n" ; OFS=""; } 
$0 ~ search { print $4 ": " $5, $8 ": " $9, $12 ": " $13 } 
```

在`BEGIN`代码块中，我们设置了`FS`和`RS`变量，正如我们之前所讨论的。我们还将**输出字段分隔符**（`OFS`）设置为空格。通过这种方式，当我们打印字段时，会用空格分隔各个值，而不是保留尖括号。范围使用了我们在查看虚拟主机时所使用的相同匹配条件。

如果我们需要在`catalog`中查找产品钻孔，可以使用以下命令：

```
$ awk -f catalog.awk search=drill catalog.xml  
```

以下截图详细显示了输出：

![](img/86b9bef1-16e5-489b-8d1b-5995016e46b3.png)

我们现在已经能够处理一个相当杂乱的 XML 文件，并从目录中生成可读的报告。AWK 的强大功能再次得到体现，对于我们来说，这是在本书中的最后一次使用。到现在为止，我希望你也能开始定期使用它。

# 总结

我们有三章使用了 AWK，首先是一些基本用法的介绍，在第十章中，*AWK 基础知识*，我们熟悉了 AWK。接着，在第十二章中，*使用 AWK 汇总日志*，以及本章，我们开始构建定制应用程序。

具体来说，在本章中我们展示了如何从标准命令的输出（如`lastlog`）中创建报告。我们看到可以否定范围，并额外使用`OR`语句。然后我们构建了一个应用程序，使我们能够查询 XML 数据。

在接下来的两章中，我们将不再使用 Shell 脚本，而是转向使用 Perl 和 Python 脚本，以便比较这些脚本语言并做出合适的选择。

# 问题

1.  我们如何获取那些从未登录过系统的用户？

1.  根据前一个问题，如何计算从未登录的用户数量？

1.  以下命令将打印多少行？

# 进一步阅读

请参阅以下内容，进一步阅读与本章相关的资料：

+   [`linux.die.net/man/8/lastlog`](https://linux.die.net/man/8/lastlog)

+   [`en.wikipedia.org/wiki/Lastlog`](https://en.wikipedia.org/wiki/Lastlog)
