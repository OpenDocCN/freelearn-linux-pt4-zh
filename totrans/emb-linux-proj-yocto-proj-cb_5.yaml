- en: Chapter 5. Debugging, Tracing, and Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing core dumps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native GDB debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross GDB debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using strace for application debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the kernel's performance counters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using static kernel tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dynamic kernel tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dynamic kernel events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Yocto's tracing and profiling tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing and profiling with perf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SystemTap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OProfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LTTng
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blktrace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging an embedded Linux product is a common task not only during development,
    but also in deployed production systems.
  prefs: []
  type: TYPE_NORMAL
- en: Application debugging in embedded Linux is different from debugging in a traditional
    embedded device in that we don't have a flat memory model with an operating system
    and applications sharing the same address space. Instead, we have a virtual memory
    model with the Linux operating system, sharing the address space and assigning
    virtual memory areas to running processes.
  prefs: []
  type: TYPE_NORMAL
- en: With this model, the mechanisms used for kernel and user space debugging differ.
    For example, the traditional model of using a JTAG-based hardware debugger is
    useful for kernel debugging, but unless it knows about the user space processes
    memory mapping, it will not be able to debug user space applications.
  prefs: []
  type: TYPE_NORMAL
- en: Application debugging is approached with the use of a user space debugger service.
    We have seen an example of this methodology in action with the TCF agent used
    in the Eclipse GDB. The other commonly used agent is the **gdbserver**, which
    we will use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we will explore the area of tracing and profiling. Tracing is a low-level
    logging of frequent system events, and the statistical analysis of these captured
    traces is called profiling.
  prefs: []
  type: TYPE_NORMAL
- en: We will use some of the tools embedded Linux and Yocto offer to trace and profile
    our systems so that they run to their maximum potential.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing core dumps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even after extensive quality assurance testing, embedded systems in-field also
    fail and need to be debugged. Moreover, often the failure is not something that
    can be easily reproduced in a laboratory environment, so we are left with production,
    often hardened system, to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we have designed our system with the aforementioned scenario in mind,
    our first debugging choice is usually to extract as much information about the
    failing system—for example, by obtaining and analyzing a core dump of the misbehaving
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the process of debugging embedded Linux systems, we can use the same toolbox
    as standard Linux systems. One of the tools enables applications to generate into
    the disk a memory core dump upon crashing. This assumes that we have enough disk
    space to store the application's entire memory map, and that writing to disk is
    quick enough that it will not drag the system to a halt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the memory core dump is generated, we use the host''s GDB to analyze the
    core dump. GDB needs to have debug information available. Debug information can
    be in the executable itself—for example, when we install the `-dbg` version of
    a package, or we configure our project to not strip binaries—or can be kept in
    a separate file. To install debug information separately from the executable,
    we use the `dbg-pkgs` feature. By default, this installs the debug information
    of a package in a `.debug` directory in the same location as the executable itself.
    To add debug information for all packages in a target image, we add the following
    to our `conf/local.conf` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can then build an appropriate toolchain generated to match our filesystem,
    as we saw in the *Preparing and using an SDK* recipe in [Chapter 4](ch04.html
    "Chapter 4. Application Development"), *Application Development*. The core dump
    contains build IDs for the executables and libraries in use at the time of the
    crash, so it's important to match the toolchain and the target image.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can display the limits of the system-wide resources with the `ulimit` tool.
    We are interested in the core file size, which by default is set to zero to avoid
    the creation of application core dumps. In our failing system, preferably in a
    test environment, make your application dump a memory core upon crashing with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then verify the change with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For this example, we will be using the `wvdial` application in a real segmentation
    fault scenario. The purpose is not to debug the application itself but to showcase
    the methodology used for core dump analysis; so, details regarding the application-specific
    configuration and system setup are not provided. However, being a real crash,
    the example is more illustrative.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run `wvdial` on the target, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The application will create a core file in the same folder, which you can then
    copy to your host system to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also simulate a core dump by sending a `SIGQUIT` signal to a running
    process. For example, you could force the sleep command to core dump with a `SIGQUIT`
    signal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once in possession of the core dump, use the cross GDB in the host to load
    it and get some useful information, such as the backtrace, using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First set up the environment in the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can then start the cross GDB debugger, passing it a debug version of the
    application. Debug versions are stored in the `sysroot` file in the same location
    as the unstripped binary, but under a `.debug` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The whole GDB banner is showed below but will be omitted in future examples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now point GDB to the location of the toolchain''s `sysroot`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now inquire GDB for the application''s backtrace as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The usage documentation for GDB found at [http://www.gnu.org/software/gdb/documentation/](http://www.gnu.org/software/gdb/documentation/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native GDB debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On devices as powerful as the Wandboard, native debugging is also an option
    to debug sporadic failures. This recipe will explore the native debugging method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For native development and debugging, Yocto offers the `-dev` and `-sdk` target
    images. To add developing tools to the `-dev` images, we can use the `tools-sdk`
    feature. We also want to install debug information and debug tools, and we do
    this by adding the `dbg-pkgs` and `tools-debug` features to our image. For example,
    for `core-image-minimal-dev`, we would add the following to our `conf/local.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To prepare a development-ready version of the `core-image-minimal-dev` target
    image, we would execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will then program the development image to our target.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the target has booted, you can start the `wvdial` application through
    the native GDB using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the target command prompt, start the GDB debugger with the application as
    argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now instruct GDB to run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then request to print a backtrace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is not the same backtrace you got when analyzing the core dump. What is
    going on here? The clue is on libcrypto, part of the OpenSSL library. OpenSSL
    probes the capabilities of the system by trying each capability and trapping the
    illegal instruction errors. So the `SIGILL` signal you are seeing during startup
    is normal and you should instruct GDB to continue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instruct GDB to continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This result is now compatible with the core dump you saw in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When debugging applications, it is sometimes useful to reduce the level of
    optimization used by the compiler. This will reduce the application''s performance
    but will facilitate debugging by improving the accuracy of the debug information.
    You can configure the build system to reduce optimization and add debug information
    by adding the following line of code to your `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By using this configuration, the optimization is reduced from `FULL_OPTIMIZATION
    (-O2)` to `DEBUG_OPTIMIZATION (-O -fno-omit-frame-pointer)`. But sometimes this
    is not enough, and you may like to build with no optimization. You can achieve
    this by overriding the `DEBUG_OPTIMIZATION` variable either globally or for a
    specific recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example on using a debug-optimized build in the upcoming recipe on *Cross
    GDB debugging*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross GDB debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run a cross compiled GDB in the host, which connects to a native gdbserver
    running on the target, it is referred to as cross debugging. This is the same
    scenario we saw in the *Using the Eclipse IDE* recipe earlier, except that Eclipse
    uses the **Target Communications Framework** (**TCF**). Cross debugging has the
    advantage of not needing debug information on target images, as they are already
    available in the host.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to use a cross GDB and gdbserver.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To include gdbserver in your target image, you can use an `-sdk` image, or
    you can add the `tools-debug` feature to your image by adding the following to
    your `conf/local.conf` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So that GDB can access debug information of the shared libraries and executables,
    add the following to the `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The images running on the target and the toolchain''s `sysroot` need to match.
    For example, if you are using `core-image-minimal` images, the toolchain needs
    to have been generated in the same project with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a `sysroot` containing debug information for binaries and
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the toolchain is installed, you can run the application to be debugged
    on the target using gdbserver—in this case, `wvdial`—in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch gdbserver with the application to run as argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The gdbserver is launched listening on localhost on a random 1234 port and is
    waiting for a connection from the remote GDB.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the host, you can now set up the environment using the recently installed
    toolchain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then launch the cross GDB, passing to it the absolute path to the debug
    version of the application to debug, which is located in a `.debug` directory
    on the `sysroot`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next configure GDB to consider all files as trusted so that it auto loads whatever
    it needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also as you know, `wvdial` will generate a `SIGILL` signal that will interrupt
    our debugging session, instruct GDB not to stop when that signal is seen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then connect to the remote target on the `1234` port with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first thing to do is to set `sysroot` so that GDB is able to find dynamically
    loaded libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type `c` to continue with the program''s execution. You will see `wvdial` continuing
    on the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will then see GDB intercepting a `SIGILL` and `SEGSEGV` signal on the host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now ask to see a backtrace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although limited, this backtrace could still be useful to debug the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We see a limited backtrace because the compiled binaries are not suitable for
    debugging, as they omit stack frames. To keep information on stack frames, add
    the following to the `conf/local.conf` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the compilation flags to debug optimization as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `-fno-omit-frame-pointer` flag will tell `gcc` to keep stack frames. The
    compiler will also reduce the optimization level to provide a better debugging
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: A debug build will also make it possible to trace variables and set breakpoints
    and watchpoints, as well as other common debugging features.
  prefs: []
  type: TYPE_NORMAL
- en: 'After building and installing the target images and toolchain again, you can
    now follow the same process as in the preceding recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code for connecting to the remote target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `sysroot` as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are done with the setup, instruct the program to continue as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now see a complete backtrace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using strace for application debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging does not always involve working with source code. Sometimes it is
    a change in an external factor that is causing the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Strace is a tool that is useful for scenarios where we are looking for problems
    outside of the binary itself; for example configuration files, input data, and
    kernel interfaces. This recipe will explain how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To include strace in your system, add the following to your `conf/local.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Strace is also part of the `tools-debug` image feature, so you can also add
    it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Strace is also included in the `-sdk` images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting, we will also include `pgrep`, a process utility that will
    make our debugging easier by looking up process IDs by name. To do so, add the
    following to your `conf/local.conf` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When printing a system call, strace prints the values passed to the kernel or
    returned from the kernel. The verbose option prints more details for some system
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, filtering just the `sendto()` system calls from a single ping
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strace allows the monitoring of system calls of running processes into the Linux
    kernel. It uses the `ptrace()` system call to do so. This means that other programs
    that use `ptrace()`, such as `gdb`, will not run simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strace is a disruptive monitoring tool, and the process being monitored will
    slow down and create many more context switches. A generic way of running strace
    on a given program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments are explained below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f`: Tells strace to trace all child processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e`: Filters the output to a selection of comma separated system calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t`: Prints absolute timestamps. Use `r` for timestamps relative to the last
    syscall, and `T` to add the time spent in the syscall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: Increases the maximum length of strings from the default of `32`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`o`: Redirects the output to a file that can then be analyzed offline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can also attach to running processes using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Or several instances of a process using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To detach, just press *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The corresponding man pages for more information about strace at [http://man7.org/linux/man-pages/man1/strace.1.html](http://man7.org/linux/man-pages/man1/strace.1.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the kernel's performance counters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardware performance counters are perfect for code optimization, especially
    in embedded systems with a single workload. They are actively used by a wide range
    of tracing and profiling tools. This recipe will introduce the Linux performance
    counters subsystem and show how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Linux Kernel Performance Counters Subsystem** (**LPC**), commonly known
    as `linux_perf`, is an abstraction interface to different CPU-specific performance
    measurements. The `perf_events` subsystem not only exposes hardware performance
    counters from the CPU, but also kernel software events using the same API. It
    also allows the mapping of events to processes, although this has a performance
    overhead. Further, it provides generalized events which are common across architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Events can be categorized into three main groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software events**: Based on kernel counters, these events are used for things
    such as context switches and minor faults tracking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware events**: These come from the processor''s CPU **Performance Monitoring
    Unit** (**PMU**) and are used to track architecture-specific items, such as the
    number of cycles, cache misses, and so on. They vary with each processor type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware cache events**: These are common hardware events that will only
    be available if they actually map to a CPU hardware event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To know whether `perf_event` support is available for your platform, you can
    check for the existence of the `/proc/sys/kernel/perf_event_paranoid` file. This
    file is also used to restrict access to the performance counters, which by default
    are set to allow both user and kernel measurement. It can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2`: Only allows user-space measurements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: Allows both kernel and user measurements (default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: Allows access to CPU-specific data but not raw tracepoint samples'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-1`: No restrictions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The i.MX6 SoC has a Cortex-A9 CPU which includes a PMU, providing six counters
    to gather statistics on the operation of the processor and memory, each one of
    them able to monitor any of 58 available events.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a description of the available events in the *Cortex-A9 Technical
    Reference Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: The i.MX6 performance counters do not allow exclusive access to just user or
    just kernel measurements. Also, i.MX6 SoC designers have unfortunately joined
    the PMU interrupts from all CPU cores, when ideally they should only be handled
    by the same CPU that raises them. You can start the i.MX6 with just one core,
    using the `maxcpus=1` kernel command-line argument, so that you can still use
    the `perf_events` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the Linux kernel to boot with one core, stop at the U-Boot prompt
    and change the `mmcargs` environment variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mmcargs` environmental variable is only used when booting from an MMC device
    like the microSD card. If the target is booting from another source, such as a
    network, the corresponding environmental variable will have to be changed. You
    can dump the whole U-Boot environment with the `printenv` U-Boot command, and
    change the required variable with `setenv`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interface introduces a `sys_perf_event_open()` syscall, with the counters
    being started and stopped using `ioctls`, and read either with `read()` calls
    or `mmapping` samples into circular buffers. The `perf_event_open()` syscall is
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There is no `C` library wrapper for it, so it needs to be called using `syscall()`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is an example, `perf_example.c`, program modified from the `perf_event_open`
    man page to measure instruction count for a `printf` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For compiling this program externally, we can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After copying the binary to your target, you can then execute it with the help
    of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, using zero instructions for the `printf()` call can't be correct.
    Looking into possible causes, we find a documented erratum (ERR006259) on i.MX6
    processors that states that in order for the PMU to be used, the SoC needs to
    receive at least 4 JTAG clock cycles after power on reset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerun the example with the JTAG connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though you can access the `perf_events` interface directly as in the preceding
    example, the recommended way to use it is through a user space application, such
    as perf, which we will see in the *Tracing and profiling with perf* recipe in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Technical Reference Manual at [http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0388f/BEHGGDJC.html](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0388f/BEHGGDJC.html)for
    more information about the Cortex-A9 PMU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using static kernel tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel is continuously being instrumented with static probe points
    called **tracepoints**, which when disabled have a very small overhead. They allow
    us to record more information than the function tracer we saw in [Chapter 2](ch02.html
    "Chapter 2. The BSP Layer"), *The BSP Layer*. Tracepoints are used by multiple
    tracing and profiling tools in Yocto.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explain how to use and define static tracepoints independently
    of user space tools.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static tracepoints can be instrumented using custom kernel modules, and also
    through the event tracing infrastructure. Enabling any of the tracing features
    in the kernel will create a `/sys/kernel/debug/tracing/` directory; for example,
    the function tracing feature as explained in the *Using the kernel function tracing
    system* in [Chapter 2](ch02.html "Chapter 2. The BSP Layer"), *The BSP Layer*.
  prefs: []
  type: TYPE_NORMAL
- en: So before continuing with this recipe, you need to configure the function tracing
    feature in the Linux kernel as explained before.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The static tracing functionality is exposed via the `debugfs` filesystem. The
    functionality offered by the interface includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing events**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see a list of available tracepoints exposed via `sysfs` and ordered
    in subsystem directories with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or in the `available_events` file with the `<subsystem>:<event>` format using
    the following commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Describing events**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each event has a specific printing format that describes the information included
    in the log event, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Enabling and disabling events**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can enable or disable events in the following ways:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By echoing 0 or 1 to the event `enable` file:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'By subsystem directory, which will enable or disable all the tracepoints in
    the directory/subsystem:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'By echoing the unique tracepoint name into the `set_event` file:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note the append operation `>>` is used not to clear events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Events can be disabled by appending an exclamation mark to their names:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Events can also be enabled/disabled by subsystem:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To disable all events:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: You can also enable tracepoints from boot by passing a `trace_event=<comma separated
    event list>` kernel command line-argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Adding events to the tracing buffer**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see the tracepoints appear on the tracing buffer, turn tracing on:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tracepoint events are integrated into the `ftrace` subsystem so that if you
    enable a tracepoint, when a tracer is running, it will show up in the trace. Take
    a look at the following commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tracepoint is inserted using the `TRACE_EVENT` macro. It inserts a callback
    in the kernel source that gets called with the tracepoint parameters as arguments.
    Tracepoints added with the `TRACE_EVENT` macro allow `ftrace` or any other tracer
    to use them. The callback inserts the trace at the calling tracer's ring buffer.
  prefs: []
  type: TYPE_NORMAL
- en: To insert a new tracepoint into the Linux kernel, define a new header file with
    a special format. By default, tracepoint kernel files are located in `include/trace/events`,
    but the kernel has functionality so that the header files can be located in a
    different path. This is useful when defining a tracepoint in a kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the tracepoint, the header file must be included in any file that inserts
    the tracepoint, and a single C file must define `CREATE_TRACE_POINT`. For example,
    to extend the `hello world` Linux kernel module we saw in a previous chapter with
    a tracepoint, add the following code to `meta-bsp-custom/recipes-kernel/hello-world-tracepoint/files/hello_world.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The tracepoint header file in `meta-bsp-custom/recipes-kernel/hello-world-tracepoint/files/trace.h`
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And the module''s `Makefile` file in `meta-bsp-custom/recipes-kernel/hello-world-tracepoint/files/Makefile`
    would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note the highlighted line that includes the current folder in the search path
    for `include` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now build the module externally, as we saw in the *Building external
    kernel modules* recipe in [Chapter 2](ch02.html "Chapter 2. The BSP Layer"), *The
    BSP Layer*. The corresponding Yocto recipe is included in the source that accompanies
    the book. Here is the code for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'After copying the resulting `hello_world.ko` module to the Wandboard''s root
    filesystem, you can load it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now see a new `log_dbg` directory inside `/sys/kernel/debug/tracing/events`,
    which contains a `log_dbg` event tracepoint with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then enable the function tracer on the `hello_timer_callback` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static tracepoints can also be filtered. When an event matches a filter set,
    it is kept, otherwise it is discarded. Events without filters are always kept.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to set a matching filter for the `log_dbg` event inserted in the
    preceding code, you could match either the `a` or `b` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux kernel documentation at [https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/trace/events.txt](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/trace/events.txt)
    for more information regarding static tracepoints events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the TRACE_EVENT() macro* article series by Steven Rostedt at [http://lwn.net/Articles/379903/](http://lwn.net/Articles/379903/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dynamic kernel tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`kprobes` is a kernel debugging facility that allows us to dynamically break
    into almost any kernel function (except `kprobe` itself) to collect debugging
    and profiling information non-disruptively. Some architectures keep an array of
    blacklisted functions, which cannot be probed using `kprobe`, but on ARM the list
    is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: Because `kprobes` can be used to change a function's data and registers, it
    should only be used in development environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of probes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kprobes`: This is the kernel probe which can be inserted into any location
    with more than one `kprobe` added at a single location, if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jprobe`: This is the jumper probe inserted at the entry point of a kernel
    function to provide access to its arguments. Only one `jprobe` may be added at
    a given location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kretprobe`: This is the return probe which triggers on a function return.
    Also, only one `kretprobe` may be added to the same location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are packaged into a kernel module, with the `init` function registering
    the probes and the `exit` function unregistering them.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explain how to use all types of dynamic probes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure the Linux kernel with `kprobes` support, you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `CONFIG_KPROBES` configuration variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `CONFIG_MODULES` and `CONFIG_MODULE_UNLOAD` so that modules can be used
    to register probes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `CONFIG_KALLSYMS` and `CONFIG_KALLSYMS_ALL` (recommended) so that kernel
    symbols can be looked up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optionally, define the `CONFIG_DEBUG_INFO` configuration variable so that probes
    can be inserted in the middle of functions as offsets from the entry point. To
    find the insertion point, you can use `objdump`, as seen in the following excerpt
    for the `do_sys_open` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `kprobes` API is defined in the `kprobes.h` file and includes registration/unregistration
    and enabling/disabling functions for the three types of probes as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, a `kprobe` probe is enabled when registering, except when the `KPROBE_FLAG_DISABLED`
    flag is passed. The following function definitions enable or disable the probe:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The registered `kprobe` probes can be listed through `debugfs`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'They can globally be enabled or disabled with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On registration, the `kprobe` probe places a breakpoint (or jump, if optimized)
    instruction at the start of the probed instruction. When the breakpoint is hit,
    a trap occurs, the registers are saved, and control passes to `kprobes`, which
    calls the pre-handler. It then single steps the breakpoint and calls the post-handler.
    If a fault occurs, the fault handler is called. Handlers can be NULL if desired.
  prefs: []
  type: TYPE_NORMAL
- en: A `kprobe` probe can be inserted either in a function symbol or into an address,
    using the offset field, but not in both.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On occasions, `kprobe` will still be too intrusive to debug certain problems,
    as it slows the functions and may affect scheduling and be problematic when called
    from interrupt context.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to place a `kprobe` probe in the open syscall, we would use the
    `meta-bsp-custom/recipes-kernel/open-kprobe/files/kprobe_open.c` custom module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We compile it with a Yocto recipe, as explained in the *Building external kernel
    modules* recipe in [Chapter 2](ch02.html "Chapter 2. The BSP Layer"), *The BSP
    Layer*. Here is the code for the `meta-bsp-custom/recipes-kernel/open-kprobe/open-kprobe.bb`
    Yocto recipe file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `Makefile` file in `meta-bsp-custom/recipes-kernel/open-kprobe/files/Makefile`
    being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy it to a target running the same kernel it has been linked against, and
    load it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see the handlers printing in the console when a file is opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `jprobe` probe is implemented with a `kprobe`. It sets a breakpoint at the
    given symbol or address (but it must be the first instruction of a function),
    and makes a copy of a portion of the stack. When hit, it then jumps to the handler
    with the same registers and stack as the probed function. The handler must have
    the same argument list and return type as the probed function, and call `jprobe_return()`
    before returning to pass the control back to `kprobes`. Then the original stack
    and CPU state are restored and the probed function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of a `jprobe` in the open syscall in the `meta-bsp-custom/recipes-kernel/open-jprobe/files/jprobe_open.c`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: A `kretprobe` probe sets a `kprobe` at the given symbol or function address
    which when hit, replaces the return address with a trampoline, usually a nop instruction,
    where `kprobe` is registered. When the probed function returns, the `kprobe` probe
    on the trampoline is hit, calling the return handler and setting back the original
    return address before resuming execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of a `kretprobe` probe in the open syscall in the `meta-bsp-custom/recipes-kernel/open-kretprobe/files/kretprobe_open.c`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted `maxactive` variable is the number of reserved storage for return
    addresses in the `kretprobe` probe, and by default, it is the number of CPUs (or
    twice the number of CPUs in preemptive systems with a maximum of 10). If `maxactive`
    is too low, some probes will be missed.
  prefs: []
  type: TYPE_NORMAL
- en: The complete examples, including Yocto recipes, can be found in the source that
    accompanies the book.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The kprobes documentation on the Linux kernel at [https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/kprobes.txt](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/kprobes.txt)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dynamic kernel events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although dynamic tracing is a very useful feature, custom kernel modules is
    not a user-friendly interface. Fortunately, the Linux kernel has been extended
    with the support of `kprobe` events, which allow us to set `kprobes` probes using
    a `debugfs` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make use of this feature, we need to configure our kernel with the `CONFIG_KPROBE_EVENT`
    configuration variable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `debugfs` interface adds probes via the `/sys/kernel/debug/tracing/kprobe_events`
    file. For example, to add a `kprobe` called `example_probe` to the `do_sys_open`
    function, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The probe will print the function''s argument list, according to the function''s
    declaration arguments as seen in the funcion''s definition below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then manage `kprobes` through the sysfs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see all the registered probes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To print the probe format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable the probe use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see the probe output on either the `trace` or `trace_pipe` files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To clear the probe (after disabling it):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To clear all probes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check the number of hit and missed events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the format being as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set a probe we use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain each of the mentioned parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: This is either `p` for `kprobe` or `r` for a return probe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event name`: This is optional and has the format `<group/event>`. If the group
    name is omitted, it defaults to `kprobes`, and if the event name is omitted, it
    is autogenerated based on the symbol. When an event name is given, it adds a directory
    under `/sys/kernel/debug/tracing/events/kprobes/` with the following content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: This is the ID of the probe event'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`: This specifies user filtering rules'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: This is the format of the probe event'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled`: This is used to enable or disable the probe event'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol`: This is either the symbol name plus an optional offset or the memory
    address where the probe is to be inserted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch arguments`: These are optional and represent the information to extract
    with a maximum of 128 arguments. They have the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lets explain each of the mentioned parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name`: This sets the argument name'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset`: This adds an offset to the address argument'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument`: This can be of the following format:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%<register>`: This fetches the specified register. For ARM these are:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`r0 to r10`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fp`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ip`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sp`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`lr`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pc`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`cpsr`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ORIG_r0`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@<address>`: This fetches the memory at the specified kernel address'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@<symbol><offset>`: This fetches the memory at the specified symbol and optional
    offset'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$stack`: This fetches the stack address'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$stack<N>`: This fetches the *n*th entry of the stack'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And for return probes we have:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$retval`: This fetches the return value'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`type`: This one sets the argument type used by `kprobe` to access the memory
    from the following options:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: u8,u16,u32,u64, for unsigned types
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: s8,s16,s32,s64, for signed types
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: string, for null terminated strings
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'bitfield, with the following format:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Current versions of the Linux kernel (from v3.14 onwards) also have support
    for user space probe events (uprobes), with a similar interface to the one for
    the `kprobes` events.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Yocto's tracing and profiling tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracing and profiling tools are used to increase the performance, efficiency,
    and quality of both, applications and systems. User space tracing and profiling
    tools make use of performance counters and static and dynamic tracing functionality
    that the Linux kernel offers, as we have seen in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tracing enables us to log an application's activity so that its behavior can
    be analyzed, optimized, and corrected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yocto offers several tracing tools including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**trace-cmd**: This is a command line interface to the `ftrace` kernel subsystem,
    and **kernelshark**, a graphical interface to trace-cmd.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**perf**: This is a tool that originated in the Linux kernel as a command line
    interface to its performance counter events subsystem. It has since then expanded
    and added several other tracing mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**blktrace**: This is a tool that provides information about the block layer
    input/output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux Trace Toolkit Next Generation** (**LTTng**): This is a tool that allows
    for correlated tracing of the Linux kernel, applications, and libraries. Yocto
    also includes **babeltrace**, a tool to translate the traces into human readable
    logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SystemTap**: This is a tool to dynamically instrument the Linux kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling refers to a group of techniques used to measure an application's consumed
    resources and the time taken to execute an application. The data is then used
    to improve the application's performance and optimize it. Some of the aforementioned
    tools such as perf and SystemTap have evolved to become powerful tracing and profiling
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the enlisted tracing tools, which can also be used for profiling,
    Yocto offers several other profiling tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OProfile**: This is a statistical profiler for Linux that profiles all running
    code with low overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Powertop**: This is a tool used to analyze the system''s power consumption
    and power management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latencytop**: This is a tool used to analyze system latencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sysprof**: This tool is included for Intel architectures on X11 graphical
    images. It does not work on ARM architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These tools can be added to your target image either individually or with the
    `tools-profile` feature. To use the tools, we also need to include debug information
    in our applications. To this extent we should use the `-dbg` version of the packages,
    or better, configure Yocto so that debug information is generated with the `dbg-pkgs`
    image feature. To add both features to your images, add the following to your
    project''s `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The `-sdk` version of target images already adds these features.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from these tools, Yocto also offers the standard monitoring tools available
    on a Linux system. Some examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**htop**: This tool is available in the `meta-oe` layer and provides process
    monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iotop**: This tool is also included in the `meta-oe` layer and provides block
    device I/O statistics by process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**procps**: This one is available in Poky and includes the following tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ps**: This tool is used to list and provide process statuses.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vmstat**: This is used for virtual memory statistics.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uptime**: This is useful for load averages monitoring.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**free**: This is used for memory usage monitoring. Remember to take kernel
    caches into account.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**slabtop**: This one provides memory usage statistics for the kernel slab
    allocator.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sysstat**: This is available in Poky and contains, among others, the following
    tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pidstat**: This is another option for process statistics.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iostat**: This one provides block I/O statistics.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mpstat**: This tool provides multi-processor statistics.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And Yocto also offers the following network tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tcpdump**: This networking tool is included in the `meta-networking` layer
    in `meta-openembedded`. It captures and analyzes network traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**netstat**: This is part of the `net-tools` package in Poky. It provides network
    protocol statistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ss**: This tool is included in the `iproute2` package in Poky. It provides
    sockets statistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing and profiling with perf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The perf Linux tool can instrument the Linux kernel with both hardware and software
    performance counter events as well as static and dynamic kernel trace points.
    For this, it uses the kernel functionality we have seen in previous recipes, providing
    a common interface to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: This tool can be used to debug, troubleshoot, optimize, and measure applications,
    workloads, or the full system, which covers the processor, kernel, and applications.
    Perf is probably the most complete of the tracing and profiling tools available
    for a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The perf source is part of the Linux kernel. To include perf in your system,
    add the following to your `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Perf is also part of the `tools-profile` image feature, so you can also add
    it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Perf is also included in the `-sdk` images.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take the maximum advantage of this tool, we need to have symbols both in
    user space applications and libraries, as well as the Linux kernel. For this,
    we need to avoid stripping binaries by adding the following to the `conf/local.conf`
    configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, adding the debug information of the applications by adding the following
    is recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the debug information is placed in a `.debug` directory in the
    same location as the binary it corresponds to. But perf needs a central location
    to look for all debug information. So, to configure our debug information with
    a structure that perf understands, we also need the following in our `conf/local.conf`
    configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Finally, configure the Linux kernel with the `CONFIG_DEBUG_INFO` configuration
    variable to include debug information, `CONFIG_KALLSYMS` to add debug symbols
    into the kernel, and `CONFIG_FRAME_POINTER` to be able to see complete stack traces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in the *Using the kernel's performance counters* recipe, we will also
    need to pass `maxcpus=1` (or `maxcpus=0` to disable SMP) to the Linux kernel in
    order to use the i.MX6 PMU, due to the sharing of the PMU interrupt between all
    cores. Also, in order to use the PMU on i.MX6 processors, the SoC needs to receive
    at least 4 JTAG clock cycles after power on reset. This is documented in the errata
    number *ERR006259*.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the `meta-fsl-arm` layer for Yocto 1.7 disables some
    of perf features. To be able to follow the upcoming examples, remove the following
    line from the `meta-fsl-arm` layer''s `/opt/yocto/fsl-community-bsp/sources/meta-fsl-arm/conf/machine/include/imx-base.inc`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Newer Yocto releases will include this by default.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perf can be used to provide a default set of event statistics for a particular
    workload with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, a single ping will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: If we are only interested in a particular set of events, we can specify the
    events we want to output information from using the `-e` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also sample data and store it so that it can be later analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Better still, we can add stack backtraces with the `-g` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be stored on a `perf.data` file which we would then analyze
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Its output can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The functions order may be customized with the `--sort` option.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how perf has resolved both user space and kernel symbols. Perf will
    read kernel symbols from the Linux kernel ELF file under `/boot`. If it is stored
    in a non-standard location, we can optionally pass its location with a `-k` option.
    If it does not find it, it will fall back to using `/proc/kallsyms`, where the
    Linux kernel exports the kernel symbols to user space when built with the `CONFIG_KALLSYMS`
    configuration variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a perf report is not showing kernel symbols, it may be because the ELF file
    does not match the running kernel. You can try to rename it and see if using `/proc/kallsyms`
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Also, to obtain complete backtraces, applications need to be compiled with debug
    optimization by using the `DEBUG_BUILD` configuration variable, as we saw earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Perf uses a **newt** interface (TUI) that needs the `expand` utility,
    part of coreutils. If coreutils is not included in your root filesystem, you can
    ask for a text-only output with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see all the functions called with the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overhead**: This represents the percentage of the sampling data corresponding
    to that function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command**: This refers to the name of the command passed to the perf record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared Object**: This represents the ELF image name (`kernel.kallsyms` will
    appear for the kernel).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privilege Level**: It has the following modes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for user mode
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k` for kernel mode'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g` for virtualized guest kernel'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u` for virtualized host user space'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H` for hypervisor'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Symbol**: This is the resolved symbol name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the TUI interface, we can press enter on a function name to access a sub-menu,
    which will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this we can, for example, annotate the code as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5186OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If using text mode, we can also get annotated output with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Perf can also do system-wide profiling instead of focusing on a specific workload.
    For example, to monitor the system for five seconds, we would execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to sample the system for five seconds, we will execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: When using system-wide measurements the command is just used as measurement
    duration. For this, the `sleep` command will not consume extra cycles.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The perf tool provides statistics for both user and kernel events occurring
    in the system. It can instrument in two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event counting** (`perf stat`): This counts events in kernel context and
    prints statistics at the end. It has the least overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event sampling** (`perf record`): This writes the gathered data to a file
    at a given sampling period. The data can then be read as profiling (`perf report`)
    or trace data (`perf script`). Gathering data to a file can be resource intensive
    and the file can quickly grow in size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, perf counts events for all the threads in the given command, including
    child processes, until the command finishes or is interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generic way to run perf is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`e`: This specifies an event list to use instead of the default set of events.
    An event filter can also be specified, with its syntax explained in the Linux
    kernel source documentation at `Documentation/trace/events.txt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`o`: This specifies the output file name, by default `perf.data`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--`: This is used as a separator when the command needs arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can also start or sample a running process by passing the `-p <pid>` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can obtain a list of all available events by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Or on a specific subsystem with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also access raw PMU events directly by using the `r<event>` event,
    for example, to read the data cache misses on an ARM core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Unless specified, the perf record will sample hardware events at an average
    rate of 1000 Hz, but the rate can be modified with the `-F <freq>` argument. Tracepoints
    will be counted on each occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: Reading tracing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perf records samples and stores tracing data in a file. The raw timestamped
    trace data can be seen with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the command we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading tracing data](img/5186OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have seen, we can use a perf report to look at the sampled data formatted
    for profiling analysis, but we can also generate python scripts that we can then
    modify to change the way the data is presented, by running the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a `perf-script.py` script that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading tracing data](img/5186OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To run the script, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to install the `perf-python` package in our target image. You can
    add this to your image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Now you will get a similar output as with the `perf` script earlier. But now
    you can modify the print statements in the python code to post process the sampled
    data to your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perf can use dynamic events to extend the event list to any location where `kprobe`
    can be placed. For this, configure the kernel for `kprobe` and `uprobe` support
    (if available), as seen in the *Using dynamic kernel events* recipe earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a probe point in a specific function execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use it in all perf tools, such as profiling the download of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can view the profiling data executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5186OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may need to configure DNS servers in your target for the `wget` command
    as seen in the preceding code to work. To use Google''s public DNS servers, you
    can add the following to your `/etc/resolv.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then delete the probe with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Profile charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'System behavior can be visualized using a perf timechart. To gather data, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'And to turn it into an `svg` file use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Using perf as strace substitute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perf can be used as an alternative to strace but with much less overhead with
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the Yocto recipe for perf does not currently build this support. We
    can see the missing library in the compilation log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A list of the available ARM i.MX6 PMU events at [http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0388f/BEHGGDJC.html](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0388f/BEHGGDJC.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An extended tutorial in the use of perf at [https://perf.wiki.kernel.org/index.php/Tutorial](https://perf.wiki.kernel.org/index.php/Tutorial)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some advanced examples at Brendan Gregg's perf site [http://www.brendangregg.com/perf.html](http://www.brendangregg.com/perf.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SystemTap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SystemTap is a GPLv2 licensed system wide tool that allows you to gather tracing
    and profiling data from a running Linux system. The user writes a `systemtap`
    script, which is then compiled into a Linux kernel module linked against the same
    kernel source it is going to run under.
  prefs: []
  type: TYPE_NORMAL
- en: The script sets events and handlers, which are called by the kernel module on
    the specified events triggering. For this, it uses the `kprobes` and `uprobes`
    (if available) interfaces in the kernel, as we saw in the *Using dynamic kernel
    events* recipe before.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use SystemTap, we need to add it to our target image either by adding it
    specifically, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: We can also add it by using the `tools-profile` image feature, or an `-sdk`
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need an SSH server running on the target. This is already available
    on the `-sdk` image; otherwise we can add one to our image with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: We will also need to compile the kernel with the `CONFIG_DEBUG_INFO` configuration
    variable to include debug information, as well as performance events counters
    and `kprobes` as explained in previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use systemtap on a Yocto system, we need to run the crosstap utility in
    the host, passing it the `systemtap` script to run. For example, to run the `sys_open.stp`
    sample script, we can run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We would run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Yocto does not support running scripts on the target, as that would require
    building modules on the target, and that is untested.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SystemTap scripts are written with its own C/awk like language. They enable
    us to trace events by instrumenting the kernel code at different locations, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: Beginning and end of SystemTap sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entry, return, or specific offset of kernel and user space functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timer events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance hardware counter events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They also enable us to extract data, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread, process, or user ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel and user space backtraces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, SystemTap also offers the ability to analyze the gathered data,
    and for different probes to work together. SystemTap includes a wide selection
    of example scripts and a framework for creating script libraries that can be shared.
    These tapsets are installed by default and can be extended by the user's own scripts.
    When a symbol is not defined in a script, SystemTap will search the tapset library
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tapset reference at [https://sourceware.org/systemtap/tapsets/](https://sourceware.org/systemtap/tapsets/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All examples included in the source at [https://sourceware.org/systemtap/examples/](https://sourceware.org/systemtap/examples/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to the systemtap scripting language at [https://sourceware.org/systemtap/langref/](https://sourceware.org/systemtap/langref/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OProfile is a statistical profiler released under the GNU GPL license. The version
    included in the Yocto 1.7 release is a system-wide profiler, which uses the legacy
    profiling mode with a kernel module to sample hardware performance counters data
    and a user space daemon to write them to a file. More recent Yocto releases use
    newer versions that use the performance events subsystem, which we introduced
    in the *Using the kernel's performance counters* recipe, so they are able to profile
    processes and workloads as well.
  prefs: []
  type: TYPE_NORMAL
- en: The version included in Yocto 1.7 consists of a kernel module, a user space
    daemon to collect sample data, and several profiling tools to analyze captured
    data.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will focus on the OProfile version included in the 1.7 Yocto release.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To include OProfile in your system, add the following to your `conf/local.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'OProfile is also part of the `tools-profile` image feature, so you can also
    add it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: OProfile is also included in the `-sdk` images.
  prefs: []
  type: TYPE_NORMAL
- en: 'OProfile does not need debugging symbols in applications unless annotated results
    are needed. For callgraph analysis, the binaries must have stack frames information
    so they should be build with debug optimization by setting the `DEBUG_BUILD` variable
    in the `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: To build the kernel driver, configure the Linux kernel with profiling support,
    `CONFIG_PROFILING`, and the `CONFIG_OPROFILE` configuration variable to build
    the OProfile module.
  prefs: []
  type: TYPE_NORMAL
- en: 'OProfile uses the hardware counters support in the SoC, but it can also work
    on a timer-based mode. To work with the timer-based model, you need to pass the
    `oprofile.timer=1` kernel argument to the Linux kernel, or load the OProfile module
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because OProfile relies on the i.MX6 performance counters, we still need to
    boot with `maxcpus=1` for it to work. This restricts the profiling in i.MX6 SoCs
    to one core.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To profile a single ping, start a profiling session as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the workload to profile, for example, a single ping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'And stop collecting data with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will get a parsing error if the kernel image name contains special characters.
    To avoid it, we can use a symbolic link as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if you see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to change the reset count of the `CPU_CYCLES` event to that minimum,
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then view the collected data with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'And an excerpt for output with callgraph and symbols is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OProfile daemon records data continuously, accumulating data from multiple
    runs. Use the `--start` and `--stop` options to start and stop accumulating new
    data. If you want to start collecting data from scratch, use the `--reset` option
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Before running a profiling session, you need to configure the OProfile daemon
    to run with or without kernel profiling. Specifying the kernel profiling option
    is the only compulsory configuration variable.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure the OProfile daemon, stop it first (if running) with the
    `--shutdown` option. The `--stop` option will only stop data collection, but will
    not kill the daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure OProfile without kernel profiling you execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'And to configure the kernel profiling, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these will configure the daemon and load the OProfile kernel module,
    if needed. Some common options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--separate=<type>`: This controls how the profiled data is separated into
    different files, with type being:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**none**: This does not separate profiles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**library**: This separates shared libraries profiles per application. The
    sample file name will include the name of library and the executable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kernel**: This adds kernel profiling.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**thread**: This adds per thread profiles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cpu**: This adds per CPU profiles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**all**: This does all of the above.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--callgrah=<depth>`: This logs called and calling functions as well as the
    time spent in functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the daemon is configured, you can start a profiling session.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the current configuration, you execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The sampled data is stored in the `/var/lib/oprofile/samples/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then analyze the collected data with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Some useful options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-c`: This shows callgraph information, if available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-g`: This shows the source file and line number for each symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: This shows full object paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o`: This provides the output to the specified file instead of `stdout`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OProfile mounts a pseudo filesystem in `/dev/oprofile` which is used to report
    and receive configuration from user space. It also contains a character device
    node used to pass sampled data from the kernel module to the user space daemon.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yocto includes a graphical user interface for OProfile that can be run in the
    host. However, it is not part of Poky and needs to be downloaded and installed
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the `oprofileui` repository at [https://git.yoctoproject.org/cgit/cgit.cgi/oprofileui/](https://git.yoctoproject.org/cgit/cgit.cgi/oprofileui/)
    for a README with instructions, or to the *Yocto Project's Profiling and Tracing
    Manual* at [http://www.yoctoproject.org/docs/1.7.1/profile-manual/profile-manual.html](http://www.yoctoproject.org/docs/1.7.1/profile-manual/profile-manual.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project's home page for more information about OProfile at [http://oprofile.sourceforge.net/news/](http://oprofile.sourceforge.net/news/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LTTng
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LTTng is a set of dual licensed GPLv2 and LGPL tracing and profiling tools for
    both applications and kernel. It produces binary trace files in the production
    optimized **Compact Trace Format** (**CTF**), which can then be analyzed by tools,
    such as **babeltrace**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To include the different LTTng tools in your system, add the following to your
    `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'They are also part of the `tools-profile` image feature, so you can also add
    them with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: These are also included in the `-sdk` images.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, Yocto 1.7 excludes `lttng-modules` from the `tools-profile`
    feature and `sdk` images for ARM; so they have to be added manually.
  prefs: []
  type: TYPE_NORMAL
- en: The LTTng command-line tool is the main user interface to LTTng. It can be used
    to trace both the Linux kernel—using the kernel tracing interfaces we have seen
    in previous recipes—as well as instrumented user space applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A kernel profiling session workflow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a profiling session with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the events you want to trace with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can get a list of the available kernel events with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This corresponds to the static tracepoint events available in the Linux kernel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you are ready to start sampling profiling data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the workload you want to profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the command finishes or is interrupted, stop the gathering of profiling
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, destroy the profiling session using the following command. Note that
    this keeps the tracing data and only destroys the session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To view the profiling data so that it is readable by humans, start `babeltrace`
    with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The profiling data can also be copied to the host to be analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: User space applications and libraries need to be instrumented so that they can
    be profiled. This is done by linking them with the `liblttng-ust` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications can then make use of the `tracef` function call, which has the
    same format as `printf()`, to output traces. For example, to instrument the example
    `helloworld.c` application we saw in previous chapters, modify the source in `meta-custom/recipes-example/helloworld/helloworld-1.0/helloworld.c`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify its Yocto recipe in `meta-custom/recipes-example/helloworld/helloworld_1.0.bb`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Then build the package, copy it to the target, and start a profiling session
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a profiling session by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the events you want to profile—in this case, all the user space events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start to gather profiling data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the workload—in this case, the instrumented hello world example program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once it finishes, stop gathering data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Without destroying the session, you can start `babeltrace` executing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you can destroy the profiling session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kernel tracing is done using the tracing functionalities available in the Linux
    kernel, as we have seen in previous recipes. For the following examples to work,
    the Linux kernel must be configured appropriately as seen in the corresponding
    recipes earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'LTTng provides a common user interface to control some of the kernel tracing
    features we saw previously, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static** **tracepoint events**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can enable specific static tracepoint events with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can enable all tracepoints with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also enable all syscalls with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can enable all tracepoints and syscalls with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Dynamic** **tracepoint events**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also add dynamic tracepoints with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also add them with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Function** **tracing**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also use the function tracing kernel functionality with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Performance** **counter events:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the hardware performance counters, for example for the CPU cycles, with
    the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `add-context --help` option to list further context options and perf
    counters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Extending application profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Further applications tracing flexibility can be achieved with the `tracepoint()`
    call by writing a template file (`.tp`), and using the `lttng-gen-tp` script along
    with the source file. This generates an object file that can then be linked to
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, Yocto has no standard way to cross-instrument user
    space applications, but it can be done natively using an `-sdk` image, or adding
    the following image features to the `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, define a tracepoint `hw.tp` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass this through the `lttng-gen-tp` tool to obtain `hw.c`, `hw.h`, and `hw.o`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the `lttng-gen-tp` tool is not installed with the `lttng-ust` package,
    but with the `lttng-ust-bin` package. This has to be added to be the target image,
    for example, by adding the following in your `conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now add the `hw.h` header file to your helloworld application that
    is in the `helloworld.c` file and use the `tracepoint()` call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Now link your application with the native `gcc` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that in order to use `gcc` on the target, we need to build one of the
    `-sdk` images, or add some extra features to our image, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'To profile your application, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a profiling session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the specific event you want to profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start gathering profiling data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the workload to profile—in this case the helloworld application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Stop gathering data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now start `babeltrace` with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, destroy the profiling session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also use the Trace Compass application or Eclipse plugin to analyze
    the traces in the host by visiting [http://projects.eclipse.org/projects/tools.tracecompass/downloads](http://projects.eclipse.org/projects/tools.tracecompass/downloads).
    A stable release was not yet available at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Details on using LTTng at [http://lttng.org/docs/](http://lttng.org/docs/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about the instrumenting of C applications at [http://lttng.org/docs/#doc-c-application](http://lttng.org/docs/#doc-c-application)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `tracepoint()` example in the `lttng-ust` source at [http://git.lttng.org/?p=lttng-ust.git;a=tree;f=tests/hello;h=4ae310caf62a8321a253fa84a04982edab52829c;hb=HEAD](http://git.lttng.org/?p=lttng-ust.git;a=tree;f=tests/hello;h=4ae310caf62a8321a253fa84a04982edab52829c;hb=HEAD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blktrace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few tools available to perform block devices I/O monitoring and
    profiling.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with `iotop` which we mentioned in the *Exploring Yocto's tracing and
    profiling tools* recipe, which gives a general idea of the throughput on a system
    and a particular process. Or `iostat`, which provides many more statistics regarding
    CPU usage and device utilization, but does not provide per process details. And
    finally `blktrace` that is a GPLv2 licensed tool which monitors specific block
    devices I/O at a low level, and can also compute **I/O operations per second**
    (**IOPS**).
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explain how to use `blktrace` to trace block devices and `blkparse`,
    to convert the traces into human readable format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use `blktrace` and `blkparse`, you can add them to the target image by adding
    it specifically, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Alternately, you can also use the `tools-profile` image feature, or an `-sdk`
    image.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to configure the Linux kernel with `CONFIG_FTRACE` and `CONFIG_BLK_DEV_IO_TRACE`
    to be able to trace block I/O actions.
  prefs: []
  type: TYPE_NORMAL
- en: When profiling a block device, it is important to minimize the effect of the
    tracing on the results; for example, not storing the tracing data on the block
    device being profiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Running the trace from a different block device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the trace from a RAM-based `tmpfs` device (such as `/var/volatile`).
    Running from a memory-based device will limit the amount of tracing data that
    can be stored though.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the trace from a network-mounted filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the trace over the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the filesystem being used in the block device to profile is an important
    factor, as filesystem features such as journalism will distort the I/O statistics.
    Flash filesystems, even if they are presented to user space as block devices,
    cannot be profiled with `blktrace`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine you want to profile the I/O for the microSD card device on the
    Wandboard. By booting the system from the network, as seen in the *Configuring
    network booting for a development setup* recipe from [Chapter 1](ch01.html "Chapter 1. The
    Build System"), *The Build System*, you can avoid unnecessary access to the device
    by the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will mount as an ext2 partition to avoid journalism, but
    other tweaks may be needed for effective profiling of a specific workload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'The workflow to profile a specific workload is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start `blktrace` to gather tracing data on the `/dev/mmcblk0` device with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the workload to profile, for example, the creation of a 10 KB file. Open
    an SSH connection to the target and execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Stop the profiling on the console with *Ctrl* + *C*. This will create a file
    in the same directory called `mmcblk0.blktrace.0` . You will see the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Some useful options for `blktrace` are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`-w`: This is used to run only for the specified number of seconds'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a`: This adds a mask to the current file, where the masks can be:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`barrier`: This refers to the barrier attribute'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complete`: This refers to an operation completed by the driver'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs`: These are the FS requests'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`issue`: This option refers to operations issued to the driver'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pc`: This refers to packet command events'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queue`: This option represents queue operations'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read`: This refers to read traces'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requeue`: This is used for requeue operations'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`: This represents synchronous attributes'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write`: This refers to write traces'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have gathered the tracing data, you can process it with `blkparse`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides an `stdout` output for all the gathered data, and a final summary,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The output format from `blkparse` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'This corresponds to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'The columns correspond to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A`: I/O remapped to a different device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`B`: I/O bounced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C`: I/O completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`: I/O issued to driver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F`: I/O front merged with request on queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`G`: Get request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I`: I/O inserted into request queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: I/O back merged with request on queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`P`: Plug request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Q`: I/O handled by request queue code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S`: Sleep request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T`: Unplug due to timeout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`U`: Unplug request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X`: Split'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The RWBS field corresponds to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R`: Read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W`: Write'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`B`: Barrier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S`: Synchronous'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another way of tracing non-disruptively is using live monitoring, that is,
    piping the output of `blktrace` to `blkparse` directly without writing anything
    to disk, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be done in just one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `blktrace` command can also send the tracing data over the network so that
    it is stored on a different device.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, start `blktrace` on the target system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'And on another device, run another instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to the target, you can now execute the specific workload you want to trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Once it finishes, interrupt the remote `blktrace` with *Ctrl* + *C*. A summary
    will be printed at both the target and the host.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run `blkparse` to process the gathered data.
  prefs: []
  type: TYPE_NORMAL
