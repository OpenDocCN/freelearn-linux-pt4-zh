- en: Iterating with Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can perform arithmetic operations and tests and our scripts have more
    control. Sometimes, you will find that you need to perform some tasks repeatedly,
    such as going through log file entries and performing an action, or maybe running
    a piece of code continuously. We are busy people who have better things to do
    than repeat a task 100 times or more; loops are our friends.
  prefs: []
  type: TYPE_NORMAL
- en: Looping structures are the lifeblood of scripts. These loops are workhorse engines
    that can iterate many times, repeating the same task reliably and consistently.
    Imagine having 100,000 lines of text within a CSV file that has to be checked
    for incorrect entries. A script can do this easily and accurately once developed
    but, in the case of a human, the reliability factor and accuracy will fail very
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s see how we can save our time and sanity by covering the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced `for` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The internal field separator (IFS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting directories and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C-style for loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting loop output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while` loops and `until` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading input from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating operator menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All our looping controls are simple and we will begin by looking at `for` loops.
    The word `for` is a keyword in bash and in terms of its working, it is similar
    to `if`. We can use the command type to verify this, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As a reserved shell keyword, we can use a `for` loop both in scripts and directly
    at the command line. In this way, we can utilize loops within and without the
    scripts, optimizing the use of the command line. A simple `for` loop is shown
    in the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `useradd` command is used to create users and the `chpasswd` command is
    used to update passwords in batch mode.
  prefs: []
  type: TYPE_NORMAL
- en: Within a `for` loop, we read from the list on the right to populate the variable
    parameter on the left; in this case, we will read from the list containing `bob`
    and `joe` into the parameter variable `u`. Each item from the list is inserted
    into the variable, one item at a time. In this way, as long as there are items
    to be processed in the list, the loop will execute until the list is exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practically, for us, the execution of this loop means that we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the user `bob`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the password for `bob`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expire the password so it will need to be reset on the first login for the user
    `bob`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then loop back and repeat the process for the user `joe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the preceding example in the following screenshot. After having
    gained root access through `sudo -i`, we proceeded to run the loop and create
    the users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee837095-5d9f-436e-85d1-0df82a9a547b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The list that is read in the `for` loop can be generated dynamically or statically,
    as shown in the previous example. To create dynamic lists, we could use various
    globbing techniques to populate the list. As an example, to work with all files
    in a directory, we could use `*`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When a list is generated, such as with file globbing, we should quote the expansion
    of the variable parameter. Without the quotes, it is possible that a space will
    be included that will cause the command to fail. This is what we have seen here
    in the `stat` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, we isolate the filenames that begin with `ba*`.
    We then use the `stat` command to print the inode metadata. The code and output
    are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abe83602-8fa0-4d8f-a709-21f360982abf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This list can also be generated from the output of another command or a pipeline
    of commands. For example, if we need to print the current working directory of
    all logged-in users, we could try something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we can see that the choice of name for the parameter
    is down to us; we are not limited to a single character and we can use the `$user`
    name in this example. By using lowercase, we will not overwrite the system variable
    `$USER`. The following screenshot demonstrates the loop and the subsequent output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc3f2493-936b-4b21-b28b-c51e60b06d45.png)'
  prefs: []
  type: TYPE_IMG
- en: The `lsof` command will list open files; we can search for the files opened
    by each user in turn and with the `bash` command as the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the scripts that we have created so far, we can create a new script
    called `hello9.sh`. If we copy the `$HOME/bin/hello2.sh` script to the new script,
    we can edit it to make use of a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The loop is used to iterate through each command-line argument supplied and
    greet each user individually. When we execute the script, we can see that we can
    now display the `Hello` message for each user. This is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d44e8d04-45ea-4fca-96d0-4e23e1390513.png)'
  prefs: []
  type: TYPE_IMG
- en: Although what we have seen here is still relatively trivial, we should now realize
    a little of what we can do with scripts and loops. The arguments of this script
    can be the usernames that we have already used or anything else. If we stick with
    the usernames, then it will be very easy to create user accounts and set passwords,
    as we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous examples, we used the `for` loop to iterate over simple values
    where each value has no space.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, if your values contain a space, you should use double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8001ef9d-760d-43c8-aa6a-e8796da1bcc2.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, each value is printed as expected thanks to double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: This example contains values in one line and we quote the values because they
    have spaces and commas. What if the values were on multiple lines, as in a file?
  prefs: []
  type: TYPE_NORMAL
- en: What if the separator between the values we want to iterate over is something
    other than a space such as a comma or a semicolon?
  prefs: []
  type: TYPE_NORMAL
- en: Here comes the IFS.
  prefs: []
  type: TYPE_NORMAL
- en: The IFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the IFS variable has the value of one of (space, newline, or tab).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you have a file like the following and you want to iterate over
    its lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write the `for` loop that will iterate over these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the result, it''s something that we don''t need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcbd11c3-188d-4dc7-97da-4bfaf9629138.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the first separator the shell found is the space, the shell treats every
    word as a field, but we need every line to be printed as a field.
  prefs: []
  type: TYPE_NORMAL
- en: Here we need to change the IFS variable to be newline instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our script to iterate over lines correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/35a6ba72-aa82-42b5-9213-5fc8b6a2f302.png)'
  prefs: []
  type: TYPE_IMG
- en: We changed the IFS variable to newline and it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the dollar sign in the IFS definition in the preceding section, `IFS=$"\n"`.
    By default, bash doesn't interpret escape characters such as `\r`, `\n`, and `\t`.
    So, in our example, it will be treated as an `n` character, so to interpret escape
    characters, you have to use a dollar sign (`$`) before it to make it work properly.
  prefs: []
  type: TYPE_NORMAL
- en: But if your IFS is a normal character, you don't have to use the dollar sign
    (`$`) at all.
  prefs: []
  type: TYPE_NORMAL
- en: Counting directories and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use a simple `for` loop to iterate over folder content and use an `if`
    statement to check whether the path is a directory or a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/812eacd0-590e-4c82-aea1-ff797f45ea55.png)'
  prefs: []
  type: TYPE_IMG
- en: This is pretty straightforward script. We iterate over directory content and
    then we use an `if` statement to check whether the path is a directory or a file.
    Finally, we print beside each path whether it's a file or a directory.
  prefs: []
  type: TYPE_NORMAL
- en: We used quotes for the path variable because the file could contain a space.
  prefs: []
  type: TYPE_NORMAL
- en: C-style for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a C language background, you will be happy to know that you can
    write your `for` loops in C-style. This feature was taken from KornShell. The
    shell `for` loop can be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is easy for C developers to use this syntax in `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The choice is yours; you have a lot of syntax styles for the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Nested loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nested loops means loops inside loops. Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/16709454-c84c-41f8-8c8a-99ed1cea62f3.png)'
  prefs: []
  type: TYPE_IMG
- en: The first loop hits first, then the second loop, and this happens three times.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting loop output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can redirect the loop output to a file using the `done` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If there is no file, it will be created and filled with the loop output.
  prefs: []
  type: TYPE_NORMAL
- en: This redirection is helpful when you don't need to show the loop output on the
    screen and save it to a file instead.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having entered our loop, we may need to either exit the loop prematurely or
    perhaps exclude certain items from processing. If we want to process only directories
    in a listing, rather than every file of any type, then to implement this, we have
    loop control keywords, such as `break` and `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: The `break` keyword is used to exit the loop, processing no more entries, whereas
    the `continue` keyword is used to stop the processing of the current entry in
    the loop and resume the processing with the next entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we only want to process directories, we could implement a test within
    the loop and determine the file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Within the loop, we want to set permissions, including the SGID and sticky bits,
    but for the directories only. The `*` search will return all files; the first
    statement within the loop will ensure that we only process directories. If the
    test is done for the current loop, the target fails the test and is not a directory;
    the `continue` keyword retrieves the next loop-list item. If the `test` returns
    `true` and we are working with a directory, then we will process the subsequent
    statements and execute the `chmod` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to run the loop until we find a directory and then exit the loop,
    we can adjust the code so that we can iterate though each file. If the file is
    a directory, then we exit the loop with the `break` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the following screenshot, we can see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac021128-1378-420d-b66d-4ee42b77ad14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By working with the same theme, we can print each directory found in the listing
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve a result by processing the loop item only if it is a directory
    and within the loop. We can work with regular files only using the `if` test.
    In this example, we append the directory name to the `dir_name` variable. Once
    we exit the loop, we print the complete list of directories. We can see this in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd0b1ce9-b6da-4e7d-9773-cc2720df8887.png)'
  prefs: []
  type: TYPE_IMG
- en: Using these examples and your own ideas, you should now be able to see how you
    can control loops using the `continue` and `break` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: while loops and until loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the `for` loop, we iterate through a list; it's either the one that
    we create or the one that is dynamically generated. Using the `while` or `until`
    loops, we loop based on the fact that the condition becomes either `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `while` loop loops while the condition is true and, conversely, an `until`
    loop will loop while the condition is false. The following command will count
    from 10 through to zero, each iteration of the loop printing the variable and
    then reducing the value by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the output of this command in the following screenshot, thus confirming
    the countdown to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a3bdb9b-ca07-42d1-9b91-88bc9fa97de0.png)'
  prefs: []
  type: TYPE_IMG
- en: The use of the `\c` escape sequence used here allows the suppression of the
    line feed normally used with `echo`. In this way, we can keep the countdown on
    the single line of output. I think you will agree that it's a nice effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functionality of this loop can be gained using the `until` loop; just a
    quick rethink of the logic is required, as we will want to loop until the condition
    becomes true. Generally, it is a personal choice and the way the logic works best
    for you about which loop to use. The following example shows the loop written
    with the `until` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Reading input from files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it may seem that these loops can do a little more than just count down
    numbers. We may want to read data in from a text file and process each line. The
    shell built-in `read` command that we saw earlier in this book can be used to
    read a file line by line. In this way, we can use a loop to process each line
    of a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate some of these functionalities, we will use a file that contains
    the server addresses. These could be hostnames or IP addresses. In the following
    example, we will make use of the IP addresses of Google DNS servers. The following
    command shows the contents of the `servers.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `read` command in the condition of the `while` loop, we can loop
    as long as we have more lines to read from the file. We specify the input file
    directly after the `done` keyword. For each line that we read from the file, we
    can test whether the server is up with the `ping` command, and, if the server
    is responding, we append it to a list of available servers. This list is printed
    once the loop closes. In the following example, we can see that we begin to add
    in as many elements of scripting as we have covered in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the operation in the following screenshot, which captures the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/224a988c-ebdd-47c4-9855-3dff9e6b286c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using this kind of loop, we can start to build extremely practical scripts
    to process information either fed from the command line or from scripts. It will
    be very easy to replace the filename that we read with `$1`, representing a positional
    parameter passed into the script. Let''s return to the `ping_server.sh` script
    and adjust it to accept the input parameter. We can copy the script to the new
    `$HOME/bin/ping_server_from_file.sh` file. Within the script, we first test whether
    the input parameter is a file. We then create an output file with a tile that
    includes the date. As we enter the loop, we append available servers to this file
    and list the file at the end of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute the script now in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the script execution should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b989b3bb-08da-48f6-9eaf-4a64c07ca5d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating operator menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can provide a menu to the Linux operators who need limited functionality
    from the shell and do not want to learn the details of command-line use. We can
    use their login script to launch a menu for them. This menu will provide a list
    of command selections to choose from. The menu will loop until the user chooses
    to exit from the menu. We can create a new `$HOME/bin/menu.sh` script; the basis
    of the menu loop will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The loop we have created here is infinite. The `true` command will always return
    true and loop continuously; however, we can provide a loop control mechanism to
    allow the user to leave the menu. To start building the structure of the menu,
    we will need to echo some text within the loop asking the user for their choice
    of command. We will clear the screen before the menu is loaded each time and an
    additional read prompt will appear after the execution of the desired command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows the user to read the output from the command before the screen
    is cleared and the menu is reloaded. The script will look like the following code
    at this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you execute the script at this stage, there will be no mechanism to leave
    the script. We have not added any code to the menu selections; however, you can
    test functionality and exit using the *Ctrl* + *C *keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, the menu should look similar to the output shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb4a5ad4-33a0-4f23-8332-ba769cc4fda6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To build the code behind the menu selection, we will implement a `case` statement.
    This will be added in between the two `read` commands, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the three options that we have added to the `case` statement, `a`,
    `b`, and `c`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Option `a`: This runs the `tar` command to back up the scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Option `b`: This runs the `cal` command to display the current month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Option `c`: This exits the script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To ensure that the user is logged out when exiting from their login script,
    we will run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exec` command is used to ensure that the shell is left after the `menu.sh`
    file is complete. In this way, the user never needs to experience the Linux shell.
    The complete script is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7c72855-f753-4ef5-8d5b-c952af292bfe.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have begun to make progress within this chapter. We have been able to join
    many of the elements that we have previously used into cohesive and functional
    scripts. Although the focus of this chapter has been on loops, we have used command-line
    lists, `if` statements, `case` statements, and arithmetic calculations.
  prefs: []
  type: TYPE_NORMAL
- en: We opened this chapter by describing loops as the workhorse of our scripts and
    we have been able to demonstrate this with `for`, `while`, and `until` loops.
    The `for` loop is used to iterate through elements of a list. The list can be
    either static or dynamic; with an emphasis on dynamic lists, we showed how simply
    these are created through file globbing or command expansion.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we saw how to iterate over complex values and how to set the IFS to iterate
    over fields correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to write nested loops and how to redirect loop output to files.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` and `until` loops are controlled using conditions. The `while` loop
    will loop while the supplied condition is true. The `until` loop will loop until
    the supplied condition returns true or while it returns false. The `continue`
    and `break` keywords are specific to loops and, using them along with `exit`,
    we can control the loop flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at modularizing scripts using functions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How many lines will be printed on screen from the following script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How many lines will be printed on the screen from the following script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with the following script? And how can you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How many lines will be printed on the screen from the following script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/abs/html/internalvariables.html](http://tldp.org/LDP/abs/html/internalvariables.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_03.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_05.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_05.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
