<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Acting Like a Typewriter and File Explorer</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"> In this chapter, we will introduce the following:</p>
<ul class="calibre13">
<li class="calibre14">Basic searching for strings and files</li>
<li class="calibre14">Using wildcards and regexes</li>
<li class="calibre14">Math and calculations in script</li>
<li class="calibre14">Striping/altering/sorting/deleting/searching strings with Bash only</li>
<li class="calibre14">Using SED and AWK to remove/replace substrings</li>
<li class="calibre14">Formatting your data/output using echo and printf</li>
<li class="calibre14">Readying your script for different languages with internationalization</li>
<li class="calibre14">Calculating statistics and reducing duplicates based on file contents</li>
<li class="calibre14">Using file attributes with conditional logic</li>
<li class="calibre14">Reading delimited data and altered output format</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Hopefully, the previous Bash crash course chapter provided more than a hint of the utility and power of Bash. On the other hand, this chapter introduces several <em class="calibre18">bolt-on</em> technologies to make Bash even more extensive when searching for items and text, or automating file explorer/file system operations. </p>
<p class="mce-root">By itself, Bash is merely a powerful scripting language, but much of Bash's flexibility comes from being able to "glue" other technologies (tools or languages) together to make the output more useful. In other words, Bash is a base platform similar to how some auto/car lovers choose a particular platform before making their modifications. Will a modified car do everything, even with enhancements? Certainly not, but it can make it more powerful or useful in specific cases, and at least provides four wheels for movement.</p>
<p class="mce-root">Not only do common scripts contain a series of commands for automation, they often include <strong class="calibre6">logic</strong> to modify strings such as the following:</p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre11">Removing trailing characters</span></li>
<li class="calibre14">Replacing sections of words (substrings)</li>
<li class="calibre14">Searching for strings in files</li>
<li class="calibre14">Finding files</li>
<li class="calibre14">Testing file types (directory, file, empty, and so on)</li>
<li class="calibre14">Performing small calculations</li>
<li class="calibre14">Limiting the scope of searches or data (filtering)</li>
<li class="calibre14">Modifying the contents of variables (strings inside of string variables)</li>
</ul>
<p class="mce-root">This logic that modifies, limits, and even replaces input/output data can be very powerful when you need to execute broad searches for a specific string or when you have copious amounts of data. Terminals chock; full of output or massive data files can be very daunting to explore! </p>
<p class="mce-root">However, there is one very important concept that still needs to be discussed, and that is <strong class="calibre6">recursive</strong> functionality. Recursive functionality can apply to script functions, logic, and even a command operation. For example, you can use <strong class="calibre6">grep </strong>to <strong class="calibre6">recursively </strong>crawl an entire directory until no more files remain, or you can recursively execute a function inside of itself until a condition is met (for example, printing a single character at a time within a string):</p>
<pre class="calibre22"># e.g. File system<br class="calibre2"/># / (start here)<br class="calibre2"/># /home (oh we found home)<br class="calibre2"/># /home/user (neat there is a directory inside it called user)<br class="calibre2"/># /home/user/.. (even better, user has files - lets look in them too)<br class="calibre2"/># /etc/ # We are done with /home and its "children" so lets look in /etc<br class="calibre2"/># ... # Until we are done</pre>
<div class="packt_tip">Be careful with recursion (especially with functions), as it can sometimes be really slow depending on the complexity of the structure (for example, file system or size of files). Also if there is a logic error, you can keep executing functions recursively forever!</div>
<p class="mce-root">This chapter is all about limiting data, utilizing it, modifying it, internationalizing it, replacing it, and even searching for it in the first place.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Basic searching for strings and files</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Imagine searching for a four leaf clover in a big garden. It would be really hard (and it is still really hard for computers). Thankfully, words are not images and text on a computer is easily searchable depending on the format. The term <strong class="calibre6">format</strong> has to be used because if your tool cannot understand a given type of text (<strong class="calibre6">encoding</strong>), then you might have trouble recognizing a <strong class="calibre6">pattern</strong> or even detecting that there is text at all!</p>
<p class="mce-root">Typically, when you are looking at the console, text files, source code (C, C++, Bash, HTML), spreadsheets, XML, and other types, you are looking at it in <strong class="calibre6">ASCII </strong>or <strong class="calibre6">UTF</strong>. ASCII is a commonly used format in the <kbd class="calibre17">*NIX</kbd> world on the console. There is also the UTF <strong class="calibre6">encoding scheme</strong>, which is an improvement upon ASCII and can support a variety of extended characters that were not present in computing originally. It comes in a number of formats such as UTF-8, UTF-16, and UTF32.</p>
<div class="packt_infobox"><span class="calibre11">When you hear the words encoding and decoding, it is similar to encryption and decryption. The purpose is not to hide something, but rather to transform some data into something appropriate for the use case. For example, transmission, usage with languages, and compression.<br class="calibre2"/></span>ASCII and UTF are not the only types your target data might be in. In various types of files, you may encounter different types of encoding of data. This is a different problem that's specific to your data and will need additional considerations.</div>
<p class="mce-root">In this recipe, we will begin the process of searching for strings and a couple of ways to search for some of your own needles in a massive haystack of data. Let's dig in.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Besides having a terminal open (and your favorite text editor, if necessary), we only need a couple of core commands such as <kbd class="calibre17">grep</kbd>, <kbd class="calibre17">ls</kbd>, <kbd class="calibre17">mkdir</kbd>, <kbd class="calibre17">touch</kbd>, <kbd class="calibre17">traceroute</kbd>, <kbd class="calibre17">strings</kbd>, <kbd class="calibre17">wget</kbd>, <kbd class="calibre17">xargs</kbd>, and <kbd class="calibre17">find.</kbd></p>
<p class="mce-root">Assuming that your user already has the correct permissions for your usage (and authorized, of course), we will need to generate data to begin searching:</p>
<pre class="calibre22">$ ~/<br class="calibre2"/>$ wget --recursive --no-parent https://www.packtpub.com www.packtpub.com # Takes awhile<br class="calibre2"/>$ traceroute packtpub.com &gt; traceroute.txt<br class="calibre2"/>$ mkdir -p www.packtpub.com/filedir www.packtpub.com/emptydir<br class="calibre2"/>$ touch www.packtpub.com/filedir/empty.txt<br class="calibre2"/>$ touch www.packtpub.com/findme.xml; echo "&lt;xml&gt;" www.packtpub.com/findme.xml</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Using the data obtained by recursively <strong class="calibre6">crawling</strong> the Packt Publishing website, we can see that inside of <strong class="calibre6">www.packtpub.com </strong>the entire website is available. Wow! We also created some test data directories and files.</p>
<ol class="calibre20">
<li class="chapter">Next, open up a terminal and create the following script:</li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/><br class="calibre2"/># Let's find all the files with the string "Packt"<br class="calibre2"/>DIRECTORY="www.packtpub.com/"<br class="calibre2"/>SEARCH_TERM="Packt"<br class="calibre2"/><br class="calibre2"/># Can we use grep?<br class="calibre2"/>grep "${SEARCH_TERM}" ~/* &gt; result1.txt 2&amp;&gt; /dev/null<br class="calibre2"/><br class="calibre2"/># Recursive check<br class="calibre2"/>grep -r "${SEARCH_TERM}" "${DIRECTORY}" &gt; result2.txt<br class="calibre2"/><br class="calibre2"/># What if we want to check for multiple terms?<br class="calibre2"/>grep -r -e "${SEARCH_TERM}" -e "Publishing" "${DIRECTORY}" &gt; result3.txt<br class="calibre2"/><br class="calibre2"/># What about find?<br class="calibre2"/>find "${DIRECTORY}" -type f -print | xargs grep "${SEARCH_TERM}" &gt; result4.txt<br class="calibre2"/><br class="calibre2"/># What about find and looking for the string inside of a specific type of content?<br class="calibre2"/>find "${DIRECTORY}" -type f -name "*.xml" ! -name "*.css" -print | xargs grep "${SEARCH_TERM}" &gt; result5.txt<br class="calibre2"/><br class="calibre2"/># Can this also be achieved with wildcards and subshell?<br class="calibre2"/>grep "${SEARCH_TERM}" $(ls -R "${DIRECTORY}"*.{html,txt}) &gt; result6.txt<br class="calibre2"/>RES=$?<br class="calibre2"/><br class="calibre2"/>if [ ${RES} -eq 0 ]; then<br class="calibre2"/>  echo "We found results!"<br class="calibre2"/>else<br class="calibre2"/>  echo "It broke - it shouldn't happen (Packt is everywhere)!"<br class="calibre2"/>fi<br class="calibre2"/><br class="calibre2"/># Or for bonus points - a personal favorite<br class="calibre2"/>history | grep "ls" # This is really handy to find commands you ran yesterday!<br class="calibre2"/><br class="calibre2"/># Aaaannnd the lesson is:<br class="calibre2"/>echo "We can do a lot with grep!"<br class="calibre2"/>exit 0</pre>
<div class="packt_infobox">Notice in the script the use of <kbd class="calibre23">~/* ?</kbd>. This refers to our home directory and introduces the <kbd class="calibre23">*</kbd> wildcard, which allows us to specify anything from that point on. There will be more on the concept of wildcards and regexes later in this chapter.</div>
<ol start="2" class="calibre20">
<li class="chapter"> If you remain in your home directory (<kbd class="calibre17">~/</kbd>) and run the script, the output should be similar to the following:</li>
</ol>
<pre class="calibre27">$ bash search.sh; ls -lah result*.txt<br class="calibre2"/>We found results!<br class="calibre2"/>We can do a lot with grep!<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 14 14:33 result1.txt<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 1.2M Nov 14 14:33 result2.txt<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 1.2M Nov 14 14:33 result3.txt<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 1.2M Nov 14 14:33 result4.txt<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 33 Nov 14 14:33 result5.txt<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 14K Nov 14 14:33 result6.txt</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This section is a bit of a <em class="calibre18">doozy</em> because we are leading up to another more expansive topic, which is using regexes and wildcards with strings. We introduced them, but also showed you that you can search for terms with <kbd class="calibre17">${SEARCH_TERM}</kbd><strong class="calibre6"> </strong>or <em class="calibre18">Packt</em> specifically without their use—it's just more work and more statements. Can you imagine writing a specific <kbd class="calibre17">grep</kbd> statement for each term such as <kbd class="calibre17">Packt1</kbd>, <kbd class="calibre17">Packt2</kbd>, <kbd class="calibre17">Packt3</kbd>, and onwards? No fun. </p>
<p class="mce-root">Using the Packt Publishing website as a <em class="calibre18">baseline</em> data set, we <em class="calibre18">grepped</em> our way through the directory using the <kbd class="calibre17">grep</kbd> command, targeting only our current location, our user's home directory. <strong class="calibre6">Grep</strong> is a powerful tool that can be used to parse the output of commands and files using patterns, regexs, and user supplied parameters. In this case, we did not expect any string to be found matching <em class="calibre18">Packt</em> because <strong class="calibre6">www.packtpub.com</strong> is <em class="calibre18">not</em> the same as <strong class="calibre6">www.Packtpub.com</strong>. Therefore, <kbd class="calibre17">result1.txt</kbd> is an empty file.</p>
<div class="packt_tip">Grep and many other utilities can be case-sensitive. To use <kbd class="calibre23">grep</kbd> in a way that's case insensitive, use the <kbd class="calibre23">-i</kbd> flag.</div>
<p class="mce-root">In the second use of <kbd class="calibre17">grep</kbd>, we used the recursive flag (<kbd class="calibre17">-r</kbd>) and found many matches. By default, <kbd class="calibre17">grep</kbd> returns the path (containing the filename) of a match, and the line the match occurred within. To find the line number, you can also use the flag (<kbd class="calibre17">-n</kbd>).</p>
<p class="mce-root">In the third example, we demonstrated that <kbd class="calibre17">grep</kbd> can be used with multiple user-supplied arguments:</p>
<pre class="calibre22">$ grep -e "Packt" -e "Publishing" -r ~/www.packtpub.com/</pre>
<div class="packt_infobox">In this recipe, we are searching using a <em class="calibre26">brute-force</em> mechanism, which means we'll find it all by using all of our strength, literally. When performing searching on large amounts of data, or even when you perform something as seemingly simple as a search on the <kbd class="calibre23">PacktPublishing</kbd> website, more advanced and targeted algorithms help you find exactly what you want more efficiently and quicker than what we are doing here!</div>
<p class="mce-root">In the fourth and fifth executed examples, we use the <kbd class="calibre17">find</kbd><strong class="calibre6"> </strong>command. We also pair it with pipes and the <strong class="calibre6"><kbd class="calibre17">xargs</kbd> </strong>command as well. By itself, <kbd class="calibre17">find</kbd> is another very powerful CLI utility that can be used to perform search functionality (and consequently, damaging things if used irresponsibly/maliciously):</p>
<pre class="calibre22">$ find "${DIRECTORY}" -type f -print | xargs grep "${SEARCH_TERM}" &gt; result4.txt</pre>
<p class="mce-root">In the preceding <kbd class="calibre17">find</kbd> command, we are using <kbd class="calibre17">-type f</kbd><strong class="calibre6">, </strong>which means that we are looking for files only within <kbd class="calibre17">${DIRECTORY}</kbd>. Then, we pipe the results into the <kbd class="calibre17">xargs</kbd> command for use with grep. Wait! What is xargs!? <kbd class="calibre17">Xargs</kbd> is a command that's commonly used in tandem with a pipe to pass newline (carriage return) data to another command. For example, if we run ls <kbd class="calibre17">-l</kbd> (with the long flag), the results are returned like this (we've added the invisible line break or <kbd class="calibre17">\n</kbd> to illustrate this):</p>
<pre class="calibre22">$ ls -l<br class="calibre2"/>drwxr-xr-x 7 rbrash rbrash 4096 Nov 13 21:48 Desktop\n<br class="calibre2"/>drwxr-xr-x 2 rbrash rbrash 4096 Feb 11 2017 Documents\n<br class="calibre2"/>drwxr-xr-x 7 rbrash rbrash 32768 Nov 14 10:54 Downloads\n<br class="calibre2"/>-rw-r--r-- 1 rbrash rbrash 8980 Feb 11 2017 examples.desktop\n<br class="calibre2"/>...</pre>
<p class="mce-root">If we piped the results directly into another command that expected an input like the following, it would break!</p>
<pre class="calibre22">$ someProgram Desktop\n Documents\n Downloads\n ...</pre>
<p class="mce-root">Instead, <kbd class="calibre17">someProgram</kbd> requires input values separated by a space and <em class="calibre18">not</em> new lines:</p>
<pre class="calibre22">$ someProgram Desktop Documents Downloads ...</pre>
<p class="mce-root">This is why you use <kbd class="calibre17">xargs</kbd>: to remove or convert the new lines into something less problematic.</p>
<p class="mce-root">Going back to the second <kbd class="calibre17">find</kbd> command example, you can see that we used the <kbd class="calibre17">-name</kbd> and <kbd class="calibre17">! -name</kbd> parameters. <kbd class="calibre17">-name</kbd> is simple; we are looking for a file with a specific user-supplied name. In the second <kbd class="calibre17">! -name</kbd> instance, the <kbd class="calibre17">!</kbd><strong class="calibre6"> </strong>means without or <em class="calibre18">not</em> with that name. This is called <strong class="calibre6">inverted logic</strong>.</p>
<p class="mce-root">We also used the <kbd class="calibre17">*</kbd> wildcard again in a different context than in the first example using <kbd class="calibre17">grep</kbd> (again, more on this later). Instead, this time, we used the <kbd class="calibre17">*</kbd> to match anything before the file's extension (<kbd class="calibre17">*.xml</kbd> or <kbd class="calibre17">*.css</kbd>). It can even be used like this: </p>
<pre class="calibre22">$ ls -l /etc/*/*.txt<br class="calibre2"/>-rw-r--r-- 1 root root 17394 Nov 10 2015 /etc/X11/rgb.txt</pre>
<p class="mce-root">In the following <kbd class="calibre17">grep</kbd> command, we use an inline subshell execution of the <kbd class="calibre17">ls</kbd> command using wildcards. Then, we take the result by setting <kbd class="calibre17">${RES}</kbd> to <kbd class="calibre17">$?</kbd>. <kbd class="calibre17">$?</kbd> is a special variable used to get the return code. Using the value within <kbd class="calibre17">${RES}</kbd>, we can now provide a bit of conditional logic if results are found and appropriately <kbd class="calibre17">echo</kbd>:</p>
<pre class="calibre22">We found results!</pre>
<p class="mce-root">Right before we exited the shell, we thought we would throw in a bonus: you can search your past ran commands using the <kbd class="calibre17">history</kbd> command and <kbd class="calibre17">grep</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using wildcards and regexes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As we saw in the previous section, there was this new concept of recursive functions and the introduction of wildcards. This section will extend upon those same fundamental primitives to create more advanced searches using regexes and globbing.</p>
<p class="mce-root">It will also extend them with a number of built-in Bash features, and some one-liners (nifty tricks) to enhance our searches. In short:</p>
<ul class="calibre13">
<li class="calibre14">A wildcard can be: <kbd class="calibre17">*</kbd>, <kbd class="calibre17">{*.ooh,*.ahh}</kbd>, <kbd class="calibre17">/home/*/path/*.txt</kbd>, <kbd class="calibre17">[0-10]</kbd>, <kbd class="calibre17">[!a]</kbd>, <kbd class="calibre17">?</kbd>, <kbd class="calibre17">[a,p] m</kbd></li>
<li class="calibre14">A regex can be: <kbd class="calibre17">$</kbd>, <kbd class="calibre17">^</kbd>, <kbd class="calibre17">*</kbd>, <kbd class="calibre17">[]</kbd>, <kbd class="calibre17">[!]</kbd>, <kbd class="calibre17">|</kbd> (be careful to escape this)</li>
</ul>
<p class="mce-root"><strong class="calibre6">Globbing </strong>basically refers to a far more computer-eccentric term, which can be simply described in layman terms as <strong class="calibre6">extended pattern matching</strong>. Wildcards are the <strong class="calibre6">symbols</strong> used to describe patterns, and <strong class="calibre6">regex</strong> is short for <strong class="calibre6">regular expression</strong>, which are terms used to describe the pattern that is to match a series of data.</p>
<div class="packt_infobox">Globbing in Bash is powerful, but likely not the best place to perform even more advanced or intricate pattern matching. In these cases, Python or another language/tool might be more appropriate.</div>
<p class="mce-root">As we can imagine, globbing and pattern matching are really useful, but they cannot be used by every utility or application. Usually, though, they can be used at the command line with utilities such as <kbd class="calibre17">grep</kbd>. For example:</p>
<pre class="calibre22">$ ls -l | grep '[[:lower:]][[:digit:]]' # Notice no result<br class="calibre2"/>$ touch z0.test<br class="calibre2"/>$ touch a1.test<br class="calibre2"/>$ touch A2.test<br class="calibre2"/>$ ls -l | grep '[[:lower:]][[:digit:]]'<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 11:31 z0.test<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 11:31 a1.test</pre>
<p class="mce-root">Using the <kbd class="calibre17">ls</kbd> command, which is piped into <kbd class="calibre17">grep</kbd> with a regex, we can see that after we <kbd class="calibre17">touch</kbd> three files and re-run the command that the regex allowed us to correctly filter the output for files starting with a lowercase character, which are followed by a single digit. </p>
<p class="mce-root">If we wanted to further enhance grep (or another command), we could use any of the following:</p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre11"><kbd class="calibre17">[:alpha:]</kbd>: Alphabetic</span><span class="calibre11"> </span><span class="calibre11">(case-insensitive) </span></li>
<li class="calibre14"><kbd class="calibre17">[:lower:]</kbd>: Lowercase <span class="calibre11">printable characters</span></li>
<li class="calibre14"><span class="calibre11"><kbd class="calibre17">[:upper:]</kbd>: Uppercase</span><span class="calibre11"> </span><span class="calibre11">printable characters</span></li>
<li class="calibre14"><kbd class="calibre17">[:digit:]</kbd>: Numbers<span class="calibre11"> </span>in decimal 0 to 9</li>
<li class="calibre14"><kbd class="calibre17">[:alnum:]</kbd>: Alphanumeric<span class="calibre11"> (all digits and alphabetic characters)</span></li>
<li class="calibre14"><kbd class="calibre17">[:space:]</kbd>: White space<span class="calibre11"> </span>meaning spaces,<span class="calibre11"> </span>tabs, and<span class="calibre11"> </span>newlines</li>
<li class="calibre14"><kbd class="calibre17">[:graph:]</kbd>: Printable<span class="calibre11"> </span>characters excluding<span class="calibre11"> </span>spaces</li>
<li class="calibre14"><kbd class="calibre17">[:print:]</kbd>: Printable<span class="calibre11"> </span>characters including<span class="calibre11"> </span>spaces</li>
<li class="calibre14"><kbd class="calibre17">[:punct:]</kbd>: Punctuation (for example, a period)</li>
<li class="calibre14"><kbd class="calibre17">[:cntrl:]</kbd>: Control<span class="calibre11"> </span>characters (non-printable characters like when a signal is generated when you use <em class="calibre26">Ctrl</em> + <em class="calibre26">C)</em></li>
<li class="calibre14"><kbd class="calibre17">[:xdigit:]</kbd>: Hexadecimal<span class="calibre11"> </span>characters</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Besides having a terminal open (and your favorite text editor, if necessary), we only need a couple of core commands: <kbd class="calibre17">grep</kbd>, <kbd class="calibre17">tr</kbd>, <kbd class="calibre17">cut</kbd><strong class="calibre6">, </strong>and <kbd class="calibre17">touch</kbd>. We're assuming that the <kbd class="calibre17">www.packtpub.com</kbd> directory that we crawled through in the previous step is still available:</p>
<pre class="calibre22">$ cd ~/<br class="calibre2"/>$ touch {a..c}.test<br class="calibre2"/>$ touch {A..C}[0..2].test2<br class="calibre2"/>$ touch Z9.test3 Z9\,test2 Z9..test2<br class="calibre2"/>$ touch ~/Desktop/Test.pdf</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's get started:</p>
<ol class="calibre20">
<li class="chapter"><span class="calibre11">Open a terminal, and an editor of your choice to create a new script.</span></li>
<li class="chapter">Inside of your script, add the following:</li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/>STR1='123 is a number, ABC is alphabetic &amp; aBC123 is alphanumeric.'<br class="calibre2"/><br class="calibre2"/>echo "-------------------------------------------------"<br class="calibre2"/># Want to find all of the files beginning with an uppercase character and end with .pdf?<br class="calibre2"/>ls * | grep [[:upper:]]*.pdf<br class="calibre2"/><br class="calibre2"/>echo "-------------------------------------------------"<br class="calibre2"/># Just all of the directories in your current directory?<br class="calibre2"/><span class="calibre11">ls -l [[:upper:]]*</span><br class="calibre2"/><br class="calibre2"/>echo "-------------------------------------------------"<br class="calibre2"/># How about all of the files we created with an expansion using the { } brackets?<br class="calibre2"/>ls [:lower:].test .<br class="calibre2"/><br class="calibre2"/>echo "-------------------------------------------------"<br class="calibre2"/># Files with a specific extension OR two?<br class="calibre2"/>echo ${STR1} &gt; test.txt<br class="calibre2"/>ls *.{test,txt} <br class="calibre2"/><br class="calibre2"/>echo "-------------------------------------------------"<br class="calibre2"/># How about looking for specific punctuation and output on the same line<br class="calibre2"/>echo "${STR1}" | grep -o [[:punct:]] | xargs echo<br class="calibre2"/><br class="calibre2"/>echo "-------------------------------------------------"<br class="calibre2"/># How about using groups and single character wildcards (only 5 results)<br class="calibre2"/>ls | grep -E "([[:upper:]])([[:digit:]])?.test?" | tail -n 5<br class="calibre2"/><br class="calibre2"/>exit 0</pre>
<ol start="3" class="calibre20">
<li class="chapter">Now, execute the script and your console should be flooded with the output. Most importantly, let's look at the last five results. Notice the <kbd class="calibre17">Z9(,)</kbd> and <kbd class="calibre17">Z9.test(3)</kbd> among the results? This is the power of a regex at work! Okay, so we get that we can now create and search for a bunch of folders or files using variables, but can I use regexes to find things like variable parameters? Absolutely! See the next step.</li>
<li class="chapter">In the console, try the following:</li>
</ol>
<pre class="calibre27">$ grep -oP 'name="\K.*?(?=")' www.packtpub.com/index.html</pre>
<ol start="5" class="calibre20">
<li class="chapter">Again, in the console, try the following:</li>
</ol>
<pre class="calibre27">$ grep -P 'name=' www.packtpub.com/index.html</pre>
<ol start="6" class="calibre20">
<li class="chapter">Can we do better using commands like <kbd class="calibre17">tr</kbd><strong class="calibre3"> </strong>to remove new lines when finding instances of IF that may span multiple lines?</li>
</ol>
<pre class="calibre27">$ tr '\n' ' ' &lt; www.packtpub.com/index.html | grep -o '&lt;title&gt;.*&lt;/title&gt;' </pre>
<ol start="7" class="calibre20">
<li class="chapter">Now, let's remove a bit more gunk from the screen using <kbd class="calibre17">cut</kbd><strong class="calibre3"> </strong>as a finale. Usually, the console is <kbd class="calibre17">80</kbd> characters wide, so let's add a line number and trim the output from <kbd class="calibre17">grep</kbd>:</li>
</ol>
<pre class="calibre27">$ grep -nP 'name=' www.packtpub.com/index.html | cut -c -80</pre>
<div class="packt_infobox">Entire books have been dedicated to parsing data with regexes, but the key thing to note is that regexes are not always the best option for either performance or for markup languages like HTML. For example, when parsing HTML, it is best to use a parser that is aware of the language itself and any language-specific nuances. </div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As you may have guessed, snooping through lots of data without regexes and wildcards can be a nightmare for the uninitiated. An even scarier one might even occur when your expressions don't use the correct terms or a valid (and accurate) expression to begin with. However, wildcards are quite useful on the command line when trying to <strong class="calibre6">craft </strong>strings together, find data quickly, and finding files. Sometimes, it the usability of the search result that's irrelevant if I'm merely looking to find the filename and rough location/line of a specific occurrence.<strong class="calibre6"> </strong>For example, where is this CSS class in what file?</p>
<p class="mce-root">Well, you made it through the script and ran several commands to get a real-world idea of how to use regexes and wildcards at a surface level. Let's turn back the clock and walk through the recipe.</p>
<p class="mce-root">In step 1, we opened a console, created a simple script, and executed it. The output results were then displayed on the console:</p>
<pre class="calibre22">$ bash test.sh <br class="calibre2"/>-------------------------------------------------<br class="calibre2"/>Linux-Journal-2017-08.pdf<br class="calibre2"/>Linux-Journal-2017-09.pdf<br class="calibre2"/>Linux-Journal-2017-10.pdf<br class="calibre2"/>Test.pdf<br class="calibre2"/>-------------------------------------------------<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 A0.test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 A1.test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 A2.test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 B0.test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 B1.test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 B2.test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 C0.test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 C1.test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 C2.test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 Z9,test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 Z9..test2<br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 Z9.test3<br class="calibre2"/><br class="calibre2"/>Desktop:<br class="calibre2"/>total 20428<br class="calibre2"/>drwxrwxr-x 2 rbrash rbrash 4096 Nov 15 12:55 book<br class="calibre2"/># Lots of files here too<br class="calibre2"/><br class="calibre2"/>Documents:<br class="calibre2"/>total 0<br class="calibre2"/><br class="calibre2"/>Downloads:<br class="calibre2"/>total 552776<br class="calibre2"/>-rw------- 1 root root 1024 Feb 11 2017 ~<br class="calibre2"/>... # I have a lot of files for this book<br class="calibre2"/><br class="calibre2"/>Music:<br class="calibre2"/>total 0<br class="calibre2"/><br class="calibre2"/>Pictures:<br class="calibre2"/>total 2056<br class="calibre2"/>drwxrwxr-x 2 rbrash rbrash 4096 Sep 6 21:56 backgrounds<br class="calibre2"/><br class="calibre2"/>Public:<br class="calibre2"/>total 0<br class="calibre2"/><br class="calibre2"/>Templates:<br class="calibre2"/>total 0<br class="calibre2"/><br class="calibre2"/>Videos:<br class="calibre2"/>total 4<br class="calibre2"/>drwxrwxr-x 13 rbrash rbrash 4096 Aug 11 10:42 movies<br class="calibre2"/>-------------------------------------------------<br class="calibre2"/>a.test b.test c.test<br class="calibre2"/>-------------------------------------------------<br class="calibre2"/>a.test b.test c.test test.txt<br class="calibre2"/>-------------------------------------------------<br class="calibre2"/>, &amp; .<br class="calibre2"/>-------------------------------------------------<br class="calibre2"/>C0.test2<br class="calibre2"/>C1.test2<br class="calibre2"/>C2.test2<br class="calibre2"/>Z9,test2<br class="calibre2"/>Z9.test3</pre>
<p class="mce-root">It could be a lot scarier! Right? In the first line, we begin by chasing down some PDFs that start with a capital (uppercase) letter. The line <kbd class="calibre17">ls * | grep [[:upper:]]*.pdf</kbd> uses the <kbd class="calibre17">ls</kbd><strong class="calibre6"> </strong>command with a <kbd class="calibre17">*</kbd> wildcard (for everything) and then pipes the output into <kbd class="calibre17">grep</kbd> with a simple regex. The regex is <kbd class="calibre17">[[:upper:]]</kbd> followed by another <strong class="calibre6"><kbd class="calibre17">*</kbd></strong> wildcard to combine the <kbd class="calibre17">.pdf</kbd> string. This produces our search results, which at a minimum will contain <kbd class="calibre17">Test.pdf</kbd> (my results returned PDFs for a popular Linux journal too!).</p>
<p class="mce-root">Then, we perform almost the same search using <kbd class="calibre17">ls -l [[:upper:]]* </kbd>, but using the <kbd class="calibre17">ls</kbd> directory with a regex will return a large amount of data (if all of the folders have contents). It begins in the current directory where the script is located, and then marches one directory deep and prints the contents. A neat feature is the use of the <kbd class="calibre17">-l</kbd> flag, which will produce <em class="calibre18">long</em> results and print the size of the directory in bytes.</p>
<p class="mce-root">Next, we use <kbd class="calibre17">ls</kbd> and look for all files beginning with a lowercase character and end with the <kbd class="calibre17">.test</kbd> extension. Little did you know, when you set up this recipe, you also saw wildcards and an expansion at work: <kbd class="calibre17">touch {a..c}.test</kbd> . The <kbd class="calibre17">touch</kbd> command created three files: <kbd class="calibre17">a.test</kbd>, <kbd class="calibre17">b.test</kbd>, and <kbd class="calibre17">c.test</kbd>. The <kbd class="calibre17">ls</kbd> command with this simple regex returns the names of the previous three files.</p>
<p class="mce-root">Again, we use the <kbd class="calibre17">ls</kbd> command with the (<kbd class="calibre17">*</kbd>), wildcard and expansion brackets to match for file extensions: <kbd class="calibre17">ls *.{test,txt}</kbd>. It searches for files with any name (<kbd class="calibre17">*</kbd>), which are then concatenated with a period (<kbd class="calibre17">.</kbd>), followed by either <kbd class="calibre17">test</kbd> or <kbd class="calibre17">txt</kbd> extensions.</p>
<p class="mce-root">Next, in step 7, we combined a few things we have learned using pipes, <kbd class="calibre17">grep</kbd>, <kbd class="calibre17">xargs</kbd>, and a regex in the command: <kbd class="calibre17">echo "${STR1}" | grep -o [[:punct:]] | xargs echo</kbd>. The fact that the output from grep will be in <kbd class="calibre17">\n</kbd> delimited form (new lines for each instance found), this will break our intention to have all of the values echoed to the console in this form and thereby we need <kbd class="calibre17">xargs</kbd> to fix the output into parameters <kbd class="calibre17">echo</kbd> can properly use. For example, <kbd class="calibre17">echo "item1\n item2\n item3\n"</kbd> will not work, but with <kbd class="calibre17">xargs</kbd>, it will look like: <span class="calibre16"><kbd class="calibre17">echo "item1"  "item2" "item3"</kbd>.</span></p>
<p class="mce-root">And in the final command, we finally arrive at a <em class="calibre18">crazier</em> regex, which in truth is actually quite tame: <kbd class="calibre17">ls | grep -E "([[:upper:]])([[:digit:]])?.test?." | tail -n 5</kbd>. It introduces a couple of concepts, including groups (the parentheses), (<kbd class="calibre17">?</kbd>) wildcards, and how you can combine multiple expression components, and <kbd class="calibre17">tail</kbd>.</p>
<p class="mce-root">Using <kbd class="calibre17">grep</kbd>, the <kbd class="calibre17">-E</kbd> (expression flag), and two groups (the expressions inside of the parenthesis), we can combine them with the <kbd class="calibre17">?</kbd> regex operator. This acts as a wildcard for a single character:</p>
<pre class="calibre22">C0.test2<br class="calibre2"/>C1.test2<br class="calibre2"/>C2.test2<br class="calibre2"/>Z9,test2<br class="calibre2"/>Z9.test3</pre>
<p class="mce-root">We can see that the last five results were returned, starting with a capital letter, followed by a number, a character (either <kbd class="calibre17">.</kbd> or <kbd class="calibre17">,</kbd>), and then the word test and a number. We created one test file called <kbd class="calibre17">Z9..test2</kbd>. Notice how it was not included among the list items? This was because we did not use an expression like this: </p>
<pre class="calibre22">$ ls | grep -E "([[:upper:]])([[:digit:]])?.?.test?"</pre>
<p class="mce-root">In step 4, we run a particular regex using <kbd class="calibre17">grep</kbd> and <kbd class="calibre17">-oP</kbd> flags, <kbd class="calibre17">grep -oP 'name="\K.*?(?=")' www.packtpub.com/index.html</kbd>, on top of our recently crawled archive of <kbd class="calibre17">www.packtpub.com</kbd>. The <kbd class="calibre17">-o</kbd> flag means output only matching values, and <kbd class="calibre17">-P</kbd><strong class="calibre6"> </strong>is for using the Perl expressions.</p>
<p class="mce-root">Notice all of the values contained with double quotes? It's looking for <em class="calibre18">any</em> match that matches the pattern <kbd class="calibre17">name="anythingGoesHere"</kbd>.<strong class="calibre6"> </strong>It's certainly not extremely useful by itself, but it illustrates the point of being able to quickly get values (for example, what if the name was very specific? You could alter <kbd class="calibre17">name=</kbd> to another value and get the exact same result!).</p>
<p class="mce-root">Following along the same context, in step 5, we can also find <em class="calibre18">all</em> occurrences of <kbd class="calibre17">name=</kbd>: <kbd class="calibre17">grep -P 'name=' www.packtpub.com/index.html</kbd>. This type of command is useful for understanding the context of information or merely the existence of it; this comes back to the idea of looking for values in CSS, C/C++, and other data/source files.</p>
<p class="mce-root">Onward to step 6, we are looking for the title HTML tag. Normally, you should use a dedicated HTML parser, but if we wanted to use grep with regexes in a hurry<span class="calibre16">—</span>we can! The <kbd class="calibre17">tr '\n' ' ' &lt; www.packtpub.com/index.html | grep -o '&lt;title&gt;.*&lt;/title&gt;'</kbd> command uses the translate function (<kbd class="calibre17">tr</kbd>) to convert the <kbd class="calibre17">\n</kbd> or newline special character into an empty space. This is useful when data has a markup that may span multiple lines.</p>
<p class="mce-root">In our closing step, we end with a bit of fine-tuning when performing broad searches. We simply use <kbd class="calibre17">grep</kbd> to provide us with the line number and filename. Using <kbd class="calibre17">cut</kbd>, we an trim the remaining characters of the output on the console (this can be really useful):</p>
<pre class="calibre22">$ grep -nHP 'name=' www.packtpub.com/index.html | cut -c -80</pre>
<div class="packt_infobox"><span class="calibre11">Regexes can also be tested online using a number of regex simulators! One popular and free tool available online is: <a href="https://regexr.com/" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://regexr.com/</a>.</span></div>
<div class="packt_tip">Don't forget that some regex functionalities also allow you to nest commands within groups! We didn't demonstrate this functionality, but it exists with acceptable results in some use cases!</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Math and calculations in script</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">After a grueling introduction to the world of wildcards and regexes for searches, we're going to move on to being able to perform some basic mathematical operations at the console. If you haven't already tried, what happens when you run something like the following in the Bash shell? Does it look like this?</p>
<pre class="calibre22">$ 1*5<br class="calibre2"/>1*5: command not found</pre>
<p class="mce-root">Command not found? Certainly, we know the computer can do <em class="calibre18">math</em>, but clearly Bash is unable to interpret mathematical operations in this way. We have to ensure that Bash is able to <strong class="calibre6">interpret </strong>these operations correctly through the use of:</p>
<ul class="calibre13">
<li class="calibre14">The <kbd class="calibre17">expr</kbd> command (antiquated)</li>
<li class="calibre14">The <strong class="calibre3"><kbd class="calibre17">bc</kbd> </strong>command</li>
<li class="calibre14">POSIX Bash shell expansion</li>
<li class="calibre14">Another language/program to do the <em class="calibre26">dirty</em> work</li>
</ul>
<p class="mce-root">Let's try again, but using the POSIX Bash shell expansion:</p>
<pre class="calibre22">$ echo $((1*5))<br class="calibre2"/>5</pre>
<p class="mce-root">We got the expected answer of <kbd class="calibre17">5</kbd>, but where does this go wrong? It goes wrong when using division and floats because Bash works primarily with integers:</p>
<pre class="calibre22">$ echo $((1/5))<br class="calibre2"/>0</pre>
<p class="mce-root">True, <kbd class="calibre17">1</kbd> divided by <kbd class="calibre17">5</kbd> is <kbd class="calibre17">0</kbd>, but there is a remainder missing! And this is why we may rely on other methods to perform simple mathematics.</p>
<p class="mce-root">One of the many uses or reasons to use equations and <kbd class="calibre17">math</kbd> in a script is to determine sizes of file system partitions. Can you imagine what may happen if a disk becomes too full? Or that we may want to automatically archive a directory if it reaches a predetermined size? Of course, this is theoretical, but things can and do break if we let a file system silently become full!</p>
<p class="mce-root">The following recipe is about determining the size of a tarball (and contents), the remaining available space on the destination partition, and whether the operation could continue or be canceled.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This recipe is going to take into account a few interesting things:</p>
<ul class="calibre13">
<li class="calibre14">Bash can't do everything well</li>
<li class="calibre14">Other utilities exist (for example, <kbd class="calibre17">bc</kbd>)</li>
<li class="calibre14">We can create our own in another language like C</li>
<li class="calibre14">Creating a tarball</li>
</ul>
<div class="packt_infobox">Sometimes, on small embedded systems, Python might not be available, but Bash (or a close relative) and C are. This is where being able to perform math without extra programs (that may not be available) can come in handy!</div>
<p class="mce-root">We will use the following command to make sure that we have all of the utilities installed for this experiment:</p>
<pre class="calibre22">$ sudo apt-get install -y bc tar</pre>
<p class="mce-root">Now, we need to create a tarball called <kbd class="calibre17">archive.tar.gz</kbd>:</p>
<pre class="calibre22"><span class="calibre11">$ </span>dd if=/dev/zero of=empty.bin bs=1k count=10000<span class="calibre11"><br class="calibre2"/>$ tar</span><span class="calibre11"><span class="calibre11"> </span></span><span class="calibre11">-</span><span class="calibre11">zcvf<span class="calibre11"> archive.tar.gz empty.bin<br class="calibre2"/>$ rm empty.bin</span></span></pre>
<p class="mce-root">We realize that the purpose of creating/compiling a simple program that is not written in Bash may be beyond the scope of this book, but it can be a helpful skill. To do this, we will need to install GCC, which is short for the GNU Compiler Collection. This sounds terribly complex and we assure you that we did all the hard work:</p>
<pre class="calibre22">$ sudo apt-get install -y gcc</pre>
<p class="mce-root">The preceding command installs the compiler, and now we need the C source code (in order to compile a <em class="calibre18">simple</em> C program). Open up a console and retrieve the code using:</p>
<pre class="calibre22">$ wget https://raw.githubusercontent.com/PacktPublishing/Bash-Cookbook/master/chapter%2002/mhelper.c</pre>
<div class="packt_infobox">This code is also available on Github at <a href="https://github.com/PacktPublishing/Bash-Cookbook" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://github.com/PacktPublishing/Bash-Cookbook</a>. </div>
<p class="mce-root">To compile the code, we will use <kbd class="calibre17">gcc</kbd> and <kbd class="calibre17">-lm</kbd> (this refers to <kbd class="calibre17">libmath</kbd>) as follows:</p>
<div class="title-page-name">
<pre class="calibre22">$ gcc -Wall -02 -o mhelper main.c -lmath</pre></div>
<p class="mce-root">If the compiler completes successfully (which it should), you will be left with a utility binary called <kbd class="calibre17">mhelper</kbd> (or math helper). We can also add this to our list of local commands by copying it to <kbd class="calibre17">/bin</kbd> using <kbd class="calibre17">sudo</kbd> and <kbd class="calibre17">cp</kbd>:</p>
<pre class="calibre22">$ sudo cp mhelper /bin; sudo chmod a+x /bin/mhelper;</pre>
<p class="mce-root">Now, <kbd class="calibre17">mhelper</kbd> can be used for basic operations such as division, multiplication, addition, and subtraction:</p>
<pre class="calibre22">$ mhelper "<strong class="calibre3">var1" "-" "var2"</strong></pre>
<div class="packt_infobox">The <kbd class="calibre23">mhelper</kbd> code is not designed to be particularly robust and to handle specific edge cases, but rather to demonstrate that another utility can be used. Python and numpy would be an excellent alternatives!</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Using the <kbd class="calibre17">mhelper</kbd> binary, <kbd class="calibre17">bc</kbd>, and other expressions, we can begin the recipe:</p>
<ol class="calibre20">
<li class="chapter">Begin by opening a terminal and an editor to create a new script called <kbd class="calibre17">mathexp.sh</kbd><strong class="calibre3"> </strong>with the following contents:</li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/># Retrieve file system information and remove header<br class="calibre2"/>TARBALL="archive.tar.gz"<br class="calibre2"/>CURRENT_PART_ALL=$(df --output=size,avail,used /home -B 1M | tail -n1)<br class="calibre2"/><br class="calibre2"/># Iterate through and fill array<br class="calibre2"/>IFS=' ' read -r -a array &lt;&lt;&lt; $CURRENT_PART_ALL<br class="calibre2"/><br class="calibre2"/># Retrieve the size of the contents of the tarball<br class="calibre2"/>COMPRESSED_SZ=$(tar tzvf "${TARBALL}" | sed 's/ \+/ /g' | cut -f3 -d' ' | sed '2,$s/^/+ /' | paste -sd' ' | bc)<br class="calibre2"/><br class="calibre2"/>echo "First inspection - is there enough space?"<br class="calibre2"/>if [ ${array[1]} -lt ${COMPRESSED_SZ} ]; then<br class="calibre2"/>    echo "There is not enough space to decompress the binary"<br class="calibre2"/>    exit 1<br class="calibre2"/>else<br class="calibre2"/>  echo "Seems we have enough space on first inspection - continuing"<br class="calibre2"/>  VAR=$((${array[0]} - ${array[2]}))<br class="calibre2"/>  echo "Space left: ${VAR}"<br class="calibre2"/>fi<br class="calibre2"/><br class="calibre2"/>echo "Safety check - do we have at least double the space?"<br class="calibre2"/>CHECK=$((${array[1]}*2))<br class="calibre2"/>echo "Double - good question? $CHECK"<br class="calibre2"/><br class="calibre2"/># Notice the use of the bc command?<br class="calibre2"/>RES=$(echo "$(mhelper "${array[1]}" "/" "2")&gt;0" | bc -l)<br class="calibre2"/>if [[ "${RES}" == "1" ]]; then<br class="calibre2"/>  echo "Sppppppaaaaccee (imagine zombies)"<br class="calibre2"/>fi<br class="calibre2"/><br class="calibre2"/># We know that this will break! (Bash is driven by integers)<br class="calibre2"/># if [ $(mhelper "${array[2]}" "/" "2") -gt 0 ]; then<br class="calibre2"/>  #~ echo "Sppppppaaaaccee (imagine zombies) - syntax error"<br class="calibre2"/># fi<br class="calibre2"/># What if we tried this with Bash and a concept again referring to floats<br class="calibre2"/># e.g., 0.5<br class="calibre2"/># It would break<br class="calibre2"/># if [ $((${array[2]} * 0.5 )) -gt 0 ]; then<br class="calibre2"/>  # echo "Sppppppaaaaccee (imagine zombies) - syntax error"<br class="calibre2"/># fi<br class="calibre2"/><br class="calibre2"/># Then untar<br class="calibre2"/>tar xzvf ${TARBALL}<br class="calibre2"/>RES=$?<br class="calibre2"/>if [ ${RES} -ne 0 ]; then<br class="calibre2"/>  echo "Error decompressing the tarball!"<br class="calibre2"/>  exit 1<br class="calibre2"/>fi<br class="calibre2"/><br class="calibre2"/>echo "Decompressing tarball complete!"<br class="calibre2"/>exit 0</pre>
<ol start="2" class="calibre20">
<li class="chapter">Now, running the script should produce an output similar to the following:</li>
</ol>
<pre class="calibre27">First inspection - is there enough space?<br class="calibre2"/>Seems we have enough space on first inspection - continuing<br class="calibre2"/>Space left: 264559<br class="calibre2"/>Safety check - do we have at least double the space?<br class="calibre2"/>Double - good question ? 378458<br class="calibre2"/>Sppppppaaaaccee (imagine zombies)<br class="calibre2"/>empty.bin<br class="calibre2"/>Decompressing tarball complete!</pre>
<p class="mce-root">Great! So we can use Bash size calculations, the <kbd class="calibre17">bc</kbd> command, and our binary. If you want to calculate the radius of a circle (which will certainly get you a float value) or a percentage, for example, you will need to be aware of this limitation in Bash.</p>
<p class="mce-root">To bring this recipe to a close, it is important to note that the <kbd class="calibre17">expr</kbd> command still exists, but it is deprecated. Using <kbd class="calibre17">$(( your equation ))</kbd> is recommended as the preferred method in new scripts.</p>
<div class="packt_tip">Using the same premise using the <kbd class="calibre23">mhelper</kbd> binary or <kbd class="calibre23">$((..))</kbd> scripting, you can also calculate percentages for situations that need variable output (for example, not whole numbers). For example, calculating screen sizes based on percentages while a whole number will be desired, you can then round up or down post calculation.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First things first, as this recipe alluded to—we noticed that the Bash shell doesn't like decimal numbers with fractions or even non-whole numbers. Wait, math!? Unfortunately, we can't hide all the details, but in programming, there are a couple of concepts that you should be aware of:</p>
<ul class="calibre13">
<li class="calibre14">Signed and unsigned numbers</li>
<li class="calibre14">Floats, doubles, and integers</li>
</ul>
<p class="mce-root">The first concept is fairly simple—current computers are binary, which means they compute using zeros (0) and ones (1). This means that they work in powers of 2^. Without getting into a lesson about basic computer science, if you see a value (datatype) that is an int (integer) and that it is a 32 bit number, this means that the maximum value if it begins at <kbd class="calibre17">0</kbd> is <kbd class="calibre17">4,294,967,295</kbd> in decimal (2^32). <span class="calibre16">This makes one critical assumption and that is that all numbers (0 included) are positive. This positive or negative property is called <strong class="calibre6">sign</strong>! If a datatype mentions signed or unsigned—now you know what it means! </span></p>
<p class="mce-root">However, there is a consequence of whether something is signed and that is that the maximum positive or negative value is decreased because one bit is used to represent sign. A signed 32 bit int (which can also be referred to as <kbd class="calibre17">int32</kbd>) shall now have a range of <kbd class="calibre17">(-)2,147,483,647</kbd> to <kbd class="calibre17">(+)2,147,483,647</kbd>.</p>
<div class="packt_infobox">As a note from the author, I realize that some of the computer science definitions are not computer science correct, meaning that I tweaked some of their meanings to make sure the key points got across in <em class="calibre26">most</em> general situations.</div>
<p class="mce-root">On another note, Bash only uses integers and you may have already seen that when you divide a value like <kbd class="calibre17">1/5</kbd>, the answer is <kbd class="calibre17">0</kbd>. True, it is not divisible, but the answer is <kbd class="calibre17">0.20</kbd> as a fraction. We also cannot multiply numbers that have a decimal point as well! Therefore, we have to use other programs such as <kbd class="calibre17">bc</kbd> or <kbd class="calibre17">mhelper.</kbd></p>
<p class="mce-root">If you are keen on computers, you also know that there are floats, doubles, and other datatypes to represent numbers. <kbd class="calibre17">Mhelper</kbd> and <kbd class="calibre17">bc</kbd> can help you deal with these types of numbers when the concept of integers fails (for example, resulting numbers are not whole numbers when dividing).</p>
<ol class="calibre20">
<li class="chapter">Back to the recipe, and in step 1:
<ul class="calibre13">
<li class="calibre28">We created a script that will check the <kbd class="calibre17">/home</kbd> directory to determine how much size is available using the <kbd class="calibre17">df</kbd> command. Using <kbd class="calibre17">tail</kbd>, another command that can be used to reduce output, we skip the first line of output and pipe all output into the <kbd class="calibre17">$CURRENT_PART_ALL</kbd><strong class="calibre3"> </strong>variable<strong class="calibre3"> </strong>(or all current partition information).</li>
<li class="calibre28">Then, the contents of the <kbd class="calibre17">$CURRENT_PART_ALL</kbd> variable are read into an array using the <kbd class="calibre17">read</kbd><strong class="calibre3"> </strong>command. Notice the use of the re-direction errors: <kbd class="calibre17">&lt;&lt;&lt;</kbd>. This is called a <strong class="calibre3">her</strong><strong class="calibre3">e-string</strong>, which in simple terms expands the variable and feeds it into <kbd class="calibre17"><kbd class="calibre29">stdin.</kbd></kbd></li>
<li class="calibre28">Now, the <kbd class="calibre17">/home</kbd> partitions storage information is inside of an array, and we have a <kbd class="calibre17">tarball</kbd> (or a file that compresses and contains the contents within), where we need to know the size of the contents within the <kbd class="calibre17">tarball.</kbd> To do this, we use a long-winded command with multiple piped commands, which retrieves the size of the contained elements and pushes them through the <kbd class="calibre17">bc</kbd> command.</li>
<li class="calibre28">Upon determining the size of the elements contained within our archive, we validate the calculated size against the remaining available space. This value is inside of the <kbd class="calibre17">array element[1]</kbd>. If the available space is less than equal to the extracted files, then exit. Otherwise, print the remaining size after performing.</li>
<li class="calibre28">For fun, we combined forking a subshell to retrieve the division results of the <kbd class="calibre17">mhelper</kbd>, which are piped through <kbd class="calibre17">bc</kbd>. This is so we can determine if there is enough space as a mere <kbd class="calibre17">boolean</kbd> value of true (1) or false (0). </li>
<li class="calibre28">Since we assume we have enough space, we untar (decompress and extract the contents) the <kbd class="calibre17">$TARBALL</kbd>. If the <kbd class="calibre17">tar</kbd> command returns a value not equal to <kbd class="calibre17">0</kbd>, then exit with an error. Otherwise, exit with success.</li>
</ul>
</li>
<li class="chapter">After executing our script, the contents of the tarball (<kbd class="calibre17">empty.bin</kbd>) should be present in the current working directory.</li>
</ol>
<div class="packt_infobox">Inside of the script, we put two different evaluations in the comments, which would return floating point values or errors in syntax. We included them for your awareness and to drive the main lesson home.<br class="calibre2"/>
Did we miss anything? Absolutely! We never checked the size of the tarball itself and made sure that its size was among the used space when performing a check to determine the remaining free space. One should always be careful when performing and enforcing size restrictions!</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Striping/altering/sorting/deleting/searching strings with Bash only</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">So far, we have seen inkling of the power of commands available in Linux, and some of these are among the most powerful: <kbd class="calibre17">sed</kbd> and <kbd class="calibre17">grep</kbd>. However, while we can easily use these commands together, <em class="calibre18">sed by itself</em> or even using another very useful command called <kbd class="calibre17">awk</kbd>, we can leverage Bash itself to shave time and reduce external dependencies in a portable way!</p>
<p class="mce-root">So, how can we do this? Let's begin with a few examples using this Bash syntax:</p>
<pre class="calibre22">#!/bin/bash<br class="calibre2"/># Index zero of VARIABLE is the char 'M' &amp; is 14 bytes long<br class="calibre2"/>VARIABLE="My test string"<br class="calibre2"/># ${VARIABLE:startingPosition:optionalLength}<br class="calibre2"/>echo ${VARIABLE:3:4}</pre>
<p class="mce-root">In the preceding example, we can see a special way of calling special substring functionality using <kbd class="calibre17">${...}<strong class="calibre3"> </strong></kbd>, where <kbd class="calibre17">VARIABLE</kbd> is a string variable within your script (or even global), and then the following variable is the <kbd class="calibre17">:</kbd>.<strong class="calibre6"> </strong>After the <kbd class="calibre17">:</kbd>, there is the <kbd class="calibre17">startingPosition</kbd> parameter<strong class="calibre6"> </strong>(remember that strings are just arrays of characters and each character can be addressed by index), and there is another optional semicolon and length parameter (<kbd class="calibre17">optionalLength</kbd>). </p>
<p class="mce-root">If we ran this script, the output would be:</p>
<pre class="calibre22">$ bash script.sh<br class="calibre2"/>test</pre>
<p class="mce-root">How is this possible, you may ask? Well, its possible with Bash's equivalent of <kbd class="calibre17">substr</kbd> (a function in C and many other programming languages), and this is achieved through the usr of the <strong class="calibre6"><kbd class="calibre17">${...}</kbd></strong>syntax. This tells bash to look inside for a variable named <kbd class="calibre17">VARIABLE</kbd> and then for two parameters: to start at byte/character <kbd class="calibre17">3</kbd> (technically <kbd class="calibre17">4</kbd> because arrays start at element <kbd class="calibre17">0</kbd> in Bash) and a length of <kbd class="calibre17">4</kbd> (to print only four characters). The result of the echo is <kbd class="calibre17">test</kbd>.</p>
<p class="mce-root">Can we do more with this, such as removing the last character? Deleting words? Searching? Of course, and all of this is covered in this recipe!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's get ready for the exercise by creating some data sets which mimic common daily problems:</span></p>
<pre class="calibre22">$ rm -rf testdata; mkdir -p testdata<br class="calibre2"/>$ echo "Bob, Jane, Naz, Sue, Max, Tom$" &gt; testdata/garbage.csv <br class="calibre2"/>$ echo "Zero, Alpha, Beta, Gama, Delta, Foxtrot#" &gt;&gt; testdata/garbage.csv <br class="calibre2"/>$ echo "1000,Bob,Green,Dec,1,1967" &gt; testdata/employees.csv<br class="calibre2"/>$ echo "2000,Ron,Brash,Jan,20,1987" &gt;&gt; testdata/employees.csv<br class="calibre2"/>$ echo "3000,James,Fairview,Jul,15,1992" &gt;&gt; testdata/employees.csv</pre>
<p class="mce-root"><span class="calibre16">Using these two CSVs, we are going to:</span></p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre11">Remove the extra spaces on the first two lines of <kbd class="calibre17">garbage.csv</kbd></span></li>
<li class="calibre14">Remove the last character from each line in <kbd class="calibre17"><span class="calibre11">garbage.csv</span></kbd></li>
<li class="calibre14">Change the case of each character to uppercase in the first two lines of <kbd class="calibre17">garbage.csv</kbd></li>
<li class="calibre14">Replace <kbd class="calibre17">Bob</kbd> with <kbd class="calibre17">Robert</kbd> in <kbd class="calibre17">employees.csv</kbd></li>
<li class="calibre14">Insert a <kbd class="calibre17">#</kbd> at the beginning of each line in <kbd class="calibre17">employees.csv</kbd></li>
<li class="calibre14">Remove the exact date of birth column/field in each line of <kbd class="calibre17">employees.csv</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's begin our activity:</span></p>
<ol class="calibre20">
<li class="chapter"><span class="calibre11">Open a new terminal and a new file with your preferred editor. Add in the following contents into the new script and save it as <kbd class="calibre17">builtin-str.sh</kbd></span>:</li>
</ol>
<pre class="calibre27"><span class="calibre11">#!/bin/bash</span><br class="calibre2"/><br class="calibre2"/><span class="calibre11"># Let's play with variable arrays first using Bash's equivalent of substr</span><br class="calibre2"/><br class="calibre2"/><span class="calibre11">STR="1234567890asdfghjkl"</span><br class="calibre2"/><br class="calibre2"/><span class="calibre11">echo "first character ${STR:0:1}"</span><br class="calibre2"/><span class="calibre11">echo "first three characters ${STR:0:3}"</span><br class="calibre2"/><br class="calibre2"/><span class="calibre11">echo "third character onwards ${STR: 3}"</span><br class="calibre2"/><span class="calibre11">echo "forth to sixth character ${STR: 3: 3}"</span><br class="calibre2"/><br class="calibre2"/><span class="calibre11">echo "last character ${STR: -1}"</span><br class="calibre2"/><br class="calibre2"/><span class="calibre11"># Next, can we compare the alphabeticalness of strings?</span><br class="calibre2"/><br class="calibre2"/><span class="calibre11">STR2="abc"</span><br class="calibre2"/><span class="calibre11">STR3="bcd"</span><br class="calibre2"/><span class="calibre11">STR4="Bcd"</span><br class="calibre2"/><br class="calibre2"/><span class="calibre11">if [[ $STR2 &lt; $STR3 ]]; then</span><br class="calibre2"/><span class="calibre11"> echo "STR2 is less than STR3"</span><br class="calibre2"/><span class="calibre11">else</span><br class="calibre2"/><span class="calibre11"> echo "STR3 is greater than STR2"</span><br class="calibre2"/><span class="calibre11">fi</span><br class="calibre2"/><br class="calibre2"/><span class="calibre11"># Does case have an effect? Yes, b is less than B</span><br class="calibre2"/><span class="calibre11">if [[ $STR3 &lt; $STR4 ]]; then</span><br class="calibre2"/><span class="calibre11"> echo "STR3 is less than STR4"</span><br class="calibre2"/><span class="calibre11">else</span><br class="calibre2"/><span class="calibre11"> echo "STR4 is greater than STR3"</span><br class="calibre2"/><span class="calibre11">fi</span></pre>
<ol start="2" class="calibre20">
<li class="chapter">Execute the script with <kbd class="calibre17">bash builtin-str.sh</kbd><strong class="calibre3"> </strong>and notice how we were able to strip the last character from a string and even compare strings.</li>
<li class="chapter">Again, open a new file called <kbd class="calibre17">builtin-strng.sh</kbd><strong class="calibre3"> </strong>and add the following contents into it:</li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/>GB_CSV="testdata/garbage.csv"<br class="calibre2"/>EM_CSV="testdata/employees.csv"<br class="calibre2"/># Let's strip the garbage out of the last lines in the CSV called garbage.csv<br class="calibre2"/># Notice the forloop; there is a caveat<br class="calibre2"/><br class="calibre2"/>set IFS=,<br class="calibre2"/>set oldIFS = $IFS<br class="calibre2"/>readarray -t ARR &lt; ${GB_CSV}<br class="calibre2"/><br class="calibre2"/># How many rows do we have?<br class="calibre2"/>ARRY_ELEM=${#ARR[@]}<br class="calibre2"/>echo "We have ${ARRY_ELEM} rows in ${GB_CSV}"</pre>
<p class="mce-root1">Let's strip the garbage<span class="calibre16">—</span>remove spaces:</p>
<pre class="calibre27"><br class="calibre2"/>INC=0<br class="calibre2"/>for i in "${ARR[@]}"for i in "${ARR[@]}"<br class="calibre2"/>do<br class="calibre2"/>:<br class="calibre2"/>res="${i//[^ ]}"<br class="calibre2"/>TMP_CNT="${#res}"<br class="calibre2"/>while [ ${TMP_CNT} -gt 0 ]; do<br class="calibre2"/>i=${i/, /,}<br class="calibre2"/>TMP_CNT=$[$TMP_CNT-1]<br class="calibre2"/>done<br class="calibre2"/>ARR[$INC]=$i<br class="calibre2"/>INC=$[$INC+1]<br class="calibre2"/>done</pre>
<p class="mce-root1">Let's remove the last character from each line:</p>
<pre class="calibre27"><span class="calibre11">INC=0</span><br class="calibre2"/>for i in "${ARR[@]}"<br class="calibre2"/>do<br class="calibre2"/>: <br class="calibre2"/>ARR[$INC]=${i::-1}<br class="calibre2"/>INC=$[$INC+1]<br class="calibre2"/>done</pre>
<p class="mce-root1">Now, let's turn all of the characters into uppercase!</p>
<pre class="calibre27">INC=0for i in "${ARR[@]}"<br class="calibre2"/>do<br class="calibre2"/>:<br class="calibre2"/>ARR[$INC]=${i^^}<br class="calibre2"/>printf "%s" "${ARR[$INC]}"<br class="calibre2"/>INC=$[$INC+1]<br class="calibre2"/>echo<br class="calibre2"/>done<br class="calibre2"/> <br class="calibre2"/># In employees.csv update the first field to be prepended with a # character<br class="calibre2"/>set IFS=,<br class="calibre2"/>set oldIFS = $IFS<br class="calibre2"/>readarray -t ARR &lt; ${EM_CSV}<br class="calibre2"/> <br class="calibre2"/># How many rows do we have?<br class="calibre2"/>ARRY_ELEM=${#ARR[@]}<br class="calibre2"/> <br class="calibre2"/>echo;echo "We have ${ARRY_ELEM} rows in ${EM_CSV}"<br class="calibre2"/># Let's add a # at the start of each line<br class="calibre2"/>INC=0<br class="calibre2"/>for i in "${ARR[@]}"<br class="calibre2"/>do<br class="calibre2"/>:<br class="calibre2"/>ARR[$INC]="#${i}"<br class="calibre2"/>printf "%s" "${ARR[$INC]}"<br class="calibre2"/>INC=$[$INC+1]<br class="calibre2"/>echo<br class="calibre2"/>done<br class="calibre2"/> <br class="calibre2"/># Bob had a name change, he wants to go by the name Robert - replace it!<br class="calibre2"/>echo<br class="calibre2"/>echo "Let's make Bob, Robert!"<br class="calibre2"/>INC=0<br class="calibre2"/>for i in "${ARR[@]}"<br class="calibre2"/>do<br class="calibre2"/>:<br class="calibre2"/># We need to iterate through Bobs first<br class="calibre2"/>ARR[$INC]=${i/Bob/Robert}<br class="calibre2"/>printf "%s" "${ARR[$INC]}"<br class="calibre2"/>INC=$[$INC+1]<br class="calibre2"/>echo<br class="calibre2"/>done</pre>
<p class="mce-root1">We will <span class="calibre16">delete the day in the <kbd class="calibre17">birth</kbd> column. The</span> <span class="calibre16">field to remove is 5 (but this is really -4):</span></p>
<pre class="calibre27"><span class="calibre11">echo;<br class="calibre2"/></span><span class="calibre11">echo "Lets remove the column: birthday (1-31)"<br class="calibre2"/></span><span class="calibre11">INC=0<br class="calibre2"/></span><span class="calibre11">COLUM_TO_REM=4<br class="calibre2"/></span><span class="calibre11">for i in "${ARR[@]}"<br class="calibre2"/></span><span class="calibre11">do<br class="calibre2"/></span><span class="calibre11"> :<br class="calibre2"/></span><span class="calibre11"># Prepare to also parse the ARR element into another ARR for<br class="calibre2"/></span><span class="calibre11"># string manipulation<br class="calibre2"/></span><span class="calibre11"> TMP_CNT=0<br class="calibre2"/></span><span class="calibre11"> STR=""<br class="calibre2"/></span><span class="calibre11"> IFS=',' read -ra ELEM_ARR &lt;&lt;&lt; "$i"<br class="calibre2"/></span><span class="calibre11"> for field in "${ELEM_ARR[@]}"<br class="calibre2"/></span><span class="calibre11"> do<br class="calibre2"/></span><span class="calibre11">   # Notice the multiple argument in an if statement<br class="calibre2"/></span><span class="calibre11">   # AND that we catch the start of it once<br class="calibre2"/></span><span class="calibre11">   if [ $TMP_CNT -ne 0 ] &amp;&amp; [ $TMP_CNT -ne $COLUM_TO_REM ]; then<br class="calibre2"/></span><span class="calibre11">   STR="${STR},${field}"<br class="calibre2"/></span><span class="calibre11">   elif [ $TMP_CNT -eq 0 ]<br class="calibre2"/>   then<br class="calibre2"/></span><span class="calibre11">   STR="${STR}${field}"<br class="calibre2"/></span><span class="calibre11">   fi <br class="calibre2"/></span><span class="calibre11">   TMP_CNT=$[$TMP_CNT+1]<br class="calibre2"/></span><span class="calibre11"> done<br class="calibre2"/></span><span class="calibre11"> ARR[$INC]=$STR<br class="calibre2"/></span><span class="calibre11"> echo "${ARR[$INC]}"<br class="calibre2"/></span><span class="calibre11"> INC=$[$INC+1]<br class="calibre2"/></span><span class="calibre11">done</span></pre>
<ol start="4" class="calibre20">
<li class="chapter">Execute the script with <kbd class="calibre17">bash builtin-strng.sh</kbd><strong class="calibre3"> </strong><span class="calibre11">and review the output.</span></li>
</ol>
<div class="packt_infobox">Did you notice all of the opportunities to re-direct input or output? Imagine the possibilities! Furthermore, much of the previous script can be performed using another tool called AWK instead.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">This recipe is a bit iterative, but it should <em class="calibre18">re-iterate</em><strong class="calibre6"> </strong>(pardon the pun) to demonstrate that Bash has a fair number of functionalities built-in to manipulate strings or any structured data. There is a basic assumption though and that is based on many OSes using C programs:</span></p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre11">A string is an array of characters</span></li>
<li class="calibre14"><span class="calibre11">Characters such as <kbd class="calibre17">','</kbd> are the same as any other character </span></li>
<li class="calibre14">Therefore, we can evaluate or test for the existence of a character to separate fields from lines and even use this to build arrays</li>
</ul>
<p class="mce-root">Now, reviewing the steps in this recipe:</p>
<ol class="calibre20">
<li class="chapter">After running the script, we have the following output in the console:</li>
</ol>
<pre class="calibre27">$ builtin-str.sh<br class="calibre2"/>first character 1<br class="calibre2"/>first three characters 123<br class="calibre2"/>third character onwards 4567890asdfghjkl<br class="calibre2"/>forth to sixth character 456<br class="calibre2"/>last character l<br class="calibre2"/>STR2 is less than STR3<br class="calibre2"/>STR4 is greater than STR3</pre>
<p class="mce-root1">We began with the string <kbd class="calibre17">STR="1234567890asdfghjkl"</kbd><strong class="calibre6"> </strong>and as the script ran in the first step:</p>
<ul class="calibre13">
<li class="calibre14">In the first step, we printed out a single character starting at the zero (0) position. Remember that this is an array, and position <kbd class="calibre17">0</kbd> is the starting element.</li>
<li class="calibre14">Next, we retrieved the first three characters to arrive at: <kbd class="calibre17">123</kbd>.</li>
<li class="calibre14">However, what if we wanted all of the characters after position 3? We would used <kbd class="calibre17">${STR: 3}</kbd> instead of <kbd class="calibre17">${STR: 0-3}</kbd>.</li>
<li class="calibre14">Then, given the preceding point, if we wanted the characters at position 4 (the forth element in the array, but this is addressed at position three (3) because counting begins at zero (0)), we use <kbd class="calibre17">${STR: 3: 3}</kbd>.</li>
<li class="calibre14">And finally, to get only the last character, we can use <kbd class="calibre17">${STR:-1}</kbd>.</li>
</ul>
<p class="mce-root1">To finish the first script in the recipe, we had three more strings. If we wished to compare them to each other, we can do so using conditional logic. Remember that bcd is less than BCD.</p>
<div class="packt_infobox">Comparing strings using simple Bash constructs can be useful when you want to write a script that quickly compares filenames for a specified execution. For example, run the <kbd class="calibre23">001-test.sh</kbd> script before <kbd class="calibre23">002-test.sh</kbd>.</div>
<ol start="2" class="calibre20">
<li class="chapter">In the second half of the recipe, we begin with a long-winded script to duplicate in an easily explained manner. We covered some of the tricks you can use with the Bash shell without using AWK and SED:</li>
</ol>
<pre class="calibre27">$ ./builtin-strng.sh <br class="calibre2"/>We have 2 rows in testdata/garbage.csv<br class="calibre2"/>BOB,JANE,NAZ,SUE,MAX,TOM<br class="calibre2"/>ZERO,ALPHA,BETA,GAMA,DELTA,FOXTROT<br class="calibre2"/><br class="calibre2"/>We have 3 rows in testdata/employees.csv<br class="calibre2"/>#1000,Bob,Green,Dec,1,1967<br class="calibre2"/>#2000,Ron,Brash,Jan,20,1987<br class="calibre2"/>#3000,James,Fairview,Jul,15,1992<br class="calibre2"/><br class="calibre2"/>Let's make Bob, Robert!<br class="calibre2"/>#1000,Robert,Green,Dec,1,1967<br class="calibre2"/>#2000,Ron,Brash,Jan,20,1987<br class="calibre2"/>#3000,James,Fairview,Jul,15,1992<br class="calibre2"/><br class="calibre2"/>Lets remove the column: birthday (1-31)<br class="calibre2"/>#1000,Robert,Green,Dec,1967<br class="calibre2"/>#2000,Ron,Brash,Jan,1987<br class="calibre2"/>#3000,James,Fairview,Jul,1992</pre>
<p class="mce-root">Here is the breakdown of the script, but a brief introduction is required for <strong class="calibre6">arrays</strong>, <strong class="calibre6">readarray</strong>, <strong class="calibre6">IFS</strong>, and <strong class="calibre6">oldIFS. </strong>The point of the exercise is to not go into a great lesson on arrays (this will happen later), but to know that you can use them automatically to create dynamic lists of things such as files or lines within a file. They are referred to using the <kbd class="calibre17">${ARR[@]}</kbd> notation, and each element can be referred to by its index value within the square brackets <kbd class="calibre17">[...]</kbd>.</p>
<p class="mce-root">The <kbd class="calibre17">readarray</kbd> command parses the input into an array using the <kbd class="calibre17">IFS</kbd> and <kbd class="calibre17">oldIFS</kbd> variables. It separates the data based on a common delimiter (IFS), and oldIFS can maintain the old values, should they be altered:</p>
<ul class="calibre13">
<li class="calibre14">In the first step, we use read in the <kbd class="calibre17">garbage.csv</kbd> (<kbd class="calibre17">${GB_CSV}</kbd>) and then <kbd class="calibre17">${#ARR[@]}</kbd> to retrieve the number of elements in the array. We don't use this value, but it is interesting to note the structure of your file and whether it is being read in correctly. Then, for each member of the array, we remove the empty spaces by counting the number of spaces and then removing them with an additional while loop, performing <kbd class="calibre17">${i/, /,}</kbd><strong class="calibre3"> </strong>until we're done. The corrected values are then re-inserted into the array.</li>
<li class="calibre14">In the next step, we use <kbd class="calibre17">${i::-1}</kbd> and a for loop to remove the last character from each line. Then, the result is re-inserted into the array.</li>
<li class="calibre14">Using a <kbd class="calibre17">for</kbd> loop and <kbd class="calibre17">ARR[$INC]=${i^^}</kbd>, all characters in the array are made uppercase, and we print out the array using <kbd class="calibre17">printf </kbd>(more on this later in another recipe).</li>
<li class="calibre14">On to <kbd class="calibre17">employees.csv</kbd>, we read it into the array again using <kbd class="calibre17">readarray.</kbd> Then, we add a hash sign (<kbd class="calibre17">#</kbd>) to the beginning of each line and re-insert it into the <kbd class="calibre17">ARR[$INC]="#${i}"</kbd> array.</li>
<li class="calibre14">Then, we search for the substring <kbd class="calibre17">Bob</kbd> and replace it with <kbd class="calibre17">ARR[$INC]=${i/Bob/Robert} </kbd>. To use the built-in search and replace functionality, we use the following syntax: <strong class="calibre3"><kbd class="calibre17">${variable/valueToFind/valueToReplaceWith}</kbd></strong>. Notice that this is also the same premise behind the space removal performed in an earlier step.</li>
<li class="calibre14">The final step is a bit more complicated and a bit <em class="calibre26">long in the tooth</em>, meaning it could be shortened and performed using another tool such as AWK, but for the purpose of an easy to read example—it was written a bit like a C program. Here, we want to remove the actual birthday value (0-31), or column 5 (the index is 4 if we consider that arrays begin at 0). To begin, we iterate through the array using a for loop, and then we use read to take the input value as an array, too! Then, for each field in the array <kbd class="calibre17">${ELEM_ARR[@]}</kbd>, we then check to see if it is not the first value, and also not the column we wish to remove. We build the correct string via concatenation and then re-insert it into the array before printing each value using <kbd class="calibre17">echo</kbd>.</li>
</ul>
<div class="packt_tip"><strong class="calibre3">Arrays</strong> are a data construct and the important thing to think about data is that it can be manipulated in a number of ways. Just like how we split a file line by line to create an array of elements, we can also split those elements into arrays of their own!</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using SED and AWK to remove/replace substrings</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Again, when we need to remove a pesky character or remove sections of strings upon </span>occurrence, we can always rely on these two powerful commands: <kbd class="calibre17">sed</kbd><strong class="calibre6"> </strong>and <kbd class="calibre17">awk</kbd>. And while we saw that Bash does indeed have a similar functionality built-in, the full tools are able to offer the same and more complex functionality. So, when should we use these tools?</p>
<ul class="calibre13">
<li class="calibre14">When we care less about the speed that might be gained by using the built-in functionality of Bash</li>
<li class="calibre14">When more complex features are needed (when programming constructs like multi-dimensional arrays are required or editing streams)</li>
<li class="calibre14">When we are focused on portability (Bash might be embedded or a limited version and standalone tools may be required)</li>
</ul>
<div class="packt_infobox">Complete books have been written on both SED and AWK, and you can always find far more information online at <a href="https://www.gnu.org/software/sed/" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://www.gnu.org/software/sed/</a> and <a href="https://www.gnu.org/software/gawk/" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://www.gnu.org/software/gawk/</a>.</div>
<p class="mce-root"><strong class="calibre6">Stream editor</strong> (<strong class="calibre6">SED</strong>) is a handy text manipulation tool that is great for one-liners and offers a simple programming language and regex matching. Alternatively, AWK is also powerful and arguably more than SED. It offers a more complete programming language with a variety of data structures and other constructs. However, it is better suited when working with files such as CSVs, which may contain fields or structured data, but SED can be better when working with text substitutions when working with pipes (for example, <kbd class="calibre17">grep X | sed ... &gt; file.txt</kbd>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's get ready for this exercise by creating some data sets which mimic common daily problems:</span></p>
<pre class="calibre22">$ rmdir testdata; mkdir -p testdata<br class="calibre2"/>$ echo "Bob, Jane, Naz, Sue, Max, Tom$" &gt; testdata/garbage.csv <br class="calibre2"/>$ echo "Bob, Jane, Naz, Sue, Max, Tom#" &gt;&gt; testdata/garbage.csv <br class="calibre2"/>$ echo "1000,Bob,Green,Dec,1,1967" &gt; testdata/employees.csv<br class="calibre2"/>$ echo" 2000,Ron,Brash,Jan,20,1987" &gt;&gt; testdata/employees.csv<br class="calibre2"/>$ echo "3000,James,Fairview,Jul,15,1992" &gt;&gt; testdata/employees.csv</pre>
<p class="mce-root"><span class="calibre16">Using these two CSVs, we are going to:</span></p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre11">Remove the extra spaces on the first two lines of <kbd class="calibre17">garbage.csv</kbd></span></li>
<li class="calibre14">Remove the last character from each line in <kbd class="calibre17"><span class="calibre11">garbage.csv</span></kbd></li>
<li class="calibre14">Change the case of each character to uppercase in the first two lines of <kbd class="calibre17">garbage.csv</kbd></li>
<li class="calibre14">Replace <kbd class="calibre17">Bob</kbd> with <kbd class="calibre17">Robert</kbd> in <kbd class="calibre17">employees.csv</kbd></li>
<li class="calibre14">Insert a <kbd class="calibre17">#</kbd> at the beginning of each line in <kbd class="calibre17">employees.csv</kbd></li>
<li class="calibre14">Remove the exact date of the birth column/field in each line of <kbd class="calibre17">employees.csv</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">As with the exercise using Bash only, we are going to perform a similar recipe as follows:</span></p>
<p class="mce-root">Create a script called <kbd class="calibre17">some-strs.sh</kbd><strong class="calibre6"> </strong>with the following content and open a new terminal:</p>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/>STR="1234567890asdfghjkl"<br class="calibre2"/>echo -n "First character "; sed 's/.//2g' &lt;&lt;&lt; $STR # where N = 2 (N +1)<br class="calibre2"/>echo -n "First three characters "; sed 's/.//4g' &lt;&lt;&lt; $STR<br class="calibre2"/><br class="calibre2"/>echo -n "Third character onwards "; sed -r 's/.{3}//' &lt;&lt;&lt; $STR<br class="calibre2"/>echo -n "Forth to sixth character "; sed -r 's/.{3}//;s/.//4g' &lt;&lt;&lt; $STR<br class="calibre2"/><br class="calibre2"/>echo -n "Last character by itself "; sed 's/.*\(.$\)/\1/' &lt;&lt;&lt; $STR<br class="calibre2"/>echo -n "Remove last character only "; sed 's/.$//' &lt;&lt;&lt; $STR</pre>
<p class="mce-root">Execute the script and review the results.</p>
<p class="mce-root">Create another script called <kbd class="calibre17">more-strsng.sh</kbd> and then execute it:</p>
<pre class="calibre27">#!/bin/sh<br class="calibre2"/>GB_CSV="testdata/garbage.csv"<br class="calibre2"/>EM_CSV="testdata/employees.csv"<br class="calibre2"/># Let's strip the garbage out of the last lines in the CSV called garbage.csv<br class="calibre2"/># Notice the forloop; there is a caveat<br class="calibre2"/><br class="calibre2"/>set IFS=,<br class="calibre2"/>set oldIFS = $IFS<br class="calibre2"/>readarray -t ARR &lt; ${GB_CSV}<br class="calibre2"/><br class="calibre2"/># How many rows do we have?<br class="calibre2"/>ARRY_ELEM=${#ARR[@]}<br class="calibre2"/>echo "We have ${ARRY_ELEM} rows in ${GB_CSV}"<br class="calibre2"/><br class="calibre2"/># Let's strip the garbage - remove spaces<br class="calibre2"/>INC=0<br class="calibre2"/>for i in "${ARR[@]}"<br class="calibre2"/>do<br class="calibre2"/>   : <br class="calibre2"/>  ARR[$INC]=$(echo $i | sed 's/ //g')<br class="calibre2"/>  echo "${ARR[$INC]}"<br class="calibre2"/>  INC=$[$INC+1]<br class="calibre2"/>done<br class="calibre2"/><br class="calibre2"/># Remove the last character and make ALL upper case<br class="calibre2"/>INC=0<br class="calibre2"/>for i in "${ARR[@]}"<br class="calibre2"/>do<br class="calibre2"/>   : <br class="calibre2"/>  ARR[$INC]=$(echo $i | sed 's/.$//' | sed -e 's/.*/\U&amp;/' )<br class="calibre2"/>  echo "${ARR[$INC]}"<br class="calibre2"/>  INC=$[$INC+1]<br class="calibre2"/>done<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/></pre>
<p class="mce-root">We w<span class="calibre16">ant to add a <kbd class="calibre17">#</kbd> at the beginning of each line and we will also use the</span> <span class="calibre16"><kbd class="calibre17">sed</kbd> tool on a per file basis. We just w</span><span class="calibre16">ant to strip Bob out and change his name to Robert by manipulating</span> <span class="calibre16">the file in-place:</span></p>
<pre class="calibre22"><span class="calibre11">set IFS=,<br class="calibre2"/>set oldIFS = $IFS<br class="calibre2"/>readarray -t ARR &lt; ${EM_CSV}<br class="calibre2"/><br class="calibre2"/>INC=0<br class="calibre2"/>for i in "${ARR[@]}"<br class="calibre2"/>do<br class="calibre2"/> : <br class="calibre2"/> ARR[$INC]=$(sed -e 's/^/#/' &lt;&lt;&lt; $i )<br class="calibre2"/> echo "${ARR[$INC]}"<br class="calibre2"/> INC=$[$INC+1]<br class="calibre2"/>done<br class="calibre2"/><br class="calibre2"/>sed -i 's/Bob/Robert/' ${EM_CSV}<br class="calibre2"/></span><span class="calibre11">sed -i 's/^/#/' ${EM_CSV} # In place, instead of on the data in the array<br class="calibre2"/></span><span class="calibre11">cat ${EM_CSV}<br class="calibre2"/></span><span class="calibre11"># Now lets remove the birthdate field from the files<br class="calibre2"/></span><span class="calibre11"># Starts to get more complex, but is done without a loop or using cut<br class="calibre2"/></span><span class="calibre11">awk 'BEGIN { FS=","; OFS="," } {$5="";gsub(",+",",",$0)}1' OFS=, ${EM_CSV}</span></pre>
<p class="mce-root">Examine the results<span class="calibre16">—</span>was it simpler to get the results to the recipes that leverage only bash built-in constructs? Likely yes in many situations, IF they are available.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">After running the two scripts in this recipe, we can see a few items emerge (especially if we compare the built-in Bash functionality for searching, replacing, and substrings).</p>
<ol class="calibre20">
<li class="chapter">After executing <kbd class="calibre17">some-strs.sh</kbd>, we can see the following output in the console:</li>
</ol>
<pre class="calibre27">$ bash ./some-strs.sh <br class="calibre2"/>First character 1<br class="calibre2"/>First three characters 123<br class="calibre2"/>Third character onwards 4567890asdfghjkl<br class="calibre2"/>Forth to sixth character 456<br class="calibre2"/>Last character by itself l<br class="calibre2"/>Remove last character only 1234567890asdfghjk</pre>
<p class="calibre30">At this point, we have seen the <kbd class="calibre17">echo</kbd> command used several times, but the <kbd class="calibre17">-n</kbd> flag means that we should not automatically create a new line (or carriage return). The <kbd class="calibre17">&lt;&lt;&lt;</kbd> re-direct for inputting values as a string has also been previously used, so this should not be new information. Given that, in the first instance, we are using <kbd class="calibre17">sed</kbd> like this: <kbd class="calibre17">sed 's/.//2g' &lt;&lt;&lt; $STR</kbd> . This script uses <kbd class="calibre17">sed</kbd> in very simple ways compared to the plethora of ways you can combine pure sed with regexs. First, you have the command (<kbd class="calibre17">sed</kbd>), then the parameters (<span class="calibre16"><kbd class="calibre17">'s/.//2g'</kbd>), and then the</span> input (<kbd class="calibre17"><span class="calibre11">&lt;&lt;&lt; $STR</span></kbd>). You can also combine parameters like this: <span class="calibre16"><kbd class="calibre17">'s/.//2g;s/','/'.'/g'</kbd> . To get the first character, we use <kbd class="calibre17">sed</kbd> in substitute mode (<kbd class="calibre17">s/</kbd>) and we retrieve two characters using (<kbd class="calibre17">/2g</kbd>), where <kbd class="calibre17">g</kbd> stands for global pattern.</span></p>
<p class="calibre30"><span class="calibre16">The reason it is <kbd class="calibre17">2g</kbd> and not <kbd class="calibre17">1g</kbd> is that a null byte is returned automatically and therefore, if you desire <em class="calibre18">n</em> characters then you must specify <em class="calibre18">n+1</em> characters. To return the first three characters, we merely change the</span> <kbd class="calibre17">sed</kbd> parameters to include <kbd class="calibre17">4g</kbd> instead of <kbd class="calibre17">2g.</kbd></p>
<p class="calibre30">In the next block of the script, we use sed as follows: <kbd class="calibre17">sed -r 's/.{3}//'</kbd> and <kbd class="calibre17">sed -r '$s/.{3}//;s/.//4g'</kbd> . You can see that in the first execution of <kbd class="calibre17">sed</kbd>, <kbd class="calibre17">-r</kbd> is used to specify a regex and so we use the regex to return the string at position 4 (again, those pesky arrays and strings) and everything beyond. In the second instance, we combine starting at the third character but limit the output to only 3 characters.</p>
<p class="calibre30">In the third block of script, we want the final character of the string using <kbd class="calibre17">sed 's/.*\(.$\)/\1/'</kbd> and then get the entire string <em class="calibre18">except</em> the last character using <kbd class="calibre17">sed 's/.$//'</kbd>. In the first instance, we use grouping and wildcards to create the regular expression to return only one character (the last character in the string), and in the second instance, we use the <kbd class="calibre17">.$</kbd> pattern to create an expression that returns everything minus the last character.</p>
<div class="packt_tip">It is important to note that search and replace can also be used for deletion operations by specifying an empty value to replace. You can also use the <kbd class="calibre23">-i</kbd> flag for in-place edits and to also perform deletion using other flags/parameters.</div>
<ol start="2" class="calibre20">
<li class="chapter">Onto the next script, and after execution, the console should look similar to the following:</li>
</ol>
<pre class="calibre27">$ bash more-strsng.sh <br class="calibre2"/>We have 2 rows in testdata/garbage.csv<br class="calibre2"/>Bob,Jane,Naz,Sue,Max,Tom$<br class="calibre2"/>Zero,Alpha,Beta,Gama,Delta,Foxtrot#<br class="calibre2"/>BOB,JANE,NAZ,SUE,MAX,TOM<br class="calibre2"/>ZERO,ALPHA,BETA,GAMA,DELTA,FOXTROT<br class="calibre2"/>#1000,Robert,Green,Dec,1,1967<br class="calibre2"/>#2000,Ron,Brash,Jan,20,1987<br class="calibre2"/>#3000,James,Fairview,Jul,15,1992<br class="calibre2"/>#1000,Robert,Green,Dec,1,1967<br class="calibre2"/>#2000,Ron,Brash,Jan,20,1987<br class="calibre2"/>#3000,James,Fairview,Jul,15,1992<br class="calibre2"/>#1000,Robert,Green,Dec,1967<br class="calibre2"/>#2000,Ron,Brash,Jan,1987<br class="calibre2"/>#3000,James,Fairview,Jul,1992</pre>
<p class="mce-root">Again, in the first block of code, we read in the CSV into an array and for each element, we perform a substitution to remove the spaces: <kbd class="calibre17">sed 's/ //g'</kbd>. </p>
<p class="mce-root">In the second block, again, we iterate through the array, but we remove the last character, <kbd class="calibre17">sed  's/.$//'</kbd>, and then pipe the output to convert everything to uppercase using <kbd class="calibre17">sed -e 's/.*/\U&amp;/'</kbd>. In the first part of the pipe, we search for the last character using <kbd class="calibre17">.$</kbd> and remove it (the <kbd class="calibre17">//</kbd>). Then, we use an expression to select everything and convert it to upper case using <kbd class="calibre17">\U&amp;</kbd> (notice that it is a special case allowed by GNU sed). Lowercase can be achieved using <kbd class="calibre17">\L&amp;</kbd> instead.</p>
<p class="mce-root">In the third block, again, we used a for each loop and a subshell, but we didn't echo the input into <kbd class="calibre17">sed.</kbd> Sed also takes input like this using the <kbd class="calibre17">&lt;&lt;&lt;</kbd> input direction. Using <kbd class="calibre17">sed -e 's/^/#/'</kbd>, we start at the beginning of the string (specified by the <kbd class="calibre17">^</kbd>) and append a <kbd class="calibre17">#</kbd>.</p>
<p class="mce-root">Next, for the last three examples, we perform work on the actual files themselves and <em class="calibre18">not</em> the arrays loaded into memory by using <kbd class="calibre17">sed</kbd> with the <kbd class="calibre17">-i</kbd> flag. This is an important distinction as it will have direct consequences on the files used as input; this is probably what you desire in your scripts anyway!<strong class="calibre6"> </strong>To replace <kbd class="calibre17">Bob</kbd> with <kbd class="calibre17">Robert,</kbd> it is the same as removing spaces except we specify the replacement. However, we are performing the replacement on the <em class="calibre18">entire</em> input CSV file! We can also add the hash sign for each line in the file, too.</p>
<p class="mce-root">In the final example, we briefly use AWK to show the power of this utility. In this example, we specify the delimiters (FS and OFS) and then we specify the fifth column alongside the <kbd class="calibre17">gsub sub</kbd> command in the AWK language to remove the column or field. Begin specifies the rules AWK shall use when parsing input and if there are multiple rules, the order received is the order executed.</p>
<p class="mce-root">Alternatively, we can print the first column or field using <kbd class="calibre17">awk 'BEGIN { FS=","} { print $1}'  testdata/employees.csv</kbd> and even the first occurrence by specifying <kbd class="calibre17">NR==1</kbd> like this: <kbd class="calibre17">awk ' BEGIN { FS=","} NR==1{ print $1}' </kbd>. Specifying the number or returned records is very useful when using the <kbd class="calibre17">grep</kbd> command and copious amounts of matches are returned.</p>
<div class="packt_infobox">Again, there is so much you can do with AWK and SED. Combined with regular expressions (regexes), explanations and examples of all sorts of usage could fill a book dedicated to each command. You can check out the tools available in the documentation on the web so that you are aware of some platform differences.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Formatting your data/output using echo and printf</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Sometimes, finding the string or the exact data you are looking for is the easy part of your task, but formatting the output data is tricky. For example, here are some situations that have subtle elements that need to be altered:</p>
<ul class="calibre13">
<li class="calibre14">Echoing output without the newline terminator (\n)</li>
<li class="calibre14">Echoing raw hexadecimal (hex) data</li>
<li class="calibre14">Printing raw hexadecimal values and printable ASCII characters</li>
<li class="calibre14">Concatenating strings</li>
<li class="calibre14">Escaping specific characters</li>
<li class="calibre14">Aligning text</li>
<li class="calibre14">Printing horizontal rules</li>
</ul>
<p class="mce-root"><span class="calibre16">In addition to tricks, we can also print values to the screen that are also floats as well (in addition to the recipe for math). Wait, what is a hexadecimal number? Yes, another type of data or at least a representation exists. To understand what hexadecimals are, we first need to remember that computers use <strong class="calibre6">binary</strong>, which consists of 1s and 0s (ones and zeros). However, binary is not very friendly to us humans (we use the decimal format when looking at numbers typically), so other representations are sometimes needed, one of which is called <strong class="calibre6">hexadecimal.</strong> As you have probably guessed, it is base 16 so it looks like 0x0 to 0xF (0x0,0x1, ... ,0x9,0xA,0xB, ..., 0XF). Here is an example:</span></p>
<pre class="calibre22">$ echo -en '\xF0\x9F\x92\x80\n'<br class="calibre2"/><img src="Images/5e50e7ee-985a-4b1d-aa99-d8d677df2e4c.png" width="894" height="913" class="calibre31"/><br class="calibre2"/>$ printf '\xF0\x9F\x92\x80\n'<br class="calibre2"/><img src="Images/5e50e7ee-985a-4b1d-aa99-d8d677df2e4c.png" width="894" height="913" class="calibre31"/></pre>
<p class="mce-root">In the preceding example, both <kbd class="calibre17">printf</kbd> and <kbd class="calibre17">echo</kbd> can be used to print raw hex and Unicode characters. Using a Unicode reference, I found the UTF-8 encoding for the <strong class="calibre6">skull </strong>character (<kbd class="calibre17">F0 9F 92 80</kbd>) and then formatted it using <kbd class="calibre17">\xFF</kbd>. Notice where FF is; it is in each <strong class="calibre6">byte</strong>.</p>
<div class="packt_tip">What can you do knowing about "raw hex" values? Well, you can send characters that the shell can interpret differently, or you can print neat things! See <a href="https://unicode-table.com" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">unicode-table.com</a> for more detail.</div>
<p class="mce-root">Wait, another term called a <strong class="calibre6">byte</strong>? Yes, and here is another one called a <strong class="calibre6">bit.</strong> A <strong class="calibre6">bit </strong>is the form because it refers to either a 0 or 1, but a <strong class="calibre6">byte is 8 bits</strong> (one byte is made up of eight bits! Get it?).</p>
<div class="packt_infobox">As a side note, depending on the platform or measurement<span class="calibre11">—</span>be aware that 1 kilobyte or KB can mean 1,024 Bytes (B) or on many marketing datasheets, 1 KB= 1,000 B. Furthermore, when you see Kb<span class="calibre11">—</span>it does NOT mean kilobytes. It means <strong class="calibre3">Kilo</strong> <strong class="calibre3">bits!</strong></div>
<div class="packt_tip">Again, being aware of computational basics such as types of data and conversion between basic data forms is a very useful tool to have in your skill set. It might even be in a job interview or two!</div>
<p class="mce-root">However, we are getting a bit ahead of ourselves<span class="calibre16">—</span>what is <kbd class="calibre17">echo</kbd> and <kbd class="calibre17">printf</kbd>? Both are commands which you may have seen earlier in this cookbook that allow you to output the contents of variables and more to the console or even to a file. <strong class="calibre6">Echo</strong> is far more "straightforward", but <strong class="calibre6">printf</strong> can provide the same and more functionality using C style parameters. In fact, one of the main features of printf over echo is that printf can format characters, pad them, and even align them.</p>
<p class="mce-root">Alright; let's get to work.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For this exercise, no extra tools or scripts are required<span class="calibre16">—</span>just you, your terminal, and Bash.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's begin our activity as follows:</span></p>
<ol class="calibre20">
<li class="chapter">O<span class="calibre11">pen up a new script called</span> <kbd class="calibre17">echo-mayhem.sh</kbd> <span class="calibre11">in your favorite editor and a new terminal. Enter the following contents and then execute the script at the prompt:</span></li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/><br class="calibre2"/># What about echo?<br class="calibre2"/>echo -n "Currently we have seen the command \"echo\" used before"<br class="calibre2"/>echo " in the previous script"<br class="calibre2"/>echo<br class="calibre2"/>echo -n "Can we also have \t tabs? \r\n\r\n?"<br class="calibre2"/>echo " NO, not yet!"<br class="calibre2"/>echo<br class="calibre2"/>echo -en "Can we also have \t tabs? \r\n\r\n?"<br class="calibre2"/>echo " YES, we can now! enable interpretation of backslash escapes"<br class="calibre2"/>echo "We can also have:"<br class="calibre2"/>echo -en '\xF0\x9F\x92\x80\n' # We can also use \0NNN for octal instead of \xFF for hexidecimal<br class="calibre2"/>echo "Check the man pages for more info ;)"</pre>
<ol start="2" class="calibre20">
<li class="chapter">After reviewing the results of <kbd class="calibre17">echo-mayhem.sh</kbd>, create another script called <kbd class="calibre17">printf-mayhem</kbd> and enter the following contents:</li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/>export LC_NUMERIC="en_US.UTF-8"<br class="calibre2"/>printf "This is the same as echo -e with a new line (\\\n)\n"<br class="calibre2"/><br class="calibre2"/>DECIMAL=10.0<br class="calibre2"/>FLOAT=3.333333<br class="calibre2"/>FLOAT2=6.6666 # On purpose two missing values<br class="calibre2"/><br class="calibre2"/>printf "%s %.2f\n\n" "This is two decimal places: " ${DECIMAL}<br class="calibre2"/><br class="calibre2"/>printf "shall we align: \n\n %.3f %-.6f\n" ${FLOAT} ${FLOAT2}<br class="calibre2"/>printf " %10f %-6f\n" ${FLOAT} ${FLOAT2}<br class="calibre2"/>printf " %-10f %-6f\n" ${FLOAT} ${FLOAT2}<br class="calibre2"/><br class="calibre2"/># Can we also print other things?<br class="calibre2"/>printf '%.0s-' {1..20}; printf "\n"<br class="calibre2"/><br class="calibre2"/># How about we print the hex value and a char for each value in a string?<br class="calibre2"/>STR="No place like home!"<br class="calibre2"/>CNT=$(wc -c &lt;&lt;&lt; $STR})<br class="calibre2"/>TMP_CNT=0<br class="calibre2"/><br class="calibre2"/>printf "Char Hex\n"<br class="calibre2"/><br class="calibre2"/>while [ ${TMP_CNT} -lt $[${CNT} -1] ]; do<br class="calibre2"/>  printf "%-5s 0x%-2X\n" "${STR:$TMP_CNT:1}" "'${STR:$TMP_CNT:1}" <br class="calibre2"/>  TMP_CNT=$[$TMP_CNT+1]<br class="calibre2"/>done</pre>
<ol start="3" class="calibre20">
<li class="chapter">Execute the contents of <kbd class="calibre17">printf-mayhem.sh</kbd> and review the contents for subtle differences.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">While this is a pretty important topic revolving around data types (especially when dealing with math or calculations), we broke the solution to this recipe up into two parts:</span></p>
<ol class="calibre20">
<li class="chapter">In step 1, echo is pretty straightforward. We have mentioned in the past that there are special characters and escapes. <kbd class="calibre17">\t</kbd> stands for tab <kbd class="calibre17">\r\n</kbd> a new line in Windows (although in Linux, <kbd class="calibre17">\n\n</kbd> would have sufficed) and again, we could print out a fancy UTF character:</li>
</ol>
<pre class="calibre27">$ bash echo-mayhem.sh <br class="calibre2"/>Currently we have seen the command "echo" used before in the previous script<br class="calibre2"/><br class="calibre2"/>Can we also have \t tabs? \r\n\r\n? NO, not yet!<br class="calibre2"/><br class="calibre2"/>Can we also have       tabs? <br class="calibre2"/><br class="calibre2"/>? YES, we can now! enable interpretation of backslash escapes<br class="calibre2"/>We can also have:<br class="calibre2"/><img src="Images/8748fc27-57d7-4674-bae9-56cea51a6ff9.png" width="894" height="913" class="calibre31"/><br class="calibre2"/>Check the man pages for more info ;)</pre>
<ol start="2" class="calibre20">
<li class="chapter">However, the results of step 2 are a bit different, as we can see in the following code. Let's explore this a bit more as it looks like it's a bit more than sloppy alignment:</li>
</ol>
<pre class="calibre27">$ bash printf-mayhem.sh <br class="calibre2"/>This is the same as echo -e with a new line (\n)<br class="calibre2"/>This is two decimal places: 10.00<br class="calibre2"/><br class="calibre2"/>shall we align: <br class="calibre2"/><br class="calibre2"/> 3.333 6.666600<br class="calibre2"/>   3.333333 6.666600<br class="calibre2"/> 3.333333 6.666600<br class="calibre2"/>--------------------<br class="calibre2"/>Char Hex<br class="calibre2"/>N 0x4E<br class="calibre2"/>o 0x6F<br class="calibre2"/>  0x20<br class="calibre2"/>p 0x70<br class="calibre2"/>l 0x6C<br class="calibre2"/>a 0x61<br class="calibre2"/>c 0x63<br class="calibre2"/>e 0x65<br class="calibre2"/>  0x20<br class="calibre2"/>l 0x6C<br class="calibre2"/>i 0x69<br class="calibre2"/>k 0x6B<br class="calibre2"/>e 0x65<br class="calibre2"/>  0x20<br class="calibre2"/>h 0x68<br class="calibre2"/>o 0x6F<br class="calibre2"/>m 0x6D<br class="calibre2"/>e 0x65<br class="calibre2"/>! 0x21<br class="calibre2"/>  0x0 </pre>
<ol start="3" class="calibre20">
<li class="chapter">As we can see, in the preceding step after execution, there are a few interesting things. The first thing we notice is that <kbd class="calibre17">printf</kbd> is echo on steroids; it provides the same functionality and far more such as alignment, strings being printed with <kbd class="calibre17">%s</kbd>, and decimal places (for example, <kbd class="calibre17">%.2f</kbd>). As we dig deeper, we can see that we can limit the number of decimal places using a % after the <kbd class="calibre17">%tag</kbd>. Notice the single character usually immediately after the <kbd class="calibre17">%</kbd> sign<span class="calibre11">—</span>this is how you format the following parameters. Using a value like <kbd class="calibre17">%10f</kbd>, we are dedicating 10 spaces to the value, or rather, the width of 10 characters. If we use <kbd class="calibre17">%-10</kbd>, then it means we are aligning the value to the left. And besides the near horizontal rule, which uses expansion, we also "stepped" our way through the string "No place like home!". Using a <kbd class="calibre17">while</kbd> loop, we print out each ASCII character using (<kbd class="calibre17">%-c</kbd>) with its corresponding hexadecimal value (<kbd class="calibre17">%-2X</kbd>).</li>
</ol>
<div class="packt_tip">Notice that even spaces have a hexadecimal (hex) value, and that is <kbd class="calibre23">0x20.</kbd> If you ran the script and got <kbd class="calibre23">"printf-mayhem.sh: line 26: printf: !: invalid number"</kbd>, this is because you missed the single <kbd class="calibre23">' </kbd>in <kbd class="calibre23">"'${STR:$TMP_CNT:1}"</kbd>. This signifies how to interpret the returned value as either a string/character or numeric value.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Readying your script for different languages with internationalization</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Great, so you have this awesome script, but it's written in standard English and you would like to target those nice people who speak other languages. In some countries like Canada, they (we) have two official languages: English and French. Sometimes, the dual-language component is enforced with legislature and localized language laws. </p>
<p class="mce-root">To get around this, let's imagine a scenario where you are an individual who has written a script that prints out specific strings, but in English first. He/she wishes to have all of the strings inside of variables so that they can be swapped in and out dynamically using system language variables. Here are the basics:</p>
<ul class="calibre13">
<li class="calibre14">Create a shell script that utilizes <strong class="calibre3">gettext </strong>and sets the appropriate variables</li>
<li class="calibre14">Build a <strong class="calibre3">po </strong>file that contains the necessary language definitions</li>
<li class="calibre14">Install your output language localization file for your script</li>
<li class="calibre14">Run your script with a language that's different than the one you originally use (by setting the LANG variable)</li>
</ul>
<p class="mce-root">Before getting started, though, there are two terms that need to be discussed: internationalization (i18n) and localization (L10n). Internationalization is a process that enables translation and localisation/adaptation for a specific script or program, and localization refers to the process of having adapted the program/application for a specific culture.</p>
<div class="packt_infobox">The translation of scripts from the start can be an effective way to save time and improve the success of multi-lingual efforts. However, be aware that it can be a time-consuming process if the developers are fluent in only one language, or translation skills are not immediately present.</div>
<p class="mce-root">For example, in English, there are several dialects. In the USA, a product of a process or leftover can be called an <strong class="calibre6">artifact</strong>, but in Canadian English, it may be called an <strong class="calibre6">artefact</strong>. It could go unnoticed (or ignored), but the program could automatically adapt with specific localization.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's get ready for the exercise by ensuring that we have the following applications and supporting libraries installed:</span></p>
<pre class="calibre22">$ sudo apt-get install -y gettext</pre>
<p class="mce-root">Next, verify your language environment variables (LANG):</p>
<pre class="calibre22">$ locale<br class="calibre2"/>LANG=en_CA:en<br class="calibre2"/>LANGUAGE=en_CA:en<br class="calibre2"/>LC_CTYPE="en_CA:en"<br class="calibre2"/>LC_NUMERIC="en_CA:en"<br class="calibre2"/>LC_TIME="en_CA:en"<br class="calibre2"/>LC_COLLATE="en_CA:en"<br class="calibre2"/>LC_MONETARY="en_CA:en"<br class="calibre2"/>LC_MESSAGES="en_CA:en"<br class="calibre2"/>LC_PAPER="en_CA:en"<br class="calibre2"/>LC_NAME="en_CA:en"<br class="calibre2"/>LC_ADDRESS="en_CA:en"<br class="calibre2"/>LC_TELEPHONE="en_CA:en"<br class="calibre2"/>LC_MEASUREMENT="en_CA:en"<br class="calibre2"/>LC_IDENTIFICATION="en_CA:en"<br class="calibre2"/>LC_ALL=</pre>
<p class="mce-root">We're assuming your environment probably has some form of English set as the default (<kbd class="calibre17">en_CA:en</kbd> is Canadian English)<span class="calibre16">—</span>keep note of the values returned for later!</p>
<div class="packt_tip">You may need to recover your language and locale settings later if something goes wrong. There are many posts on the internet, but a few hints are: <kbd class="calibre23">$ export LC_ALL="en_US.UTF-8"</kbd>; <kbd class="calibre23">sudo locale-gen</kbd>; and <kbd class="calibre23">sudo dpkg-reconfigure locales</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's begin our activity as follows:</span></p>
<ol class="calibre20">
<li class="chapter">Open a new terminal and create a new script called <kbd class="calibre17">hellobonjour.sh</kbd><strong class="calibre3"> </strong>with the following contents:</li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/>. gettext.sh<br class="calibre2"/>function i_have() {<br class="calibre2"/>  local COUNT=$1<br class="calibre2"/>  ###i18n: Please leave $COUNT as is<br class="calibre2"/>  echo -e "\n\t" $(eval_ngettext "I have \$COUNT electronic device" "I have \$COUNT electronic devices" $COUNT)<br class="calibre2"/><br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>echo $(gettext "Hello")<br class="calibre2"/>echo<br class="calibre2"/><br class="calibre2"/>echo $(gettext "What is your name?")<br class="calibre2"/>echo<br class="calibre2"/><br class="calibre2"/>###i18n: Please leave $USER as is<br class="calibre2"/>echo -e "\t" $(eval_gettext "My name is \$USER" )<br class="calibre2"/>echo<br class="calibre2"/><br class="calibre2"/>echo $(gettext "Do you have electronics?")<br class="calibre2"/><br class="calibre2"/>i_have 0<br class="calibre2"/>i_have 1<br class="calibre2"/>i_have 2<br class="calibre2"/><br class="calibre2"/></pre>
<ol start="2" class="calibre20">
<li class="chapter">Run <kbd class="calibre17">xgettext</kbd> to generate the appropriate strings. We will not use the results, but this is how you can generate a minimalist PO file:</li>
</ol>
<pre class="calibre27">$ xgettext --add-comments='##i18n' -o hellobonjour_fr.po hellobonjour.sh --omit-header</pre>
<ol start="3" class="calibre20">
<li class="chapter">Copy the already compiled list of strings into the language PO file called <kbd class="calibre17">hellobonjour_fr.po</kbd>:</li>
</ol>
<pre class="calibre27"># Hellobonjour.sh<br class="calibre2"/># Copyright (C) 2017 Ron Brash<br class="calibre2"/># This file is distributed under the same license as the PACKAGE package.<br class="calibre2"/># Ron Brash &lt;ron.brash@gmail.com&gt;, 2017<br class="calibre2"/># Please ignore my terrible google translations; <br class="calibre2"/># As always, some is better than none!<br class="calibre2"/>#, fuzzy<br class="calibre2"/>msgid ""<br class="calibre2"/>msgstr ""<br class="calibre2"/>"Project-Id-Version: 1.0\n"<br class="calibre2"/>"Report-Msgid-Bugs-To: i18n@example.com\n"<br class="calibre2"/>"POT-Creation-Date: 2017-12-08 12:19-0500\n"<br class="calibre2"/>"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"<br class="calibre2"/>"Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n"<br class="calibre2"/>"Language-Team: French Translator &lt;fr@example.org&gt;\n"<br class="calibre2"/>"Language: fr\n"<br class="calibre2"/>"MIME-Version: 1.0\n"<br class="calibre2"/>"Content-Type: text/plain; charset=iso-8859-1\n"<br class="calibre2"/>"Content-Transfer-Encoding: 8bit\n"<br class="calibre2"/><br class="calibre2"/>#. ##i18n: Please leave $COUNT as is<br class="calibre2"/>#: hellobonjour.sh:6<br class="calibre2"/>#, sh-format<br class="calibre2"/>msgid "I have $COUNT electronic device"<br class="calibre2"/>msgid_plural "I have $COUNT electronic devices"<br class="calibre2"/>msgstr[0] "J'ai $COUNT appareil electronique"<br class="calibre2"/>msgstr[1] "J'ai $COUNT appareils electroniques"<br class="calibre2"/><br class="calibre2"/>#: hellobonjour.sh:10<br class="calibre2"/>msgid "Hello"<br class="calibre2"/>msgstr "Bonjour"<br class="calibre2"/><br class="calibre2"/>#: hellobonjour.sh:13<br class="calibre2"/>msgid "What is your name?"<br class="calibre2"/>msgstr "Comment t'appelles tu?"<br class="calibre2"/><br class="calibre2"/>#. ##i18n: Please leave $USER as is<br class="calibre2"/>#: hellobonjour.sh:17<br class="calibre2"/>#, sh-format<br class="calibre2"/>msgid "My name is $USER"<br class="calibre2"/>msgstr "Mon nom est $USER"<br class="calibre2"/><br class="calibre2"/>#: hellobonjour.sh:20<br class="calibre2"/>msgid "Do you have electronics?"<br class="calibre2"/>msgstr "Avez-vous des appareils electroniques?"</pre>
<ol start="4" class="calibre20">
<li class="chapter">Next, using <kbd class="calibre17">msgfmt</kbd>,<strong class="calibre3"> </strong>compile the PO file into a binary language file with the <kbd class="calibre17">.mo</kbd> extension and place it in our arbitrary language folder:</li>
</ol>
<pre class="calibre27">$ rm -rf locale/fr/LC_MESSAGES<br class="calibre2"/>$ mkdir -p locale/fr/LC_MESSAGES<br class="calibre2"/>$ sudo msgfmt -o locale/fr/LC_MESSAGES/hellobonjour.mo hellobonjour_fr.po</pre>
<ol start="5" class="calibre20">
<li class="chapter">Once you have your language file in place, create the following script with the name of <kbd class="calibre17">translator.sh</kbd>:</li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/>./hellobonjour.sh<br class="calibre2"/><br class="calibre2"/>export TEXTDOMAIN="hellobonjour"<br class="calibre2"/>export TEXTDOMAINDIR=`pwd`/locale<br class="calibre2"/><br class="calibre2"/>export LANGUAGE=fr<br class="calibre2"/>./hellobonjour.sh</pre>
<ol start="6" class="calibre20">
<li class="chapter">Upon executing <kbd class="calibre17">translator.sh</kbd>, review the results for both executions of <kbd class="calibre17">translator.sh</kbd>:</li>
</ol>
<pre class="calibre27">$ bash translator.sh</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">It goes without saying that translation can be a tricky beast, especially when managing encoding and when producing results that make sense at the human language level. Furthermore, even a slight change in the value within the script can break the PO file and the resulting script will not be fully translated (sometimes, not even at all). </p>
<div class="packt_infobox">Take care not to break the <em class="calibre26">keys</em> when making modifications to the scripts at a later date.</div>
<ol class="calibre20">
<li class="chapter">Step one is fairly straightforward<span class="calibre11">—y</span>ou just create a script. If you run the script, you will see purely an English result, but at least the plural and non-plural output is correct. Notice <kbd class="calibre17">. gettext.sh</kbd>; this line preps <kbd class="calibre17">gettext</kbd> to prepare and to be ran for internationalization/localization. In the script, we also use <kbd class="calibre17">gettext</kbd>, <kbd class="calibre17">eval_gettext</kbd>, and <kbd class="calibre17">eval_ngettext</kbd>. These are functions that allow the translation to occur. Use <kbd class="calibre17">gettext</kbd> for simple translations, <kbd class="calibre17">eval_gettext</kbd> for a translation that contains a variable, and <kbd class="calibre17">eval_ngettext</kbd> when you have translations that contain plural objects. As you may have noticed, <kbd class="calibre17">eval_ngettext</kbd> is a bit more complex: <kbd class="calibre17">$(eval_ngettext "I have \$COUNT electronic device" "I have \$COUNT electronic devices" $COUNT)</kbd>. The first parameter for <kbd class="calibre17">eval_ngettext</kbd> is the singular translation, the second is the plural, and the count is the variable used to determine if a singular or plural value is used. Variables are referred to in the original script with an escape <kbd class="calibre17">\$COUNT</kbd>, and the translated string that contains the variable will appear as <kbd class="calibre17">$COUNT</kbd> inside of the translation file without the escape:</li>
</ol>
<pre class="calibre27">./hellobonjour.sh <br class="calibre2"/>Hello<br class="calibre2"/><br class="calibre2"/>What is your name?<br class="calibre2"/><br class="calibre2"/>   My name is rbrash<br class="calibre2"/><br class="calibre2"/>Do you have electronics?<br class="calibre2"/><br class="calibre2"/>   I have 0 electronic devices<br class="calibre2"/><br class="calibre2"/>   I have 1 electronic device<br class="calibre2"/><br class="calibre2"/>   I have 2 electronic devices</pre>
<ol start="2" class="calibre20">
<li class="chapter">In step two, we create the language file called a PO file using <kbd class="calibre17">xgettext</kbd>. PO is short for Portable Object. Notice that we omitted the header because it will produce extra output. It is particularly useful when you want to write notes, versions, and even specify the encoding used.</li>
</ol>
<p class="mce-root"> </p>
<ol start="3" class="calibre20">
<li class="chapter">Instead of writing the translations from scratch, we used our trusty friend Google translate to produce a few basic translations and we copy them over the output from <kbd class="calibre17">xgettext.</kbd> Xgettext created almost the same file! Notice <kbd class="calibre17">msgid</kbd>, <kbd class="calibre17">msgstr</kbd>, <kbd class="calibre17">msgplural</kbd>, and <kbd class="calibre17">msgstr[...]</kbd>. <kbd class="calibre17">Msgid</kbd> and <kbd class="calibre17">msgid_plural</kbd> are used to match the original values as if they were a key. For example, as the script runs, <kbd class="calibre17">gettext</kbd> sees <kbd class="calibre17">"I have $COUNT electronic device"</kbd>, and then knows to output a specific translation that matches that same <kbd class="calibre17">msgid</kbd>:</li>
</ol>
<pre class="calibre27">msgid "I have $COUNT electronic device"<br class="calibre2"/>msgid_plural "I have $COUNT electronic devices"<br class="calibre2"/>msgstr[0] ".."</pre>
<ol start="4" class="calibre20">
<li class="chapter"><kbd class="calibre17">hellobonjour_fr.po</kbd> contains all of our translations, and now we can use a command called <kbd class="calibre17">msgfmt</kbd>, which is used to produce a MO file or Machine Object. If you open this file with an editor like <kbd class="calibre17">vi</kbd>, you will notice that it contains a bunch of symbols representing binary and the strings. This file should not be edited, but rather the input PO file itself.</li>
<li class="chapter">Next, we create a file called <kbd class="calibre17">translator.sh</kbd>. It runs <kbd class="calibre17">hellobonjour.sh</kbd> and contains a few lines that set three important variables: <kbd class="calibre17">TEXTDOMAIN</kbd>, <kbd class="calibre17">TEXTDOMAINDIR</kbd>, and <kbd class="calibre17">LANGUAGE</kbd>. <kbd class="calibre17">TEXTDOMAIN</kbd> is typically the variable used to describe the binary or shell script (think of it as a namespace), and <kbd class="calibre17">TEXTDOMAINDIR</kbd> is the directory for <kbd class="calibre17">gettext</kbd> to look for the translation. Notice that it's in a local relative directory, and not <kbd class="calibre17">/usr/share/locale</kbd> (which it could be). Finally, we set <kbd class="calibre17">LANGUAGE</kbd> to fr for French. </li>
<li class="chapter">When we execute <kbd class="calibre17">translator.sh</kbd>, <kbd class="calibre17">hellobonjour.sh</kbd> is run twice and outputs once in English, and the second time in French:</li>
</ol>
<pre class="calibre27">$ bash translator.sh <br class="calibre2"/><br class="calibre2"/>Hello<br class="calibre2"/><br class="calibre2"/>What is your name?<br class="calibre2"/><br class="calibre2"/>   My name is rbrash<br class="calibre2"/><br class="calibre2"/>Do you have electronics?<br class="calibre2"/><br class="calibre2"/>   I have 0 electronic devices<br class="calibre2"/><br class="calibre2"/>   I have 1 electronic device<br class="calibre2"/><br class="calibre2"/>   I have 2 electronic devices<br class="calibre2"/>Bonjour<br class="calibre2"/><br class="calibre2"/>Comment t'appelles tu?<br class="calibre2"/><br class="calibre2"/>   Mon nom est rbrash<br class="calibre2"/><br class="calibre2"/>Avez-vous des appareils electroniques?<br class="calibre2"/><br class="calibre2"/>   J'ai 0 appareils electroniques<br class="calibre2"/><br class="calibre2"/>   J'ai 1 appareil electronique<br class="calibre2"/><br class="calibre2"/>   J'ai 2 appareils electroniques</pre>
<div class="packt_tip">Do not use the old format of $"my string" for translation. It is subject to security risks!</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Calculating statistics and reducing duplicates based on file contents</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">At first glance, calculating statistics based on the contents of a file might not be among the most interesting tasks one could accomplish with Bash scripting, however, it can be useful in several circumstances. Let's imagine that our program takes user input from several commands. We could calculate the length of the input to determine if it is too little or too much. Alternatively, we could also determine the size of a string to determine buffer sizes for a program written in another programming language (such as C/C++):</span></p>
<pre class="calibre22">$ wc -c &lt;&lt;&lt; "1234567890"<br class="calibre2"/>11 # Note there are 10 chars + a new line or carriage return \n<br class="calibre2"/>$ echo -n "1234567890" | wc -c<br class="calibre2"/>10</pre>
<div class="packt_infobox">We can use commands like <kbd class="calibre23">wc</kbd> to calculate the number of occurrences of words, total number of lines, and many other actions in conjunction to the functionality provided by your script.</div>
<p class="mce-root">Better yet, what if we used a command called <strong class="calibre6">strings</strong> to output all printable ASCII strings to a file? The strings program will output <em class="calibre18">every</em> occurrence of a string<span class="calibre16">—</span>even if there are duplicates. Using other programs like <kbd class="calibre17">sort</kbd> and <kbd class="calibre17">uniq</kbd> (or a combination of the two), we can also sort the contents of a file and reduce duplicates if we wanted to calculate the number of <em class="calibre18">unique</em> lines within a file:</p>
<pre class="calibre27">$ strings /bin/ls &gt; unalteredoutput.txt<br class="calibre2"/>$ ls -lah unalteredoutput.txt <br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 22K Nov 24 11:17 unalteredoutput.txt<br class="calibre2"/>$ strings /bin/ls | sort -u &gt; sortedoutput.txt<br class="calibre2"/>$ ls -lah sortedoutput.txt <br class="calibre2"/>-rw-rw-r-- 1 rbrash rbrash 19K Nov 24 11:17 usortedoutput.txt</pre>
<p class="mce-root">Now that we know a few basic premises of why we may need to perform some basic statistics, let's carry on with the recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's get ready for the exercise by creating a single dataset:</span></p>
<pre class="calibre22">$ mkdir -p testdata<br class="calibre2"/>$ cat /etc/hosts &gt; testdata/duplicates.txt; cat /etc/hosts &gt;&gt; testdata/duplicates.txt</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">We have already seen most of these concepts already and even <kbd class="calibre17">wc</kbd><strong class="calibre6"> </strong>itself in one of the previous recipes, so let's get started:</span></p>
<ol class="calibre20">
<li class="chapter"><span class="calibre11">Open a terminal and run the following commands:</span></li>
</ol>
<pre class="calibre27">$ wc -l testdata/duplicates.txt<br class="calibre2"/>$ wc -c testdata/duplicates.txt</pre>
<ol start="2" class="calibre20">
<li class="chapter">As you may have noticed, the output has the filename included. Can we remove it with AWK? Absolutely, but we can also remove it with a command called <kbd class="calibre17">cut.</kbd> The <kbd class="calibre17">-d</kbd> flag stand, for delimiter and we would like to have a field (specified by <kbd class="calibre17">-f1</kbd>):</li>
</ol>
<pre class="calibre27">$ wc -c testdata/duplicates.txt | cut -d ' ' -f1<br class="calibre2"/>$ wc -c testdata/duplicates.txt | awk '{ print $1 }'</pre>
<ol start="3" class="calibre20">
<li class="chapter">Imagine that we have a massive file full of strings. Could we reduce the returned results? Of course, but let's use the <kbd class="calibre17">sort</kbd> command first to sort the elements contained in <kbd class="calibre17">testdata/duplicates.txt</kbd> and then use <kbd class="calibre17">sort</kbd> to produce a list of only the unique elements:</li>
</ol>
<pre class="calibre27">$ sort testdata/duplicates.txt<br class="calibre2"/>$ sort -u testdata/duplicates.txt<br class="calibre2"/>$ sort -u testdata/duplicates.txt | wc -l</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Overall, no truly abstract concepts were introduced in this script, except for counting numbers of </span>occurrences and the benefit of sort. Sorting can be a time-consuming process to reduce unneeded or extra data or when the order matters, but it can also be rewarding when performing bulk operations, and pre-processing yields faster returns overall.</p>
<p class="mce-root">Onward and upward to the recipe:</p>
<ol class="calibre20">
<li class="chapter">Running these two <kbd class="calibre17">wc</kbd><strong class="calibre3"> </strong>commands will produce both a character and line count of the file <kbd class="calibre17">testdata/duplicates.txt.</kbd> It also begins to show another problem. The data can be padded with the filename prefixed with a space:</li>
</ol>
<pre class="calibre27">$ wc -l testdata/duplicates.txt<br class="calibre2"/>18 testdata/duplicates.txt<br class="calibre2"/>$ wc -c testdata/duplicates.txt<br class="calibre2"/>438 testdata/duplicates.txt</pre>
<ol start="2" class="calibre20">
<li class="chapter">In step 2, we use <kbd class="calibre17">awk</kbd> and <kbd class="calibre17">cut</kbd> to remove the second field. The <kbd class="calibre17">cut</kbd> command is a useful command for trimming strings, which may be delimited or merely using hard-coded values such as remove X characters. Using <kbd class="calibre17">cut</kbd>, <kbd class="calibre17">-d</kbd> stands for delimiter, the space in this example (<kbd class="calibre17">' '</kbd>), and <kbd class="calibre17">-f1</kbd> stands for field <kbd class="calibre17">1</kbd>:</li>
</ol>
<pre class="calibre27">$ wc -c testdata/duplicates.txt | cut -d ' ' -f1<br class="calibre2"/>438<br class="calibre2"/>$ wc -c testdata/duplicates.txt | awk '{ print $1 }'<br class="calibre2"/>438</pre>
<ol start="3" class="calibre20">
<li class="chapter">In the final step, we run the <kbd class="calibre17">sort</kbd> command three times. We run it once to merely sort the elements in <kbd class="calibre17">testdata/duplicates.txt</kbd>, but then we use the <kbd class="calibre17">-u</kbd> to sort and keep only unique elements, and the <kbd class="calibre17">final</kbd> command counts the number of unique elements. Of course, the returned value is <kbd class="calibre17">9</kbd> because we had 18 lines in the original duplicates file:</li>
</ol>
<pre class="calibre27">$sort testdata/duplicates.txt<br class="calibre2"/><br class="calibre2"/>127.0.0.1 localhost<br class="calibre2"/>127.0.0.1 localhost<br class="calibre2"/>127.0.1.1 moon<br class="calibre2"/>127.0.1.1 moon<br class="calibre2"/>::1 ip6-localhost ip6-loopback<br class="calibre2"/>::1 ip6-localhost ip6-loopback<br class="calibre2"/>fe00::0 ip6-localnet<br class="calibre2"/>fe00::0 ip6-localnet<br class="calibre2"/>ff00::0 ip6-mcastprefix<br class="calibre2"/>ff00::0 ip6-mcastprefix<br class="calibre2"/>ff02::1 ip6-allnodes<br class="calibre2"/>ff02::1 ip6-allnodes<br class="calibre2"/>ff02::2 ip6-allrouters<br class="calibre2"/>ff02::2 ip6-allrouters<br class="calibre2"/># The following lines are desirable for IPv6 capable hosts<br class="calibre2"/># The following lines are desirable for IPv6 capable hosts<br class="calibre2"/><br class="calibre2"/>$ sort -u testdata/duplicates.txt<br class="calibre2"/><br class="calibre2"/>127.0.0.1 localhost<br class="calibre2"/>127.0.1.1 moon<br class="calibre2"/>::1 ip6-localhost ip6-loopback<br class="calibre2"/>fe00::0 ip6-localnet<br class="calibre2"/>ff00::0 ip6-mcastprefix<br class="calibre2"/>ff02::1 ip6-allnodes<br class="calibre2"/>ff02::2 ip6-allrouters<br class="calibre2"/># The following lines are desirable for IPv6 capable hosts<br class="calibre2"/>$ sort -u testdata/duplicates.txt | wc -l<br class="calibre2"/>9</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using file attributes with conditional logic</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Earlier in this book, we touched upon various tests for strings, numbers, and variables. Using a similar concept built into Bash, we can also use various attributes to test against files and directories. This extends upon the introduction conditional logic to perform tests on files. Does an example exist? Is it a directory? and so on.</span></p>
<p class="mce-root">For a moment, though, couldn't we just use the results from executing and checking the return code? Absolutely! This is another method you can use, especially if you are using a version of Bash that supports all of Bashes features. It is just another way to "skin the rabbit".</p>
<p class="mce-root">Let's start off first with some of the common flags, which return true if:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre17">-e</kbd>: The file exists</li>
<li class="calibre14"><kbd class="calibre17">-f</kbd>: This is a regular file and not a directory or device file</li>
<li class="calibre14"><kbd class="calibre17">-s</kbd>: The file is not empty or zero in size</li>
<li class="calibre14"><kbd class="calibre17">-d</kbd>: This is a directory</li>
<li class="calibre14"><kbd class="calibre17">-r</kbd>: This has read permissions</li>
<li class="calibre14"><kbd class="calibre17">-w</kbd>: This has write permissions</li>
<li class="calibre14"><kbd class="calibre17">-x</kbd>:This has execute permissions</li>
<li class="calibre14"><kbd class="calibre17">-O</kbd>: This is the owner of the file the current user</li>
<li class="calibre14"><kbd class="calibre17">-G</kbd>: This executes the user if they have the same group as yours</li>
<li class="calibre14"><kbd class="calibre17">f1</kbd> (<kbd class="calibre17">- nt</kbd>, <kbd class="calibre17">-ot</kbd>, <kbd class="calibre17">-ef</kbd>) <kbd class="calibre17">f2</kbd>: Refers to if <kbd class="calibre17">f1</kbd> is newer than <kbd class="calibre17">f2</kbd>, older than <kbd class="calibre17">f2</kbd>, or are hard-linked to the same file</li>
</ul>
<div class="packt_infobox">There is more information available on file test operations in the GNU Bash manual:<a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1"> https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's get ready for the exercise by creating a few text files and directories, and adding some content:</span></p>
<pre class="calibre22">$ cd ~/<br class="calibre2"/>$ mkdir -p fileops<br class="calibre2"/>$ touch fileops/empty.txt<br class="calibre2"/>$ echo "abcd1234!!" &gt; fileops/string.txt<br class="calibre2"/>$ echo "yieldswordinthestone" &gt; fileops/swordinthestone.txt<br class="calibre2"/>$ touch fileops/read.txt fileops/write.txt fileops/exec.txt fileops/all.txt<br class="calibre2"/>$ chmod 111 fileops/exec.txt; chmod 222 fileops/write.txt; chmod 444 fileops/read.txt; fileops/all.txt;chmod 777 fileops/all.txt<br class="calibre2"/>$ sudo useradd bob<br class="calibre2"/>$ echo "s the name" &gt; fileops/bobs.txt<br class="calibre2"/>$ sudo chown bob.bob fileops/bobs.txt</pre>
<p class="mce-root"><span class="calibre16">This recipe is about performing some simple file tests and to combine some of the other knowledge from earlier recipes on conditional logic, but with a twist—using user input from the CLI and file permissions.</span></p>
<div class="packt_tip">Notice the commands <kbd class="calibre23">chmod</kbd>, <kbd class="calibre23">useradd</kbd>, and <kbd class="calibre23">chmod</kbd>. Chmod is the command you may use to change the permissions of files for execution and more.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's begin our activity as follows:</span></p>
<ol class="calibre20">
<li class="chapter">Open a new terminal and start an editor of your choice and create a new script. The following is a code snippet from the script:</li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/>FILE_TO_TEST=""<br class="calibre2"/><br class="calibre2"/>function permissions() {<br class="calibre2"/>  <br class="calibre2"/>  echo -e "\nWhat are our permissions on this $2?\n"<br class="calibre2"/>  if [ -r $1 ]; then <br class="calibre2"/>    echo -e "[R] Read" <br class="calibre2"/>  fi<br class="calibre2"/>  if [ -w $1 ]; then <br class="calibre2"/>    echo -e     "[W] Write" <br class="calibre2"/>  fi<br class="calibre2"/>  if [ -x $1 ]; then <br class="calibre2"/>    echo -e "[X] Exec" <br class="calibre2"/>  fi<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>function file_attributes() {<br class="calibre2"/><br class="calibre2"/>  if [ ! -s $1 ]; then<br class="calibre2"/>    echo "\"$1\" is empty" <br class="calibre2"/>  else <br class="calibre2"/>    FSIZE=$(stat --printf="%s" $1 2&gt; /dev/null)<br class="calibre2"/>    RES=$?<br class="calibre2"/>    if [ $RES -eq 1 ]; then<br class="calibre2"/>      return<br class="calibre2"/>    else<br class="calibre2"/>      echo "\"$1\" file size is: ${FSIZE}\""<br class="calibre2"/>    fi<br class="calibre2"/>  fi<br class="calibre2"/>  <br class="calibre2"/>  if [ ! -O $1 ]; then<br class="calibre2"/>    echo -e "${USER} is not the owner of \"$1\"\n"<br class="calibre2"/>  fi<br class="calibre2"/>  if [ ! -G $1 ]; then<br class="calibre2"/>    echo -e "${USER} is not among the owning group(s) for \"$1\"\n"<br class="calibre2"/>  fi<br class="calibre2"/>  <br class="calibre2"/>  permissions $1 "file"<br class="calibre2"/>  <br class="calibre2"/>}</pre>
<ol start="2" class="calibre20">
<li class="chapter">Execute the script and try to access the various files, including the directories and files that do not exist. What do you notice?</li>
<li class="chapter">Remove the folder now with this command:</li>
</ol>
<pre class="calibre27">$ sudo rm -rf fileops</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">First, before digging into the script itself or even the attributes/properties of files, we need to know a few things about Linux and its sibling operating systems:</span></p>
<ul class="calibre13">
<li class="calibre14">Files and directories can be owned. This means that they can have an owner (user) and groups associated with their ownership. For this, we can use the <kbd class="calibre17">chown</kbd> and <kbd class="calibre17">chgrp</kbd><strong class="calibre3"><span class="calibre11"> </span></strong>commands.</li>
<li class="calibre14">Files and directories can have different permissions applied to them. This means that they may be executable, readable, writable, and/or everything. For this, we can use the <kbd class="calibre17">chmod</kbd><strong class="calibre3"> </strong>command and the appropriate permission setting.</li>
<li class="calibre14">Files and directories can also be empty.</li>
</ul>
<p class="mce-root">Great! Furthermore, there are two more concepts that need to be introduced:</p>
<ul class="calibre13">
<li class="calibre14">The <kbd class="calibre17">read</kbd><strong class="calibre3"> </strong>command, which is used to wait for user input and read it into a variable. It is also useful for "pause" functionality in scripts.</li>
<li class="calibre14">Recursive functions. Notice that inside of the script unless it exits or the user presses <em class="calibre26">ctl + C</em>, the script keeps calling a particular function. This is recursion and it will continue unless stopped or a limit is applied.</li>
</ul>
<p class="mce-root">At this point, we also know functions, parameters, input/output, return codes, subshells, and conditional logic. You may not have noticed the <kbd class="calibre17">!</kbd> character, and this is used to negate a statement. For example, if we test for the existence of <kbd class="calibre17">fileops/bobs.txt</kbd> using the <kbd class="calibre17">-e</kbd> test operator, it will return true. Instead, we can test for the opposite, which is that <kbd class="calibre17">fileops/bobs.txt</kbd> is non-existent.</p>
<div class="packt_infobox">The same logic as inverting or negating statements can also be achieved using if/else functionality, but it can sometimes improve script "readability" and "flow". Ultimately, the choice to use inversion is up to the script writer.</div>
<ol class="calibre20">
<li class="chapter">Great! We have created our script and are ready to execute it.</li>
<li class="chapter">Upon executing the script, we are greeted with:</li>
</ol>
<pre class="calibre27">$ ./files-extended.sh <br class="calibre2"/>Welcome to the file attributes tester<br class="calibre2"/><br class="calibre2"/>To exit, press CTRL + C<br class="calibre2"/><br class="calibre2"/>What is the complete path of the file you want to inspect?<br class="calibre2"/> # </pre>
<p class="mce-root">If we look back at the setup for this recipe, we know that we created several files inside of the directory <kbd class="calibre17">fileops/</kbd> and that a few of them have different permissions, one of which is owned by a user named <kbd class="calibre17">Bob</kbd>. </p>
<p class="mce-root">Let's try a few executions (in order) :</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre17">fileops/bobs.txt</kbd></li>
<li class="calibre14"><kbd class="calibre17">fileops/write.txt</kbd></li>
<li class="calibre14"><kbd class="calibre17">fileops/exec.txt</kbd></li>
<li class="calibre14"><kbd class="calibre17">fileops/all.txt</kbd></li>
<li class="calibre14"><kbd class="calibre17">thisDoesNotExist.txt</kbd>:</li>
</ul>
<pre class="calibre27"># fileops/bobs.txt<br class="calibre2"/><br class="calibre2"/>"fileops/bobs.txt" file size is: 11"<br class="calibre2"/>rbrash is not the owner of "fileops/bobs.txt"<br class="calibre2"/><br class="calibre2"/>rbrash is not among the owning group(s) for "fileops/bobs.txt"<br class="calibre2"/><br class="calibre2"/>What are our permissions on this file?<br class="calibre2"/><br class="calibre2"/>[R] Read<br class="calibre2"/><br class="calibre2"/>What is the complete path of the file you want to inspect?<br class="calibre2"/> # fileops/write.txt<br class="calibre2"/><br class="calibre2"/>"fileops/write.txt" is empty<br class="calibre2"/><br class="calibre2"/>What are our permissions on this file?<br class="calibre2"/><br class="calibre2"/>[W] Write<br class="calibre2"/><br class="calibre2"/>What is the complete path of the file you want to inspect?<br class="calibre2"/> # fileops/exec.txt<br class="calibre2"/><br class="calibre2"/>"fileops/exec.txt" is empty<br class="calibre2"/><br class="calibre2"/>What are our permissions on this file?<br class="calibre2"/><br class="calibre2"/>{X] Exec<br class="calibre2"/><br class="calibre2"/>What is the complete path of the file you want to inspect?<br class="calibre2"/> # fileops/all.txt<br class="calibre2"/><br class="calibre2"/>"fileops/all.txt" is empty<br class="calibre2"/><br class="calibre2"/>What are our permissions on this file?<br class="calibre2"/><br class="calibre2"/>[R] Read<br class="calibre2"/>[W] Write<br class="calibre2"/>{X] Exec<br class="calibre2"/><br class="calibre2"/>What is the complete path of the file you want to inspect?<br class="calibre2"/> # fileops<br class="calibre2"/><br class="calibre2"/>Directory "fileops" has children:<br class="calibre2"/><br class="calibre2"/>all.txt<br class="calibre2"/>bobs.txt<br class="calibre2"/>empty.txt<br class="calibre2"/>exec.txt<br class="calibre2"/>read.txt<br class="calibre2"/>string.txt<br class="calibre2"/>swordinthestone.txt<br class="calibre2"/>write.txt<br class="calibre2"/><br class="calibre2"/>What are our permissions on this directory?<br class="calibre2"/><br class="calibre2"/>[R] Read<br class="calibre2"/>[W] Write<br class="calibre2"/>{X] Exec<br class="calibre2"/><br class="calibre2"/>What is the complete path of the file you want to inspect?<br class="calibre2"/> # thisDoesNotExist.txt<br class="calibre2"/><br class="calibre2"/>Error: "thisDoesNotExist.txt" does not exist!<br class="calibre2"/>$</pre>
<p class="mce-root">As <kbd class="calibre17">thisDoesNotExist.txt</kbd> does not exist, the script abruptly exits and places you back at the console prompt. We tested with the various flags, negation, ownership, and even our ever useful utility <kbd class="calibre17">xargs</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reading delimited data and altered output format</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Every day, we open many files in many different formats. However, when thinking about large amounts of data, it is always a good practice to use standard formats. One of these is called <strong class="calibre6">Comma Separated Values</strong>, or CSVs, and it uses a comma (,) to separate <strong class="calibre6">elements </strong>or <strong class="calibre6">delimit</strong> on each row. This is particularly useful when you have large amounts of data or <strong class="calibre6">records</strong>, and that data will be used in a scripted fashion. For example, in every school semester, <span class="calibre16">Bob, the system administrator,</span> needs to create a series of new users and set their information. Bob also gets a standardized CSV (like in the following snippet) from the people in charge of attendance:</p>
<pre class="calibre22">Rbrash,Ron,Brash,01/31/88,+11234567890,rbrash@acme.com,FakePassword9000<br class="calibre2"/>...</pre>
<p class="mce-root">If Bob the administrator wishes to only read this information into an array and create users, it is relatively trivial for him to parse a CSV and create each record in one single scripted action. This allows Bob to focus his time and effort on other important issues such as troubleshooting end-user WiFi issues.</p>
<p class="mce-root">While this is a trivial example, these same files may be in different forms with <strong class="calibre6">delimiters </strong>(the <kbd class="calibre17">,</kbd> or <kbd class="calibre17">$</kbd> sign, for example), different data, and different structures. However, each file works on the premise that each line is a record that needs to be read into some structure (whatever it may be) in SQL, Bash arrays, and so on:</p>
<pre class="calibre22">Line1Itself: Header (optional and might not be present)<br class="calibre2"/>Line2ItselfIsOneREc:RecordDataWithDelimiters:endline (windows \r\n, in Linux \n)<br class="calibre2"/>....</pre>
<p class="mce-root">In the preceding example of a pseudo CSV, there is a header, which may be optional (not present), and then several lines (each being a record). Now, for Bob to parse the CSV, he has many ways to do this, but he may use specialized functions that apply a strategy such as:</p>
<pre class="calibre22">$ Loop through each item until done<br class="calibre2"/>for each line in CSV:<br class="calibre2"/>    # Do something with the data such as create a user<br class="calibre2"/>    # Loop through Next item if it exists</pre>
<p class="mce-root">To read in the data, Bob or yourself may resort to using:</p>
<ul class="calibre13">
<li class="calibre14">For loops and arrays</li>
<li class="calibre14">A form of iterator</li>
<li class="calibre14">Manually walking through each line (not efficient)</li>
</ul>
<p class="mce-root">Once any input data has been read in, the next step is to do something with the data itself. Is it to be transformed? Is it to be used immediately? Sanitized? Stored? Or converted to another format? Just like Bob, there are many things that can be performed using the data read in by the script.</p>
<p class="mce-root">In regards to outputting the data, we can also convert it to XML, JSON, or even insert it into a database as SQL. Unfortunately, this process requires being able to know at least two things: the format of the input data and the format of the output data.</p>
<div class="packt_infobox">Knowing common data formats and how they often have validation applied can be a great asset when building automated scripts and identifying any changes in the future. Enforcement of data validation also has several benefits and can help save the day when all of a sudden the script breaks without warning!</div>
<p class="mce-root">This recipe aims at walking you through reading a trivial CSV and outputting the data into some arbitrary formats.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">Let's get ready for the exercise by creating some data sets which mimic common daily problems:</span></p>
<pre class="calibre22">$ cd ~/<br class="calibre2"/>$ echo <br class="calibre2"/>$ echo -e "XML_HDR='&lt;?xml version="1.0" encoding="UTF-8"?&gt;'\\nSRT_CONTR='&lt;words type="greeting"&gt;'\\nEND_CONTR='&lt;/words&gt;'" &gt; xml-parent.tpl<br class="calibre2"/>$ echo -e "ELM='\"&lt;word lang=\"\$1\"&gt;\"\$2\"&lt;/word&gt;\"'" &gt; word.tpl<br class="calibre2"/>$ echo -e "\"EN\",\"Hello\"\n\"FR\",\"Bonjour\"" &gt; words.csv</pre>
<div class="packt_infobox">In Bash, the single quote (<span class="calibre11">'</span>) is used for literal strings. In this case, we want every part of the string to be present without escaping slashes and double quotes.</div>
<p class="mce-root">To operate this script, you have the following applications installed for use within the script:</p>
<pre class="calibre22">$ sudo apt-get install npm sed awk<br class="calibre2"/>$ sudo npm install -g xml2json-command<br class="calibre2"/>$ sudo ln -s /usr/bin/nodejs /usr/bin/node</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's begin our activity as follows:</p>
<ol class="calibre20">
<li class="chapter">O<span class="calibre11">pen a terminal and create the <kbd class="calibre17">data-csv-to-xml.sh</kbd> script with the following contents. Then, execute the script after saving it using</span> <kbd class="calibre17">$ bash data-csv-to-xml.sh</kbd><span class="calibre11">:</span></li>
</ol>
<pre class="calibre27">#!/bin/bash<br class="calibre2"/><br class="calibre2"/># Import template variables<br class="calibre2"/>source xml-parent.tpl<br class="calibre2"/>source word.tpl<br class="calibre2"/><br class="calibre2"/>OUTPUT_FILE="words.xml"<br class="calibre2"/>INPUT_FILE="words.csv"<br class="calibre2"/>DELIMITER=','<br class="calibre2"/><br class="calibre2"/># Setup header<br class="calibre2"/>echo ${XML_HDR} &gt; ${OUTPUT_FILE}<br class="calibre2"/>echo ${SRT_CONTR} &gt;&gt; ${OUTPUT_FILE}<br class="calibre2"/><br class="calibre2"/># Enter content<br class="calibre2"/>echo ${ELM} | \<br class="calibre2"/>sed '{:q;N;s/\n/\\n/g;t q}'| \<br class="calibre2"/>awk \<br class="calibre2"/>'{ print "awk \x27 BEGIN{FS=\"'${DELIMITER}'\"}{print "$0"}\x27 '${INPUT_FILE}'"}' | \<br class="calibre2"/> sh &gt;&gt; ${OUTPUT_FILE}<br class="calibre2"/><br class="calibre2"/># Append trailer<br class="calibre2"/>echo ${END_CONTR} &gt;&gt; ${OUTPUT_FILE}<br class="calibre2"/><br class="calibre2"/>cat ${OUTPUT_FILE}</pre>
<ol start="2" class="calibre20">
<li class="chapter">Examine the output, but be aware that "pretty" XML isn't necessary and in fact, we don't even need to have the XML on multiple lines. If pure data is required for a web application, the extra new lines and tabs are unnecessary data to be transmitted.</li>
<li class="chapter">Create another <span class="calibre11">script named </span><kbd class="calibre17">data-xml-to-json.sh</kbd><span class="calibre11"> with the following contents. Then, execute the script after saving it using </span><kbd class="calibre17">$ <span class="calibre11"> </span>data-xml-to-json.sh</kbd>:</li>
</ol>
<pre class="calibre27">!#/bin/bash<br class="calibre2"/>INPUT_FILE"words.xml"<br class="calibre2"/>OUTPUT_FILE="words.json"<br class="calibre2"/><br class="calibre2"/># Easy one line!<br class="calibre2"/>xml2json &lt; ${INPUT_FILE} ${OUTPUT_FILE}</pre>
<ol start="4" class="calibre20">
<li class="chapter">Review the output and see how it easy it is! Are there areas you could improve on in both of the scripts?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre16">We have already discussed several important aspects such as the power of the SED and AWK commands, and even CSVs, but we have not discussed the importance of being able to <strong class="calibre6">transform</strong> the format and structure of data. CSVs are a fundamental and very common format of data, but unfortunately, it isn't the best choice for some applications, so we may use XML or JSON. Here are two scripts (or rather one script and one tool) that can convert our original data into various formats:</span></p>
<ol class="calibre20">
<li class="chapter">When executing <kbd class="calibre17">data-csv-to-xml.sh</kbd>, we notice several things: we utilize two source template files, which can be altered for flexibility, and then a large piped command that leverages sed and AWK. On input, we take each of the CSV values and build a <kbd class="calibre17">&lt;word lang="x"&gt;Y&lt;/word&gt;</kbd> XML element using the format template inside of <kbd class="calibre17">word.tpl</kbd>, where <kbd class="calibre17">$0</kbd> is field one and <kbd class="calibre17">$1</kbd> is field two. The script will produce a <kbd class="calibre17">words.csv</kbd> and output the following:</li>
</ol>
<pre class="calibre27">$ bash data-csv-to-xml.sh<br class="calibre2"/>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="calibre2"/>&lt;words type="greeting"&gt;<br class="calibre2"/>&lt;word lang="EN"&gt;"Hello"&lt;/word&gt;<br class="calibre2"/>&lt;word lang="FR"&gt;"Bonjour"&lt;/word&gt;<br class="calibre2"/>&lt;/words&gt;</pre>
<ol start="2" class="calibre20">
<li class="chapter">In the second script, we merely take <kbd class="calibre17">words.xml</kbd> as input into the command <kbd class="calibre17">xml2json</kbd>. The output will be in JSON format. Cool hey?</li>
</ol>
<pre class="calibre27">!#/bin/bash<br class="calibre2"/>{<br class="calibre2"/>  "words": {<br class="calibre2"/>    "type": "greeting",<br class="calibre2"/>    "word": [<br class="calibre2"/>      {<br class="calibre2"/>        "lang": "EN",<br class="calibre2"/>        "$t": "\"Hello\""<br class="calibre2"/>      },<br class="calibre2"/>      {<br class="calibre2"/>        "lang": "FR",<br class="calibre2"/>        "$t": "\"Bonjour\""<br class="calibre2"/>      }<br class="calibre2"/>    ]<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<div class="packt_infobox">The differences and reasons between all three formats of data (CSV, XML, and JSON) is left as an exercise for the reader to discover. Another exercise to explore is performing data validation to ensure integrity and constraints on data. For example, XML can use XSD schemas to enforce data limits.</div>


            </article>

            
        </section>
    </div>



  </body></html>