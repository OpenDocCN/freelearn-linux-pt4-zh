["```\n# e.g. File system\n# / (start here)\n# /home (oh we found home)\n# /home/user (neat there is a directory inside it called user)\n# /home/user/.. (even better, user has files - lets look in them too)\n# /etc/ # We are done with /home and its \"children\" so lets look in /etc\n# ... # Until we are done\n```", "```\n$ ~/\n$ wget --recursive --no-parent https://www.packtpub.com www.packtpub.com # Takes awhile\n$ traceroute packtpub.com > traceroute.txt\n$ mkdir -p www.packtpub.com/filedir www.packtpub.com/emptydir\n$ touch www.packtpub.com/filedir/empty.txt\n$ touch www.packtpub.com/findme.xml; echo \"<xml>\" www.packtpub.com/findme.xml\n```", "```\n#!/bin/bash\n\n# Let's find all the files with the string \"Packt\"\nDIRECTORY=\"www.packtpub.com/\"\nSEARCH_TERM=\"Packt\"\n\n# Can we use grep?\ngrep \"${SEARCH_TERM}\" ~/* > result1.txt 2&> /dev/null\n\n# Recursive check\ngrep -r \"${SEARCH_TERM}\" \"${DIRECTORY}\" > result2.txt\n\n# What if we want to check for multiple terms?\ngrep -r -e \"${SEARCH_TERM}\" -e \"Publishing\" \"${DIRECTORY}\" > result3.txt\n\n# What about find?\nfind \"${DIRECTORY}\" -type f -print | xargs grep \"${SEARCH_TERM}\" > result4.txt\n\n# What about find and looking for the string inside of a specific type of content?\nfind \"${DIRECTORY}\" -type f -name \"*.xml\" ! -name \"*.css\" -print | xargs grep \"${SEARCH_TERM}\" > result5.txt\n\n# Can this also be achieved with wildcards and subshell?\ngrep \"${SEARCH_TERM}\" $(ls -R \"${DIRECTORY}\"*.{html,txt}) > result6.txt\nRES=$?\n\nif [ ${RES} -eq 0 ]; then\n  echo \"We found results!\"\nelse\n  echo \"It broke - it shouldn't happen (Packt is everywhere)!\"\nfi\n\n# Or for bonus points - a personal favorite\nhistory | grep \"ls\" # This is really handy to find commands you ran yesterday!\n\n# Aaaannnd the lesson is:\necho \"We can do a lot with grep!\"\nexit 0\n```", "```\n$ bash search.sh; ls -lah result*.txt\nWe found results!\nWe can do a lot with grep!\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 14 14:33 result1.txt\n-rw-rw-r-- 1 rbrash rbrash 1.2M Nov 14 14:33 result2.txt\n-rw-rw-r-- 1 rbrash rbrash 1.2M Nov 14 14:33 result3.txt\n-rw-rw-r-- 1 rbrash rbrash 1.2M Nov 14 14:33 result4.txt\n-rw-rw-r-- 1 rbrash rbrash 33 Nov 14 14:33 result5.txt\n-rw-rw-r-- 1 rbrash rbrash 14K Nov 14 14:33 result6.txt\n```", "```\n$ grep -e \"Packt\" -e \"Publishing\" -r ~/www.packtpub.com/\n```", "```\n$ find \"${DIRECTORY}\" -type f -print | xargs grep \"${SEARCH_TERM}\" > result4.txt\n```", "```\n$ ls -l\ndrwxr-xr-x 7 rbrash rbrash 4096 Nov 13 21:48 Desktop\\n\ndrwxr-xr-x 2 rbrash rbrash 4096 Feb 11 2017 Documents\\n\ndrwxr-xr-x 7 rbrash rbrash 32768 Nov 14 10:54 Downloads\\n\n-rw-r--r-- 1 rbrash rbrash 8980 Feb 11 2017 examples.desktop\\n\n...\n```", "```\n$ someProgram Desktop\\n Documents\\n Downloads\\n ...\n```", "```\n$ someProgram Desktop Documents Downloads ...\n```", "```\n$ ls -l /etc/*/*.txt\n-rw-r--r-- 1 root root 17394 Nov 10 2015 /etc/X11/rgb.txt\n```", "```\nWe found results!\n```", "```\n$ ls -l | grep '[[:lower:]][[:digit:]]' # Notice no result\n$ touch z0.test\n$ touch a1.test\n$ touch A2.test\n$ ls -l | grep '[[:lower:]][[:digit:]]'\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 11:31 z0.test\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 11:31 a1.test\n```", "```\n$ cd ~/\n$ touch {a..c}.test\n$ touch {A..C}[0..2].test2\n$ touch Z9.test3 Z9\\,test2 Z9..test2\n$ touch ~/Desktop/Test.pdf\n```", "```\n#!/bin/bash\nSTR1='123 is a number, ABC is alphabetic & aBC123 is alphanumeric.'\n\necho \"-------------------------------------------------\"\n# Want to find all of the files beginning with an uppercase character and end with .pdf?\nls * | grep [[:upper:]]*.pdf\n\necho \"-------------------------------------------------\"\n# Just all of the directories in your current directory?\nls -l [[:upper:]]*\n\necho \"-------------------------------------------------\"\n# How about all of the files we created with an expansion using the { } brackets?\nls [:lower:].test .\n\necho \"-------------------------------------------------\"\n# Files with a specific extension OR two?\necho ${STR1} > test.txt\nls *.{test,txt} \n\necho \"-------------------------------------------------\"\n# How about looking for specific punctuation and output on the same line\necho \"${STR1}\" | grep -o [[:punct:]] | xargs echo\n\necho \"-------------------------------------------------\"\n# How about using groups and single character wildcards (only 5 results)\nls | grep -E \"([[:upper:]])([[:digit:]])?.test?\" | tail -n 5\n\nexit 0\n```", "```\n$ grep -oP 'name=\"\\K.*?(?=\")' www.packtpub.com/index.html\n```", "```\n$ grep -P 'name=' www.packtpub.com/index.html\n```", "```\n$ tr '\\n' ' ' < www.packtpub.com/index.html | grep -o '<title>.*</title>' \n```", "```\n$ grep -nP 'name=' www.packtpub.com/index.html | cut -c -80\n```", "```\n$ bash test.sh \n-------------------------------------------------\nLinux-Journal-2017-08.pdf\nLinux-Journal-2017-09.pdf\nLinux-Journal-2017-10.pdf\nTest.pdf\n-------------------------------------------------\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 A0.test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 A1.test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 A2.test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 B0.test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 B1.test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 B2.test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 C0.test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 C1.test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 C2.test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 Z9,test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 Z9..test2\n-rw-rw-r-- 1 rbrash rbrash 0 Nov 15 22:13 Z9.test3\n\nDesktop:\ntotal 20428\ndrwxrwxr-x 2 rbrash rbrash 4096 Nov 15 12:55 book\n# Lots of files here too\n\nDocuments:\ntotal 0\n\nDownloads:\ntotal 552776\n-rw------- 1 root root 1024 Feb 11 2017 ~\n... # I have a lot of files for this book\n\nMusic:\ntotal 0\n\nPictures:\ntotal 2056\ndrwxrwxr-x 2 rbrash rbrash 4096 Sep 6 21:56 backgrounds\n\nPublic:\ntotal 0\n\nTemplates:\ntotal 0\n\nVideos:\ntotal 4\ndrwxrwxr-x 13 rbrash rbrash 4096 Aug 11 10:42 movies\n-------------------------------------------------\na.test b.test c.test\n-------------------------------------------------\na.test b.test c.test test.txt\n-------------------------------------------------\n, & .\n-------------------------------------------------\nC0.test2\nC1.test2\nC2.test2\nZ9,test2\nZ9.test3\n```", "```\nC0.test2\nC1.test2\nC2.test2\nZ9,test2\nZ9.test3\n```", "```\n$ ls | grep -E \"([[:upper:]])([[:digit:]])?.?.test?\"\n```", "```\n$ grep -nHP 'name=' www.packtpub.com/index.html | cut -c -80\n```", "```\n$ 1*5\n1*5: command not found\n```", "```\n$ echo $((1*5))\n5\n```", "```\n$ echo $((1/5))\n0\n```", "```\n$ sudo apt-get install -y bc tar\n```", "```\n$ dd if=/dev/zero of=empty.bin bs=1k count=10000\n$ tar -zcvf archive.tar.gz empty.bin\n$ rm empty.bin\n```", "```\n$ sudo apt-get install -y gcc\n```", "```\n$ wget https://raw.githubusercontent.com/PacktPublishing/Bash-Cookbook/master/chapter%2002/mhelper.c\n```", "```\n$ gcc -Wall -02 -o mhelper main.c -lmath\n```", "```\n$ sudo cp mhelper /bin; sudo chmod a+x /bin/mhelper;\n```", "```\n$ mhelper \"var1\" \"-\" \"var2\"\n```", "```\n#!/bin/bash\n# Retrieve file system information and remove header\nTARBALL=\"archive.tar.gz\"\nCURRENT_PART_ALL=$(df --output=size,avail,used /home -B 1M | tail -n1)\n\n# Iterate through and fill array\nIFS=' ' read -r -a array <<< $CURRENT_PART_ALL\n\n# Retrieve the size of the contents of the tarball\nCOMPRESSED_SZ=$(tar tzvf \"${TARBALL}\" | sed 's/ \\+/ /g' | cut -f3 -d' ' | sed '2,$s/^/+ /' | paste -sd' ' | bc)\n\necho \"First inspection - is there enough space?\"\nif [ ${array[1]} -lt ${COMPRESSED_SZ} ]; then\n    echo \"There is not enough space to decompress the binary\"\n    exit 1\nelse\n  echo \"Seems we have enough space on first inspection - continuing\"\n  VAR=$((${array[0]} - ${array[2]}))\n  echo \"Space left: ${VAR}\"\nfi\n\necho \"Safety check - do we have at least double the space?\"\nCHECK=$((${array[1]}*2))\necho \"Double - good question? $CHECK\"\n\n# Notice the use of the bc command?\nRES=$(echo \"$(mhelper \"${array[1]}\" \"/\" \"2\")>0\" | bc -l)\nif [[ \"${RES}\" == \"1\" ]]; then\n  echo \"Sppppppaaaaccee (imagine zombies)\"\nfi\n\n# We know that this will break! (Bash is driven by integers)\n# if [ $(mhelper \"${array[2]}\" \"/\" \"2\") -gt 0 ]; then\n  #~ echo \"Sppppppaaaaccee (imagine zombies) - syntax error\"\n# fi\n# What if we tried this with Bash and a concept again referring to floats\n# e.g., 0.5\n# It would break\n# if [ $((${array[2]} * 0.5 )) -gt 0 ]; then\n  # echo \"Sppppppaaaaccee (imagine zombies) - syntax error\"\n# fi\n\n# Then untar\ntar xzvf ${TARBALL}\nRES=$?\nif [ ${RES} -ne 0 ]; then\n  echo \"Error decompressing the tarball!\"\n  exit 1\nfi\n\necho \"Decompressing tarball complete!\"\nexit 0\n```", "```\nFirst inspection - is there enough space?\nSeems we have enough space on first inspection - continuing\nSpace left: 264559\nSafety check - do we have at least double the space?\nDouble - good question ? 378458\nSppppppaaaaccee (imagine zombies)\nempty.bin\nDecompressing tarball complete!\n```", "```\n#!/bin/bash\n# Index zero of VARIABLE is the char 'M' & is 14 bytes long\nVARIABLE=\"My test string\"\n# ${VARIABLE:startingPosition:optionalLength}\necho ${VARIABLE:3:4}\n```", "```\n$ bash script.sh\ntest\n```", "```\n$ rm -rf testdata; mkdir -p testdata\n$ echo \"Bob, Jane, Naz, Sue, Max, Tom$\" > testdata/garbage.csv \n$ echo \"Zero, Alpha, Beta, Gama, Delta, Foxtrot#\" >> testdata/garbage.csv \n$ echo \"1000,Bob,Green,Dec,1,1967\" > testdata/employees.csv\n$ echo \"2000,Ron,Brash,Jan,20,1987\" >> testdata/employees.csv\n$ echo \"3000,James,Fairview,Jul,15,1992\" >> testdata/employees.csv\n```", "```\n#!/bin/bash\n\n# Let's play with variable arrays first using Bash's equivalent of substr\n\nSTR=\"1234567890asdfghjkl\"\n\necho \"first character ${STR:0:1}\"\necho \"first three characters ${STR:0:3}\"\n\necho \"third character onwards ${STR: 3}\"\necho \"forth to sixth character ${STR: 3: 3}\"\n\necho \"last character ${STR: -1}\"\n\n# Next, can we compare the alphabeticalness of strings?\n\nSTR2=\"abc\"\nSTR3=\"bcd\"\nSTR4=\"Bcd\"\n\nif [[ $STR2 < $STR3 ]]; then\n echo \"STR2 is less than STR3\"\nelse\n echo \"STR3 is greater than STR2\"\nfi\n\n# Does case have an effect? Yes, b is less than B\nif [[ $STR3 < $STR4 ]]; then\n echo \"STR3 is less than STR4\"\nelse\n echo \"STR4 is greater than STR3\"\nfi\n```", "```\n#!/bin/bash\nGB_CSV=\"testdata/garbage.csv\"\nEM_CSV=\"testdata/employees.csv\"\n# Let's strip the garbage out of the last lines in the CSV called garbage.csv\n# Notice the forloop; there is a caveat\n\nset IFS=,\nset oldIFS = $IFS\nreadarray -t ARR < ${GB_CSV}\n\n# How many rows do we have?\nARRY_ELEM=${#ARR[@]}\necho \"We have ${ARRY_ELEM} rows in ${GB_CSV}\"\n```", "```\n\nINC=0\nfor i in \"${ARR[@]}\"for i in \"${ARR[@]}\"\ndo\n:\nres=\"${i//[^ ]}\"\nTMP_CNT=\"${#res}\"\nwhile [ ${TMP_CNT} -gt 0 ]; do\ni=${i/, /,}\nTMP_CNT=$[$TMP_CNT-1]\ndone\nARR[$INC]=$i\nINC=$[$INC+1]\ndone\n```", "```\nINC=0\nfor i in \"${ARR[@]}\"\ndo\n: \nARR[$INC]=${i::-1}\nINC=$[$INC+1]\ndone\n```", "```\nINC=0for i in \"${ARR[@]}\"\ndo\n:\nARR[$INC]=${i^^}\nprintf \"%s\" \"${ARR[$INC]}\"\nINC=$[$INC+1]\necho\ndone\n\n# In employees.csv update the first field to be prepended with a # character\nset IFS=,\nset oldIFS = $IFS\nreadarray -t ARR < ${EM_CSV}\n\n# How many rows do we have?\nARRY_ELEM=${#ARR[@]}\n\necho;echo \"We have ${ARRY_ELEM} rows in ${EM_CSV}\"\n# Let's add a # at the start of each line\nINC=0\nfor i in \"${ARR[@]}\"\ndo\n:\nARR[$INC]=\"#${i}\"\nprintf \"%s\" \"${ARR[$INC]}\"\nINC=$[$INC+1]\necho\ndone\n\n# Bob had a name change, he wants to go by the name Robert - replace it!\necho\necho \"Let's make Bob, Robert!\"\nINC=0\nfor i in \"${ARR[@]}\"\ndo\n:\n# We need to iterate through Bobs first\nARR[$INC]=${i/Bob/Robert}\nprintf \"%s\" \"${ARR[$INC]}\"\nINC=$[$INC+1]\necho\ndone\n```", "```\necho;\necho \"Lets remove the column: birthday (1-31)\"\nINC=0\nCOLUM_TO_REM=4\nfor i in \"${ARR[@]}\"\ndo\n :\n# Prepare to also parse the ARR element into another ARR for\n# string manipulation\n TMP_CNT=0\n STR=\"\"\n IFS=',' read -ra ELEM_ARR <<< \"$i\"\n for field in \"${ELEM_ARR[@]}\"\n do\n   # Notice the multiple argument in an if statement\n   # AND that we catch the start of it once\n   if [ $TMP_CNT -ne 0 ] && [ $TMP_CNT -ne $COLUM_TO_REM ]; then\n   STR=\"${STR},${field}\"\n   elif [ $TMP_CNT -eq 0 ]\n   then\n   STR=\"${STR}${field}\"\n   fi \n   TMP_CNT=$[$TMP_CNT+1]\n done\n ARR[$INC]=$STR\n echo \"${ARR[$INC]}\"\n INC=$[$INC+1]\ndone\n```", "```\n$ builtin-str.sh\nfirst character 1\nfirst three characters 123\nthird character onwards 4567890asdfghjkl\nforth to sixth character 456\nlast character l\nSTR2 is less than STR3\nSTR4 is greater than STR3\n```", "```\n$ ./builtin-strng.sh \nWe have 2 rows in testdata/garbage.csv\nBOB,JANE,NAZ,SUE,MAX,TOM\nZERO,ALPHA,BETA,GAMA,DELTA,FOXTROT\n\nWe have 3 rows in testdata/employees.csv\n#1000,Bob,Green,Dec,1,1967\n#2000,Ron,Brash,Jan,20,1987\n#3000,James,Fairview,Jul,15,1992\n\nLet's make Bob, Robert!\n#1000,Robert,Green,Dec,1,1967\n#2000,Ron,Brash,Jan,20,1987\n#3000,James,Fairview,Jul,15,1992\n\nLets remove the column: birthday (1-31)\n#1000,Robert,Green,Dec,1967\n#2000,Ron,Brash,Jan,1987\n#3000,James,Fairview,Jul,1992\n```", "```\n$ rmdir testdata; mkdir -p testdata\n$ echo \"Bob, Jane, Naz, Sue, Max, Tom$\" > testdata/garbage.csv \n$ echo \"Bob, Jane, Naz, Sue, Max, Tom#\" >> testdata/garbage.csv \n$ echo \"1000,Bob,Green,Dec,1,1967\" > testdata/employees.csv\n$ echo\" 2000,Ron,Brash,Jan,20,1987\" >> testdata/employees.csv\n$ echo \"3000,James,Fairview,Jul,15,1992\" >> testdata/employees.csv\n```", "```\n#!/bin/bash\nSTR=\"1234567890asdfghjkl\"\necho -n \"First character \"; sed 's/.//2g' <<< $STR # where N = 2 (N +1)\necho -n \"First three characters \"; sed 's/.//4g' <<< $STR\n\necho -n \"Third character onwards \"; sed -r 's/.{3}//' <<< $STR\necho -n \"Forth to sixth character \"; sed -r 's/.{3}//;s/.//4g' <<< $STR\n\necho -n \"Last character by itself \"; sed 's/.*\\(.$\\)/\\1/' <<< $STR\necho -n \"Remove last character only \"; sed 's/.$//' <<< $STR\n```", "```\n#!/bin/sh\nGB_CSV=\"testdata/garbage.csv\"\nEM_CSV=\"testdata/employees.csv\"\n# Let's strip the garbage out of the last lines in the CSV called garbage.csv\n# Notice the forloop; there is a caveat\n\nset IFS=,\nset oldIFS = $IFS\nreadarray -t ARR < ${GB_CSV}\n\n# How many rows do we have?\nARRY_ELEM=${#ARR[@]}\necho \"We have ${ARRY_ELEM} rows in ${GB_CSV}\"\n\n# Let's strip the garbage - remove spaces\nINC=0\nfor i in \"${ARR[@]}\"\ndo\n   : \n  ARR[$INC]=$(echo $i | sed 's/ //g')\n  echo \"${ARR[$INC]}\"\n  INC=$[$INC+1]\ndone\n\n# Remove the last character and make ALL upper case\nINC=0\nfor i in \"${ARR[@]}\"\ndo\n   : \n  ARR[$INC]=$(echo $i | sed 's/.$//' | sed -e 's/.*/\\U&/' )\n  echo \"${ARR[$INC]}\"\n  INC=$[$INC+1]\ndone\n\n```", "```\nset IFS=,\nset oldIFS = $IFS\nreadarray -t ARR < ${EM_CSV}\n\nINC=0\nfor i in \"${ARR[@]}\"\ndo\n : \n ARR[$INC]=$(sed -e 's/^/#/' <<< $i )\n echo \"${ARR[$INC]}\"\n INC=$[$INC+1]\ndone\n\nsed -i 's/Bob/Robert/' ${EM_CSV}\nsed -i 's/^/#/' ${EM_CSV} # In place, instead of on the data in the array\ncat ${EM_CSV}\n# Now lets remove the birthdate field from the files\n# Starts to get more complex, but is done without a loop or using cut\nawk 'BEGIN { FS=\",\"; OFS=\",\" } {$5=\"\";gsub(\",+\",\",\",$0)}1' OFS=, ${EM_CSV}\n```", "```\n$ bash ./some-strs.sh \nFirst character 1\nFirst three characters 123\nThird character onwards 4567890asdfghjkl\nForth to sixth character 456\nLast character by itself l\nRemove last character only 1234567890asdfghjk\n```", "```\n$ bash more-strsng.sh \nWe have 2 rows in testdata/garbage.csv\nBob,Jane,Naz,Sue,Max,Tom$\nZero,Alpha,Beta,Gama,Delta,Foxtrot#\nBOB,JANE,NAZ,SUE,MAX,TOM\nZERO,ALPHA,BETA,GAMA,DELTA,FOXTROT\n#1000,Robert,Green,Dec,1,1967\n#2000,Ron,Brash,Jan,20,1987\n#3000,James,Fairview,Jul,15,1992\n#1000,Robert,Green,Dec,1,1967\n#2000,Ron,Brash,Jan,20,1987\n#3000,James,Fairview,Jul,15,1992\n#1000,Robert,Green,Dec,1967\n#2000,Ron,Brash,Jan,1987\n#3000,James,Fairview,Jul,1992\n```", "```\n$ echo -en '\\xF0\\x9F\\x92\\x80\\n'\n\n$ printf '\\xF0\\x9F\\x92\\x80\\n'\n\n```", "```\n#!/bin/bash\n\n# What about echo?\necho -n \"Currently we have seen the command \\\"echo\\\" used before\"\necho \" in the previous script\"\necho\necho -n \"Can we also have \\t tabs? \\r\\n\\r\\n?\"\necho \" NO, not yet!\"\necho\necho -en \"Can we also have \\t tabs? \\r\\n\\r\\n?\"\necho \" YES, we can now! enable interpretation of backslash escapes\"\necho \"We can also have:\"\necho -en '\\xF0\\x9F\\x92\\x80\\n' # We can also use \\0NNN for octal instead of \\xFF for hexidecimal\necho \"Check the man pages for more info ;)\"\n```", "```\n#!/bin/bash\nexport LC_NUMERIC=\"en_US.UTF-8\"\nprintf \"This is the same as echo -e with a new line (\\\\\\n)\\n\"\n\nDECIMAL=10.0\nFLOAT=3.333333\nFLOAT2=6.6666 # On purpose two missing values\n\nprintf \"%s %.2f\\n\\n\" \"This is two decimal places: \" ${DECIMAL}\n\nprintf \"shall we align: \\n\\n %.3f %-.6f\\n\" ${FLOAT} ${FLOAT2}\nprintf \" %10f %-6f\\n\" ${FLOAT} ${FLOAT2}\nprintf \" %-10f %-6f\\n\" ${FLOAT} ${FLOAT2}\n\n# Can we also print other things?\nprintf '%.0s-' {1..20}; printf \"\\n\"\n\n# How about we print the hex value and a char for each value in a string?\nSTR=\"No place like home!\"\nCNT=$(wc -c <<< $STR})\nTMP_CNT=0\n\nprintf \"Char Hex\\n\"\n\nwhile [ ${TMP_CNT} -lt $[${CNT} -1] ]; do\n  printf \"%-5s 0x%-2X\\n\" \"${STR:$TMP_CNT:1}\" \"'${STR:$TMP_CNT:1}\" \n  TMP_CNT=$[$TMP_CNT+1]\ndone\n```", "```\n$ bash echo-mayhem.sh \nCurrently we have seen the command \"echo\" used before in the previous script\n\nCan we also have \\t tabs? \\r\\n\\r\\n? NO, not yet!\n\nCan we also have       tabs? \n\n? YES, we can now! enable interpretation of backslash escapes\nWe can also have:\n\nCheck the man pages for more info ;)\n```", "```\n$ bash printf-mayhem.sh \nThis is the same as echo -e with a new line (\\n)\nThis is two decimal places: 10.00\n\nshall we align: \n\n 3.333 6.666600\n   3.333333 6.666600\n 3.333333 6.666600\n--------------------\nChar Hex\nN 0x4E\no 0x6F\n  0x20\np 0x70\nl 0x6C\na 0x61\nc 0x63\ne 0x65\n  0x20\nl 0x6C\ni 0x69\nk 0x6B\ne 0x65\n  0x20\nh 0x68\no 0x6F\nm 0x6D\ne 0x65\n! 0x21\n  0x0 \n```", "```\n$ sudo apt-get install -y gettext\n```", "```\n$ locale\nLANG=en_CA:en\nLANGUAGE=en_CA:en\nLC_CTYPE=\"en_CA:en\"\nLC_NUMERIC=\"en_CA:en\"\nLC_TIME=\"en_CA:en\"\nLC_COLLATE=\"en_CA:en\"\nLC_MONETARY=\"en_CA:en\"\nLC_MESSAGES=\"en_CA:en\"\nLC_PAPER=\"en_CA:en\"\nLC_NAME=\"en_CA:en\"\nLC_ADDRESS=\"en_CA:en\"\nLC_TELEPHONE=\"en_CA:en\"\nLC_MEASUREMENT=\"en_CA:en\"\nLC_IDENTIFICATION=\"en_CA:en\"\nLC_ALL=\n```", "```\n#!/bin/bash\n. gettext.sh\nfunction i_have() {\n  local COUNT=$1\n  ###i18n: Please leave $COUNT as is\n  echo -e \"\\n\\t\" $(eval_ngettext \"I have \\$COUNT electronic device\" \"I have \\$COUNT electronic devices\" $COUNT)\n\n}\n\necho $(gettext \"Hello\")\necho\n\necho $(gettext \"What is your name?\")\necho\n\n###i18n: Please leave $USER as is\necho -e \"\\t\" $(eval_gettext \"My name is \\$USER\" )\necho\n\necho $(gettext \"Do you have electronics?\")\n\ni_have 0\ni_have 1\ni_have 2\n\n```", "```\n$ xgettext --add-comments='##i18n' -o hellobonjour_fr.po hellobonjour.sh --omit-header\n```", "```\n# Hellobonjour.sh\n# Copyright (C) 2017 Ron Brash\n# This file is distributed under the same license as the PACKAGE package.\n# Ron Brash <ron.brash@gmail.com>, 2017\n# Please ignore my terrible google translations; \n# As always, some is better than none!\n#, fuzzy\nmsgid \"\"\nmsgstr \"\"\n\"Project-Id-Version: 1.0\\n\"\n\"Report-Msgid-Bugs-To: i18n@example.com\\n\"\n\"POT-Creation-Date: 2017-12-08 12:19-0500\\n\"\n\"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n\"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n\"Language-Team: French Translator <fr@example.org>\\n\"\n\"Language: fr\\n\"\n\"MIME-Version: 1.0\\n\"\n\"Content-Type: text/plain; charset=iso-8859-1\\n\"\n\"Content-Transfer-Encoding: 8bit\\n\"\n\n#. ##i18n: Please leave $COUNT as is\n#: hellobonjour.sh:6\n#, sh-format\nmsgid \"I have $COUNT electronic device\"\nmsgid_plural \"I have $COUNT electronic devices\"\nmsgstr[0] \"J'ai $COUNT appareil electronique\"\nmsgstr[1] \"J'ai $COUNT appareils electroniques\"\n\n#: hellobonjour.sh:10\nmsgid \"Hello\"\nmsgstr \"Bonjour\"\n\n#: hellobonjour.sh:13\nmsgid \"What is your name?\"\nmsgstr \"Comment t'appelles tu?\"\n\n#. ##i18n: Please leave $USER as is\n#: hellobonjour.sh:17\n#, sh-format\nmsgid \"My name is $USER\"\nmsgstr \"Mon nom est $USER\"\n\n#: hellobonjour.sh:20\nmsgid \"Do you have electronics?\"\nmsgstr \"Avez-vous des appareils electroniques?\"\n```", "```\n$ rm -rf locale/fr/LC_MESSAGES\n$ mkdir -p locale/fr/LC_MESSAGES\n$ sudo msgfmt -o locale/fr/LC_MESSAGES/hellobonjour.mo hellobonjour_fr.po\n```", "```\n#!/bin/bash\n./hellobonjour.sh\n\nexport TEXTDOMAIN=\"hellobonjour\"\nexport TEXTDOMAINDIR=`pwd`/locale\n\nexport LANGUAGE=fr\n./hellobonjour.sh\n```", "```\n$ bash translator.sh\n```", "```\n./hellobonjour.sh \nHello\n\nWhat is your name?\n\n   My name is rbrash\n\nDo you have electronics?\n\n   I have 0 electronic devices\n\n   I have 1 electronic device\n\n   I have 2 electronic devices\n```", "```\nmsgid \"I have $COUNT electronic device\"\nmsgid_plural \"I have $COUNT electronic devices\"\nmsgstr[0] \"..\"\n```", "```\n$ bash translator.sh \n\nHello\n\nWhat is your name?\n\n   My name is rbrash\n\nDo you have electronics?\n\n   I have 0 electronic devices\n\n   I have 1 electronic device\n\n   I have 2 electronic devices\nBonjour\n\nComment t'appelles tu?\n\n   Mon nom est rbrash\n\nAvez-vous des appareils electroniques?\n\n   J'ai 0 appareils electroniques\n\n   J'ai 1 appareil electronique\n\n   J'ai 2 appareils electroniques\n```", "```\n$ wc -c <<< \"1234567890\"\n11 # Note there are 10 chars + a new line or carriage return \\n\n$ echo -n \"1234567890\" | wc -c\n10\n```", "```\n$ strings /bin/ls > unalteredoutput.txt\n$ ls -lah unalteredoutput.txt \n-rw-rw-r-- 1 rbrash rbrash 22K Nov 24 11:17 unalteredoutput.txt\n$ strings /bin/ls | sort -u > sortedoutput.txt\n$ ls -lah sortedoutput.txt \n-rw-rw-r-- 1 rbrash rbrash 19K Nov 24 11:17 usortedoutput.txt\n```", "```\n$ mkdir -p testdata\n$ cat /etc/hosts > testdata/duplicates.txt; cat /etc/hosts >> testdata/duplicates.txt\n```", "```\n$ wc -l testdata/duplicates.txt\n$ wc -c testdata/duplicates.txt\n```", "```\n$ wc -c testdata/duplicates.txt | cut -d ' ' -f1\n$ wc -c testdata/duplicates.txt | awk '{ print $1 }'\n```", "```\n$ sort testdata/duplicates.txt\n$ sort -u testdata/duplicates.txt\n$ sort -u testdata/duplicates.txt | wc -l\n```", "```\n$ wc -l testdata/duplicates.txt\n18 testdata/duplicates.txt\n$ wc -c testdata/duplicates.txt\n438 testdata/duplicates.txt\n```", "```\n$ wc -c testdata/duplicates.txt | cut -d ' ' -f1\n438\n$ wc -c testdata/duplicates.txt | awk '{ print $1 }'\n438\n```", "```\n$sort testdata/duplicates.txt\n\n127.0.0.1 localhost\n127.0.0.1 localhost\n127.0.1.1 moon\n127.0.1.1 moon\n::1 ip6-localhost ip6-loopback\n::1 ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\nff02::2 ip6-allrouters\n# The following lines are desirable for IPv6 capable hosts\n# The following lines are desirable for IPv6 capable hosts\n\n$ sort -u testdata/duplicates.txt\n\n127.0.0.1 localhost\n127.0.1.1 moon\n::1 ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n# The following lines are desirable for IPv6 capable hosts\n$ sort -u testdata/duplicates.txt | wc -l\n9\n```", "```\n$ cd ~/\n$ mkdir -p fileops\n$ touch fileops/empty.txt\n$ echo \"abcd1234!!\" > fileops/string.txt\n$ echo \"yieldswordinthestone\" > fileops/swordinthestone.txt\n$ touch fileops/read.txt fileops/write.txt fileops/exec.txt fileops/all.txt\n$ chmod 111 fileops/exec.txt; chmod 222 fileops/write.txt; chmod 444 fileops/read.txt; fileops/all.txt;chmod 777 fileops/all.txt\n$ sudo useradd bob\n$ echo \"s the name\" > fileops/bobs.txt\n$ sudo chown bob.bob fileops/bobs.txt\n```", "```\n#!/bin/bash\nFILE_TO_TEST=\"\"\n\nfunction permissions() {\n\n  echo -e \"\\nWhat are our permissions on this $2?\\n\"\n  if [ -r $1 ]; then \n    echo -e \"[R] Read\" \n  fi\n  if [ -w $1 ]; then \n    echo -e     \"[W] Write\" \n  fi\n  if [ -x $1 ]; then \n    echo -e \"[X] Exec\" \n  fi\n}\n\nfunction file_attributes() {\n\n  if [ ! -s $1 ]; then\n    echo \"\\\"$1\\\" is empty\" \n  else \n    FSIZE=$(stat --printf=\"%s\" $1 2> /dev/null)\n    RES=$?\n    if [ $RES -eq 1 ]; then\n      return\n    else\n      echo \"\\\"$1\\\" file size is: ${FSIZE}\\\"\"\n    fi\n  fi\n\n  if [ ! -O $1 ]; then\n    echo -e \"${USER} is not the owner of \\\"$1\\\"\\n\"\n  fi\n  if [ ! -G $1 ]; then\n    echo -e \"${USER} is not among the owning group(s) for \\\"$1\\\"\\n\"\n  fi\n\n  permissions $1 \"file\"\n\n}\n```", "```\n$ sudo rm -rf fileops\n```", "```\n$ ./files-extended.sh \nWelcome to the file attributes tester\n\nTo exit, press CTRL + C\n\nWhat is the complete path of the file you want to inspect?\n # \n```", "```\n# fileops/bobs.txt\n\n\"fileops/bobs.txt\" file size is: 11\"\nrbrash is not the owner of \"fileops/bobs.txt\"\n\nrbrash is not among the owning group(s) for \"fileops/bobs.txt\"\n\nWhat are our permissions on this file?\n\n[R] Read\n\nWhat is the complete path of the file you want to inspect?\n # fileops/write.txt\n\n\"fileops/write.txt\" is empty\n\nWhat are our permissions on this file?\n\n[W] Write\n\nWhat is the complete path of the file you want to inspect?\n # fileops/exec.txt\n\n\"fileops/exec.txt\" is empty\n\nWhat are our permissions on this file?\n\n{X] Exec\n\nWhat is the complete path of the file you want to inspect?\n # fileops/all.txt\n\n\"fileops/all.txt\" is empty\n\nWhat are our permissions on this file?\n\n[R] Read\n[W] Write\n{X] Exec\n\nWhat is the complete path of the file you want to inspect?\n # fileops\n\nDirectory \"fileops\" has children:\n\nall.txt\nbobs.txt\nempty.txt\nexec.txt\nread.txt\nstring.txt\nswordinthestone.txt\nwrite.txt\n\nWhat are our permissions on this directory?\n\n[R] Read\n[W] Write\n{X] Exec\n\nWhat is the complete path of the file you want to inspect?\n # thisDoesNotExist.txt\n\nError: \"thisDoesNotExist.txt\" does not exist!\n$\n```", "```\nRbrash,Ron,Brash,01/31/88,+11234567890,rbrash@acme.com,FakePassword9000\n...\n```", "```\nLine1Itself: Header (optional and might not be present)\nLine2ItselfIsOneREc:RecordDataWithDelimiters:endline (windows \\r\\n, in Linux \\n)\n....\n```", "```\n$ Loop through each item until done\nfor each line in CSV:\n    # Do something with the data such as create a user\n    # Loop through Next item if it exists\n```", "```\n$ cd ~/\n$ echo \n$ echo -e \"XML_HDR='<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\\\\nSRT_CONTR='<words type=\"greeting\">'\\\\nEND_CONTR='</words>'\" > xml-parent.tpl\n$ echo -e \"ELM='\\\"<word lang=\\\"\\$1\\\">\\\"\\$2\\\"</word>\\\"'\" > word.tpl\n$ echo -e \"\\\"EN\\\",\\\"Hello\\\"\\n\\\"FR\\\",\\\"Bonjour\\\"\" > words.csv\n```", "```\n$ sudo apt-get install npm sed awk\n$ sudo npm install -g xml2json-command\n$ sudo ln -s /usr/bin/nodejs /usr/bin/node\n```", "```\n#!/bin/bash\n\n# Import template variables\nsource xml-parent.tpl\nsource word.tpl\n\nOUTPUT_FILE=\"words.xml\"\nINPUT_FILE=\"words.csv\"\nDELIMITER=','\n\n# Setup header\necho ${XML_HDR} > ${OUTPUT_FILE}\necho ${SRT_CONTR} >> ${OUTPUT_FILE}\n\n# Enter content\necho ${ELM} | \\\nsed '{:q;N;s/\\n/\\\\n/g;t q}'| \\\nawk \\\n'{ print \"awk \\x27 BEGIN{FS=\\\"'${DELIMITER}'\\\"}{print \"$0\"}\\x27 '${INPUT_FILE}'\"}' | \\\n sh >> ${OUTPUT_FILE}\n\n# Append trailer\necho ${END_CONTR} >> ${OUTPUT_FILE}\n\ncat ${OUTPUT_FILE}\n```", "```\n!#/bin/bash\nINPUT_FILE\"words.xml\"\nOUTPUT_FILE=\"words.json\"\n\n# Easy one line!\nxml2json < ${INPUT_FILE} ${OUTPUT_FILE}\n```", "```\n$ bash data-csv-to-xml.sh\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<words type=\"greeting\">\n<word lang=\"EN\">\"Hello\"</word>\n<word lang=\"FR\">\"Bonjour\"</word>\n</words>\n```", "```\n!#/bin/bash\n{\n  \"words\": {\n    \"type\": \"greeting\",\n    \"word\": [\n      {\n        \"lang\": \"EN\",\n        \"$t\": \"\\\"Hello\\\"\"\n      },\n      {\n        \"lang\": \"FR\",\n        \"$t\": \"\\\"Bonjour\\\"\"\n      }\n    ]\n  }\n}\n```"]