<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Application Development"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Application Development</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing toolchains</li><li class="listitem" style="list-style-type: disc">Preparing and using an SDK</li><li class="listitem" style="list-style-type: disc">Using the Application Development Toolkit</li><li class="listitem" style="list-style-type: disc">Using the Eclipse IDE</li><li class="listitem" style="list-style-type: disc">Developing GTK+ applications</li><li class="listitem" style="list-style-type: disc">Using the Qt Creator IDE</li><li class="listitem" style="list-style-type: disc">Developing Qt applications</li><li class="listitem" style="list-style-type: disc">Describing workflows for application development</li><li class="listitem" style="list-style-type: disc">Working with GNU make</li><li class="listitem" style="list-style-type: disc">Working with the GNU build system</li><li class="listitem" style="list-style-type: disc">Working with the CMake build system</li><li class="listitem" style="list-style-type: disc">Working with the SCons builder</li><li class="listitem" style="list-style-type: disc">Developing with libraries</li><li class="listitem" style="list-style-type: disc">Working with the Linux framebuffer</li><li class="listitem" style="list-style-type: disc">Using the X Windows system</li><li class="listitem" style="list-style-type: disc">Using Wayland</li><li class="listitem" style="list-style-type: disc">Adding Python applications</li><li class="listitem" style="list-style-type: disc">Integrating the Oracle Java Runtime Environment</li><li class="listitem" style="list-style-type: disc">Integrating the Open Java Development Kit</li><li class="listitem" style="list-style-type: disc">Integrating Java applications</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec56"/>Introduction</h1></div></div></div><p>Dedicated applications are what define an embedded product, and Yocto offers helpful application development tools as well as the functionality to integrate with popular <span class="strong"><strong>Integrated Development Environments</strong></span> (<span class="strong"><strong>IDE</strong></span>)<a id="id406" class="indexterm"/> like Eclipse and Qt Creator. It also provides a wide range of utility classes to help in the integration of finished applications into the build system and the target images.</p><p>This chapter will introduce the IDEs and show us how they are used to build and debug C and C++ applications on real hardware, and will explore application development, including graphical frameworks and Yocto integration, not only for C and C++ but also Python and Java applications.</p></div></div>
<div class="section" title="Introducing toolchains"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec57"/>Introducing toolchains</h1></div></div></div><p>A toolchain is a set of<a id="id407" class="indexterm"/> tools, binaries, and libraries used to build applications to run on a computer platform. In Yocto, the toolchains are based on GNU components.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec148"/>Getting ready</h2></div></div></div><p>A GNU toolchain contains the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Assembler (GNU as)</strong></span>: This <a id="id408" class="indexterm"/>is part of the binutils package</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Linker (GNU ld)</strong></span>: This <a id="id409" class="indexterm"/>is also part of the binutils package</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Compiler (GNU gcc)</strong></span>: This <a id="id410" class="indexterm"/>has support for C, C++, Java, Ada, Fortran, and Objective C</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Debugger (GNU gdb)</strong></span>: This is the <a id="id411" class="indexterm"/>GNU debugger</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Binary file tools (objdump, nm, objcopy, readelf, strip, and so on)</strong></span>: These are part <a id="id412" class="indexterm"/>of the binutils package.</li></ul></div><p>These components are enough to build bare metal applications, bootloaders like U-Boot, or operating systems like the Linux kernel, as they don't need a C library and they implement the C library functions they need. However, for Linux user space applications, a POSIX-compliant C library is needed.</p><p>The GNU C library, <code class="literal">glibc</code>, is the <a id="id413" class="indexterm"/>default C library used in the Yocto project. Yocto is introducing support for musl, a smaller C library, but as we have mentioned before, there is still work to be done until it is ready to be used with the hardware platforms supported by the FSL community layer.</p><p>But on embedded systems, it is not just a toolchain we need, but a cross-compilation toolchain. This is because we build in a host computer but run the resulting binaries on the target, which is usually a different architecture. In reality, there are several types of toolchains, based on the architecture of the machine building the toolchain (build machine), running the toolchain (host machine), and running the binaries built by the toolchain (target machine). The most common combinations are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Native</strong></span>: An example of<a id="id414" class="indexterm"/> this is an x86 machine running a toolchain that has also been built on an x86 machine producing binaries to run on an x86 machine. This is common in desktop computers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cross-compilation</strong></span>: This is<a id="id415" class="indexterm"/> the most common on embedded systems; for example, an x86 machine running a toolchain that has also been built on an x86 machine but producing binaries to run on a different architecture, like ARM.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cross-native</strong></span>: This is<a id="id416" class="indexterm"/> typically the toolchain running on targets. An example of this is where a toolchain has been built on an x86 machine but runs on ARM and produces binaries for ARM.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Canadian</strong></span>: Rarely seen, this is<a id="id417" class="indexterm"/> where the build, host, and target machines are all different.</li></ul></div><p>The process of building a cross-compilation toolchain is complex and fault prone, so automated tools for toolchain building have emerged, like <span class="strong"><strong>buildroot</strong></span><a id="id418" class="indexterm"/> and <a id="id419" class="indexterm"/>
<span class="strong"><strong>crosstool-NG</strong></span>. The Yocto build system also compiles its own toolchain on every build, and as we will see, you can use this toolchain for application development too.</p><p>But the cross-compilation toolchain and C library are not the only things we need in order to build applications; we also need a <code class="literal">sysroot</code>; that is, a root filesystem on the host with the libraries and header files that can be found on the target root filesystem.</p><p>The combination of the cross-compilation toolchain, the <code class="literal">sysroot</code>, and sometimes other development tools such as an IDE is referred to as an SDK, or Software Development Kit.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec149"/>How to do it...</h2></div></div></div><p>There are several <a id="id420" class="indexterm"/>ways to <a id="id421" class="indexterm"/>obtain an SDK with the Yocto project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the<a id="id422" class="indexterm"/> <span class="strong"><strong>Application Development Toolkit</strong></span> (<span class="strong"><strong>ADT</strong></span>).<p>If you are using a hardware platform supported by Poky (that is, a virtualized QEMU machine or one of the reference boards), the recommendation is to use ADT, which will install all the required SDK components for you.</p></li><li class="listitem" style="list-style-type: disc">Downloading a precompiled toolchain.<p>The easiest way to obtain a cross-compilation toolchain for a supported platform is to download a precompiled one; for example from the Yocto project<a id="id423" class="indexterm"/> downloads site, <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/">http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/</a>. The Yocto project provides prebuilt toolchains for both 32- and 64-bit i686 host machines, and prebuilt ARM toolchains both for <span class="strong"><strong>armv5</strong></span><a id="id424" class="indexterm"/> and <a id="id425" class="indexterm"/>
<span class="strong"><strong>armv7</strong></span> architectures. These contain <code class="literal">sysroot</code> that match the <code class="literal">core-image-sato</code> target image. However, the prebuilt <code class="literal">sysroot</code> is soft floating point, so it can't be used with the target images built by the FSL community layer for i.MX6-based platforms, which are hard floating point. To install the prebuilt armv7 toolchain for an x86_64 host, run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ wget http://downloads.yoctoproject.org/releases/yocto/yocto- 1.7.1/toolchain/x86_64/poky-glibc-x86_64-core-image-sato- armv7a-vfp-neon-toolchain-1.7.1.sh</strong></span>
<span class="strong"><strong>$ chmod a+x poky-glibc-x86_64-core-image-sato-armv7a-vfp-neon- toolchain-1.7.1.sh</strong></span>
<span class="strong"><strong>$ ./poky-glibc-x86_64-core-image-sato-armv7a-vfp-neon- toolchain-1.7.1.sh</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Building your own toolchain installer.<p>On most embedded Linux projects, your machine will be supported by an external layer, and you will have a customized root filesystem that your <code class="literal">sysroot</code> will need to match. So building your own toolchain installer is recommended when you have a customized root filesystem. For example, the ideal toolchain to work with the Wandboard would be <span class="strong"><strong>Cortex-A9</strong></span>-specific and targeted to produce hard floating point binaries.</p></li><li class="listitem" style="list-style-type: disc">Using the <a id="id426" class="indexterm"/>Yocto <a id="id427" class="indexterm"/>project build system.<p>Finally, if you already have a Yocto build system installation on your host, you can also use it for application development. Usually, application developers do not need the complexity of a Yocto build system installation, so a toolchain installer for the target system will be enough.</p></li></ul></div></div></div>
<div class="section" title="Preparing and using an SDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec58"/>Preparing and using an SDK</h1></div></div></div><p>The Yocto build <a id="id428" class="indexterm"/>system can be used to generate a cross-compilation toolchain<a id="id429" class="indexterm"/> and matching <code class="literal">sysroot</code> for a target system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec150"/>Getting ready</h2></div></div></div><p>We will use the previously used <code class="literal">wandboard-quad</code> build directory and source the <code class="literal">setup-environment</code> script as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec151"/>How to do it...</h2></div></div></div><p>There are several ways to <a id="id430" class="indexterm"/>build an SDK with the Yocto build<a id="id431" class="indexterm"/> system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">meta-toolchain</code> target.<p>This <a id="id432" class="indexterm"/>method will build a toolchain that matches your target platform, and a basic <code class="literal">sysroot</code> that will not match your target root filesystem. However, this toolchain can be used to build bare metal software like the U-Boot bootloader or the Linux kernel, which do not need a <code class="literal">sysroot</code>. The Yocto project offers downloadable <code class="literal">sysroot</code> for the supported hardware platforms. You can also build this toolchain yourself with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake meta-toolchain</strong></span>
</pre></div><p>Once built, it can be installed with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tmp/deploy/sdk</strong></span>
<span class="strong"><strong>$ ./poky-glibc-x86_64-meta-toolchain-cortexa9hf-vfp-neon- toolchain-1.7.1.sh</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">populate_sdk</code> task.<p>This is<a id="id433" class="indexterm"/> the recommended way to build a toolchain<a id="id434" class="indexterm"/> matching your target platform with a <code class="literal">sysroot</code> matching<a id="id435" class="indexterm"/> your target <a id="id436" class="indexterm"/>root <a id="id437" class="indexterm"/>filesystem. You build it with: </p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake core-image-sato -c populate_sdk</strong></span>
</pre></div><p>You should replace <code class="literal">core-image-sato</code> for the target root filesystem image you want the <code class="literal">sysroot</code> to match. The resulting toolchain can be installed with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tmp/deploy/sdk</strong></span>
<span class="strong"><strong>$ ./poky-glibc-x86_64-core-image-sato-cortexa9hf-vfp-neon- toolchain-1.7.1.sh</strong></span>
</pre></div><p>Also, if you want your toolchain to be able to build static applications, you need to add static libraries to it. You can do this by adding specific static libraries to your target image, which could also be used for native compilation. For example, to add the static <code class="literal">glibc</code> libraries, add the following to your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append =  " glibc-staticdev"</pre></div><p>And then build the toolchain to match your root filesystem as explained previously.</p><p>You usually won't want the static libraries added to your image, but do you want to be able to cross-compile static applications, so you can also add all the static libraries to the toolchain by adding:</p><div class="informalexample"><pre class="programlisting">SDKIMAGE_FEATURES_append = " staticdev-pkgs"</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">meta-toolchain-qt</code> target.<p>This method<a id="id438" class="indexterm"/> will extend <code class="literal">meta-toolchain</code> to build Qt applications. We will see how to build <a id="id439" class="indexterm"/>Qt applications later on. To build this<a id="id440" class="indexterm"/> toolchain, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake meta-toolchain-qt</strong></span>
</pre></div><p>Once built, it can be installed with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tmp/deploy/sdk</strong></span>
<span class="strong"><strong>$ ./poky-glibc-x86_64-meta-toolchain-qt-cortexa9hf-vfp-neon- toolchain-qt-1.7.1.sh</strong></span>
</pre></div><p>The resulting toolchain installers will be located under <code class="literal">tmp/deploy/sdk</code> for all the cases mentioned here.</p></li><li class="listitem" style="list-style-type: disc">The <code class="literal">meta-ide-support</code> target.<p>This method does not<a id="id441" class="indexterm"/> generate a toolchain installer, but it prepares the current build project to use its own toolchain. It will generate an <code class="literal">environment-setup</code> script inside the tmp directory.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake meta-ide-support</strong></span>
</pre></div><p>To use <a id="id442" class="indexterm"/>the bundled toolchain, you can now source that<a id="id443" class="indexterm"/> script as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source tmp/environment-setup-cortexa9hf-vfp-neon-poky-linux- gnueabi</strong></span>
</pre></div></li></ul></div></div></div>
<div class="section" title="Using the Application Development Toolkit"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec59"/>Using the Application Development Toolkit</h1></div></div></div><p>The ADT is an SDK <a id="id444" class="indexterm"/>installation script that installs the following for Poky-supported hardware platforms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A prebuilt cross-compilation toolchain, as explained previously</li><li class="listitem" style="list-style-type: disc">A <code class="literal">sysroot</code> that matches the <code class="literal">core-image-sato</code> target image</li><li class="listitem" style="list-style-type: disc">The QEMU emulator</li><li class="listitem" style="list-style-type: disc">Other development user space tools used for system profiling (these will be discussed in the following chapters)</li></ul></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec152"/>Getting ready</h2></div></div></div><p>To install the ADT, you can choose either of the following options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Download a precompiled tarball from the Yocto project downloads site with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ wget http://downloads.yoctoproject.org/releases/yocto/yocto- 1.7.1/adt-installer/adt_installer.tar.bz2</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Build one using your Yocto <code class="literal">build</code> directory.</li></ul></div><p>The ADT installer is an automated script to install precompiled Yocto SDK components, so it will be the same whether you download the prebuilt version or you build one yourself.</p><p>You can then configure it before running it to customize the installation.</p><p>Note that it only makes sense to use the ADT for the Poky-supported platforms. For instance, it is not that useful for external hardware like <code class="literal">wandboard-quad</code> unless you provide your own components.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec153"/>How to do it...</h2></div></div></div><p>To build the <a id="id445" class="indexterm"/>ADT from your Yocto <code class="literal">build</code> directory, open a new shell and execute the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/poky</strong></span>
<span class="strong"><strong>$ source oe-init-build-env qemuarm</strong></span>
<span class="strong"><strong>$ bitbake adt-installer</strong></span>
</pre></div><p>The ADT tarball will be located in the <code class="literal">tmp/deploy/sdk</code> directory.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec154"/>How it works...</h2></div></div></div><p>To install it, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extract the tarball on a location of your choice:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto</strong></span>
<span class="strong"><strong>$ cp /opt/yocto/poky/qemuarm/tmp/deploy/sdk/adt_installer.tar.bz2 /opt/yocto</strong></span>
<span class="strong"><strong>$ tar xvf adt_installer.tar.bz2</strong></span>
<span class="strong"><strong>$ cd /opt/yocto/adt-installer</strong></span>
</pre></div></li><li class="listitem">Configure the <a id="id446" class="indexterm"/>installation by editing the <code class="literal">adt_installer.conf</code> file. Some of the options are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">YOCTOADT_REPO</code>: This is a<a id="id447" class="indexterm"/> repository with the packages and root filesystem to be used. By default, it uses the one on the Yocto project web site, <a class="ulink" href="http://adtrepo.yoctoproject.org/1.7.1/">http://adtrepo.yoctoproject.org/1.7.1/</a>, but you could set one up yourself with your customized packages and root filesystem.</li><li class="listitem" style="list-style-type: disc"><code class="literal">YOCTOADT_TARGETS</code>: This defines the machine targets the SDK is for. By <a id="id448" class="indexterm"/>default, this is ARM and x86.</li><li class="listitem" style="list-style-type: disc"><code class="literal">YOCTOADT_QEMU</code>: This <a id="id449" class="indexterm"/>option controls whether to install the QEMU emulator. The default is to install it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">YOCTOADT_NFS_UTIL</code>: This <a id="id450" class="indexterm"/>option controls whether to install user mode NFS. It is recommended if you are going to use the Eclipse IDE with QEMU-based machines. The default is to install it.</li></ul></div><p>And then for the specific target architectures (only shown for ARM):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">YOCTOADT_ROOTFS_arm</code>: This<a id="id451" class="indexterm"/> defines the specific root filesystem images to download from the ADT repository. By default it installs the <code class="literal">minimal</code> and <code class="literal">sato-sdk</code> images.</li><li class="listitem" style="list-style-type: disc"><code class="literal">YOCTOADT_TARGET_SYSROOT_IMAGE_arm</code>: This is the root filesystem used<a id="id452" class="indexterm"/> to create the <code class="literal">sysroot</code>. This must also be included in the <code class="literal">YOCTOADT_ROOTFS_arm</code> selection that was explained earlier. By default this is the <code class="literal">sato-sdk</code> image.</li><li class="listitem" style="list-style-type: disc"><code class="literal">YOCTOADT_TARGET_MACHINE_arm</code>: This is the machine that the images are downloaded <a id="id453" class="indexterm"/>for. By default this is <code class="literal">qemuarm</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">YOCTOADT_TARGET_SYSROOT_LOC_arm</code>: This is <a id="id454" class="indexterm"/>the path on the host to install the target's <code class="literal">sysroot</code>. By default this is <code class="literal">$HOME/test-yocto/</code>.</li></ul></div></li><li class="listitem">Run the ADT installer as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./adt_installer</strong></span>
</pre></div><p>It will ask for<a id="id455" class="indexterm"/> an installation location (by default <code class="literal">/opt/poky/1.7.1</code>) and whether you want to run it in interactive or silent mode.</p></li></ol></div></div></div>
<div class="section" title="Using the Eclipse IDE"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec60"/>Using the Eclipse IDE</h1></div></div></div><p>Eclipse is an open source <a id="id456" class="indexterm"/>IDE that is written mostly in Java and released under the <a id="id457" class="indexterm"/>
<span class="strong"><strong>Eclipse Public License</strong></span> (<span class="strong"><strong>EPL</strong></span>). It can be extended using plugins, and the Yocto project releases a Yocto plugin that allows us to use Eclipse for application development.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec155"/>Getting ready</h2></div></div></div><p>Yocto 1.7 provides <a id="id458" class="indexterm"/>Eclipse Yocto plugins for two different Eclipse versions, Juno and Kepler. They can be downloaded at <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/">http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/eclipse-plugin/</a>. We will use Kepler 4.3, as it is the newest. We will start with the Eclipse Kepler standard edition and install all the required plugins we need.</p><p>It is recommended to run Eclipse under Oracle Java 1.7, although other Java providers are supported. You can install Oracle Java 1.7<a id="id459" class="indexterm"/> from Oracle's web site, <a class="ulink" href="https://www.java.com/en/">https://www.java.com/en/</a>, or using a Ubuntu Java Installer PPA, <a class="ulink" href="https://launchpad.net/~webupd8team/+archive/ubuntu/java">https://launchpad.net/~webupd8team/+archive/ubuntu/java</a>. The latter will <a id="id460" class="indexterm"/>integrate Java with your package management system, so it's preferred. To install it, follow these steps:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo add-apt-repository ppa:webupd8team/java</strong></span>
<span class="strong"><strong>$ sudo apt-get update</strong></span>
<span class="strong"><strong>$ sudo apt-get install oracle-java7-set-default</strong></span>
</pre></div><p>To download and install Eclipse Kepler<a id="id461" class="indexterm"/> standard edition for an x86_64 host, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Fetch the tarball from the Eclipse download site, <a class="ulink" href="http://eclipse.org/downloads/packages/release/Kepler/SR2">http://eclipse.org/downloads/packages/release/Kepler/SR2</a>. For example:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> $ wget http://download.eclipse.org/technology/epp/downloads/release/kepler/SR2/eclipse-standard-kepler-SR2-linux-gtk-x86_64.tar.gz</strong></span>
</pre></div></li><li class="listitem">Unpack it on a location of your choice as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ tar xvf eclipse-standard-kepler-SR2-linux-gtk-x86_64.tar.gz</strong></span>
</pre></div></li><li class="listitem">Start the Eclipse <a id="id462" class="indexterm"/>IDE with the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nohup eclipse/eclipse &amp;</strong></span>
</pre></div></li><li class="listitem">Select <span class="strong"><strong>Install New Software</strong></span> from the <span class="strong"><strong>Help</strong></span> pull-down menu. Then select the <span class="strong"><strong>Kepler - http://download.eclipse.org/releases/kepler</strong></span> source.</li><li class="listitem">Install the following Eclipse components:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Linux tools:<p><span class="strong"><strong>LTTng - Linux Tracing Toolkit</strong></span></p></li><li class="listitem" style="list-style-type: disc">Mobile and device development:<p><span class="strong"><strong>C/C++ Remote Launch</strong></span></p><p><span class="strong"><strong>Remote System Explorer End-user Runtime</strong></span></p><p><span class="strong"><strong>Remote System Explorer User Actions</strong></span></p><p><span class="strong"><strong>Target Management Terminal</strong></span></p><p><span class="strong"><strong>TCF Remote System Explorer add-in</strong></span></p><p><span class="strong"><strong>TCF Target Explorer</strong></span></p></li><li class="listitem" style="list-style-type: disc">Programming languages:<p><span class="strong"><strong>C/C++ Autotools Support</strong></span></p><p><span class="strong"><strong>C/C++ Development Tools</strong></span></p></li></ul></div></li><li class="listitem">Install the Eclipse Yocto plugin by adding<a id="id463" class="indexterm"/> this repository source: <a class="ulink" href="http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler">http://downloads.yoctoproject.org/releases/eclipse-plugin/1.7.1/kepler</a>, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/5186OS_04_01.jpg" alt="Getting ready"/></div></li><li class="listitem">Choose <span class="strong"><strong>Yocto Project ADT plug-in</strong></span> and ignore the unsigned content warning. We won't be covering other plugin extensions.</li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec156"/>How to do it...</h2></div></div></div><p>To configure Eclipse <a id="id464" class="indexterm"/>to use a Yocto toolchain, go to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Preferences</strong></span> | <span class="strong"><strong>Yocto Project ADT</strong></span>.</p><p>The ADT configuration offers two cross-compiler options:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Standalone pre-built toolchain</strong></span>: Choose <a id="id465" class="indexterm"/>this when you have installed a toolchain either from a toolchain installer or the ADT installer.</li><li class="listitem"><span class="strong"><strong>Build system derived toolchain</strong></span>: Choose this when using a Yocto <code class="literal">build</code> directory prepared <a id="id466" class="indexterm"/>with <code class="literal">meta-ide-support</code> as explained previously.</li></ol></div><p>It also offers two target options:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>The QEMU emulator</strong></span>: Choose <a id="id467" class="indexterm"/>this if you are using Poky with a virtualized machine and you have used the ADT installer to install a <code class="literal">qemuarm</code> Linux kernel and root filesystem.</li><li class="listitem"><span class="strong"><strong>External hardware</strong></span>: Choose <a id="id468" class="indexterm"/>this if you are using real hardware like the <code class="literal">wandboard-quad</code> hardware. This option is the most useful for embedded development.</li></ol></div><p>An example<a id="id469" class="indexterm"/> configuration when using the ADT installer with its default configuration would be to choose the standalone prebuilt toolchain option along with the QEMU emulator as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cross-compiler options:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Standalone pre-built toolchain:<p><span class="strong"><strong>Toolchain root location</strong></span>: <code class="literal">/opt/poky/1.7.1</code></p><p><span class="strong"><strong>Sysroot location</strong></span>: <code class="literal">${HOME}/test-yocto/qemuarm</code></p><p><span class="strong"><strong>Target architecture</strong></span>: <code class="literal">armv5te-poky-linux-gnueabi</code></p></li><li class="listitem" style="list-style-type: disc">Target options:<p><span class="strong"><strong>QEMU kernel</strong></span>: <code class="literal">/tmp/adt-installer/download_image/zImage-qemuarm.bin</code></p></li></ul></div><div class="mediaobject"><img src="graphics/5186OS_04_02.jpg" alt="How to do it..."/></div></li></ul></div><p>And for a build <a id="id470" class="indexterm"/>system derived toolchain using the <code class="literal">wandboard-quad</code> reference board, this is what you will need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cross-compiler options:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build system derived toolchain:<p><span class="strong"><strong>Toolchain root location</strong></span>: <code class="literal">/opt/yocto/fsl-community-bsp/wandboard-quad</code></p><p><span class="strong"><strong>Sysroot location</strong></span>: <code class="literal">/opt/yocto/fsl-community-bsp/wandboard-quad/tmp/sysroots/wandboard-quad</code></p></li></ul></div><div class="mediaobject"><img src="graphics/5186OS_04_03.jpg" alt="How to do it..."/></div></li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec157"/>There's more...</h2></div></div></div><p>In order to perform debugging on a remote target, it needs to be running the <code class="literal">tcf-agent</code> daemon. It is included by default on the SDK images, but you can also include it in any other image by adding the following to your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">EXTRA_IMAGE_FEATURES += "eclipse-debug"</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec158"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information, refer to the <span class="emphasis"><em>Yocto Project Application Developer's Guide</em></span> at<a id="id471" class="indexterm"/> <a class="ulink" href="http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html">http://www.yoctoproject.org/docs/1.7.1/adt-manual/adt-manual.html</a></li></ul></div></div></div>
<div class="section" title="Developing GTK+ applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec61"/>Developing GTK+ applications</h1></div></div></div><p>This recipe will show <a id="id472" class="indexterm"/>how to build, run, and debug a graphical GTK+ application using the Eclipse IDE.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec159"/>Getting ready</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">eclipse-debug</code> feature to your project's <code class="literal">conf/local.conf</code> file as follows:<div class="informalexample"><pre class="programlisting">EXTRA_IMAGE_FEATURES += "eclipse-debug"</pre></div></li><li class="listitem">Build a <code class="literal">core-image-sato</code> target image as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake core-image-sato</strong></span>
</pre></div></li><li class="listitem">Build a <code class="literal">core-image-sato</code> toolchain as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c populate_sdk core-image-sato</strong></span>
</pre></div></li><li class="listitem">Install the toolchain as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tmp/deploy/sdk</strong></span>
<span class="strong"><strong>$ ./poky-glibc-x86_64-core-image-sato-cortexa9hf-vfp-neon- toolchain-1.7.1.sh</strong></span>
</pre></div></li></ol></div><p>Before launching the Eclipse IDE, we can check whether we are able to build and launch a GTK application manually. We will build the following GTK+ hello world application:</p><p>The following is a code for <code class="literal">gtk_hello_world.c</code>:</p><div class="informalexample"><pre class="programlisting">#include &lt;gtk/gtk.h&gt;

int main(int argc, char *argv[])
{
  GtkWidget *window;
  gtk_init (&amp;argc, &amp;argv);
  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_widget_show (window);
  gtk_main ();
  return 0;
}</pre></div><p>To build it, we use the <code class="literal">core-image-sato</code> toolchain installed as described previously:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source /opt/poky/1.7.1/environment-setup-cortexa9hf-vfp-neon-poky- linux-gnueabi</strong></span>
<span class="strong"><strong>$ ${CC} gtk_hello_world.c -o helloworld `pkg-config --cflags --libs gtk+-2.0`</strong></span>
</pre></div><p>This command uses the <code class="literal">pkg-config</code> helper tool to read the <code class="literal">.pc</code> files that are installed with the GTK libraries in the <code class="literal">sysroot</code> to determine which compiler switches (<code class="literal">--cflags</code> for <code class="literal">include</code> directories and <code class="literal">--libs</code> for the libraries to link with) are needed to compile programs that use GTK.</p><p>We can manually copy the resulting binary to our Wandboard while booting <code class="literal">core-image-sato</code> over NFS and run it from the target's console with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># DISPLAY=:0 helloworld</strong></span>
</pre></div><p>This will open a GTK+ window over the SATO desktop.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec160"/>How to do it...</h2></div></div></div><p>We can now configure <a id="id473" class="indexterm"/>the Eclipse ADT plugin using the standalone toolchain as described before, or we could decide to use the build system derived toolchain instead.</p><div class="mediaobject"><img src="graphics/5186OS_04_04.jpg" alt="How to do it..."/></div><p>Follow the next steps to build and run an example hello world application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new hello world GTK autotools project. Accept all the defaults in the project creation wizard. Browse to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Project</strong></span> | <span class="strong"><strong>C/C++</strong></span> | <span class="strong"><strong>C Project</strong></span> | <span class="strong"><strong>Yocto Project ADT Autotools Project</strong></span> | <span class="strong"><strong>Hello World GTK C Autotools Project</strong></span>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>When choosing a name for your project, avoid using special characters like dashes, as they could cause problems with the build tools.</p></div></div></li><li class="listitem">Build the project <a id="id474" class="indexterm"/>by going to <span class="strong"><strong>Project</strong></span> | <span class="strong"><strong>Build Project</strong></span>.<div class="mediaobject"><img src="graphics/5186OS_04_05.jpg" alt="How to do it..."/></div></li><li class="listitem">Even though the<a id="id475" class="indexterm"/> project builds successfully, you may see errors both marked in the source and in the <span class="strong"><strong>Problems</strong></span> tab. This is because the Eclipse's code analysis feature cannot resolve all the project's symbols. To resolve it, add the needed <code class="literal">include</code> header files to your project's properties by going to <span class="strong"><strong>Project</strong></span> | <span class="strong"><strong>Properties</strong></span> | <span class="strong"><strong>C/C++ General</strong></span> | <span class="strong"><strong>Paths and Symbols</strong></span> | <span class="strong"><strong>Includes</strong></span>.<div class="mediaobject"><img src="graphics/5186OS_04_06.jpg" alt="How to do it..."/></div></li><li class="listitem">Under <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run Configurations</strong></span>, you should have <span class="strong"><strong>C/C++ Remote Application</strong></span> with<a id="id476" class="indexterm"/> a TCF target called <code class="literal">&lt;project_name&gt;_gdb_arm-poky-linux-gnueabi</code>. If you don't, create one.<div class="mediaobject"><img src="graphics/5186OS_04_07.jpg" alt="How to do it..."/></div></li><li class="listitem">Create a new <a id="id477" class="indexterm"/>TCF connection to the target's IP address using the <span class="strong"><strong>New...</strong></span> button in the <span class="strong"><strong>Main</strong></span> tab.<div class="mediaobject"><img src="graphics/5186OS_04_08.jpg" alt="How to do it..."/></div></li><li class="listitem">Fill in the <span class="strong"><strong>Remote Absolute File Path for C/C++ Application</strong></span> field with the path to the binary and include the binary name; for example, <code class="literal">/gtk_hello_world</code>.</li><li class="listitem">In the <span class="strong"><strong>Commands to execute before application</strong></span> field, enter <code class="literal">export DISPLAY=:0</code>.<div class="mediaobject"><img src="graphics/5186OS_04_09.jpg" alt="How to do it..."/></div></li><li class="listitem">Run the <a id="id478" class="indexterm"/>application and log in as <code class="literal">root</code> with an empty password. You should see the GTK application on your SATO desktop, and the following output in the Console tab:<div class="mediaobject"><img src="graphics/5186OS_04_23.jpg" alt="How to do it..."/></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>If you have<a id="id479" class="indexterm"/> problems connecting to the target, verify that it is running <code class="literal">tcf-agent</code> by typing in the following on the target's console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps w | grep tcf</strong></span>
<span class="strong"><strong>735 root     11428 S    /usr/sbin/tcf-agent -d -L- -l0</strong></span>
</pre></div><p>If you have login problems, you can use Eclipse's <span class="strong"><strong>Remote System Explorer</strong></span> (<span class="strong"><strong>RSE)</strong></span> perspective to clear passwords and debug the connection to the target. Once the connection can be established and you are able to browse the target's filesystem through RSE, you can come back to the run configuration.</p></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec161"/>There's more...</h2></div></div></div><p>To debug the <a id="id480" class="indexterm"/>application, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Debug Configuration</strong></span>.</li><li class="listitem">Under the <span class="strong"><strong>Debugger</strong></span> tab, verify the GDB debugger path is the correct toolchain debugger location.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/opt/poky/1.7.1/sysroots/x86_64-pokysdk-linux/usr/bin/arm- poky-linux-gnueabi/arm-poky-linux-gnueabi-gdb</strong></span>
</pre></div><p>If it isn't, point it to the correct location.</p><div class="mediaobject"><img src="graphics/5186OS_04_10.jpg" alt="There's more..."/></div></li><li class="listitem">Double-click<a id="id481" class="indexterm"/> on the <code class="literal">main</code> function in the source file to add a breakpoint. A blue dot will appear on the side bar.</li><li class="listitem">Click on the <span class="strong"><strong>Debug</strong></span> button. The debug perspective appears with the application executing on the remote Wandboard hardware.<div class="mediaobject"><img src="graphics/5186OS_04_11.jpg" alt="There's more..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>If you get <a id="id482" class="indexterm"/>
<span class="strong"><strong>Text file busy</strong></span> error, remember to close the application we ran on the previous point.</p></div></div></li></ol></div></div></div>
<div class="section" title="Using the Qt Creator IDE"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec62"/>Using the Qt Creator IDE</h1></div></div></div><p>Qt Creator is a <a id="id483" class="indexterm"/>multiplatform IDE part of the Qt Application Development Framework SDK. It is the IDE of choice for Qt application development and is available with multiple licenses, including GPLv3, LGPLv2, and commercial licenses as well.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec162"/>Getting ready</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download and install the Qt Creator 3.3.0 for your host from the Qt project downloads website. For downloading and installing an x86_64 Linux host, you can use the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ wget http://download.qt.io/official_releases/qtcreator/3.3/3.3.0/qt -creator-opensource-linux-x86_64-3.3.0.run</strong></span>
<span class="strong"><strong>$ chmod u+x qt-creator-opensource-linux-x86_64-3.3.0.run</strong></span>
<span class="strong"><strong>$ ./qt-creator-opensource-linux-x86_64-3.3.0.run</strong></span>
</pre></div></li><li class="listitem">Build a toolchain that is ready to develop Qt applications with the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake meta-toolchain-qt</strong></span>
</pre></div></li><li class="listitem">Install it as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tmp/deploy/sdk</strong></span>
<span class="strong"><strong>$ ./poky-glibc-x86_64-meta-toolchain-qt-cortexa9hf-vfp-neon- toolchain-qt-1.7.1.sh</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec163"/>How to do it...</h2></div></div></div><p>Before launching <a id="id484" class="indexterm"/>Qt Creator, we need to set up the development environment. To make this happen automatically when we launch Qt Creator, we can patch its initialization script by adding the following line right at the beginning of the <code class="literal">bin/qtcreator.sh</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>source /opt/poky/1.7.1/environment-setup-cortexa9hf-vfp-neon-poky- linux-gnueabi</strong></span>
<span class="strong"><strong>#! /bin/sh</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Note that the environment initialization script is placed before the hash bang.</p></div></div><p>Now we can run Qt Creator  as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./bin/qtcreator.sh &amp;</strong></span>
</pre></div><p>And configure it by going to <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Options</strong></span> and using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First we configure a new device for our Wandboard. Under <span class="strong"><strong>Devices</strong></span> | <span class="strong"><strong>Add</strong></span>, we select <span class="strong"><strong>Generic Linux Device</strong></span>.<div class="mediaobject"><img src="graphics/5186OS_04_12.jpg" alt="How to do it..."/></div><p>Set the <a id="id485" class="indexterm"/>root password in the target by using the <code class="literal">passwd</code> command from the target's root console and type it in the password field.</p></li><li class="listitem">Under <span class="strong"><strong>Build &amp; Run</strong></span>, we configure a new compiler pointing to the Yocto <code class="literal">meta-toolchain-qt</code> compiler path we just installed. Here's the path as shown in the following screenshot:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/opt/poky/1.7.1/sysroots/x86_64-pokysdk-linux/usr/bin/arm- poky-linux-gnueabi/arm-poky-linux-gnueabi-g++</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/5186OS_04_13.jpg" alt="How to do it..."/></div></li><li class="listitem">Similarly for<a id="id486" class="indexterm"/> a cross-debugger, the following is the path which is also mentioned in the following screenshot:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/opt/poky/1.7.1/sysroots/x86_64-pokysdk-linux/usr/bin/arm- poky-linux-gnueabi/arm-poky-linux-gnueabi-gdb</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/5186OS_04_14.jpg" alt="How to do it..."/></div></li><li class="listitem">And then we<a id="id487" class="indexterm"/> configure Qt by selecting the <code class="literal">qmake</code> builder from the toolchain. Here's the path which is also mentioned in the following screenshot:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/opt/poky/1.7.1/sysroots/x86_64-pokysdk-linux/usr/bin/qmake</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/5186OS_04_15.jpg" alt="How to do it..."/></div></li><li class="listitem">Finally we <a id="id488" class="indexterm"/>configure a new kit as follows:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <span class="strong"><strong>Generic Linux Device</strong></span> and configure its <code class="literal">sysroot</code> to:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/opt/poky/1.7.1/sysroots/cortexa9hf-vfp-neon-poky-linux- gnueabi/</strong></span>
</pre></div></li><li class="listitem">Select the compiler, debugger, and Qt version we just defined.<div class="mediaobject"><img src="graphics/5186OS_04_16.jpg" alt="How to do it..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>In Ubuntu, Qt <a id="id489" class="indexterm"/>Creator stores its configuration on the user's home directory under <code class="literal">.config/QtProject/</code>.</p></div></div></li></ol></div></li></ol></div></div></div>
<div class="section" title="Developing Qt applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec63"/>Developing Qt applications</h1></div></div></div><p>This recipe will show how <a id="id490" class="indexterm"/>to build, run, and debug a graphical Qt application using Qt Creator.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec164"/>Getting ready</h2></div></div></div><p>Before launching Qt Creator, we check whether we are able to build and launch a Qt application manually. We will build a Qt hello world application.</p><p>Here is the code for <code class="literal">qt_hello_world.cpp</code>:</p><div class="informalexample"><pre class="programlisting">#include &lt;QApplication&gt;
#include &lt;QPushButton&gt;

 int main(int argc, char *argv[])
 {
     QApplication app(argc, argv);

     QPushButton hello("Hello world!");

     hello.show();
     return app.exec();
 }</pre></div><p>To build it, we use the <code class="literal">meta-toolchain-qt</code> installed as described previously:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source /opt/poky/1.7.1/environment-setup-cortexa9hf-vfp-neon-poky- linux-gnueabi</strong></span>
<span class="strong"><strong>$ qmake -project</strong></span>
<span class="strong"><strong>$ qmake</strong></span>
<span class="strong"><strong>$ make</strong></span>
</pre></div><p>This uses <code class="literal">qmake</code> to create a <a id="id491" class="indexterm"/>project file and a <code class="literal">Makefile</code> file with all the relevant code files in the folder.</p><p>To run it, we first need to build a filesystem with Qt support. We first prepare the environment as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
</pre></div><p>And configure our project with the <code class="literal">qt4-pkgs</code> extra feature by adding the following to <code class="literal">conf/local.conf</code>:</p><div class="informalexample"><pre class="programlisting">EXTRA_IMAGE_FEATURES += "qt4-pkgs"</pre></div><p>And for Qt applications, we also need the <a id="id492" class="indexterm"/>
<span class="strong"><strong>International Component for Unicode</strong></span> (<span class="strong"><strong>ICU</strong></span>) library, as the Qt libraries are compiled with support for it.</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " icu"</pre></div><p>And build it with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake core-image-sato</strong></span>
</pre></div><p>Once finished, we can program the microSD card image and boot the Wandboard. Copy the <code class="literal">qt_hello_world</code> binary to the target and run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># DISPLAY=:0 qt_hello_world</strong></span>
</pre></div><p>You should see the Qt hello world window on the X11 desktop.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec165"/>How to do it...</h2></div></div></div><p>Follow these steps to build and run an example hello world application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new empty project by going to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New File or Project</strong></span> | <span class="strong"><strong>Other project</strong></span> | <span class="strong"><strong>Empty qmake project</strong></span>.</li><li class="listitem">Select only the <span class="strong"><strong>wandboard-quad</strong></span> kit we just created.<div class="mediaobject"><img src="graphics/5186OS_04_17.jpg" alt="How to do it..."/></div></li><li class="listitem">Add a new <a id="id493" class="indexterm"/>C++ file, <code class="literal">qt_hello_world.cpp</code>, by going to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New File or Project</strong></span> | <span class="strong"><strong>C++</strong></span> | <span class="strong"><strong>C++ Source File</strong></span>.</li><li class="listitem">Paste the contents of the <code class="literal">qt_hello_world.cpp</code> file into Qt Creator, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/5186OS_04_18.jpg" alt="How to do it..."/></div></li><li class="listitem">Configure <a id="id494" class="indexterm"/>your project with the target installation details by adding the following to your <code class="literal">hw.pro</code> file:<div class="informalexample"><pre class="programlisting">SOURCES += \
   qt_hello_world.cpp

TARGET =  qt_hello_world
   target.files =  qt_hello_world
   target.path = /

INSTALLS += target</pre></div><p>Replace <code class="literal">qt_hello_world</code> with the name of your project.</p></li><li class="listitem">Build the project. If you have build errors, verify that the Yocto build environment has been correctly set up.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>You can try to manually run the toolchain <code class="literal">environment-setup</code> script before launching Qt Creator.</p></div></div></li><li class="listitem">Go to <span class="strong"><strong>Projects</strong></span> | <span class="strong"><strong>Run</strong></span> and check your project settings.<div class="mediaobject"><img src="graphics/5186OS_04_19.jpg" alt="How to do it..."/></div></li><li class="listitem">As can be seen<a id="id495" class="indexterm"/> in this screenshot, Qt Creator will use the SFTP protocol to transfer the files to the target. By default, the dropbear SSH server running on <code class="literal">core-image-sato</code> does not have SFTP support. We need to add it to our image to allow Qt Creator to work by adding the <code class="literal">openssh-sftp-server</code> package to the project's <code class="literal">conf/local.conf</code> file.<div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append =  " openssh-sftp-server"</pre></div><p>However, there are other tools we will need, like the <span class="strong"><strong>gdbserver</strong></span> if we want to debug our application, so it's easier to add the <code class="literal">eclipse-debug</code> feature, which will add all of the needed applications to the target image.</p><div class="informalexample"><pre class="programlisting">EXTRA_IMAGE_FEATURES += "eclipse-debug"</pre></div></li><li class="listitem">You can now run the project.<div class="mediaobject"><img src="graphics/5186OS_04_20.jpg" alt="How to do it..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>If the application fails to be deployed with a login error, verify that you have set a root password in the target as explained in the recipe previously, or that you are using SSH key authentication.</p></div></div></li></ol></div><p>You should now see<a id="id496" class="indexterm"/> the example Qt hello world application running on your SATO desktop.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec166"/>There's more...</h2></div></div></div><p>To debug the application, toggle a breakpoint on the source and click on the <span class="strong"><strong>Debug</strong></span> button.</p><div class="mediaobject"><img src="graphics/5186OS_04_21.jpg" alt="There's more..."/></div></div></div>
<div class="section" title="Describing workflows for application development"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec64"/>Describing workflows for application development</h1></div></div></div><p>The workflows for <a id="id497" class="indexterm"/>application <a id="id498" class="indexterm"/>development are similar to the ones we already saw for U-Boot and the Linux kernel back in <a class="link" href="ch02.html" title="Chapter 2. The BSP Layer">Chapter 2</a>, <span class="emphasis"><em>The BSP Layer</em></span>.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec167"/>How to do it...</h2></div></div></div><p>We will see how the following development workflows are applied to application development:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">External development</li><li class="listitem" style="list-style-type: disc">Working directory development</li><li class="listitem" style="list-style-type: disc">External source development</li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec168"/>How it works...</h2></div></div></div><div class="section" title="External development"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec61"/>External development</h3></div></div></div><p>This is what we have been<a id="id499" class="indexterm"/> using on the recipes we saw before when building from the command line using a standalone toolchain, and also when using both the Eclipse and Qt Creator IDEs. This workflow produces binaries that have to be individually copied to the hardware to run and debug. It can be used in conjunction with the other workflows.</p></div><div class="section" title="Working directory development"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec62"/>Working directory development</h3></div></div></div><p>When the application is being <a id="id500" class="indexterm"/>built by the Yocto build system, we use this workflow to debug sporadic problems. However, it is not the recommended workflow for long developments. Note, though, that it is usually the first step when debugging third-party packages.</p><p>We will use the <code class="literal">helloworld_1.0.bb</code> custom recipe we saw back in the <span class="emphasis"><em>Adding new packages</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. The Software Layer">Chapter 3</a>, <span class="emphasis"><em>The Software Layer</em></span>, <code class="literal">meta-custom/recipes-example/helloworld/helloworld_1.0.bb</code>, as an example.</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple helloworld application"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "file://helloworld.c"

S = "${WORKDIR}"

do_compile() {
             ${CC} helloworld.c -o helloworld
}

do_install() {
             install -d ${D}${bindir}
             install -m 0755 helloworld ${D}${bindir}
}</pre></div><p>Here, the <code class="literal">helloworld.c</code> source file is the following:</p><div class="informalexample"><pre class="programlisting">#include &lt;stdio.h&gt;

int main(void)
{
   return printf("Hello World");
}</pre></div><p>The workflow steps are:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start the <a id="id501" class="indexterm"/>package compilation from scratch.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake -c cleanall helloworld</strong></span>
</pre></div><p>This will erase the package's build folder, shared state cache, and downloaded package source.</p></li><li class="listitem">Start a development shell:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c devshell helloworld</strong></span>
</pre></div><p>This will fetch, unpack, and patch the <code class="literal">helloworld</code> sources and spawn a new shell with the environment ready for compilation. The new shell will change to the package's <code class="literal">build</code> directory.</p></li><li class="listitem">Depending on the <code class="literal">SRC_URI</code> variable, the package's <code class="literal">build</code> directory can be revision controlled already. If not, as is the case in this example, we will create a local Git repository as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git init</strong></span>
<span class="strong"><strong>$ git add helloworld.c</strong></span>
<span class="strong"><strong>$ git commit -s -m "Original revision"</strong></span>
</pre></div></li><li class="listitem">Perform the modifications we need; for example, change <code class="literal">helloworld.c</code> to print <code class="literal">Howdy world</code> as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#include &lt;stdio.h&gt;</strong></span>

<span class="strong"><strong>int main(void)</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>   return printf("Howdy World");</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li><li class="listitem">Exit <code class="literal">devshell</code> and build the package without erasing our modifications.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -C compile helloworld</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>Note the capital <code class="literal">C</code> (which invokes the compile task) and also all the tasks that follow it.</p></div></div></li><li class="listitem">Test your <a id="id502" class="indexterm"/>changes on the hardware by copying the generated package and installing it. Because you have only modified one package, the rest of the dependencies should be already installed in the running root filesystem. Run the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -e helloworld | grep ^WORKDIR=</strong></span>
<span class="strong"><strong>WORKDIR="/opt/yocto/fsl-community-bsp/wandboard- quad/tmp/work/cortexa9hf-vfp-neon-poky-linux- gnueabi/helloworld/1.0-r0"</strong></span>
<span class="strong"><strong>$ scp ${WORKDIR_PATH}/deploy-rpms/deploy- rpms/cortexa9hf_vfp_neon/helloworld-1.0- r0.cortexa9hf_vfp_neon.rpm root@&lt;target_ip_address&gt;:/</strong></span>
<span class="strong"><strong>$ rpm -i /helloworld-1.0-r0.cortexa9hf_vfp_neon.rpm</strong></span>
</pre></div><p>This assumes the target's root filesystem has been built with the <code class="literal">package-management</code> feature and the <code class="literal">helloworld</code> package is added to the <code class="literal">RM_WORK_EXCLUDE</code> variable when using the <code class="literal">rm_work</code> class.</p></li><li class="listitem">Go back to <code class="literal">devshell</code> and commit your change to the local Git repository as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake -c devshell helloworld</strong></span>
<span class="strong"><strong>$ git add  helloworld.c</strong></span>
<span class="strong"><strong>$ git commit -s -m "Change greeting message"</strong></span>
</pre></div></li><li class="listitem">Generate a patch into the recipe's patch directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git format-patch -1 -o /opt/yocto/fsl-community- bsp/sources/meta-custom/recipes- example/helloworld/helloworld-1.0</strong></span>
</pre></div></li><li class="listitem">Finally, add the patch to the recipe's <code class="literal">SRC_URI</code> variable, as shown here:<div class="informalexample"><pre class="programlisting">SRC_URI  =  "file://helloworld.c \
           file://0001-Change-greeting-message.patch"</pre></div></li></ol></div></div><div class="section" title="External source development"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec63"/>External source development</h3></div></div></div><p>This workflow is <a id="id503" class="indexterm"/>recommended for development work once the application has been integrated into the Yocto build system. It can be used in conjunction with external development using an IDE, for example.</p><p>In the example recipe we saw earlier, the source file was placed on the <code class="literal">meta-custom</code> layer along with the metadata.</p><p>It is more common to have the recipe fetch directly from a revision control system like Git, so we will<a id="id504" class="indexterm"/> change the <code class="literal">meta-custom/recipes-example/helloworld/helloworld_1.0.bb</code> file to source from a Git directory as follows:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple helloworld application"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "git://github.com/yoctocookbook/helloworld"

S = "${WORKDIR}/git"

do_compile() {
             ${CC} helloworld.c -o helloworld
}

do_install() {
             install -d ${D}${bindir}
             install -m 0755 helloworld ${D}${bindir}
}</pre></div><p>We can then clone it into a local directory as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/</strong></span>
<span class="strong"><strong>$ git clone git://github.com/yoctocookbook/helloworld</strong></span>
</pre></div><p>An alternative to using a remote revision controlled repository it to use a local one. To do so, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a local Git repository that will hold the source:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir -p /opt/yocto/helloworld</strong></span>
<span class="strong"><strong>$ cd /opt/yocto/helloworld</strong></span>
<span class="strong"><strong>$ git init</strong></span>
</pre></div></li><li class="listitem">Copy our <code class="literal">helloworld.c</code> file over here, and add it to the repository:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git add helloworld.c</strong></span>
</pre></div></li><li class="listitem">Finally, commit it with a signature and a message:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git commit -s -m "Original revision"</strong></span>
</pre></div></li></ol></div><p>In any case, we have the version-controlled source in a local directory. We will then configure our <code class="literal">conf/local.conf</code> file to work from it as follows:</p><div class="informalexample"><pre class="programlisting">INHERIT += "externalsrc"
EXTERNALSRC_pn-helloworld = "/opt/yocto/helloworld"
EXTERNALSRC_BUILD_pn-helloworld = "/opt/yocto/helloworld"</pre></div><p>And build it with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake helloworld</strong></span>
</pre></div><p>We can then<a id="id505" class="indexterm"/> work directly in the local folder without the risk of accidentally having BitBake erase our code. Once development is complete, the modifications to <code class="literal">conf/local.conf</code> are removed and the recipe will fetch the source from its original <code class="literal">SRC_URI</code> location.</p></div></div></div>
<div class="section" title="Working with GNU make"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec65"/>Working with GNU make</h1></div></div></div><p>GNU make<a id="id506" class="indexterm"/> is a make implementation for Linux systems. It is used by a wide variety of open source projects, including the Linux kernel. The build is managed by a <code class="literal">Makefile</code>, which tells make how to build the source code.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec169"/>How to do it...</h2></div></div></div><p>Yocto recipes inherit <code class="literal">base.bbclass</code> and hence their default behavior is to look for a <code class="literal">Makefile</code>, <code class="literal">makefile</code>, or <code class="literal">GNU Makefile</code> and use GNU make to build the package.</p><p>If your package already contains a <code class="literal">Makefile</code>, then all you need to worry about are the arguments that need to be passed to make. Make arguments can be passed using the <code class="literal">EXTRA_OEMAKE</code> variable, and a <code class="literal">do_install</code> override that calls the <code class="literal">oe_runmake</code> install needs to be provided, otherwise an empty install is run.</p><p>For example, the<a id="id507" class="indexterm"/> <code class="literal">logrotate</code> recipe is based on a <code class="literal">Makefile</code> and looks as follows:</p><div class="informalexample"><pre class="programlisting">SUMMARY = "Rotates, compresses, removes and mails system log files"
SECTION = "console/utils"
HOMEPAGE = "https://fedorahosted.org/logrotate/"
LICENSE = "GPLv2"

DEPENDS="coreutils popt"

LIC_FILES_CHKSUM = "file://COPYING;md5=18810669f13b87348459e611d31ab760"

SRC_URI = "https://fedorahosted.org/releases/l/o/logrotate/logrotate- ${PV}.tar.gz \"
SRC_URI[md5sum] = "99e08503ef24c3e2e3ff74cc5f3be213"
SRC_URI[sha256sum] = "f6ba691f40e30e640efa2752c1f9499a3f9738257660994de70a45fe00d12b64"

EXTRA_OEMAKE = ""

do_install(){
    oe_runmake install DESTDIR=${D} PREFIX=${D} MANDIR=${mandir}
    mkdir -p ${D}${sysconfdir}/logrotate.d
    mkdir -p ${D}${sysconfdir}/cron.daily
    mkdir -p ${D}${localstatedir}/lib
    install -p -m 644 examples/logrotate-default ${D}${sysconfdir}/logrotate.conf
    install -p -m 755 examples/logrotate.cron ${D}${sysconfdir}/cron.daily/logrotate
    touch ${D}${localstatedir}/lib/logrotate.status
}</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec170"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information about<a id="id508" class="indexterm"/> GNU make, visit <a class="ulink" href="https://www.gnu.org/software/make/manual/">https://www.gnu.org/software/make/manual/</a></li></ul></div></div></div>
<div class="section" title="Working with the GNU build system"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec66"/>Working with the GNU build system</h1></div></div></div><p>A <code class="literal">Makefile</code> is a good solution <a id="id509" class="indexterm"/>when you are always going to build and run your software on the same system, and things like <code class="literal">glibc</code> and <code class="literal">gcc</code> versions and the available library versions are known. However, most software need to be built and run in a variety of systems.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec171"/>Getting ready</h2></div></div></div><p>The GNU build system, or <code class="literal">autotools</code>, is a set of tools whose aim is to create a <code class="literal">Makefile</code> for your software in a variety of systems. It's made up of three main tools:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">autoconf</code>: This parses <a id="id510" class="indexterm"/>the contents of a <code class="literal">configure.ac</code> file that describes the source code to be built and creates a <code class="literal">configure</code> script. This script will then be used to generate the final <code class="literal">Makefile</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">automake</code>: This <a id="id511" class="indexterm"/>parses the contents of a <code class="literal">Makefile.am</code> file and converts it into a <code class="literal">Makefile.in</code> file. This is then used by the <code class="literal">configure</code> script generated earlier to obtain a <code class="literal">config.status</code> script that gets automatically executed to obtain the final <code class="literal">Makefile</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">libtools</code>: This <a id="id512" class="indexterm"/>manages the creation of both static and dynamic libraries.</li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec172"/>How to do it...</h2></div></div></div><p>The Yocto <a id="id513" class="indexterm"/>build system contains classes with the required knowledge to build <code class="literal">autotools</code> packages. All your recipe needs to do is to inherit the <code class="literal">autotools</code> class and configure the arguments to be passed to the <code class="literal">configure</code> script in the <code class="literal">EXTRA_OECONF</code> variable. Usually, the <code class="literal">autotools</code> system understands how to install the software, so you do not need a <code class="literal">do_install</code> override.</p><p>There is a wide variety of open source projects that use <code class="literal">autotools</code> as the build system.</p><p>An example, <code class="literal">meta-custom/recipes-example/hello/hello_2.9.bb</code>, that does not need any extra configure options, follows:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "GNU helloworld autotools recipe"
SECTION = "examples"

LICENSE = "GPLv3"
LIC_FILES_CHKSUM = "file://${COREBASE}/meta/files/common- licenses/GPL-3.0;md5=c79ff39f19dfec6d293b95dea7b07891"

SRC_URI = "${GNU_MIRROR}/hello/hello-${PV}.tar.gz"
SRC_URI[md5sum] = "67607d2616a0faaf5bc94c59dca7c3cb"
SRC_URI[sha256sum] = "ecbb7a2214196c57ff9340aa71458e1559abd38f6d8d169666846935df191ea7"

inherit autotools gettext</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec173"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information about the <a id="id514" class="indexterm"/>GNU build system, visit <a class="ulink" href="http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html">http://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html</a></li></ul></div></div></div>
<div class="section" title="Working with the CMake build system"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec67"/>Working with the CMake build system</h1></div></div></div><p>The GNU make<a id="id515" class="indexterm"/> system is a great tool when you build exclusively for Linux systems. However, some packages are multiplatform and need a way to manage <code class="literal">Makefile</code> files on different operating systems. <span class="strong"><strong>CMake</strong></span><a id="id516" class="indexterm"/> is a cross-platform build system that can work not only with GNU make, but also Microsoft Visual Studio and Apple's Xcode.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec174"/>Getting ready</h2></div></div></div><p>The CMake tool parses the <code class="literal">CMakeLists.txt</code> files in every directory to control the build process. An example <code class="literal">CMakeLists.txt</code> file to compile the hello world example follows:</p><div class="informalexample"><pre class="programlisting">cmake_minimum_required(VERSION 2.8.10)
project(helloworld)
add_executable(helloworld helloworld.c)
install(TARGETS helloworld RUNTIME DESTINATION bin)</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec175"/>How to do it...</h2></div></div></div><p>The Yocto build system also contains classes with the required knowledge to build CMake packages. All your recipe needs to do is to inherit the <code class="literal">cmake</code> class and configure the arguments to be passed to the <code class="literal">configure</code> script in the <code class="literal">EXTRA_OECMAKE</code> variable. Usually, the CMake system understands how to install the software, so you do not need a <code class="literal">do_install</code> override.</p><p>A recipe to build the <code class="literal">helloworld.C</code> example application, <code class="literal">meta-custom/recipes-example/helloworld-cmake/helloworld-cmake_1.0.bb</code>, follows:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple helloworld cmake application"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "file://CMakeLists.txt \
           file://helloworld.c"
S = "${WORKDIR}"

inherit cmake

EXTRA_OECMAKE = ""</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec176"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information about <a id="id517" class="indexterm"/>CMake, visit <a class="ulink" href="http://www.cmake.org/documentation/">http://www.cmake.org/documentation/</a></li></ul></div></div></div>
<div class="section" title="Working with the SCons builder"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec68"/>Working with the SCons builder</h1></div></div></div><p><span class="strong"><strong>SCons</strong></span><a id="id518" class="indexterm"/> is also a multiplatform build system written in Python, with its configuration files also written in the same language. It also includes support for Microsoft Visual Studio among other features.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec177"/>Getting ready</h2></div></div></div><p>SCons parses the <code class="literal">SConstruct</code> files, and by default it does not propagate the environment into the build system. This <a id="id519" class="indexterm"/>is to avoid build issues caused by environment differences. This is a complication for Yocto, as it configures the environment with the cross-compilation toolchain settings.</p><p>SCons does not define a standard way to support cross-compilation, so every project will implement it differently. For a simple example as the hello world program, we can just initialize the <code class="literal">CC</code> and <code class="literal">PATH</code> variables from the external environment as follows:</p><div class="informalexample"><pre class="programlisting">import os
env = Environment(CC = os.environ['CC'],
                  ENV = {'PATH': os.environ['PATH']})
env.Program("helloworld", "helloworld.c")</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec178"/>How to do it...</h2></div></div></div><p>The Yocto build system also contains classes with the required knowledge to build SCons packages. All your recipe needs to do is to inherit the <code class="literal">SCons</code> class and configure the arguments to be passed to the configure script in the <code class="literal">EXTRA_OESCONS</code> variable. Although some packages using <code class="literal">SCons</code> might deal with installation through an install alias as required by the <code class="literal">SCons</code> class, your recipe will mostly need to provide a <code class="literal">do_install</code> task override.</p><p>An example recipe to build the <code class="literal">helloworld.c</code> example application, <code class="literal">meta-custom/recipes-example/helloworld-scons/helloworld-scons_1.0.bb</code>, follows:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple helloworld scons application"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "file://SConstruct \
           file://helloworld.c"

S = "${WORKDIR}"

inherit scons

EXTRA_OESCONS = ""

do_install() {
    install -d ${D}/${bindir}
    install -m 0755 helloworld ${D}${bindir}
}</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec179"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information about <a id="id520" class="indexterm"/>SCons, visit <a class="ulink" href="http://www.scons.org/doc/HTML/scons-user/">http://www.scons.org/doc/HTML/scons-user/</a></li></ul></div></div></div>
<div class="section" title="Developing with libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec69"/>Developing with libraries</h1></div></div></div><p>Most applications make use of shared libraries, which saves system memory and disk space, as they are shared between different applications. Modularizing code into libraries also allows for easier versioning and code management.</p><p>This recipe will explain how to work with both static and shared libraries in Linux and Yocto.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec180"/>Getting ready</h2></div></div></div><p>By convention, library files start with the <code class="literal">lib</code> prefix.</p><p>There are basically two library types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Static libraries</strong></span> (<code class="literal">.a</code>): When the object code is linked and becomes part of the application</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dynamic libraries</strong></span> (<code class="literal">.so</code>): Linked at<a id="id521" class="indexterm"/> compile time but not included in the application, so they need to be available at runtime. Multiple applications can share a dynamic library so they need less disk space.</li></ul></div><p>Libraries are placed in the following standard root filesystem locations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/lib</code>: Libraries required for startup</li><li class="listitem" style="list-style-type: disc"><code class="literal">/usr/lib</code>: Most system libraries</li><li class="listitem" style="list-style-type: disc"><code class="literal">/usr/local/lib</code>: Non-system libraries</li></ul></div><p>Dynamic libraries<a id="id522" class="indexterm"/> follow certain naming conventions on running systems so that multiple versions can co-exist, so a library can be referenced by different names. Some of them are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The linker name with the <code class="literal">.so</code> suffix; for example, <code class="literal">libexample.so</code>.</li><li class="listitem" style="list-style-type: disc">The fully qualified name or <code class="literal">soname</code>, a symbolic link to the library name. For example, <code class="literal">libexample.so.x</code>, where <code class="literal">x</code> is the version number. Increasing the version number means the library is not compatible with previous versions.</li><li class="listitem" style="list-style-type: disc">The real name. For example, <code class="literal">libexample.so.x.y[.z]</code>, where <code class="literal">x</code> is the major version number, <code class="literal">y</code> is the minor version number, and the optional <code class="literal">z</code> is a release number. Increasing minor or release numbers retains compatibility.</li></ul></div><p>In GNU <code class="literal">glibc</code>, starting an ELF binary calls a program loader, <code class="literal">/lib/ld-linux-X</code>. Here, <code class="literal">X</code> is the version number, which finds all the needed shared libraries. This process uses a couple of interesting files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/etc/ld.so.conf</code>: This stores the directories searched by the loader</li><li class="listitem" style="list-style-type: disc"><code class="literal">/etc/ld.so.preload</code>: This is used to override libraries</li></ul></div><p>The <code class="literal">ldconfig</code> tool reads the <code class="literal">ld.so.conf</code> file and creates a cache file (<code class="literal">/etc/ld.so.cache</code>) to increase access speed.</p><p>The following environment variables can also be helpful:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LD_LIBRARY_PATH</code>: This is a colon-separated directory list to search libraries in. It is used when debugging or using non-standard library locations.</li><li class="listitem" style="list-style-type: disc"><code class="literal">LD_PRELOAD</code>: This is used to override shared libraries.</li></ul></div><div class="section" title="Building a static library"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec64"/>Building a static library</h3></div></div></div><p>We will build a <a id="id523" class="indexterm"/>static library, <code class="literal">libhelloworld</code>, from two source files, <code class="literal">hello.c</code> and <code class="literal">world.c</code>, and use it to build a hello world application. The source files for the library are presented here.</p><p>The following is the code for the <code class="literal">hello.c</code> file:</p><div class="informalexample"><pre class="programlisting">char * hello (void)
{
  return "Hello";
}</pre></div><p>This is the code for <code class="literal">world.c</code> file:</p><div class="informalexample"><pre class="programlisting">char * world (void)
{
  return "World";
}</pre></div><p>To build the library, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Configure the build environment:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source /opt/poky/1.7.1/environment-setup-cortexa9hf-vfp- neon-poky-linux-gnueabi</strong></span>
</pre></div></li><li class="listitem">Compile and link the library:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>${CC} -c hello.c world.c</strong></span>
<span class="strong"><strong>${AR} -cvq libhelloworld.a hello.o world.o</strong></span>
</pre></div></li><li class="listitem">Verify the contents of the library:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>${AR} -t libhelloworld.a</strong></span>
</pre></div></li></ol></div><p>The application <a id="id524" class="indexterm"/>source code is presented next.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For the <code class="literal">helloworld.c</code> file the following is the code:<div class="informalexample"><pre class="programlisting">#include &lt;stdio.h&gt;
int main (void)
{
  return printf("%s %s\n",hello(),world());
}</pre></div></li><li class="listitem" style="list-style-type: disc">To build it we run:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>${CC} -o helloworld helloworld.c libhelloworld.a</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">We can check which libraries it links with using <code class="literal">readelf</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ readelf -d helloworld</strong></span>
<span class="strong"><strong>Dynamic section at offset 0x534 contains 24 entries:</strong></span>
<span class="strong"><strong>  Tag        Type                         Name/Value</strong></span>
<span class="strong"><strong> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</strong></span>
</pre></div></li></ul></div></div><div class="section" title="Building a shared dynamic library"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec65"/>Building a shared dynamic library</h3></div></div></div><p>To build a <a id="id525" class="indexterm"/>dynamic library from the same sources, we would run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>${CC} -fPIC -g -c hello.c world.c</strong></span>
<span class="strong"><strong>${CC} -shared -Wl,-soname,libhelloworld.so.1 -o libhelloworld.so.1.0 hello.o world.o</strong></span>
</pre></div><p>We can then use it to build our <code class="literal">helloworld C</code> application, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>${CC} helloworld.c libhelloworld.so.1.0 -o helloworld</strong></span>
</pre></div><p>And again, we <a id="id526" class="indexterm"/>can check the dynamic libraries using <code class="literal">readelf</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ readelf -d helloworld</strong></span>
<span class="strong"><strong>Dynamic section at offset 0x6ec contains 25 entries:</strong></span>
<span class="strong"><strong>  Tag        Type                         Name/Value</strong></span>
<span class="strong"><strong> 0x00000001 (NEEDED)                     Shared library: [libhelloworld.so.1]</strong></span>
<span class="strong"><strong> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</strong></span>
</pre></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec181"/>How to do it...</h2></div></div></div><p>An example recipe for the static library<a id="id527" class="indexterm"/> example we just saw follows, <code class="literal">meta-custom/recipes-example/libhelloworld-static/libhelloworldstatic_1.0.bb</code>:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple helloworld example static library"
SECTION = "libs"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "file://hello.c \
           file://world.c \
           file://helloworld.pc"
S = "${WORKDIR}"

do_compile() {
        ${CC} -c hello.c world.c
        ${AR} -cvq libhelloworld.a hello.o world.o
}

do_install() {
        install -d ${D}${libdir}
        install -m 0755 libhelloworld.a ${D}${libdir}
}</pre></div><p>By default, the configuration in <code class="literal">meta/conf/bitbake.conf</code> places all static libraries in a <code class="literal">-staticdev</code> package. It is also placed in the <code class="literal">sysroot</code> so that it can be used.</p><p>For a dynamic library, we <a id="id528" class="indexterm"/>would use the following recipe, <code class="literal">meta-custom/recipes-example/libhelloworld-dyn/libhelloworlddyn_1.0.bb</code>:</p><div class="informalexample"><pre class="programlisting">meta-custom/recipes-example/libhelloworld-dyn/libhelloworlddyn_1.0.bb
DESCRIPTION = "Simple helloworld example dynamic library"
SECTION = "libs"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "file://hello.c \
           file://world.c \
           file://helloworld.pc"

S = "${WORKDIR}"

do_compile() {
       ${CC} -fPIC -g -c hello.c world.c
       ${CC} -shared -Wl,-soname,libhelloworld.so.1 -o libhelloworld.so.1.0 hello.o world.o
}

do_install() {
       install -d ${D}${libdir}
       install -m 0755 libhelloworld.so.1.0 ${D}${libdir}
       ln -s libhelloworld.so.1.0 ${D}/${libdir}/libhelloworld.so.1
       ln -s libhelloworld.so.1 ${D}/${libdir}/libhelloworld.so
}</pre></div><p>Usually we would list the library dependencies (if any) in the <code class="literal">RDEPENDS</code> variable, but this is not always needed as the build system performs some automatic dependency checking by inspecting both the library file and the <code class="literal">pkg-config</code> file and adding the dependencies it finds to <code class="literal">RDEPENDS</code> automatically.</p><p>Multiple versions of the same library can co-exist on the running system. For that, you need to provide different recipes with the same package name but different package revision. For example, we would have <code class="literal">libhelloworld-1.0.bb</code> and <code class="literal">libhelloworld-1.1.bb</code>.</p><p>And to build an application using the static library, we would create a recipe in <code class="literal">meta-custom/recipes-example/helloworld-static/helloworldstatic_1.0.bb</code>, as follows:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple helloworld example"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

DEPENDS = "libhelloworld-static"

SRC_URI = "file://helloworld.c"

S = "${WORKDIR}"

do_compile() {
        ${CC} -o helloworld helloworld.c ${STAGING_LIBDIR}/libhelloworld.a
}

do_install() {
        install -d ${D}${bindir}
        install -m 0755 helloworld ${D}${bindir}
}</pre></div><p>To build using the<a id="id529" class="indexterm"/> dynamic library, we would just need to change the recipe in <code class="literal">meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb</code> to <code class="literal">meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb</code>:</p><div class="informalexample"><pre class="programlisting">meta-custom/recipes-example/helloworld-shared/helloworldshared_1.0.bb
DESCRIPTION = "Simple helloworld example"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

DEPENDS = "libhelloworld-dyn"

SRC_URI = "file://helloworld.c"

S = "${WORKDIR}"

do_compile() {
        ${CC} -o helloworld helloworld.c -lhelloworld
}

do_install() {
        install -d ${D}${bindir}
        install -m 0755 helloworld ${D}${bindir}
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec182"/>How it works...</h2></div></div></div><p>Libraries should <a id="id530" class="indexterm"/>provide the information required to use them, such as <code class="literal">include</code> headers and <code class="literal">library</code> dependencies. The Yocto Project provides two ways for libraries to provide build settings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">binconfig</code> class. This is a legacy class used for libraries that provide a <code class="literal">-config</code> script to provide build settings.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">pkgconfig</code> class. This is the recommended method for libraries to provide build settings.</li></ul></div><p>A <code class="literal">pkg-config</code> build settings file has the <code class="literal">.pc</code> suffix, is distributed with the library, and is installed in a common location known to the <code class="literal">pkg-config</code> tool.</p><p>The <code class="literal">helloworld.pc</code> file for the dynamic library looks as follows:</p><div class="informalexample"><pre class="programlisting">prefix=/usr/local
exec_prefix=${prefix}
includedir=${prefix}/include
libdir=${exec_prefix}/lib

Name: helloworld
Description: The helloworld library
Version: 1.0.0
Cflags: -I${includedir}/helloworld
Libs: -L${libdir} -lhelloworld</pre></div><p>However, for the static library, we would change the last line to:</p><div class="informalexample"><pre class="programlisting">Libs: -L${libdir} libhelloworld.a</pre></div><p>A package wanting to use this <code class="literal">.pc</code> file would inherit the <code class="literal">pkgconfig</code> class.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec183"/>There's more...</h2></div></div></div><p>There's a provision for packages that build both a library and an executable but do not want both of them installed together. By inheriting the <code class="literal">lib_package</code> class, the package will create a separate <code class="literal">-bin</code> package with the executables.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec184"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More details regarding <code class="literal">pkg-config</code> can be <a id="id531" class="indexterm"/>found at <a class="ulink" href="http://www.freedesktop.org/wiki/Software/pkg-config/">http://www.freedesktop.org/wiki/Software/pkg-config/</a></li></ul></div></div></div>
<div class="section" title="Working with the Linux framebuffer"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec70"/>Working with the Linux framebuffer</h1></div></div></div><p>The Linux kernel provides an <a id="id532" class="indexterm"/>abstraction for the graphical hardware in the form of framebuffer devices. These allow applications to access the graphics hardware through a well-defined API. The framebuffer is also used to provide a graphical console to the Linux kernel, so that it can, for example, display colors and a logo.</p><p>In this recipe, we will explore how applications can use the Linux framebuffer to display graphics and video.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec185"/>Getting ready</h2></div></div></div><p>Some applications, especially<a id="id533" class="indexterm"/> in embedded devices, are able to access the framebuffer by mapping the memory and accessing it directly. For example, the <code class="literal">gstreamer</code> framework is able to work directly over the framebuffer, as is the Qt graphical framework.</p><p>Qt is a cross-platform application framework written in C++ and developed both by Digia, under the Qt company name, and the open source Qt project community.</p><p>For Qt applications, Poky provides a <code class="literal">qt4e-demo-image</code> and the FSL community BSP provides a <code class="literal">qte-in-use-image</code>, both of which include support for Qt4 Extended over the framebuffer. The provided framework also includes support for hardware acceleration – not only video but also 2D and 3D graphical acceleration provided through the OpenGL and OpenVG APIs.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec186"/>How to do it...</h2></div></div></div><p>To compile the Qt hello world application we saw in the <span class="emphasis"><em>Developing Qt applications</em></span> recipe earlier, we could use the following <code class="literal">meta-custom/recipes-qt/qt-helloworld/qt-helloworld_1.0.bb</code> Yocto recipe:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple QT helloworld example"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

RDEPENDS_${PN} += "icu"

SRC_URI = "file://qt_hello_world.cpp \
           file://qt_hello_world.pro"

S = "${WORKDIR}"

inherit qt4e

do_install() {
         install -d ${D}${bindir}
         install -m 0755 qt_hello_world ${D}${bindir}
}</pre></div><p>Here the <code class="literal">meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.cpp</code> source file is as <a id="id534" class="indexterm"/>follows:</p><div class="informalexample"><pre class="programlisting">#include &lt;QApplication&gt;
#include &lt;QPushButton&gt;

 int main(int argc, char *argv[])
 {
     QApplication app(argc, argv);

     QPushButton hello("Hello world!");

     hello.show();
     return app.exec();
 }</pre></div><p>And the <code class="literal">meta-custom/recipes-qt/qt-helloworld/qt-helloworld-1.0/qt_hello_world.pro</code> project file is as follows:</p><div class="informalexample"><pre class="programlisting">SOURCES += \
   qt_hello_world.cpp</pre></div><p>Then we add it to the image by using the following in your project's <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " qt-helloworld"</pre></div><p>And we build the image with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake qt4e-demo-image</strong></span>
</pre></div><p>We can then program the SD card image, boot it, log in to the Wandboard, and launch the application by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># qt_hello_world -qws</strong></span>
</pre></div><p>The <code class="literal">-qws</code> command-line option is needed to run the server application.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec187"/>How it works...</h2></div></div></div><p>The framebuffer<a id="id535" class="indexterm"/> devices are located under <code class="literal">/dev</code>. The default framebuffer device is <code class="literal">/dev/fb0</code>, and if the graphics hardware provides more than one, they will be sequentially numbered.</p><p>By default, the Wandboard boots with two framebuffer devices, <code class="literal">fb0</code> and <code class="literal">fb1</code>. The first is the default video display, and the second one is an overlay plane that can be used to combine content on the display.</p><p>However, the i.MX6 SoC supports up to four displays, so it could have up to four framebuffer devices in addition to two overlay framebuffers.</p><p>You can change the default framebuffer used by applications with the <code class="literal">FRAMEBUFFER</code> environment variable. For example, if your hardware supports several framebuffers, you could use the second one by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># export FRAMEBUFFER=/dev/fb1</strong></span>
</pre></div><p>The framebuffer devices are memory mapped and you can perform file operations on them. For example, you can clear the contents of the screen by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /dev/zero &gt; /dev/fb0</strong></span>
</pre></div><p>Or copy it with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /dev/fb0 &gt; fb.raw</strong></span>
</pre></div><p>You may even restore the contents with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat fb.raw &gt; /dev/fb0</strong></span>
</pre></div><p>User space programs can also interrogate the framebuffers or modify their configuration programmatically using <code class="literal">ioctls</code>, or from the console by using the <code class="literal">fbset</code> application, which is included in Yocto's core images as a BusyBox applet.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># fbset -fb /dev/fb0</strong></span>
<span class="strong"><strong>mode "1920x1080-60"</strong></span>
<span class="strong"><strong>        # D: 148.500 MHz, H: 67.500 kHz, V: 60.000 Hz</strong></span>
<span class="strong"><strong>        geometry 1920 1080 1920 1080 24</strong></span>
<span class="strong"><strong>        timings 6734 148 88 36 4 44 5</strong></span>
<span class="strong"><strong>        accel false</strong></span>
<span class="strong"><strong>        rgba 8/16,8/8,8/0,0/0</strong></span>
<span class="strong"><strong>endmode</strong></span>
</pre></div><p>You can configure the framebuffer HDMI device with a specific resolution, bits per pixel, and refresh rate by passing the <code class="literal">video</code> command-line option from the U-Boot bootloader to the Linux kernel. The specific format depends on the device framebuffer driver, and for the Wandboard it is as follows:</p><div class="informalexample"><pre class="programlisting">video=mxcfbn:dev=hdmi,&lt;xres&gt;x&lt;yres&gt;M[@rate]</pre></div><p>Where:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">n</code> is the framebuffer number</li><li class="listitem" style="list-style-type: disc"><code class="literal">xres</code> is the horizontal resolution</li><li class="listitem" style="list-style-type: disc"><code class="literal">yres</code> is the vertical resolution</li><li class="listitem" style="list-style-type: disc"><code class="literal">M</code> specifies that the timings are to be calculated using the VESA coordinated video timings instead of from a look-up table</li><li class="listitem" style="list-style-type: disc"><code class="literal">rate</code> is the refresh rate</li></ul></div><p>For example, for <a id="id536" class="indexterm"/>the <code class="literal">fb0</code> framebuffer, you could use:</p><div class="informalexample"><pre class="programlisting">video=mxcfb0:dev=hdmi,1920x1080M@60</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>Note that after some time of inactivity, the virtual console will blank out. To unblank the display, use:</p><div class="informalexample"><pre class="programlisting"># echo 0 &gt; /sys/class/graphics/fb0/blank</pre></div></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec188"/>There's more...</h2></div></div></div><p>The FSL community BSP layer<a id="id537" class="indexterm"/> also provides a <code class="literal">fsl-image-multimedia</code> target image that includes the <code class="literal">gstreamer</code> framework, including plugins that make use of the hardware acceleration features within the i.MX6 SoC. A <code class="literal">fsl-image-multimedia-full</code> image is also provided, which extends the supported <code class="literal">gstreamer</code> plugins.</p><p>To build the <code class="literal">fsl-image-multimedia</code> image with framebuffer support, you need to remove the graphical distribution features by adding the following to your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">DISTRO_FEATURES_remove = "x11 directfb wayland"</pre></div><p>And build the image with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake fsl-image-multimedia</strong></span>
</pre></div><p>The resulting <code class="literal">fsl-image-multimedia-wandboard-quad.sdcard</code> image at <code class="literal">tmp/deploy/images</code> can be programmed into a microSD card and booted.</p><p>The default Wandboard device tree defines an <code class="literal">mxcfb1</code> node as follows:</p><div class="informalexample"><pre class="programlisting">       mxcfb1: fb@0 {
                compatible = "fsl,mxc_sdc_fb";
                disp_dev = "hdmi";
                interface_pix_fmt = "RGB24";
                mode_str ="1920x1080M@60";
                default_bpp = &lt;24&gt;;
                int_clk = &lt;0&gt;;
                late_init = &lt;0&gt;;
        };</pre></div><p>So, connecting a 1920x1080 HDMI monitor should show a virtual terminal with the Poky login prompt.</p><p>We can then use <a id="id538" class="indexterm"/>the <code class="literal">gstreamer</code> command-line tool, <code class="literal">gst-launch</code>, to construct <code class="literal">gstreamer</code> pipelines. For example, to view a hardware-accelerated video over the framebuffer, you can download the Big Bunny teaser full HD video file and play it over the framebuffer using the <code class="literal">gstreamer</code> framework's <code class="literal">gst-launch</code> command-line tool as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /home/root</strong></span>
<span class="strong"><strong># wget http://video.blendertestbuilds.de/download.blender.org/peach/trailer_ 1080p.mov</strong></span>
<span class="strong"><strong># gst-launch playbin2 uri=file:///home/root/trailer_1080p.mov</strong></span>
</pre></div><p>The video will use Freescale's <code class="literal">h.264</code> video decoder plugin, <code class="literal">vpudec</code>, which makes use of the hardware video processing unit inside the i.MX6 SoC to decode the <code class="literal">h.264</code> video.</p><p>You can see a list of the available i.MX6-specific plugins by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># gst-inspect | grep imx</strong></span>
<span class="strong"><strong>h264.imx:  mfw_h264decoder: h264 video decoder</strong></span>
<span class="strong"><strong>audiopeq.imx:  mfw_audio_pp: audio post equalizer</strong></span>
<span class="strong"><strong>aiur.imx: webm: webm</strong></span>
<span class="strong"><strong>aiur.imx:  aiurdemux: aiur universal demuxer</strong></span>
<span class="strong"><strong>mpeg2dec.imx:  mfw_mpeg2decoder: mpeg2 video decoder</strong></span>
<span class="strong"><strong>tvsrc.imx:  tvsrc: v4l2 based tv src</strong></span>
<span class="strong"><strong>ipucsc.imx:  mfw_ipucsc: IPU-based video converter</strong></span>
<span class="strong"><strong>mpeg4dec.imx:  mfw_mpeg4aspdecoder: mpeg4 video decoder</strong></span>
<span class="strong"><strong>vpu.imx:  vpudec: VPU-based video decoder</strong></span>
<span class="strong"><strong>vpu.imx:  vpuenc: VPU-based video encoder</strong></span>
<span class="strong"><strong>mp3enc.imx:  mfw_mp3encoder: mp3 audio encoder</strong></span>
<span class="strong"><strong>beep.imx: ac3: ac3</strong></span>
<span class="strong"><strong>beep.imx: 3ca: ac3</strong></span>
<span class="strong"><strong>beep.imx:  beepdec: beep audio decoder</strong></span>
<span class="strong"><strong>beep.imx:  beepdec.vorbis: Vorbis decoder</strong></span>
<span class="strong"><strong>beep.imx:  beepdec.mp3: MP3 decoder</strong></span>
<span class="strong"><strong>beep.imx:  beepdec.aac: AAC LC decoder</strong></span>
<span class="strong"><strong>isink.imx:  mfw_isink: IPU-based video sink</strong></span>
<span class="strong"><strong>v4lsink.imx:  mfw_v4lsink: v4l2 video sink</strong></span>
<span class="strong"><strong>v4lsrc.imx:  mfw_v4lsrc: v4l2 based camera src</strong></span>
<span class="strong"><strong>amrdec.imx:  mfw_amrdecoder: amr audio decoder</strong></span>
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec189"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The framebuffer API is documented in the Linux kernel documentation<a id="id539" class="indexterm"/> at <a class="ulink" href="https://www.kernel.org/doc/Documentation/fb/api.txt">https://www.kernel.org/doc/Documentation/fb/api.txt</a></li><li class="listitem" style="list-style-type: disc">For more information regarding Qt for <a id="id540" class="indexterm"/>Embedded Linux, refer to <a class="ulink" href="http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html">http://qt-project.org/doc/qt-4.8/qt-embedded-linux.html</a></li><li class="listitem" style="list-style-type: disc">Documentation for the gstreamer 0.10 framework<a id="id541" class="indexterm"/> can be found at <a class="ulink" href="http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/">http://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gstreamer-0.10/</a></li></ul></div></div></div>
<div class="section" title="Using the X Windows system"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec71"/>Using the X Windows system</h1></div></div></div><p>The X Windows system <a id="id542" class="indexterm"/>provides the framework for a GUI environment – things like drawing and moving windows on the display and interacting with input devices like the mouse, the keyboard, and touchscreens. The protocol version has been X11 for over two decades, so it also known as X11.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec190"/>Getting ready</h2></div></div></div><p>The reference implementation for the X Windows system is the <a id="id543" class="indexterm"/>
<span class="strong"><strong>X.Org</strong></span> server, which is released under permissive licenses such as MIT. It uses a client/server model, with the server communicating with several client programs, serving user input, and accepting graphical output. The X11 protocol is network transparent so that the clients and the server may run on different machines, with different architectures and operating systems. However, mostly, they both run on the same machine and communicate using local sockets.</p><p>User interface specifications, such as buttons or menu styles, are not defined in X11, which leaves it to other window manager applications that are usually part of desktop environments, such as Gnome or KDE.</p><p>X11 has input and video drivers to handle the hardware. For example, it has a framebuffer driver, <code class="literal">fbdev</code>, that can output to a non-accelerated Linux framebuffer, and <code class="literal">evdev</code>, a generic Linux input device driver with support for mice, keyboards, tablets, and touchscreens.</p><p>The design of the X11 Windows systems makes it heavy for embedded devices, and although a powerful device like the quad-core i.MX6 has no trouble using it, many embedded devices choose other graphical alternatives. However, there are many graphical applications, mostly from the desktop environment, that run over the X11 Windows system.</p><p>The FSL community BSP layer provides a hardware-accelerated X video driver for the i.MX6 SoC, <code class="literal">xf86-video-imxfb-vivante</code>, which is included in the X11-based <code class="literal">core-image-sato</code> target image and other graphical images.</p><p>The X server is configured by an <code class="literal">/etc/X11/xorg.conf</code> file that configures the accelerated device as follows:</p><div class="informalexample"><pre class="programlisting">Section "Device"
    Identifier  "i.MX Accelerated Framebuffer Device"
    Driver      "vivante"
    Option      "fbdev"     "/dev/fb0"
    Option      "vivante_fbdev" "/dev/fb0"
    Option      "HWcursor"  "false"
EndSection</pre></div><p>The graphical <a id="id544" class="indexterm"/>acceleration is provided by the Vivante GPUs included in the i.MX6 SoC.</p><p>Low-level X11 development is not recommended, and toolkits such as GTK+ and Qt are preferred. We will see how to integrate both types of graphical applications into our Yocto target image.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec191"/>How to do it...</h2></div></div></div><p>SATO<a id="id545" class="indexterm"/> is the default visual style for the Poky distribution based on <span class="strong"><strong>Gnome Mobile and Embedded</strong></span> (<span class="strong"><strong>GMAE</strong></span>). It is a <a id="id546" class="indexterm"/>desktop environment based on GTK+ that uses the matchbox-window-manager. It has the peculiarity of showing one single fullscreen window at a time.</p><p>To build the GTK hello world application, <code class="literal">meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld-1.0/gtk_hello_world.c</code>, that we introduced earlier, as follows:</p><div class="informalexample"><pre class="programlisting">#include &lt;gtk/gtk.h&gt;

int main(int argc, char *argv[])
{
    GtkWidget *window;
    gtk_init (&amp;argc, &amp;argv);
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    gtk_widget_show (window);
    gtk_main ();
    return 0;
}</pre></div><p>We can <a id="id547" class="indexterm"/>use the following <code class="literal">meta-custom/recipes-graphics/gtk-helloworld/gtk-helloworld_1.0.bb</code> recipe:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple GTK helloworld application"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "file://gtk_hello_world.c"

S = "${WORKDIR}"

DEPENDS = "gtk+"

inherit pkgconfig

do_compile() {
    ${CC} gtk_hello_world.c -o helloworld `pkg-config --cflags -- libs gtk+-2.0`
}

do_install() {
    install -d ${D}${bindir}
    install -m 0755 helloworld ${D}${bindir}
}</pre></div><p>We can then add the package to the <code class="literal">core-image-sato</code> image by using:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " gtk-helloworld"</pre></div><p>And we can build it, program it, and run the application from the serial terminal with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># export DISPLAY=:0</strong></span>
<span class="strong"><strong># helloworld</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec192"/>There's more...</h2></div></div></div><p>Accelerated graphical output is also supported on the Qt framework, either directly on the framebuffer (like in the <code class="literal">qt4e-demo-image</code> target we saw before) or using the X11 server available in <code class="literal">core-image-sato</code>.</p><p>To build the Qt hello world source<a id="id548" class="indexterm"/> we introduced in the previous recipe but over X11, we can use the <code class="literal">meta-custom/recipes-qt/qtx11-helloworld/qtx11-helloworld_1.0.bb</code> Yocto recipe shown as follows::</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple QT over X11 helloworld example"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

RDEPENDS_${PN} += "icu"

SRC_URI = "file://qt_hello_world.cpp \
           file://qt_hello_world.pro"

S = "${WORKDIR}"

inherit qt4x11

do_install() {
         install -d ${D}${bindir}
         install -m 0755 qt_hello_world ${D}${bindir}
}</pre></div><p>We then need to add the Qt4 framework to the target image as well as the application.</p><div class="informalexample"><pre class="programlisting">EXTRA_IMAGE_FEATURES += "qt4-pkgs"
IMAGE_INSTALL_append = " qtx11-helloworld"</pre></div><p>We can then build <code class="literal">core-image-sato</code> using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake core-image-sato</strong></span>
</pre></div><p>Program and boot our target. Then run the application with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># export DISPLAY=:0</strong></span>
<span class="strong"><strong># qt_hello_world</strong></span>
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec193"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More information on the X.Org server<a id="id549" class="indexterm"/> can be found at <a class="ulink" href="http://www.x.org">http://www.x.org</a></li><li class="listitem" style="list-style-type: disc">The Qt application framework documentation<a id="id550" class="indexterm"/> can be found at <a class="ulink" href="https://qt-project.org/">https://qt-project.org/</a></li><li class="listitem" style="list-style-type: disc">More information and documentation about GTK+<a id="id551" class="indexterm"/> can be found at <a class="ulink" href="http://www.gtk.org/">http://www.gtk.org/</a></li></ul></div></div></div>
<div class="section" title="Using Wayland"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec72"/>Using Wayland</h1></div></div></div><p>Wayland<a id="id552" class="indexterm"/> is a display server protocol that is intended to replace the X Window system, and it is licensed under the MIT license.</p><p>This recipe will provide an overview of Wayland, including some key differences with the X Window system, and will show how to make use of it in Yocto.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec194"/>Getting ready</h2></div></div></div><p>The Wayland <a id="id553" class="indexterm"/>protocol follows a client/server model in which clients are the graphical applications requesting the display of pixel buffers on the screen, and the server, or compositor, is the service provider that controls the display of these buffers.</p><p>The Wayland compositor can be a Linux display server, an X application, or a special Wayland client. Weston is the reference Wayland compositor in the Wayland project. It is written in C and works with the Linux kernel APIs. It relies on <code class="literal">evdev</code> for the handling of input events.</p><p>Wayland uses <span class="strong"><strong>Direct Rendering Manager (DRM)</strong></span> in the Linux kernel and does not need something like an X server. The client renders the window contents to a buffer shared with the compositor by itself, using a rendering library, or an engine like Qt or GTK+.</p><p>Wayland lacks the network transparency features of X, but it is likely that similar functionality will be added in the future.</p><p>It also has better security features than X and is designed to provide confidentiality and integrity. Wayland does not allow applications to look at the input of other programs, capture other input events, or generate fake input events. It also makes a better job out of protecting the Window outputs. However, this also means that it currently offers no way to provide some of the features we are used to in desktop X systems like screen capturing, or features common in accessibility programs.</p><p>Being lighter than X.Org and more secure, Wayland is better suited to use with embedded systems. If needed, X.Org can run as a client of Wayland for backwards compatibility.</p><p>However, Wayland is not as established as X11, and the Wayland-based images in Poky do not receive as much community attention as the X11-based ones.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec195"/>How to do it...</h2></div></div></div><p>Poky offers a <code class="literal">core-image-weston</code> image that includes the Weston compositor.</p><p>Modifying our GTK hello <a id="id554" class="indexterm"/>world example from the <span class="emphasis"><em>Using the X Windows system</em></span> recipe to use GTK3 and run it with Weston is straightforward.</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple GTK3 helloworld application"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "file://gtk_hello_world.c"

S = "${WORKDIR}"

DEPENDS = "gtk+3"

inherit pkgconfig

do_compile() {
    ${CC} gtk_hello_world.c -o helloworld `pkg-config --cflags -- libs gtk+-3.0`
}

do_install() {
    install -d ${D}${bindir}
    install -m 0755 helloworld ${D}${bindir}
}</pre></div><p>To build it, configure your <code class="literal">conf/local.conf</code> file by removing the <code class="literal">x11</code> distribution feature as follows:</p><div class="informalexample"><pre class="programlisting">DISTRO_FEATURES_remove = "x11"</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>You will need to build from scratch by removing both the <code class="literal">tmp</code> and <code class="literal">sstate-cache</code> directories when changing the <code class="literal">DISTRO_FEATURES</code> variable.</p></div></div><p>Add the application to the image with:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " gtk3-helloworld"</pre></div><p>And build the image with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake core-image-weston</strong></span>
</pre></div><p>Once the build finishes, you will find the microSD card image ready to be programmed under <code class="literal">tmp/deploy/images/wandboard-quad</code>.</p><p>You can then<a id="id555" class="indexterm"/> launch the application by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># export XDG_RUNTIME_DIR=/var/run/user/root</strong></span>
<span class="strong"><strong># helloworld</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec196"/>There's more...</h2></div></div></div><p>The FSL community BSP release supports hardware-accelerated graphics in Wayland using the Vivante GPU included in the i.MX6 SoC.</p><p>This means that applications like <code class="literal">gstreamer</code> will be able to offer hardware-accelerated output when running with the Weston compositor.</p><p>Wayland support can also be found in graphical toolkits like Clutter and GTK3+.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec197"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can find more information about Wayland<a id="id556" class="indexterm"/> on the project's web page at <a class="ulink" href="http://wayland.freedesktop.org/">http://wayland.freedesktop.org/</a></li></ul></div></div></div>
<div class="section" title="Adding Python applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec73"/>Adding Python applications</h1></div></div></div><p>In Yocto 1.7, Poky has <a id="id557" class="indexterm"/>support for building both Python 2 and Python 3 applications, and includes a small set of Python development tools in the <code class="literal">meta/recipes-devtools/python</code> directory.</p><p>A wider variety of Python applications are available in the <code class="literal">meta-python</code> layer included as part of <code class="literal">meta-openembedded</code>, which you can add to your <code class="literal">conf/bblayers.conf</code> file if you want to.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec198"/>Getting ready</h2></div></div></div><p>The standard tool for packaging Python modules is <code class="literal">distutils</code>, which is included for both Python 2 and Python 3. Poky includes the <code class="literal">distutils</code> class (<code class="literal">distutils3</code> in Python 3), which is used to build Python packages that use <code class="literal">distutils</code>. An example recipe in <code class="literal">meta-python</code> that uses the <code class="literal">distutils</code> class is <code class="literal">meta-python/recipes-devtools/python/python-pyusb_1.0.0a2.bb</code>.</p><div class="informalexample"><pre class="programlisting">SUMMARY = "PyUSB provides USB access on the Python language"
HOMEPAGE = "http://pyusb.sourceforge.net/"
SECTION = "devel/python"
LICENSE = "BSD"
LIC_FILES_CHKSUM = "file://LICENSE;md5=a53a9c39efcfb812e2464af14afab013"
DEPENDS = "libusb1"
PR = "r1"

SRC_URI = "\
    ${SOURCEFORGE_MIRROR}/pyusb/${SRCNAME}-${PV}.tar.gz \
"
SRC_URI[md5sum] = "9136b3dc019272c62a5b6d4eb624f89f"
SRC_URI[sha256sum] = "dacbf7d568c0bb09a974d56da66d165351f1ba3c4d5169ab5b734266623e1736"

SRCNAME = "pyusb"
S = "${WORKDIR}/${SRCNAME}-${PV}"

inherit distutils</pre></div><p>However, <code class="literal">distutils</code> does not<a id="id558" class="indexterm"/> install package dependencies, allow package uninstallation, or allow us to install several versions of the same package, so it is only recommended for simple requirements. Hence, <code class="literal">setuptools</code> was developed to extend on <code class="literal">distutils</code>. It is not included in the standard Python libraries, but it is available in Poky. There is also a <code class="literal">setuptools</code> class in Poky (<code class="literal">setuptools3</code> for Python 3) that is used to build Python packages distributed with <code class="literal">setuptools</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec199"/>How to do it...</h2></div></div></div><p>To build a Python hello world example application with <code class="literal">setuptools</code>, we would use a Yocto <code class="literal">meta-custom/recipes-python/python-helloworld/pythonhelloworld_1.0.bb</code> recipe as follows:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple Python setuptools hello world application"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "file://setup.py \
      file://python-helloworld.py \
      file://helloworld/__init__.py \
              file://helloworld/main.py"

S = "${WORKDIR}"

inherit setuptools

do_install_append () {
    install -d ${D}${bindir}
    install -m 0755 python-helloworld.py ${D}${bindir}
}</pre></div><p>To create an example hello <a id="id559" class="indexterm"/>world package, we create the directory structure shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5186OS_04_22.jpg" alt="How to do it..."/></div><p>Here is the code for the same directory structure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir -p meta-custom/recipes-python/python-helloworld/python- helloworld-1.0/helloworld/</strong></span>
<span class="strong"><strong>$ touch meta-custom/recipes-python/python-helloworld/python- helloworld-1.0/helloworld/__init__.py</strong></span>
</pre></div><p>And create the following <a id="id560" class="indexterm"/>
<code class="literal">meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/setup.py</code> Python setup file:</p><div class="informalexample"><pre class="programlisting">import sys
from setuptools import setup

setup(
    name = "helloworld",
    version = "0.1",
    packages=["helloworld"],
    author="Alex Gonzalez",
    author_email = "alex@example.com",
    description = "Hello World packaging example",
    license = "MIT",
    keywords= "example",
    url = "",
)</pre></div><p>As well as the <code class="literal">meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/helloworld/main.py</code> python file:</p><div class="informalexample"><pre class="programlisting">import sys

def main(argv=None):
    if argv is None:
        argv = sys.argv
    print "Hello world!"
    return 0</pre></div><p>And a <code class="literal">meta-custom/recipes-python/python-helloworld/python-helloworld-1.0/python-helloworld.py</code> test script that makes use of the module:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
import sys
import helloworld.main

if __name__ == '__main__':
       sys.exit(helloworld.main.main())</pre></div><p>We can then add it to our image with:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " python-helloworld"</pre></div><p>And build it using:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake core-image-minimal</strong></span>
</pre></div><p>Once programmed and <a id="id561" class="indexterm"/>booted, we can test the module by running the example script:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/bin/python-helloworld.py</strong></span>
<span class="strong"><strong>Hello world!</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec200"/>There's more...</h2></div></div></div><p>In <code class="literal">meta-python</code>, you can also find the <code class="literal">python-pip</code> recipe that will add the <code class="literal">pip</code> utility to your target image. It can be used to install packages from the <a id="id562" class="indexterm"/>
<span class="strong"><strong>Python Package Index</strong></span> (<span class="strong"><strong>PyPI</strong></span>).</p><p>You can add it to your image with:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append  = " python-pip python-distribute"</pre></div><p>You will need to add the <code class="literal">meta-openembedded/meta-python</code> layer to your <code class="literal">conf/bblayers.conf</code> file in order to build your image, and also the <code class="literal">python-distribute</code> dependency, which is needed by <code class="literal">python-pip</code>. Then you can build for the <code class="literal">core-image-minimal</code> image with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake core-image-minimal</strong></span>
</pre></div><p>Once installed, you can use it from the target as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># pip search &lt;package_name&gt;</strong></span>
<span class="strong"><strong># pip install &lt;package_name&gt;</strong></span>
</pre></div></div></div>
<div class="section" title="Integrating the Oracle Java Runtime Environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec74"/>Integrating the Oracle Java Runtime Environment</h1></div></div></div><p>Oracle provides two specialized Java editions for embedded development:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Java SE embedded</strong></span>: This is a <a id="id563" class="indexterm"/>large subset of the desktop version of the standard <a id="id564" class="indexterm"/>Java SE. It contains optimizations with respect to the standard edition, like size and memory usage, to adapt it to the needs of mid-sized embedded devices.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Java Micro Edition</strong></span> (<span class="strong"><strong>ME</strong></span>): This is<a id="id565" class="indexterm"/> targeted at headless low- and mid-range devices, and is a subset of Java SE complying with the <a id="id566" class="indexterm"/><span class="strong"><strong>Connected Limited Device Configuration</strong></span> (<span class="strong"><strong>CLDC</strong></span>), and including some extra features and tools for the embedded market. Oracle offers a couple of reference implementations, but Java ME will have to be individually integrated from source into specific platforms.</li></ul></div><p>We will focus on Java SE embedded, which can be downloaded in binary format from the Oracle download site.</p><p>Java SE embedded<a id="id567" class="indexterm"/> is commercially licensed and requires royalty payments for embedded deployments.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec201"/>Getting ready</h2></div></div></div><p>Yocto has a <code class="literal">meta-oracle-java</code> layer that is meant to help in the integration of the official Oracle <span class="strong"><strong>Java Runtime Environment</strong></span> (<span class="strong"><strong>JRE</strong></span>)<a id="id568" class="indexterm"/> Version 7. However, installation without user intervention is not possible, as the Oracle's web page requires login and the acceptance of its license.</p><p>In Java SE embedded Version 7, Oracle offered both soft and hard floating point versions of headless and headful JREs for ARMv6/v7, and a headless version JRE for soft floating point user spaces for ARMv5. Java SE embedded version 7 provides two different <span class="strong"><strong>Java Virtual Machines</strong></span> (<span class="strong"><strong>JVMs</strong></span>)<a id="id569" class="indexterm"/> for ARM Linux:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A client JVM optimized for responsiveness</li><li class="listitem" style="list-style-type: disc">A server JVM identical to the client JVM but optimized for long-running applications</li></ul></div><p>At the time of writing, the <code class="literal">meta-oracle-java</code> layer only has a recipe for the headless hard floating-point version with the client JVM. We will add recipes for the latest Java 7 SE embedded, which is update 75, for both headless and headful hard floating point JREs, which are appropriate to run on an i.MX6-based board like <code class="literal">wandboard-quad</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec202"/>How to do it...</h2></div></div></div><p>To install the Java SE embedded runtime environment, first we need to clone the <code class="literal">meta-oracle-java</code> layer into our sources directory and add it to our <code class="literal">conf/bblayers.conf</code> file as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/sources</strong></span>
<span class="strong"><strong>$ git clone git://git.yoctoproject.org/meta-oracle-java</strong></span>
</pre></div><p>Then we need to explicitly accept the Oracle Java license by adding the following to our <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">LICENSE_FLAGS_WHITELIST += "oracle_java"</pre></div><p>We want to build the<a id="id570" class="indexterm"/> newest update available, so we add the following <code class="literal">meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headless_1.7.0.bb</code> recipe to our <code class="literal">meta-custom</code> layer:</p><div class="informalexample"><pre class="programlisting">SUMMARY = "Oracle Java SE runtime environment binaries"

JDK_JRE = "ejre"
require recipes-devtools/oracle-java/oracle-jse.inc

PV_UPDATE = "75"
BUILD_NUMBER = "13"

LIC_FILES_CHKSUM = "\
       file://${WORKDIR}/${JDK_JRE}${PV}_${PV_UPDATE}/COPYRIGHT;md5=0b204 bd2921accd6ef4a02f9c0001823 \
       file://${WORKDIR}/${JDK_JRE}${PV}_${PV_UPDATE}/THIRDPARTYLICENSERE ADME.txt;md5=f3a388961d24b8b72d412a079a878cdb \
       "

SRC_URI = "http://download.oracle.com/otn/java/ejre/7u${PV_UPDATE}- b${BUILD_NUMBER}/ejre-7u${PV_UPDATE}-fcs-b${BUILD_NUMBER}-linux- arm-vfp-hflt-client_headless-18_dec_2014.tar.gz"
SRC_URI[md5sum] = "759ca6735d77778a573465b1e84b16ec"
SRC_URI[sha256sum] = "ebb6499c62fc12e1471cff7431fec5407ace59477abd0f48347bf6e89c6bff3b"

RPROVIDES_${PN} += "java2-runtime"</pre></div><p>Try to build the recipe with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bitbake oracle-jse-ejre-arm-vfp-hflt-client-headless</strong></span>
</pre></div><p>You will see that we get a checksum mismatch. This is caused by the license acceptance step in Oracle's website. To get around this, we will need to manually download the file into the <code class="literal">downloads</code> directory as specified in our project's <code class="literal">DL_DIR</code> configuration variable.</p><p>Then we can add the JRE to our target image:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " oracle-jse-ejre-arm-vfp-hflt-client- headless"</pre></div><p>And build it with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake core-image-minimal</strong></span>
</pre></div><p>We can now log in to the target and run it with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/bin/java -version</strong></span>
<span class="strong"><strong>java version "1.7.0_75"</strong></span>
<span class="strong"><strong>Java(TM) SE Embedded Runtime Environment (build 1.7.0_75-b13, headless)</strong></span>
<span class="strong"><strong>Java HotSpot(TM) Embedded Client VM (build 24.75-b04, mixed mode)</strong></span>
</pre></div><p>We can also build <a id="id571" class="indexterm"/>the headful version using the following <code class="literal">meta-custom/recipes-devtools/oracle-java/oracle-jse-ejre-arm-vfphflt-client-headful_1.7.0.bb</code> recipe:</p><div class="informalexample"><pre class="programlisting">SUMMARY = "Oracle Java SE runtime environment binaries"

JDK_JRE = "ejre"
require recipes-devtools/oracle-java/oracle-jse.inc

PV_UPDATE = "75"
BUILD_NUMBER = "13"

LIC_FILES_CHKSUM = "\
       file://${WORKDIR}/${JDK_JRE}${PV}_${PV_UPDATE}/COPYRIGHT;md5=0b204 bd2921accd6ef4a02f9c0001823 \
       file://${WORKDIR}/${JDK_JRE}${PV}_${PV_UPDATE}/THIRDPARTYLICENSERE ADME.txt;md5=f3a388961d24b8b72d412a079a878cdb \
       "

SRC_URI = "http://download.oracle.com/otn/java/ejre/7u${PV_UPDATE}- b${BUILD_NUMBER}/ejre-7u${PV_UPDATE}-fcs-b${BUILD_NUMBER}-linux- arm-vfp-hflt-client_headful-18_dec_2014.tar.gz"

SRC_URI[md5sum] = "84dba4ffb47285b18e6382de2991edfc"
SRC_URI[sha256sum] = "5738ffb8ce2582b6d7b39a3cbe16137d205961224899f8380eebe3922bae5c61"

RPROVIDES_${PN} += "java2-runtime"</pre></div><p>And add it to the target image with:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append =  " oracle-jse-ejre-arm-vfp-hflt-client- headful"</pre></div><p>And build <code class="literal">core-image-sato</code> with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake core-image-sato</strong></span>
</pre></div><p>In this case, the reported Java version is:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/bin/java -version</strong></span>
<span class="strong"><strong>java version "1.7.0_75"</strong></span>
<span class="strong"><strong>Java(TM) SE Embedded Runtime Environment (build 1.7.0_75-b13)</strong></span>
<span class="strong"><strong>Java HotSpot(TM) Embedded Client VM (build 24.75-b04, mixed mode)</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec203"/>There's more...</h2></div></div></div><p>The latest<a id="id572" class="indexterm"/> release at the time of this writing is Java SE embedded Version 8 update 33 (8u33).</p><p>Oracle offers the download of the JDK only, and a host tool, <span class="strong"><strong>jrecreate</strong></span>, needs to be used to configure and create an appropriate JRE from the JDK. The tool allows us to choose between different JVMs (minimal, client, and server) as well as soft or hard floating point ABIs, extensions like JavaFX, locales, and several other tweakings to the JVM.</p><p>Oracle Java SE embedded Version 8 provides support for headful X11 development using Swing, AWT, and JavaFX only for ARMv7 hard floating point user spaces, and includes support for JavaFX (the graphical framework aimed to replace Swing and AWT) on the Freescale i.MX6 processor.</p><p>There is no Yocto recipe to integrate Java Version 8 at the time of this writing.</p></div></div>
<div class="section" title="Integrating the Open Java Development Kit"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec75"/>Integrating the Open Java Development Kit</h1></div></div></div><p>The open source alternative to the Oracle Java SE embedded is the <span class="strong"><strong>Open Java Development Kit</strong></span> (<span class="strong"><strong>OpenJDK</strong></span>), an open source implementation of Java SE licensed under the GPLv2, with the classpath exception, which means that applications are allowed to link without being bound by the GPL license.</p><p>This recipe will show <a id="id573" class="indexterm"/>how to build OpenJDK with Yocto and integrate the JRE into our target images.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec204"/>Getting ready</h2></div></div></div><p>The main <a id="id574" class="indexterm"/>components of OpenJDK are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The HotSpot Java Virtual Machine</li><li class="listitem" style="list-style-type: disc">The <a id="id575" class="indexterm"/><span class="strong"><strong>Java Class Library</strong></span> (<span class="strong"><strong>JCL</strong></span>)</li><li class="listitem" style="list-style-type: disc">The Java <a id="id576" class="indexterm"/>compiler, <span class="strong"><strong>javac</strong></span></li></ul></div><p>Initially, OpenJDK needed to be built using a proprietary JDK. However, the <span class="strong"><strong>IcedTea</strong></span><a id="id577" class="indexterm"/> project allowed us to build OpenJDK using the GNU classpath, the GNU compiler for Java (GCJ), and bootstrap a JDK to build OpenJDK. It also complements OpenJDK with some missing components available on Java SE like a web browser plugin and web start implementations.</p><p>Yocto can build meta-java using the <code class="literal">meta-java</code> layer, which includes recipes for cross-compiling OpenJDK using IcedTea.</p><p>You can download OpenJDK from its Git repository<a id="id578" class="indexterm"/> at <a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/">http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/</a>.</p><p>Development discussions can be followed and contributed to by visiting the development mailing list at <a class="ulink" href="http://lists.openembedded.org/mailman/listinfo/openembedded-devel">http://lists.openembedded.org/mailman/listinfo/openembedded-devel</a>.</p><p>The <code class="literal">meta-java</code> layer also includes recipes for a wide variety of Java libraries and VMs, and tools for application development like<a id="id579" class="indexterm"/> <span class="strong"><strong>ant</strong></span> and<a id="id580" class="indexterm"/> <span class="strong"><strong>fastjar</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec205"/>How to do it...</h2></div></div></div><p>To build OpenJDK 7, you <a id="id581" class="indexterm"/>need to clone the <code class="literal">meta-java</code> layer as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/sources/</strong></span>
<span class="strong"><strong>$ git clone http://git.yoctoproject.org/cgit/cgit.cgi/meta-java/</strong></span>
</pre></div><p>At the time of this writing, there is no 1.7 Dizzy branch yet, so we will work directly from the master branch.</p><p>Add the layer to your <code class="literal">conf/bblayers.conf</code> file:</p><div class="informalexample"><pre class="programlisting">+ ${BSPDIR}/sources/meta-java \
 "</pre></div><p>And configure the project by adding the following to your <code class="literal">conf/local.conf</code> file:</p><div class="informalexample"><pre class="programlisting">PREFERRED_PROVIDER_virtual/java-initial = "cacao-initial"
PREFERRED_PROVIDER_virtual/java-native = "jamvm-native"
PREFERRED_PROVIDER_virtual/javac-native = "ecj-bootstrap-native"
PREFERRED_VERSION_openjdk-7-jre = "25b30-2.3.12"
PREFERRED_VERSION_icedtea7-native = "2.1.3"</pre></div><p>You can then add the OpenJDK package to your image with:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " openjdk-7-jre"</pre></div><p>And build the image of your choice:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake core-image-sato</strong></span>
</pre></div><p>When you run the <a id="id582" class="indexterm"/>target image, you will get the following Java version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># java -version</strong></span>
<span class="strong"><strong>java version "1.7.0_25"</strong></span>
<span class="strong"><strong>OpenJDK Runtime Environment (IcedTea 2.3.12) (25b30-2.3.12)</strong></span>
<span class="strong"><strong>OpenJDK Zero VM (build 23.7-b01, mixed mode)</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec206"/>How it works...</h2></div></div></div><p>To test the JVM, we can byte-compile a Java class on our host and copy it to the target to execute it. For instance, we can use the following simple <code class="literal">HelloWorld.java</code> example:</p><div class="informalexample"><pre class="programlisting">class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello World!");
  }
}</pre></div><p>To byte-compile it in the host, we need to have a Java SDK installed. To install a Java SDK in Ubuntu, just run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install openjdk-7-jdk</strong></span>
</pre></div><p>To byte-compile the example, we execute:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ javac HelloWorld.java</strong></span>
</pre></div><p>To run it, we copy the <code class="literal">HelloWorld.class</code> to the target, and from the same folder we run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># java HelloWorld</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec207"/>There's more...</h2></div></div></div><p>When using<a id="id583" class="indexterm"/> OpenJDK on a production system, it is recommended to always use the latest available release, which contains bug and security fixes. At the time of this writing, the latest OpenJDK 7 release is update 71 (jdk7u71b14), buildable with IcedTea 2.5.3, so the <code class="literal">meta-java</code> recipes should be updated.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec208"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Up-to-date information regarding <a id="id584" class="indexterm"/>openJDK can be obtained at <a class="ulink" href="http://openjdk.java.net/">http://openjdk.java.net/</a></li></ul></div></div></div>
<div class="section" title="Integrating Java applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec76"/>Integrating Java applications</h1></div></div></div><p>The <code class="literal">meta-java</code> layer also <a id="id585" class="indexterm"/>offers helper classes to ease the integration of Java libraries and applications into Yocto. In this recipe, we will see an example of building a Java library using the provided classes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec209"/>Getting ready</h2></div></div></div><p>The <code class="literal">meta-java</code> layer provides two main classes to help with the integration of Java applications and libraries:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Java bbclass</strong></span>: This <a id="id586" class="indexterm"/>provides the default target directories and <a id="id587" class="indexterm"/>some auxiliary functions, namely:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">oe_jarinstall</code>: This installs <a id="id588" class="indexterm"/>and symlinks a JAR file</li><li class="listitem" style="list-style-type: disc"><code class="literal">oe_makeclasspath</code>: This<a id="id589" class="indexterm"/> generates a classpath string from JAR filenames</li><li class="listitem" style="list-style-type: disc"><code class="literal">oe_java_simple_wrapper</code>: This <a id="id590" class="indexterm"/>wraps your Java application in a shell script</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The java-library bbclass</strong></span>: This <a id="id591" class="indexterm"/>inherits the Java bbclass and <a id="id592" class="indexterm"/>extends it to create and install JAR files.</li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec210"/>How to do it...</h2></div></div></div><p>We will use the following <a id="id593" class="indexterm"/>
<code class="literal">meta-custom/recipes-java/java-helloworld/java-helloworld-1.0/HelloWorldSwing.java</code> graphical Swing hello world as an example:</p><div class="informalexample"><pre class="programlisting">import javax.swing.JFrame;
import javax.swing.JLabel;

public class HelloWorldSwing {
    private static void createAndShowGUI() {
        JFrame frame = new JFrame("Hello World!");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JLabel label = new JLabel("Hello World!");
        frame.getContentPane().add(label);

        frame.pack();
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                createAndShowGUI();
            }
        });
    }
}</pre></div><p>To integrate this <code class="literal">HelloWorldSwing</code> application, we can use a Yocto <code class="literal">meta-custom/recipes-java/java-helloworld/java-helloworld_1.0.bb</code> recipe as follows:</p><div class="informalexample"><pre class="programlisting">DESCRIPTION = "Simple Java Swing hello world application"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

RDEPENDS_${PN} = "java2-runtime"

SRC_URI = "file://HelloWorldSwing.java"

S = "${WORKDIR}"

inherit java-library

do_compile() {
        mkdir -p build
        javac -d build `find . -name "*.java"`
        fastjar cf ${JARFILENAME} -C build .
}

BBCLASSEXTEND = "native"</pre></div><p>The recipe is also <a id="id594" class="indexterm"/>buildable for the host native architecture. We can do this either by providing a separate <code class="literal">java-helloworld-native</code> recipe that inherits the <code class="literal">native</code> class or by using the <code class="literal">BBCLASSEXTEND</code> variable as we did earlier. In both cases, we could then use the <code class="literal">_class-native</code> and <code class="literal">_class-target</code> overrides to differentiate between native and target functionality.</p><p>Even though Java is byte-compiled and the compiled class will be the same for both, it still makes sense to add the native support explicitly.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec211"/>How it works...</h2></div></div></div><p>The <code class="literal">java-library</code> class will create a library package with the name <code class="literal">lib&lt;package&gt;-java</code>.</p><p>To add it to a target image, we would use:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " libjava-helloworld-java"</pre></div><p>We can then decide whether we want to run the application with the Oracle JRE or OpenJDK. For OpenJDK, we will add the following packages to our image:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " openjdk-7-jre openjdk-7-common"</pre></div><p>And for the Oracle JRE, we will use the following:</p><div class="informalexample"><pre class="programlisting">IMAGE_INSTALL_append = " oracle-jse-ejre-arm-vfp-hflt-client- headful"</pre></div><p>The available JREs do not currently run over the framebuffer or Wayland, so we will use an X11-based graphical image like <code class="literal">core-image-sato</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /opt/yocto/fsl-community-bsp/</strong></span>
<span class="strong"><strong>$ source setup-environment wandboard-quad</strong></span>
<span class="strong"><strong>$ bitbake core-image-sato</strong></span>
</pre></div><p>We can then boot it, log in to the target, and execute the example with OpenJDK by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># export DISPLAY=:0</strong></span>
<span class="strong"><strong># java -cp /usr/share/java/java-helloworld.jar HelloWorldSwing</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec212"/>There's more...</h2></div></div></div><p>At the time of this <a id="id595" class="indexterm"/>writing, OpenJDK as built from the <code class="literal">meta-java</code> layer master branch is not able to run X11 applications and will fail with this exception:</p><div class="informalexample"><pre class="programlisting">Exception in thread "main" java.awt.AWTError: Toolkit not found: sun.awt.X11.XToolkit
        at java.awt.Toolkit$2.run(Toolkit.java:875)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.awt.Toolkit.getDefaultToolkit(Toolkit.java:860)
        at java.awt.Toolkit.getEventQueue(Toolkit.java:1730)
        at java.awt.EventQueue.invokeLater(EventQueue.java:1217)
        at javax.swing.SwingUtilities.invokeLater(SwingUtilities.java:1287)
        at HelloWorldSwing.main(HelloWorldSwing.java:17)</pre></div><p>However, the precompiled Oracle JRE runs the application without issues with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># export DISPLAY=:0</strong></span>
<span class="strong"><strong># /usr/bin/java -cp /usr/share/java/java-helloworld.jar HelloWorldSwing</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>If you see build errors when building packages with the Oracle JRE, try using a different package format, for example, IPK, by adding the following to your <code class="literal">conf/local.conf</code> configuration file:</p><div class="informalexample"><pre class="programlisting">PACKAGE_CLASSES = "package_ipk"</pre></div><p>This is due to dependency problems in the <code class="literal">meta-oracle-java</code> layer with the RPM package manager, as explained in the layer's README file.</p></div></div></div></div></body></html>