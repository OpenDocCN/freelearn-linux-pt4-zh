["```\n    {\n    \"run_tasks\": [\n    {\n    \"principals\": { \"values\": [\"A\", \"B\"] },\n    \"users\": { \"values\": [\"U\"] }\n    }\n    ]\n    }\n    Any framework can run tasks as user guest, as shown by the following code:\n      {\n    \"run_tasks\": [\n    {\n    \"principals\": { \"type\": \"ANY\" },\n    \"users\": { \"values\": [\"guest\"] }\n    }\n    ]\n    }\n    No framework can run tasks as root, as follows:\n      {\n    \"run_tasks\": [\n    {\n    \"principals\": { \"type\": \"NONE\" },\n    \"users\": { \"values\": [\"root\"] }\n    }\n        ]\n      }\n    ```", "```\n      {\n    \"run_tasks\": [\n    {\n    \"principals\": { \"values\": [ \"A\" ] },\n    \"users\": { \"values\": [\"guest\"] }\n    },\n    {\n    \"principals\": { \"values\": [ \"A\" ] },\n    \"users\": { \"type\": \"NONE\" }\n    }\n    ]\n      }\n    The framework A can register with X and Y roles, as follows:\n    {\n    \"register_frameworks\": [\n    {\n    \"principals\": { \"values\": [\"A\"] },\n    \"roles\": { \"values\": [\"X\", \"Y\"] }\n    }\n    ]\n    }\n    Only the framework A and no one else can register with X role, as follows:\n      {\n    \"register_frameworks\": [\n    {\n    \"principals\": { \"values\": [\"A\"] },\n    \"roles\": { \"values\": [\"X\"] }\n    },\n    {\n    \"principals\": { \"type\": \"NONE\" },\n    \"roles\": { \"values\": [\"X\"] }\n    }\n    ]\n      }\n    ```", "```\n      {\n    \"permissive\" : false,\n    \"register_frameworks\": [\n    {\n    \"principals\": { \"values\": [\"A\"] },\n    \"roles\": { \"values\": [\"X\"] }\n    }\n    ]\n    }\n    Only the P principal can shut down any frameworks through the /teardown HTTP endpoint. Take a look at the following code:\n      {\n    \"permissive\" : false,\n    \"shutdown_frameworks\":[\n    {\n    \"principals\": { \"values\": [\"P\"] },\n    \"framework_principals\":{\"type\":\"ANY\"}\n    }\n    ]\n      }\n    ```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"type\"       : \"SUBSCRIBE\",\n\n\"subscribe\"  : {\n\"framework_info\"  : {\n\"user\" :  \"U\",\n\"name\" :  \"N\"\n},\n\n\"force\" : true\n  }\n}\n```", "```\nHTTP/1.1 200 OK\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_value>\"},\n\"type\"            : \"TEARDOWN\",\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_Value>\"},\n\"type\"            : \"ACCEPT\",\n\"accept\"          : {\n\"offer_ids\"     : [\n{\"value\" : \"<some_Value>\"},\n{\"value\" : \"<some_value>\"}\n],\n\"operations\"    : [ {\"type\" : \"LAUNCH\", \"launch\" : {...}} ],\n\"filters\"       : {...}\n  }\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_Value>\"},\n\"type\"            : \"DECLINE\",\n\"decline\"         : {\n\"offer_ids\"     : [\n                       {\"value\" : \"<some_value>\"},\n                       {\"value\" : \"<some_Value>\"}\n                      ],\n\"filters\"       : {...}\n  }\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_value>\"},\n\"type\"            : \"REVIVE\",\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_value>\"},\n\"type\"            : \"KILL\",\n\"kill\"            : {\n\"task_id\"   :  {\"value\" : \"<some_Value>\"},\n\"agent_id\"  :  {\"value\" : \"<some_value>\"}\n  }\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_value>\"},\n\"type\"            : \"SHUTDOWN\",\n\"shutdown\"            : {\n\"executor_id\":  {\"value\" : \"<some_value>\"},\n\"agent_id\":  {\"value\" : \"<some_value>\"}\n  }\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_value>\"},\n\"type\"            : \"ACKNOWLEDGE\",\n\"acknowledge\"     : {\n\"agent_id\"  :  {\"value\" : \"<some_Value>\"},\n\"task_id\"   :  {\"value\" : \"<some_value>\"},\n\"uuid\"      :  \"<some_value>\"\n  }\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_value>\"},\n\"type\"            : \"RECONCILE\",\n\"reconcile\"       : {\n\"tasks\"     : [\n                   { \"task_id\"  : { \"<some_value>\" },\n\"agent_id\" : { \"<some_value>\" }\n                   }\n                  ]\n  }\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_value>\"},\n\"type\"            : \"MESSAGE\",\n\"message\"         : {\n\"agent_id\"       : {\"value\" : \"<some_value>\"},\n\"executor_id\"    : {\"value\" : \"<some_value>\"},\n\"data\"           : \"<some_Value>\"\n  }\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\nPOST /api/v1/scheduler  HTTP/1.1\n\n{\n\"framework_id\"    : {\"value\" : \"<some_value>\"},\n\"type\"            : \"REQUEST\",\n\"requests\"        : [\n      {\n\"agent_id\"       : {\"value\" : \"<some_value>\"},\n\"resources\"      : {}\n      },\n  ]\n}\n```", "```\nHTTP/1.1 202 Accepted\n```", "```\n<event-length>\n{\n\"type\"         : \"SUBSCRIBED\",\n\"subscribed\"   : {\n\"framework_id\"               : {\"value\":\"<some_value>\"},\n\"heartbeat_interval_seconds\" : 10\n  }\n}\n```", "```\n<event-length>\n{\n\"type\"    : \"OFFERS\",\n\"offers\"  : [\n    {\n\"offer_id\":{\"value\": \"<some_value>\"},\n\"framework_id\":{\"value\": \"<some_Value>\"},\n\"agent_id\":{\"value\": \"<some_value>\"},\n\"hostname\":\"agent.host\",\n\"resources\":[...],\n\"attributes\":[...],\n\"executor_ids\":[]\n    }\n  ]\n}\n```", "```\n<event-length>\n{\n\"type\":\"RESCIND\",\n\"rescind\":{\n\"offer_id\":{\"value\":\"<some_value>\"}\n}\n}\n```", "```\n<event-length>\n{\n\"type\"    : \"UPDATE\",\n\"update\"  : {\n\"status\"    : {\n\"task_id\"   : { \"value\" : \"<some_value>\"},\n\"state\"     : \"TASK_FINISHED\",\n\"source\"    : \"SOURCE_EXECUTOR\",\n\"uuid\"      : \"<some_value>\",\n\"bytes\"     : \"<some_Value\"\n\n      }\n  }\t\n}\n```", "```\n<event-length>\n{\n\"type\":\"MESSAGE\",\n\"message\":{\n\"agent_id\":{\"value\":\"<some_value>\"},\n\"executor_id\":{\"value\":\"<some_value>\"},\n\"data\":\"<some_value>\"\n}\n}\n```", "```\n<event-length>\n{\n\"type\":\"FAILURE\",\n\"failure\":{\n\"agent_id\":{\"value\":\"<some_Value>\"},\n\"executor_id\":{\"value\":\"<some_Value>\"},\n\"status\": 1\n}\n}\n```", "```\n<event-length>\n{\n\"type\":\"ERROR\",\n\"message\":\"Framework is not authorized\"\n}\n```", "```\n<event-length>\n{\n\"type\":\"HEARTBEAT\",\n}\n```", "```\nProtos.ExecutorInfopiExecutorInfo = \nProtos.ExecutorInfo.newBuilder()\n.setExecutorId(Protos.ExecutorID.newBuilder()\n.setValue(\"CalculatePi\"))\n.setCommand(piCommandInfo)\n.setName(\"PiExecutor\")\n.setSource(\"java\")\n.build();\n```", "```\nProtos.FrameworkInfo.BuilderframeworkBuilder = Protos.FrameworkInfo.newBuilder()\n.setFailoverTimeout(120000)\n.setUser(\"\")\n.setName(\"PiFramework\"); \n```", "```\nScheduler scheduler = new PiScheduler(piExecutorInfo, 1);\n```", "```\nMesosSchedulerDriverschedulerDriver = \nnew MesosSchedulerDriver(scheduler,frameworkBuilder.build(), MESOS-MASTER);\nint status = schedulerDriver.run() == Protos.Status.DRIVER_STOPPED ? 0 : 1;\nschedulerDriver.stop();\nSystem.exit(status);\n```", "```\n/* Create the PiDriver class with the following contents: */\n\nimport com.google.protobuf.ByteString;\nimport org.apache.log4j.Logger;\nimport org.apache.mesos.MesosSchedulerDriver;\nimport org.apache.mesos.Protos;\nimport org.apache.mesos.Scheduler;\n\npublic class PiDriver {\n\nprivate final static Logger LOGGER = Logger.getLogger(PiDriver.class);\n\npublic static void main(String[] args) {\n\nString path = System.getProperty(\"user.dir\") + \"/target/scala-2.10/mesos-pi-assembly-1.0.jar\";\n\n/* Defining the executor */\n\nProtos.CommandInfo.URIuriProtos.CommandInfo.URI.newBuilder().setValue(path).setExtract(false).build();\nString commandPi = \"java -cpmesos-pi-assembly-1.0.jarPiExecutor\";\nProtos.CommandInfopiCommandInfo = Protos.CommandInfo.newBuilder().setValue(commandPi).addUris(uri).build();\n\n/* Setting the executor information */\n\nProtos.ExecutorInfopiExecutorInfo = Protos.ExecutorInfo.newBuilder().setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"CalculatePi\")).setCommand(piCommandInfo).setName(\"PiExecutor\").setSource(\"java\").build();\n\n/* Defining framework & specifying related information*/\n\nProtos.FrameworkInfo.BuilderframeworkBuilder = Protos.FrameworkInfo.newBuilder().setFailoverTimeout(120000).setUser(\"\").setName(\"PiFramework\").setPrincipal(\"test-framework-java\");\n\n/* Enabling checkpointing */\n\nif (System.getenv(\"MESOS_CHECKPOINT\") != null) {\nSystem.out.println(\"Enabling checkpoint for the framework\");\nframeworkBuilder.setCheckpoint(true);\n}\n\n/* Initializing the scheduler */\n\nScheduler scheduler = new PiScheduler(piExecutorInfo, 1);\n\n/* Defining the scheduler driver */\n\nMesosSchedulerDriverschedulerDriver = new MesosSchedulerDriver(scheduler, frameworkBuilder.build(), args[0]);;\n\nint status = schedulerDriver.run() == Protos.Status.DRIVER_STOPPED ? 0 : 1;\nschedulerDriver.stop();\nSystem.exit(status);\n}\n\n}\n```", "```\n@Override \npublic void launchTask(final ExecutorDriverexecutorDriver, final Protos.TaskInfotaskInfo) \n{\n\n/* Set the task status as running for the task ID with a builder pattern. */\n\nProtos.TaskStatustaskStatus = Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId())\n.setState(Protos.TaskState.TASK_RUNNING).build();\n\n/* Send the status update to the framework scheduler retrying as necessary until an acknowledgement has been receivedor the executor is terminated, in which case,a TASK_LOST status update will be sent.+*/\n\nexecutorDriver.sendStatusUpdate(taskStatus);\n\n/* Actual Pi computation */\n\ntry {\nmessage = computePi().getBytes();\n}\ncatch (IOException e) {\nLOGGER.error(\"Error computing Pi :\" + e.getMessage());\n}\n\n/* Return the value of Pi to framework */\n\nexecutorDriver.sendFrameworkMessage(message);\n\n/* Mark state of task as finished and send status update to framework scheduler. */\n\ntaskStatus = Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()) \n.setState(Protos.TaskState.TASK_FINISHED)\n.build();\n\nexecutorDriver.sendStatusUpdate(taskStatus);\n\n}\n```", "```\n/* Create the PiExecutor class with the following contents: */\n\nimport org.apache.log4j.Logger;\nimport org.apache.mesos.Executor;\nimport org.apache.mesos.ExecutorDriver;\nimport org.apache.mesos.MesosExecutorDriver;\nimport org.apache.mesos.Protos;\n\nimport java.io.IOException;\n\npublic class PiExecutor implements Executor {\nprivate final static Logger LOGGER = Logger.getLogger(PiExecutor.class);\n\n/**\n*Invoked once the executor driver has been able to\n*successfully connect with Mesos. \n*In particular, a scheduler can pass some\n*data to it's executors through the\n*{@linkorg.apache.mesos.Protos.ExecutorInfo#getData()}field.\n*@param driver - The executor driver that was registered and connectedto the Mesos cluster.\n*@paramexecutorInfo - Describes information about the registered executor.\n*@paramframeworkInfo - Describes the framework that was registered.\n*@paramslaveInfo - Describes the slave that will be used to launchthe tasks for this executor.\n*For more details, seeorg.apache.mesos.ExecutorDriver and org.apache.mesos.MesosSchedulerDriver\n\n*/\n\n@Override \npublic void registered(ExecutorDriver driver, Protos.ExecutorInfoexecutorInfo,Protos.FrameworkInfoframeworkInfo, Protos.SlaveInfoslaveInfo) {\nLOGGER.info(\"Registered PinUserBoardExecutor on \" + slaveInfo.getHostname());\n}\n\n/*\n* Invoked when executor re-registers with a restarted slave.\n    * @param driver - The executor driver that was re-registered with Mesos master.\n    * @paramslaveInfo - Describes the slave that will be used to launch the tasks for this executor.\n    * For more details, see org.apache.mesos.ExecutorDriver\n*/\n\n@Override \npublic void reregistered(ExecutorDriver driver, Protos.SlaveInfoslaveInfo) {\n\n}\n\n/*\n    * Invoked when executor becomes 'disconnected' from  slave.\n    * (e.g. when the slave is being restarted due to an upgrade)\n    * @param driver - The executor driver that was disconnected.\n\n*/\n\n@Override \npublic void disconnected(ExecutorDriver driver) {\n\n}\n\n/*\n    * Invoked when a task has been launched on this executor \n    * (initiated via \n    * {@linkorg.apache.mesos.SchedulerDriver#launchTasks}. \n    * Note that this task can be realized with a \n    * thread, a process, or some simple computation, \n    * however, no other callbacks will be invoked on this executor\n    * until this callback has returned.\n    * \n* @param driver - The executor driver that launched the task.\n    * @param task - Describes the task that was launched.\n    * For more details, see \n    * org.apache.mesos.ExecutorDriver and \n    * org.apache.mesos.Protos.TaskInfo\n*/\n\n@Override \npublic void launchTask(ExecutorDriver driver, Protos.TaskInfo task) {\nLOGGER.info(\"Launching task in PinUserBoardExecutor..\");\nProtos.TaskStatustaskStatus = Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId()).setState(Protos.TaskState.TASK_RUNNING).build();\ndriver.sendStatusUpdate(taskStatus);\nString url = task.getData().toStringUtf8();\n\nbyte[] message = new byte[0];\n\ntry {\nmessage = computePi().getBytes();\n} \ncatch (IOException e) {\nLOGGER.error(\"Error computing Pi :\" + e.getMessage());\n}\nLOGGER.info(\"Sending framework message and marking task finished.\"+ getClass().getName());\ndriver.sendFrameworkMessage(message);\n\ntaskStatus = Protos.TaskStatus.newBuilder().setTaskId(task.getTaskId()).setState(Protos.TaskState.TASK_FINISHED).build();\n\ndriver.sendStatusUpdate(taskStatus);\n}\n\n/* Code to compute Pi */\n\nprivate String computePi() throws IOException {\n\ndouble pi = 0;\ndouble y = 1;\n\nintlps = 90000000*2;\nintcnt = 0;\nfor(int x=1; x <lps; x+=2) {\npi = pi + (y/x);\ny = -y;\ncnt++;\n}\n\nreturn \"Value of PI=\" + 4*pi + \" after \" + cnt; \n/* PI=3.141592642478473 after 90000000 */\n\n}\n\n    /*\n    * Invoked when a task running within this executor \n    * has been killed \n    * (via {@link org.apache.mesos.SchedulerDriver#killTask}). \n    * Note that no status update will be sent \n    * on behalf of the executor, the executor is responsible for \n    * creating new TaskStatus (i.e., with TASK_KILLED) &invoking \n    * {@link org.apache.mesos.ExecutorDriver#sendStatusUpdate}.\n\n    * @param driver - The executor driver that owned the task that was killed.\n@param task - The ID of the task that was killed.\n\n@For more details, see org.apache.mesos.ExecutorDriver andorg.apache.mesos.Protos.TaskID\n\n*/\n\n@Override \npublic void killTask(ExecutorDriver driver, Protos.TaskIDtaskId) {\n\n}\n\n/*\n@Invoked when a framework message has arrived \n*for this executor. \n*These messages are best effort; \n*do not expect a framework message to be \n*retransmitted in any reliable fashion.\n*@param driver - The executor driver that received the message.\n@param data - The message payload.\n    * For more details, see \n    * org.apache.mesos.ExecutorDriver\n*/\n\n@Override \npublic void frameworkMessage(ExecutorDriver driver, byte[] data) {\n\n}\n\n/*\n    * Invoked when the executor should terminate \n    * all of it's currently running tasks. \n    * Note that after Mesos has determined that \n    * an executor has terminated any tasks that \n    * the executor did not send terminal status updates \n    * for (e.g. TASK_KILLED, TASK_FINISHED, TASK_FAILED and so on) \n    * a TASK_LOST status update will be created.\n    * @param driver - The executor driver that should terminate\n    * For more details, see org.apache.mesos.ExecutorDriver\n\n*/\n\n@Override \npublic void shutdown(ExecutorDriver driver) {\n\n}\n\n/*\n* Invoked when a fatal error has occurred with \n    * the executor and/or executor driver. \n    * The driver will be aborted BEFORE invoking this callback\n    * @param driver - The executor driver that was aborted due to this error\n    * @param message - The error message.\n    * For more details, see org.apache.mesos.ExecutorDriver\n\n*/\n\n@Override \npublic void error(ExecutorDriver driver, String message) {\n\n}\n\n/* The main method in which we initiates and calls the run() method in MesosExecutorDriver */\n\npublic static void main(String[] args) {\nMesosExecutorDrivermesosExecutorDriver = new MesosExecutorDriver(new PiExecutor());System.exit(mesosExecutorDriver.run() == Protos.Status.DRIVER_STOPPED ? 0 : 1);\n}\n\n}\n```", "```\nimport org.apache.log4j.Logger;\nimport org.apache.mesos.Protos;\nimport org.apache.mesos.Scheduler;\nimport org.apache.mesos.SchedulerDriver;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PiScheduler implements Scheduler {\n\nprivate final static Logger LOGGER = Logger.getLogger(PiScheduler.class);\n\nprivate final Protos.ExecutorInfopiExecutor;\nprivate final inttotalTasks;\nprivate intlaunchedTasks = 0;\nprivate intfinishedTasks = 0;\n\n/**ThePiSchedulertakes information from the PiExecutor and \n  * the total number of tasks through its constructor \n  * which is implemented below \n*/\n\npublic PiScheduler(Protos.ExecutorInfo _piExecutor, int _totalTasks) {\nthis.totalTasks = _totalTasks; \nthis.piExecutor = _piExecutor;\n}\n\n@Override public void registered(SchedulerDriverschedulerDriver, Protos.FrameworkIDframeworkID, Protos.MasterInfomasterInfo) {\nLOGGER.info(\"Registered! ID = \" + frameworkID.getValue());\n}\n\n@Override public void reregistered(SchedulerDriverschedulerDriver, Protos.MasterInfomasterInfo) {\n\n}\n\n/**The resourceoffer() method is invoked when resources \n  * have been offered to this framework. \n* We will set the number of CPUs, and amount of memory that \n  * our framework requires through the call described below \n*/\n\n@Override public void resourceOffers(SchedulerDriverschedulerDriver, List<Protos.Offer> list) {\n\n/* The amount of CPU cores and Memory required for our tasks is specified */\n\ndouble CPUS_PER_TASK = 1;\ndouble MEM_PER_TASK = 128;\n\nfor (Protos.Offer offer : list) {\nList<Protos.TaskInfo>taskInfoList = new ArrayList<Protos.TaskInfo>();\ndouble offerCpus = 0;\ndouble offerMem = 0;\n\nfor (Protos.Resource resource : offer.getResourcesList()) {\nif (resource.getName().equals(\"cpus\")) {\nofferCpus += resource.getScalar().getValue();\n} else if (resource.getName().equals(\"mem\")) {\nofferMem += resource.getScalar().getValue();\n}\n}\n\nLOGGER.info(\"Received Offer : \" + offer.getId().getValue() + \"with cpus = \" + offerCpus + \" and mem =\"+ offerMem);\n\ndouble remainingCpus = offerCpus;\ndouble remainingMem = offerMem;\n\nif (launchedTasks<totalTasks&&remainingCpus>= CPUS_PER_TASK&&remainingMem>= MEM_PER_TASK) {\n\nProtos.TaskIDtaskID = Protos.TaskID.newBuilder().setValue(Integer.toString(launchedTasks++)).build();\nLOGGER.info(\"Launching task :\" + taskID.getValue() + \" using the offer : \" + offer.getId().getValue());\n\n/* PiExecutor is created as a task and is launched*/\n\nProtos.TaskInfopiTaskInfo = Protos.TaskInfo.newBuilder()\n.setName(\"task \" + taskID.getValue()).setTaskId(taskID).setSlaveId(offer.getSlaveId()).addResources(Protos.Resource.newBuilder().setName(\"cpus\")\n.setType(Protos.Value.Type.SCALAR).setScalar(Protos.Value.Scalar.newBuilder().setValue(CPUS_PER_TASK))).addResources(Protos.Resource.newBuilder().setName(\"mem\").setType(Protos.Value.Type.SCALAR).setScalar(Protos.Value.Scalar.newBuilder().setValue(MEM_PER_TASK))).setExecutor(Protos.ExecutorInfo.newBuilder(piExecutor)).build();\n\ntaskID = Protos.TaskID.newBuilder().setValue(Integer.toString(launchedTasks++)).build();\n\nLOGGER.info(\"Launching task :\" + taskID.getValue() + \" using the offer : \" + offer.getId().getValue());\n\ntaskInfoList.add(piTaskInfo);\n\n}\n\nschedulerDriver.launchTasks(offer.getId(), taskInfoList);\n\n}\n\n}\n\n/** Invoked when an offer is no longer valid \n  * (e.g., the slave was lost or another framework used \n  * resources in the offer). \n  * If for whatever reason an offer is never rescinded \n  * (e.g., dropped message, failing over framework and so on), \n  * a framework that attempts to launch tasks \n  * using an invalid offer will receive TASK_LOST\n  * status update for those tasks */\n  */\n@Override public void offerRescinded(SchedulerDriverschedulerDriver, Protos.OfferIDofferID) {\n\n}\n\n/**The statusUpdate() call is invoked when \n  * the status of a task has changed \n  * (e.g., a slave is lost which means the task is lost, \n  * a task finishes and executor sends a status update)\n*/\n\n@Override public void statusUpdate(SchedulerDriverschedulerDriver, Protos.TaskStatustaskStatus) {\n\nLOGGER.info(\"Status update : Task ID \"+ taskStatus.getTaskId()\n.getValue() + \"in state : \"+ taskStatus.getState().getValueDescriptor().getName());\nif (taskStatus.getState() == Protos.TaskState.TASK_FINISHED) {\nfinishedTasks++;\nLOGGER.info(\"Finished tasks : \" + finishedTasks);\n\n/* We can stop the scheduler once the tasks are completed */\n\nif (finishedTasks == totalTasks) {\nschedulerDriver.stop();\n}\n}\n\nif (taskStatus.getState() == Protos.TaskState.TASK_FAILED|| taskStatus.getState() == Protos.TaskState.TASK_KILLED|| taskStatus.getState() == Protos.TaskState.TASK_LOST) {\nLOGGER.error(\"Aborting because the task \"+ taskStatus.getTaskId().getValue() + \" is in unexpected state : \"+ taskStatus.getState().getValueDescriptor().getName() + \"with reason : \"+ taskStatus.getReason().getValueDescriptor().getName()+ \" from source : \"+ taskStatus.getSource().getValueDescriptor().getName() + \" with message : \"+ taskStatus.getMessage());\nschedulerDriver.abort();\n}\n}\n\n/**The frameworkMessage() is invoked when an executor \n  * sends a message. In our case we will be sending \n  * the value of Pi from our executor as the message.\n*/\n\n@Override public void frameworkMessage(SchedulerDriverschedulerDriver, Protos.ExecutorIDexecutorID,Protos.SlaveIDslaveID, byte[] bytes) {\nString data = new String(bytes);\nSystem.out.println(data);\nLOGGER.info(\"Output :\\n=========\\n \" + data);\n}\n\n/* Invoked when scheduler becomes disconnected from master \n  * (e.g. master fails and another is taking over)\n*/\n\n@Override public void disconnected(SchedulerDriverschedulerDriver) {\n\n}\n\n/* Invoked when a slave has been determined unreachable \n  * (e.g., machine failure, network partition). \n  * Most frameworks will need to reschedule \n  * any tasks launched on this slave on a new slave. \n*/\n\n@Override public void slaveLost\n(SchedulerDriverschedulerDriver, Protos.SlaveIDslaveID) {\n\n}\n\n/* Invoked when an executor has exited/terminated. \n  * Note that any tasks running will have \n  * TASK_LOST status updates automatically generated.\n*/\n\n@Override public void executorLost(SchedulerDriverschedulerDriver, Protos.ExecutorIDexecutorID,Protos.SlaveIDslaveID, inti) {\n\n}\n\n/* Invoked when there is an unrecoverable error \n  * in the scheduler or driver. \n  * The driver will be aborted before invoking this callback.\n*/\n\n@Override public void error(SchedulerDriverschedulerDriver, String s) {\nLOGGER.error(\"Error : \" + s);\n}\n\n}\n```", "```\nimport AssemblyKeys._\n\nassemblySettings\n\nname := \"mesos-pi\"\n\nversion := \"1.0\"\n\nscalaVersion := \"2.10.4\"\n\nlibraryDependencies += \"org.apache.mesos\" % \"mesos\" % \"0.26.0\"\n\nlibraryDependencies += \"log4j\" % \"log4j\" % \"1.2.17\"\n```", "```\n$ sbt assembly\n\n```", "```\n$ sbt'run 127.0.0.1:5050'\nMultiple main classes detected, select one to run:\n [1] PiDriver\n [2] PiExecutor\n\nEnter number: 1\n\n```", "```\nValue of PI=3.141592642478473 after 90000000\n\n```"]