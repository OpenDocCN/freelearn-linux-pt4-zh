<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Rewrite Engine and Access Control"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Rewrite Engine and Access Control</h1></div></div></div><p>The World Wide Web and HTTP as its building block operate in URLs. Since URLs are so fundamental, the ability of a server to manipulate URLs is essential.</p><p>Nginx allows you to manipulate URLs using a built-in rewrite engine. The Nginx rewrite engine has a broad functionality and is very easy to configure, which makes it a very powerful tool. We'll walk through the entire rewrite engine in this chapter.</p><p>Another topic that we are going to explore in this chapter is access control. This is, obviously, an essential function of every software system that keeps the system secure and reliable. We'll walk through access control methods available in Nginx and explore their subtleties, and you'll learn how to combine them.</p><div class="section" title="The basics of the rewrite engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>The basics of the rewrite engine</h1></div></div></div><p>The <a id="id226" class="indexterm"/>rewrite engine allows you to manipulate the request URI of inbound requests.</p><p>The rewrite engine is configured using rewrite rules. Rewrite rules are used when the request <a id="id227" class="indexterm"/>URI needs to undergo transformation before further processing. Rewrite rules instruct Nginx to match the request URI with a regular expression and substitute the request URI with a specified pattern whenever a match has been scored.</p><p>Rewrite rules can be specified inside <code class="literal">server</code>, <code class="literal">location</code>, and <code class="literal">if</code> sections of the configuration.</p><p>Let's study some examples of rewrite rules in action. Consider a simple case when one resource needs to be substituted by another:</p><div class="informalexample"><pre class="programlisting">location / {
    rewrite ^/css/default\.css$ /css/styles.css break;
    root /var/www/example.com;
}</pre></div><p>With the preceding configuration, every request to <code class="literal">/css/default.css</code> will have its URI rewritten to <code class="literal">/css/styles.css</code> and will fetch this resource instead. The <code class="literal">rewrite</code> directive<a id="id228" class="indexterm"/> specifies a pattern that has to match the request URI in order to fire the rule and a substitution string that says how the request URI must look after transformation. The third argument, <code class="literal">break</code>, is a flag that instructs Nginx to stop processing<a id="id229" class="indexterm"/> rewrite rules once a match for this rule has been scored.</p><p>The preceding <a id="id230" class="indexterm"/>configuration can be extended to work with multiple resources as well. For that, you need to use captures (round brackets in the first argument) and positional parameters (variables with numbers that refer to captures):</p><div class="informalexample"><pre class="programlisting">location / {
    rewrite ^/styles/(.+)\.css$ /css/$1.css break;
    root /var/www/example.com;
}</pre></div><p>With the preceding configuration, every request to any CSS file in <code class="literal">/styles/</code> will have its URI rewritten to the corresponding resource in <code class="literal">/css/</code>.</p><p>In the last two examples, we used the <code class="literal">break</code> flag in order to stop rewrite rules from processing as soon as a match is found (assuming more rules can be added to those configurations). If we want to combine those two examples, we need to drop the <code class="literal">break</code> flag and allow the cascading application of rewrite rules:</p><div class="informalexample"><pre class="programlisting">location / {
    rewrite ^/styles/(.+)\.css$ /css/$1.css;
    rewrite ^/css/default\.css$ /css/styles.css;
    root /var/www/example.com;
}</pre></div><p>Now, every request to style sheets in <code class="literal">/styles/</code> will be redirected to the corresponding resource in <code class="literal">/css/</code>, and <code class="literal">/css/default.css</code> will be rewritten to <code class="literal">/css/styles.css</code>. A request to <code class="literal">/styles/default.css</code> will undergo two rewrites, as it sequentially matches both rules.</p><p>Notice that all URI transformations are performed by Nginx internally. This means that for an external client, the original URIs return ordinary resources, thus the previous configurations will externally look like a series of documents with identical content (that is, <code class="literal">/css/default.css</code> will be identical to <code class="literal">/css/styles.css</code>).</p><p>This is not a desirable effect in the case of ordinary web pages, as search engines might penalize your website for duplicate content.</p><p>To avoid this problem, it is necessary to replace copies of a resource with permanent redirects to the master resource, as shown in the following configuration:</p><div class="informalexample"><pre class="programlisting">location / {
    rewrite ^/styles/(.+)\.css$ /css/$1.css permanent;
    root /var/www/example.com;
}</pre></div><p>This works well for whole sections of a website:</p><div class="informalexample"><pre class="programlisting">location / {
    rewrite ^/download/(.+)$ /media/$1 permanent;
    root /var/www/example.com;
}</pre></div><p>It also works for an entire virtual host:</p><div class="informalexample"><pre class="programlisting">server {
    listen 80;
    server_name example.com;
    rewrite ^/(.*)$ http://www.example.com/$1 permanent;
}</pre></div><p>The<a id="id231" class="indexterm"/> preceding configuration for any URL requested performs a permanent redirect from a top-level domain <code class="literal">example.com</code> to the <code class="literal">www</code> sub domain, making it the primary entry point of the website.</p><p>The next powerful application of rewrite rules is translating a semantic URL into a URL with a query (section of a URL after the <span class="emphasis"><em>?</em></span> character). This functionality has its primary application<a id="id232" class="indexterm"/> in <span class="strong"><strong>Search Engine Optimization</strong></span> (<span class="strong"><strong>SEO</strong></span>) and website usability, and it is driven by a need to obtain semantic URLs for each and every resource and to deduplicate the content.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>You <a id="id233" class="indexterm"/>can find more information about semantic URLs at <a class="ulink" href="https://en.wikipedia.org/wiki/Semantic_URL">https://en.wikipedia.org/wiki/Semantic_URL</a>.</p></div></div><p>Consider the following configuration:</p><div class="informalexample"><pre class="programlisting">server {
    [...]
    rewrite ^/products/$ /products.php last;
    rewrite ^/products/(.+)$ /products.php?name=$1 last;
    rewrite ^/products/(.+)/(.+)/$ /products.php?name=$1&amp;page=$2 last;
    [...]
}</pre></div><p>The preceding configuration transforms URLs consisting of a number of path sections starting with <code class="literal">/products</code> into a URL starting with <code class="literal">/products.php</code> and arguments. In this way, it is possible to hide implementation details from users and search engines, and generate semantic URLs.</p><p>Note <a id="id234" class="indexterm"/>that the flags of the rewrite directives are now set to <code class="literal">last</code>. This makes Nginx seek a new location for a rewritten URL and process request with a newly-found location.</p><p>Now that you have studied some examples of rewrite rules in action, you can learn more about the nitty-gritty details in order to master the rewrite rule. The following sections take a deeper look at its syntax and functionality.</p><div class="section" title="More about rewrite rules"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>More about rewrite rules</h2></div></div></div><p>Now, let's <a id="id235" class="indexterm"/>discuss some of interesting details of the<a id="id236" class="indexterm"/> rewrite rules. Here's the complete syntax of the <code class="literal">rewrite</code> directive:</p><div class="informalexample"><pre class="programlisting">rewrite &lt;pattern&gt; &lt;substitution&gt; [&lt;flag&gt;];</pre></div><p>The first argument of this directive, <code class="literal">&lt;pattern&gt;</code>, is a regular expression that needs to match the request URI in order to activate the substitution. The <code class="literal">&lt;substitution&gt;</code> argument is a script that is evaluated once a match has been scored and the value produced by evaluation replaces the request URI. Special variables <code class="literal">$1</code>...<code class="literal">$9</code> can be used to cross-reference a pattern and its substitution by referring to a capture with the specified position. The <code class="literal">&lt;flag&gt;</code> argument affects the behavior of the <code class="literal">rewrite</code> directive. The following table lists all possible flags of the <code class="literal">rewrite</code> directive and their functions:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Flag</p>
</th><th style="text-align: left" valign="bottom">
<p>Function</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">break</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Interrupts <a id="id237" class="indexterm"/>processing of rewrite rules</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">last</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Interrupts <a id="id238" class="indexterm"/>processing of rewrite rules and looks up a location for the new request URI</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">redirect</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns <a id="id239" class="indexterm"/>a temporary redirect (HTTP status <code class="literal">302</code>) to the new request URI</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">permanent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns<a id="id240" class="indexterm"/> a permanent redirect (HTTP status <code class="literal">301</code>) to the new request URI</p>
</td></tr></tbody></table></div><p>The rewrite engine makes multiple passes before a location for the request is found, and then in the request location and subsequent locations that the request is redirected to (such as those that are invoked by the <code class="literal">error_page</code> directive).</p><p>Rewrite<a id="id241" class="indexterm"/> rules specified directly in the <code class="literal">server</code> section<a id="id242" class="indexterm"/> are processed in the first pass, while rewrite rules in the <code class="literal">location</code>, <code class="literal">if</code>, and other sections within the <code class="literal">server</code> section are processed at subsequent passes. Consider the following example:</p><div class="informalexample"><pre class="programlisting">server {
  &lt;rewrite rules here are processed in the first pass&gt;;

  location /a {
      &lt;rewrite rules here are processed in subsequent passes&gt;;
  }
  location /b {
     &lt;rewrite rules here are processed in subsequent passes&gt;;
  }
}</pre></div><p>After the first pass is complete, Nginx searches for a location that matches the rewritten request URI if a rewrite was performed, or a location that matches the original request URI (if no rewrite took place). The subsequent passes alter the request URI without changing the location.</p><p>Rewrite rules at each pass are processed in order of appearance. Once a match is scored, the substitution is applied and processing resumes with subsequent rewrite rules—unless a flag is specified to interrupt processing.</p><p>If the resulting request URI starts with http:// or https://, it is treated as absolute and Nginx returns a temporary (<code class="literal">302</code> "Found") or a permanent (<code class="literal">301</code> "Moved Permanently") redirect to the resulting location.</p></div><div class="section" title="Patterns"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Patterns</h2></div></div></div><p>Now, let's<a id="id243" class="indexterm"/> go back to the <code class="literal">&lt;pattern&gt;</code> argument and see how a match pattern can be specified. The following table gives a brief overview of regular <a id="id244" class="indexterm"/>expression syntax used in rewrite rules:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pattern</p>
</th><th style="text-align: left" valign="bottom">
<p>Examples</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;pattern A&gt; &lt;pattern B&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Ab, (aa)(bb)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Following</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;pattern A&gt; |  &lt;pattern B&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">a|b, (aa)|(bb)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Alternative</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;pattern&gt;?</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(\.gz)?</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Option</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;pattern&gt;*</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">A*, (aa)*</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Repetition of <code class="literal">&lt;pattern&gt;</code> from <span class="emphasis"><em>0</em></span> to <span class="emphasis"><em>infinity</em></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;pattern&gt;+</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">a+, (aa)+</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Repetition of <code class="literal">&lt;pattern&gt;</code> from <span class="emphasis"><em>1</em></span> to <span class="emphasis"><em>infinity</em></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;pattern&gt;{n}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">a{5}, (aa){6}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Repetition of <code class="literal">&lt;pattern&gt;</code> <span class="emphasis"><em>n</em></span> times</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;pattern&gt;{n,}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">a{3,}, (aa){7,}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Repetition of <code class="literal">&lt;pattern&gt;</code> from <span class="emphasis"><em>n</em></span> to <span class="emphasis"><em>infinity</em></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;pattern&gt;{,m}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">a{,6}, (aa){,3}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Repetition of <code class="literal">&lt;pattern&gt;</code> from <span class="emphasis"><em>0</em></span> to <span class="emphasis"><em>m</em></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;pattern&gt;{n,m}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">a{5,6}, (aa){1,3}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Repetition of <code class="literal">&lt;pattern&gt;</code> from <span class="emphasis"><em>n</em></span> to <span class="emphasis"><em>m</em></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">( &lt;pattern&gt; )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(aa)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Grouping <a id="id245" class="indexterm"/>or parameter capture</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal"> .</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">.+</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Any character</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">^</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^/index</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Start of line</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">\.php$</code>
</p>
</td><td style="text-align: left" valign="top">
<p>End of line</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[&lt;characters&gt;]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">[A-Za-z]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Any character from the specified set</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[^&lt;characters&gt;]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">[^0-9]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Any character outside of the specified set</p>
</td></tr></tbody></table></div><p>The <a id="id246" class="indexterm"/>patterns are listed in increasing priority order. That is, the pattern <code class="literal">aa|bb</code> will be interpreted as <code class="literal">a(a|b)b</code>, while the pattern <code class="literal">a{5}aa{6}</code> will be interpreted as <code class="literal">(a{5})(a)(a{6})</code> and so on.</p><p>To specify characters that are themselves part of regular expression syntax, you can use the backslash character <code class="literal">\</code>, for example <code class="literal">\*</code> will match an asterisk <code class="literal">*</code>, <code class="literal">\.</code> will match a dot character <code class="literal">.</code>, <code class="literal">\\</code> will match the backslash character itself and <code class="literal">\{</code> will match an opening curly bracket <code class="literal">{</code>.</p><p>More<a id="id247" class="indexterm"/> information about regular expression syntax in rewrite rules can be found on the PCRE <a id="id248" class="indexterm"/>website <a class="ulink" href="http://www.pcre.org">www.pcre.org</a>.</p></div><div class="section" title="Captures and positional parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Captures and positional parameters</h2></div></div></div><p>Captures are designated with round brackets and mark sections of matched URLs that need to be<a id="id249" class="indexterm"/> extracted. Positional parameters refer to substrings<a id="id250" class="indexterm"/> of the matched URLs extracted by <a id="id251" class="indexterm"/>corresponding capture, that is, if the pattern is as follows:</p><div class="informalexample"><pre class="programlisting">^/users/(.+)/(.+)/$</pre></div><p>Also, if the request URL is like this:</p><div class="informalexample"><pre class="programlisting">/users/id/23850/</pre></div><p>The positional parameters <code class="literal">$1</code> and <code class="literal">$2</code> will evaluate to <code class="literal">id</code> and <code class="literal">23850</code>, respectively. Positional parameters can be used in any order within the substitution string and this is how you connect it with the match pattern.</p></div><div class="section" title="Other functionalities of the rewrite engine"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Other functionalities of the rewrite engine</h2></div></div></div><p>The<a id="id252" class="indexterm"/> rewrite engine can also be used to perform other tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Assigning variables</li><li class="listitem" style="list-style-type: disc">Evaluating <a id="id253" class="indexterm"/>predicates using the <code class="literal">if</code> directive</li><li class="listitem" style="list-style-type: disc">Replying with specified HTTP status code</li></ul></div><p>A combination of these operations and rewrite rules can be performed at every pass of the rewrite engine. Note that <code class="literal">if</code> sections are separate locations, so it is still possible that the location will change at the location rewrite pass.</p></div><div class="section" title="Assigning variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Assigning variables</h2></div></div></div><p>Variables <a id="id254" class="indexterm"/>can be assigned using the <code class="literal">set</code> directive:</p><div class="informalexample"><pre class="programlisting">set $fruit "apple";</pre></div><p>Variable values can be scripts with text and other variables:</p><div class="informalexample"><pre class="programlisting">set $path "static/$arg_filename";</pre></div><p>Once set on <a id="id255" class="indexterm"/>the rewrite phase, variables can be used in any directive in the rest of the configuration file.</p></div><div class="section" title="Evaluating predicates using if sections"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Evaluating predicates using if sections</h2></div></div></div><p>You<a id="id256" class="indexterm"/> have probably figured out from the title that <code class="literal">if</code> sections are part of the rewrite engine. This is true. The <code class="literal">if</code> sections can be used to conditionally apply selected rewrite rules:</p><div class="informalexample"><pre class="programlisting">if ( $request_method = POST ) {
    rewrite ^/media/$ /upload last;
}</pre></div><p>In the preceding configuration, any attempt to make a POST request to the URL <code class="literal">/media/</code> will result in rewriting it to the URL <code class="literal">/upload</code>, while requests with other methods to the same URL will result in no rewrites. Multiple conditions can also be combined. Let's look at the following code:</p><div class="informalexample"><pre class="programlisting">set $c1 "";
set $c2 "";

if ( $request_method = POST ) {
    set $c1 "yes";
}

if ( $scheme = "https" ) {
    set $c2 "yes";
}

set $and "${c1}_${c2}";

if ( $and = "yes_yes" ) {
    rewrite [...];
}</pre></div><p>The preceding configuration applies the rewrite only when both <code class="literal">if</code> conditions are fulfilled, that is, when the request method is <code class="literal">POST</code> and the request URL scheme is <code class="literal">https</code>.</p><p>Now that you know how you can use the <code class="literal">if</code> section, let's talk about its side effects. Remember that conditions in the <code class="literal">if</code> directives are evaluated in the course of the <code class="literal">rewrite</code> directive processing. What it means is that when the <code class="literal">if</code> section contains directives that are not part of the rewrite engine, the behavior of the <code class="literal">if</code> section becomes non-intuitive. This was discussed in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Nginx">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Nginx</em></span>. Consider the following configuration:</p><div class="informalexample"><pre class="programlisting">if ( $request_method = POST ) {
    set $c1 "yes";
    proxy_pass http://localhost:8080;
}

if ( $scheme = "https" ) {
    set $c2 "yes";
    gzip on
}</pre></div><p>Each<a id="id257" class="indexterm"/> individual <code class="literal">if</code> section contains an atomic set of configuration settings. Assume Nginx receives a <code class="literal">POST</code> request with the <code class="literal">https</code> URL scheme such that both conditions evaluate to true. All <code class="literal">set</code> directives will be correctly processed by the rewrite engine and will be assigned to proper values. However, Nginx cannot merge other configuration settings and cannot have multiple configurations active at once. When rewrite processing is finished, Nginx simply switches configuration to the last <code class="literal">if</code> section with its conditions evaluated to true. Because of that, in the preceding configuration, compression will be switched on but the request will not be proxied according to <code class="literal">proxy_pass</code> directive. This is not something you might expect.</p><p>To <a id="id258" class="indexterm"/>avoid this non-intuitive behavior, stick to the following best practices:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Minimize the usage of the <code class="literal">if</code> directive</li><li class="listitem" style="list-style-type: disc">Combine the <code class="literal">if</code> evaluations using the <code class="literal">set</code> directive</li><li class="listitem" style="list-style-type: disc">Take actions only in the last <code class="literal">if</code> section.</li></ul></div></div><div class="section" title="Replying with a specified HTTP status code"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Replying with a specified HTTP status code</h2></div></div></div><p>If a<a id="id259" class="indexterm"/> definite reply with a specified HTTP status code is required in a certain location, you can use the <code class="literal">return</code> directive to enable this behavior and specify the status code, a reply body, or a redirect URL. Let's look at the following code:</p><div class="informalexample"><pre class="programlisting">location / {
    return 301 "https://www.example.com$uri";
}</pre></div><p>The preceding configuration will execute a permanent redirect (301) to the secure part of domain <code class="literal">www.example.com</code> and the URI path identical to the URI path in the original request. Thus, the second argument of the <code class="literal">return</code> directive will be treated as a redirect URI. The <a id="id260" class="indexterm"/>other status codes that treat the second argument of the <code class="literal">return</code> directive as a redirect URI are <code class="literal">302</code>, <code class="literal">303</code> and <code class="literal">307</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Performing a redirect with the <code class="literal">return</code> directive is much faster than doing so with the <code class="literal">rewrite</code> directive, because it does not run any regular expressions. Use the <code class="literal">return</code> directive in your configuration instead of the <code class="literal">rewrite</code> directive whenever possible.</p></div></div><p>The status code 302 is quite common, so the <code class="literal">return</code> directive has a simplified syntax for temporary redirects:</p><div class="informalexample"><pre class="programlisting">location / {
    return "https://www.example.com$uri";
}</pre></div><p>As you can see, if the <code class="literal">return</code> directive has a single argument, it is treated as redirect URI and makes Nginx perform a temporary redirect. This argument must start from <code class="literal">http</code>:// or <code class="literal">https://</code> to trigger such behavior.</p><p>The <code class="literal">return</code> directive can be used to return a reply with a specified body. To trigger such behavior, the status code must simply be other than <code class="literal">301</code>, <code class="literal">302</code>, <code class="literal">303</code> or <code class="literal">307</code>. The second argument of the <code class="literal">return</code> directive specified the content of the response body:</p><div class="informalexample"><pre class="programlisting">location /disabled {
    default_type text/plain;
    return 200 "OK";
}</pre></div><p>The preceding configuration will return HTTP status 200 (OK) with the specified response body. To assert correct processing of the body content, we set response content type to <code class="literal">text/plain</code> using the <code class="literal">default_type</code> directive.</p></div></div></div>
<div class="section" title="Access control"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Access control</h1></div></div></div><p>Access<a id="id261" class="indexterm"/> control restrictions are essential to day-to-day operation. Nginx includes a group of modules that let you allow or deny access depending on various conditions. Nginx denies access to a resource by returning a <code class="literal">403</code> (Forbidden HTTP) status or 401 (Unauthorized) if accessing the resource requires authentication. This<a id="id262" class="indexterm"/> 403 (Forbidden) status code can be intercepted and customized using the <code class="literal">error_page</code> directive.</p><div class="section" title="Restricting access by IP address"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Restricting access by IP address</h2></div></div></div><p>Nginx<a id="id263" class="indexterm"/> allows you to permit or deny access to a virtual host or a location by IP address. For that, you can use the directives <code class="literal">allow</code> and <code class="literal">deny</code>. They have the following format:</p><div class="informalexample"><pre class="programlisting">allow &lt;IP address&gt; | &lt;IP address&gt;/&lt;prefix size&gt; | all;
deny &lt;IP address&gt; | &lt;IP address&gt;/&lt;prefix size&gt; | all;</pre></div><p>Specifying an IP address allows or denies access to a single IP address within a location, while specifying an IP address with a prefix size (for example 192.168.0.0/24 or 200.1:980::/32) allows or denies access to a range of IP addresses.</p><p>The <code class="literal">allow</code> and <code class="literal">deny</code> directives are processed in order of appearance within a location. The remote IP address of a requesting client is matched against the argument of each directive. Once an <code class="literal">allow</code> directive with a matching address is found, access is immediately allowed. Once a <code class="literal">deny</code> directive with a matching address is found, access is immediately denied. Once Nginx reaches the <code class="literal">allow</code> or <code class="literal">deny</code> directive with the <code class="literal">all</code> argument, access is immediately allowed or denied, regardless of client's IP address.</p><p>This, obviously, allows some variation. Here are some simple examples:</p><div class="informalexample"><pre class="programlisting">server {
    deny 192.168.1.0/24;
    allow all;
    [...]
}</pre></div><p>The preceding configuration makes Nginx deny access to IP addresses 192.168.1.0 to 192.168.1.255, while allowing access to everyone else. This happens because the <code class="literal">deny</code> directive is processed first and if matched, is immediately applied. The entire server will be forbidden for specified IP addresses.</p><div class="informalexample"><pre class="programlisting">server {
    […]
    location /admin {
        allow 10.132.3.0/24;
        deny all;
    }
}</pre></div><p>The preceding configuration makes Nginx allow access to <code class="literal">location /admin</code> only to IP addresses in the range 10.132.3.0 to 10.132.3.255. Assuming this range of IP addresses corresponds to some privileged group of users, this configuration makes perfect sense, as only they can access the administrative area of this web application.</p><p>Now, we <a id="id264" class="indexterm"/>can improve on that and make the configuration more complicated. Assume that more networks need access to this web application's administrative interface, while the IP address 10.132.3.55 needs to be denied access due to technical or administrative reasons. Then, we can extend the preceding configuration as follows:</p><div class="informalexample"><pre class="programlisting">server {
  […]
  location /admin {
      allow 10.129.1.0/24;
      allow 10.144.25.0/24;
      deny 10.132.3.55;
      allow 10.132.3.0/24;
      deny all;
  }
}</pre></div><p>As you can see, the directives <code class="literal">allow</code> and <code class="literal">deny</code> are quite intuitive to use. Use them as long as the list of IP addresses to match is not too long. Nginx processes these directives in sequential order, so the time taken to check the client's IP address against the list is on average proportional to the length of the list no matter which directive the address is matched against.</p><p>If you need to match client's IP address against a larger list of addresses, consider using the <code class="literal">geo</code> directive.</p></div><div class="section" title="Using the geo directive to restrict access by IP address"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Using the geo directive to restrict access by IP address</h2></div></div></div><p>With the <code class="literal">geo</code> directive, you<a id="id265" class="indexterm"/> can transform an IP address into a literal or numerical value that can later be used to trigger some actions while processing a request.</p><p>The <code class="literal">geo</code> directive<a id="id266" class="indexterm"/> has<a id="id267" class="indexterm"/> the following format:</p><div class="informalexample"><pre class="programlisting">geo [$&lt;source variable&gt;] $&lt;target variable&gt; { &lt;address mapping&gt; }</pre></div><p>If the source variable is omitted, the <code class="literal">$remote_addr</code> variable is used instead. The address mapping is a list of key/value pairs, separated by whitespace. A key is usually an IP address or an IP address with a prefix size specifying a subnet. A value is an arbitrary string of character or a number. Let's look at the following code:</p><div class="informalexample"><pre class="programlisting">geo $admin_access {
    default                 deny;
    10.129.1.0/24      allow;
    10.144.25.0/24    allow;
    10.132.3.0/24      allow;
}</pre></div><p>The value of the source variable is<a id="id268" class="indexterm"/> used as a key to look up an entry in the address mapping. Once found, the target variable is assigned to the looked-up value. Otherwise, the default value is used.</p><p>With the preceding configuration, the variable <code class="literal">$admin_access</code> will be assigned the value <code class="literal">allow</code> if the remote client's IP address originates from the subnet 10.129.1.0/24, 10.144.25.0/24 or 10.132.3.0/24, and <code class="literal">deny</code> otherwise.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>The <code class="literal">geo</code> directive builds an efficient succinct data structure to look up the values by IP address in memory. It can handle hundreds of thousands of IP addresses and subnets. To accelerate the startup time, specify IP addresses to the <code class="literal">geo</code> directive in ascending order, for example, 1.x.x.x to 10.x.x.x, 1.10.x.x to 1.30.x.x.</p></div></div><p>The address mapping section can contain directives that affect the behavior of <code class="literal">geo</code> address mapping. The following table lists those directives along with their functions:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Directive</p>
</th><th style="text-align: left" valign="bottom">
<p>Function</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">default</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specifies<a id="id269" class="indexterm"/> a value that is returned when no match is found in the IP address mapping.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">proxy</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specifies <a id="id270" class="indexterm"/>the address of a proxy server. If a request originates from an address specified by one of the <code class="literal">proxy</code> directives, <code class="literal">geo</code> will use the last address from the "X-Forwarded-For" header and not from the source variable.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">proxy_recursive</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If a<a id="id271" class="indexterm"/> request originates from an address specified by one of <code class="literal">proxy</code> directives, <code class="literal">geo</code> will process addresses in the "X-Forwarded-For" header from right-to-left in search of an<a id="id272" class="indexterm"/> address outside of the list specified by the <code class="literal">proxy</code> directive. In other words, this directive makes <code class="literal">geo</code> make a better effort in the search for a real IP address.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ranges</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables <a id="id273" class="indexterm"/>IP address ranges in the mapping list.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">delete</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Removes<a id="id274" class="indexterm"/> the specified sub network from the mapping.</p>
</td></tr></tbody></table></div><p>Let's take a look at some examples.</p><p>Consider Nginx receives HTTP traffic<a id="id275" class="indexterm"/> from an application-level load balancer or an inbound proxy located at IP 10.200.0.1. Since all requests will originate from this IP, we need to examine the "X-Forwarded-For" header in order to obtain the real IP address of the client. We then need to change the preceding configuration as follows:</p><div class="informalexample"><pre class="programlisting">geo $example {
    default                 deny;
    proxy 10.200.0.1;
    10.129.1.0/24      allow;
    10.144.25.0/24    allow;
    10.132.3.0/24      allow;
}</pre></div><p>If the server is behind a chain of proxies, the real IP address can be obtained by specifying the <code class="literal">proxy_recursive</code> directive and listing all proxies in the chain:</p><div class="informalexample"><pre class="programlisting">geo $example {
    default                 deny;
    proxy 10.200.0.1;
    proxy 10.200.1.1;
    proxy 10.200.2.1;
    proxy_recursive;
    10.129.1.0/24      allow;
    10.144.25.0/24    allow;
    10.132.3.0/24      allow;
}</pre></div><p>In the preceding example, proxies have IP addresses 10.200.0.1, 10.200.1.1 and 10.200.2.1. The order the addresses are listed in is not important, as Nginx simply iterates over the addresses specified in the "X-Forwarded-For" header from right-to-left and checks their presence in the <code class="literal">geo</code> block. The first address outside of the proxy list becomes the real IP address of the client.</p><p>If IP addresses need to be specified as ranges instead or in addition to subnets, you can enable this by specifying the <code class="literal">ranges</code> directive:</p><div class="informalexample"><pre class="programlisting">geo $example {
    default                                 deny;
    ranges;
    10.129.1.0-10.129.1.255      allow;
    10.144.25.0-10.144.25.255  allow;
    10.132.3.0/24                       allow;
}</pre></div><p>Finally, with the help of the <code class="literal">delete</code> directive, we can define the IP address mapping that allows us to implement an access control procedure analogous to allow and deny directives on a larger scale:</p><div class="informalexample"><pre class="programlisting">geo $admin_access {
    default                 deny;
    10.129.1.0/24      allow;
    10.144.25.0/24    allow;
    10.132.3.0/24      allow;
    delete 10.132.3.55;
}</pre></div><p>To put this configuration in action, we<a id="id276" class="indexterm"/> need to use the <code class="literal">if</code> section to forbid request those client's IP address do not fall in the <code class="literal">allow</code> range of the <code class="literal">geo</code> directive:</p><div class="informalexample"><pre class="programlisting">server {
  […]
  geo $admin_access {
      default                 deny;
      10.129.1.0/24      allow;
      10.144.25.0/24    allow;
      10.132.3.0/24      allow;
      delete 10.132.3.55;
  }

  location /admin {
      if($admin_access != allow) {
          return 403;
      }
      [...]
  }
}</pre></div><p>As you can see, the <code class="literal">geo</code> directive is a powerful and very scalable tool, and access restriction is one of many applications that it can be put to.</p></div><div class="section" title="Using basic authentication for access restriction"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Using basic authentication for access restriction</h2></div></div></div><p>You<a id="id277" class="indexterm"/> can configure Nginx to allow access only to those users who can provide the correct combination of a username and a password. Username/password verification is enabled using the <code class="literal">auth_basic</code> directive:</p><div class="informalexample"><pre class="programlisting">auth_basic &lt;realm name&gt; | off;</pre></div><p>Realm name specifies the name of a realm (an authenticated area). This argument is usually set to a string that helps users to identify the area they are trying to access (for example <span class="emphasis"><em>Administrative area</em></span>, <span class="emphasis"><em>Web mail</em></span>, and so on). This string will be passed to the browser and displayed in the username/password entry dialog. In addition to the realm name, you need to specify a file containing a user database using the <code class="literal">auth_basic_user_file</code> directive:</p><div class="informalexample"><pre class="programlisting">auth_basic_user_file &lt;path to a file&gt;;</pre></div><p>This file must contain authentication information with a username and a password in each line:</p><div class="informalexample"><pre class="programlisting">username1:encrypted_password1
username2:encrypted_password2
username3:encrypted_password3
username4:encrypted_password4
username5:encrypted_password5</pre></div><p>This file presumably must be placed outside of document root of any website you are hosting. The access rights must be set up such that Nginx can only read this file, never write or execute.</p><p>Passwords must be encrypted using one of the following algorithms:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Algorithms</p>
</th><th style="text-align: left" valign="bottom">
<p>Comments</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>CRYPT</p>
</td><td style="text-align: left" valign="top">
<p>Unix <a id="id278" class="indexterm"/>DES-based password encryption algorithm</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SSHA</p>
</td><td style="text-align: left" valign="top">
<p>Salted<a id="id279" class="indexterm"/> Secure Hash Algorithm 1</p>
</td></tr><tr><td colspan="2" style="text-align: center" valign="top">
<p>
<span class="emphasis"><em>Deprecated: Do not use</em></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>MD5</p>
</td><td style="text-align: left" valign="top">
<p>Message<a id="id280" class="indexterm"/> Digest 5 algorithm</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SHA</p>
</td><td style="text-align: left" valign="top">
<p>Unsalted <a id="id281" class="indexterm"/>Secure Hash Algorithm 1</p>
</td></tr></tbody></table></div><p>The password file<a id="id282" class="indexterm"/> can be managed using the <code class="literal">htpasswd</code> utility from Apache web server. Here are some examples:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Instruction</p>
</th><th style="text-align: left" valign="bottom">
<p>Command</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Create a password file and add user <code class="literal">john</code> to the password file</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">$ htpasswd -b -d -c /etc/nginx/auth.d/auth.pwd john test</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Add user <code class="literal">thomas</code> to the password file</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">$ htpasswd -b -d /etc/nginx/auth.d/auth.pwd thomas test</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Replace John's password</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">$ htpasswd -b -d /etc/nginx/auth.d/auth.pwd john test</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Remove user <code class="literal">john</code> from the password file</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">$ htpasswd -D /etc/nginx/auth.d/auth.pwd john</code>
</p>
</td></tr></tbody></table></div><p>The<a id="id283" class="indexterm"/> option <code class="literal">-d</code> forces encryption of passwords using the CRYPT algorithm, which is relatively less secure than SSHA (Salted SHA). To encrypt passwords using SSHA and achieve higher security of your passwords you can use the <code class="literal">slappasswd</code> utility from the <code class="literal">slapd</code> package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install slapd</strong></span>
<span class="strong"><strong>$ slappasswd -s test</strong></span>
<span class="strong"><strong>{SSHA}ZVG7uXWXQVpITwohT0F8yMDGWs0AbYd3</strong></span>
</pre></div><p>Copy the output of <code class="literal">slappasswd</code> into the password file. The password file now looks like this:</p><div class="informalexample"><pre class="programlisting">john:{SSHA}ZVG7uXWXQVpITwohT0F8yMDGWs0AbYd3</pre></div><p>This can be further automated using the <code class="literal">echo</code> command:</p><div class="informalexample"><pre class="programlisting">echo "john:"$(slappasswd -s test) &gt; /etc/nginx/auth.d/auth.pwd</pre></div><p>Once the password file is ready, we can configure password authentication:</p><div class="informalexample"><pre class="programlisting">location /admin {
    auth_basic "Administrative area";
    auth_basic_user_file /etc/nginx/auth.d/auth.pwd;
    [...]
}</pre></div><p>Password authentication is now enabled; you can navigate to <code class="literal">location /admin</code> and see the password prompt:</p><div class="mediaobject"><img src="graphics/B04282_04_01.jpg" alt="Using basic authentication for access restriction"/></div><p>Access<a id="id284" class="indexterm"/> to the protected resource will be granted only when a valid combination of username and password is entered into the password prompt.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Nginx reads and parses the password file every time a request to protected resources is made. This is scalable only when the number of entries in the password file does not exceed a few hundred.</p></div></div></div><div class="section" title="Authenticating users with a subrequest"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Authenticating users with a subrequest</h2></div></div></div><p>User <a id="id285" class="indexterm"/>authentication can be delegated to another web server using the auth request module. This module must first be enabled at the source code configuration stage using the <code class="literal">–with-http_auth_request_module</code> command-line switch:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./configure –with-http_auth_request_module</strong></span>
<span class="strong"><strong>$ make</strong></span>
<span class="strong"><strong>$ make install</strong></span>
</pre></div><p>Now the <code class="literal">auth_request</code> module is ready to be used. The delegation can be configured as follows:</p><div class="informalexample"><pre class="programlisting">location /example {
    auth_request /auth;
    [...]
}

location = /auth {
    internal;
    proxy_pass http://backend;
    proxy_set_header Content-Length "";
    proxy_pass_request_body off;
}</pre></div><p>With <a id="id286" class="indexterm"/>the preceding configuration, Nginx will execute a subrequest to <code class="literal">location /auth</code>. This location will pass the subrequest to an external web application (using the <code class="literal">proxy_pass</code> directive). As the original request might have a request body that the authentication application does not expect, we discard it by specifying <code class="literal">proxy_pass_request_body off</code> and nullifying the "Content-Length" header using <code class="literal">proxy_set_header</code>.</p><p>In order to reply to a subrequest issued by auth request module, you need to create an application that analyzes data from the original request and replies with HTTP status 401 (Unauthorized) or 403 (Forbidden) in order to block access, and with a successful HTTP status 200 to 299 in order to allow access. Here is an example of such an application in <code class="literal">node.js</code>:</p><div class="informalexample"><pre class="programlisting">var http         = require('http');
var express      = require('express')
var cookieParser = require('cookie-parser')

var app = express()
app.use(cookieParser())

app.get('/auth', function(req, res) {
  if(req.cookies.uid) {
    res.sendStatus(200);
  }
  else {
    res.sendStatus(403);
  }
})

app.listen(3000)</pre></div><p>This application allows access as long a cookie names <code class="literal">uid</code> is present, and forbids access otherwise.</p><p>To run this application, create a directory, create a file named <code class="literal">auth.js</code> in this directory, and put the preceding source code into this file. After that, install the required modules <code class="literal">express</code> and <code class="literal">cookie-parser</code> using <code class="literal">npm</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install express cookie-parser</strong></span>
</pre></div><p>After that, you can run the application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ node auth.js</strong></span>
</pre></div><p>The<a id="id287" class="indexterm"/> application will start listening on port 3000. The following Nginx configuration can be used in order to try the application:</p><div class="informalexample"><pre class="programlisting">location /example {
    auth_request /auth;
}

location = /auth {
    internal;
    proxy_pass http://localhost:3000;
    proxy_set_header Content-Length "";
    proxy_pass_request_body off;
}</pre></div><p>The subrequest will be delegated to port 3000 of the host, where Nginx is running, and the application will reply to that request.</p><p>If the application needs to examine the original request URI, it can be passed using the <code class="literal">proxy_set_header</code> directive:</p><div class="informalexample"><pre class="programlisting">proxy_set_header X-Auth-URI $request_uri;</pre></div><p>The original IP address and other original request parameters can be passed to the authenticating application in the same way.</p><p>This is how more sophisticated authentication logic can be implemented in Nginx. If you make the application always reply with HTTP status 200, it can be used for purposes other than authentication, such as logging or data injection.</p></div><div class="section" title="Combining multiple access restriction methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Combining multiple access restriction methods</h2></div></div></div><p>Multiple <a id="id288" class="indexterm"/>access restriction methods can be combined together. For that, they must be both configured and enabled. By default, all configured access restriction methods must be satisfied in order to allow the request. If any of the access restriction methods are not satisfied, Nginx rejects the request with 403 Forbidden HTTP status.</p><p>This behavior can be changed using the <code class="literal">satisfy</code> directive:</p><div class="informalexample"><pre class="programlisting">satisfy all | any;</pre></div><p>Specifying <code class="literal">satisfy any</code> in a location makes Nginx accept the request if any of the enabled access restriction methods are satisfied, while specifying <code class="literal">satisfy all</code> (the default) makes Nginx accept the request only if all enabled access restriction methods are satisfied. To demonstrate how it works, let's extend the preceding example:</p><div class="informalexample"><pre class="programlisting">server {
    […]
    location /admin {
        auth_basic "Administrative area";
        auth_basic_user_file /etc/nginx/auth.d/admin.users;
        allow 10.132.3.0/24;
        deny all;
        satisfy any;
    }
}</pre></div><p>This configuration enables and configures both password authentication and IP address restriction. With <code class="literal">satisfy</code> set to <code class="literal">any</code>, a user needs to either enter a correct username/password combination or originate from IP address range 10.132.3.0 to 10.132.3.255. This makes users from this network somehow more trusted, as they are not required to enter their username and password in order to access the administrative area.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, you learned how to use the rewrite engine and access control functions. These are essential tools of every web master and site reliability engineer. Excelling in configuring and using these features will help you to solve day-to-day problems more efficiently.</p><p>In the next chapter, we will talk about managing inbound and outbound traffic. You will learn how to set various limitations on inbound traffic, how to configure upstream, and how to apply various options to outbound traffic.</p></div></body></html>