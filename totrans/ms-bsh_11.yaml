- en: Living as a Daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the journey that we had through the pages of this book, we saw lots of fun
    stuff, played with processes, sent signals, put things in the background, and
    wrote complex scripts. Everything done so far has one goal: to make us get the
    best from our Bash, have it working for us in repetitive tasks, and use built-ins,
    loops, and external commands to ease our everyday life as a power user. There
    are some times, though, when we need our scripts getting to work on a long run,
    maybe staying active indefinitely, so just running it as a normal program would
    not fit our need. We have to sweep through the obscure path of life as a daemon.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a daemon?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, what makes a daemon different from a normal program? We usually want
    to use a daemon to get some of the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Runs indefinitely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offers a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Survives even if the calling session ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not lock a terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not lock the any subdirectory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That is, more or less, what a daemon as we know it does. Imagine the SSHD daemon,
    FTPD, or Apache:'
  prefs: []
  type: TYPE_NORMAL
- en: Runs in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offers a service you interact with a socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be started or stopped but no further direct interaction from the command
    line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available when you log in and still there when you log off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They run in background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You actually have no idea on how they can do all of this.
  prefs: []
  type: TYPE_NORMAL
- en: DEMO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, how could we turn one of our scripts into a daemon? One first attempt could
    be using `&`. The trailing ampersand is a Bash built-in which instructs the shell
    to run the command in the background inside a subshell. Once the command is executed, the
    shell does not wait for it to finish but returns a code `0`, which means successful,
    and proceeds further in any other commands that are to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What we saw in the example is that the shell executed the first `ls` command
    and gave us back this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But then, it did not wait for the `ls` process to complete its job; it just
    forked it in a subshell and proceeded to execute the `ps` command. For our experiments,
    let''s create an empty shell and a script with an infinite loop, which actually
    does nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special, the only thing interesting here is that once launched, the
    script will execute until we stop it. Now, let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we said it does nothing, but it actually does something: it gets hold
    of your terminal and will not give it back to you until it is terminated or sent
    into the background. So, here we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ctrl *+ *C* sends a `SIGKILL` signal to the process and terminates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Ctrl*+*Z *sends `SIGTSTP`, which suspends its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once suspended, we can put the job in the background using its job ID, in our
    case `[1]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If now we check the status of the job, it will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the script is no longer stopped, but it is actually running
    in the background. At this point, you may have forgotten what was the PID of the
    subshell running the script, or you just do not know that there is a quick way
    to recall it, since it is stored in the `$!` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s bring the process into the foreground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Kill it since it got hold of the terminal once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens if we run multiple instances of the script directly
    in the background using the ampersand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, all of them are in the background with their own job ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There is something new in the output of jobs and those are  `–` and `+` characters,
    which are close to the job ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+`: This identifies the job that `fg` or `bg` will work on by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: This identifies the job that would be the default if the current default
    job exited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s make a test. First, check the status of the jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All of them are running in the background. Let''s recall in the foreground
    the default one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's suspend it with *Ctrl*+*Z:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we just gave the `fg` command without an argument; and as expected, the
    job with ID `3` and the `+` trailing character was pulled into the foreground.
    Now, let''s check the status of the jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The third job is stopped, but we can see the `+` character. Let''s recall the
    default job to the foreground again, and then stop it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the third job is the default one because it never died, it just got
    suspended. So, time to gracefully kill it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the status of the job now that we killed the default
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That's it, the job ID number `2` is now the default one, and the number `1`
    is the second in the line.
  prefs: []
  type: TYPE_NORMAL
- en: nohup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'nohup is a **Portable Operating System Interface** (**POSIX**) command that
    prevents the process given as an argument from receiving the **Hangup (HUP)**
    signal. If we run a script preceding it with nohup, it will be shielded by the
    HUP signal sent to all the processes when the interactive session closes. If the
    standard output is a terminal, nohup appends it to the `nohup.out` file in the
    local directory and if it is not possible in the user''s home directory while
    the standard error is redirected to the `stdout`. So something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is running in the background as `jobs` correctly reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the script is detached and `stdout` is redirected to the `nohup.out` file
    while`stdin` is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s exit our interactive session using `exit `and recreate a new session.
    We just have to open a new terminal and give the `jobs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing, no jobs were listed. Why? Is the process still there? Let''s have
    a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is still running and `PID` is the same, so why don''t we see it
    in the job list? Because we closed the old shell and opened a new one; and so
    the old job list, related to the old shell, got destroyed. This is desirable since
    without having a job ID, the shell cannot control the process and interfere with
    it directly. Then, have a look at the second field of the process listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'While `grep` has a terminal associated `pts/0`, the `while` script runs without
    any terminal associated, so we see `?` and that is what we wanted from the beginning.
    Before proceeding, let''s clean up, killing the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, everything is clear, simple, and easy, isn''t it? No. Sometimes we just
    fire an application on a remote server through SSH. We use `nohup` and `&` to
    detach completely from the terminal, and shield it from the HUP signal on session
    closure; and then when we try to log off, our connection just hangs indefinitely.
    What happened? Why does everything seem to hang? This behavior is due to the OpenSSH
    server that handles the SSH connections: before closing the connection, OpenSSH
    waits to read the **end-of-file (eof)** on the pipes connected to `stdout` and
    `stderr` of the process ran by the user. The issue here is related to how a file
    returns an eof in Unix, and it does so when all the references to it have been
    closed. But when you run a process in the background of the shell you are working
    on over an SSH connection, the process gets the standard references to `stdout`
    and `stderr` of the shell it runs in. When you then close the shell, the OpenSSH
    server loses these references, because the shell has now died and so it will never
    see any eof coming from those. So, it will hang the connection indefinitely. So,
    how to prevent this? Actually either manually closing the process once it has
    been launched and before logging out or redirecting the references to the standard
    streams (`stdin`, `stdout`, `stderr`) when launching it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, not even redirecting sometimes works since OpenSSH is quite sensitive
    to a bunch of causes and circumstances and will not send any HUP to the processes.
  prefs: []
  type: TYPE_NORMAL
- en: disown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we run a process and then want to keep it alive even after the interactive
    shell has been closed? Let''s recall what happens when a shell exits: before exiting,
    it sends `SIGHUP` to all the jobs running. If a job is in stop state, the shell
    will send it a `SIGCONT` signal to resume it so that it can receive the `SIGHUP`
    signal and gracefully die. To accomplish this task, the shell browses through
    a table where it keeps all the jobs, and here is the trick. Let''s start a script
    in the background a few times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s have a look at the shell job table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see all three processes running as we expected. Now do the fun stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What just happened to the job with ID `2`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, it disappeared from the job table but it''s still there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ps` command followed by `-p` and `pid` just shows us a process selecting
    it on `PID`. It just showed that our disowned job is still up and running. So,
    with `disown` , we just removed a job from the shell job list; and thus, when
    the shell exits, it will not send to this job the `SIGHUP` signal it would send if
    no `disown` was given. We can actually go even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The job is still there but has been marked not to receive a `SIGHUP` signal
    from the shell when the latter exits. Optionally, you can run `disown` with no
    `ID` and `-a` so that it removes or marks all the IDs in the job table. No ID
    and `-r` will restrict the operations to only the running jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Are the background processes not being killed after your interactive shell
    is closed? Let''s check this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`huponexit` is set to off. This can be the reason why the background processes
    are not being killed on shell exit. We can temporarily set it on with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To make it permanent, set it in `~/.bashrc` or `/etc/bashrc` with `shopt -s
    huponexit.`
  prefs: []
  type: TYPE_NORMAL
- en: Double fork and setsid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of methods to daemonize a process, maybe less popular but
    really interesting ones; and these are the **double fork** and **setsid**.
  prefs: []
  type: TYPE_NORMAL
- en: Double fork is the way a process is usually daemonized and implies a fork, a
    duplication of the parent process to create a child one. In the case of double
    forking applied to daemonization, the parent process forks off a child process,
    then terminates it. Then, the child process forks its own child process and terminates.
    So, at the end of the chain, the two parent processes die and only the grandchild
    is alive and running but as a daemon. The reason for this resides in how a controlling
    terminal for a session is allocated since the child processes that are forked
    inherit the controlling terminal from their parent process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an interactive session, the shell is the first processed to be executed,
    so it is the controlling process for the terminal and the session leader from
    which all forked processes in the session inherit their controlling terminal.
    Forking and killing the parent processes gives us an orphan process, which is
    automatically reparented to `init`, so it becomes the child of the main process
    of the system. All of this is to prevent the child process from being a session
    leader and acquiring a controlling terminal; and this is the reason why we double
    fork and kill the parent twice: we want to make the child process an orphan so
    that the system, to prevent it from becoming a zombie process, will reparent it
    to `init`. Since it is is not the first process in its pipeline, it cannot become
    a session leader and acquire the controlling terminal. So, the child process is
    then moved to a different session and has no hold on the controlling terminal,
    going effectively daemon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look and start our script in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And have a look at the IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The session ID is the same as the shell from which it forked, but it has its
    own process group ID and the **Parent Process ID** (**PPID**)equal to its parent
    process ID. Let''s see where the script places itself in the process tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, it is nested inside the login session, so it is part of this session.
    Now, let''s double fork:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The PPID of the shell executing `while` is now really interesting; it took
    the value of `1`. This means that his parent process is no longer the shell spawned
    at the login session but the `init` process. But notice, it still shares the same
    session ID and the same terminal. We can double-check with `pstree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We do not have any nesting since we are directly reparented at the first level
    to `init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `setsid`, we get a slightly different outcome. Whenever a process which
    is not the process group leader calls `setsid` , this creates a new session and
    makes the calling process the session leader, the process group leader of a newly
    created process group, and deprives it of a controlling terminal. So, we essentially
    come up with a new session that holds a new process group and only one process,
    the calling process. Both the session and process group ID are set to the calling
    process ID. We want to daemonize a process but there is a drawback, we do not
    have any output unless we redirect to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s demonize our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we had to use the `-e` option of `ps` to show all the processes
    and the `grep` to while, because `ps`, by default, shows only the processes with
    the same effect user ID as the current user and with the same terminal. In this
    case, we changed the terminal, so it would not show up. Finally, let''s have a
    look at `pstree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As we would expect, since the `PPID` is `1`, we see a nesting on the first level.
    The process, in our case the shell, executing the script is reparented to `init`
    without any controlling terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have examined a few methods on how to effectively put a process
    in the background and shield it from a session closure, we can proceed further,
    having a look at how we can actually write scripts that demonize themselves, going
    in the background and working without user interaction. Well, there would be some
    workaround such as using utilities: a screen and a terminal multiplexer, which
    allow you to detach a session from a terminal so that the process can keep running
    even if user logs out. Anyway, this is not our goal, we are not reviewing external
    tools but trying to sort out the best from our Bash, so the next paragraph will
    dwell a bit on the different methods to have Bash to demonize our scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: Becoming a daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A life as a daemon is not an easy life and requires a lot of gruesome deaths
    of parent processes.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing needed for a process to become a daemon is to fork as a new
    process so the parent can exit, and the the prompt is returned to the invoking
    shell. This ensures that the new process is not a process group leader, since
    a process group leader cannot create a new session calling `setsid`. So, the new
    child process can now be promoted to process group leader and session leader by
    calling `setsid`. So far, the new session has no controlling terminal, and so
    does the new child. So, we fork again to be sure that the session and group leader
    can exit. Now, the grandchild is not a session, so the terminal it is going to
    open cannot be its controlling terminal. This is how things work in the hard life
    of a Linux process; if it is not a session leader, the terminal it is going to
    open is not the controlling terminal for the calling process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the process is detached from a controlling terminal but we still have
    an issue: it is locking the directory it has been called from, so if we tried
    to unmount it, we''d fail. The next step is to have the process change its working
    directory to `/` , the root directory of the filesystem (`chdir` `/`), or to any
    directory holding the files the process requires to be able to run. We are almost
    there. A good practice is to set `umask 0` for the process, so we reset `umask`.
    The process could have inherited and will create files with the permissions granted
    by the `open()` call. We are almost there; the next step for the process is to
    close the standard file descriptors (`stdin`, `stdout`, `stderr`) inherited from
    the parent process and open a new set.'
  prefs: []
  type: TYPE_NORMAL
- en: Trapping a daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before giving yourselves to the black magic of creating a daemon, you should
    learn how to shield it from any signals that can doom it to death. As we saw in
    the previous chapters, if a process dies, it could leave a mess behind since it
    had no time to clean *the house*. Scary, but we can do something to prevent all
    this: using traps that will help us deal with the signal and create more robust
    and well functioning scripts. In our case, the `trap` built-in will be handy to
    keep an eye on how our script behaves, since it is a signal handler that modifies
    how a process reacts to a signal. The general syntax of trap is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With commands being a list that can be executed, functions included, upon receiving
    a signal. We already saw some of the signals and their numeric values, but trap
    can use some keywords for the most common ones, as listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signal** | **Numeric value** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `HUP` | `1` | Hang up. Means that the controlling terminal exited. |'
  prefs: []
  type: TYPE_TB
- en: '| `INT` | `2` | Interrupt, it happens when *Ctrl* + *C* is pressed. |'
  prefs: []
  type: TYPE_TB
- en: '| `QUIT` | `3` | Quit. |'
  prefs: []
  type: TYPE_TB
- en: '| `KILL` | `9` | This is an untrappable signal. Upon receiving, the process
    has to exit. |'
  prefs: []
  type: TYPE_TB
- en: '| `TERM` | `15` | Terminate, is the default kill signal, can be handled, otherwise
    the process exits gracefully. |'
  prefs: []
  type: TYPE_TB
- en: '| `EXIT` | `0` | An exit trap is raised on exit. |'
  prefs: []
  type: TYPE_TB
- en: You can specify one or more signals per single trap, and you can also reset
    a trap to its default behavior using the trap called `– signal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signals, how many of them? Who can remember all of them? No one but the `kill`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how to use a trap for a clean exit with this little example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This script features an infinite `while` loop, which hosts a nested `for` loop,
    running through a range between `1` and `1000`. When the value of `x` reaches
    `500` , it prints a message on the `write.log` file. Upon exit, the inner loop
    is relaunched, but the outer structure is an infinite loop and will keep running
    indefinitely. Let''s run it and after a few seconds, let''s issue a *Ctrl *+ *C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we had the terminal locked by our script that was running in the foreground,
    and to regain control, we had to issue a `kill -15` , a *TERM* signal, by pressing
    *Ctrl*+*C*. Let''s have a look at the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems that the log was left behind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, it is actually our log filled with the message we set up. Being a log,
    it is not so bad if it is left behind, but what if this were a temporary file?
    Would we want to litter the filesystem with temp files each time the script exits
    because of a term or another signal? Let''s improve it creating a cleanup function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once invoked, this function will echo a meaningful message on `stdout`, delete
    the `write.log` file, and exit with a successful status. The last bit is the actual
    signal handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all, let''s run the script and give a *Ctrl*+*C* after a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems it worked; let''s have a look at the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Clean, `write.log` has been cleaned upon exit. This is the expected and desired
    behavior. We can also go further, shielding the process from a signal so that
    is essentially ignored. Let''s add the following line to our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute the script in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, since we are going to deal with daemons, we do not have to fear killing innocent
    processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Haha! We killed you!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Ahem, we have to reconsider our statement. It seems that our trap worked very
    well. In fact, a trap with a signal but with just `‘''` as argument simply lets
    the signal be ignored. Well, we have other means of destruction, as we can invoke
    `INT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we exited the script in an orderly manner, no logs left behind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The filesystem is clean, no `write.log` left on it. Now, let''s see a tricky
    use of a trap adding a few bits to our script. Let''s start with `y=0` placed
    at the very opening of the script, followed by a slightly revised loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If a signal is received while Bash is waiting for a command to complete, the
    trap will be executed only after the command is over with its execution. If the
    built-in `wait` is used, it will return immediately upon receiving a signal for
    which a `trap` is set and the `trap` itself gets executed. Notice that a `trap`
    usually exits with a status of 0, but, in this case, the value of the exit status
    will be higher than 128.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time a command is executed, the value of the variable is printed as we
    can see, debugging the script with the `-x` option added to the Bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Move around the `trap` line and see how much info you can gather by modifying
    it to suit your needs. So, play for a while and have fun preparing for the the
    final touch of magic.
  prefs: []
  type: TYPE_NORMAL
- en: Going dark with the daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you think doing daemons is a complex task? Yes it is, unless you use a nice
    utility called *daemon*. The task of this program is to daemonize other commands
    or script in a simple and neat way. Does this utility take any shortcuts? No,
    it just goes through all the steps we have already seen to detach a process from
    the controlling terminal, putting it in background, starting a new session, clearing
    the umask, and closing the old file descriptors. Well, doing it by ourselves in
    Bash coding will be quite a difficult task. This program makes everything straightforward,
    nothing to take care of manually. But there is a drawback: this is not a standard
    utility and must be installed by the user. Not a big issue indeed since many distributions
    such as Debian or Red Hat have a package for this utility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to try this utility out, so let''s take our `write.sh` script and daemonize
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We just called the daemon program, passing the full path to our script and
    the `-r` option that will respawn it in case it gets stopped. Let''s see what
    happens on our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, our script has no controlling terminal; it is running in background
    and writing its log file into the root directory of our filesystem. Now, let''s
    kill it with the `-9` option, as no process can ignore it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'So we killed the process; let''s verify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is there. We actually killed its process but the `-r` option for
    daemon forced it to respawn the script; and here we are, our daemon is up and
    running even though we killed it. If we really want to read it, we must first
    kill the daemon program then the script process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the easiest way to run daemon, which has quite a bunch of options.
    For instance, let''s say we want to run the script as user `zarrelli` and have
    it change the directory to a subdir:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'With `-D`, we gave a new target for `chdir` while `-u` gives the process a
    new running user as we can see from `ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the newly created log files belong to the user called `zarrelli`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Simple, but probably we want a service that runs at the startup of the system
    and stops when it shuts down. So, why not use `systemd` for our purposes?  First
    step, we create the `/etc/systemd/system/writing.service` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a basic unit for a `systemd` managed service, so let''s
    write the following unit configuration lines inside the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special here; depending on what kind of script we are going to demonize,
    we can choose our after target. A network script needs to be run after the network
    is up, so `network.target` is more appropriate here. We could just want to add
    some logging function, so we gave `syslog.target`. We could also give multiple
    target, so it really depends on what we are going to demonize. Under `[Service]` ,
    we just point out the script executable and, more importantly, the type of execution:
    since our script will run indefinitely, it will never exit. So we need to specify
    the *simple* startup style so that `systemd` will execute the script and move
    on without waiting for it to exit like in the *fork* style. The rest is quite
    straightforward, so let''s save the file and give the appropriate permission to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, time to enable the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Create a symlink from `/etc/systemd/system/default.target.wants/writing.service`
    to `/etc/systemd/system/writing.service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reloading the `systemd` daemon will help to have the new service recognized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we are ready for the first execution of our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'No output here, but since this service is managed by `systemd` , we can ask
    the latter what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is running; let''s make some other checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `log` file is there, filling up; now let''s check the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is, without an associated controlling terminal. Last bit, we have to
    stop the daemon when we do not want it to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if we do not want our daemon to be managed by `systemd` anymore, we
    can just unlink it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, restart `systemd` daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look at how to set a process in the background and
    have it survive to our logouts and to most of the signal we could send to it.
    Next step was how to daemonize a process and how to make a system managed service
    out of it thanks to systemd. Is that all? Well, no. With a bit of creativity,
    we can assemble the bits and bricks we were given and create our own daemonized
    scripts and services, so this could be a nice homework during some rainy days.
  prefs: []
  type: TYPE_NORMAL
- en: We are now leaving daemons and moving onto something more related to system
    administration tasks, and we will see how to use some easy, powerful utilities
    and services to customize the environment we are working in and how to make it
    reasonably safe with little efforts.
  prefs: []
  type: TYPE_NORMAL
