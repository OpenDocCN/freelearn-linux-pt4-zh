<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">First Steps in Administration using PowerShell</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we cover the following topics:</p>
<ol>
<li>Working with date properties</li>
<li>Working with date and time functions</li>
<li>Working with currently running process to measure resource consumption</li>
<li>Launching and stopping a process</li>
<li>Finding the owner of a process</li>
<li>Invoking an application based on the file type</li>
<li>Installing the CronTab module</li>
<li>Scheduling jobs in PowerShell</li>
<li>Removing scheduled jobs in PowerShell</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>As per Harvard Business Review, a way to effectively learn is to cycle between <em>information feasting</em> and <em>information fasting</em>. Given that we have familiarised ourselves (and perhaps a little overwhelmed by the volume of the last chapter), we will take a lighter approach to our first steps to administration using PowerShell.</p>
<p>So far, we have seen how to run cmdlets, what their parameters are, how to set and use aliases, etc. <span>In this chapter, we would learn how to use some basic utilities, work with processes, and call applications.</span></p>
<p>Also, even though the title of the book says Linux, most of the recipes in the book should work on Windows as well (especially PowerShell 6.0 on Windows); minor modifications may be required, such as using the backslash in paths.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with date properties</h1>
                </header>
            
            <article>
                
<p>PowerShell is best learnt, starting with simple cmdlets. And <kbd>Get-Date</kbd> is one of the simplest-yet-not-completely-leveraged cmdlets present in PowerShell. In this recipe, we shall play with dates and see how they can be used in different scenarios. As always, the possibilities with PowerShell are quite more than a book can cover. In the interest of brevity, we will look at just enough to enable you to launch yourself gracefully into the world of PowerShell automation; the rest, you would be able to handle by yourself.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>If you followed along the previous chapters and performed all the exercises mentioned in them, you should be good to go. Otherwise, go to the chapter, <em>Installation, Reference and Help</em>, and get yourself a copy of PowerShell. Come back here to continue. This recipe uses only the terminal, so there is no need for anything else.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Before we start working with dates, let us make a simple call for the date.</p>
<ol>
<li>Display the current date and time.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date<br/><br/>Saturday, 16 June 2018 12:14:07</pre>
<ol start="2">
<li>Find out what members this returned object has.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date | Get-Member</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/2fa6a427-d4fb-4f66-a683-816c5e5d09d4.png" width="1812" height="1044"/></div>
<p style="padding-left: 60px">A whole bunch of properties and methods.</p>
<ol start="3">
<li>Attempt to display the date like 16/06/2018.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $Date = Get-Date<br/>PS&gt; "$Date.Day/$Date.Month/$Date.Year"</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/5e6589ce-2bd7-48fd-83f3-13864445c379.png" width="1812" height="1044"/></div>
<p style="padding-left: 60px">The colours do not look right.</p>
<ol start="4">
<li>Change the command as follows. The syntax should look better now, based on your terminal theme. (Don't worry about why the change works for now; we shall look at it when dealing with variables at a later point.)</li>
</ol>
<pre style="padding-left: 90px">PS&gt; "$($Date.Day)/$($Date.Month)/$($Date.Year)"<br/>16/6/2018</pre>
<p style="padding-left: 60px">But that was a lot of work. Is there an easier way?</p>
<ol start="5">
<li>Look in Help to see what parameters you get.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Help Get-Date</pre>
<p style="padding-left: 60px">There is a <kbd>Format</kbd> parameter.</p>
<ol start="6">
<li>Type the following to get the short date.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date -Format d</pre>
<p style="padding-left: 60px">Try the following as the values for <kbd>Format</kbd>: <kbd>g</kbd>, <kbd>U</kbd>, <kbd>yyyy/MM/dd</kbd> and <kbd>yyyyMMddhhmmss</kbd>.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/58296173-4b02-41ea-881a-9f97745811eb.png" width="1812" height="1044"/></div>
<ol start="7">
<li>If you're more comfortable with the UNIX formatting of date, use the <kbd>Uformat</kbd> parameter.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date -Uformat %d/%m/%Y</pre>
<p style="padding-left: 60px">Let us take one more step to pass a custom date to the system and fetch a little information from it, leveraging the members of the object that is output by <kbd>Get-Date</kbd>.</p>
<ol start="8">
<li>Find what day Halloween falls on, in 2018.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; (Get-Date -Day 31 -Month 10 -Year 2018).DayOfWeek <br/>Wednesday</pre>
<ol start="9">
<li>If you know how date in your locale works, pass the date as follows and get the same information.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Date 31/10/2018).DayOfWeek</pre>
<ol start="10">
<li>If you remember the concept of Type Accelerators, use it to get the information you need.</li>
</ol>
<div class="packt_infobox">Remember to use the YMD or MDY format when calling the <kbd>DateTime</kbd> accelerator, in order to avoid errors.</div>
<pre style="padding-left: 90px">PS&gt; ([datetime]'10/31/2018').DayOfWeek</pre>
<p style="padding-left: 60px"><span>To avoid ambiguity, spell out the month.</span></p>
<pre style="padding-left: 90px">PS&gt; ([datetime]'31 October 2018').DayOfWeek</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>System.DateTime</kbd> class in .NET packs a good-enough amount of properties and methods. The <kbd>Get-Date</kbd> cmdlet leverages these properties and methods by means of encapsulation. The <kbd>Get-Date</kbd> cmdlet, by default, pulls the current date and time of the system, and allows you to pick child objects from it, or quickly tie them together as <em>formats</em>.</p>
<p>Besides these operations, the cmdlet also allows you to pass simple string formed like date and time, and converts the input string into the <kbd>DateTime</kbd> object.</p>
<p>While <kbd>Get-Date</kbd> takes into account your current locale, the type accelerator, <kbd>DateTime</kbd>, seems to work on YMD- or the MDY-formatted date-time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>The <a href="https://msdn.microsoft.com/library/system.globalization.datetimeformatinfo.aspx#Remarks">DateTimeFormatInfo</a> Class | Remarks (Microsoft Developer Network)</li>
<li>Recipe 2.3: Parsing input from text to object (Type Accelerators)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with date and time functions</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, <em>Working with date properties</em>, we focused on the properties that the <kbd>DateTime</kbd> object has. The parameters we saw for <kbd>Get-Date</kbd> also worked on these properties. In this recipe, we shall look at methods within the <kbd>DateTime</kbd> object, and learn to use them to our benefit. The main idea behind this recipe, though, is to make you comfortable using methods that are part of the output objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let us first start with converting local time into UTC.</p>
<ol>
<li>At the prompt, type in <kbd>Get-Date</kbd> and list out the members of the output object.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date | Get-Member</pre>
<ol start="2">
<li>There is a method, called <kbd>ToUniversalTime</kbd>. Call the method.</li>
</ol>
<div class="packt_tip">Reduce keystrokes by using tab-completion.</div>
<pre style="padding-left: 90px">PS&gt; (Get-Date).ToUniversalTime()</pre>
<p style="padding-left: 60px">Compare the output to your local time.</p>
<ol start="3">
<li>Next, let us see what day it would be, exactly thirty-five days from today.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Date).AddDays(35)</pre>
<ol start="4">
<li>If you would like to see what time it would be after three hours and eighteen minutes:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Date).AddHours(3).AddMinutes(18)</pre>
<ol start="5">
<li>Next, find out how many days have passed since the World Environment Day, 2016.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Date).Subtract((Get-Date '5 June 2016'))</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/f40255e1-1726-409d-ab88-f5eae0366a3b.png" width="1812" height="1044"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The object that is returned by <kbd>Get-Date</kbd> has several methods just like how it has properties. In this recipe, we use the methods to manipulate date the way we need it. Methods are called with arguments. When you do not want to specify any argument, ensure still to call the methods with an empty pair of parentheses.</p>
<p>Methods can be chained in the way we did in adding hours as well as minutes. As long as the output object does not change, in most cases, you should be able to call methods pertaining to the object by chaining them. If, for instance, you convert the date object into string at the first method, the second method should be a string-input-enabled method. When in doubt, use the <kbd>Get-Member</kbd> cmdlet on the output to see what methods it would support.</p>
<p><span>When you look at <kbd>Get-Member</kbd> run against the <kbd>DateTime</kbd> object, you see that the <kbd>Subtract</kbd> method accepts <kbd>DateTime</kbd> as its argument. Hence the use of <kbd>Get-Date</kbd> <em>within</em> the argument. </span>Passing a cmdlet output as an argument to a method requires the cmdlet, along with the parameters that are passed, to be enclosed within an additional pair of parentheses<span>–</span><kbd>Subtract((Get-Date '5 June 2016'))</kbd> as opposed to <kbd>Subtract(Get-Date '5 June 2016')</kbd><span>–</span>so that the inner command is executed first to get a value, and then, passed to the method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with currently-running processes to measure resource consumption</h1>
                </header>
            
            <article>
                
<p>A good chunk of administration involves working with processes on a given computer. PowerShell contains cmdlets that enable you to work with processes on a computer. In this recipe, we will list out all the processes running in the system, and fetch the amount of resources the processes are collectively consuming.</p>
<p>In the following chapter, <em>Passing data through pipelines</em>, we would look at other options such as filtration and so on, using what we learn in this recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>As we already discussed, our goal here is to work with processes.</p>
<ol>
<li>List out the cmdlets that help you work with processes.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Command -Noun Process</pre>
<div class="packt_tip">Remember that PowerShell uses only singular nouns.</div>
<p style="padding-left: 60px">We get five cmdlets. What we initially need is Get-Process.</p>
<ol start="2">
<li>Run the cmdlet to see what it shows.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process</pre>
<p style="padding-left: 60px">The output is a long table of processes, the memory they are consuming, the CPU time they are using, etc.</p>
<ol start="3">
<li>Get the total count of processes currently running in the system.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Process).Count</pre>
<ol start="4">
<li>Now, fetch the average of the pages of memory used by the processes. The term for this is Working Set, denoted as WS.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process | Measure-Object -Property WS -Average</pre>
<ol start="5">
<li>There are other fields in the hash table as well. Let us get all of that information.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process | Measure-Object -Property WS -Average -Sum -Minimum -Maximum</pre>
<ol start="6">
<li>Get the average, sum, minimum and maximum for both, the working set, as well as the CPU.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process | Measure-Object -Property WS, CPU -Average -Sum -Minimum -Maximum</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/4352fcb8-f849-4aa5-8832-54d1d1d7f056.png" width="1852" height="1084"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The cmdlet, Get-Process, gives out an entire table of all the processes running in the system. Think of each row as an individual object, and the entire table as an array of these rows. Count (or in other words, length) is, logically, a property of an array. Therefore, we call the cmdlet, and on the object that is output, we run a counting operation. This gives us how many processes are running in the system at the moment.</p>
<p>The next cmdlet we see is an important one, as well: <kbd>Measure-Object</kbd>. This cmdlet is designed to perform measurements on the objects that are output. In our case, we pick the property, <kbd>WS</kbd> to perform measurements on. If no property is specified, PowerShell will pick the property based on its definition in the output object.</p>
<p><kbd>Measure-Object</kbd> is capable of performing some neat arithmetic calculations on the output object. We use this capability of the cmdlet to fetch the average first, and then, the sum, the minimum value, and the maximum value as well. The <kbd>Property</kbd> parameter accepts a string array as input (<kbd>Get-Help Measure-Object -Parameter Property</kbd>). Therefore, we specify WS as well as CPU (separated by commas) in the cmdlet, and then perform the measurement operation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Launching and stopping a process</h1>
                </header>
            
            <article>
                
<p>All pro-terminal administrators launch and stop processes from the terminal all the time. This usually happens at the terminal prompt on Bash. With PowerShell, the process is not very different. This recipe will show you how to work the processes. And by the way, this recipe where you go on a full information fast.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Open VS Code. If the status bar at the bottom is blue, chances are that a folder is open in VS Code. VS Code saves the location it is open at, and so, even if you start a session of VS Code after a fresh reboot, you would still see a folder open. We need the folder closed. To do this, press Ctrl + Shift + N (or go to File &gt; New Window). Close the window where a folder is open.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>If you listed out the commands in the previous recipe, scroll up to find what cmdlets might help you with this recipe.</p>
<ol>
<li>At the prompt, type in the following to start Visual Studio Code.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Start-Process code</pre>
<p style="padding-left: 60px">Ensure that the status bar at the bottom is not blue. If it is blue, read the <em>Getting Ready</em> section of this recipe. <span>Press Ctrl + Shift + E or click on Explorer icon on the left sidebar of VS Code. There should not be any directory open there.</span></p>
<ol start="2">
<li>Open VS Code at the directory you created the <kbd>hello-world</kbd> script.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Start-Process code -ArgumentList /home/ram/Documents/code/github/powershell/</pre>
<p style="padding-left: 60px">Press Ctrl + Shift + E or click on Explorer icon on the left sidebar of VS Code. Do you see the directory open?</p>
<p style="padding-left: 60px">Now, let us stop the VS Code process.</p>
<ol start="3">
<li>List out the processes running in the system and see if anything matches <kbd>code</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process | grep code</pre>
<ol start="4">
<li>If you want the PowerShell way of doing it, run the following command and note the name in the <kbd>ProcessName</kbd> column:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process *code*</pre>
<ol start="5">
<li>PowerShell deals with objects; <kbd>grep</kbd> outputs text. Therefore, now that we know that the exact name of the process is <kbd>code</kbd>, we directly get details on the process.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process code</pre>
<p style="padding-left: 60px">That gives us a valid output.</p>
<ol start="6">
<li>Stop all the <kbd>code</kbd> processes.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Stop-Process code</pre>
<p style="padding-left: 60px">That would not work; the cmdlet accepts a <kbd>System.Diagnostics.Process</kbd> object as input.</p>
<ol start="7">
<li>Enclose <kbd>Get-Process</kbd> within parentheses and pass the input to <kbd>Stop-Process</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Stop-Process (Get-Process code)</pre>
<ol start="8">
<li>Now, see if there is a <kbd>code</kbd> process running any more.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process code</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/d4e99014-7a79-4f58-9d80-a711853638b3.png" width="1812" height="1044"/></div>
<p style="padding-left: 60px">The best way of stopping a process is using its ID.</p>
<ol start="9">
<li>I am running <kbd>dconf-editor</kbd> on my PC right now, and would like to close it. You may choose any process to stop; play safe, though.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process dconf-editor<br/>PS&gt; Stop-Process -Id 20608</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The cmdlet, Start-Process, works with paths. In case of <kbd>code</kbd>, though, Linux knows the path where the package is installed. Therefore, simply calling the package by "command" is sufficient.</p>
<p>The VS Code process accepts directory/file location as an input. Therefore, we add the <kbd>ArgumentList</kbd> parameter and pass the path to the process as an argument. This opens that directory in <span>VS Code</span>.</p>
<p>Stopping a process requires a .NET object as input by default; <kbd>Stop-Process</kbd> would not accept string as the default input. Therefore, we enclose the <kbd>Get-Process</kbd> cmdlet within parentheses, so that it gets executed first and outputs a <span><kbd>System.Diagnostics.Process</kbd> object, which is then processed by <kbd>Stop-Process</kbd>.</span></p>
<p>In order to be exact with respect to which process we would like to stop, we use the Process ID, and pass it as the argument to <kbd>Stop-Process</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding the owner of a process</h1>
                </header>
            
            <article>
                
<p>In the recipe, <em>Working with currently-running processes…</em>, we listed out the processes running in the system. The table did not show us the process owner. In this recipe, we look at working with processes started by a certain owner.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Get-Process</kbd> cmdlet can fetch us this information.</p>
<ol>
<li>At the prompt, type the following to get all the parameters that the <kbd>Get-Process</kbd> cmdlet accepts.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Help Get-Process</pre>
<ol start="2">
<li>We see a parameter <kbd>IncludeUserName</kbd> (the name suggests it is a switch parameter). Get more information on it.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Help Get-Process -Parameter IncludeUserName</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/c0afced1-67c8-48e2-bb2a-faff5025c2b6.png" width="1812" height="1044"/></div>
<ol start="3">
<li>Run the command:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process -IncludeUserName</pre>
<ol start="4">
<li>Filter out the processes started by you. We will use <kbd>grep</kbd> for this operation, until we learn how to filter in PowerShell.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process -IncludeUserName | grep ram</pre>
<ol start="5">
<li>Count the number of processes running under your name.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; (Get-Process -IncludeUserName | grep ram).Count</pre>
<ol start="6">
<li>If you would like to use the <kbd>Measure-Object</kbd> cmdlet, you can.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process -IncludeUserName | grep ram | Measure-Object</pre>
<ol start="7">
<li>Let us now see how what amount of working set all of the processes started by you consume.</li>
</ol>
<pre style="padding-left: 90px" class="mce-root">PS&gt; Get-Process -IncludeUserName | grep ram | Measure-Object -Property WS -Sum</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/ca96880c-e0ef-4261-9578-d0b31a8234e2.png" width="1812" height="1044"/></div>
<p>There is an error.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>Get-Process</kbd> does not show you the process owner information by default. In some situations, it may be necessary to have this information. In this simple recipe, we use the help documentation to get all the parameters and use the <kbd>IncludeUserName</kbd> switch parameter to get the process owner information.</p>
<p>In the next step, we filter out the processes started by a certain user, and then, count the number of processes. We do the same using <kbd>Measure-Object</kbd> as well, and notice that the output is the same. <kbd>Measure-Object</kbd> has "object" in its name, but worked on text that was output by <kbd>grep</kbd>. At the same time, it said at the next step that the value of <kbd>Property</kbd> is invalid.</p>
<p>The answer to why <kbd>Measure-Object</kbd> worked when counting, is in the step that precedes it. We know that if an array is output, PowerShell can count the number of elements in the array. <kbd>Measure-Object</kbd> is also capable of the same: measuring what can be measured in string arrays—<kbd>Count</kbd> works on string arrays.</p>
<p>However, when we tried to fetch the total working set, <kbd>Measure-Object</kbd> could not get us that. The reason is that the output of <kbd>grep</kbd>, as we have seen before, is plain text.</p>
<pre>PS&gt; Get-Process -IncludeUserName | grep ram | Get-Member</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Something perhaps a few steps ahead, but, what if we wanted to get that working set information anyway, from the output of <kbd>grep</kbd>? Simple challenge, accepted.</p>
<pre>PS&gt; Get-Process -IncludeUserName | grep ram | awk '{print $1}' | ForEach-Object {[Double]$_} | Measure-Object -Sum</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/a7449853-658a-4dc1-bb60-82cb93f4e8f3.png" width="1812" height="1044"/></div>
<p>Do not worry too much about how that works, for now. Once we read and understand looping through available elements, we will have a better understanding of how we got this to work. For now, understand that we converted each of the returned strings into <kbd>double</kbd> values using the <kbd>Double</kbd> type accelerator. Then, we did a <kbd>Measure-Object</kbd> and found the sum.</p>
<p>Of course, with only PowerShell, this would be much simpler.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 2.4: Comparing the outputs of Bash and PowerShell.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Invoking an application based on the file type</h1>
                </header>
            
            <article>
                
<p>So far, we have seen how to use <kbd>Start-Process</kbd> to start an application. That involves, in many cases, launching the application, and from the application, opening a file that you want to work on, using the application. In this recipe, we will leverage the concept of file association, and a proper calling cmdlet to launch an application. In fact, we will go a little further than that.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Download a few images from the web to work with this recipe. They could be anything, just ensure that all of them are of the same file type.</p>
<ol>
<li>Navigate to the location where you saved the image files.</li>
<li>At the prompt, type in the following command to open your image viewer, and the files in it.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Invoke-Item -Path *.png</pre>
<ol start="3">
<li>Now, create a text file in the same location.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; New-Item file-1.txt -ItemType File</pre>
<ol start="4">
<li>Now, invoke all the files in their respective applications.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Invoke-Item *</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the recipe, <em>Calling a PowerShell cmdlet from outside of<span> </span>PowerShell</em>, we called a PowerShell script from Bash by first invoking PowerShell and then passing the script as an argument to the<span> </span><kbd>pwsh</kbd><span> </span>command. The process is very similar in PowerShell as well, as seen in<span> </span><em>Launching and stopping a process</em>.</p>
<p>The <kbd>Invoke-Item</kbd> cmdlet relies on the internal file association to open the files. The real use of <kbd>Invoke-Item</kbd> is when opening multiple files, whether of the same kind, or different kinds of files within the same path using the respective applications that handle them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing the Crontab PowerShell module </h1>
                </header>
            
            <article>
                
<p>In this recipe, we will discuss the installation details of a PowerShell module to manage Cron jobs using PowerShell on a Linux machine.</p>
<p><span>There are times when there is a need for performing administrative tasks or scheduling a script to execute automatically at given time. Linux distros, by default, come with a scheduling utility, called, Crontab, which allows any given tasks to be run automatically in the background at a given time. Cron is a time-based scheduler program. It generates events based on the definition in the <kbd>crontab</kbd> file.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The PowerShell crontab wrapper module is not available in the PowerShell repository as yet. You must download the files manually to install the module. The simplest way is to clone the PowerShell repository and install the module from within its <kbd>demos</kbd> directory.</p>
<div class="packt_infobox packt_tip">If you would rather only install the CronTab module alone, download the <kbd>&lt;repo&gt;/demos/crontab</kbd> <em>directory</em> manually. Then, start PowerShell as super-user, and navigate to <kbd>crontab</kbd>. Continue from step 4.</div>
<ol>
<li>Clone the PowerShell repository on to your computer.</li>
</ol>
<pre style="padding-left: 90px">$ mkdir ~/code<br/>$ git clone https://github.com/PowerShell/PowerShell.git</pre>
<ol start="2">
<li>Start <kbd>pwsh</kbd> as a super-user.</li>
<li>Go to the <kbd>demos/crontab/CronTab</kbd> directory within the repository. This is where the module manifest is placed.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Set-Location ~/code/PowerShell/demos/crontab</pre>
<ol start="4">
<li>Use the <kbd>Import-Module</kbd> <span>cmdlet on the module manifest to import the module.</span></li>
</ol>
<pre style="padding-left: 90px">PS&gt; Import-Module -Name ./CronTab/CronTab.psd1</pre>
<ol start="5">
<li>To list the components of CronTab module use the <kbd>Get-Module</kbd> cmdlet.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Module -Name CronTab | Format-List<br/>Name : CronTab<br/>Path : /home/PacktPub/CronTab.psm1<br/>Description : <br/>ModuleType : Script<br/>Version : 0.0<br/>NestedModules : {}<br/>ExportedFunctions : {ConvertTo-CronJob, Get-CronJob, Get-CronTab, Get-CronTabUser...}<br/>ExportedCmdlets : <br/>ExportedVariables : <br/>ExportedAliases : </pre>
<ol start="6">
<li>To list the available command types of <kbd>CronTab</kbd> module use  the <kbd>Get-Command</kbd> cmdlet.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Command -Module CronTab  <br/>CommandType Name Version Source<br/>----------- ---- ------- ------<br/>Function ConvertTo-CronJob 0.0 CronTab<br/>Function Get-CronJob 0.0 CronTab<br/>Function Get-CronTab 0.0 CronTab<br/>Function Get-CronTabUser 0.0 CronTab<br/>Function Import-CronTab 0.0 CronTab<br/>Function Invoke-CronTab 0.0 CronTab<br/>Function New-CronJob 0.0 CronTab<br/>Function Remove-CronJob 0.0 CronTab</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When you download the<span>CronTab</span> module,  the following files get copied to the CronTab folder from the URL mentioned in the recipe, and these files contain the module data.</p>
<ol>
<li>CronTab.ps1xml</li>
<li>CronTab.psd1</li>
<li>CronTab.psm1</li>
</ol>
<p><span>The </span><kbd>Import-Module</kbd><span> cmdlet registers the cmdlets available in the module into the PowerShell session and makes the module ready for use. The Import-Module cmdlet is run against the module manifest, which is the <kbd>psd1</kbd> file. </span></p>
<p>When you run the <kbd>Get-Command</kbd> cmdlet, you get a list of all the cmdlets available in the module.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scheduling jobs in PowerShell</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will see how to schedule a job using PowerShell cmdlets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<ol>
<li>Log in to the terminal using SU privileges.</li>
<li>Open a PowerShell console using the <kbd>pwsh</kbd> command.</li>
<li>Import the module (refer the recipe: Installation of the Crontab PowerShell module).</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, check the existence of the command or scripts that you want to schedule from a terminal </li>
</ol>
<pre style="padding-left: 90px">$ pwsh -f "/tmp/DataLoading.PS1;"</pre>
<ol start="2">
<li>To run the script based on a schedule, use the <kbd>New-CronJob</kbd> cmdlet.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; New-CronJob -Command 'pwsh -f "/tmp/DataLoading.PS1;"' -Minute 0,15,30,45 | Out-Host<br/><br/>PS&gt; New-CronJob -Command 'pwsh -f "/tmp/DataLoading.PS1;"' -Minute */15 | Out-Host<br/><br/>PS&gt; New-CronJob -Command 'pwsh -f "/tmp/DataLoading.PS1;"' -Minute */15 -Hour 10-12 | Out-Host <br/><br/>PS&gt; New-CronJob -Command 'rm -rf /tmp/clr*' -Minute 15 -Hour 1 | Out-Host <br/><br/>PS&gt; New-CronJob -Command 'pwsh -f "/tmp/DataLoading.PS1;"' -Minute */15 -Hour 10-12 -DayOfWeek sun,tue,fri -Month Jan,Mar,Jun,Sep,Dec | Out-Host</pre>
<ol start="3">
<li>To get the list of currently scheduled jobs, run the <kbd>Get-CronJob</kbd> cmdlet.</li>
</ol>
<pre style="padding-left: 90px"><span>PS /home/PacktPub&gt; Get-CronJob |Format-Table -AutoSize <br/>Minute Hour DayOfMonth Month DayOfWeek Command<br/>------ ---- ---------- ----- --------- -------<br/>2 * * * * python ./pythonexmaple.py<br/>5 1 * * * rm -rf /tmp/clr*.*<br/>15 * * * * /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"<br/>*/15 * * * * /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"<br/>0,15,30,45 * * * * /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"<br/>*/15 10-12 * * * /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"<br/>*/15 10-12 * Jan,Mar sun,tue,fri /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"</span></pre>
<ol start="4">
<li>To view the contents of scheduled jobs in the crontab configuration file, use <kbd>Get-CronTab</kbd>. </li>
</ol>
<pre style="padding-left: 90px">PS &gt; Get-CronTab <br/>2 * * * * python ./pythonexmaple.py<br/>5 1 * * * rm -rf /tmp/clr*.*<br/>*/15 * * * * /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"<br/>0,15,30,45 * * * * /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"<br/>*/15 10-12 * * * /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"<br/>*/15 10-12 * Jan, Mar, Jun, Sep, Dec sun, tue, fri /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The PowerShell implementation of <kbd>crontab</kbd> technically a wrapper, which encapsulates the <kbd>crontab</kbd> commands that work in Linux. Why use PowerShell to schedule jobs if the underlying functions are that of <kbd>crontab</kbd>? The reason would be the uniformity of usage, the consistency and the object-oriented approach. If you know to use PowerShell, that is all you need in order to be able to use <kbd>crontab</kbd> as well. That is the goal.</p>
<p>The New-CronTab cmdlet is used to define new tasks. The parameters available define the frequency with which the tasks are to be executed. The <span>Cron jobs are executed with the same privileges as with which the <kbd>New-CronTab</kbd> cmdlet was executed. In other words, if you launched PowerShell as a super-user and ran New-CronTab to define a schedule, the commands that would be run on the specified schedule would be run with super-user privileges.</span></p>
<p>In the steps, the command to run is listed using <kbd>-Command</kbd> parameter.</p>
<p>Let us also look in brief how what inputs the New-CronTab accepts. There are two ways to run a command every 15 minutes: The first is where each minute is specified:</p>
<pre>0,15,30,45 * * * * /path/command</pre>
<p><span>Alternatively,  you can simplify the same to <kbd>*/15</kbd>.</span></p>
<pre>*/15 * * * * /path/command</pre>
<p>Range can also be specified for scheduling a job. In our example, the job runs at 10 A.M,11 A.M and 12 P.M hours using the range option.</p>
<pre>*/15 10-12 * * * /path/command</pre>
<p>In the last example, (the Names format), the job is scheduled to run using the DayOfweek (Sun, Tue, Fri) and Month (Jan, Mar) parameters.</p>
<pre>*/15       10-12 *          Jan,Mar sun,tue,fri /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"</pre>
<p>The Cron Table configuration is read using <kbd>Get-CronTab</kbd> cmdlet. Each line represents a record of metadata about the scheduled job; it specifies the frequency and the command/script that should be executed.</p>
<p>The caveat as of now is that if you setup Cron jobs incorrectly they appear to silently fail. Cron has an own reserved <kbd>syslog</kbd> facility, so you should have a look at the <kbd>/etc/syslog.conf</kbd> file (or the equivalent file in your Linux distro) to see where messages from <kbd>cron</kbd> are sent. The common destinations include <kbd>/var/log/cron</kbd>, <kbd>/var/log/messages</kbd> and <kbd>/var/log/syslog</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Removing the jobs in PowerShell</h1>
                </header>
            
            <article>
                
<p>In this recipe, we're going to see the steps to remove the entries from the CronTab file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>That we have created entries into the <kbd>cron</kbd> configuration file, let us attempt to remove those entries.</p>
<ol>
<li>List the jobs using the <kbd>Get-CronJob</kbd> cmdlet. This will get you the list of jobs that are created by reading the <kbd>CronTab</kbd> file</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-CronJob | Format-Table -AutoSize</pre>
<ol start="2">
<li>Now, apply a conditional logic to segregate the required job entries using <kbd>Where-Object</kbd> clause. You will read more about this in the chapter, <em>Passing Data Through Pipelines</em>.</li>
</ol>
<pre style="padding-left: 90px">PS &gt; Get-CronJob | Where-Object {$_.Month -match 'Jan'} | Format-Table -AutoSize <br/><br/>Minute Hour DayOfMonth Month DayOfWeek Command<br/>------ ---- ---------- ----- --------- -------<br/>*/15 10-12 * Jan,Mar,Jun,Sep,Dec sun,tue,fri /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"<br/>*/15 10-12 * Jan,Mar sun,tue,fri /usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"</pre>
<ol start="4">
<li>Remove the entries using <kbd>Remove-CronJob</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS &gt; Get-CronJob | Where-Object {$_.Month -match 'Jan'} | Remove-CronJob <br/><br/>Confirm<br/>Are you sure you want to perform this action?<br/>Performing the operation "Remove" on target "/usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"".<br/>[Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help (default is "Y"): Y<br/><br/>Confirm<br/>Are you sure you want to perform this action?<br/>Performing the operation "Remove" on target "/usr/bin/pwsh -c "cd /tmp/; ./DataLoading.PS1;"".<br/>[Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help (default is "Y"): Y<br/>PS /home/PacktPub&gt; </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>When we would like to remove cron jobs, we list out the cron jobs and then, pass the job objects via the pipeline to the cmdlet, <kbd>Remove-CronJob</kbd>, to remove the jobs from the configuration file.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>