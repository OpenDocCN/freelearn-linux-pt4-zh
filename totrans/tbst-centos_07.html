<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Troubleshooting Security Issues"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Troubleshooting Security Issues</h1></div></div></div><p>In this chapter, we will discuss the issues related to the security of CentOS 7. However, instead of taking a traditional tour relating to hardening a server, we will take a more pragmatic approach by reviewing SSH, <code class="literal">SELinux</code>, HIDS, and Firewalld in an alternate fashion in order to encourage you to discover more about the system in general.</p><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discover how to use <code class="literal">aureport</code> to generate audit reports and audit <code class="literal">SELinux</code> with <code class="literal">setroubleshoot</code></li><li class="listitem" style="list-style-type: disc">Learn how to add and manage <code class="literal">SSH</code> banners and use <code class="literal">FIGlet</code> to create custom banners</li><li class="listitem" style="list-style-type: disc">Discover more about the rudiments of tuning the <code class="literal">SSH</code> service</li><li class="listitem" style="list-style-type: disc">Learn how to install <code class="literal">Tripwire</code> and provide your system with an intrusion detection system</li><li class="listitem" style="list-style-type: disc">Discover more about Firewalld, zone management, and how to add/remove interfaces, ports, and masquerade your infrastructure</li><li class="listitem" style="list-style-type: disc">Learn how to remove Firewalld and return to iptables</li></ul></div><div class="section" title="Auditing SELinux with aureport and setroubleshoot"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Auditing SELinux with aureport and setroubleshoot</h1></div></div></div><p>Disabling <a id="id284" class="indexterm"/>
<code class="literal">SELinux</code> is something that happens quite regularly. It is a common occurrence when hosted control panels are used, or when one or more specific applications seem to be experiencing such difficulties that they will not run with <code class="literal">SELinux</code> enabled. In these instances, the act of disabling <code class="literal">SELinux</code> is a tried-and-tested technique that can save the system's administrator an immense amount of time. For many, this is an automatic response, while others will argue that the tools associated with <code class="literal">SELinux</code> are probably more at home on the desktop, workstation, on servers with a GUI, or in a controlled network environment. However, the fact is simple, the act of disabling <code class="literal">SELinux</code> will remove a key component of security and leave the system exposed. I agree, <code class="literal">SELinux</code> is a complex system, and for those of us who wish to <a id="id285" class="indexterm"/>enjoy the protection it offers, our lives can be made simpler through the option of running <code class="literal">aureport</code> like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># aureport --avc | tail -n 10</strong></span>
</pre></div><p>This will provide a list of <code class="literal">avc</code> messages, the output of which may look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>AVC Report</strong></span>
<span class="strong"><strong>========================================================</strong></span>
<span class="strong"><strong># date time comm subj syscall class permission obj event</strong></span>
<span class="strong"><strong>========================================================</strong></span>
<span class="strong"><strong>1. 04/18/2015 13:50:53 ? system_u:system_r:init_t:s0 0 (null) (null) (null) unset 384</strong></span>
<span class="strong"><strong>2. 04/18/2015 13:55:49 ? system_u:system_r:init_t:s0 0 (null) (null) (null) unset 789</strong></span>
</pre></div><p>The <code class="literal">aureport</code> utility<a id="id286" class="indexterm"/> is designed to create column-based reports that show the events recorded in the audit log files, and by taking this one step further, you can also use this same utility to create a list of executable files with the following variation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># aureport -x</strong></span>
</pre></div><p>The output of which, depending on the nature of your system, could look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>5988. 05/03/2015 12:40:01 /usr/sbin/crond cron ? 0 773</strong></span>
<span class="strong"><strong>5989. 05/03/2015 12:40:01 /usr/sbin/crond cron ? 0 774</strong></span>
<span class="strong"><strong>5990. 05/03/2015 12:50:01 /usr/sbin/crond cron ? -1 775</strong></span>
<span class="strong"><strong>5991. 05/03/2015 12:50:01 /usr/sbin/crond cron ? -1 776</strong></span>
<span class="strong"><strong>5992. 05/03/2015 12:50:01 /usr/sbin/crond cron ? 0 778</strong></span>
<span class="strong"><strong>5993. 05/03/2015 12:50:01 /usr/sbin/crond cron ? 0 779</strong></span>
<span class="strong"><strong>5994. 05/03/2015 12:50:01 /usr/sbin/crond cron ? 0 780</strong></span>
<span class="strong"><strong>5995. 05/03/2015 12:50:01 /usr/sbin/crond cron ? 0 781</strong></span>
<span class="strong"><strong>5996. 05/03/2015 13:00:01 /usr/sbin/crond cron ? -1 782</strong></span>
<span class="strong"><strong>5997. 05/03/2015 13:00:01 /usr/sbin/crond cron ? -1 783</strong></span>
<span class="strong"><strong>5998. 05/03/2015 13:00:01 /usr/sbin/crond cron ? 0 785</strong></span>
<span class="strong"><strong>5999. 05/03/2015 13:00:01 /usr/sbin/crond cron ? 0 786</strong></span>
<span class="strong"><strong>6000. 05/03/2015 13:00:01 /usr/sbin/crond cron ? 0 787</strong></span>
<span class="strong"><strong>6001. 05/03/2015 13:00:01 /usr/sbin/crond cron ? 0 788</strong></span>
<span class="strong"><strong>6002. 05/03/2015 13:01:01 /usr/sbin/crond cron ? -1 789</strong></span>
<span class="strong"><strong>6003. 05/03/2015 13:01:01 /usr/sbin/crond cron ? -1 790</strong></span>
<span class="strong"><strong>6004. 05/03/2015 13:01:01 /usr/sbin/crond cron ? 0 792</strong></span>
<span class="strong"><strong>6005. 05/03/2015 13:01:01 /usr/sbin/crond cron ? 0 793</strong></span>
<span class="strong"><strong>6006. 05/03/2015 13:01:01 /usr/sbin/crond cron ? 0 794</strong></span>
<span class="strong"><strong>6007. 05/03/2015 13:01:01 /usr/sbin/crond cron ? 0 795</strong></span>
</pre></div><p>Others may<a id="id287" class="indexterm"/> want to use this utility in order to generate a full authentication report by using the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># aureport -au -i</strong></span>
</pre></div><p>The output of which would look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Authentication Report</strong></span>
<span class="strong"><strong>============================================</strong></span>
<span class="strong"><strong># date time acct host term exe success event</strong></span>
<span class="strong"><strong>============================================</strong></span>
<span class="strong"><strong>1. 04/18/2015 12:40:57 root 192.168.1.17 ssh /usr/sbin/sshd yes 343</strong></span>
<span class="strong"><strong>2. 04/18/2015 12:40:57 root 192.168.1.17 ssh /usr/sbin/sshd yes 346</strong></span>
<span class="strong"><strong>3. 04/18/2015 19:28:26 root 192.168.1.17 ssh /usr/sbin/sshd yes 1099</strong></span>
<span class="strong"><strong>4. 04/18/2015 19:28:26 root 192.168.1.17 ssh /usr/sbin/sshd yes 1102</strong></span>
<span class="strong"><strong>5. 04/19/2015 04:57:06 root 192.168.1.17 ssh /usr/sbin/sshd yes 345</strong></span>
</pre></div><p>To generate a summary report of failed authentication events, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># aureport -au --summary -i --failed</strong></span>
</pre></div><p>You can create an opposing summary report of successful authentication events with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># aureport -au --summary -i --success</strong></span>
</pre></div><p>So, given the depth of reporting at your disposal, when you are dealing with a system that runs <code class="literal">SELinux</code>, your first point of call as a troubleshooter is to consider the benefits of <code class="literal">aureport</code> when auditing the system. However, as an addition, you will also want to consider a tool called <code class="literal">setroubleshoot</code>.</p><p>The <code class="literal">setroubleshoot</code> tool<a id="id288" class="indexterm"/> can be installed with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install setroubleshoot setools</strong></span>
</pre></div><p>Having done this, you have now equipped the system with a tool that will actively return announcements from the log file found at <code class="literal">/var/log/audit/audit.log</code> and translate them into something far more "human-friendly". This tool is called <code class="literal">sealert</code> and its purpose is to issue reports and resolutions regarding any issues related to <code class="literal">SELinux</code>.</p><p>A process can be started by invoking the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sealert -a /var/log/audit/audit.log</strong></span>
</pre></div><p>However, if you're expecting a large return of data, then the following variation may be more applicable to your needs:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sealert -a /var/log/audit/audit.log | less</strong></span>
</pre></div><p>However, before<a id="id289" class="indexterm"/> we exit our discussion on auditing <code class="literal">SELinux</code>, for those of you who are running headless and would like to receive e-mail alerts, a final configuration change may be necessary.</p><p>To do this, we will open the following file in our favorite text editor:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/setroubleshoot/setroubleshoot.conf</strong></span>
</pre></div><p>Scroll down this file to find the <code class="literal">[email]</code> section and add your e-mail address to the following line by replacing the relevant text:</p><div class="informalexample"><pre class="programlisting">from_address = SELinux_Troubleshoot</pre></div><p>Now, create the relevant list of recipients by customizing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>echo "email@domain.com" &gt;&gt; /var/lib/setroubleshoot/email_alert_recipients</strong></span>
</pre></div><p>The <code class="literal">setroubleshoot</code> command may not be the perfect solution for everyone and every environment, but the effect of using this package is to realize that regardless of whether you are running a headless server, a server with a GUI, or even a desktop workstation, <code class="literal">SELinux Alert</code> is a solution that will enable you to keep using and enjoying the benefits of <code class="literal">SELinux</code> without sacrificing your security.</p><p>Given the weight of this subject, further reading regarding <code class="literal">SELinux</code> and <code class="literal">setroubleshoot</code> is available at the end of this chapter.</p></div></div>
<div class="section" title="SSH banners"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>SSH banners</h1></div></div></div><p>Using <a id="id290" class="indexterm"/>SSH banners is not exactly troubleshooting in its purest form (and yes, we are dipping into the subject of hardening). However, as it is often considered to be a good idea that all servers carry some form of legal banner, notice, or security warning that should be displayed to a user before and after the SSH authentication process is started and finished, it is an area we should explore. Troubleshooters do not build systems, but they do fix them and, for this reason, it is something you will be expected to know. Moreover, as this provides an entry into the world of SSH, learning how to develop your very own (and unique) SSH login banners will be a nice place to start.</p><p>To display a banner prior to SSH authentication, you should open the following file in your favorite editor:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/issue.net</strong></span>
</pre></div><p>Now, add the<a id="id291" class="indexterm"/> desired message, notice, or security notice as required, but remember, try to keep it short and simple.</p><p>For example, you may want to say:</p><div class="informalexample"><pre class="programlisting">Warning! You are entering a secure area. This service is restricted to authorized users only. All activities on this system are logged. Any unauthorized access will be fully investigated and reported to the appropriate law enforcement agencies.</pre></div><p>Having done this and saved the file, you should now open the master configuration file for SSH in your favorite text editor like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/ssh/sshd_config</strong></span>
</pre></div><p>Then scroll down until you find the following line:</p><div class="informalexample"><pre class="programlisting">#Banner</pre></div><p>Uncomment it and add the correct path to <code class="literal">issue.net</code> like this:</p><div class="informalexample"><pre class="programlisting">Banner /etc/issue.net</pre></div><p>Now save and close the file before restarting the SSH service in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl restart sshd</strong></span>
</pre></div><p>At this point, you should check the status of the SSH service at any time by typing this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl status sshd</strong></span>
</pre></div><p>You can qualify the banner settings used by SSH with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep -i banner /etc/ssh/sshd_config</strong></span>
</pre></div><p>However, let's say you wanted to provide a unique message by converting plain text to a large ASCII banner.</p><p>To do this, we will need to install a small utility called <code class="literal">FIGlet</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install figlet</strong></span>
</pre></div><p>To use <code class="literal">FIGlet</code>, you simply need to use the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># figlet "My Message Here"</strong></span>
</pre></div><p>However, for the purposes of our SSH banner, we will want to create a message that is stored on a local file like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># figlet "My Message Here" &gt; /path/to/banner.txt</strong></span>
</pre></div><p>Having done this, simply return to the following file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/ssh/sshd_config</strong></span>
</pre></div><p>Now find where you previously uncommented this line:</p><div class="informalexample"><pre class="programlisting">Banner /etc/issue.net</pre></div><p>Replace the<a id="id292" class="indexterm"/> target path with the path to your new banner file created with <code class="literal">FIGlet</code>:</p><div class="informalexample"><pre class="programlisting">Banner /path/to/banner.txt</pre></div><p>To finish, save and close the file, and then restart the SSH service like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl restart sshd</strong></span>
</pre></div><p>You could say that was it, but if you wish to provide an additional post-login message, then this can be achieved by editing the following file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/motd</strong></span>
</pre></div><p>Again, simply add the desired message before saving and closing the file in the usual way. After you have completed these steps, the next time a user completes SSH authentication they will not only be greeted by a server message, but they will also be welcomed by a secondary message, thereby giving you plenty of opportunities to provide system users with suitable instruction and reports where required.</p><p>Remember, login banners can be useful for two main reasons. They not only provide a small message to users before accessing the system, but also serve to warn against unauthorized access while delivering important information to system administrators without their needing to request it.</p></div>
<div class="section" title="Tuning SSH"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Tuning SSH</h1></div></div></div><p>SSH is the <a id="id293" class="indexterm"/>definitive way of communicating with your system. It is a vital service to the lifeblood of your system and it maintains a single, system-wide configuration file that enables the system administrator to modify the operation of the daemon.</p><p>SSH access is generally given using the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ssh username@ipaddress</strong></span>
</pre></div><p>However, if things are particularly slow, the first step in troubleshooting your system is to use the alternative debug mode like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ssh username@ipaddress -vvv</strong></span>
</pre></div><p>So with this in mind, let's take a closer look at this file to assist you in the process of troubleshooting the <code class="literal">sshd</code> daemon as a whole.</p><p>We will <a id="id294" class="indexterm"/>begin by opening the following file in our favorite text editor:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/ssh/sshd_config</strong></span>
</pre></div><p>Seen as a good practice when dealing with dictionary attacks, scanners, or bots, you can change the SSH port by simply replacing the value <code class="literal">#Port 22</code> with something completely different, such as <code class="literal">Port 2222</code>.</p><p>You can also restrict the root login (this is always recommended) by updating the following value to read as follows:</p><div class="informalexample"><pre class="programlisting">PermitRootLogin no</pre></div><p>To disable tunneled clear passwords, you should uncomment the following line:</p><div class="informalexample"><pre class="programlisting">PermitEmptyPasswords no</pre></div><p>SSH logs can be difficult at times, so before we end this brief review of SSH, if it is felt that the system is going through a stage difficult to diagnose, it is often a good idea to simply uncomment and update the logging parameters like this:</p><div class="informalexample"><pre class="programlisting">#LogLevel INFO</pre></div><p>Modify this to read:</p><div class="informalexample"><pre class="programlisting">LogLevel VERBOSE</pre></div><p>Otherwise, if necessary, higher levels of logging can be achieved with:</p><div class="informalexample"><pre class="programlisting">LogLevel DEBUG</pre></div><p>Now, the final modification may not prevent an attack, but by requiring SSH to look up, the remote hostname through forward and reverse DNS will generate the appropriate warnings in the system log files. To do this, simply find the following line:</p><div class="informalexample"><pre class="programlisting">#UseDNS yes</pre></div><p>Update this line to read:</p><div class="informalexample"><pre class="programlisting">UseDNS yes</pre></div><p>However, if SSH is still acting rather sluggish, then ensuring that SSH does not require a reverse DNS lookup can improve the situation immensely. To do this, simply change the preceding line to read:</p><div class="informalexample"><pre class="programlisting">UseDNS no</pre></div><p>Moreover, it is also possible that a difficulty may arise from the use of <code class="literal">GSSAPI</code> authentication. This is not common as it is a feature of SSH that is called upon when a <code class="literal">GSSAPI</code> server is required to validate the relevant user credentials. To avoid this, you should add or edit the following line to read:</p><div class="informalexample"><pre class="programlisting">GSSAPIAuthentication no</pre></div><p>Further to this, you<a id="id295" class="indexterm"/> may also want to consider the subject of timeouts. This common problem can be managed by configuring the correct <code class="literal">ServerAliveInterval</code>, <code class="literal">ServerAliveCountMax</code>, and <code class="literal">TCPKeepAlive</code> values. I have made a simple recommendation here, but you should remember to ensure that these values are appropriate to your needs.</p><p>For example, the following rules imply that a packet will be issued every 60 seconds:</p><div class="informalexample"><pre class="programlisting">ServerAliveInterval 15
ServerAliveCountMax 3
TCPKeepAlive yes</pre></div><p>Adjusting the following values can serve to provide a more sustainable connection:</p><div class="informalexample"><pre class="programlisting">ClientAliveInterval 30
ClientAliveCountMax 5</pre></div><p>Finally, to make the SSH service just a little bit more secure, scroll down to the bottom of the main configuration file and add the following line in order to maintain a list of usernames that will be allowed to undertake the SSH authentication process:</p><div class="informalexample"><pre class="programlisting">AllowUsers &lt;username1&gt; &lt;username2&gt;</pre></div><p>Alternatively, instead of enabling access on a per-user basis, this process of managing identities can be simplified on a per-group basis like this:</p><div class="informalexample"><pre class="programlisting">AllowGroup &lt;groupname&gt;</pre></div><p>Your job is nearly done, but having said all that, and depending on your reasons for troubleshooting the SSH daemon, you must remember to ensure that, when your work is finished, the SSH service must be secured against the possibility of an attack. So, always keep in mind that a successful troubleshooting session will not only fix the problem, it will also serve to ensure the continuation of a safe and secure server.</p><p>For example, for those of you who are not using <code class="literal">SELinux</code>, <code class="literal">fail2ban</code>, or other such security measures, you can always review the login records at any time by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /var/log/secure | grep 'sshd'</strong></span>
</pre></div><p>The output of which will look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>May  3 13:57:24 centos7 sshd[2479]: pam_unix(sshd:session): session closed for user root</strong></span>
<span class="strong"><strong>May  3 13:57:28 centos7 sshd[3313]: Accepted password for root from 192.168.1.17 port 51093 ssh2</strong></span>
<span class="strong"><strong>May  3 13:57:28 centos7 sshd[3313]: pam_unix(sshd:session): session opened for user root by (uid=0)</strong></span>
</pre></div><p>And, should <a id="id296" class="indexterm"/>you wish to view a list of failed attempts, you could try the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /var/log/secure | grep 'sshd.*Failed'</strong></span>
</pre></div><p>Accepted login attempts can be viewed with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cat /var/log/secure | grep 'sshd.*Accepted'</strong></span>
</pre></div></div>
<div class="section" title="Intrusion detection with Tripwire"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Intrusion detection with Tripwire</h1></div></div></div><p>Tripwire<a id="id297" class="indexterm"/> is a <a id="id298" class="indexterm"/>
<span class="strong"><strong>host-based intrusion detection system</strong></span> (<span class="strong"><strong>HIDS</strong></span>). It works by collecting configuration <a id="id299" class="indexterm"/>and filesystem details and uses this information to provide a reference point between the previous state of a system and its current state, a process that is achieved by monitoring which files or directories were added or modified recently, who changed them, what changes were made, and when the changes took place.</p><p>As discussed in a previous chapter, you will need access to the EPEL repository in order to get Tripwire. When you are ready, it can be installed like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install tripwire</strong></span>
</pre></div><p>To begin <a id="id300" class="indexterm"/>using Tripwire, you will need to create the appropriate local and site keys with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tripwire-setup-keyfiles</strong></span>
</pre></div><p>When prompted, add a passphrase for both the site and local key file. Tripwire will advise you to use a combination of uppercase and lowercase letters, digits, and punctuation marks and, when complete, you will be asked to sign the configuration file with the previously created site passphrase.</p><p>Once this process is complete, you have the chance to customize Tripwire by making changes to the following file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/tripwire/twpol.txt</strong></span>
</pre></div><p>Before you begin, it is advisable to read through <code class="literal">twpol.txt</code> as many of the default directories used will not necessarily be available to your system. These extra lines will not cause you any specific problems, but they should be commented out if you want to avoid meaningless error messages.</p><p>You can achieve this by commenting the following lines:</p><div class="informalexample"><pre class="programlisting">### Filename: /root/.Xauthority
### No such file or directory
### Continuing...</pre></div><p>Further to <a id="id301" class="indexterm"/>this, you should also spend some time <a id="id302" class="indexterm"/>reviewing the following file in order to customize Tripwire for a suitable purpose:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/tripwire/twcfg.txt</strong></span>
</pre></div><p>So, having made the relevant changes, you should now update the Tripwire policy file in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tripwire --update-policy --secure-mode low /etc/tripwire/twpol.txt</strong></span>
</pre></div><p>Tripwire will now step through various onscreen phases to reference your changes; when it has finished, you should now be able to initialize the Tripwire database like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tripwire --init</strong></span>
</pre></div><p>Tripwire will now begin to scan the system, but this may take some time depending on the overall size of the system in question:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Wrote database file: /var/lib/tripwire/server1.server1.com.twd</strong></span>
<span class="strong"><strong>The database was successfully generated.</strong></span>
</pre></div><p>When complete, you can run a Tripwire report with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tripwire --check --interactive</strong></span>
</pre></div><p>By running the preceding command, Tripwire will automatically open the report in <code class="literal">vi</code> and, from this point onwards, all subsequent reports will be made in the compare mode. So having done this, why not take this opportunity to create a few simple text files or directories in your home folder and rerun the report so that the findings of Tripwire become much more obvious.</p><p>Remember, if any changes to the filesystem are considered to be the result of a system intrusion, the administrator will be notified and they will need to restore the system with files and directories that can be trusted. For this reason, any system changes must be validated through Tripwire.</p><p>You can validate your current policy file by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tripwire --check</strong></span>
</pre></div><p>You can send <a id="id303" class="indexterm"/>Tripwire reports via e-mail with utilities such as <code class="literal">mutt</code> in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install mutt</strong></span>
<span class="strong"><strong># tripwire --check | mutt -s "Tripwire report" email@domain.com</strong></span>
</pre></div><p>Or by modifying the later part of the daily <code class="literal">cron</code> job:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># nano /etc/cron.daily/tripwire-check</strong></span>
</pre></div><p>By including the following line:</p><div class="informalexample"><pre class="programlisting">test -f /etc/tripwire/tw.cfg &amp;&amp;  /usr/sbin/tripwire --check | /bin/mail -s "Tripwire File Integrity Report" emailaddress@domain.com</pre></div><p>Of course, in the <a id="id304" class="indexterm"/>space of a few short paragraphs, we have now managed to take a small but significant step towards building a comprehensive host-based intrusion system. It is not troubleshooting in the purest form of the word, but it will help you to diagnose an issue at some point in the future. Moreover, between now and then, you can read more about <code class="literal">Tripwire</code> by reviewing the manual like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># man tripwire</strong></span>
</pre></div><p>However, and just before we finish, at this stage, I would suggest that you secure both the <code class="literal">twpol.txt</code> and <code class="literal">twcfg.txt</code> files. In the full knowledge that Tripwire's policy file is far more extensible than what has been suggested, in order to assist your ongoing learning I have provided a link to the project home page at the end of this chapter.</p></div>
<div class="section" title="Firewalld &#x2013; zone, service, and port management"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Firewalld – zone, service, and port management</h1></div></div></div><p>The <a id="id305" class="indexterm"/>purpose of Firewalld is to replace the need for iptables and improve the management of security by enabling configuration changes without stopping the current connections. Firewalld runs as a daemon that allows for rules to be added and changed instantly and it uses network zones to define a level of trust for any and all associated network connections. For the troubleshooter, this does provide a range of flexible options but, more importantly, it is necessary to understand that, while a connection can only be a part of a single zone, a zone can be used across many network connections.</p><p>To know whether<a id="id306" class="indexterm"/> Firewalld is currently running, you can type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --state</strong></span>
</pre></div><p>To list the<a id="id307" class="indexterm"/> predefined zones, you can use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --get-zones</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>These zones can be defined as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">drop</code>: In <a id="id308" class="indexterm"/>this zone, incoming network packets are dropped (with no reply), and only outgoing network connections are possible</li><li class="listitem" style="list-style-type: disc"><code class="literal">block</code>: In this<a id="id309" class="indexterm"/> zone, only network connections initiated within this system are possible as all incoming network connections are rejected with an <code class="literal">icmp-host-prohibited</code> message</li><li class="listitem" style="list-style-type: disc"><code class="literal">public</code>: This <a id="id310" class="indexterm"/>zone is used in areas where you do not trust the other computers; only selected incoming connections are accepted</li><li class="listitem" style="list-style-type: disc"><code class="literal">external</code>: This <a id="id311" class="indexterm"/>zone is used on external networks with masquerading enabled and only selected incoming connections are accepted</li><li class="listitem" style="list-style-type: disc"><code class="literal">dmz</code>: This <a id="id312" class="indexterm"/>is the demilitarized zone</li><li class="listitem" style="list-style-type: disc"><code class="literal">work/home/internal</code>: This <a id="id313" class="indexterm"/>zone is used in environments where you mostly trust the other computers on the network; again, only selected incoming connections are accepted</li><li class="listitem" style="list-style-type: disc"><code class="literal">trusted</code>: In <a id="id314" class="indexterm"/>this zone, all network connections are accepted</li></ul></div></div></div><p>However, by extending this command, we can also discover what the default zone is by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --get-default-zone</strong></span>
</pre></div><p>The value of this can be updated with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --set-default-zone=&lt;new-zone-name&gt;</strong></span>
</pre></div><p>Taking this one step further, we can extend this command to provide not only a list of zones, but also network interface information like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --get-active-zones</strong></span>
</pre></div><p>In this situation, network interfaces can be managed with the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --add-interface=&lt;device-name&gt;</strong></span>
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --change-interface=&lt;device-name&gt;</strong></span>
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --remove-interface=&lt;device-name&gt;</strong></span>
</pre></div><p>We can change the assignment of network interfaces and bind them to different zones using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --permanent --zone=&lt;zone-name&gt; --change-interface=&lt;device-name&gt;</strong></span>
</pre></div><p>Finally, you can<a id="id315" class="indexterm"/> obtain all the relevant information about any particular zone by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --list-all</strong></span>
</pre></div><p>You can list all supported services with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --get-services</strong></span>
</pre></div><p>Then you can manage additional services within a zone using the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --add-service=&lt;service-name&gt;</strong></span>
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --remove-service=&lt;service-name&gt;</strong></span>
</pre></div><p>Otherwise, list all ports open in any particular zone with this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --list-ports</strong></span>
</pre></div><p>You can manage the addition or removal of TCP/UDP ports like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --add-port=&lt;port-number/protocol&gt;</strong></span>
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --remove-port=&lt;port-number/protocol&gt;</strong></span>
</pre></div><p>Finally, and without trying to over-complicate the array of commands available, you can configure masquerading in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --add-masquerade</strong></span>
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --remove-masquerade</strong></span>
</pre></div><p>Then query it like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --query-masquerade</strong></span>
</pre></div><p>You can manage port forwarding with these commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --add-forward-port=&lt;port-number&gt;</strong></span>
<span class="strong"><strong># firewall-cmd --zone=&lt;zone-name&gt; --remove-forward-port=&lt;port-number&gt;</strong></span>
</pre></div><p>For example, in a typical configuration, if you want to send all packets intended for port 22 to port 2222, you can use the following syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># firewall-cmd --zone=external --add-forward-port=22:proto=tcp:toport=2222</strong></span>
</pre></div><p>So, as you can see, Firewalld is <a id="id316" class="indexterm"/>comprehensive, but in the full knowledge that there are many more commands that can be discussed, the intention is to show that a troubleshooter has the ability to dynamically manage firewall architecture without ever needing to stop or restart the firewall service. This is something that cannot be achieved with iptables; in many respects, based on the associated learning curve and the plethora of new commands, it is a defining feature that may prove to be a great success.</p><p>Further information about Firewalld can be found at the end of this chapter.</p></div>
<div class="section" title="Removing Firewalld and returning to iptables"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Removing Firewalld and returning to iptables</h1></div></div></div><p>Firewalld may not be <a id="id317" class="indexterm"/>to everyone's liking and you may prefer iptables. So, on <a id="id318" class="indexterm"/>a final note, if you ever find yourself in a situation where you do not want to use Firewalld, you can return to iptables easily.</p><p>To begin with, you should disable Firewalld like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl disable firewalld</strong></span>
<span class="strong"><strong># systemctl stop firewalld</strong></span>
</pre></div><p>You should then install and configure iptables by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install iptables-services</strong></span>
<span class="strong"><strong># touch /etc/sysconfig/iptables</strong></span>
<span class="strong"><strong># touch /etc/sysconfig/ip6tables</strong></span>
</pre></div><p>Now, start the <code class="literal">iptables</code> service with the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># systemctl start iptables</strong></span>
<span class="strong"><strong># systemctl start ip6tables</strong></span>
<span class="strong"><strong># systemctl enable iptables</strong></span>
<span class="strong"><strong># systemctl enable ip6tables</strong></span>
</pre></div><p>From this point onwards, you now have <code class="literal">iptables</code> as your firewall service of choice. However, just before you go, it is probably a good idea to reboot your server in order for the kernel to account for the new configuration.</p><p>To do this, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># reboot</strong></span>
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Summary</h1></div></div></div><p>From the more passive positioning of SSH banners and notices to the rigid approach involved in building a host-based intrusion detection system, in this chapter we covered a number of approaches intended to provide a way forward in troubleshooting security. We have not only talked about the release of Firewalld, and how it can be used to dynamically re-engineer the entire firewall environment without an interruption in service, but we have also discussed OpenSSH and shown you the way back to using iptables.</p><p>I believe everyone would agree that security is a big subject and its methods and approaches are found throughout the pages in this book. However, having toured this chapter, I hope that this small stepping-stone will serve you well in the future before we take the next step with a discussion on troubleshooting database services.</p></div>
<div class="section" title="References"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec73"/>References</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Red Hat customer portal: <a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/</a></li><li class="listitem" style="list-style-type: disc">The Fedora project – the SELinux troubleshooting tool (setroubleshoot): <a class="ulink" href="https://fedorahosted.org/setroubleshoot/wiki/SETroubleShoot%20Overview">https://fedorahosted.org/setroubleshoot/wiki/SETroubleShoot%20Overview</a></li><li class="listitem" style="list-style-type: disc">Oracle – configuring and using SELinux: <a class="ulink" href="http://docs.oracle.com/cd/E37670_01/E36387/html/ol_selinux_sec.html">http://docs.oracle.com/cd/E37670_01/E36387/html/ol_selinux_sec.html</a></li><li class="listitem" style="list-style-type: disc">The Fedora project – Docs/Drafts/SELinux/SETroubleShoot/DeveloperFAQ: <a class="ulink" href="http://fedoraproject.org/wiki/Docs/Drafts/SELinux/SETroubleShoot/DeveloperFAQ">http://fedoraproject.org/wiki/Docs/Drafts/SELinux/SETroubleShoot/DeveloperFAQ</a></li><li class="listitem" style="list-style-type: disc">The FIGlet home page: <a class="ulink" href="http://www.figlet.org">http://www.figlet.org</a></li><li class="listitem" style="list-style-type: disc">The Tripwire project home page: <a class="ulink" href="http://sourceforge.net/projects/tripwire/">http://sourceforge.net/projects/tripwire/</a></li><li class="listitem" style="list-style-type: disc">The SSH Wikipedia page: <a class="ulink" href="http://en.wikipedia.org/wiki/Secure_Shell">http://en.wikipedia.org/wiki/Secure_Shell</a></li><li class="listitem" style="list-style-type: disc">The SSH project home page: <a class="ulink" href="http://www.openssh.com">http://www.openssh.com</a></li><li class="listitem" style="list-style-type: disc">The FirewallD Fedora project: <a class="ulink" href="https://fedoraproject.org/wiki/FirewallD">https://fedoraproject.org/wiki/FirewallD</a></li><li class="listitem" style="list-style-type: disc">RHEL – using Firewalls: <a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html</a></li></ul></div></div></body></html>