<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Adding a Magnetic Contact Sensor"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Adding a Magnetic Contact Sensor</h1></div></div></div><p>Now that we have built our port expander hardware, we need to learn how to program it so that our Raspberry Pi can detect the things that we connect to it as part of our home security system. We will begin by connecting switches to our system in the form of magnetic sensors—the most common component used in home security systems to detect intrusions through doors and windows.</p><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learning about reed switches and how they work as door sensors</li><li class="listitem" style="list-style-type: disc">Enabling and setting up the I2C bus on the Raspberry Pi</li><li class="listitem" style="list-style-type: disc">Connecting our sensor to an input on our port expander</li><li class="listitem" style="list-style-type: disc">Learning how to access our I2C port expander from a Bash script</li><li class="listitem" style="list-style-type: disc">Writing a script that will detect the state of our door sensor</li><li class="listitem" style="list-style-type: disc">Looking at other types of contact sensors that can be connected and programmed in the same way</li></ul></div><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Prerequisites</h1></div></div></div><p>You'll need the following parts for the<a id="id135" class="indexterm"/> exercises in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our Raspberry Pi and Port Expander board</li><li class="listitem" style="list-style-type: disc">8 x 10K ohm resistors</li><li class="listitem" style="list-style-type: disc">A magnetic door sensor and magnet</li><li class="listitem" style="list-style-type: disc">A hook-up wire</li><li class="listitem" style="list-style-type: disc">A 4-core alarm wire</li></ul></div></div></div>
<div class="section" title="The working of magnetic contact sensors"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>The working of magnetic contact sensors</h1></div></div></div><p>A <span class="strong"><strong>reed switch</strong></span> is <a id="id136" class="indexterm"/>essentially what makes up our <span class="strong"><strong>magnetic contact sensor</strong></span>. A reed switch comprises two metal <a id="id137" class="indexterm"/>contacts made of magnetic material (called reeds) placed inside a glass envelope. When the contacts touch, the switch is on, and when they spring apart, the switch is off and the circuit is broken. The way to <a id="id138" class="indexterm"/>control these contacts is by means of a <span class="strong"><strong>magnetic field</strong></span> that makes or breaks the circuit when it is near to the switch.</p><p>A normally open (NO) type of reed<a id="id139" class="indexterm"/> switch is normally switched off until a magnet comes close to the switch, which then pulls the contacts together.</p><p>A normally closed (NC) variety<a id="id140" class="indexterm"/> works the other way with the switch being normally on until the magnet comes close to the switch, pulling the two contacts apart.</p><div class="mediaobject"><img src="graphics/B04579_04_01.jpg" alt="The working of magnetic contact sensors"/><div class="caption"><p>A typical type of reed switch</p></div></div><p>You can now see how a magnetic reed switch can be a useful sensor in security applications, and in particular for our home security<a id="id141" class="indexterm"/> system, to detect when <span class="strong"><strong>doors</strong></span> and <span class="strong"><strong>windows</strong></span> are <a id="id142" class="indexterm"/>opened and closed. We simply put a reed switch on the door frame and connect it to our security system, with the magnet placed opposite the switch on the actual door. When the door opens and closes, it makes or breaks the contacts in our reed switch.</p><p>Reed switches and their magnets, which are designed for security systems, usually come enclosed in little plastic housings, making them easy to screw onto the door and frame.</p><div class="mediaobject"><img src="graphics/B04579_04_02.jpg" alt="The working of magnetic contact sensors"/><div class="caption"><p>A door-frame-mounted magnetic sensor containing a reed switch (Type: Cherry MP201801)</p></div></div><p>The magnetic <a id="id143" class="indexterm"/>sensor is mounted on the door frame (obviously, so it can connect to the alarm circuit wires), while the respective magnet will be attached to the door, close enough to the edge such that the sensor contacts connect (or break, depending on the type) when the magnet is directly opposite it.</p><div class="mediaobject"><img src="graphics/B04579_04_03.jpg" alt="The working of magnetic contact sensors"/><div class="caption"><p>A respective door-mounted magnetic actuator (Type: Cherry AS201801)</p></div></div></div>
<div class="section" title="Setting up the I2C port expander"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Setting up the I2C port expander</h1></div></div></div><p>Now that we have built our port expander, we need to get it ready to connect our sensors to. First, we <a id="id144" class="indexterm"/>need to install the tools on the Raspberry Pi to allow us to use the I2C bus and program devices connected to it, including the MCP23017 chip that makes up our port expander.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Don't connect your port expander to the Raspberry Pi until after you've set up the I2C bus on your system.</p></div></div><div class="section" title="Enabling the I2C Bus"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Enabling the I2C Bus</h2></div></div></div><p>It's highly likely that the module for using the I2C bus hasn't been loaded by default. Fortunately, doing<a id="id145" class="indexterm"/> this is fairly straightforward <a id="id146" class="indexterm"/>and can be done using the Raspberry Pi configuration tool. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Launch the Raspberry Pi configuration tool with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo raspi-config</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/B04579_04_04.jpg" alt="Enabling the I2C Bus"/></div></li><li class="listitem">Select option 8: <code class="literal">Advanced Options</code>.<div class="mediaobject"><img src="graphics/B04579_04_05.jpg" alt="Enabling the I2C Bus"/></div></li><li class="listitem">Select <a id="id147" class="indexterm"/>Option <a id="id148" class="indexterm"/>A7: <code class="literal">I2C</code>.<div class="mediaobject"><img src="graphics/B04579_04_06.jpg" alt="Enabling the I2C Bus"/></div></li><li class="listitem">Select <code class="literal">&lt;Yes&gt;</code>.</li><li class="listitem">Reboot your Raspberry Pi for the setting to take effect.</li></ol></div><p>Now that the I2C bus has been enabled, we need to set up the operating system so that the required modules <a id="id149" class="indexterm"/>are loaded each time the system boots. To do<a id="id150" class="indexterm"/> this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Edit the<a id="id151" class="indexterm"/> <span class="strong"><strong>Modules file</strong></span> using the following line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo nano /etc/modules</strong></span>
</pre></div></li><li class="listitem">Add the following lines to the file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>i2c-bcm2708</strong></span>
<span class="strong"><strong>i2c-dev</strong></span>
</pre></div></li><li class="listitem">Save the file and exit Nano.</li></ol></div></div><div class="section" title="Installing the I2C tools package"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Installing the I2C tools package</h2></div></div></div><p>So that we can<a id="id152" class="indexterm"/> easily access the I2C bus using Bash scripts, we need to install the <code class="literal">i2c-tools</code> package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install i2c-tools</strong></span>
</pre></div><p>Once installed, we <a id="id153" class="indexterm"/>should shutdown our system:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo shutdown –h now</strong></span>
</pre></div><p>After activity has stopped, switch off your Raspberry Pi, connect your port expander to the GPIO port, and power it back up so that we can start using it.</p><p>As a quick sanity check, you can see if I2C support has been loaded by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls /dev/i2c-*</strong></span>
</pre></div><p>This should give you a list of at least one bus—for example, <code class="literal">/dev/i2c-1</code>—if the module is loaded. If it's not, you'll probably get the following response:</p><p>
<span class="strong"><strong> ls: cannot access /dev/i2c-*: No such file or directory</strong></span>
</p><p>
<span class="emphasis"><em>In this case, you'll need to check back through the previous steps as something hasn't happened properly.</em></span>
</p></div><div class="section" title="Finding our devices"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Finding our devices</h2></div></div></div><p>The <code class="literal">i2c-tools</code> package installs several different tools to help us use our port expander attached to<a id="id154" class="indexterm"/> the bus. The <code class="literal">i2cdetect</code> tool allows us to find I2C buses and devices attached to the busses.</p><p>To get a list of I2C busses on our system, type the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo i2cdetect -l</strong></span>
</pre></div><p>You should get the following response:</p><p>
<span class="strong"><strong>pi@raspberrypi ~ $ sudo i2cdetect -l</strong></span>
</p><p>
<span class="strong"><strong>i2c-1  i2c       20804000.i2c              I2C adapter</strong></span>
</p><p>The preceding output shows that we have one I2C bus, and this will be the one connected to our GPIO. <span class="emphasis"><em>Note that earlier models of the Raspberry Pi may return the device ID as being i2c-0</em></span>.</p><p>We can now <a id="id155" class="indexterm"/>use the tool to scan for all of the devices attached to our bus. We do this by specifying the bus ID, as in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo i2cdetect 1</strong></span>
</pre></div><p>With nothing attached to the I2C bus (that is, without our port expander attached) we'd expect to see the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pi@raspberrypi ~ $ sudo i2cdetect 1</strong></span>
<span class="strong"><strong>WARNING! This program can confuse your I2C bus, cause data loss and worse!</strong></span>
<span class="strong"><strong>I will probe file /dev/i2c-1.</strong></span>
<span class="strong"><strong>I will probe address range 0x03-0x77.</strong></span>
<span class="strong"><strong>Continue? [Y/n] Y</strong></span>
<span class="strong"><strong>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</strong></span>
<span class="strong"><strong>00:          -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>70: -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>pi@raspberrypi ~ $</strong></span>
</pre></div><p>
<span class="emphasis"><em>Nothing found on the I2C bus</em></span>
</p><p>With our port expander attached, we should see the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pi@raspberrypi ~ $ i2cdetect 1</strong></span>
<span class="strong"><strong>WARNING! This program can confuse your I2C bus, cause data loss and worse!</strong></span>
<span class="strong"><strong>I will probe file /dev/i2c-1.</strong></span>
<span class="strong"><strong>I will probe address range 0x03-0x77.</strong></span>
<span class="strong"><strong>Continue? [Y/n] Y</strong></span>
<span class="strong"><strong>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</strong></span>
<span class="strong"><strong>00:          -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>20: 20 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>70: -- -- -- -- -- -- -- --</strong></span>
<span class="strong"><strong>pi@raspberrypi ~ $</strong></span>
</pre></div><p>
<span class="emphasis"><em>Our I2C port expander slave device can be found at the address, 0x20 (32 decimal).</em></span>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>The preceding address is the location of our MCP23017 chip connected to the I2C bus. If you don't see this, then there's probably a wiring issue and you'll need to go back and check.</p></div></div><p>You'll recall that we can <a id="id156" class="indexterm"/>add up to 8 of these devices to the I2C bus by setting the A0-A2 pins to a unique address. If A0 is set to <code class="literal">high</code>, then the address of the device will be shown as 0x21 (33 decimal)—and up to 0x27 (39 decimal), if all pins are high.</p></div><div class="section" title="Setting up the port expander"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Setting up the port expander</h2></div></div></div><p>As discussed<a id="id157" class="indexterm"/> in the previous chapter, we can have 2 x 8-bit busses on our port expander, with each pin being defined as an input or output. On the expander board we built, we called them I/O BUS A and I/O BUS B.</p><p>To configure the MCP23017 chip on the I2C bus, we can send it the appropriate commands using the<a id="id158" class="indexterm"/> <span class="strong"><strong>i2cset</strong></span> tool we installed earlier.</p><p>On our home security system, we are going to assign all of the pins on BUS A as inputs for connecting our sensors to it. To do this, we use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo i2cset –y 1 0x20 0x00 0xFF</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>What does this command mean?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">-y: This runs the command without user interaction.</li><li class="listitem" style="list-style-type: disc">1: This is the ID of the bus (for example, <code class="literal">i2c-1</code>).</li><li class="listitem" style="list-style-type: disc">0x20: This is the address of the chip.</li><li class="listitem" style="list-style-type: disc">0x00: This is the data register on the chip (in this case, the PORT A pin assignment).</li><li class="listitem" style="list-style-type: disc">0xFF: This is the Value loaded into the data register (in this case, all pins as inputs—binary %11111111).</li></ul></div></div></div><p>You can check that the data register has been set correctly by reading it using the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo i2cget –y 1 0x20 0x00</strong></span>
</pre></div><p>This should return a <a id="id159" class="indexterm"/>value of <code class="literal">0xFF</code>, which is the value we set earlier.</p></div></div>
<div class="section" title="Connecting our magnetic contact sensor"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Connecting our magnetic contact sensor</h1></div></div></div><p>Now that we've got our port expander working with the Raspberry Pi, we can start connecting things to it and create the scripts that will monitor the sensors on the input pins.</p><p>Let's go back to <a id="id160" class="indexterm"/>our port expander stripboard that was built in the previous chapter and connect our magnetic sensor. But first, we need to ensure that all of our inputs are pulled low by default using 10Kohm resistors. This prevents them from being in a <span class="emphasis"><em>floating</em></span> state and giving us spurious data when we read the port's data.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>In the following diagram, I've connected the pull-down resistors externally, but you may want to include them directly on the stripboard. Toward the end of this book, we'll have a new board layout that brings everything that we've been prototyping so far together in a single solution.</p></div></div><p>To check the port's input value, we use the <code class="literal">i2cget</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo i2cget –y 1 0x20 0x12</strong></span>
</pre></div><p>This should return <code class="literal">0x00</code>, which means all inputs are off (binary %00000000).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>What does this command mean?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">-y: This runs the command without user interaction.</li><li class="listitem" style="list-style-type: disc">1: This is the ID of the bus (for example i2c-1).</li><li class="listitem" style="list-style-type: disc">0x20: This is the address of the chip.</li><li class="listitem" style="list-style-type: disc">0x12: This is the data register on the chip (in this case, the PORT A read value).</li></ul></div></div></div><p>Now let's connect one side of our magnetic sensor's reed switch to data pin 0 of BUS A (which we'll call GPA0 for reference), and the other side to our +3.3V line. By default, the switch is normally open (NO), which means that the input is still pulled low by the resistor.</p><p>But when you move the accompanying magnet near to the sensor switch (for example, if the door is closed), the switch will close, pulling the input high to the +3.3V line. If you read the port's input value now, by running the same command, you should see that it returns 0x01, indicating<a id="id161" class="indexterm"/> that the first bit is high (binary %00000001).</p><div class="mediaobject"><img src="graphics/B04579_04_07.jpg" alt="Connecting our magnetic contact sensor"/></div></div>
<div class="section" title="Monitoring the sensor"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Monitoring the sensor</h1></div></div></div><p>Now that we have everything in place and our magnetic sensor is detecting whether the door is closed, we can monitor this sensor with a simple Bash script that uses the I2C tool commands that<a id="id162" class="indexterm"/> we installed earlier.</p><p>The code listing for <code class="literal">poll-magnetic-switch.sh </code>is as follows:</p><div class="informalexample"><pre class="programlisting">#!/bin/bash
sudo i2cset –y 1 0x20 0x00 0xFF

# loop forever
while true
do
  # read the sensor state
  SWITCH=$(sudo i2cget –y 1 0x20 0x12)

  if [ $SWITCH == "0x01" ]
  then
    #contact closed so wait for a second
    echo "The door is closed!"
    sleep 1
  else
    #contact was opened
    echo "The door is open!"
  fi
done</pre></div><p>When you run the script and then push the button, you should see "<span class="strong"><strong>The door is open!</strong></span>" scrolling up the<a id="id163" class="indexterm"/> console screen until you stop pressing it.</p><p>By combining this with our elaborate light switch project in chapter 2, we can switch on the LED connected to GPIO17 when the door is opened:</p><div class="informalexample"><pre class="programlisting">#!/bin/bash

#set up the LED GPIO pin
sudo echo 17 &gt; /sys/class/gpio/export
sudo echo out &gt; /sys/class/gpio/gpio17/direction

#set up port expander 
sudo i2cset –y 1 0x20 0x00 0xFF

# loop forever
while true
do
  # read the sensor state
  SWITCH=$(sudo i2cget –y 1 0x20 0x12)

  if [ $SWITCH == "0x01" ]
  then
    #switch not pushed so turn off LED pin
    sudo echo 0 &gt; /sys/class/gpio/gpio17/value
  else
    #switch was pushed so turn on LED pin
    sudo echo 1 &gt; /sys/class/gpio/gpio17/value
  fi
  #short delay
  sleep 0.5
done</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Later, as we add more sensors to different input pins, we will need to be able to detect which one has been triggered. We'll look at writing a Bash function later in the book, which will parse the returned hex value from the i2cget command, and tell us exactly <a id="id164" class="indexterm"/>which of the 8 inputs is high.</p></div></div></div>
<div class="section" title="Anti-tamper circuits"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Anti-tamper circuits</h1></div></div></div><p>If you take a closer look at our system, you might realize that depending on whether you are detecting <a id="id165" class="indexterm"/>normally open or normally closed sensor switches, it is possible to tamper with the sensor channel by simply cutting the wire. So, in the case of a normally open switch, it wouldn't activate the monitoring system if the wires were cut, as it would always appear to be open, even if the switch was closed.</p><p>To mitigate this, most alarm systems feature a 4-core wiring system to connect the sensor devices to the main control board—two cores are used to connect the sensor and two are used to create<a id="id166" class="indexterm"/> an <span class="strong"><strong>anti-tamper loop</strong></span>, which then itself forms a sensor input for monitoring.</p><div class="mediaobject"><img src="graphics/B04579_04_10.jpg" alt="Anti-tamper circuits"/><div class="caption"><p>4-core alarm cable</p></div></div><p>Take a look<a id="id167" class="indexterm"/> at the following circuit so that you see what I mean:</p><div class="mediaobject"><img src="graphics/B04579_04_08.jpg" alt="Anti-tamper circuits"/></div><p>In this circuit, we have two sensors: one for monitoring a window and one for monitoring a door. These are connected to the I/O BUS A inputs, 0 and 1 (or GPA0 and GPA1, as we like to call them). As before, they are pulled down to 0V by resistors but, when switches are closed, the positive voltage rail takes the inputs high.</p><p>However, we've <a id="id168" class="indexterm"/>also added an anti-tamper loop throughout the whole system, which is connected to GPA7 for monitoring. The loop is daisy-chained through each of the cables connecting the sensors to the controller board. All the time the loop is intact, the input GPA7 is kept high, but if the cable is cut anywhere, the current will stop flowing through it and the resistor, R3, will pull the input low. This will then be detected by the monitoring script.</p><p>Many security sensor products provide a facility to terminate anti-tamper loop wires within them.</p><p>So, in our home security system, we're going to assign GPA7 as our anti-tamper loop.</p></div>
<div class="section" title="Getting into the zone"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Getting into the zone</h1></div></div></div><p>It may have occurred to<a id="id169" class="indexterm"/> you by now that even a modest-sized property could require plenty of door and window sensors; thus, if we used one input for each sensor, we'd soon run out unless we put more and more port expanders onto the system. The same is true for commercially available security systems.</p><p>So, the way this is dealt <a id="id170" class="indexterm"/>with is by creating <span class="strong"><strong>zones</strong></span>, with each zone containing a group of sensors. A bedroom, for example, may be defined as one zone with a window sensor, a door sensor, and movement detector forming that zone. In this scenario, each sensor is connected to the next in a series (or daisy-chained); if one of them triggers, it will alert the monitoring system that there was a trigger in the zone. Obviously, though, it may not necessarily be the actual detector, which in most applications isn't really an issue.</p><p>However, this can introduce some challenges when we're considering mixing normally open and normally closed type sensors within a zone, but this is something we will explore later on in this book.</p><p>The other sensors you can use are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hall Effect Sensor</strong></span>: Hall-effect sensors are simple electronic chips that are used to detect magnetic fields placed near them. They are not dissimilar to the reed switch we've<a id="id171" class="indexterm"/> been using; however, because they are electronic devices, they are able to measure the degree of proximity in<a id="id172" class="indexterm"/> relation to the magnet (or the strength of magnetism), rather than being just on or off, as is the case with the reed switch. Also, because they are solid-state, they could be seen as being more reliable than mechanical switches.<div class="mediaobject"><img src="graphics/B04579_04_11.jpg" alt="Getting into the zone"/><div class="caption"><p>A low-cost hall effect sensor—Allegro Microsystems A1302KUA-T</p></div></div></li><li class="listitem" style="list-style-type: disc">Pressure Mat Sensors: Pressure<a id="id173" class="indexterm"/> mats are used to detect a person standing or walking on them, and can be placed under a floor mat to hide them from sight. They can even be used in a chair to detect people sitting on it. Essentially, they are switches, just like the reed switch, except that they are activated by the pressure of walking on them, and so, can be wired and used in <a id="id174" class="indexterm"/>exactly the same way as for our magnetic<a id="id175" class="indexterm"/> sensor circuits.<div class="mediaobject"><img src="graphics/B04579_04_09.jpg" alt="Getting into the zone"/><div class="caption"><p>A pressure switch can be used under a front-door mat</p></div></div></li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, we got our I2C-based port expander configured and working, and we experimented with it by connecting a magnetic sensor—one of the most commonly used sensors in security systems. We've also learned how to interact with I2C devices using Bash scripts, and how to read and write data to and from these devices.</p><p>In addition, we should now be beginning to understand the various elements and building blocks of a security system, including anti-tamper loops and zones. These are concepts that will prepare us for later on in the book, when we start to piece all of this together and build our final, all-encompassing system.</p><p>In the next chapter, we will look at passive infra-red motion detectors, how they work, and how we can connect the wired and wireless types to our home security system. We'll also learn how to create log files based on events using Bash scripts so that we can maintain a history of detector states as they change.</p></div></body></html>