- en: Creating Interactive Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](f439f212-0f5f-4c9d-abdb-9f9b8c199a78.xhtml), *The What and Why
    of Scripting with Bash*, we learned how to create a script and use some of its
    basic elements. These included optional parameters that we can pass through to
    the script when it is executed. In this chapter, we will extend this by using
    the shell's built-in `read` command to allow for interactive scripts. Interactive
    scripts are scripts that prompt for information during the script's execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `echo` with options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic script using `read`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing read scripts with `read` prompts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the number of entered characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the visibility of the entered text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read options values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to be standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing learning with simple scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: Using echo with options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, in this book we have been able to see that the `echo` command is very
    useful and is going to be used in many of our scripts, if not all of them. When
    running the `echo` command, the built-in command will be used unless we state
    the full path to the file. We can test this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To gain help on the built-in command, we can use man bash and search for `echo`;
    however, the `echo` command is identical to the internal command, so we recommend
    that you use man echo in most cases in order to display the command options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic use of `echo` that we have seen so far will produce a text output
    and a new line. This is often the desired response, so we don''t need to be concerned
    that the next prompt will append to the end of the echoed text. The new line separates
    the script output from the next shell prompt. If we do not supply any text string
    to print, `echo` will print only the new line to `STDOUT`. We can test this with
    the following command, directly from the command line. We do not need to run `echo`
    or, in fact, any other command from a script. To run `echo` from the command line,
    we simply enter the command as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show a clear new line between the command we issued and the
    subsequent prompt. We can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efb1c784-4e60-46cd-81ad-bbd50cace4c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to suppress the new line, which is especially useful if we are to
    prompt users, we can do this in the following two ways, with the help of `echo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result will be to suppress the line feed. In the initial example, the `-n`
    option is used to suppress the line feed. The second example uses the more generic
    `-e` option, which allows escape sequences to be added to the text string. To
    continue on the same line, we use `\c` as the escape sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not look great as the final part of the script or when it is run
    from the command line, as the command prompt will follow. This is illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da374c15-d11a-42ff-bc0c-f4c957d812a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic script using read
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When used as part of a script that prompts for user input, the suppression
    of the line feed is exactly what we want. We will begin by copying the existing
    `hello2.sh` script to `hello3.sh` and build an interactive script. Initially,
    we will use `echo` as the prompt mechanism, but, as we gradually enhance the script,
    we will generate the prompt directly from the shell built-in `read` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `$HOME/bin/hello3.sh` script so that it reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we execute the script, we will be greeted and prompted with whatever is typed.
    This is echoed using the `$REPLY` variable in the echo statement. As we have not
    yet supplied a variable name to the read built-in command, the default `$REPLY`
    variable is used. The script execution and output are shown in the following screenshot.
    Take some time to practice the script on your own system.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f745d37-3805-4fc8-ba30-a6672c7a4e87.png)'
  prefs: []
  type: TYPE_IMG
- en: This little step has taken us a long way and there are many uses for a script
    like this; we have all used installation scripts that prompt for options and directories
    as we run through the install. We accept that it is still quite trivial, but,
    as we delve into the chapter, we will get closer to some more useful scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Script comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should always introduce commenting scripts early in the piece. A script
    comment is prefaced with a `#` symbol. Anything after the # symbol is a comment
    and is not evaluated by the script. The shebang, `#!/bin/bash`, is primarily a
    comment and, as such, is not evaluated by the shell. The shell running the script
    reads the whole shebang, so it knows which command interpreter to hand the script
    over to. A comment may be at the start of a line or partway into the line. Shell
    scripting does not have the notion of multi-line comments.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are not already familiar with comments, then please note that they are
    added to the script to describe who wrote the script, when it was written and
    last updated, and what the script does. They are the metadata of the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of comments in scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is good practice to comment, and add comments that explain what the code
    is doing and why. This will help you and your colleagues who need to edit the
    script at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing scripts with read prompts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can use the built-in read to populate a variable. So far,
    we have used echo to produce the prompt, but this can be passed to read itself
    using the `-p` option. The `read` command will surpass the additional linefeed,
    so we reduce both the line count and the complexity to some degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this at the command line itself. Try typing the following command
    to see `read` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use the `read` command with the `-p` option. The argument that follows the
    option is the text that appears in the prompt. Normally, we would make sure that
    there is a trailing space at the end of the text to ensure that we can clearly
    see what we type. The last argument supplied here is the variable we want to populate;
    we simply call it name. Variables are case-sensitive too. Even if we do not supply
    the last argument, we can still store the user's response, but this time in the
    `REPLY` variable.
  prefs: []
  type: TYPE_NORMAL
- en: When we return the value of a variable, we use `$`, but not when we write it.
    In simple terms, when reading a variable we refer to `$VAR` and when setting a
    variable we refer to `VAR=value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read` command with syntax using the `-p` option is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can edit the script so that it appears similar to the following extract
    from `hello3.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `read` prompt cannot evaluate commands within the message string, such as
    those we used before.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number of entered characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have not needed this functionality in the scripts we have used so far, but
    we may need to ask users to hit any key to continue. At the moment, we have set
    it up in such a way that the variable is not populated until we hit the *Enter*
    key. Users have to hit *Enter* to continue. If we use the `-n` option followed
    by an integer, we can specify the number of characters to accept before continuing;
    we will set `1` in this case. Take a look at the following code extract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now the script will pause after displaying the name until we press any key;
    we can literally press any key before continuing, as we accept just 1 key stroke,
    whereas earlier we were required to leave the default behavior in place, as we
    could not know how long an entered name would be. We have to wait for the user
    to hit *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: We add an additional echo here to ensure that a new line is issued before the
    script ends. This ensures that the shell prompt starts on a new line.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the visibility of the entered text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though we have limited the input to a single character, we do get to see
    the text on the screen. In the same way, if we type the name, we get to see the
    entered text before we hit *Enter*. In this case, it is just untidy, but if we
    are entering sensitive data, such as a PIN or a password, we should hide the text.
    We can use the silent option, or `-s`, to achieve this. A simple edit in the script
    will set this in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we use a key to continue, it will not be displayed on the screen.
    We can see the behavior of the script in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a3a1c4d-d287-4f35-9209-34a0d28f59fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Passing options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen in the first chapter how to read parameters from the user.
    Also, you can pass options. So, what are options? And how are they different from
    parameters?
  prefs: []
  type: TYPE_NORMAL
- en: Options are characters with a single dash before them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` is an option. You can check from your script if the user entered this
    option; if so, then your script can behave in some manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass multiple options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To print these options, you can use the `$1`, `$2`, and `$3` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00112873-5c8f-48e9-bbe6-da929c24c9ec.png)'
  prefs: []
  type: TYPE_IMG
- en: We should check these options, but, since we haven't discussed conditional statements
    yet, we will keep it simple for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options can be passed with a value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here the `-b` option is passed with a value of `20`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f49ffb2c-345c-4111-a6bf-7299bae26f75.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the variable `$3=20`, which is the passed value.
  prefs: []
  type: TYPE_NORMAL
- en: This might not be acceptable to you. You need `$2=-b` and `$3=-c`.
  prefs: []
  type: TYPE_NORMAL
- en: We will use some conditional statements to get these options correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you don't know about the while loop, it's not a problem; we will discuss
    conditional statements in detail in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `shift` command shifts the options one step to the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we have three options or parameters and we use the `shift` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$3` becomes `$2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$2` becomes `$1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$1` is dropped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's like an action to move forward while iterating over the options using the
    while loop.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the first loop cycle, `$1` will be the first option. After shifting the
    options, `$1` will be the second option and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you try the previous code, you will notice that it still doesn't identify
    the values of options correctly. Don't worry, the solution is coming; just wait
    a little longer.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters with options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To pass parameters along with options simultaneously, you must separate them
    with a double dash, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the previous technique, we can iterate over the options till we reach
    the double dash, then we will iterate over the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run it with parameters and options combined, we should see a list
    of options and another list of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/bc37cb87-8604-4816-8a01-d35bbfcbe25f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, anything passed after the double dash is treated as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Read options values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to identify options and parameters, but we still need a way
    to read the options values correctly.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to pass a value for a specific option. How can this value be read?
  prefs: []
  type: TYPE_NORMAL
- en: We will check for the `$2` variable while the iteration goes through the options
    that we expect a value for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f03655e1-78fb-4bc8-99f1-ee6f69db10f8.png)'
  prefs: []
  type: TYPE_IMG
- en: This looks good now; your script identifies the options and the passed value
    for the second option.
  prefs: []
  type: TYPE_NORMAL
- en: There is a built-in option for getting options from the users, which is using
    the `getopt` function.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `getopt` doesn't support options with more than one character.
  prefs: []
  type: TYPE_NORMAL
- en: There is a non-built-in program called `getopt`, which supports options larger
    than one character, but, again, the macOS X version doesn't support long options.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, if you would like to read more about `getopt` usage, refer to the further
    reading resources given after this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Try to be standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may use bash scripts from GitHub, and you may notice that there is a standard
    option scheme that is followed. It's not required, but it is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some of the commonly used options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-a`: List all items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c`: Get a count of all items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d`: Output directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e`: Expand items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: Specify a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h`: Show the help page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i`: Ignore the character case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l`: List a text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o`: Send output to a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-q`: Keep silent; don''t ask the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: Process something recursively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: Use stealth mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v`: Use verbose mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x`: Specify an executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-y`: Accept without prompting me'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing learning with simple scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our scripts are still a little trivial, and we have not looked at conditional
    statements so we can test for correct input, but let's take a look at some simple
    scripts that we can build with some functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Backing-up with scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created some scripts, we may want to back these up to a different
    location. If we create a script to prompt us, we can choose the location and the
    type of files that we want to backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following script for your first practice. Create the script and
    name it `$HOME/backup.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the file is commented; though, in black and white, the readability
    is a little difficult. If you have an electronic copy of this book, you should
    see the colors in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eae4e9df-999d-4a0a-b469-d3de9048748d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As the script runs, you may choose `.sh` for the files to backup and backup
    as the directory. The script execution is shown in the following screenshot, along
    with a listing of the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c16ef07-c383-425a-8264-3c39feca6afe.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you can see that we can start to create meaningful scripts with trivial
    scripting; although we strongly urge adding error checking of the user input if
    this script is for something other than personal use. As we progress into the
    book, we will cover this.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at some practical scripts that we can use to connect to servers.
    Firstly, we will look at ping, and in the second script we will look at prompting
    for SSH credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1 – ping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is something we can all do, as no special services are required. This
    will simplify the `ping` command for console users who may not know the details
    of the command. This will ping the server for just three counts rather than the
    normal infinite amount. There is no output if the server is alive, but a failed
    server reports `sever dead`. Create the following script as `$HOME/bin/ping_server.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows successful and failed outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c3d2840-0f52-4c10-8c79-d168635d5c25.png)'
  prefs: []
  type: TYPE_IMG
- en: Version 2 – SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often SSH is installed and running on servers, so you may be able to run this
    script if your system is running SSH or you have access to an SSH server. In this
    script, we prompt for the server address and username, and pass them through to
    the SSH client. Create the following script as `$HOME/bin/connect_server.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Use of the brace bracket is to delimit the variable from the `@` symbol in the
    last line of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Version 3 – MySQL/MariaDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next script, we will provide the detail for a database connection along
    with the SQL query to execute. You will be able to run this if you have a MariaDB
    or MySQL database server on your system, or one that you can connect to. For this
    demonstration, we will use Linux Mint 18.3 and MariaDB version 10; however, this
    should work for any MySQL server or MariaDB, from version 5 onwards. The script
    collects user and password information as well as the SQL command to execute.
    Create the following script as `$HOME/bin/run_mysql.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this script, we can see that we suppress the display of the MySQL password
    when we input it into the `read` command using the `-s` option. Again, we use
    `echo` directly to ensure that the next prompt starts on a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script input is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/356f2b3d-3ee9-43f8-a629-81b7c1c4e83a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we can easily see the password suppression working and the ease of adding
    to the MySQL commands.
  prefs: []
  type: TYPE_NORMAL
- en: Reading files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `read` command is not only used to read inputs from the user; you can use
    the `read` command to read files for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We redirect the file content to the `while` command to read the content using
    the `read` command, line by line.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we print the line using the `echo` command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feel proud that you now have your *I can read* badge for shell scripting. We
    have developed our scripts to be interactive and to prompt users for input during
    the script execution. These prompts can be used to simplify user operations on
    the command line. In this way, they do not need to remember the command-line options
    or have passwords that end up stored in the command-line history. When using passwords,
    we can simply store the value using the read `-sp` options.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we saw how to pass options with and without values, and how to identify
    values correctly. We saw how to pass options and parameters at the same time,
    thanks to the double dash.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take our time to look at the conditional statements
    in bash.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How many comments are in the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And we run the script with these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What is the result of running this code?
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run it with these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: What is the result?
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the dropped parameter?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_08_02.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_08_02.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ss64.com/bash/read.html](https://ss64.com/bash/read.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.manpagez.com/man/1/getopt/](http://www.manpagez.com/man/1/getopt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ss64.com/bash/getopts.html](https://ss64.com/bash/getopts.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
