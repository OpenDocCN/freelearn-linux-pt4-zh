<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Preparing for Administration using PowerShell</h1>
                </header>
            
            <article>
                
<p> In this chapter, we cover the following topics:</p>
<ol>
<li>Installing Visual Studio Code</li>
<li>Configuring automatic variables</li>
<li>Changing the shell behaviour using a variable</li>
<li>Enabling automated execution of commands for each load</li>
<li>Customising the terminal prompt</li>
<li>Understanding standard redirection in PowerShell</li>
<li>Calling native Linux commands from PowerShell</li>
<li>Understanding cmdlets and parameters</li>
<li>Running cmdlets with minimal keystrokes</li>
<li>Finding parameter aliases</li>
<li>Calling a PowerShell script</li>
<li>Dot-sourcing a PowerShell script</li>
<li>Calling a PowerShell cmdlet from outside of PowerShell</li>
<li>Recording the cmdlets run on the PowerShell console</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p class="mce-root">It is common notion that the more you use the terminal (as opposed to the GUI), the more efficient you are. Typing out commands is much easier and faster than clicking around the screen. However, to someone who has just begun using the terminal, it may not be so. Over time, as administrators grow more and more comfortable with the terminal, they learn to configure it for speed and efficiency, much like a trained horse. Further, most efficient administrators like automating several parts of their workflow—customising <kbd>.bashrc</kbd> and Vim scripts  are examples of it. In this chapter, we will familiarise ourselves with the different consoles and tools that work with PowerShell, and will also look at a few simple recipes which would help customise our workspace, so that we can be more efficient.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Visual Studio Code</h1>
                </header>
            
            <article>
                
<p>Scripting can happen on the console itself, with Vim. It is also possible to use other editors like Gedit or even Atom to write PowerShell scripts. It is, however, recommended to use Microsoft's open source code editor, called, Visual Studio Code (or <kbd>vscode</kbd>). In this recipe, we would look at installing Visual Studio Code, and configuring it to work with PowerShell.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>We would look at the steps to install <kbd>vscode</kbd> on Ubuntu. Today, most repositories contain Visual Studio Code. You may check in the software store of your distribution to install <kbd>vscode</kbd>. If not, the easiest way to install <kbd>vscode</kbd> is to download the <kbd>.deb</kbd> (or the <kbd>.rpm</kbd> package based on your distro), and run it to install the package on your computer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Installing Visual Studio Code is simple.</p>
<ol>
<li>If your Linux distribution has a software store, search the store for Visual Studio Code.</li>
<li>If you find Visual Studio Code, install the package from there. If not, proceed with the next step.</li>
<li>The package name for Visual Studio Code is <kbd>code</kbd>. Use your package manager to search for the package in the repository. On Ubuntu, the command would be:</li>
</ol>
<pre style="padding-left: 90px">$ sudo apt-cache pkgnames code</pre>
<ol start="4">
<li>If you're able to find the package in your repository, install vscode like you would any other package.</li>
</ol>
<pre style="padding-left: 90px">$ sudo apt install code</pre>
<ol start="5">
<li>If you were unable to find the package, go to <a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a> and download the right <kbd>code</kbd> package for your distro.</li>
<li>To install VS Code, call your package manager with the path to the downloaded package.</li>
</ol>
<pre style="padding-left: 90px">$ sudo apt install install code_version_arch.deb</pre>
<ol start="7">
<li>If you would rather install VS Code in portable mode, download the VS Code tarball and extract its contents to a convenient location to run VS Code. Although, remember that updates to VS Code would be handled by VS Code itself, in this case.</li>
</ol>
<p>Visual Studio Code is a powerful code editor in itself. However, it may not fully support PowerShell right out of the box. You would need to install the extension that packs capabilities which help run write and run PowerShell scripts.</p>
<ol>
<li>Launch Visual Studio Code.</li>
<li>Click on the Extensions icon or press <kbd>Ctrl+Shift+X</kbd> to go to the Extensions pane.</li>
<li>In the search bar, enter <kbd>powershell publisher:Microsoft</kbd> and hit Enter to search for the PowerShell package.</li>
<li>Click on Install in the resulting package–the PowerShell package should be on top.</li>
<li>Once the installation completes, click on Reload to reload Visual Studio Code with PowerShell capabilities.</li>
</ol>
<p>You are now ready to develop PowerShell scripts using a friendly editor that supports almost all of the capabilities that Windows PowerShell Integrated Scripting Environment has, and more!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Windows PowerShell ISE was the de-facto environment to develop PowerShell scripts and even applications written in PowerShell. Then came Adam Driscoll's PowerShell extension to Microsoft Visual Studio which integrated PowerShell into the integrated development environment.</p>
<p>While PowerShell was being worked on, and the .NET Foundation was formed, Microsoft started working on a lightweight code editor called Visual Studio Code that packed many of the great features of Visual Studio, without all the load of the language libraries. This was enough to build PowerShell scripts; most PowerShell <em>script-writers</em> use mainly the IntelliSense features, and Visual Studio Code has them.</p>
<p>Using a package manager to install VS Code ensures that all the dependencies are met. Also, this method of installation ensures that the signing key is added to the system. This way, updates to VS Code can be installed through the system, such as by running <kbd>sudo apt upgrade</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="https://code.visualstudio.com/docs/setup/linux">Installing Visual Studio Code on Linux</a> (Microsoft documentation)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring automatic variables</h1>
                </header>
            
            <article>
                
<p>Perhaps nothing contributes to efficiency like configurability. Configuring a system is a way of moulding it to your taste. You are the only one who knows best what works for you. Therefore, the more configurable a system is, the better it can be moulded to your use. automatic variables in PowerShell are one of the first steps to customisation in PowerShell (profiles are the other; we shall look into them shortly). In this recipe, we will list out all the automatic variables, and configure some of them to our requirements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Read the <em>Listing the various providers in PowerShell</em> section of <em>Installation, Reference and Help</em>, to learn how to use the various providers in PowerShell.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let us first list out the variables we have. This can be done in two ways:</p>
<ul>
<li>Using a cmdlet</li>
<li>Using a provider</li>
</ul>
<p>Let us first look at using the cmdlet to list out the variables built into PowerShell.</p>
<ol>
<li>Open a terminal window. If you have one open, restart PowerShell.</li>
<li>Find the cmdlet that works with variables.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Command -Noun Variable</pre>
<p style="padding-left: 60px">Remember that the noun in a cmdlet is always singular. Therefore, it would be <kbd>Variable</kbd>, and not <kbd>Variables</kbd>.</p>
<ol start="3">
<li>There are five cmdlets that deal with variables. We want to fetch a list of all variables already existing in a new session of PowerShell. Let us pick <kbd>Get-Variable</kbd>, and fetch help information for it.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Help Get-Variable</pre>
<ol start="4">
<li>This is the cmdlet that we need to list out all the variables predefined in the current scope.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Variable</pre>
<p>That should list out all the variables predefined in the current scope.</p>
<div class="packt_tip">Any variables you define would be listed here. Hence, it is important that you start a fresh session of PowerShell to see what variables have been predefined.</div>
<p>Let us now use a PowerShell provider to list out the variables defined in the current scope.</p>
<ol>
<li>List out the PowerShell providers. We looked at providers in the previous chapter.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-PsProvider</pre>
<ol start="2">
<li>Change location to the <kbd>Variable:</kbd> drive of the <kbd>Variable</kbd> provider. This is done using <kbd>Set-Location</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Set-Location Variable:</pre>
<ol start="3">
<li>Now, let us list out all the available child items of the <kbd>Variable:</kbd> drive.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem .</pre>
<p>The output of this was identical to that of <kbd>Get-Variable</kbd>, called without an argument.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>PowerShell is built with some variables that control its behaviour, and administrators are allowed to modify some of them to suit the needs. Some variables, however, cannot be modified; they are contextual, and add some amount of flexibility (or modularity, as the case might be) to the shell.</p>
<p>One such example would be <kbd>$PWD</kbd>, which contains the path of the present directory. This variable changes itself based on the execution of <kbd>Set-Location</kbd>. Values cannot be explicitly assigned to such variables; setting values explicitly would have no effect on the behaviour of the shell.</p>
<p>Some variables, on the other hand, accept values, and let us control the execution of commands and scripts. We shall look at an example in the next recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Changing the shell behaviour using a variable</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we took a look at the existing variables. In this recipe, we will change the value of one of the variables to control the behaviour of PowerShell. Again, remember that the change in the value is ephemeral; the values would be reset once the PowerShell process is restarted.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Read the previous recipe to understand what automatic variables that come predefined. Also, start Visual Studio Code. Follow the steps below to start VS Code.</p>
<ol>
<li>Open Applications (I'm using the Gnome DE, which shows all applications with <kbd>Super + A</kbd>).</li>
<li>Type in <kbd>code</kbd>.</li>
<li>Press <kbd>Ctrl + `</kbd> to launch the terminal.</li>
<li>Click on New File at the welcome screen. (Or press <kbd>Ctrl + N</kbd>.)</li>
<li>At the bottom right of the VS Code window, you would see the file type set to Plain Text. Click on it; you would be taken to the command bar on top.</li>
<li>Type in <kbd>powershell</kbd> at the command bar. The PowerShell Integrated Console will open at the bottom.</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-310 image-border" src="Images/4695ded0-1291-4688-85fc-14410d9643aa.png" style="width:49.25em;height:38.67em;" width="1638" height="1286"/></div>
<p>We are all set for the recipe now.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let us run a command that would result in an error. For now, let us not focus on the syntax of the command; our only goal for now is to generate an error. At the first line of the script window, type in:</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem /home/ram/random-directory<br/>Write-Host "Hello world!"</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-311 image-border" src="Images/b0b222fa-1b67-42e4-a78e-d22e94f2bc8a.png" style="width:52.17em;height:41.00em;" width="1638" height="1286"/></div>
<ol start="2">
<li>Run the two-liner script using the <kbd>F5</kbd> key.</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-312 image-border" src="Images/104cf932-9a53-42b2-8bed-87e13ae01667.png" style="width:39.25em;height:30.83em;" width="1638" height="1286"/></div>
<p style="padding-left: 60px">PowerShell is prompt to show an error. It also displays the <kbd>Hello world!</kbd> string.</p>
<ol start="3">
<li>Now, let us set the error action preference, using the variable, <kbd>ErrorActionPreference</kbd>. We know there's such a variable from the previous recipe. First, though, restart PowerShell. The easiest way is to click on the little bin icon at the top of the Integrated Console window. When VS Code asks if you would like to restart the session, click on Yes.</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-313 image-border" src="Images/b9254d0b-3222-4b7d-879b-2d8b4063252b.png" style="width:46.17em;height:36.25em;" width="1638" height="1286"/></div>
<ol start="4">
<li>Now, set the <kbd>ErrorActionPreference</kbd> variable. At the PowerShell Integrated Console, enter:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Set-Variable ErrorActionPreference SilentlyContinue</pre>
<ol start="5">
<li>Run the two-liner script again.</li>
</ol>
<p style="padding-left: 60px">There is no error this time. And we see <kbd>Hello world!</kbd> at the console.</p>
<div class="packt_tip">If you do not want the entire script appear at the prompt, make the first line of the script, <kbd>Clear-Host</kbd>; this would clear the screen before showing the output.</div>
<ol start="6">
<li>What if you were to check whether an error was generated at all? We check the value of the automatic variable, <kbd>Error</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Variable Error</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-314 image-border" src="Images/48e32e87-abde-4edd-9ca0-6cf1a296a5aa.png" style="width:45.33em;height:35.58em;" width="1638" height="1286"/></div>
<ol start="7">
<li>The <kbd>Value</kbd> column contains some text. Let's select and expand the contents of <kbd>Value</kbd>.</li>
</ol>
<pre style="padding-left: 90px">Get-Variable Error | Select-Object -ExpandProperty Value</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-315 image-border" src="Images/735a62cc-1e23-4373-8710-1f1c53943594.png" style="width:47.83em;height:37.58em;" width="1638" height="1286"/></div>
<p>The output text is the same as what we received before we set the error action preference.</p>
<div class="packt_tip">You can also simply call the <kbd>Error</kbd> variable to read all the errors that occurred in the current session.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>By default, the error action preference is <kbd>Continue</kbd>, which means that PowerShell would display the error, and continue with the execution of the rest of the script (this effect is not noticeable when running individual commands, hence the creation of the two-liner, or three-liner in case you added <kbd>Clear-Host</kbd> at the top). By setting <kbd>ErrorActionPreference</kbd> to <kbd>SilentlyContinue</kbd>, we instruct PowerShell to record the error but not show it on the screen, and at the same time, go on with executing the rest of the script.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables?view=powershell-6#erroractionpreference">about_Preference_Variables, $ErrorActionPreference</a> (Microsoft documentation)</li>
<li>Recipe: Error handling in PowerShell</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Enabling automated execution of commands for each load</h1>
                </header>
            
            <article>
                
<p>Like we saw in the previous recipes, these changes are ephemeral; they remain as long as the session is active. There might be situations wherein administrators might require running a few commands, or loading modules to enable them to work faster. For instance, I tend to load a series of modules that help me manage Microsoft Exchange, Active Directory, VMware vSphere infrastructure, Citrix XenApp, Microsoft System Center, and other environments using PowerShell.</p>
<p>If you see, all of these products require different ways of loading the modules, snap-ins and scripts, and many of them require certain configuration every time you load the modules (such as connecting to VM servers with administrator credentials). These can be done using the PowerShell profile.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>PowerShell by default does not create a profile during installation. It simply runs with its default configuration. Any override to this configuration would require creating and modifying the profile.</p>
<ol>
<li>Open a PowerShell console. (You could either run pwsh at the terminal or use the VS Code console. This recipe uses the terminal.)</li>
<li>Reveal the path of your profile. To do this, simply call the automatic variable.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $PROFILE</pre>
<ol start="3">
<li>Check if your profile exists.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Test-Path $PROFILE</pre>
<ol start="4">
<li>If you get True as the response, you can proceed with the recipe. If the response is False, which is most likely the case, run the following:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; New-Item $PROFILE -ItemType File</pre>
<ol start="5">
<li>You may receive an error, saying a part of the path was not found. This is because your <kbd>~/.config/</kbd> directory does not by default contain a <kbd>powershell</kbd> directory. Adding <kbd>-Force</kbd> to the command creates this directory and creates your profile file at the location.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; New-Item $PROFILE -ItemType File -Force</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-316 image-border" src="Images/c6790c84-4047-427b-933e-47b24beaf1d1.png" style="width:43.33em;height:24.92em;" width="1450" height="835"/></div>
<ol start="6">
<li>We will now edit the profile in VS Code. At the terminal, type:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; code $PROFILE</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>You should have the profile open now. It would currently be empty. Let us now customise PowerShell's error action behaviour. Remember that we said that setting <kbd>ErrorActionPreference</kbd> to <kbd>SilentlyContinue</kbd> at the terminal was temporary. Let us now ensure that <kbd>ErrorActionPreference</kbd> is permanently set to <kbd>SilentlyContinue</kbd> every time we launch PowerShell.</p>
<ol>
<li class="mce-root">Switch to the terminal window. If you have the window open since the last recipe, restart PowerShell.</li>
<li class="mce-root">Let us see what the error action preference is at the moment.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Variable ErrorActionPreference<br/>Continue</pre>
<ol start="3">
<li>Switch to VS Code. The profile should already be open for edits.</li>
<li>At the very first line, type in:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Set-Variable ErrorAction SilentlyContinue</pre>
<ol start="5">
<li>Save the profile and close the file.</li>
<li class="mce-root">At the terminal, type <kbd>exit</kbd> to exit from PowerShell. Start PowerShell again.</li>
<li>Let us now check what the value is for <kbd>ErrorActionPreference</kbd>. At the prompt, type:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; $ErrorActionPreference<br/>SilentlyContinue</pre>
<ol start="8">
<li>To ensure the preference is indeed in place, type:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem /home/ram/random-directory</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-317 image-border" src="Images/bf5a2583-205d-4e2a-b756-4611f2977719.png" style="width:47.33em;height:27.25em;" width="1450" height="835"/></div>
<p>The cursor simply returned to the prompt at the next line without throwing an error.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Long story short, the PowerShell profile executes every time a PowerShell session is loaded. This profile is a PowerShell script file that can contain a series of commands and functions, which would be executed just like another script.</p>
<p>One important point to remember is that there is a different profile for each host. For instance, there is a separate profile for PowerShell loaded on the Terminal, and a different one for the Integrated Terminal on VS Code. This is because each of the terminals has a different nature.</p>
<div class="packt_tip">Execution Policies have not been implemented in PowerShell on Linux. In case PowerShell on Linux gains the safety belt in the future, the execution policy should be set to allow execution of scripts in order for the profile to load.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It is bad practice to set a global action preference. Empty the profile to remove the error action preference. Since the profile has nothing else, you could even delete the profile using the following command:</p>
<pre> Remove-Item $PROFILE</pre>
<p>Read the best practices for more information.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Customising the terminal prompt</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we customised the error action preference using the profile. We used an already-demonstrated command to show that commands that can be run on the PowerShell console can be added to the profile as well, and this was a way to automate running a certain set of commands which could be used to increase productivity.</p>
<p>Now, we will take the next step and customise our console prompt. The options are theoretically endless; this recipe is just another demonstration of how flexible PowerShell is.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>You need VS Code for this recipe. If you did not follow along the last recipe, follow the steps in the <em>Getting Ready</em> section of the last recipe to create a PowerShell profile, only this time, run the commands at the PowerShell Integrated Console of VS Code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Ensure that the profile is empty. If you just created the profile, you can simply proceed further. If not, clear all contents in the profile. If the error action preference is set in the profile, it would become hard to troubleshoot scripts that you create in the future.</p>
<ol>
<li>Enter the following in the main window.</li>
</ol>
<div>
<pre style="padding-left: 90px"><span>function</span><span> </span><span>prompt</span><span> {<br/></span><span>  </span><span>$</span><span>Location</span><span> </span><span>=</span><span> </span><span>(</span><span>Get-Location</span><span>)</span><span>.Path.ToString</span><span>()<br/></span>  <span>switch</span><span> </span><span>-</span><span>Wildcard </span><span>($</span><span>Location</span><span>)</span><span> {<br/></span>    <span>"/home/</span><span>$</span><span>env:USERNAME</span><span>"</span><span> { </span><span>$</span><span>Location</span><span> </span><span>=</span><span> </span><span>'~'</span><span>;</span><span> </span><span>break</span><span> }<br/></span>    <span>"/home/</span><span>$</span><span>env:USERNAME</span><span>/Documents"</span><span> { </span><span>$</span><span>Location</span><span> </span><span>=</span><span> </span><span>'Documents'</span><span>;</span><span> </span><span>break</span><span> }<br/></span>    <span>"/home/</span><span>$</span><span>env:USERNAME</span><span>/Downloads"</span><span> { </span><span>$</span><span>Location</span><span> </span><span>=</span><span> </span><span>'Downloads'</span><span>;</span><span> </span><span>break</span><span> }<br/></span>    <span>"/home/</span><span>$</span><span>env:USERNAME</span><span>/Pictures"</span><span> { </span><span>$</span><span>Location</span><span> </span><span>=</span><span> </span><span>'Pictures'</span><span>;</span><span> </span><span>break</span><span> }<br/></span>    <span>"/home/</span><span>$</span><span>env:USERNAME</span><span>/Videos"</span><span> { </span><span>$</span><span>Location</span><span> </span><span>=</span><span> </span><span>'Videos'</span><span>;</span><span> </span><span>break</span><span> }<br/></span>    <span>"/home/</span><span>$</span><span>env:USERNAME</span><span>/Music"</span><span> { </span><span>$</span><span>Location</span><span> </span><span>=</span><span> </span><span>'Music'</span><span>;</span><span> </span><span>break</span><span> }<br/></span>    <span>"/home/</span><span>$</span><span>env:USERNAME</span><span>/Documents/code"</span><span> { </span><span>$</span><span>Location</span><span> </span><span>=</span><span> </span><span>'Code'</span><span>;</span><span> </span><span>break</span><span> }<br/></span>    <span>"/home/</span><span>$</span><span>env:USERNAME</span><span>/*"</span><span> { </span><span>$</span><span>Location</span><span> </span><span>=</span><span> </span><span>$</span><span>Location</span><span>.Replace</span><span>(</span><span>"/home/</span><span>$</span><span>env:USERNAME</span><span>/"</span><span>,</span><span> </span><span>'~/'</span><span>);</span><span> </span><span>break</span><span> }<br/></span><span>    Default { }<br/></span><span>  }<br/></span><span>  </span><span>Write-Host</span><span> </span><span>"PS "</span><span> </span><span>-</span><span>NoNewline<br/></span>  <span>Write-Host</span><span> </span><span>`<br/></span>    <span>($($</span><span>env:USERNAME</span><span>)</span><span> </span><span>+</span><span> </span><span>"@"</span><span> </span><span>+</span><span> </span><span>"</span><span>$(</span><span>[System.Net.Dns]</span><span>::GetHostByName</span><span>((</span><span>hostname</span><span>))</span><span>.HostName</span><span>)</span><span> "</span><span>)</span><span> </span><span>`<br/></span>    <span>-</span><span>NoNewLine </span><span>-</span><span>ForegroundColor Cyan<br/></span>  <span>Write-Host</span><span> </span><span>"</span><span>$</span><span>Location</span><span>"</span><span> </span><span>-</span><span>NoNewline </span><span>-</span><span>ForegroundColor Green<br/></span>  <span>Write-Host</span><span> </span><span>(</span><span>"</span><span>`n</span><span>&gt; "</span><span>)</span><span> </span><span>-</span><span>NoNewline<br/></span>  <span>return</span><span> </span><span>" "<br/></span><span>}</span></pre></div>
<ol start="2">
<li>Save the profile script file.</li>
<li>Click on the little bin icon at the top of the Integrated Console to kill the current PowerShell session.</li>
<li>When VS Code prompts you whether you would like to restart the session, click Yes.</li>
</ol>
<p style="padding-left: 60px" class="mce-root">Your prompt should look as shown in the image below.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-318 image-border" src="Images/f6f8c8ed-8df5-4d42-8415-d37b24ac6e27.png" style="width:41.33em;height:32.50em;" width="1638" height="1286"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The prompt is controlled by a function called <kbd>prompt</kbd>. To demonstrate this, we could use:</p>
<pre>Get-Command prompt</pre>
<p>The output shows that there is indeed such a command, which is of the type <kbd>Function</kbd>. To know the contents of the <kbd>prompt</kbd> function, enter:</p>
<pre>PS&gt; (Get-Command prompt).ScriptBlock</pre>
<p>The output shows you the entire function you just wrote. This is, however, the function that overrode the default <kbd>prompt</kbd> function. If you clear your profile, restart the PowerShell session, and type in the command above, you would see a simple three-liner output, which is the default <kbd>prompt</kbd> function.</p>
<p>Now to break down the function we wrote:</p>
<p>First, you declare the function you are about to write. This is done using the keyword, <kbd>function</kbd>, followed by the name of the function. Since we want to work with the prompt, we use the existing function name so as to override the default functionality. The next thing that follows is the script block, which starts with a <kbd>{</kbd>.</p>
<p>We want the location to appear at the prompt. This is a must-have information, for obvious reasons.</p>
<p>If you notice, PowerShell shows the complete Home path at the prompt. While this works, we are used to the tilde for Home. Also, I know that Documents, Music and other folders reside within my Home folder, and I would rather have just the name of the folder appear at the prompt. This would mean some text manipulation. Therefore, I assign the current location to a variable, <kbd>$Location</kbd>.</p>
<p>Next, we perform a switch-case operation and arrive at the value for what needs to be displayed at the prompt. Don't worry about the syntaxes for now; we will look into each of those in the chapters that follow.</p>
<p>Later, we use a few <kbd>Write-Host</kbd> statements to construct the prompt text. The <kbd>-NoNewLine</kbd> parameter ensures that the contents of each statement do not go to the next line. When we need a line break, we explicitly add <kbd>`n</kbd>.</p>
<div class="packt_tip packt_infobox">If you want to break a long-running line in a script, use the backtick (<kbd>`</kbd>) character at the point where you would like to break the line and press Enter to break the line after the backtick. PowerShell would treat the line with the backtick, as well as the line that follows, as the same line. Similarly, if you would like to write two statements in the same line, use the semicolon (<kbd>;</kbd>) at the end of the first statement, and continue with the second after a space. PowerShell will treat both the clauses as separate statements, just like plain English.</div>
<p>Since <kbd>Write-Host</kbd> just sends text to the host, and does not return anything, we add a return statement to the function, with merely an empty space.</p>
<p>When we reload the PowerShell Integrated Console, the profile is loaded, and this time, the custom <kbd>prompt</kbd> function in the profile overrides the default <kbd>prompt</kbd> function, and presents us with a nice prompt, formatted just the way we defined.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Play around with the sequences and the contents of the <kbd>Write-Host</kbd> statements for now to customise your prompt. Once we are comfortable with the syntaxes in PowerShell, we should be able to customise the profile further.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_prompts?view=powershell-6">about_Prompts</a> (Microsoft Documentation)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding standard redirection in PowerShell</h1>
                </header>
            
            <article>
                
<p>When I first started using the command line interface, I was daunted by <kbd>&lt;</kbd> and <kbd>&gt;</kbd> and <kbd>&gt;&gt;</kbd> at first. Then, I entirely stopped using the command line interface for a while and went back to the Windows administrator ways, albeit with an unusual-for-a-Windows-admin level of use of keyboard shortcuts (it's all about the speed and efficiency!).</p>
<p>When PowerShell came along, I had forgotten about those operators; I simply went ahead and understood the concept of object and pipelines, and worked for years that way. Switching to Linux at home made me want to know the "Linux way" of using the terminal. The operators came back to haunt me. I simply installed PowerShell on Linux.</p>
<p>Redirection in PowerShell mainly relies on streams. And streams are covered in a different chapter. For now, we stick with the default stream, which is, <kbd>Success</kbd>.</p>
<p>This recipe covers the different, simple redirections to help with basic administration. We shall come back to streams while understanding the concepts of error handling.</p>
<p>Before we begin, let us understand that PowerShell is very different from Bash in terms of redirection, although it packs some minor similarities; similarities enough to make you not go away, but rather appreciate the flexibility of the object model, and the uniformity of use.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We shall perform four activities in this recipe:</p>
<ol>
<li>Redirect output to a file</li>
<li>Append another output to the same file</li>
<li>Send the output of a command to the console as well as a file</li>
<li>Accept the input of one command into another</li>
</ol>
<p>Apart from the operators that we use in the first two activities, we will also look at the cmdlet equivalents to those operators.</p>
<ol>
<li>List out all the processes running on your computer at the moment.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process</pre>
<ol start="2">
<li>The output was shown on the console. Now, let us redirect the contents into a file.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process &gt; processes.txt</pre>
<ol start="3">
<li>List out the contents of the file.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Content ./processes.txt</pre>
<ol start="4">
<li>Let us now append the file with the date and time stamp.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date &gt;&gt; ./processes.txt</pre>
<ol start="5">
<li>Read the contents of the file now.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Content ./processes.txt</pre>
<p>You can see that the file now contains a list of all the processes running in the system, as well as the time stamp. The time stamp got <em>appended</em> to the file.</p>
<p>When going the <em>PowerShell way</em>, the same results can be accomplished using the <kbd>Out-File</kbd> cmdlet. (<kbd>Out-File</kbd> has more features such as setting the encoding and new line control.) Let us accomplish the same tasks using the <kbd>Out-File</kbd> cmdlet. You may want to delete <kbd>processes.txt</kbd> before proceeding.</p>
<ol>
<li>Let us list out the currently-running processes again, and send the output to a file using <kbd>Out-File</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process | Out-File processes.txt</pre>
<ol start="2">
<li>Now, let us append the time stamp to the file.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Date | Out-File processes.txt -Append</pre>
<p style="padding-left: 60px">If you notice, the output of <kbd>Get-Process</kbd> and <kbd>Get-Date</kbd> went directly to the file; nothing got displayed on the host.</p>
<p>If we want to display the output on the console as well as send the content to a file, we simply use <kbd>Tee-Object</kbd> instead of <kbd>Out-File</kbd>. If you would like, delete the file, <kbd>processes.txt</kbd> again.</p>
<ol>
<li>Run the following command.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Process | Tee-Object ./processes.txt</pre>
<p style="padding-left: 60px">The list of running processes should be shown at the terminal.</p>
<ol start="2">
<li>Check the contents of the file, <kbd>processes.txt</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS /home/ram&gt; Get-Content ./processes.txt</pre>
<p>As you can see, the list of processes appears in the text file as well.</p>
<p>Let us now proceed with learning to make cmdlets accept input from files. Linux administrators are used to making commands accept input from a file, like so:</p>
<pre>$ command &lt; input_file.txt</pre>
<p>The command accepts input from <kbd>input_file.txt</kbd>, and performs operations on the input content.</p>
<p>In PowerShell, this is handled using <kbd>Get-Content</kbd> and the pipe (<kbd>|</kbd>). The PowerShell equivalent of a command accepting input from a file would be:</p>
<pre>PS&gt; Get-Content input_file.txt | command</pre>
<p>This might seem the other way around to most of those who are not used to PowerShell. Let us break down the process into pieces and try to understand it better. For instance, let us say you have a list of files in a text file called <kbd>input.txt</kbd>.</p>
<ol>
<li>Reveal the contents of the text file.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Content input.txt</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-319 image-border" src="Images/cfa87d64-fffb-4078-a37e-18d89fb00bae.png" style="width:44.42em;height:24.58em;" width="1450" height="803"/></div>
<ol start="2">
<li>List out the contents of the current directory.</li>
</ol>
<pre style="padding-left: 90px">$ ls</pre>
<p style="padding-left: 60px">We have five test files in the current directory, four of which are in the list (the input file). Let us say that you would like to delete the files listed in the input file, from the directory.</p>
<ol start="3">
<li>Pass the output of <kbd>Get-Content</kbd> to the command, <kbd>Remove-Item</kbd>, through the pipe.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Content input.txt | Remove-Item</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-320 image-border" src="Images/f5ac1741-e892-4737-9bc2-842204050c21.png" style="width:44.83em;height:24.83em;" width="1450" height="803"/></div>
<ol start="4">
<li>List out the files currently present in the directory.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem .</pre>
<p>Et <span class="xr"><span class="orth">voilà</span></span>! If you compare the outputs of <kbd>ls</kbd> (before) and  <kbd>Get-ChildItem</kbd> (after); the files that were listed in the text file are no more.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we set out to understand the similarities between Bash and PowerShell. In spite of being fundamentally different from Bash, PowerShell does pack some similarities to Bash. Two of the similarities, as we saw, are passing content to files and appending content to the files.</p>
<p>We looked at three cmdlets in this recipe, one of which were used twice.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Out-File</h1>
                </header>
            
            <article>
                
<p>Those comfortable with Bash use the <kbd>&gt;</kbd> for sending the output to a file, and <kbd>&gt;&gt;</kbd> to append the output to an existing file. in PowerShell, we use the <kbd>Out-File</kbd> cmdlet. We run a command that sends output to the standard out, and through the pipe, redirect the output to <kbd>Out-File</kbd>, which handles writing the output to a file. Usually, <kbd>Out-File</kbd> is used to send content to a text file.</p>
<p>When there is a need to append the content to a file, we use the <kbd>-Append</kbd> switch with <kbd>Out-File</kbd>. This way, if the file that is being written to already contains content, the content isn't overwritten (overwriting content is the default behaviour of <kbd>Out-File</kbd>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tee-Object</h1>
                </header>
            
            <article>
                
<p>There are situations wherein you need to send content to a file, as well as display the content on the console. This is handled using a simple call of <kbd>Tee-Object</kbd>. <kbd>Tee-Object</kbd> works like the letter T; apart from sending content to a file or a variable, it also sends the content down the pipeline. In case <kbd>Tee-Object</kbd> is the last cmdlet in the statement, the pipeline output is sent out to standard out, which in most cases is the host (or in other words, the console by default).</p>
<p>In our recipe, we sent the first output to the file, <kbd>processes.txt</kbd>, and the second output was not sent down the pipeline. Therefore, <kbd>Tee-Object</kbd> picked the standard out.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accepting input from file</h1>
                </header>
            
            <article>
                
<p>This process is significantly different in PowerShell, compared to Bash. In Bash, we call the command first, and then ask it to accept input from a file. In PowerShell, we make PowerShell read the contents of the input file first, and then send the output to the command that accepts input through the pipeline.</p>
<p>In our recipe, we read the contents of the file, <kbd>input.txt</kbd>, which contained a list of four file names. We used <kbd>Get-Content</kbd> to read the content from the file. <kbd>Get-Content</kbd> sent the output to the standard out at first, thereby showing us the contents of the file. We then added a pipe to tell PowerShell that we need further processing, and then, added <kbd>Remove-Item</kbd> to the command chain. (<kbd>Remove-Item</kbd> deletes items, which could be directories, files or links.)</p>
<p>As we would see later in this chapter, the first parameter (positional parameter, position 1) of <kbd>Remove-Item</kbd> is <kbd>Path</kbd>, which is also the parameter that accepts input through the pipeline. For more information, run the following command and read about the <kbd>Path</kbd> parameter of <kbd>Remove-Item</kbd>.</p>
<pre>PS&gt; Get-Help Remove-Item -Parameter Path</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-321 image-border" src="Images/b1fcf9d5-5153-4ba2-a432-5bbcb8028f80.png" style="width:39.25em;height:21.75em;" width="1450" height="803"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Clean up the contents that we created for this recipe if you are the type that likes directories clean! If we need more files or directories in later recipes, we will create them as needed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li>Recipe 3.8: Understanding cmdlets and parameters</li>
<li>Recipe 1.6: Looking for help information specific to a parameter</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling native Linux commands from PowerShell</h1>
                </header>
            
            <article>
                
<p>In the chapter, <em>Introducing the Core and its Capabilities</em>, we saw how native Linux commands were not convenience aliases in PowerShell on Linux, but the commands themselves. In this recipe, we would demonstrate using Linux commands at the PowerShell prompt. Remember how we used a Bash terminal to run the commands <kbd>ls -l</kbd> and <kbd>awk</kbd> to list the contents of a directory, and separate the columns in the output, in the recipe, <em>Comparing the outputs of Bash and PowerShell</em>. We will perform the same operation on the home directory, from with PowerShell, without using any of the PowerShell cmdlets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p>It is recommended that you have a Windows PC with PowerShell installed on it (Windows PowerShell would also do) in order to compare the outputs and see if we encounter any errors.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>At the PowerShell prompt, type in the following command to list the contents of the directory.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; ls -l</pre>
<p style="padding-left: 60px">You see the familiar output (albeit without any of the colours, if your terminal emulator uses colours for file names).</p>
<ol start="2">
<li>Let us now look at the .NET Type Name of the output. For this, we would need to use the <kbd>Get-Member</kbd> cmdlet.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; ls -l | Get-Member</pre>
<p style="padding-left: 60px">PowerShell displays, <kbd>TypeName: System.String</kbd>, which is consistent with what we saw in the aforementioned recipe.</p>
<ol start="3">
<li>If you have a Windows PC with PowerShell (or Windows PowerShell), run the same command on it.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; ls -l | Get-Member</pre>
<p style="padding-left: 60px">Notice the .NET Type Name here; it is <kbd>System.IO.DirectoryInfo</kbd>, and if you scroll down the console a little, you would also see <kbd>System.IO.FileInfo</kbd>.</p>
<ol start="4">
<li>Next, at the PowerShell on Windows (or Windows PowerShell) prompt, type:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; ls -l</pre>
<p style="padding-left: 60px">You would receive an error, stating that there was no value given to the parameter, <kbd>LiteralPath</kbd>.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-322 image-border" src="Images/d565f397-477e-4b86-9518-f45d18ed8ab4.png" style="width:43.92em;height:24.00em;" width="1862" height="1019"/></div>
<ol start="5">
<li>At the PowerShell prompt on the Windows PC, enter the following and press the Tab key on your keyboard, instead of Enter.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; ls -l</pre>
<p style="padding-left: 60px">You would see that the parameter name was completed to <kbd>LiteralPath</kbd>.</p>
<ol start="6">
<li>Press the Esc key to clear the command line.</li>
<li>Come back to Linux, and at the PowerShell prompt, type in the following and press the Tab key:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; ls -l</pre>
<ol start="8">
<li>Nothing happens. Now, enter the following and press the Tab key:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-ChildItem -l</pre>
<p style="padding-left: 60px">The parameter name was completed to <kbd>-LiteralPath</kbd>. Let us take one more step and conclude this recipe.</p>
<ol start="9">
<li>At the PowerShell prompt on Windows, run the following command.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Alias ls</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-323 image-border" src="Images/91a6d14f-bbab-406c-8212-2285ff34399e.png" style="width:42.25em;height:23.08em;" width="1862" height="1019"/></div>
<ol start="10">
<li>Switch back to Linux and run the same command.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Alias ls</pre>
<p style="padding-left: 60px">You receive an error stating that there is no such alias.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-324 image-border" src="Images/75f2ffac-79de-4a70-af27-a3f0ade44b63.png" style="width:47.75em;height:27.50em;" width="1450" height="835"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When we run any of the Linux commands on PowerShell on Linux, PowerShell does not call the convenience aliases that were created for the benefit of Linux administrators, when Windows PowerShell was launched; these convenience aliases have not been included in PowerShell on Linux. PowerShell, instead, runs the actual Linux commands and shows the output on the console. Piping the output to other Linux commands work the same way as they do on Bash, when running them on PowerShell on Linux.</p>
<p>The first point to note is that <kbd>ls -l</kbd> is an actual command in Linux, and it returns the list of files and directories in the current directory, in a table format. When the same command is run on PowerShell on Windows, we receive an error, since PowerShell on Windows interprets <kbd>ls</kbd> as <kbd>Get-ChildItem</kbd>, and <kbd>-l</kbd> as the incomplete-but-definitive call to <kbd>-LiteralPath</kbd> and returns an error that the literal path was not specified.</p>
<p>When we run <kbd>Get-Alias</kbd> on <kbd>ls</kbd> on both the operating systems, PowerShell on Linux returns an error, while PowerShell on Windows shows the underlying PowerShell cmdlet.</p>
<p>The other point that pins down this fact is that the output of <kbd>ls</kbd> is string, as opposed to a system object, when the same <kbd>ls</kbd> is run on PowerShell on Windows. On Windows, PowerShell calls <kbd>Get-ChildItem</kbd> under the hood, and the output shown is that of <kbd>Get-ChildItem</kbd>. This is supported by the type name in the output of <kbd>Get-Member</kbd>, which is from the <kbd>System.IO</kbd> namespace. On the other hand, on Linux, running <kbd>Get-Member</kbd> on the output of <kbd>ls</kbd> simply returns <kbd>System.String</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases?view=powershell-6">about_Aliases</a> (Microsoft documentation)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding cmdlets and parameters</h1>
                </header>
            
            <article>
                
<p>Most of our scripting and administration is going to revolve around running cmdlets and chaining them. In some situations, we run a cmdlet expecting it to work a certain way, only to find out that the cmdlet threw an error, or worse, did something undesirable.</p>
<p>The key to getting cmdlets to do what we want them to do is  to eliminate ambiguity. In this recipe, we will learn to construct commands contextually and effectively.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Read the Help section of the first chapter, <em>Installation, Reference and Help</em>. Let us understand the notifications used in the help information that <kbd>Get-Help</kbd> shows.</p>
<p>While this may not be an exhaustive guide to using help, it should cover most of your daily help document reading needs. The idea is to show you the notations. These notations may appear in several combinations (parameter values in curly braces, surrounded by square brackets, for example).</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Notation</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td><kbd>-Parameter &lt;DataType&gt;</kbd></td>
<td>No square brackets: Mandatory parameter, named. The parameter must be called by name, and a value of DataType must be specified.</td>
</tr>
<tr>
<td><kbd>[-Parameter &lt;DataType&gt;]</kbd></td>
<td>Square brackets around the parameter-data-type-pair: Optional parameter, although, it must be called by name, and a value of DataType must be passed.</td>
</tr>
<tr>
<td><kbd>[-Parameter] &lt;DataType&gt;</kbd></td>
<td>Square brackets around the parameter name: Positional parameter. You can simply pass a value of DataType to the cmdlet, as long as the value is at the position shown by the parameter in the help text. The parameter need not be called by name as long as the position is right.</td>
</tr>
<tr>
<td><kbd>[[-Parameter] &lt;DataType&gt;]</kbd></td>
<td>Square brackets around the parameter name, and another pair of square brackets around the parameter-data-type-pair: Positional parameter, which is optional.</td>
</tr>
<tr>
<td><kbd>-Parameter &lt;DataType[]&gt;</kbd></td>
<td>Square brackets after DataType: Multi-valued parameter. This parameter accepts multiple values as input, each pair of values separated by a comma.</td>
</tr>
<tr>
<td><kbd>-Parameter</kbd></td>
<td>No data type: Switch parameter. Calling the parameter makes the switch $true, and not calling it uses the default value for the switch. To disable the switch, set it to false, like -Parameter:$false.</td>
</tr>
<tr>
<td><kbd>-Parameter {Value1 | Value2 | Value3}</kbd></td>
<td>Values surrounded by curly braces: Parameter that accepts predefined values as input. In this case, you would call the parameter like <kbd>-Parameter Value1</kbd>, or <kbd>-Parameter Value2</kbd>. In other words, this parameter does not accept arbitrary values.</td>
</tr>
</tbody>
</table>
<div class="packt_tip packt_infobox">Bash champions take note: PowerShell needs a comma separating the values in a multi-valued parameter. Therefore, if you would like to call <kbd>Remove-Item</kbd> on three files, you would enter <kbd>Remove-Item file1, file2, file3</kbd>. If only a space separates the values (like Bash's input), PowerShell will consider the three values as values to three positional parameters, and would either throw an error, or do something you did not want it to, based on the cmdlet you call.</div>
<p>In general, anything surrounded by square brackets is optional. Anything surrounded by curly braces indicates predefined parameter values (the pipe separates each value). Data type followed by an empty pair of square brackets indicate array of that data type. And the position of the parameter is to be noted.</p>
<div class="packt_tip">Notice the combination: <kbd>Required</kbd> is false, there is a default value as shown in the text below the parameter name, and the position is <kbd>1</kbd>. This means that you can simply call the cmdlet, and it would run itself against the default value for its first parameter. The example used here is <kbd>Get-ChildItem</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>That was a long getting ready section. Let us now put this knowledge to use.</p>
<ol>
<li>Run a command to get a list of files and directories in the current location.</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem</pre>
<ol start="2">
<li class="mce-root">Let us now add a <kbd>.</kbd> to indicate the current location.</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem .</pre>
<ol start="3">
<li>Compare the outputs of the last two commands.</li>
<li>Next, let us go with the following:</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem -Path .</pre>
<p style="padding-left: 60px">Is the output the same as that of the last two commands?</p>
<ol start="5">
<li>Run the following and note the values for each of the keys below:</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Help Get-ChildItem -Parameter Path<br/><br/>-Path &lt;String[]&gt;<br/>    Specifies a path to one or more locations. Wildcards are permitted. The default location is the current directory (`.`).<br/>    <br/>    Required?                    false<br/>    Position?                    1<br/>    Default value                Current directory<br/>    Accept pipeline input?       True (ByPropertyName, ByValue)<br/>    Accept wildcard characters?  true</pre>
<ol start="6">
<li class="mce-root">Next, create a file in the current location, called <kbd>file1</kbd> by calling the parameter by name.</li>
</ol>
<pre style="padding-left: 90px">Get-Help New-Item<br/><br/>.<br/>.<br/>.<br/>SYNTAX<br/>    New-Item [[-Path] &lt;String[]&gt;] [-Confirm] [-Credential &lt;PSCredential&gt;] [-Force] [-ItemType &lt;String&gt;] -Name &lt;String&gt; [-UseTransaction] [-Value &lt;Object&gt;] [-WhatIf] [&lt;CommonParameters&gt;]<br/><br/>    New-Item [-Path] &lt;String[]&gt; [-Confirm] [-Credential &lt;PSCredential&gt;] [-Force] [-ItemType &lt;String&gt;] [-UseTransaction] [-Value &lt;Object&gt;] [-WhatIf] [&lt;CommonParameters&gt;]</pre>
<ol start="7">
<li>We have two possibilities: <kbd>Path</kbd> and <kbd>Name</kbd>. Look for information on <kbd>Path</kbd>.</li>
</ol>
<pre style="padding-left: 90px">PS&gt; Get-Help New-Item -Parameter Path<br/><br/>-Path &lt;String[]&gt;<br/>    Specifies the path of the location of the new item. Wildcard characters are permitted.<br/><br/>    You can specify the name of the new item in Name , or include it in Path .<br/><br/>    Required?                    true<br/>    Position?                    0<br/>    Default value                None<br/>    Accept pipeline input?       True (ByPropertyName)<br/>    Accept wildcard characters?  false</pre>
<p style="padding-left: 60px">If we use <kbd>Name</kbd>, we have to call it by name (no pun intended). If not, we can specify the name as part of <kbd>Path</kbd> (no alliteration intended either).</p>
<ol start="8">
<li>Let us use <kbd>Path</kbd> first. “<kbd>-Path</kbd>” need not be written, since it is a positional parameter.</li>
</ol>
<pre style="padding-left: 90px">New-Item file1</pre>
<ol start="9">
<li>Try the same operation with <kbd>Name</kbd>. This time, mention the parameter name.</li>
</ol>
<pre style="padding-left: 90px">New-Item -Name file2</pre>
<ol start="10">
<li>If you would like, create a third file, by calling <kbd>Path</kbd> by name.</li>
</ol>
<pre style="padding-left: 90px">New-Item -Path file3</pre>
<ol start="11">
<li>List out the contents of the current location.</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem -Path .</pre>
<p style="padding-left: 60px">The files are present.</p>
<ol start="12">
<li>Let us now delete the files.</li>
</ol>
<pre style="padding-left: 90px">Get-Help Remove-Item</pre>
<ol start="13">
<li>Mention the file names as paths.</li>
</ol>
<pre style="padding-left: 90px">Remove-Item file1</pre>
<ol start="14">
<li>List the contents of the directory.</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem -Path .</pre>
<ol start="15">
<li>Now, let us delete multiple files in one shot. And this time, let us call the parameter by name.</li>
</ol>
<pre style="padding-left: 90px">Remove-Item -Path file1, file2</pre>
<ol start="16">
<li>Let us now create a directory. We need to use parameter called ItemType, which has predefined values, based on the provider (we are using <kbd>FileSystem</kbd>).</li>
</ol>
<pre style="padding-left: 90px">New-Item -Path test-dir -ItemType Directory</pre>
<ol start="17">
<li>Create three new files like so:</li>
</ol>
<pre style="padding-left: 90px">New-Item test-dir/file1, test-dir/file2 -ItemType File<br/>New-Item test-dir/child-dir -ItemType Directory<br/>New-Item test-dir/child-dir/file3 -ItemType File</pre>
<ol start="18">
<li>Now, let us delete the contents. Wait for a confirmation prompt to appear after running the command.</li>
</ol>
<pre style="padding-left: 90px">Remove-Item -Path test-dir</pre>
<ol start="19">
<li>Read the prompt. It talks something of the <kbd>Recurse</kbd> parameter.</li>
<li>Choose <kbd>L</kbd> and press Enter to abort the process.</li>
<li>Now, enter the following command:</li>
</ol>
<pre style="padding-left: 90px">Remove-Item -Path test-dir -Recurse</pre>
<ol start="22">
<li>That was quiet! List out the contents of the current directory to ensure <kbd>test-dir</kbd> is gone.</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem .</pre>
<p>The directory is indeed gone.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Working with cmdlets is simple. There are two kinds of parameters: named and positional.</p>
<p>Positional parameters work based on the position. They are programmed in such a way that PowerShell understands their logical sequence and performs its actions. For instance, when moving items, the general way of working is to call the command, pass the source first and then the destination.</p>
<p>Therefore:</p>
<pre>Move-Item /home/ram/Documents/GitHub /home/ram/Documents/Code/</pre>
<p>would mean that you want to move the directory, <kbd>GitHub</kbd> to <kbd>Code</kbd>. Many PowerShell cmdlets are programmed to understand this.</p>
<p>Named parameters, on the other hand, are to be called by name. Help text shows them without any brackets surrounding them. Calling the positional parameters by name is optional—you are allowed to simply pass the values. However, be careful with what position or sequence you mention them in.</p>
<p>The best practice is to always pass parameter values, calling them by name when writing scripts. When running quick commands, on the other hand, you may omit calling positional parameters by name in the interest of speed.</p>
<p>Some parameters have predefined value validation added to them. These parameters accept only those values that have been defined in them. For instance, <kbd>ItemType</kbd> only accepts <kbd>File</kbd>, <kbd>Directory</kbd>, <kbd>SymbolicLink</kbd>, <kbd>Junction</kbd> and <kbd>HardLink</kbd> as values as of writing this section.</p>
<p>And then, there are switch parameters. <kbd>Recurse</kbd> is an example. When you call these parameters with no value, the parameters assume <kbd>True</kbd> in most cases. When you have to set them to <kbd>False</kbd>, you mention, <kbd>-Parameter:$false</kbd> (for example, <kbd>-Confirm:$false</kbd>). If you do not call the switch parameter, the parameter goes with the default value specified in the cmdlet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>If you would like to create the files and directories again, don't run four commands. Run the following two.</p>
<pre>New-Item test-dir/child-dir -ItemType Directory -Force<br/>New-Item ./test-dir/file1, ./test-dir/file2, ./test-dir/child-dir/file3</pre>
<p>The parameter, Force, creates <kbd>test-dir</kbd> when creating <kbd>child-dir</kbd>.</p>
<p>Go ahead and delete the entire directory if you want to, without the <kbd>Recurse</kbd> parameter. At the confirmation prompt, press Enter (<kbd>Y</kbd> is the default response).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running cmdlets with minimal keystrokes</h1>
                </header>
            
            <article>
                
<p>Commands have been made to be short, historically. However, the situation turned into a dilemma over time, since shorter commands meant that they had to be remembered, and longer commands meant more keystrokes.</p>
<p>PowerShell has long commands, however, it deals with them in two ways:</p>
<ol>
<li>Aliases, which tend to be shorter.</li>
<li>Tab completion, which require more keystrokes than aliases, but don't require remembering much.</li>
</ol>
<p>The first way necessitates using our memory to recall command names as required. The second, on the other hand, solves the keystroke issue efficiently.</p>
<p>Bash users are used to getting a list of matches laid out in a nice tabular format when the tab key matches more than one strings in the context. On the other hand, the matches cycle at the cursor in Windows (which most Bash users find "weird").</p>
<p>Be that as it may, tab completion is a boon, and this recipe makes complete use of tab completion and simple string matching to significantly reduce keystrokes when using PowerShell cmdlets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>We use the Gnome Terminal terminal emulator for this recipe, and tab completion on PowerShell on Linux on Gnome Terminal behaves exactly the same way that it works on Bash on Gnome Terminal:</p>
<ul>
<li>If only one word matches the string before the tab, the word is completed.</li>
<li>If multiple words match the string before the tab, all possible options are listed.</li>
</ul>
<p>If you are using VS Code for this recipe, or a different terminal emulator, its behaviour may be different.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let us get right to it!</p>
<p>Say, we would like to get the list of files and directories within the current directory.</p>
<ol>
<li>The right way of doing this, as per best practices would be:</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem -Path .</pre>
<ol start="2">
<li>However, as we've seen before, the easy way of doing this would be:</li>
</ol>
<pre style="padding-left: 90px">gci</pre>
<p style="padding-left: 60px">We would use the former way when including the cmdlet in a script. This avoids ambiguity, in most contexts that the script would run in. This usually means minimal bugs. The latter, on the other hand, is the short way of running the same cmdlet, by leveraging the user-friendly features of it, combined with the awareness of the environment as an intelligent human. This approach significantly reduces key strokes<span>–three characters, as opposed to twenty-one</span>.</p>
<p style="padding-left: 60px">Although, if you are writing a script and would like to reduce keystrokes, you could still do it, without having to remember things such as <kbd>gpv</kbd> means <kbd>Get-ItemPropertyValue</kbd>.</p>
<p style="padding-left: 60px">Enter: Tab completion.</p>
<ol start="3">
<li>Follow the keystrokes mentioned below:</li>
</ol>
<pre style="padding-left: 90px">get-ch&lt;Tab&gt;&lt;Space&gt;.</pre>
<p style="padding-left: 60px">Those were ten keystrokes including &lt;Enter&gt;.</p>
<p style="padding-left: 60px">There may be situations wherein you would need to call a named parameter. And the named parameter might be long.</p>
<ol start="4">
<li>Find a command that has <kbd>ComputerName</kbd> as a parameter.</li>
</ol>
<pre style="padding-left: 90px">get-comm&lt;Tab&gt;&lt;Space&gt;-param&lt;Tab&gt;&lt;Space&gt;computername&lt;Enter&gt;</pre>
<p style="padding-left: 120px">This completes to:</p>
<pre style="padding-left: 90px">Get-Command -Parameter computername</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-325 image-border" src="Images/c624b608-e1c3-4cae-91db-beeec2cef223.png" style="width:38.83em;height:22.33em;" width="1450" height="835"/></div>
<p style="padding-left: 60px">But it throws an error. The error says, <kbd>Possible matches include: -ParameterName -ParameterType</kbd>. This is the caveat in PowerShell on Linux. Let us try again:</p>
<pre style="padding-left: 90px">get-comm&lt;Tab&gt;&lt;Space&gt;-param&lt;Tab&gt;&lt;Tab&gt;</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-326 image-border" src="Images/e5f9420d-d558-4df5-957a-64e2e050e962.png" style="width:43.33em;height:24.92em;" width="1450" height="835"/></div>
<ol start="5">
<li>Read the list of possibilities and select <kbd>ParameterName</kbd>.</li>
</ol>
<pre style="padding-left: 90px">get-comm&lt;Tab&gt;&lt;Space&gt;-param&lt;Tab&gt;n&lt;Tab&gt;&lt;Space&gt;computername&lt;Enter&gt;</pre>
<ol start="6">
<li>The complete resolution of that would be:</li>
</ol>
<pre style="padding-left: 90px">Get-Command -ParameterName computername</pre>
<p style="padding-left: 60px">And it worked.</p>
<p style="padding-left: 60px">Next, let us suspend the activity in our session for, say, five seconds. The cmdlet for this would be <kbd>Start-Sleep</kbd>.</p>
<ol start="7">
<li>Let us first get help on the cmdlet.</li>
</ol>
<pre style="padding-left: 90px">Get-Help Start-Sleep</pre>
<p style="padding-left: 60px">The help text says that the parameter at position one, which need not be named is <kbd>Seconds</kbd> (square brackets around Seconds in the second parameter set), and it accepts integer values.</p>
<ol start="8">
<li>Therefore, to suspend the session for five seconds, we would use:</li>
</ol>
<pre style="padding-left: 90px">Start-Sleep 5</pre>
<ol start="9">
<li>If we wanted the session (or script) suspended for 100 milliseconds, we would need to use the named <kbd>Milliseconds</kbd> parameter. With tab completion, it would be:</li>
</ol>
<pre style="padding-left: 90px">start-s&lt;Tab&gt;&lt;Space&gt;-mi&lt;Tab&gt;100</pre>
<p style="padding-left: 60px">Which would resolve to:</p>
<pre style="padding-left: 90px">Start-Sleep -Milliseconds 100</pre>
<ol start="10">
<li>You can, in fact, reduce the number of tabs when using parameter names. Just type enough for PowerShell to uniquely identify the parameter name:</li>
</ol>
<pre style="padding-left: 90px">start-s&lt;Tab&gt;&lt;Space&gt;-m&lt;Space&gt;100</pre>
<p style="padding-left: 60px">Which would resolve to:</p>
<pre style="padding-left: 90px">Start-Sleep -m 100</pre>
<p class="mce-root">If the delay was not noticeable, feel free to increase the number a little (say, 3000).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<div>
<p>We have already seen how to use aliases. Aliases work just like normal cmdlets, including the syntax of their parameters. The only catch is that we have to remember the aliases. Custom aliases, as shall see in the best practices section, are a bad idea given that the aliases have to be imported everywhere we want to run scripts that have custom aliases. </p>
</div>
<div>
<p>Tab completion on the other hand, reduces the number of keystrokes, but requires muscle memory. It requires some level of practice, given which, significantly improves productivity. </p>
</div>
<div>
<p>Tab completion works when writing cmdlets, writing parameter names, as well as when passing pre-defined values to parameters, such as:  </p>
</div>
<div>
<pre>set-exec&lt;Tab&gt;&lt;Space&gt;-exec&lt;Tab&gt;&lt;Space&gt;unre&lt;Tab&gt; </pre></div>
<div>
<p>Which completes to: </p>
</div>
<div>
<pre>Set-ExecutionPolicy -ExecutionPolicy Unrestricted </pre></div>
<div>
<p>In many situations, it is not necessary to use tab completion at all, for instance, in the case of <kbd>Start-Sleep</kbd>. There is no parameter that starts with <kbd>m</kbd> in case of the cmdlet. Therefore, using <kbd>-m</kbd> was sufficient for PowerShell to uniquely identify <kbd>-Milliseconds</kbd>. That saved us the <kbd>&lt;Tab&gt;</kbd> keystroke as well. </p>
</div>
<div>
<p>Productivity with respect to writing scripts in PowerShell is a skill that comes with practice. While aliases sure are a shortcut to speed, they have their perils. On the other hand, using the keyboard to write scripts helps with muscle memory, which not only helps us think in PowerShell, it also helps speeding up tab completion, which works equally well when running commands at the console, or writing scripts. </p>
</div>
<div>
<p>Using short parameter names is generally not a good practice while scripting; use these with a similar caution as aliases. Short parameter names affect readability, and also, might break scripts at some point in future. For instance, if you call a certain cmdlet in a script, with a short parameter name <kbd>-comp</kbd>, which at the time of the creation of the script, stood only for <kbd>ComputerName</kbd>. Later, imagine the cmdlet received an update with an added parameter, <kbd>-CompatibilityMode</kbd>; this would break the script that you wrote.</p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<div>
<p>Try to type most commonly used cmdlets along with the parameters to practice tab completion. </p>
</div>
<div>
<p>Get familiar with VS Code by typing the cmdlets in the script pane. Notice how cmdlet, parameter and parameter value completion work in VS Code. If you prefer completion to work the same way as at the console, refer my custom settings JSON in the book’s GitHub repository.</p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding parameter aliases</h1>
                </header>
            
            <article>
                
<div>
<p>We worked with aliases for cmdlets, we saw how to uniquely identify parameter names without having to type the entire parameter name, and we also looked at leveraging the power of tab completion. </p>
</div>
<div>
<p>To complete the cycle, let us also look at parameter aliases. </p>
</div>
<div>
<p>As you may have guessed, parameter aliases work very similar to cmdlet aliases. The primary goal of these aliases is to reduce keystrokes. </p>
</div>
<div>
<p>Parameter aliases are not documented in a friendly way, however, can be easily found thanks to the object-oriented model of PowerShell. In this recipe, we shall look at how to fetch parameter aliases. </p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>Find all the commands that take in <kbd>ComputerName</kbd> as a parameter, with minimal keystrokes.</p>
<pre>get-comm&lt;Tab&gt;-parametern&lt;Tab&gt;Cn</pre>
<p>This resolves to:</p>
<pre>Get-Command -ParameterName Cn</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-327 image-border" src="Images/7de20ecf-5174-4e9e-a5ae-9e024c717114.png" style="width:46.17em;height:26.58em;" width="1450" height="835"/></div>
<p>The output was the same as what we ran a while ago:</p>
<pre>Get-Command -ParameterName ComputerName</pre>
<p>How did PowerShell know that <kbd>Cn</kbd> stands for <kbd>ComputerName</kbd>?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<div>
<p>Parameters are part of cmdlets, and <kbd>Get-Command</kbd> is the cmdlet that fetches information about cmdlets.</p>
<ol>
<li>For this example, let us pick the cmdlet, <kbd>Invoke-Command</kbd>.</li>
</ol>
</div>
<div>
<pre style="padding-left: 90px">Get-Command Invoke-Command </pre></div>
<div>
<ol start="2">
<li>Examine the object that this command outputs. </li>
</ol>
</div>
<div>
<pre style="padding-left: 90px">Get-Command Invoke-Command | Get-Member </pre></div>
<div>
<ol start="3">
<li>The output shows a member called Parameters. Use the member access operator to pick the member. </li>
</ol>
</div>
<div>
<pre style="padding-left: 90px">(Get-Command Invoke-Command).Parameters </pre></div>
<div>
<ol start="4">
<li>See what members this member contains. </li>
</ol>
</div>
<div>
<pre style="padding-left: 90px">(Get-Command Invoke-Command).Parameters | Get-Member </pre></div>
<div>
<ol start="5">
<li>Would Values show us the information we need? </li>
</ol>
</div>
<div>
<pre style="padding-left: 90px">(Get-Command Invoke-Command).Parameters.Values </pre></div>
<div>
<ol start="6">
<li>Yes, that does give us something, but there is too much output. We need only the parameter names and their aliases. </li>
</ol>
</div>
<div>
<pre style="padding-left: 90px">(Get-Command Invoke-Command).Parameters.Values | select Name, Aliases </pre></div>
<div>
<p>There you go.</p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<div>
<p>We saw while reading about the Core and its capabilities, that PowerShell, most of the time, returns objects. And every object can have objects within itself. Going by the same path as that of .NET, a member access operator can be used to select the members (which could be properties or methods). Properties are addressed by simply using the property names, while methods need arguments passed to them (an empty pair of parentheses is still needed if no argument is being passed). </p>
</div>
<div>
<p>The parameters of a cmdlet are objects of the output that the <kbd>Get-Command</kbd> cmdlet returns. Therefore, calling <kbd>Get-Command</kbd> with the cmdlet, <kbd>Invoke-Command</kbd> returns data about <kbd>Invoke-Command</kbd> as the output object. This can be further broken down to several other objects (members), among which, there is <kbd>Parameters</kbd>.</p>
</div>
<div>
<div>
<p><kbd>Parameters</kbd> itself can be further broken down into other members, <kbd>Values</kbd> being one of them—<kbd>Values</kbd> contains the names of the parameters, as revealed by running <kbd>Get-Member</kbd>. </p>
</div>
<div>
<p>We select two objects from within <kbd>Values</kbd>, called <kbd>Name</kbd> and <kbd>Aliases</kbd>. </p>
</div>
<div>
<p>These parameter aliases can be used in place of parameters themselves. </p>
</div>
<div>
<p>There are two caveats with parameter aliases: </p>
</div>
<ul>
<li>They are case-sensitive, which means reaching for the Shift key. </li>
</ul>
</div>
<div>
<ul>
<li>They have to be remembered, even though they have a pattern to them, just like how cmdlet aliases do (<kbd>ip</kbd> for <kbd>Import</kbd> and <kbd>g</kbd> for <kbd>Get</kbd>, for instance).</li>
</ul>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling a PowerShell script</h1>
                </header>
            
            <article>
                
<p>PowerShell scripts are nothing but a series of PowerShell cmdlets, each in a line of a <kbd>ps1</kbd> file. These instructions are executed one after the other, similar to the good old shell script. Using VS Code makes running PowerShell scripts simpler, in that you simply have to run the script to make the script work its magic.</p>
<p>However, running PowerShell scripts on VS Code is not the usual way of automation for obvious reasons. Also, there are many ways to run a PowerShell script. We shall look at a very simple way of running the script in this recipe; as we progress in the book, we will also add more features to our scripts, and further, will package them into modules for future use.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p>This recipe uses VS Code to write the script. While any text or code editor would work for the script, we use VS Code because in my experience, VS Code is the friendliest editor for  PowerShell scripting.</p>
<ol>
<li>Open VS Code, create a new file.</li>
<li>Create a new directory at a convenient location (<kbd>~/Code</kbd>, perhaps?).</li>
<li>Save the empty file as <kbd>hello-world.ps1</kbd> within the directory you just created.</li>
<li>Observe the bottom right of VS Code; it should now say, <kbd>PowerShell</kbd>.</li>
<li>Press <kbd>Ctrl + `</kbd> to close the console at the bottom to reduce distraction.</li>
</ol>
<p>If everything is as shown in the screenshot below, you are good to go. (Ignore the colour of the status bar at the bottom, as well as the git status at the bottom-left for now.)</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-328 image-border" src="Images/23eb3582-a3de-490a-804e-16c977434c72.png" style="width:43.83em;height:34.42em;" width="1638" height="1286"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>At the script pane, type in:</li>
</ol>
<pre style="padding-left: 90px">Write-Host "Hello, World!"</pre>
<ol start="2">
<li>Save (<strong>File</strong> &gt; <strong>Save</strong> or <kbd>Ctrl + S</kbd>) the script.</li>
<li>Click on <strong>Debug</strong> in the left. Alternatively, press <kbd>Ctrl + Shift + D</kbd>. This opens the Debug pane.</li>
<li>Press the green play-button-like <strong>Start debugging</strong> button.</li>
</ol>
<p style="padding-left: 60px">The console should pop out and display <kbd>Hello, World!</kbd>.</p>
<ol start="5">
<li>Let us run the script one more time. This time, we will not open the Debug pane or press buttons on the screen. Simply, press <kbd>F5</kbd>.</li>
</ol>
<p style="padding-left: 60px"><kbd>Hello, World!</kbd> should again be displayed in the console.</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-329 image-border" src="Images/0ab2165b-fadb-4c0e-b8e4-b87e283c3067.png" style="width:41.25em;height:32.42em;" width="1638" height="1286"/></div>
<p>Let us now call the script without using the debug controls.</p>
<ol>
<li>Close the file (Ctrl + W).</li>
<li>At the prompt on the console, type in:</li>
</ol>
<pre style="padding-left: 90px">./hello-world.ps1</pre>
<p style="padding-left: 60px">You should see <kbd>Hello, World!</kbd> appear.</p>
<ol start="3">
<li>Now, navigate to home.</li>
<li>Next, type <kbd>&amp;</kbd>, add a space, <kbd>./</kbd> and start typing the path to where you stored the script. Use tab completion just like how you would on Bash.</li>
<li>When you reach the location of the script file, press Enter to call the file.</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-330 image-border" src="Images/7d6b31d4-f323-4db3-81a8-b7aaa3faf1b9.png" style="width:39.58em;height:31.08em;" width="1638" height="1286"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The simplest way to run a PowerShell script is to debug it at the Integrated Scripting Environment. We use VS Code as our ISE of choice in this case. The other two ways of calling<span> the script </span>described in this recipe are from the PowerShell console. You may use the integrated console in VS Code, or a PowerShell console called at the Terminal for this purpose.</p>
<p>When the script is located at the present working directory, PowerShell just calls the <kbd>ps1</kbd> file and executes it. Another way of calling PowerShell scripts is to use <kbd>&amp;</kbd> (or the <strong>call operator</strong>): type <kbd>&amp;</kbd> followed by a space, followed by the path to the script file. This way of calling handles spaces in the path well.</p>
<p>If the path to the script contains spaces, the path would need to be surrounded by quotes. This would make PowerShell think that you are simply giving it a string value. PowerShell would, then, simply display the path as text the moment you press Enter.</p>
<p>When you use the <kbd>&amp;</kbd> call operator, you tell PowerShell that you want to run a script (or a command).</p>
<p>Another way of calling scripts is to use <kbd>.</kbd> (or the <strong>dot operator</strong>), which we shall look at in the next recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dot-sourcing a PowerShell script</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we saw how to call PowerShell scripts from outside of the ISE. We gave PowerShell the path, and explicitly mentioned that we would like it to run the script, by using a call operator.</p>
<p>This way is ideal if you would just like the script to perform its task and not leave anything behind, like variable values and such. However, there are situations wherein we would like to run a script and, say, retain values of the variables we declared and assigned in them, or use the functions we declared in them.</p>
<p>In such situations where we would like the functions, variables and even aliases retained in the current session, we use dot-sourcing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you deleted the file after the previous recipe, restore it or recreate it using the steps in the previous recipe. Then,</p>
<ol>
<li>Open the script file that you created in the previous recipe. At the second line, type the following.</li>
</ol>
<pre style="padding-left: 90px">$Message = "I was dot-sourced!"</pre>
<ol start="2">
<li>Save the script. Do not run it yet.</li>
<li>Place your cursor at the integrated console, and call the script using the call operator.</li>
</ol>
<pre style="padding-left: 90px">&amp; ./hello-world</pre>
<ol start="4">
<li>We declared $Message and assigned a string value to it. Call the variable to see what value it contains.</li>
</ol>
<pre style="padding-left: 90px">$Message</pre>
<p style="padding-left: 60px">Nothing.</p>
<ol start="5">
<li>Now, dot-source the script. (There are two dots; one is the operator, and the other after the space is reference to the current directory.)</li>
</ol>
<pre style="padding-left: 90px">. ./hello-world.ps1</pre>
<ol start="6">
<li>Call the $Message variable again.</li>
</ol>
<pre style="padding-left: 90px">$Message</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-331 image-border" src="Images/a0c0e9b2-1b76-46b1-97de-239dcda9adea.png" style="width:41.58em;height:32.67em;" width="1638" height="1286"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When a script or a command is called using the call operator, the script or command is simply run without the current session (or technically, scope) being modified. The command or script runs and exits without changing anything pertaining to the session, including changes to built-in/automatic variables.</p>
<p>When changes to the scope are desired, the script or command must be dot-sourced. This way, whatever variables, functions or aliases are defined in it, are retained in the current scope.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Create a new alias using <kbd>New-Alias</kbd> within the <kbd>hello-world.ps1</kbd> script. Try to get the value of the alias after first calling the script (using the debug control, as well as using the call operator), and then, by dot-sourcing the script. Observe the outcomes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling a PowerShell cmdlet from outside of PowerShell</h1>
                </header>
            
            <article>
                
<p>So far we have learnt to call cmdlets from the console, run scripts at the ISE, and call scripts in two modes. In this very short recipe, we shall learn how to call a PowerShell cmdlet from outside of PowerShell.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open a Terminal window.</li>
<li>At the prompt, type:</li>
</ol>
<pre style="padding-left: 90px">pwsh -h</pre>
<ol start="3">
<li>Read the syntax for the command.</li>
<li>At the prompt, type:</li>
</ol>
<pre style="padding-left: 90px">pwsh -c Get-ChildItem</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-332 image-border" src="Images/23321ef5-fc49-4e61-a77e-e957c0051db9.png" style="width:41.83em;height:24.08em;" width="1450" height="835"/></div>
<ol start="5">
<li>Let us now run the <kbd>hello-world.ps1</kbd> script.</li>
</ol>
<pre style="padding-left: 90px">pwsh -f ./Documents/code/github/powershell/chapter-3/hello-world.ps1</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-333 image-border" src="Images/705055a1-23b9-4322-bb0b-ee77122284eb.png" style="width:43.17em;height:24.83em;" width="1450" height="835"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>PowerShell is not an application that runs on top of Bash. PowerShell is a shell itself. However, it can be called from with Bash just like another application. Like applications, the <kbd>pwsh</kbd> command takes in arguments, which are then processed by PowerShell.</p>
<p>The two main ways we may want to use PowerShell from within Bash is to run a single command, or call a script file. You can even call a script block, however, this must be done from within PowerShell. In most cases, running single cmdlets or calling a script should suffice.</p>
<p>In general, when calling <kbd>pwsh</kbd> with cmdlets, make <kbd>-Command</kbd> (or <kbd>-c</kbd>) the last parameter, since anything that comes after the cmdlet itself is considered cmdlet arguments. Same goes for <kbd>-File</kbd> as well.</p>
<p>When a script is designed to accept arguments, the script arguments can be passed after the script name, just like with cmdlets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Recording the cmdlets run on the PowerShell console</h1>
                </header>
            
            <article>
                
<p>Often, there are situations in which you perform a series of tasks on your PowerShell console, and after quite some trial-and-error, come across a solution. And then, you wish you had recorded everything you did on the console. You could still copy content from the console, so you try to scroll up. But you can only go so far. Your command history (a little like Bash history) can help you, but sometimes, that feels limited as well.</p>
<p>A few months ago, we were troubleshooting a sync issue between two of their software update distribution systems which were supposed to work in sync. After some of us were done beating around the GUI, (of course) we decided to pick PowerShell to fix the issue. We ran a series of commands, and after a few hours of fighting with the systems, the systems yielded, and we were back up and running.</p>
<p>Our managers asked for all the steps that we took to achieve this, so that they could be documented for future use. Of course I cannot tell you all the steps that we took—because: a) scope of the book, and b) agreements with our clients—but I can tell you what can help in such situations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Start PowerShell at the terminal, or use the PowerShell Integrated Console on VS Code.</p>
<ol>
<li>Run the following command:</li>
</ol>
<pre style="padding-left: 90px">Start-Transcript -Path ./command-transcript.txt</pre>
<ol start="2">
<li>You can also simply run the cmdlet without any arguments; it would automatically create a text file with an auto-generated file name. Get the current system date and time</li>
</ol>
<pre style="padding-left: 90px">Get-Date</pre>
<ol start="3">
<li>List out all the files and directories in the current location.</li>
</ol>
<pre style="padding-left: 90px">Get-ChildItem .</pre>
<ol start="4">
<li>Create a new directory.</li>
</ol>
<pre style="padding-left: 90px">New-Item test-transcript -ItemType Directory</pre>
<ol start="5">
<li>Create a new file within the directory.</li>
</ol>
<pre style="padding-left: 90px">New-Item -Path test-transcript/testing-transcript.txt -ItemType File</pre>
<ol start="6">
<li>Add content to the file.</li>
</ol>
<pre style="padding-left: 90px">@'<br/>In publishing and graphic design, lorem ipsum is a placeholder text commonly used to demonstrate the visual form of a document without relying on meaningful content (also called greeking).<br/>Replacing the actual content with placeholder text allows designers to design the form of the content before the content itself has been produced.<br/>—Wikipedia<br/>'@ | Out-File ./test-transcript/testing-transcript.txt -Append</pre>
<ol start="7">
<li>Delete the directory.</li>
</ol>
<pre style="padding-left: 90px">Remove-Item -Path ./test-transcript -Recurse</pre>
<ol start="8">
<li>Stop recording what you did.</li>
</ol>
<pre style="padding-left: 90px">Stop-Transcript</pre>
<ol start="9">
<li>You should have now received the location of the transcript file. Read the contents of the file.</li>
</ol>
<pre style="padding-left: 90px">Get-Content -Path ./command-transcript.txt</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-334 image-border" src="Images/3b8eda4d-a326-4155-b8ea-67f3d63f7aa3.png" style="width:45.17em;height:26.00em;" width="1450" height="835"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A transcript created by running <kbd>Start-Transcript</kbd> stores all of your actions and the console output of all of the commands you ran, in a text file. The transcript also contains some of other useful information pertaining to the context the commands were run in.</p>
<p>A transcript file is a little more than a history file, in that the former contains the output of the commands, apart from the commands themselves.</p>
<p>The <kbd>Start-Transcript</kbd> cmdlet does not require any argument at all; it can create a text file at the user's home, with a unique name to ensure that no other transcript is rewritten. In other words, <kbd>Path</kbd> is an optional parameter.</p>
<p>This concludes this chapter about preparing for administration using PowerShell. It's time to crack your knuckles and refill your coffee mug. Did I tell you coffee speeds up thinking in PowerShell? Placebo, you say? Let's not get into an argument right now.</p>


            </article>

            
        </section>
    </div>



  </body></html>