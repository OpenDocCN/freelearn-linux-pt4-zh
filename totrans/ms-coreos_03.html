<html><head></head><body>
<p id="filepos216260" class="calibre_"><span class="calibre1"><span class="bold">Chapter 3. CoreOS Autoupdate</span></span></p><p class="calibre_8">One of the missions of CoreOS is to keep the operating system as secure as possible. One way to achieve this is to keep the OS up to date with the latest patches. The CoreOS automatic update scheme provides you with a secure, reliable, and robust mechanism that provides pushed updates. CoreOS provides enough controls to the user to control the update based on their environment.</p><p class="calibre_8">This chapter will cover the following topics:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">The CoreOS release cycle</li><li value="2" class="calibre_13">The partition scheme used in CoreOS</li><li value="3" class="calibre_13">The CoreOS automatic update infrastructure</li><li value="4" class="calibre_13">The configuration of the CoreOS update</li><li value="5" class="calibre_13">The CoreUpdate commercial service from CoreOS</li></ul><p class="calibre_8">All examples from this chapter will use CoreOS in the AWS environment. There is a section on <span class="italic">Vagrant CoreOS update</span> where Vagrant-specific CoreOS updates are mentioned.</p><div class="mbp_pagebreak" id="calibre_pb_75"/>


<p id="filepos217656" class="calibre_9"><span class="calibre1"><span class="bold">The CoreOS release cycle</span></span></p><p class="calibre_8">Alpha, Beta, and <a/>Stable are release channels within CoreOS. CoreOS releases progress through each channel in this order: Alpha-&gt;Beta-&gt;Stable. An Alpha channel is a <a/>development channel. An Alpha release in the Alpha channel gets promoted to the Beta channel after reaching defined quality level and becomes a Beta release. A Beta release in the Beta channel gets promoted to the Stable channel when it gets to production quality and becomes a Stable release. All releases get started as Alpha, but the promotion to Beta and Stable happens on the basis of testing.</p><p class="calibre_8">The CoreOS release<a/> page reflects the latest Alpha, Beta, and Stable releases (<a href="https://coreos.com/releases/">https://coreos.com/releases/</a>). The following are the latest releases as of August 19, 2015:</p><p class="calibre_9"><img src="images/00401.jpg" class="calibre_78"/></p><p class="calibre_8">
</p><p class="calibre_8">The major version number (for example, <span class="bold">766</span> in <span class="bold">766.3.0</span>) is the number of days from July 13, 2013, which was the CoreOS epoch.</p><p class="calibre_8">As CoreOS is <a/>composed of multiple system components such as etcd, fleet, flannel, Docker, and RKT, every release will have a particular version of the system components<a/> based on the stability of individual components. For example, the following are the versions of the critical system components as of CoreOS version <span class="bold">808.0.0</span>:</p><p class="calibre_9"><img src="images/00404.jpg" class="calibre_79"/></p><p class="calibre_8">
</p><p class="calibre_8">The following command can be used to check the CoreOS version in the node. The node here is running image <tt class="calibre2">723.3.0</tt>, which was a stable release at that point:</p><p class="calibre_9"><img src="images/00036.jpg" class="calibre_80"/></p><p class="calibre_8">
</p><p class="calibre_8">The following command<a/> can be used to check the CoreOS Linux kernel version:</p><p class="calibre_9"><img src="images/00411.jpg" class="calibre_81"/></p><p class="calibre_8">
</p><p class="calibre_8">The following are <a/>versions of critical system components in CoreOS release 723.3.0:</p><p class="calibre_9"><img src="images/00413.jpg" class="calibre_82"/></p><p class="calibre_8">
</p><div class="mbp_pagebreak" id="calibre_pb_76"/>


<p id="filepos220514" class="calibre_"><span class="calibre1"><span class="bold">The partition table on CoreOS</span></span></p><p class="calibre_8">The partition<a/> table shows you the disk partitions maintained by the OS. The<a/> following image shows you a partition table in one of the <a/>CoreOS cluster nodes using the <tt class="calibre2">sudo cgpt show /dev/xvda</tt> command:</p><p class="calibre_9"><img src="images/00084.jpg" class="calibre_83"/></p><p class="calibre_8">
</p><p class="calibre_8">The following<a/> screenshot shows the <tt class="calibre2">df –k</tt> output in the same node:</p><p class="calibre_9"><img src="images/00105.jpg" class="calibre_84"/></p><p class="calibre_8">
</p><p class="calibre_8">The following are some notes on the preceding two outputs:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">There are nine partitions in total. The key partitions are <tt class="calibre2">USR-A</tt>, <tt class="calibre2">USR-B</tt>, <tt class="calibre2">OEM</tt>, and <tt class="calibre2">ROOT</tt>.</li><li value="2" class="calibre_13">System files are in the <tt class="calibre2">USR</tt> partition, user files are in the <tt class="calibre2">ROOT</tt> partition, and provider-related files are in the <tt class="calibre2">OEM</tt> partition.</li><a/><li value="3" class="calibre_13">The <tt class="calibre2">USR</tt> partition is mounted as read-only, and the <tt class="calibre2">ROOT</tt> partition is mounted as read-write.</li><li value="4" class="calibre_13">The <tt class="calibre2">ROOT</tt> partition gets mounted as <tt class="calibre2">/</tt>, the <tt class="calibre2">USR-A</tt> or <tt class="calibre2">USR-B</tt> partition gets mounted in <tt class="calibre2">/usr</tt>, and the <tt class="calibre2">OEM</tt> partition gets mounted in <tt class="calibre2">/usr/share/oem</tt>.</li><a/><li value="5" class="calibre_13">There are two <tt class="calibre2">/usr</tt> partitions, <tt class="calibre2">USR-A</tt> and <tt class="calibre2">USR-B</tt>. By default, the system comes up with the <tt class="calibre2">USR-A</tt> partition. When the CoreOS update is done, the root partition is downloaded to <tt class="calibre2">USR-B</tt> and, using persistent flags such as <tt class="calibre2">priority</tt>, <tt class="calibre2">tries</tt>, and <tt class="calibre2">successful</tt>, the CoreOS bootloader selects the appropriate USR partition on bootup. In the preceding example, the <tt class="calibre2">USR-A</tt> partition has priority set to <tt class="calibre2">1</tt> and the <tt class="calibre2">USR-B</tt> partition has priority set to <tt class="calibre2">0</tt>, and the CoreOS bootloader picks <tt class="calibre2">USR-A</tt>.</li></ul><p class="calibre_8">I did a manual update of OS and the following output shows the active partition being <tt class="calibre2">USR-B</tt> with priority for <tt class="calibre2">USR-B</tt> being higher. The manual update of the CoreOS system can be done using the command specified in the following <span class="italic">Update examples</span> section. The <tt class="calibre2">/usr</tt> directory is now pointing to <tt class="calibre2">/dev/xvda4</tt>, which is <tt class="calibre2">USR-B</tt>, and it was earlier pointing to <tt class="calibre2">/dev/xvda3</tt>, which was <tt class="calibre2">USR-A</tt>:</p><p class="calibre_9"><img src="images/00257.jpg" class="calibre_85"/></p><p class="calibre_8">
</p><div class="mbp_pagebreak" id="calibre_pb_77"/>


<p id="filepos223651" class="calibre_"><span class="calibre1"><span class="bold">CoreOS automatic update</span></span></p><p class="calibre_8">CoreOS relies on the<a/> automatic update mechanism to<a/> keep the OS up to date. The following are some aspects of the CoreOS update:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">The CoreOS update mechanism is based on Google's open source Omaha protocol (<a href="https://code.google.com/p/omaha/">https://code.google.com/p/omaha/</a>) that is used in the Chrome browser.</li><li value="2" class="calibre_13">Either CoreOS public servers or private servers can be used as an image repository.</li><li value="3" class="calibre_13">The dual partition scheme is used where an update is done to the secondary partition while the primary partition is not touched. On reboot, there is a binary swap from the primary to the secondary partition. This keeps the update scheme robust. If there are issues with the new image, CoreOS automatically rolls back to the working image in the other partition.</li><a/><li value="4" class="calibre_13">Images are signed and verified on each update.</li></ul><p class="calibre_8">The following screenshot shows you the steps for the automatic update:</p><p class="calibre_9"><img src="images/00259.jpg" class="calibre_86"/></p><p class="calibre_8">
</p><div class="mbp_pagebreak" id="calibre_pb_78"/>


<p id="filepos225202" class="calibre_"><span class="calibre1"><span class="bold">Update and reboot services</span></span></p><p class="calibre_8">There are<a/> two critical services controlling update and reboot in CoreOS. They are <tt class="calibre2">update-engine.service</tt> and<a/>
<tt class="calibre2">locksmithd.service</tt>.</p><div class="mbp_pagebreak" id="calibre_pb_79"/>


<p id="filepos225537" class="calibre_9"><span class="calibre3"><span class="bold">Update-engine.service</span></span></p><p class="calibre_8"><tt class="calibre2">Update-engine.service</tt> takes care of periodically checking for updates from the appropriate release channel <a/>specified. A default check for update is done 10 minutes after reboot or at one-hour intervals.</p><p class="calibre_8">The following output shows you the status of update-engine.service:</p><p class="calibre_9"><img src="images/00261.jpg" class="calibre_87"/></p><p class="calibre_8">
</p><p class="calibre_8">The release channel is specified in <tt class="calibre2">/etc/coreos/update.conf</tt>. In the following node, the release channel is selected as stable. The release channel is derived from <tt class="calibre2">cloud-config</tt>:</p><p class="calibre_9"><img src="images/00263.jpg" class="calibre_88"/></p><p class="calibre_8">
</p><p class="calibre_8"><tt class="calibre2">Update-engine.service</tt> takes care of updating the appropriate partition, <tt class="calibre2">USR-A</tt> or <tt class="calibre2">USR-B</tt>. The currently used partition is not touched.</p><p class="calibre_8">The following command can be executed to trigger a manual update:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">update_engine_client -check_for_update</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p id="filepos227018" class="calibre_9"><span class="calibre3"><span class="bold">Debugging update-engine.service</span></span></p><p class="calibre_8">Logs for the <a/>update service can be checked using <tt class="calibre2">journalctl –u update-engine.service</tt>. From the logs, we can identify the Omaha protocol request and response, and debugging can be done using error codes in the response.</p><div class="mbp_pagebreak" id="calibre_pb_80"/>


<p id="filepos227435" class="calibre_9"><span class="calibre3"><span class="bold">Locksmithd.service</span></span></p><p class="calibre_8"><tt class="calibre2">Locksmithd.service</tt> takes<a/> care of rebooting the CoreOS node using the selected reboot strategy. <tt class="calibre2">Locksmithd.service</tt> runs as a daemon.</p><p class="calibre_8">The following output shows you the status of <tt class="calibre2">locksmithd.service</tt>:</p><p class="calibre_9"><img src="images/00266.jpg" class="calibre_89"/></p><p class="calibre_8">
</p><p id="filepos228008" class="calibre_9"><span class="calibre3"><span class="bold">Locksmith strategy</span></span></p><p class="calibre_8">The following are<a/> the four configurable strategies for the CoreOS node reboot<a/> after a new image update.</p><p id="filepos228262" class="calibre_9"><span class="bold">The etcd-lock scheme</span></p><p class="calibre_8">In this scheme, the reboot is done after first taking a lock from <tt class="calibre2">etcd</tt>. In a multinode cluster, this works out really well as it prevents all the nodes from rebooting at the same time and maintains<a/> cluster integrity. We can control the number of nodes that can reboot together using the lock count mechanism. The lock <tt class="calibre2">max</tt> count specifies the number of nodes that can acquire a lock simultaneously. In a three-node cluster, we need to limit the lock <tt class="calibre2">max</tt> count to <tt class="calibre2">1</tt>, but in a five-node cluster, we can keep the lock <tt class="calibre2">max</tt> count up to <tt class="calibre2">2</tt>, which allows a maximum of two nodes to acquire lock and reboot simultaneously. </p><p class="calibre_8">The following example shows you how the available lock count varies when we do the locking and unlocking operation:</p><p class="calibre_9"><img src="images/00268.jpg" class="calibre_90"/></p><p class="calibre_8">
</p><p id="filepos229373" class="calibre_9"><span class="bold">Reboot</span></p><p class="calibre_8">In this scheme, the node is rebooted immediately without taking a lock from the cluster. This is useful in<a/> scenarios where the upgrade is manually controlled by the administrator.</p><p id="filepos229662" class="calibre_9"><span class="bold">Best-effort</span></p><p class="calibre_8">In this scheme, it is first <a/>checked whether <tt class="calibre2">etcd</tt> is running. If <tt class="calibre2">etcd</tt> is running, the <tt class="calibre2">etcd</tt> lock is acquired and then the rebooting is done. Otherwise, reboot is done immediately. This is a variation of the etcd-lock scheme mentioned before.</p><p id="filepos230043" class="calibre_9"><span class="bold">Off</span></p><p class="calibre_8">This causes locksmithd to<a/> exit and do nothing. This option should not be chosen unless the administrator wants to control the upgrades with great precision.</p><p id="filepos230306" class="calibre_9"><span class="calibre3"><span class="bold">Groups</span></span></p><p class="calibre_8">Locksmith groups were<a/> introduced in locksmithd version 0.3.1. With groups, we can group a set of CoreOS nodes and locking will be applicable to this group. For example, let's say that we have a five-node cluster and two nodes are running load balancers. If we set the lock-max-count to <tt class="calibre2">2</tt>, it is possible that both the nodes running load balancers can reboot at the same time and we can lose that service during this period. To avoid this issue, we can set a different lock <tt class="calibre2">max</tt> count for the default group and the <tt class="calibre2">lb</tt> group.</p><p class="calibre_8">In the example shown in following screenshot, we have set the lock count of <tt class="calibre2">2</tt> for the default group and lock count of <tt class="calibre2">1</tt> for the <tt class="calibre2">lb</tt> group. Groups can be defined as part of starting the <tt class="calibre2">locksmithd service</tt>. To put a CoreOS node in<a/> a locksmith group, we need to start locksmithd with the <tt class="calibre2">--group</tt> option or set the <tt class="calibre2">LOCKSMITHD_GROUP</tt> environment variable and restart the locksmithd service:</p><p class="calibre_9"><img src="images/00270.jpg" class="calibre_91"/></p><p class="calibre_8">
</p><p id="filepos231637" class="calibre_9"><span class="calibre3"><span class="bold">Locksmithctl</span></span></p><p class="calibre_8">Locksmithctl is a<a/> frontend CLI to control locksmith. Using this, we can get the status of locksmith service, lock and unlock groups, set the <tt class="calibre2">lock max</tt> count, and so on.</p><p id="filepos231951" class="calibre_9"><span class="calibre3"><span class="bold">Debugging locksmithd.service</span></span></p><p class="calibre_8">Logs for this service <a/>can be checked with <tt class="calibre2">journalctl –u locksmithd.service</tt>.</p><div class="mbp_pagebreak" id="calibre_pb_81"/>


<p id="filepos232207" class="calibre_"><span class="calibre1"><span class="bold">Setting update options</span></span></p><p class="calibre_8">CoreOS update<a/> options can be set using either <tt class="calibre2">cloud-config</tt> or by changing configuration files manually. Using <tt class="calibre2">cloud-config</tt>, update options are configured <a/>as part of the node configuration after reboot. With the manual approach, we need to start the appropriate update services for changes to take effect. The manual approach is used mainly to debug.</p><div class="mbp_pagebreak" id="calibre_pb_82"/>


<p id="filepos232760" class="calibre_9"><span class="calibre3"><span class="bold">Using cloud-config</span></span></p><p class="calibre_8">The following is a<a/> sample <tt class="calibre2">cloud-config</tt> with the release <a/>channel group set to <tt class="calibre2">stable</tt> and the locksmith reboot <a/>strategy set to <tt class="calibre2">etcd-lock</tt>. (The default server used is <a href="https://public.update.core-os.net/">https://public.update.core-os.net/</a>, so this is not specified here.)</p><p class="calibre_8"><tt class="calibre2">#cloud-config<br class="calibre4"/>coreos:<br class="calibre4"/>  etcd2:<br class="calibre4"/>    # specify the initial size of your cluster with ?size=X<br class="calibre4"/>    discovery: https://discovery.etcd.io/eb32a1397bd087f84e65ab802b6aa2f7<br class="calibre4"/>    advertise-client-urls: http://$private_ipv4:2379,http://$private_ipv4:4001<br class="calibre4"/>    initial-advertise-peer-urls: http://$private_ipv4:2380<br class="calibre4"/>    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001<br class="calibre4"/>    listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001<br class="calibre4"/>  update:<br class="calibre4"/>    reboot-strategy: "etcd-lock"<br class="calibre4"/>    group: "stable"<br class="calibre4"/>  units:<br class="calibre4"/>    - name: etcd2.service<br class="calibre4"/>      command: start<br class="calibre4"/>    - name: fleet.service<br class="calibre4"/>      command: start</tt></p><p class="calibre_8">After starting the <a/>cluster using the preceding <tt class="calibre2">cloud-config</tt>, we can check whether <tt class="calibre2">/etc/coreos/update.conf</tt> is updated with the correct parameters:</p><p class="calibre_9"><img src="images/00273.jpg" class="calibre_92"/></p><p class="calibre_8">
</p><div class="mbp_pagebreak" id="calibre_pb_83"/>


<p id="filepos234500" class="calibre_9"><span class="calibre3"><span class="bold">Manual configuration</span></span></p><p class="calibre_8">The default reboot strategy<a/> is <tt class="calibre2">best-effort</tt>. In the following node, the reboot strategy is not specified, so it is using best-effort:</p><p class="calibre_9"><img src="images/00275.jpg" class="calibre_93"/></p><p class="calibre_8">
</p><p class="calibre_8">Let's change the reboot strategy to <tt class="calibre2">reboot</tt> in <tt class="calibre2">/etc/coreos/update.conf</tt>. We need to restart <tt class="calibre2">locksmithd.service</tt>:</p><p class="calibre_9"><img src="images/00277.jpg" class="calibre_94"/></p><p class="calibre_8">
</p><p class="calibre_8">As shown in the <a/>following logs, the reboot strategy is taking effect:</p><p class="calibre_9"><img src="images/00280.jpg" class="calibre_95"/></p><p class="calibre_8">
</p><div class="mbp_pagebreak" id="calibre_pb_84"/>


<p id="filepos235587" class="calibre_"><span class="calibre1"><span class="bold">Update examples</span></span></p><p class="calibre_8">We can do updates<a/> within the same release channel or across release channels. If we do updates in the same release channel, the node gets updated to the latest version in that release channel. If we do updates across release channels, the node gets updated to the latest version in the new release channel.</p><div class="mbp_pagebreak" id="calibre_pb_85"/>


<p id="filepos236065" class="calibre_9"><span class="calibre3"><span class="bold">Updating within the same release channel</span></span></p><p class="calibre_8">Let's look at the<a/> initial version and reboot strategy. The node is running stable version 723.3.0 as shown in the following screenshot:</p><p class="calibre_9"><img src="images/00282.jpg" class="calibre_96"/></p><p class="calibre_8">
</p><p class="calibre_8">Looking at the CoreOS releases page, the latest STABLE release is 766.3.0. If we do an update on the STABLE channel, the node should get updated to 766.3.0.</p><p class="calibre_8">Let's trigger the<a/> update manually with the following command:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">update_engine_client -check_for_update</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">If we don't trigger the update manually, <tt class="calibre2">update-engine</tt> will still do the update based on its periodic checks.</p><p class="calibre_8">The following logs from <tt class="calibre2">update-engine.service</tt> show the Omaha request to the CoreOS public imaging server:</p><p class="calibre_9"><img src="images/00284.jpg" class="calibre_97"/></p><p class="calibre_8">
</p><p class="calibre_8">The following logs from update-engine show the Omaha response from the CoreOS public server giving the image with version 766.3.0:</p><p class="calibre_9"><img src="images/00287.jpg" class="calibre_98"/></p><p class="calibre_8">
</p><p class="calibre_8">After the update is successful, the following message appears on the node from <tt class="calibre2">locksmithd.service,</tt> indicating that the node will be updated with the new image. The new image is updated<a/> to the non-active USR partition:</p><p class="calibre_9"><img src="images/00289.jpg" class="calibre_99"/></p><p class="calibre_8">
</p><p class="calibre_8">The following is the node version after reboot. We can see that the version is upgraded successfully to 766.3.0:</p><p class="calibre_9"><img src="images/00291.jpg" class="calibre_100"/></p><p class="calibre_8">
</p><div class="mbp_pagebreak" id="calibre_pb_86"/>


<p id="filepos238584" class="calibre_9"><span class="calibre3"><span class="bold">Updating from one release channel to another</span></span></p><p class="calibre_8">We can switch release <a/>channels by updating <tt class="calibre2">/etc/coreos/update.conf</tt>. These are the steps:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">Update the release channel group from <tt class="calibre2">stable</tt> to <tt class="calibre2">alpha</tt>, as shown in the following screenshots:<p class="calibre_"><img src="images/00294.jpg" class="calibre_101"/></p><p class="calibre_8">
</p></li><li value="2" class="calibre_13">Restart <tt class="calibre2">update-engine.service</tt>:<p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">sudo systemctl restart update-engine</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p></li><li value="3" class="calibre_31">The <tt class="calibre2">update-engine</tt> service will check for an update after 10 minutes. We can force the update with the following command:<p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">update_engine_client -check_for_update</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p></li></ul><p class="calibre_8">The following log <a/>shows you that the version 808.0.0 image is being fetched now:</p><p class="calibre_9"><img src="images/00296.jpg" class="calibre_102"/></p><p class="calibre_8">
</p><p class="calibre_8">The following is the version after the node is rebooted. We can see that the image is upgraded to the latest alpha release <tt class="calibre2">808.0.0</tt>:</p><p class="calibre_9"><img src="images/00300.jpg" class="calibre_103"/></p><p class="calibre_8">
</p><div class="mbp_pagebreak" id="calibre_pb_87"/>


<p id="filepos240446" class="calibre_"><span class="calibre1"><span class="bold">CoreUpdate</span></span></p><p class="calibre_8">CoreUpdate is a<a/> commercial service provided by CoreOS to manage the customer updates of CoreOS clusters. The following are some of the features provided by the <a/>CoreUpdate service:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">The GUI dashboard provides you with a summary and detailed view of all the updates.</li><li value="2" class="calibre_13">Custom image servers will be provided on a per customer basis.</li><li value="3" class="calibre_13">Server groups can be created so that updates can be done in groups and rate limiting can be done on a per group basis.</li><li value="4" class="calibre_13">An HTTP API is provided so that CoreUpdate can be integrated with existing DevOps systems available with the customer.</li><li value="5" class="calibre_13">Images can be hosted on public servers or customer's local servers. This is useful from a security perspective so that customers don't have to worry about opening up their firewall.</li><a/><li value="6" class="calibre_13"><tt class="calibre2">Updateservicectl</tt> is provided as a frontend CLI.</li></ul><div class="mbp_pagebreak" id="calibre_pb_88"/>


<p id="filepos241809" class="calibre_"><span class="calibre1"><span class="bold">Vagrant CoreOS update</span></span></p><p class="calibre_8">If the Vagrant box is already downloaded, the new CoreOS version will be updated only if the box is updated.</p><p class="calibre_8">Even though we<a/> change the version in Vagrantfile from stable to alpha to beta, the new CoreOS version does not get updated on <tt class="calibre2">vagrant reload --provision</tt>. Only when we perform vagrant destroy and restart, the new version gets loaded. We can directly trigger an update from the CoreOS node using <tt class="calibre2">update-engine</tt>, and it works irrespective of the VBOX version.</p><p class="calibre_8">We get the following message when Vagrant CoreOS is not up to date:</p><p class="calibre_9"><img src="images/00302.jpg" class="calibre_104"/></p><p class="calibre_8">
</p><p class="calibre_8">To update the Vagrant box version, we can perform <tt class="calibre2">vagrant box update</tt> as shown in the following screenshot:</p><p class="calibre_9"><img src="images/00304.jpg" class="calibre_105"/></p><p class="calibre_8">
</p><p class="calibre_8">The <tt class="calibre2">vagrant reload</tt> command or <tt class="calibre2">vagrant reload --provision</tt> command do not help to update the CoreOS <a/>version. We need to destroy and recreate the cluster to get the latest version.</p><div class="mbp_pagebreak" id="calibre_pb_89"/>


<p id="filepos243339" class="calibre_"><span class="calibre1"><span class="bold">Summary</span></span></p><p class="calibre_8">In this chapter, we covered different aspects of the CoreOS update, including the CoreOS release cycle, services controlling the CoreOS update, and options available to customers to control their cluster's update strategy. The CoreOS update mechanism is simple, unique, and robust, and it takes care of the biggest concern in the cloud, which is security. In the next chapter, we will cover details on critical CoreOS services—<tt class="calibre2">systemd</tt>, <tt class="calibre2">etcd</tt>, and <tt class="calibre2">fleet</tt>.</p><div class="mbp_pagebreak" id="calibre_pb_90"/>


<p id="filepos243962" class="calibre_"><span class="calibre1"><span class="bold">References</span></span></p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">CoreOS releases: <a href="https://coreos.com/releases/">https://coreos.com/releases/</a></li><a/><li value="2" class="calibre_13">CoreOS update philosophy: <a href="https://coreos.com/using-coreos/updates/">https://coreos.com/using-coreos/updates/</a></li><a/><li value="3" class="calibre_13">CoreUpdate service: <a href="https://coreos.com/products/coreupdate/">https://coreos.com/products/coreupdate/</a></li><a/><li value="4" class="calibre_13">Locksmith GitHub page: <a href="https://github.com/coreos/locksmith">https://github.com/coreos/locksmith</a></li><a/><li value="5" class="calibre_13">Update strategies: <a href="https://coreos.com/os/docs/latest/update-strategies.html">https://coreos.com/os/docs/latest/update-strategies.html</a></li><a/></ul><div class="mbp_pagebreak" id="calibre_pb_91"/>


<p id="filepos245016" class="calibre_"><span class="calibre1"><span class="bold">Further reading and tutorials</span></span></p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">The anatomy of a CoreOS update: <a href="https://www.youtube.com/watch?v=JeICd9XyXfY">https://www.youtube.com/watch?v=JeICd9XyXfY</a></li><a/><li value="2" class="calibre_13">The Omaha update protocol: <a href="https://github.com/google/omaha">https://github.com/google/omaha</a> and <a href="https://coreos.com/docs/coreupdate/custom-apps/coreupdate-protocol/">https://coreos.com/docs/coreupdate/custom-apps/coreupdate-protocol/</a></li><a/></ul><div class="mbp_pagebreak" id="calibre_pb_92"/>
</body></html>