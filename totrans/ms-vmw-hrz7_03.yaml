- en: Understanding Horizon 7 Architecture and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced you to virtual desktop infrastructure
    and, in particular, the VMware solution, VMware Horizon. As part of that introduction,
    we took a high-level view of some of the different components that make up the
    complete solution. In this chapter, we will start to take a deeper dive into these
    architecture and infrastructure components, concentrating on how they work together
    to make up the complete solution.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the sections of this chapter, we will discuss the role of each of
    the Horizon View components, explaining where each one fits into the overall infrastructure,
    and its role. Once we have explained the high-level concept, we will then take
    a deeper dive into how each individual component works. As we work through the
    sections, we will also highlight some of the best practices, as well as some useful
    hints and tips along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the way, we will also cover some of the third-party technologies that
    integrate and complement VMware Horizon, such as antivirus solutions, storage
    acceleration technologies, and high-end graphics solutions, which all help deliver
    a complete end-to-end solution from the data center to the end user. After reading
    this chapter, you will be able to describe each of the Horizon components, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connection server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replica server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and the VMware Unified Access Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing end user profiles in **View Persona Management** (**VDI**) and **User
    Environment Manager** (**UEM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked, instant, and full clones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware-accelerated graphics (vSGA, vDGA, and vGPU)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss what part each one plays within the overall solution, and why
    you would use them, along with how to configure them and the prerequisites for
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the key Horizon components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with, we are going to introduce you to, at a high level, the core
    infrastructure components and the architecture that make up the Horizon View solution.
    We will start with a top-level overview, as shown in the following diagram, before
    we start to drill down into each component in greater detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e500b731-1e9b-4aa7-ab7d-b44a6d077cb0.png)'
  prefs: []
  type: TYPE_IMG
- en: All the VMware Horizon components described in the preceding diagram are part
    of the overall Horizon solution, but, don't forget, some of the features available
    are dependent on which edition you have purchased.
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth remembering that Horizon licensing includes the relevant vSphere
    components, ESXi hypervisor and vCenter Server licensing, to enable you to deploy
    the core hosting infrastructure. You can deploy as many ESXi hosts and vCenter
    servers as you require to host the desktop infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: High-level architectural overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss the core Horizon View features and
    functionality for brokering virtual desktop machines that are hosted on the VMware
    vSphere platform.
  prefs: []
  type: TYPE_NORMAL
- en: The Horizon architecture is straightforward to understand, as its foundations
    lie in the standard VMware vSphere products (ESXi and vCenter). So, if you have
    the skills and experience of working with this platform, then you are already
    halfway there.
  prefs: []
  type: TYPE_NORMAL
- en: Horizon View builds on the vSphere infrastructure, taking advantage of some
    of the features of the ESXi hypervisor and vCenter Server, adding a number of
    virtual server machines to perform the various View roles and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of the View architecture for delivering virtual desktops is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/842ef811-5905-48b4-a877-a78fc312021f.png)'
  prefs: []
  type: TYPE_IMG
- en: Horizon View infrastructure components run as applications that are installed
    on the Microsoft Windows Server operating system, except for the Unified Access
    Gateway, which is a hardened Linux-based appliance. In theory, these infrastructure
    components could run on physical machines; however, there are a great number of
    benefits when you run them as virtual machines, such as delivering HA and DR,
    as well as the typical cost savings that can be achieved through virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections will cover each of these roles and components of the
    View architecture in greater detail, starting with the Horizon View Connection
    Server.
  prefs: []
  type: TYPE_NORMAL
- en: The Horizon View Connection Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Horizon View Connection Server is also referred to as a connection broker
    or a view manager. It is the primary component of the View infrastructure. Its
    primary role is to connect a user to their virtual desktop by means of performing
    user authentication and then delivering and managing the appropriate desktop resources
    based on the user's profile and entitlement. When logging on to your virtual desktop,
    it is the connection server that you are communicating with.
  prefs: []
  type: TYPE_NORMAL
- en: How does the connection server work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user will connect to their VDI desktop using their endpoint device by first
    launching the Horizon Client, but, equally, they could use browser-based access.
    We will cover the Horizon clients and other access methods in [Chapter 12](e1944fcc-6ae9-4db7-b51b-db75e37e01ab.xhtml),
    *Horizon Client Options*.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens next, and how does the login process work? Once the Horizon
    client has launched, the end user enters the address details of the View Connection
    server they want to connect to (**1**), which in turn responds (**2**) by asking
    them to provide their network login details, their Active Directory domain username,
    and their password.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that Horizon View now supports the following different AD
    Domain functional levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Server 2003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Server 2008 and Windows Server 2008 R2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Server 2012 and Windows Server 2012 R2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Server 2016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end users' credentials are authenticated with Active Directory (**3**) and,
    if successful, the user can continue the login process. Depending on what resources
    they are entitled to, the end user will see a launch screen that displays a few
    different virtual desktop machine icons that are available for them to log in
    to. These desktop icons represent the desktop pools that the user has been entitled
    to use. They may well also see application icons representing published applications.
  prefs: []
  type: TYPE_NORMAL
- en: A desktop pool is basically a collection of similar virtual desktop machines.
    For example, it could be a pool for the marketing department where the virtual
    desktop machines contain specific applications and software for that department.
    We will discuss desktop pools in more detail in [Chapter 8](d44c9a7b-bcae-4758-a857-197be388a4be.xhtml),
    *Configuring and Managing Desktop Pools – Part 1*.
  prefs: []
  type: TYPE_NORMAL
- en: Once authenticated, the view manager or the connection server makes a call to
    the vCenter server (**4**) to create a virtual desktop machine, and then vCenter
    makes a call (**5**) to either View Composer (if you are using linked clones),
    or it will create an instant clone using the VM fork feature of vSphere to start
    the build process of the virtual desktop if there is not one already available
    for the user to log in to.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the overall build process, at this point, if configured, VMware UEM
    will load the end user's profile, personalizing and customizing the virtual desktop
    to that individual user. The same applies to VMware app volumes, which, if configured,
    will now deliver any layered applications at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the build process has completed, and the virtual desktop machine is available
    to the end user, complete with their profile and applications, it is displayed
    or delivered within the Horizon Client window (**6**) or browser, using the chosen
    display protocol PCoIP, Blast Extreme, or RDP. This process is described pictorially
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7444ef5-d086-45f5-ad92-1273ef188a2e.png)'
  prefs: []
  type: TYPE_IMG
- en: There are other ways to deploy VDI solutions that do not require a connection
    broker, although you could argue that, strictly speaking, this is not a true VDI
    solution. As we discussed in the introduction and history, this is what the first
    VDI solutions looked like, allowing an end user to connect directly to their own
    virtual desktop via the RDP protocol. If you think about it, though, there are
    still some specific use cases for doing it this way.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a large number of remote branches or offices, you could
    deploy a subset of the infrastructure, hosting it on the local site, allowing
    users to continue working in the event of a WAN outage or poor network communication
    between the branch and head office.
  prefs: []
  type: TYPE_NORMAL
- en: It just so happens that VMware also thought of this as a use case and has a
    solution that's referred to as a **Brokerless View**, which uses the VMware Horizon
    view agent DirectConnection plugin to connect directly to a virtual desktop machine
    without needing the connection server. This was originally part of the Desktone
    **Desktop as a Service** (**DaaS**) solution that VMware acquired in October 2013\.
    However, don't forget that in a Horizon View environment, the view connection
    server provides greater functionality and does much more than just connect users
    to desktops, as we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Along with brokering the connections between the end users and the virtual desktop
    machines, the view connection server also works with the vCenter server to manage
    the virtual desktop machines. For example, when using linked clones or instant
    clones and powering on virtual desktops, these tasks are initiated by the connection
    server, but they are executed by the vCenter server.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered what the connection server is and given you an overview
    of how it works, in the next section, we are going to look at the requirements
    you need in order for it to run.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum requirements for the connection server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install the connection server, you need to meet the following minimum requirements
    to run on physical or virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the hardware required for installing the connection
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ffb6c9e-a63b-4a92-a2f0-cc4a067beac9.png)'
  prefs: []
  type: TYPE_IMG
- en: Supported OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The view connection server must be installed on one of the operating systems
    listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b461a76-6380-45bb-9f38-616afa48023f.png)'
  prefs: []
  type: TYPE_IMG
- en: Windows Server 2008 R2 without a service pack is no longer supported.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to look at the Horizon View security server.
  prefs: []
  type: TYPE_NORMAL
- en: The Horizon View security server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Horizon View security server** is another individual component of the
    architecture and is another role performed by the connection server. The key differences
    are that firstly, it sits within your DMZ, and therefore is not joined to your
    domain. This allows it to be used for end users to securely connect to their virtual
    desktop machine from an external network or the internet without the need for
    a VPN. As it is paired with one of your connection servers, the internal connection
    server it is paired with takes care of knowing about the users and desktop pools,
    and so on. Secondly, it does not hold a copy of the ADAM database. As you will
    see in [Chapter 5](89619cdf-5fc7-4dd1-a431-76cef6cbb67c.xhtml), *Installing and
    Configuring Horizon 7 – Part 2*, the installation process is the same as installing
    the view connection server, but, instead, this time, you select the security server
    role from the drop-down menu at the start of installation.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot install the view security server on the same machine that is already
    running as a connection server or any of the other Horizon View components.
  prefs: []
  type: TYPE_NORMAL
- en: How does the security server work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with, the user login process at the beginning is the same as when connecting
    to a view connection server, essentially because the security server is just another
    version of the connection server running a subset of the features, with the exclusion
    of the ADAM database. The difference is that you connect to the address of the
    security server. The security server sits inside your DMZ and communicates with
    a connection server sitting on the internal network that it is paired with. So,
    now we have added an extra security layer, as the internal connection server is
    not exposed externally, with the idea being that users can now access their virtual
    desktop machines externally without needing to first connect to a VPN on the network.
  prefs: []
  type: TYPE_NORMAL
- en: The security server should not be joined to the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'This security server connection process is described pictorially in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user logs in from the Horizon client, they now use the external URL
    of the security server to access the connection server, which, in turn, authenticates
    the user against Active Directory. If the connection server is configured as a
    PCoIP gateway, then it will pass the connection and addressing information to
    the Horizon client. This connection information will allow the Horizon client
    to connect to the security server using PCoIP. This is shown in the diagram by
    the green arrow (**1**). The security server will then forward the PCoIP connection
    to the virtual desktop machine (**2**), creating the connection for the user.
    The virtual desktop machine is displayed/delivered within the Horizon client window
    (**3**) using the chosen display protocol (PCoIP, Blast Extreme, or RDP). We will
    cover this process and the different ports View uses for connecting later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Horizon View replica server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Horizon View replica server, as the name suggests, is a replica or a copy
    of a view connection server and serves two key roles.
  prefs: []
  type: TYPE_NORMAL
- en: The first role is to enable high availability for your Horizon view environment.
    Having a replica of your view connection server means that, if a connection server
    fails, a replica server will take over the management of connection requests so
    that end users are still able to connect to their virtual desktop machines.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, adding replica servers allows you to scale up the number of users
    and virtual desktop connections. An individual instance of a connection server
    can support 2,000 connections, so adding additional connection servers allows
    you to add another 2,000 users at a time, up to the maximum of five connection
    servers and 10,000 users per Horizon view pod. We will discuss the Pod and Block
    architecture in [Chapter 3](20877fa6-9a03-4c97-ab85-4a4338e2c680.xhtml), *Design
    and Deployment Considerations*.
  prefs: []
  type: TYPE_NORMAL
- en: When deploying a replica server, remember that you will need to change the IP
    address or update the DNS record to match this server if you are not using a load
    balancer.
  prefs: []
  type: TYPE_NORMAL
- en: As with the security server, you will see that the installation process is again
    almost the same as the connection server, but this time, you select the replica
    server role from the drop-down menu during installation.
  prefs: []
  type: TYPE_NORMAL
- en: How does the replica server work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first question is: what gets replicated? The connection broker stores all
    its information relating to the end users, desktop pools, virtual desktop machines,
    and other View-related objects, in an ADAM database. Then, using the **Lightweight
    Directory Access Protocol** (**LDAP**) (it uses a method similar to the one AD
    uses for replication), this View information gets copied from the original connection
    server to the replica server.'
  prefs: []
  type: TYPE_NORMAL
- en: As both the connection server and the replica server are now identical to each
    other, if your connection server fails, then you essentially have a backup that
    steps in and takes over, so that end users can continue to connect to their virtual
    desktop machines. Also, as the replica server is another instance of a connection
    server within your environment, you can scale up and manage additional end users.
  prefs: []
  type: TYPE_NORMAL
- en: As with the other Horizon components, you cannot install the replica server
    role on the same machine that is running as a connection server or any of the
    other Horizon View components.
  prefs: []
  type: TYPE_NORMAL
- en: The Horizon View enrolment server and True SSO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Horizon View Enrollment Server** is the final component that is part of
    the Horizon View connection server installation options, and is another installation
    option from the connection server installation process and is selected from the
    drop-down menu. So, what role does the enrolment server perform?
  prefs: []
  type: TYPE_NORMAL
- en: Horizon 7 saw the introduction of a new feature, called **True SSO**. True SSO
    is a solution that allows a user to authenticate to a Microsoft Windows environment
    without them having to enter their AD credentials. It integrates into another
    VMware product, **VMware Identity Manager** (**VIDM**), which forms part of both
    Horizon 7's advanced and enterprise editions.
  prefs: []
  type: TYPE_NORMAL
- en: Its job is to sit between the connection server and the Microsoft CA to request
    temporary certificates from the certificate store.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is described pictorially in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a579db1c-47d7-4f3e-9dc7-b742ed58ca9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A user first logs into VIDM, either using their credentials or another authentication
    method such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: RSA SecurID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kerberos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RADIUS authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSA Adaptive Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standards-based, third-party identity providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once successfully authenticated, the end user will be presented with the virtual
    desktop machines or hosted applications that they are entitled to use. They can
    launch any of these by simply double-clicking, which will launch the Horizon client,
    as shown by the red arrow (**1**) in the previous diagram. The user's credentials
    will then be passed to the connection server (**2**), which, in turn, will verify
    them by sending a **Security Assertion Markup Language** (**SAML**) assertion
    back to the identity manager (**3**).
  prefs: []
  type: TYPE_NORMAL
- en: If the end user's credentials are verified, then the connection server passes
    them on to the enrolment server (**4**). The enrolment server then makes a request
    to the Microsoft **Certificate Authority** (**CA**) to generate a short-lived,
    temporary certificate for that user to use (**5**).
  prefs: []
  type: TYPE_NORMAL
- en: With the certificate now generated, the connection server presents it to the
    operating system of the virtual desktop machine (**6**), which, in turn, validates
    with Active Directory to confirm whether the certificate is authentic (**7**).
  prefs: []
  type: TYPE_NORMAL
- en: When the certificate has been authenticated, the end user is logged on to their
    virtual desktop machine, which is then displayed/delivered to the Horizon client
    using the chosen display protocol (**8**).
  prefs: []
  type: TYPE_NORMAL
- en: True SSO is supported by all Horizon 7-supported desktop operating systems,
    as well as Windows Server 2008 R2 and Windows Server 2012 R2\. It also supports
    PCoIP, HTML, and Blast Extreme delivery protocols.
  prefs: []
  type: TYPE_NORMAL
- en: VMware Unified Access Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **VMware Unified Gateway** performs the same role as the view security
    server and is shown in the following diagram, but there''s one key difference.
    Instead of being a Windows application and another role in the connection server,
    the Unified Access Gateway is a separate virtual appliance that runs a hardened,
    locked-down Linux operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a852476-4147-4f12-8a51-886e8bf70e66.png)'
  prefs: []
  type: TYPE_IMG
- en: Although the Unified Gateway appliances deliver pretty much the same functionality
    as the security server, they do not yet completely replace it, especially if you
    already have a production deployment that uses the security server for external
    access. In that event, you can continue to use this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the secure tunnel function, PCoIP Secure Gateway, or the Blast
    Secure Gateway features of the connection server, then these features will need
    to be disabled on the connection server if you are using Unified Access Gateway.
    They are all enabled by default on the Unified Gateway appliance.
  prefs: []
  type: TYPE_NORMAL
- en: A key difference between Unified Access Gateway Appliances and the security
    server is in the way Unified Access Gateway scales. Before, you had to pair a
    security server with a connection server, which was a limitation, but this is
    no longer the case. As such, you can now scale to as many Unified Access Gateways
    as you need for your environment, with the maximum limit being around 2,000 sessions
    for a single appliance. Adding additional appliances is simply a case of deploying
    the appliance, as appliances don't depend on other appliances and do not communicate
    with them. They communicate directly with the connection servers over a load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent or non-persistent desktops?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to talk about the different types of desktop assignments
    and the way a virtual desktop machine is delivered to an end user. This is an
    important design consideration, as the chosen method could potentially impact
    on the storage requirements (covered in the next section), the hosting infrastructure,
    and which technology or solution is used to provision the virtual desktop machines
    to the end users.
  prefs: []
  type: TYPE_NORMAL
- en: One of the questions that often gets asked is whether you should deploy a dedicated
    (persistent) assignment or a floating desktop (non-persistent) assignment. Desktops
    can either be individual virtual machines, which are dedicated to a user on a
    1:1 basis (as we have in a physical desktop deployment, where each user effectively
    owns their own desktop), or a user has a new, vanilla desktop that gets provisioned,
    built, personalized, and then assigned to them at login. The virtual desktop machine
    they access is chosen at random from a pool of available desktops that the end
    user is entitled to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two options are described in more detail as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persistent desktop**: End users are assigned a desktop that keeps all their
    documents, applications, and settings between sessions. The first time the user
    connects to it, the desktop gets statically assigned and is further used for all
    subsequent sessions. No other user is permitted access to the desktop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-persistent desktop**: End users might be connected to different virtual
    desktops each time they connect. Environmental applications or user data does
    not persist between sessions and is instead delivered as the user logs on to their
    desktop using the composite desktop model we discussed back in [Chapter 1](6b70801c-f579-4fd6-8910-1cc57a06831e.xhtml),
    *Introducing VDI and VMware Horizon 7*. The desktop is refreshed or reset when
    the user logs off and is then ready for the next user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most use cases, a non-persistent configuration is the best option; the key
    reason is that using this model, you don't need to build all the desktops upfront
    for each user. You only need to power on a virtual desktop as and when it's required.
    All end users start with the same basic desktop, which then gets personalized
    before delivery. This helps with concurrency rates. For example, you might have
    5,000 people in your organization, but only 2,000 ever log in at the same time;
    therefore, you only need to have 2,000 virtual desktops available. Otherwise,
    you would have to build a desktop for each one of the 5,000 users that might ever
    log in, resulting in more server infrastructure, more storage capacity, and more
    software licensing.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that used to be a bit of a showstopper for non-persistent
    desktops was regarding how to deliver the applications to the virtual desktop
    machine, and whether this would mean you had to install applications each time
    an end user logged in. Now that application layering solutions, such as VMware
    App Volumes or Liquidware FlexApp, are becoming a more mainstream technology,
    the applications can be delivered on demand as the desktop is built and the user
    logs in.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that we often see some confusion over is the difference between
    persistent and non-persistent desktops, and how cloning fits in. Just to make
    it clear, linked clones, full clones, and instant clones are not what we are talking
    about when we refer to persistent and non-persistent desktops. *Cloning operations*
    refers to how a desktop is built and provisioned, whereas the terms *persistent*
    and *non-persistent* refer to how a desktop is assigned to an end user.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent and non-persistent desktops are purely about user assignment and
    whether an end user has a dedicated desktop, or one allocated from a pool on demand
    each time they log in. Cloning is a feature of Horizon View, which uses either
    View Composer and/or vCenter to create the desktop images for each user from a
    master or parent image. This means, regardless of having a persistent or non-persistent
    desktop assignment, the virtual desktop machine could still be a linked clone,
    full clone, or instant clone.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we are going to cover an in-depth overview of the cloning
    technologies available in Horizon 7, starting with Horizon View Composer and linked
    clones, and the advantages the technology delivers.
  prefs: []
  type: TYPE_NORMAL
- en: Horizon View Composer and linked clones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss how virtual desktop machines are built,
    created, and scaled using cloning techniques. We will describe the different cloning
    options, what they deliver, and how they impact disk storage requirements.
  prefs: []
  type: TYPE_NORMAL
- en: What is cloning?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting at a high level, a clone is a copy of an existing or parent virtual
    machine. This parent virtual desktop machine is your gold build from which you
    want to create new virtual desktop machines. When a clone is created, it becomes
    a separate, new virtual desktop machine with its own unique identity. This process
    is not unique to Horizon View. It''s actually a function of vSphere and vCenter,
    and in the case of Horizon View, we add in another component, View Composer, to
    manage the desktop images. There are three types of clone that can be deployed:
    a full clone, a linked clone, or an instant clone.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main reasons a virtual desktop project fails to deliver or doesn't
    even get out of the starting blocks is because of the heavy infrastructure and
    storage requirements. The storage requirements are often seen as a huge cost burden,
    which can be attributed to the fact that people are approaching a VDI project
    in the same way they would approach a physical desktop environment. This would
    mean that each user gets their own dedicated virtual desktop and the hard-disk
    space that comes with it, albeit a virtual disk. This is then scaled out for the
    entire user population, with each user being allocated a virtual desktop with
    some storage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss an example. If you had 1,000 users and allocated 250 GB disk space
    per desktop, you would need 1,000 * 250 GB = 250 TB of disk space just for the
    virtual desktop environment. That's a lot of storage just for desktops and could
    result in significant infrastructure costs, which could possibly mean that the
    cost to deploy this amount of storage in the data center would render the project
    cost-ineffective compared to physical desktop deployments. This would be described
    as the **Full Clone** approach.
  prefs: []
  type: TYPE_NORMAL
- en: What is a full clone?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name implies, a full clone disk is an exact, full-size copy of the parent
    virtual machine or gold image template. Once the clone of the gold image has been
    created, the virtual desktop machine is unique, with its own identity, and operates
    as a fully independent virtual desktop in its own right and is not reliant on
    the gold image from which it was created.
  prefs: []
  type: TYPE_NORMAL
- en: However, as it is a full-sized copy, be aware that it will take up exactly the
    same amount of storage as the gold image, which leads back to our discussion earlier
    in this chapter about storage capacity requirements. Using a full clone will require
    larger amounts of storage capacity and will possibly lead to higher infrastructure
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: But before you completely dismiss the idea of using full clone virtual desktop
    machines, there are some use cases that rely on this model. For example, if you
    use VMware Mirage to deliver the operating system as a base layer, it only works
    today with full clones and dedicated Horizon View virtual desktop machines.
  prefs: []
  type: TYPE_NORMAL
- en: With VDI, a new approach to deploying storage is needed, and this is where linked
    clone and instant clone technology comes into play. In a nutshell, linked and
    instant clones are designed to reduce the amount of disk space required, and to
    simplify the deployment and management of images to multiple virtual desktop machines,
    making it a centralized, and much easier, process.
  prefs: []
  type: TYPE_NORMAL
- en: What are linked clones?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having discussed full clones, we are going to talk about deploying virtual desktop
    machines using linked clones.
  prefs: []
  type: TYPE_NORMAL
- en: In a linked clone deployment, a delta disk is created and then used by the virtual
    desktop machine to store the data differences between its own operating system
    and the operating system of its parent virtual desktop machine. Unlike the full
    clone method, a linked clone is not a full copy of the virtual disk. The term
    *linked clone* refers to the fact that the linked clone will always look to its
    parent in order to operate, as it continues to read from the replica disk. Basically,
    the replica is a copy of a snapshot of the parent virtual desktop machine.
  prefs: []
  type: TYPE_NORMAL
- en: The linked clone itself could potentially grow to the same size as the replica
    disk if you allowed it to. However, you can set limits on how big it can grow,
    and should it start to get too big, then you can refresh the virtual desktops
    that are linked to it. This essentially starts the cloning process again from
    the initial snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately after a linked clone virtual desktop is deployed, the difference
    between the parent virtual machine and the newly-created virtual desktop machine
    is extremely small, and therefore reduces the storage capacity requirements compared
    to that of a full clone. This is how linked clones are more space-efficient than
    their full clone brothers.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying technology behind linked clones is more like a snapshot than
    a clone, but with one key difference—View Composer. With View Composer, you can
    have more than one active snapshot linked to the parent virtual machine disk.
    This allows you to create multiple virtual desktop images from just one parent.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice would be to deploy an environment with linked clones (or instant
    clones) to reduce the storage requirements. However, as we previously mentioned,
    there are some use cases where you may need to deploy full clones.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to be aware of, which still relates to the storage, is that, rather
    than capacity, we are now talking about performance. All linked clone virtual
    desktops are going to be reading from one replica and will, therefore, drive a
    high number of **Input/Output Operations Per Second** (**IOPS**) on the storage
    where the replica lives. Depending on your desktop pool design, you are likely
    to have more than one replica, as you would typically have more than one data
    store. This, in turn, depends on the number of users who will drive the design
    of the solution. We will cover this in greater detail in [Chapter 3](20877fa6-9a03-4c97-ab85-4a4338e2c680.xhtml),
    *Design and Deployment Considerations*.
  prefs: []
  type: TYPE_NORMAL
- en: With Horizon View, you can choose the location where the replica lives. One
    of the recommendations is that the replica should sit in fast storage, such as
    a local or shared SSD.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative solution would be to deploy some form of storage acceleration
    technology to drive the IOPS. Horizon View also has its own integrated solution,
    called **View Storage Accelerator** (**VSA**) or **Content Based Read Cache**
    (**CBRC**). This feature allows you to allocate up to 2 GB of memory from the
    underlying ESXi host server, which can be used as a cache for the most commonly
    read blocks. As we are talking about creating and booting up desktop operating
    systems, the same blocks are required; as these can be retrieved from memory,
    the process is accelerated.
  prefs: []
  type: TYPE_NORMAL
- en: View Storage Accelerator is enabled by default when using instant clones and
    cannot be configured.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution is **View Composer Array Integration** (**VCAI**), which allows
    the process of building linked clones to be offloaded to the storage array and
    its native snapshot mechanism, rather than taking CPU cycles from the host server.
  prefs: []
  type: TYPE_NORMAL
- en: There are also several other third-party solutions that resolve the storage
    performance bottleneck, such as ThinScale's ThinIO ([https://www.thinscale.com/products/thinio/](https://www.thinscale.com/products/thinio/))
    solution, which delivers software-defined storage acceleration to actively reduce
    disk I/O.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a deeper look at how the linked clone process
    works.
  prefs: []
  type: TYPE_NORMAL
- en: How do linked clones work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step, before you even start to build clones, is to create your master
    virtual desktop machine image, which should contain not only the operating system,
    core applications, and settings, but also the Horizon View Agent components. This
    virtual desktop machine will become your parent VM or your gold image from which
    all other virtual desktop machines will be created. We will cover the build process
    in [Chapter 7](d42ce468-eec2-4d43-ba82-25b90b59f936.xhtml), *Building and Optimizing
    the Virtual Desktop OS*. Linked clones are built and managed using View composer
    and the vCenter server.
  prefs: []
  type: TYPE_NORMAL
- en: The gold image or parent image cannot be a virtual machine template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the parent VM has been built, then you can start to build virtual desktops
    and virtual desktop pools using that image. An overview of the linked clone creation
    process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1624fe36-2f5e-4e23-821d-321189377c75.png)'
  prefs: []
  type: TYPE_IMG
- en: Take your gold image (**1**), and take a snapshot of it (**2**). When you create
    your desktop pool, this snapshot is selected and will become the replica (**3**)
    and will be set to be read-only. Each virtual desktop is linked back to this replica,
    hence, the term *linked clone*. When you start creating your virtual desktops,
    you create linked clones that are unique copies for each user.
  prefs: []
  type: TYPE_NORMAL
- en: Try not to create too many snapshots for your parent VM. I would recommend having
    just a handful; otherwise, this could impact the performance of your desktops
    and make it a little harder to know which snapshot is which.
  prefs: []
  type: TYPE_NORMAL
- en: Creating linked clones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the image-building process, and once the replica disk has been created,
    View Composer creates several other virtual disks, including the linked clone
    (operating system disk) itself. These are described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Linked clone disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main disk that is created is the linked clone disk itself. This linked clone
    disk is basically an empty virtual disk container that is attached to the virtual
    desktop machine as the user logs in and the desktop starts up and boots.
  prefs: []
  type: TYPE_NORMAL
- en: This disk will start off small but will grow over time depending on the block
    changes that are requested from the replica disk by the virtual desktop machine's
    operating system. These block changes are stored in the linked clone disk, and
    this disk is sometimes referred to as the **delta disk**, or **differential disk**,
    since it stores all the delta changes that the desktop operating system requests
    from the parent VM. As mentioned before, the linked clone disk can grow to the
    maximum size, equal to the parent VM, but, following best practice, you would
    never let this happen. Typically, you can expect the linked clone disk to only
    increase to a few hundred MBs. We will cover this in the *L**inked clone features
    and functionality* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The replica disk is set as read-only and is used as the primary disk. Any writes
    and/or block changes that are requested by the virtual desktop are written/read
    directly from the linked clone disk.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended best practice is to allocate tier-1 storage, such as local or shared
    SSD drives, for storing and hosting the replica, as all virtual desktop machines
    within the cluster will be continually referencing this single read-only VMDK
    file as their base image. Keeping it high in the stack improves performance, by
    reducing the overall storage
  prefs: []
  type: TYPE_NORMAL
- en: Persistent disk or user data disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The persistent disk feature of View Composer allows you to configure a separate
    disk that contains just the user data and user settings and not the operating
    system. This allows any user data to be preserved when you update or make changes
    to the operating system disk, such as a recompose action.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that the persistent disk is referenced by the VM name and
    not the username, so bear this in mind if you want to attach the disk to a different
    VM.
  prefs: []
  type: TYPE_NORMAL
- en: The data disk is also used to store the end user's profile. You, therefore,
    need to size it accordingly, ensuring that it is large enough to store any user
    profile type data, such as Virtual Desktop Assessments. This is another reason
    why it's a good idea to run a desktop assessment, as we will cover in [Chapter
    3](20877fa6-9a03-4c97-ab85-4a4338e2c680.xhtml), *Design and Deployment Considerations*,
    so that you can build up a picture of what your user desktop profiles and user
    data requirements look like.
  prefs: []
  type: TYPE_NORMAL
- en: Disposable disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the **disposable disk** option, Horizon View creates what is effectively
    a temporary disk that gets deleted every time the user powers off their virtual
    desktop machine.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about how the Windows desktop operating system operates and the
    files it creates, there are several files that are used on a temporary basis.
    Files such as temporary internet files or the Windows pagefile are two such examples.
    As these are only temporary files, why would you want to keep them? With Horizon
    View, these types of files are redirected to the disposable disk and then deleted
    when the VM is powered off.
  prefs: []
  type: TYPE_NORMAL
- en: Horizon View provides the option to have a disposable disk for each virtual
    desktop. This disposable disk is used to contain temporary files that will get
    deleted when the virtual desktop is powered off. These are files that you don't
    want to store on the main operating system disk, as they would consume unnecessary
    disk space. For example, files on the disposable disk are things such as the pagefile,
    Windows system temporary files, and VMware log files.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth pointing out that we are talking about temporary system files and
    not user files. An end user's temporary files are still stored on the user data
    disk so that they can be preserved. Many applications use the Windows temp folder
    to store installation CAB files, which can be referenced post-installation. Having
    said that, you might want to delete the temporary user data to reduce the overall
    desktop image size, in which case you could ensure that the user's temporary files
    are directed to the disposable disk.
  prefs: []
  type: TYPE_NORMAL
- en: Internal disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we have the internal disk. The internal disk is used to store important
    configuration information, such as the computer account password, which would
    be needed to join the virtual desktop machine back to the domain if you refreshed
    the linked clones. It is also used to store the **Sysprep** and **Quickprep**
    configuration details. We will cover Quickprep in [Chapter 7](d42ce468-eec2-4d43-ba82-25b90b59f936.xhtml),
    *Building and Optimizing the Virtual Desktop OS*.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of disk space, the internal disk is relatively small, averaging around
    20 MB. By default, the user will not see this disk from their Windows Explorer,
    as it contains important configuration information that you wouldn't want them
    to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows you an outline of the different disk types created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fc90d3d-b667-4be6-856f-8cf55aec88b4.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will take a deeper dive into how the linked clone process
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the linked clone process works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several complex steps performed by View Composer and View Manager
    that initiate when a user requests a virtual desktop machine. So, what's the process
    of building a linked clone desktop, and what goes on behind the scenes? When a
    user logs into Horizon View and requests a virtual desktop machine, View Manager,
    using vCenter and View Composer, will create a virtual desktop machine if there
    is not already one available to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: This process is described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and provisioning a new virtual desktop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in the process is to create and provision the virtual desktop
    machine as described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: An entry for the virtual desktop machine is created in the **Active Directory
    Application Mode** (**ADAM**) database before it is then put into provisioning
    mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The linked clone virtual desktop machine is created by View Composer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A machine account is created in Active Directory with a randomly generated password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View Composer checks for a replica disk and creates one if one does not already
    exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A linked clone is created by the vCenter Server API call from View Composer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An internal disk is created to store the configuration information and machine
    account password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The virtual desktop machine has been created and is now ready for the next step
    of the process—customization.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the desktop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the new linked clone virtual desktop machine has been built, the next
    step in the process is to customize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To customize the virtual desktop machine, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The virtual desktop machine is switched to customization mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The virtual desktop machine is customized by vCenter Server using the `customizeVM_Task`
    command and is joined to the domain with the information you entered in the View
    Manager console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The linked clone virtual desktop is powered on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The View Composer Agent on the linked clone virtual desktop machine starts up
    for the first time and joins the machine to the domain, using the `NetJoinDomain`
    command and the machine account password that was created on the internal disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The linked clone virtual desktop machine is now Sysprep'd or Quickprep'd. Once
    complete, View Composer tells View Agent that the customization has finished,
    and View Agent tells View Manager that the customization process has finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The linked clone virtual desktop machine is powered off and a snapshot is taken.
    If you use Quickprep, then you don't need to restart the virtual desktop machine
    following customization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The linked clone virtual desktop machine is marked as provisioned and is now
    available for use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an end user connects and powers on a linked clone virtual desktop machine,
    the View Composer agent installed on that virtual desktop is able to track changes
    to the machine account password. If there is a change, then the new updated password
    will be stored on the linked clone internal disk. The machine account password
    is often changed, depending on password policies, so if the View Composer agent
    detects this change of password, then it will update the machine account password
    on the internal disk that was created when the linked clone desktop was created.
    This is a key feature when refreshing linked clone disks, as the linked clone
    virtual desktop machine reverts back to the snapshot taken after the virtual desktop
    machine has been customized. This means that the View Composer agent can reset
    the machine account password to the latest one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The linked clone process is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3c39cd8-9cd5-41df-8a34-ae096d4c67a7.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we are going to look at some of the additional features
    and functions of using linked clones.
  prefs: []
  type: TYPE_NORMAL
- en: Linked clone features and functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several other management functions that you can perform on a linked
    clone disk using View Composer. These functions are outlined in this section and
    are used to deliver the ongoing management of the virtual desktop machines.
  prefs: []
  type: TYPE_NORMAL
- en: Recomposing a linked clone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recomposing a linked clone virtual desktop machine or desktop pool allows you
    to perform updates to the operating system disk, such as updating the image with
    the latest patches, or software updates. You can only perform updates on the same
    version of an operating system, so you cannot use the recompose feature to migrate
    from one operating system to another, such as going from Windows 7 to Windows
    10.
  prefs: []
  type: TYPE_NORMAL
- en: As we've covered in the *What does View Composer Build?* section, we have separate
    disks for items such as a user's data. These disks are not affected during a recompose
    operation, so all user-specific data on them is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: When you initiate the recompose operation, View Composer essentially starts
    the linked clone building process over again; thus, a new operating system disk
    is created, which then gets customized, and a snapshot, such as the ones shown
    in the preceding sections, is taken.
  prefs: []
  type: TYPE_NORMAL
- en: During the recompose operation, the Mac addresses of the network interface and
    the Windows SID are not preserved. There are some management tools and security-type
    solutions that might not work due to this change. However, the UUID will remain
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you perform the recompose operation, you will need to create your new
    image and then take the initial snapshot. The recompose process is described in
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: View Manager switches the linked clone to maintenance mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View Manager calls the View composer resync API for the linked clones being
    recomposed, directing View Composer to use the new base image and the snapshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no replica for the base image and snapshot exist, then, in the target datastore
    used by the linked clone, View Composer will create the replica in that same target
    datastore, that is, unless you have configured View to use a separate datastore
    for storing replicas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the linked clone, the current OS disk is deleted by the View composer. It
    then creates a new OS disk that is linked to the newly created replica.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remainder of the recompose cycle follows the customization phase of the
    provisioning and customization cycles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows a graphical representation of the recompose process.
    Before the process begins, the first thing you need to do is update your gold
    image (**1**) with the patch updates or new applications you want to deploy as
    the virtual desktops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d3374ba-08db-4227-a7b9-f3cf7edf1a1f.png)'
  prefs: []
  type: TYPE_IMG
- en: As described in the preceding steps, the snapshot is then taken (**2**) to create
    the new replica, Replica V2 (**3**). The existing OS disk is destroyed, but the
    user data disk (**4**) is maintained during the recompose process.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing a linked clone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By carrying out a refresh of the linked clone virtual desktop, you are effectively
    reverting it to its initial state, when its original snapshot was taken after
    it had completed the customization phase. This process only applies to the operating
    system disk and no other disks are affected.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case for refresh operations would be recomposing a non-persistent
    desktop two hours after logoff, to return it to its original state and make it
    available for the next user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The refresh process performs the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The linked clone virtual desktop is switched to maintenance mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View Manager reverts the linked clone virtual desktop to the snapshot taken
    after customization was completed: `- vdm-initial-checkpoint`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The linked clone virtual desktop starts up, and the View Composer agent detects
    whether the machine account password needs to be updated. If it doesn't, and the
    current password on the internal disk is newer than the password currently stored
    in the registry, then the View Composer agent updates the machine account password
    using the password that is on the internal disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the reasons you would perform a refresh operation is if the linked clone
    OS disk starts to become bloated. As we previously discussed, the OS-linked clone
    disk could grow to the full size of its parent image. This means it would be taking
    up more disk space than is necessary, which kind of defeats the objective of linked
    clones. The refresh operation effectively resets the linked clone back to a small
    delta between it and its parent image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a representation of the refresh operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9002f0b-553e-4190-a195-642c4c657afc.png)'
  prefs: []
  type: TYPE_IMG
- en: The linked clone disk on the left-hand side of the diagram has started to grow
    (**2**). Refreshing the first places the virtual desktop machine in maintenance
    mode (**1**). The virtual desktop is then reverted to the original snapshot (**3**).
    The new linked clone desktop has now been reset to the same size as when it was
    first created (**4**).
  prefs: []
  type: TYPE_NORMAL
- en: Rebalancing operations with View Composer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rebalance operation in View Composer is used to evenly distribute the linked
    clone virtual desktop machines across multiple datastores in your environment.
    You would perform this task if one of your datastores was becoming full while
    others have ample free space. It might also help with the performance of that
    datastore. For example, if you had 10 virtual desktop machines in one datastore
    and only 2 in another, then running a rebalance operation would potentially even
    this out and leave you with 6 virtual desktop machines in each datastore.
  prefs: []
  type: TYPE_NORMAL
- en: You must use the View Administrator console to initiate the rebalance operation
    in View Composer. If you simply try to Storage vMotion any of your virtual desktop
    machines, then View Composer will not be able to keep track of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you have six virtual desktop machines on one datastore
    and seven on another, then it is highly likely that initiating a rebalance operation
    will have no effect, and no virtual desktop machines will be moved, as doing so
    has no benefit. A VDI desktop will only be moved to another datastore if the target
    datastore has significantly more spare capacity than the source:'
  prefs: []
  type: TYPE_NORMAL
- en: The linked clone is switched to maintenance mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Virtual machines to be moved are identified based on the free space in the available
    datastores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operating system disk and persistent disk are disconnected from the virtual
    desktop machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The detached operating system disk and persistent disk are moved to the target
    datastore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The virtual desktop machine is moved to the target datastore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operating system disk and persistent disk are reconnected to the linked
    clone virtual desktop machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View Composer resynchronizes the linked clone virtual desktop machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View Composer checks for the replica disk in the datastore and creates one if
    one does not already exist, as per the provisioning steps covered earlier in this
    chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As per a recompose operation, the OS disk for the linked clone gets deleted
    and a new one is created and then customized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows the rebalance operation. It started with two virtual
    desktop machines in datastore A, and four virtual desktop machines in datastore
    B. The rebalance operation in this example evened out the datastores so that there
    are four virtual desktop machines in each of the two datastores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c44335aa-f665-4ecf-8a4b-1d98455d0542.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we are going to look at the Instant Clone feature for creating
    virtual desktop machines.
  prefs: []
  type: TYPE_NORMAL
- en: Instant Clones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Instant Clones** feature is functionality built into the vSphere platform
    rather than a specific Horizon feature, and was made available from the vSphere
    6.0 U1 release when it became a supported feature as part of Horizon.
  prefs: []
  type: TYPE_NORMAL
- en: It uses the VMware VM Fork technology to very quickly provision virtual desktop
    machines. An instant clone is created from an already powered on and running virtual
    desktop machine, called the parent virtual desktop machine, which is quiesced
    before the instant clone is created. This is what makes instant clones quicker
    to provision than linked clones and View Composer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The instant clone shares its memory and its disk with the parent virtual desktop
    machine for read operations and is created immediately, and in an already powered-on
    state, unlike with View Composer-based linked clones that must power on as part
    of the creation process. As well as sharing the memory and disk with the parent
    virtual desktop machine, the instant clone has its own unique memory and delta
    disk file. The following diagram shows the instant clone''s architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cba7d6a8-a804-4e1f-90d4-8154b719edd2.png)'
  prefs: []
  type: TYPE_IMG
- en: When the end user logs off the instant clone virtual desktop machine, it is
    destroyed, and when the user logs on again, they will have a new instant clone
    created. If they need any data to persist, then they would use the Writeable Volume
    feature of App Volumes to deliver that functionality and UEM to manage their personalization
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of instant clones, the virtual desktop machines will need
    to be running virtual machine hardware version 11 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Instant clone build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, when we talked about linked clones, we looked at what the build
    process looks like and what gets built, so let's now look at that again from an
    instant clone perspective.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we start with the master image, the virtual desktop machine that
    all other desktops are built from. The first thing that happens is that a snapshot
    of the master virtual desktop machine is taken. Next, an internal template is
    created that is a linked clone of the master virtual desktop machine based on
    the virtual desktop machine snapshot taken in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the replica virtual desktop machine, which is a thin-provisioned,
    full clone of the internal template virtual desktop machine. View Storage Accelerator
    uses a CBRC digest of this virtual desktop machine. After the replica virtual
    desktop machine, the running parent virtual desktop machine is created using a
    linked clone of the replica virtual desktop machine, which, in turn, is based
    on a replica virtual desktop machine snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the instant clone desktop is created and is ready for the end user.
    The following diagram describes this process pictorially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09296593-2598-425b-b0c5-4c6748142b1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Instant clone benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several benefits to using instant clones, compared to linked clones:'
  prefs: []
  type: TYPE_NORMAL
- en: Instant clones provision in seconds, whereas linked clones take a lot longer
    (typically minutes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no longer any boot storms, as the parent desktop is already powered
    on, and therefore all instant clones get created in an already powered-on state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no requirement to perform a refresh or recompose operation, as desktops
    have a short life cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patching the operating system requires you to just update the parent VM, rather
    than running a recompose operation, resulting in an end user receiving the updated
    virtual desktop machine on their next login, automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They lessen the load on the vCenter server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no requirement for SE Spare Disk or CBRC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we are going to look at how these newly built virtual desktop
    machines are customized and personalized.
  prefs: []
  type: TYPE_NORMAL
- en: View Persona Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with a little bit about the background and history behind **View
    Persona Management**. View Persona Management was originally a technology product
    called **Virtual Profiles**, and was acquired by VMware from RTO Software in 2010.
  prefs: []
  type: TYPE_NORMAL
- en: View Persona Management was then introduced with **View 5.0**, and it allows
    you to configure user profiles so that they dynamically synchronize with a remote
    profile repository that is located on a file server in the data center. Its purpose
    is to manage user profiles centrally within a virtualized desktop environment
    as part of the composite desktop model we discussed in [Chapter 1](6b70801c-f579-4fd6-8910-1cc57a06831e.xhtml),
    *Introducing VDI and VMware Horizon 7*.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to manage user profiles differently in VDI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a VDI solution, one of the key benefits is the way the virtual desktop is
    either built on demand or delivered from a pool of prebuilt, non-persistent desktops
    and then delivered back to the user. The typical deployment model is the non-persistent
    model, which basically means that the user doesn't own their own desktop or have
    personal files, data, or settings stored on it either. It's these settings that
    form their user profile.
  prefs: []
  type: TYPE_NORMAL
- en: When they log in, they could have any desktop delivered to them from a pool
    of available virtual desktop machines. This means that the virtual desktop that
    is delivered would not be personalized to that user. It would just be a standard
    vanilla build of the operating system and applications.
  prefs: []
  type: TYPE_NORMAL
- en: This is where View Persona Management comes into play and delivers the user's
    profile to that non-persistent virtual desktop machine they have been assigned
    to, effectively making it their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about the desktop being built on demand, we are again referring
    to the composite desktop model and how a desktop is put together from several
    different components. As a reminder, the desktop can be broken down into three
    components: the operating system, applications, and the user''s personalization
    or profile, essentially, the bit that makes the desktop yours. As a user logs
    in, all these pieces come together to deliver the end user desktop experience.
    With View Persona Management, we are talking about the user''s profile.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will introduce you to View Persona Management and its benefits
    for managing user profiles. A deeper dive into the technical details and configuring
    View Persona Management can be found in [Chapter 17](https://www.packtpub.com/sites/default/files/downloads/Managing_the_End_User_Environment_in_Horizon.pdf),
    *Managing the End User Environment in Horizon*.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of View Persona Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a high level, View Persona Management provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast loading of user personalization settings, with just-in-time retrieval of
    user profile data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Little or no infrastructure is required—just a file share or the use of an existing
    folder redirection structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile consistency maintains personalization between sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient architecture with no dependency on Windows roaming user profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplatform support for Windows XP, Windows Vista, Windows 7, Windows 8.x,
    and Windows 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the listed features, View Persona Management also helps reduce
    virtual desktop TCO by enabling the move to a stateless virtual desktop environment.
    In some deployments, users were placed in dedicated pools solely to retain their
    profile settings, which added to the cost and complexity in management. When it
    comes to cost, as persona management is an integrated part of Horizon View; you
    don't need to purchase additional third-party products, unless you need additional
    functionality above and beyond the basics.
  prefs: []
  type: TYPE_NORMAL
- en: On the subject of management, there are no additional components to set up or
    install, since everything is driven by the Active Directory Group Policy. In terms
    of scalability, again, as there are no infrastructure overheads such as databases,
    so scalability is not an issue, as it scales with your active directory.
  prefs: []
  type: TYPE_NORMAL
- en: VMware UEM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **VMware UEM** product is one of the newest editions to the Horizon portfolio
    and was added when VMware acquired the Dutch company Immidio back in February
    2015\. Immidio was a software company that created products that were aimed at
    helping their consultants out in the field, with the core product being called
    **Flex+**.
  prefs: []
  type: TYPE_NORMAL
- en: UEM adds additional functionality over and above the standard persona management
    solution, providing a central management console, to deliver personalization of
    the end user's virtual desktop machine as well as the ability to dynamically configure
    policies. It works across several different environments, such as virtual desktop
    machines, physical PCs, as well as cloud-based Windows desktop environments or
    DaaS. It's all about managing Windows profiles regardless of where or how the
    operating system runs.
  prefs: []
  type: TYPE_NORMAL
- en: To manage a virtual desktop machine with UEM, you will need to install the FlexEngine
    components onto the virtual desktop machine. Make sure you include this as part
    of your master image or parent virtual desktop machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five key use cases that UEM can be used with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Configuration Management**: Allows you to configure an application''s
    initial settings rather than deploying the application''s own default settings.
    You can configure predefined settings as one-time defaults, fully enforced (application
    starts with the user''s personalized settings every time), or partially enforced
    (application starts as configured, but allows the user to perform limited personalization),
    using the VMware UEM Application Profiler to capture predefined settings for an
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Environment Settings**: Allows you to centrally manage user environment
    settings such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application blocking
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Application shortcuts and file type associations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drive and printer mappings
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Files, folders, and registry settings
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Folder redirection
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Personalization**: Abstracts user-specific desktop and application settings
    from the underlying OS and then makes these settings available across multiple
    devices, Windows versions, and applications. It also supports operating system
    migration such as Windows 7 or Windows 10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Migration**: Allows an end user to effectively have roaming application
    and personalization settings so that they can move between different operating
    system versions, such as from Windows 7 to Windows 10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Configuration**: Using condition sets allows you to combine conditions
    based on variables such as user, location, and device, to deliver dynamic delivery
    of content and appearance, for example, delivering access to a network printer
    based on an end user''s location, or to create drive mapping that is based on
    the user''s identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SmartPolicies is a feature of Horizon and uses UEM to deliver a set of policies
    that are specific to virtual desktop machines.
  prefs: []
  type: TYPE_NORMAL
- en: To use SmartPolicies, it is recommended that you run View Connection Server
    Version 7.2 or later and is required for using Smart Policies with RDSH-published
    applications. You also require UEM 9.0 or later, but UEM 9.2 or later is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Smart Policies, administrators have a more granular level of control over
    an end user''s virtual desktop machine. Horizon 7 features can be dynamically
    enabled, disabled, or controlled based on the end user as well as other variables,
    such as the client device type, IP address, and desktop pool name. With SmartPolicies,
    you can configure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: USB redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clipboard behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client drive redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML access file transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bandwidth profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using UEM 9.1 or later, along with the Horizon Agent 7.0.1 or later,
    this setting applies when users are using either the Blast Extreme display protocol
    or the PCoIP display protocol.
  prefs: []
  type: TYPE_NORMAL
- en: UEM or Persona Management?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The question is which solution should you use? UEM is available as part of Horizon
    Enterprise Edition or as a standalone product, so that means higher or additional
    costs, unless, of course, you planned on purchasing Enterprise Edition in the
    first place.
  prefs: []
  type: TYPE_NORMAL
- en: UEM delivers a far greater set of configuration variables and features, as well
    as having a central management console that makes it far easier to manage and
    deploy. However, you may already have a more comprehensive UEM solution in place.
    If you are using a lesser edition of Horizon, then Persona Management may well
    deliver your requirements, and, if not, then maybe it's worth considering a third-party
    product, such as Liquidware ProfileUnity.
  prefs: []
  type: TYPE_NORMAL
- en: Printing from a virtual desktop machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A question that often comes up when deploying a VDI solution is "*How do you
    manage printing*?" As your virtual desktop is now effectively running on a server
    in the data center, does that mean that when you hit the print button, your print
    job comes out there? What about printer drivers? Typically, your desktop has the
    driver installed for the printer that is nearest to you, or it might be a locally-attached
    printer. Does that mean you need to install every possible printer driver on to
    your virtual desktop machines? Luckily, the answer to these questions is no, and,
    in this section, we will briefly cover how VMware Horizon View manages printing.
  prefs: []
  type: TYPE_NORMAL
- en: Bundled within Horizon View is an OEM virtual printing solution, **ThinPrint**,
    for which a company called Cortado is the OEM. ThinPrint allows your end users
    to print either to a network-based printer or to a local printer that is attached
    from the user's endpoint device to their virtual desktop machine via USB redirection.
    We will cover USB device management in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: To answer the question about the printer drivers that must be installed, ThinPrint
    uses a single, virtual print driver that replaces all other print drivers. You
    can still install a specific print driver, if necessary, for use cases where your
    printer has some additional features or functionalities. However, the virtual
    print driver provides support for most multifunctional printers, supporting features
    such as double-sided printing.
  prefs: []
  type: TYPE_NORMAL
- en: The other question is regarding location and where your print job prints are
    also addressed with ThinPrint, which provides a location-based printing feature
    that allows you to map to a printer that is nearest to your endpoint device. There
    are, of course, third-party solutions available such as UniPrint.
  prefs: []
  type: TYPE_NORMAL
- en: Managing USB devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There isn't a list that details every single device that works within Horizon
    View, as that would be one very long list, and it would be impractical to test
    everything out there, given the number of USB devices on the market.
  prefs: []
  type: TYPE_NORMAL
- en: Most USB devices should work in a Horizon View environment, as all it essentially
    does is redirect the USB traffic from the View client running on the endpoint
    device to the View agent running on the virtual desktop machine. A complete list
    of validated devices does not exist, as it would be a very long list and impossible
    to test every device on the market. If there are any questions about the functionality
    of a device, you should contact the USB device's manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: There might be some devices that will not work, purely due to the nature and
    the behavior of the device itself; for example, some security devices that check
    the physical properties of the machine or device they are plugged into. We used
    to classify USB webcams as unsupported devices. However, with the introduction
    of **Real Time Audio Video** (**RTAV**), these devices are now supported. In the
    next section, we will talk about how you can select which USB devices get redirected
    by using USB filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering supported USB devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some circumstances, you might not want to allow users to have the ability
    to plug in external USB devices and redirect them to their virtual desktop machine.
    The question is whether you allow users to plug USB devices into their physical
    desktops?
  prefs: []
  type: TYPE_NORMAL
- en: Horizon View has a feature that can prevent USB devices from being redirected
    to the user's VDI desktop. You can apply this using a policy on the endpoint device,
    the virtual desktop, or by means of an Active Directory Group Policy. For example,
    your organization might want to prevent USB memory sticks from being used, as
    this would give the user the ability to copy data from the virtual desktop machine
    (one of the reasons for the deployment of VDI is so that data is centralized and
    doesn't leave the data center).
  prefs: []
  type: TYPE_NORMAL
- en: You can create specific filters to include devices (by the manufacturer or by
    device type) that you want to allow, but block all others. So, if you have a corporate,
    standard-type device, it will be allowed. You could even go to the next level
    and choose a specific model of a device while blocking any other devices, even
    though they are from the same vendor.
  prefs: []
  type: TYPE_NORMAL
- en: Managing multi-function USB devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your environment, you might have USB devices that have several different
    functions, while still using a single USB connection. For example, a multimedia
    keyboard could have a touchpad mouse, speakers, a fingerprint reader, and the
    keyboard itself.
  prefs: []
  type: TYPE_NORMAL
- en: Horizon View supports a function known as **device splitting**. This allows
    you to just redirect certain components of that device rather than the entire
    device. With our multimedia example, you might want to leave the mouse as a local
    device on the endpoint, while redirecting the fingerprint reader to allow secure
    login to the virtual desktop.
  prefs: []
  type: TYPE_NORMAL
- en: ThinApp application virtualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ThinApp is an agentless application virtualization or application packaging
    solution that decouples applications from their underlying operating systems.
    It's designed to eliminate application conflict, streamline application delivery,
    and improve management. ThinApp licenses are included with the Horizon View license
    and can be used on both physical and virtual desktops, therefore providing a mechanism
    to deliver applications across your entire desktop estate.
  prefs: []
  type: TYPE_NORMAL
- en: How does application virtualization work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ThinApp encapsulates applications into a package consisting of a single `.exe`
    or `.msi` file and abstracts them from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The host operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any traditionally installed applications already running on the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other virtual applications running on the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications then run in their own isolated virtual environment, with minimal
    or zero impact on the underlying operating system, virtual filesystem, or virtual
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a ThinApp package, you are basically capturing all the application
    files, registry settings, and filesystem changes that an application requires
    for it to run. It also captures its own agent as part of the process, so the endpoint
    device requires nothing to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Once packaged, the application can be deployed (either streamed or installed)
    on to the virtual desktop machine or even a physical desktop. The only requirement
    ThinApp packages have to run is an underlining Windows operating system, either
    physical or virtual. When running, it's important to note that the package makes
    no changes to the OS of the machine it's running on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no requirements for additional backend infrastructure components,
    as all your ThinApp-packaged applications are stored in a file share on a file
    server. This means that you can centrally manage and easily update your packages
    so that all users will receive the updates the next time they launch the application.
    The following diagram shows a high-level ThinApp architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c8dabd-c3b7-495c-a2e7-6552faee09d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To summarize, ThinApp delivers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows Windows applications to be packaged, distributed, and executed as single
    `.exe` or `.msi` files on either physical or virtual desktop machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builds process links, a `Virtual OS` (`VOS`) with a compressed embedded filesystem,
    and registry, in a single file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires no pre-installed software on the end user machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a zero footprint on the underlying OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Necessitates no traditional installation or changes to the local OS registry
    or filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires no backend server infrastructure, other than a file share to store
    your ThinApp packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about ThinApp and how to use it in your environment, read *VMware
    ThinApp 4.7 Essentials*, by Peter Bjork, Packt Publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Antivirus software for virtual desktops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a traditional desktop model, an antivirus agent is installed, runs on every
    desktop, and is responsible for the performance of antivirus detection scans,
    while maintaining and updating the definition files containing information about
    the latest malware.
  prefs: []
  type: TYPE_NORMAL
- en: This model works well in the physical desktop world, but presents some challenges
    when running in a virtual desktop environment. When a detection scan starts, every
    virtual desktop's resource usage will increase significantly. This will result
    in end user performance degradation, and the desktop host server will become resource-bound.
    That's fine on a physical desktop, but now, in VDI, it's the servers hosting the
    desktops that are going to become resource-bound. When recomposing desktops or
    building them on demand, the desktops will have to download the definitions file
    each time, taking up network bandwidth and storage capacity. One last thing you
    need to take into consideration is the memory footprint of the typical desktop
    AV software that gets installed on each virtual desktop. You will need to allocate
    more memory to run the agents and scanning process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you have a vSphere host server running maybe 100 virtual desktops
    or so; what if, at 12:00 on Thursday, they all kick off a virus scan? That host
    is likely to become 100% utilized very quickly, both for CPU and storage I/Os,
    with the result being unresponsive desktops. Instead of affecting one user's desktop,
    you have now affected 100 users, desktops. You could schedule the scans so that
    they don't all happen at once, but, ideally, you need to look at alternative methods
    that are designed to work more specifically with a virtual desktop infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, if we are recomposing desktops or building them on demand, we must
    download the definitions file every time, which not only takes up network bandwidth,
    but also unnecessary storage capacity.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is required is a new approach to antivirus protection, specifically
    designed for virtual desktop infrastructure. With VMware vSphere 5.5, VMware introduced
    a product called **vShield Endpoint**, which has now been superceded by VMware
    NSX that addresses the problems inherent in antivirus scanning in large-scale
    virtual desktop implementations. It does this by offloading all antivirus operations
    into one centralized appliance. The scanning is then done at the hypervisor level
    and not on each of the virtual desktop machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although VMware provide the engine to help deliver the scanning process, they
    have also worked alongside and partnered with some of the leading antivirus software
    vendors to deliver the knowledge around how to identify and protect against viruses,
    malware, and other threats. They work with partners including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Bitdefender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kaspersky
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: McAfee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sourcefire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symantec
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trend Micro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols – Delivering the virtual desktop experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important elements of a virtual desktop solution is how you
    get the screen contents of the virtual desktop machine, which is running in the
    data center, delivered to the end user''s device they are connecting from, and
    how they interact using the keyboard and mouse. To do this, VMware Horizon View
    has the option to use several displays or delivery protocols: PCoIP, Blast Extreme,
    or RDP. In this section, we are going to cover each protocol, how it works in
    delivering the end user experience, and some more advanced technical details.'
  prefs: []
  type: TYPE_NORMAL
- en: PCoIP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PCoIP** is a high-performance display protocol designed and developed by
    Teradici ([http://www.teradici.com/](http://www.teradici.com/)). It has been purpose
    built to deliver virtual desktops over the LAN or WAN and to provide end users
    with the best feature-rich desktop experience.'
  prefs: []
  type: TYPE_NORMAL
- en: With PCoIP, the entire screen content is compressed, encrypted, and encoded
    in the data center before transmitting only the pixels across a standard IP network
    to PCoIP-enabled endpoint devices (such as zero clients) that use the hardware-based
    Teradici Terra 1 or Terra 2 chipset, or to Windows, macOS, or tablet devices running
    the software-based Horizon Client. The key thing to remember is that no data ever
    leaves the data center.
  prefs: []
  type: TYPE_NORMAL
- en: PCoIP supports high-resolution, full-frame rates, 3D graphics, HD media, multiple
    displays (up to four, depending on the endpoint device), and high-definition audio.
    PCoIP also supports USB peripheral redirection.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some legacy display protocols that were built just to deliver applications,
    PCoIP was designed and built from the ground up, specifically to deliver a full
    desktop experience, taking advantage of Teradici-based zero clients with an integrated
    graphics acceleration technology built into the silicon on these devices, or software-based
    clients. PCoIP ensures the best user experience, regardless of the end user location,
    whether that is on the LAN or even across a WAN. It adapts, dynamically adapts
    based on network conditions and user policy.
  prefs: []
  type: TYPE_NORMAL
- en: PCoIP host rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let's start by looking at how the different rendering models work. With
    a desktop PC, the applications, operating system, and graphics drivers work together
    locally to deliver the best performance on that PC. This is local client rendering.
  prefs: []
  type: TYPE_NORMAL
- en: If we move to a client rendering model, we now introduce a network between the
    components. Images are now sent across the network to the endpoint device, where
    they are processed locally using the resources of that endpoint device. Using
    this model introduces degradation of the application performance as it travels
    across the network from the host server to the client, and you would still need
    a powerful Windows-based endpoint device.
  prefs: []
  type: TYPE_NORMAL
- en: So, what about host rendering? In a host rendering scenario, the desktop PC
    environment that we previously described is pretty much the same. However, the
    PC is now running as a virtual desktop machine. This means that applications will
    work as they normally would on a physical desktop PC and the rendering is done
    at the host end. PCoIP then works by encrypting just the pixels on the virtual
    desktop machine running the View agent, and then sends them to the endpoint device
    running the View client, or to a zero client device running Teradici hardware,
    where the decoding takes place.
  prefs: []
  type: TYPE_NORMAL
- en: Using this model, you can easily deploy lower powered, non-Windows devices such
    as zero clients, as the applications have no dependencies on the endpoint on which
    they run.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-codec support with PCoIP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look at how an image is built up and how the content is rendered, some
    of the components of the image might require the use of different codecs to display
    the image, depending on what type of image it is. For example, you would use a
    different codec to display text from one that you would use to display videos.
  prefs: []
  type: TYPE_NORMAL
- en: PCoIP can analyze these different media image components and apply the appropriate
    codec for each pixel before compressing, encrypting, and sending the pixels to
    the endpoint device for decoding. Working in this way allows PCoIP to transmit
    the pixels more efficiently, which ultimately means less bandwidth and better
    performance. It also means that you can control the image content quality that
    is being delivered. We will talk about it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the image quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quality of the image that PCoIP delivers can be controlled through the AD
    Group Policy or SmartPolicies to deliver the appropriate image quality, depending
    on the use case. The image is built progressively from what is termed a **perceptually
    lossless image** to a **lossless image**, with the latter delivering a high-fidelity,
    pixel-perfect image. For example, would you really need to build a pixel-perfect
    image if you were just running Microsoft Word?
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to remember is that the quality of the image will have an
    impact on the bandwidth required to deliver it. We will cover these controls in
    more detail in [Chapter 10](8ebc54c4-3812-46fe-9534-fe38b78804a9.xhtml), *Fine-Tuning
    the End User Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic networking capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To manage the use of bandwidth, PCoIP employs adaptive encoders that automatically
    adjust the image quality on networks that are congested. The level of network
    congestion can be defined via policies that allow you to configure this based
    on use case, location, and so on. So, maybe the limits are different for those
    users based in the HQ on the main network, versus those in satellite/branch sites.
    When the network is no longer congested, then the maximum image quality is restored.
    PCoIP doesn't transfer any user data over the network. It just transmits pixels,
    and therefore uses a real-time **User Datagram Protocol** (**UDP**), rather than
    using a TCP protocol (used for **Voice over IP** (**VoIP**), to ensure a responsive
    and interactive end user experience. This will reduce the overall bandwidth requirement
    and deliver the best interactive user experience, based on the network bandwidth
    available at any particular time.
  prefs: []
  type: TYPE_NORMAL
- en: UDP does not employ error checking or correction, and therefore removes any
    overheads in processing the checking and correcting. The lack of retransmission
    delays that you would find with a TCP protocol means that it's ideal for streaming
    media. For the end user experience, these delays translate to jerky movements,
    most commonly experienced when watching video content.
  prefs: []
  type: TYPE_NORMAL
- en: PCoIP offloading with the Teradici PCoIP Hardware Accelerator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the software solutions discussed in the previous sections, Teradici
    also offers a server offload card called the **Teradici PCoIP Hardware Accelerator**.
    This PCI card is installed in the servers that are hosting the virtual desktop
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to say about this card is that it is not a **Graphics Processing
    Unit** (**GPU**) card. I often hear some confusion around this, and users assume
    that, by adding an accelerator card, you would get the OpenGL and DirectX capabilities,
    but this is not the case. You might improve the overall experience and performance,
    but you won't be adding additional GPU features.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of this card is purely to take the load away from the CPU of the
    host server when it is processing image encoding operations. Offloading the image
    encoding to a specialized hardware solution reduces CPU utilization, which, in
    turn, delivers a consistent end user experience, thereby allowing applications
    to run more smoothly as they have the resources they require. If you compare it
    to something such as TCP Offload Engine or the TOE card used in the IP storage
    world for iSCSI, it's much better to use hardware-based cards than it is to use
    software initiators.
  prefs: []
  type: TYPE_NORMAL
- en: Freeing up CPU cycles and the overall load on the servers' CPU will potentially
    result in better consolidation ratios of the virtual desktops, that is, more virtual
    desktops per host server. Typically, you will see a 1.2 fold increase.
  prefs: []
  type: TYPE_NORMAL
- en: The accelerator card can also be used in conjunction with a GPU. In this scenario,
    the card efficiently encodes the extra pixels that are generated by the GPU, ensuring
    the end user has all the benefits that the local GPU can deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Teradici host card for physical PCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Teradici also has a solution for physical workstations to leverage the PCoIP
    protocol: the **PCoIP Remote Workstation card**. This card is not actually for
    virtual desktop sessions, but, instead, it allows you to add a Teradici host card
    to a physical workstation, connect to your workstation, and send remote graphics,
    audio, and USB from the workstation to a PCoIP-enabled endpoint device, such as
    a zero client. Think of it as picking up your desktop PC and putting it in the
    data center, and then running a very long video, mouse, and keyboard cable to
    it. This use case is typically deployed for high-powered rack mount workstations
    or PCs.'
  prefs: []
  type: TYPE_NORMAL
- en: So, how does that fit in with Horizon View? Quite simply, the connection to
    the physical desktop from the client device is managed using Horizon View and
    the connection server brokers the session in the same way it would when connecting
    to a virtual desktop machine. The pixels and keyboard and mouse strokes are sent
    over the network using the PCoIP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: How the PCoIP connection process works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following describes how the PCoIP connection process works when an end
    user logs in and requests a virtual desktop machine:'
  prefs: []
  type: TYPE_NORMAL
- en: The Horizon Client sends the end user's credentials for authentication via HTTPS
    to the external URL of the PCoIP External URL that you configured on the security
    server or Unified Access Gateway. To do this, it uses the XML-API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTPS authentication data is passed through from either the Unified Access Gateway
    or the security server to the connection server. The security server uses IPsec
    protected AJP13-forwarded traffic, from the security server to the connection
    server that it is paired with. The desktop pools and apps that the user is entitled
    to are read from the connection server and then displayed as available resources
    displayed in the Horizon Client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end user launches either a virtual desktop or published app session. This
    connection is initiated on TCP port `4172` (PCoIP port) to the Unified Access
    Gateway or the security server. This session initiation process is called the
    **PCoIP session handshake**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A bi-directional PCoIP connection is established using UDP port `4172` (ensure
    that this port is not being blocked) to send the session data from the Horizon
    client and the configured `pcoipExternalUrl` to the Unified Access Gateway or
    the security server. Details of the PCoIP session are then forwarded from the
    Unified Access Gateway or the security server back to the Horizon Agent running
    on the virtual desktop machine and then to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pcoipExternalUrl` is only used for the Unified Access Gateway. If you are
    using security servers for external access, then the PCoIP external URL on the
    paired connection server will be used instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95435ec1-d35d-42b1-91b0-59816387fa9c.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we are going to look at the **Blast Extreme** protocol
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Blast Extreme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blast Extreme is a new VMware developed protocol that uses the H.264 video codec
    as an option if you have the appropriate GPU acceleration resources available
    in the host servers, allowing it to deliver the user experience to H.264-enabled
    client devices. H.264, or MPEG-4 part 10, is an advanced video coding, or MPEG-4
    AVC, solution. It is a standard of video compression that is block-oriented, motion
    compensation-based. It's a commonly used video format, and an example of where
    it is used is in the delivery of DVD video content.
  prefs: []
  type: TYPE_NORMAL
- en: Blast as a VMware protocol has been around for a while and was first seen in
    Horizon 5.2 a few years ago, where it was used to deliver HTML5 access to virtual
    desktop machines. Now, however, it's not just limited to delivering HTML5 access;
    it can also deliver the user experience to the latest client devices using standard
    HTTPS ports.
  prefs: []
  type: TYPE_NORMAL
- en: The Blast Extreme delivery method is also on feature parity with PCoIP and supports
    similar functionality, such as client drive redirection, USB, unified communications,
    and local printing. Where they start to differ is in resource consumption, with
    Blast using far fewer CPU cycles, and delivery protocols, and more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Like PCoIP, Blast Extreme can compensate for an increase in latency or a reduction
    in bandwidth and dynamically adjust; however, it can also leverage both TCP and
    UDP, whereas PCoIP is UDP only.
  prefs: []
  type: TYPE_NORMAL
- en: You can also connect multiple monitors. Depending on the endpoint device, up
    to four monitors are supported, each one running at 2,560 x 1,600\. Or you can
    run three 4K monitors running at 3,840 x 2,160 for Windows 7 remote desktops with
    Aero disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the other features of Blast Extreme are detailed in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blast Adaptive UX**: Delivers end user access to Horizon View virtual desktop
    machines and hosted applications via the Horizon View Client or browser-based
    clients, using either Blast Extreme, PCoIP, or RDP. It automatically adapts to
    network conditions, delivering the best experience possible, through either.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blast Multimedia**: Delivers rich video playback for Flash, HTML5, QuickTime,
    Microsoft Silverlight, and Windows Media.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blast 3D Services**: Built on the broadest virtualized graphics capabilities
    in the industry, including hardware-accelerated graphics with NVIDIA GRID vGPU
    technology. With Blast 3D enabled, Horizon View supports either up to two monitors
    running up to 1,920 x 1,200, or a single 4K monitor running at 3,840 x 2,160.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blast Live Communications**: Delivers full access to communications tools
    such as headsets and webcams, for rich audio and video. Supports applications
    such as Skype, Google Hangouts, and Cisco WebEx.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blast Unity Touch**: Delivers a more intuitive interface, allowing you to
    use Windows desktops, applications, and files from a mobile device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blast Local Access**: Supports connecting peripheral devices such as USB
    flash drives, printers, smart card devices, and smartphones to your virtual desktop
    machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blast Horizon Clients**: Blast-enabled clients for delivering a high-end
    user experience to endpoint devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Blast Extreme connection process works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps describe how the Blast Extreme connection process works:'
  prefs: []
  type: TYPE_NORMAL
- en: As with PCoIP, with Blast Extreme, the Horizon Client sends the end user's credentials
    for authentication via HTTPS to the external URL of the PCoIP external URL that
    you configured on the security server or Unified Access Gateway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTPS authentication data is passed through from either the Unified Access Gateway
    appliance or the security server to the connection server. The security server
    uses AJP13-forwarded traffic from the security server to the connection server
    it are paired with. The desktop pools and apps that the user is entitled to are
    read from the connection server and then displayed as available resources displayed
    in the Horizon client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end user launches either a virtual desktop or published app session from
    the Horizon client. A session handshake occurs over HTTPS on TCP port `443` to
    the Unified Access Gateway Appliance or the security server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A secure WebSocket is established on TCP port `443`) to allow the session data
    between the Horizon client and the Unified Access Gateway Appliance or the security
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Blast Secure Gateway Service (either Unified Access Gateway Appliance or
    security server-based) will attempt to establish a UDP WebSocket connection on
    port `443`. If the connection fails, or is blocked for some reason, then the Blast
    Secure Gateway Service will revert to the initial WebSocket TCP port `443` connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7e6984a-3eab-48cf-b24e-83f8be4676c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For more detailed port settings, follow this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://techzone.vmware.com/resource/](https://techzone.vmware.com/resource/network-ports-vmware-horizon-7)[network-ports-vmware-horizon-7](https://techzone.vmware.com/resource/network-ports-vmware-horizon-7).'
  prefs: []
  type: TYPE_NORMAL
- en: Alternative display protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of other mainstream desktop protocols available on the market,
    some that work with VMware Horizon, and others that are used by Horizon's competitors.
    The main protocols available today are Microsoft **Remote Desktop Protocol** (**RDP**)
    and Citrix **Independent Computing Architecture** (**ICA**). These are described
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: RDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RDP was developed for Microsoft and is used primarily to connect to a remote
    machine, server, desktop, or virtual machine using TCP IP. The RDP is now more
    commonly known as the **Remote Desktop Connection**. You probably use it daily
    to connect remotely to your server infrastructure in order to manage servers remotely.
  prefs: []
  type: TYPE_NORMAL
- en: When you connect to the remote desktop or machine, you are essentially connecting
    to a terminal service component, which then relays the screen content back to
    the client, along with keystrokes and mouse movements.
  prefs: []
  type: TYPE_NORMAL
- en: ICA protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ICA is another display protocol that is used by Citrix in its products, XenDesktop
    and XenApp. It is similar in design to other protocols in that it is used to deliver
    screen content and keyboard strokes to a client device over a TCP IP network connection.
  prefs: []
  type: TYPE_NORMAL
- en: You connect using an ICA client, such as **Citrix Receiver**, installed on your
    endpoint device. This loads an ICA file containing the details of the remote system
    you are connecting to and any properties to apply to that session.
  prefs: []
  type: TYPE_NORMAL
- en: What about **High Definition Experience** (**HDX**)? HDX is not a protocol or
    a technology, but rather a marketing brand for HDX. HDX encompasses a number of
    Citrix technologies that describe the entire user experience rather than concentrating
    on just the protocol element. You will also see some sub-brands fall under HDX,
    such as HDX MediaStream, HDX RealTime, and HDX 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Which protocol should you use – Blast Extreme, PCoIP, or RDP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good understanding of PCoIP, Blast Extreme, and RDP, which
    one would you choose?
  prefs: []
  type: TYPE_NORMAL
- en: The most compelling reason to go with PCoIP is the fact that it uses the UDP
    protocol, which is much better suited to streaming media and therefore lends itself
    perfectly to the characteristics of virtual desktop delivery, but, as discussed,
    Blast can also use UDP as the delivery protocol. Just to highlight this again,
    UDP is not concerned with how the data ends up on the endpoint device; it's only
    concerned with the speed of delivery and how quickly it gets there.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, RDP uses TCP as its protocol, which is widely used across
    the internet. The key difference with TCP is that it is concerned with how the
    data is being received. TCP requests an acknowledgment from the endpoint device
    as to whether it has received all of the packets successfully. If the endpoint
    device does not receive what it was expecting, then it replies, asking TCP to
    either stop sending packets or to narrow the amount that it receives. UDP just
    keeps sending and is much speedier, simply because there is no acknowledgment
    packet back from the endpoint device.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Blast Extreme would come in, as it can use either TCP or UDP as
    the delivery protocol and is able to determine what network capacity it has available
    to it and adjust accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Blast Extreme will also use fewer resources on the endpoint device, especially
    if you offload the decoding using the NVIDIA GRID technology. However, the only
    point to be aware of is that when using TCP as the delivery protocol, it could
    potentially consume more bandwidth, as it compensates for packet loss.
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases where PCoIP won't be the appropriate protocol and Blast
    Extreme or RDP would need to be used. The one we see most often is when the required
    network ports are being blocked by corporate policy, or from remote locations
    that lock down internet connections.
  prefs: []
  type: TYPE_NORMAL
- en: When your desktop is displayed back to you, PCoIP uses UDP port `4172` to send
    the pixels. This port is sometimes blocked, as it's not typically used. The result
    of this port being blocked is that, even though you will be able to log on to
    your virtual desktop via the View client and everything looks OK' you will just
    receive a black screen. The black screen is due to the pixels being blocked as
    they are sent. In this example, the workaround is to access the desktop from an
    HTML5-enabled browser using Blast Extreme, which uses standard HTTPS ports. We
    will cover this in [Chapter 10](8ebc54c4-3812-46fe-9534-fe38b78804a9.xhtml), *Fine-Tuning
    the End User Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway here is to engage with your networking and security teams when
    planning how users connect to their virtual desktop machines and look at how the
    users are working and from what locations. It may well be that you don't need
    external access, and therefore WAN limitations are no longer a consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have talked about how to deliver graphics via the delivery protocol,
    in the next section, we are going to look at the options for enabling high-end
    graphics in virtual desktop machines.
  prefs: []
  type: TYPE_NORMAL
- en: Horizon View Hardware-accelerated graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Early versions of virtual desktop technology faced challenges when it came to
    delivering high-end graphical content, as the host servers were not designed to
    render and deliver the size and quality of images required for such applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a brief history and background. The technology to support high-end
    graphics was released in several phases, with the first support for 3D graphics
    released in vSphere 5, with View 5.0 using software-based rendering. This gave
    us the ability to support things such as the Windows Aero feature, but it was
    still not powerful enough for some of the high-end use cases due to this being
    a software feature.
  prefs: []
  type: TYPE_NORMAL
- en: The next phase was to provide a hardware-based GPU virtualization solution that
    came with vSphere 5.1 and allowed virtual machines to share a physical GPU by
    allowing virtual machines to pass through the hypervisor layer to take advantage
    of a physical graphics card installed inside the host server.
  prefs: []
  type: TYPE_NORMAL
- en: If we had this conversation a couple of years ago and you had a use case that
    required high-end graphics capabilities, then virtual desktops would not have
    been a viable solution. As we just discussed, in a VDI environment, graphics will
    be delivered using a virtualized, software-based graphics driver as part of the
    hypervisor.
  prefs: []
  type: TYPE_NORMAL
- en: Also, don't forget that, as we are now using servers to host the virtual desktops,
    we are using the power of the graphics card in the server, and servers aren't
    renowned for their high-end graphics capabilities and have limited GPU power,
    as typically, all a server needs to do is display a management console.
  prefs: []
  type: TYPE_NORMAL
- en: That has all changed now. With the release of View 5.2 back in 2013, the ability
    to deliver hardware-accelerated graphics became a standard product feature with
    the introduction of **Virtual Shared Graphics Acceleration** (**vSGA**), which
    was then followed by the launch of **Virtual Dedicated Graphics Acceleration**
    (**vDGA**).
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss these two technologies in the following sections of this chapter.
    We will also discuss the latest installment of graphics capabilities in Horizon
    View, with **Virtual Graphics Processing Unit** (**vGPU**).
  prefs: []
  type: TYPE_NORMAL
- en: vSGA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vSGA implementation allows for multiple virtual desktop machines to share
    a physical GPU card, which is installed inside the ESXi host server that is hosting
    those virtual desktop machines.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, the virtual desktop machines do not have direct access to a dedicated
    physical GPU card. Instead, the standard VMware SVGA 3D graphics driver that is
    part of VMware Tools is installed on the virtual desktop's operating system. The
    SVGA driver is a VMware driver that provides support for DirectX 9.0c and OpenGL
    2.1.
  prefs: []
  type: TYPE_NORMAL
- en: In this configuration, the driver supplied by the graphics card manufacturer
    (VIB) is installed on the ESXi hypervisor rather than the virtual desktop machine's
    own operating system. Graphics commands from user sessions are intercepted by
    this driver and sent to the hypervisor, which controls the GPU in the ESXi server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delivery to the user''s endpoint works in the same way, where DevTAP encodes
    the user experience to PCoIP or Blast Extreme, and delivers it to the end user''s
    device, either in an HTML5 browser or Horizon Client. The following diagram shows
    an overview of the vSGA architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab9c0469-21d3-4d39-b404-51a826fe3b1d.png)'
  prefs: []
  type: TYPE_IMG
- en: There are several configurations and support options to consider, which we will
    cover in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: vSGA-supported graphics cards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'vSGA will support OpenGL 2.1- and DirectX 9-based applications running either
    on Windows 7 or 8 virtual desktop machines, virtualized on VMware vSphere 5.1
    and greater, using one of the following manufacturer''s GPU cards:'
  prefs: []
  type: TYPE_NORMAL
- en: Intel HD Graphics P4700, and Intel Iris Graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tesla
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NVIDIA GRID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMD FirePro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the latest compatibility guide and supported graphics cards, please click
    on the following link: [http://www.vmware.com/resources/compatibility/search.php?deviceCategory=vsga](http://www.vmware.com/resources/compatibility/search.php?deviceCategory=vsga).'
  prefs: []
  type: TYPE_NORMAL
- en: How many virtual desktops are supported by vSGA?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a question that often gets asked when talking about delivering hardware-based
    graphics within a Horizon View environment, so let's spend some time understanding
    this. Within Horizon View, you can create different desktop pools depending on
    the use case, as we will cover in [Chapter 8](d44c9a7b-bcae-4758-a857-197be388a4be.xhtml),
    *Configuring and Managing Desktop Pools – Part 1*, where one of the desktop pools
    will be configured to use high-end graphics. Typically, you would not want to
    give all users access to a hardware-based GPU, hence the reason you would create
    a desktop pool for this use case.
  prefs: []
  type: TYPE_NORMAL
- en: So, to answer the question, the number of virtual desktops you can allocate
    to a GPU is dependent on the amount of video memory (VRAM) that you allocate to
    each virtual desktop. The thing to bear in mind is that the resources are shared,
    and therefore normal VMware virtualization rules apply. The first thing to note
    is how memory is shared.
  prefs: []
  type: TYPE_NORMAL
- en: Half of the video memory allocated to a virtual desktop machine is allocated
    from the GPU card's memory, and the other half is from the host server's memory.
    When sizing your host servers, you need to ensure that you have enough memory
    configured in the server to allocate this as video memory.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this, and on the number of virtual desktops supported being based on
    the amount of allocated VRAM, let's look at how that works out.
  prefs: []
  type: TYPE_NORMAL
- en: The default amount of VRAM allocated to a virtual desktop machine is 128 MB.
    So, in this example, 64 MB will come from the GPU and the other 64 MB from the
    host server. If you then take a GPU card that has 4 GB of VRAM on board, you will
    be able to support 64 virtual desktops (4 GB or 4,096 MB divided by 64 MB from
    the GPU = 64 virtual desktop machines).
  prefs: []
  type: TYPE_NORMAL
- en: With Horizon View, you can allocate a maximum of 512 MB of VRAM per virtual
    desktop machine. If you apply this to the preceding example using the same 4 GB
    GPU card, you now reduce the number of supported virtual desktops to 16 (4 GB
    or 4,096 MB divided by 256 MB from the GPU = 16 virtual desktop machines).
  prefs: []
  type: TYPE_NORMAL
- en: With the AMD graphics solutions, the maximum number of supported desktops is
    15 desktops per GPU.
  prefs: []
  type: TYPE_NORMAL
- en: We stated previously that normal VMware virtualization rules apply, so let's
    explain exactly what that means. Basically, what happens when you can't fulfil
    a virtual desktop machine's specification and there are insufficient resources?
    It won't boot or power on, right? It's the same for GPU configuration. If you
    configure a desktop pool with more virtual desktop machines than you can support
    on that GPU, they will not boot.
  prefs: []
  type: TYPE_NORMAL
- en: If you do happen to configure more virtual desktop machines in a pool where
    you probably cannot guarantee the GPU resources to be available, set the Hardware
    3D setting in the View Administrator console to Automatic. Doing this allows Horizon
    View to revert to the software-based 3D rendering to deliver the virtual desktop
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: vDGA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While vSGA works on a shared basis, vDGA allows for an individual VM to have
    its own dedicated access to a physical GPU card installed in the ESXi host server.
    This allows the virtual desktop machine to have a higher level of graphics performance,
    making it perfect for such use cases as CAD/CAM applications, as it supports DirectX
    (9, 10, and 11), OpenGL 4.4, and NVIDIA CUDA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture for vDGA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13660d3c-57e2-4c16-a4d3-8c75c8ecf8cd.png)'
  prefs: []
  type: TYPE_IMG
- en: The vDGA solution makes use of a feature called **VMDirectPath I/O pass-through**,
    sometimes referred to as **PCI pass-through**, which allows the virtual desktop
    machine to pass through the hypervisor layer and directly access the hardware
    in the host server. In this case, the hardware in question is the NVIDIA GPU cards.
  prefs: []
  type: TYPE_NORMAL
- en: As a VDI Desktop is mapped directly to a GPU on a one-to-one basis, you cannot
    use vSphere features such as HA, DRS, or vMotion.
  prefs: []
  type: TYPE_NORMAL
- en: How many virtual desktops are supported with vDGA?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike vSGA, which is limited by the amount of memory on the GPU card, vDGA
    is limited purely by the number of GPUs or GRID cards you can physically fit into
    the host server. This is dependent on your server vendor and what they support.
  prefs: []
  type: TYPE_NORMAL
- en: Server vendors offer NVIDIA GRID-enabled servers that are prebuilt, and therefore
    this technology is only available from the OEM channel. The primary reason is
    that servers require additional power and cooling components to drive the GRID
    cards.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an NVIDIA GRID K2 GPU card has two GPUs on board, which would mean
    that you can allocate four virtual desktop machines to this card. Depending on
    your server hardware platform, you could install more than one card, thereby increasing
    the number of users that have access to a hardware-enabled GPU in their virtual
    desktop.
  prefs: []
  type: TYPE_NORMAL
- en: vDGA-supported graphics cards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of the GPU cards that are supported with vDGA:'
  prefs: []
  type: TYPE_NORMAL
- en: NVIDIA GRID, NVIDIA Tesla, and NVIDIA Quadro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMD FirePro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the latest compatibility guide and supported graphics cards, please click
    on the following link: [http://www.vmware.com/resources/compatibility/search.php?deviceCategory=vdga](http://www.vmware.com/resources/compatibility/search.php?deviceCategory=vdga).'
  prefs: []
  type: TYPE_NORMAL
- en: vGPU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we have talked about two different models for delivering
    high-end graphics. However, there are a couple of limitations to each of these
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: With vSGA, you get the scalability in terms of the number of users that can
    use the GPU card; however, because it does not use the native driver provided
    by the GPU vendor, then some of the ISVs will not certify their applications running
    on this solution. They would need to certify the VMware SVGA driver, as that's
    the driver that's used.
  prefs: []
  type: TYPE_NORMAL
- en: So, the answer to tackle the ISV support issue is to use vDGA, which does use
    the native GPU vendor's graphics driver, but now you are limited in terms of scalability
    and the high cost. Having a virtual desktop machine dedicated to a GPU, with only
    a handful of GPUs available in each host server would make for quite an expensive
    solution. Having said that, there may be a use case where that would be the correct
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a solution that is the best of both worlds; a solution that
    takes the shared GPU approach for scalability, yet uses the native graphics drivers.
    That solution is called vGPU, and was launched as part of Horizon 6 and the 6.1
    release.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture for vGPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/167e6018-2e9d-424a-b1d7-4869560d1a6b.png)'
  prefs: []
  type: TYPE_IMG
- en: In this model, we have the native NVIDIA driver installed in the virtual desktop
    machines, which then has direct access to the NVIDIA GRID card in the host servers.
    The GPU is then effectively virtualized and time-sliced, with each virtual desktop
    machine having a slice of that time.
  prefs: []
  type: TYPE_NORMAL
- en: vGPU is only available with VMware vSphere 6 and Horizon View 6.1 and later.
  prefs: []
  type: TYPE_NORMAL
- en: How many virtual desktops are supported with vGPU?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With vGPU, the number of supported users/virtual desktop machines is based
    on different profiles. These profiles are detailed in the following diagram and
    give you the number of users, number of supported monitors, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/374dfd12-544d-4507-8c26-0aa812132f2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As with the vDGA and vSGA solutions, you need to check that you have the correct
    supported hardware. In addition, you should also check that your applications
    are supported in these configurations. You can find the current list of supported
    applications by following the link to the NVIDIA website: [http://www.nvidia.com/object/grid-isv-tested-applications.html](http://www.nvidia.com/object/grid-isv-tested-applications.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Unified communications support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like high-end graphics, if we had a conversation about running a unified communications
    solution or VoIP session on a VDI desktop a couple of years ago, I would have
    described it as Kryptonite for VDI! Although it technically works, the first call
    might have acceptable performance, but adding more users would ultimately bring
    the servers to their knees with the amount of traffic generated and resources
    required to conduct the calls. Eventually, the experience would have become completely
    unusable. Unified communications was not a good use case for VDI.
  prefs: []
  type: TYPE_NORMAL
- en: However, this has all changed, and you can now happily use a unified communications
    solution with your virtual desktop. There was always a great use case to deploy
    unified communications with VDI; it's just that it never worked! Take, for example,
    a call center environment. with the ability to provide a DR solution or allow
    users to work from home during a snowy day and still be able to make and answer
    calls as if they were in the office.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why didn''t it work? Quite simply, because when you placed a VoIP call
    from your virtual desktop, the call would go over the PCoIP protocol, causing
    bandwidth issues and making your desktop perform slowly, and placing an additional
    load on the servers in having to process the call. This is detailed in the following
    diagram, which shows how it was before and the result afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1e051d8-deb7-4453-8718-a91e9ac57d8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To solve these issues, and to enable a working solution, VMware concentrated
    on three key areas and delivered the following new features/enhancements:'
  prefs: []
  type: TYPE_NORMAL
- en: Offloading media processing to the client device by removing the load that was
    placed on the server in the data center
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimized point-to-point media delivery, eliminating the hairpin effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-quality UC VoIP and video with QoS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do unified communications work now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A remote procedure call utilizes a virtual channel to allow the different components
    of a softphone, running on a VDI desktop, to communicate and pass voice and video
    data to other softphone components in the client device. These out-of-band communications.
  prefs: []
  type: TYPE_NORMAL
- en: The call-control stack (a **SIP stack** if using SIP signaling) communicates
    with the call-control server or call manager to register or establish the call.
  prefs: []
  type: TYPE_NORMAL
- en: A media engine on the client device performs the encoding and decoding of voice
    and video streams into native voice and video codecs and then streams the VoIP/video
    stream directly to the other endpoint (as directed by the call manager server),
    therefore setting up a peer-to-peer call and not going through the data center.
    This now eliminates the hairpin effect.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, VMware supports solutions from Cisco, Mittal, Avaya, and Microsoft
    Lync 2013\. We will cover the **Microsoft Skype (Lync)** solution in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Support for Microsoft Skype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on what we just discussed, VMware Horizon now supports Microsoft Skype
    with the Horizon Virtualization Pack for Skype for Business. This includes full
    support for VoIP and video. The following diagram shows the process of how the
    client works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39d67b6b-0d4d-4fb7-9049-a89dc9682ec3.png)'
  prefs: []
  type: TYPE_IMG
- en: To enable Skype, you need to ensure that the Horizon Virtualization Pack for
    Skype for Business is installed on the endpoint device, along with the Horizon
    Client and Microsoft Skype client. VMware has implemented Microsoft's **Dynamic
    Virtual Channels** (**DVC**) inside the PCoIP protocol to enable this feature.
    DVC provides the communication path between the virtual desktop machine and the
    client endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some limitations to the solution that should be mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuning pages are not available for the audio device and the video device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-view video is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recording of conversations is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call delegation is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response group agent anonymization feature is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining meetings anonymously is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Skype for Business VDI plugin with a Skype for Business Phone Edition
    device is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-Time Audio-Video (RTAV)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following on from the unified communications support, the next question we hear
    concerns support for plugging in a USB webcam and using it with a virtual desktop.
  prefs: []
  type: TYPE_NORMAL
- en: The issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like unified communications and VoIP, using a webcam, or using audio in and
    audio out on a virtual desktop machine was not initially supported due to the
    high bandwidth requirements these types of devices require, thereby resulting
    in poor performance. Any redirection of these types of devices was previously
    handled with the USB redirection feature of the PCoIP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: This is how audio-in used to work, but audio-in using a 3.5 mm jack socket did
    not work at all. Audio-out did work when using the PCoIP audio redirection feature,
    which was much better than using USB redirection. This was because the client
    system was unable to split a USB audio device, which resulted in the audio-out
    functionality remaining local, while the audio-in got redirected. This implies
    that using a USB headset in a VoIP solution would require the entire headset (audio-in
    and audio-out) to be forwarded to the guest.
  prefs: []
  type: TYPE_NORMAL
- en: How does RTAV fix this issue?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**RTAV** does not use a USB to forward audio and webcam devices. Instead, the
    USB devices remain connected to the local client, and the audio and images are
    taken from the local device. Audio and image data are encoded and delivered to
    the guest virtual desktop machine, where they are then decoded. VMware installs
    a virtual webcam and a virtual microphone virtual desktop machine. These devices
    are used to play back the audio and video. You will see these device entries in
    the device manager of your virtual desktop machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'RTAV can support the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting webcams and audio devices simultaneously, used for VoIP-based video
    conferencing apps such as Skype.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio-in only (no video) for VoIP (voice-only) apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webcam only; used for webcam monitoring type apps (CCTV, for example), and taking
    photos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL Content Redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **URL Content Redirection** feature allows you to configure a URL to either
    open on a local browser on the endpoint device, or open on the virtual desktop
    machine. Which content opens in which is configured by using a **GPO**.
  prefs: []
  type: TYPE_NORMAL
- en: The use case for doing this is to separate internal browsing from internal browsing.
    It may be that if you want to look at secure content, then you would use the browser
    on the virtual desktop machine, since, if the data doesn't leave the data center,
    then any other browsing can happen locally. Another case may be that you want
    to limit bandwidth usage into the data center, and if users are browsing heavy
    content, they can use their local internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of URL that you can configure for redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: URLs that a user enters into the address bar of the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Links in an application, such as Outlook or Word, that users can click
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizon clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Horizon client is basically where your virtual desktop machine''s screen
    is decoded and displayed on an endpoint device. There are two distinct types of
    Horizon Clients: a software-based version, which is installed on the user''s endpoint
    device, and a hardware-based version, which uses zero or thin clients.'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the View client options in [Chapter 12](e1944fcc-6ae9-4db7-b51b-db75e37e01ab.xhtml),
    *Horizon Client Options*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the Horizon View architecture and the different
    components that make up the complete solution. We covered key technologies, such
    as how linked clones and instant clones work to optimize storage, and then we
    introduced some of the features that go toward delivering a great end user experience,
    such as delivering high-end graphics, unified communications, profile management,
    and how the protocols deliver the desktop to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand all of these features and components, how they work,
    and how they fit into the overall solution, in the upcoming chapters, we will
    be taking a deeper look at how to configure them.
  prefs: []
  type: TYPE_NORMAL
