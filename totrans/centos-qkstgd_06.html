<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Process Management</h1>
                </header>
            
            <article>
                
<p>Processes access multiple resources in a running system. Process management is essential to manage these resources effectively and keep your system up and running smoothly. In this chapter, you will learn how to view processes running on a Linux system and how to employ interactive management from the command line. Then, you will learn how to control different programs running on a Linux system using the command line. You will also learn how to communicate with different processes using signals and how to modify their priority level on a running system.</p>
<p class="mce-root"/>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding processes</li>
<li>Viewing current processes</li>
<li>Communicating with processes using signals</li>
<li>Monitoring processes and load averages</li>
<li>Managing a processes' priority levels with nice and renice</li>
<li>Controlling jobs on the command line</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding processes</h1>
                </header>
            
            <article>
                
<p>This section deals with various concepts related to processes, such as their types, states, attributes, and so on. Process management is an essential skill that all types of users of Linux systems should master.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining a process</h1>
                </header>
            
            <article>
                
<p>A process is an instance of a program in execution. It differs from a program or command in the sense that a single program can start several processes simultaneously. Each process uses several resources, as mentioned in the following list:</p>
<ul>
<li>An address space in memory</li>
<li>Each process has some security properties, such as ownership, privileges, and so on</li>
<li>Each process has a state</li>
<li>Each process has local and global environment variables</li>
<li>Each process has a scheduling context</li>
<li>Each process has allocated resources, such as file descriptors, network ports, and so on</li>
<li>A kernel keeps tracks of each process by assigning each process a unique <strong>process ID</strong> (<strong>PID</strong>) number</li>
<li>A user's program accesses the information for each process through a directory called <kbd>/proc/PID</kbd>, which is maintained by a kernel</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Process creation on a Linux system</h1>
                </header>
            
            <article>
                
<p>All processes on CentOS 7 are descendants of the first system process, known as <strong>systemd</strong>. An existing process (parent) duplicates its own address space using a fork system call to create a new process (child) structure. Each new process is assigned a unique PID for tracking process state, CPU usage, memory usage, and other characteristics. PIDs are generally assigned in ascending order when a new process is created. The PID 1 is assigned to the systemd process. The PID and <strong>PPID</strong> (short for <strong>Parent Process ID</strong>) are the attributes of each process running on a Linux system.</p>
<p>PPID is the PID of a parent process that starts the child process. If a parent dies, that process is known as an <strong>orphan</strong> process. For a long time, the orphan process has been adopted by the <kbd>init</kbd> (PID=1) process. However, nowadays, in recent kernels, <kbd>kthread</kbd> (PID=2) is the adoptive process for orphan child processes.</p>
<p>A <strong>thread ID</strong> (<strong>TID</strong>) number is the same as PID for single-threaded processes. For multi-threaded processes, each thread shares the same PID, but a different TID.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Processes types</h1>
                </header>
            
            <article>
                
<p>There are different types of processes, based on the task they are performing. Some of the common types of processes that exist on a Linux system are described in the following subsections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interactive processes</h1>
                </header>
            
            <article>
                
<p>This type of process is started by a user, either on the command line or a through graphical user interface, such as Bash shell, Firefox, <kbd>top</kbd> command, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Batch processes</h1>
                </header>
            
            <article>
                
<p>These kind of processes are scheduled to run from the Terminal and disconnect themselves from the Terminal at a later stage. An example of this is <kbd>updatedb</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Daemons</h1>
                </header>
            
            <article>
                
<p>These processes are automatically started on system boot up and continue to run until shutdown or until stopped in-between manually. They continuously wait for a user or system request in the background. By convention, the names of most daemon programs end with the letter <kbd>d</kbd>, such as <kbd>httpd</kbd>, <kbd>named</kbd>, <kbd>mysqld</kbd>, and so on.</p>
<p> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Threads</h1>
                </header>
            
            <article>
                
<p>Threads are also known as <strong>lightweight processes</strong> (<strong>LWPs</strong>). Each thread has a main process whose memory and other resources are shared by a thread. Each thread is scheduled and runs independently by the kernel. A thread can end at any time without terminating the whole process, and a process can also create new threads at any time. For example, when we open multiple tabs in a Firefox browser, it creates multiple threads, and each thread runs independently.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Kernel threads</h1>
                </header>
            
            <article>
                
<p>These are kernel tasks that are started and used by the kernel, and users do not have much control over them, such as <kbd>kthreadd</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Process states</h1>
                </header>
            
            <article>
                
<p>Linux is a multitasking operating system, where each CPU core executes one process at any single point in time. This process of scheduling (constantly shifting processes on and off the CPU), and allocating CPU time as per priority, is one of the key functions of a kernel. Based on this, processes are assigned a state such as running, sleeping, stopped, and so on, which keeps changing with the circumstances.</p>
<p>The following table lists Linux process states with their flags and descriptions:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 69px">
<p class="CDPAlignCenter CDPAlign"><strong>Name of process state</strong></p>
</td>
<td style="width: 45px">
<p class="CDPAlignCenter CDPAlign"><strong>Flag</strong></p>
</td>
<td style="width: 205px">
<p class="CDPAlignCenter CDPAlign"><strong>Kernel defined name</strong></p>
</td>
<td style="width: 380px">
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 69px">
<p>Running</p>
</td>
<td style="width: 45px">
<p><kbd>R</kbd></p>
</td>
<td style="width: 205px">
<p><kbd>TASK_RUNNING</kbd></p>
</td>
<td style="width: 380px">
<p>In this state, a process is either currently executing on a CPU or waiting to run in a queue. This state is also known as <strong>runnable</strong> when a process is ready to run and is waiting in a queue.</p>
</td>
</tr>
<tr>
<td style="width: 69px" rowspan="3">
<p>Sleeping</p>
</td>
<td style="width: 45px">
<p><kbd>S</kbd></p>
</td>
<td style="width: 205px">
<p><kbd>TASK_INTERRUPTIBLE</kbd></p>
</td>
<td style="width: 380px">
<p>In this state, a process is waiting for an event to complete. On receiving a signal, the process returns to the running state.</p>
</td>
</tr>
<tr>
<td style="width: 45px">
<p><kbd>D</kbd></p>
</td>
<td style="width: 205px">
<p><kbd>TASK_UNINTERRUPTIBLE</kbd></p>
</td>
<td style="width: 380px">
<p>In this state, a process will not respond to a signal. It is used only in specific conditions, usually associated with I/O, when interruptions are not desirable.</p>
</td>
</tr>
<tr>
<td style="width: 45px">
<p><kbd>K</kbd></p>
</td>
<td style="width: 205px">
<p><kbd>TASK_KILLABLE</kbd></p>
</td>
<td style="width: 380px">
<p>In this state, a process is in the sleeping state and will only respond to a kill signal to exit.</p>
</td>
</tr>
<tr>
<td style="width: 69px">
<p>Stopped</p>
</td>
<td style="width: 45px">
<p><kbd>T</kbd></p>
</td>
<td style="width: 205px"><kbd>TASK_STOPPED</kbd></td>
<td style="width: 380px">
<p>This state is reached when a process is stopped by a job control signal.</p>
</td>
</tr>
<tr>
<td style="width: 69px">
<p>Zombie</p>
</td>
<td style="width: 45px">
<p><kbd>Z</kbd></p>
</td>
<td style="width: 205px"><kbd>EXIT_ZOMBIE</kbd></td>
<td style="width: 380px">
<p>A zombie or defunct process state is one where a process has terminated but its entry is not removed from the process table by the respective parent.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Viewing current processes</h1>
                </header>
            
            <article>
                
<p>Each process running on a Linux system has various attributes, such as PID, PPID, the CPU time consumed by the process, the physical and virtual memory consumption of the process, and so on. All of this information can be found in the process table of the operating system. When working in a multi-user environment, it might happen that a process started by a user consumes the CPU cycle excessively. Hence, it is essential to manage processes and to manage computer resources efficiently. For this, we need to identify the types of processes and change their priority levels, or even terminate them if required. This section describes the use of various commands that are helpful for viewing processes and their attributes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Listing running processes</h1>
                </header>
            
            <article>
                
<p>The <strong>ps</strong> (short for <strong>process status</strong>) is used to list the current processes information that's available in the process table. It's similar to the <kbd>tasklist</kbd> command of Windows, which also used to list the running tasks of Windows in the command prompt.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The ps command</h1>
                </header>
            
            <article>
                
<p>The Linux version of the <kbd>ps</kbd> command supports three types of format, as follows:</p>
<ul>
<li><strong>Unix (POSIX) standard</strong>: In this format, options may be grouped and prefixed with a hyphen</li>
<li><strong>BSD standard</strong>: In this format, various options can be grouped, but they are not prefixed with a hyphen symbol</li>
<li><strong>GNU standard</strong>: In this format, long options are used, which are prefixed with two hyphen symbols</li>
</ul>
<p>Various uses for the <kbd>ps</kbd> command, are described in the following subsections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying processes running from the current shell</h1>
                </header>
            
            <article>
                
<p>Use the <kbd>ps</kbd> command, as shown in the following screenshot to list the process running from the current shell:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f43c215a-365a-4cd8-9a58-864c5ff1d60b.png" style="width:14.67em;height:4.83em;" width="331" height="110"/></p>
<p>The output shows rows of data with the following columns:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Command</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong> Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>PID</kbd></p>
</td>
<td>
<p>The process ID of the running process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TTY</kbd></p>
</td>
<td>
<p>The Terminal type from which the process is running</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TIME</kbd></p>
</td>
<td>
<p>The cumulative CPU time consumed by the process and the child processes started by the process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>CMD</kbd></p>
</td>
<td>
<p>The command that runs as the current process</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying all processes by their user</h1>
                </header>
            
            <article>
                
<p>The <kbd>ps</kbd> command can be used with the <kbd>-u</kbd> option to filter processes by user, as shown in the following command line:</p>
<pre><strong>$ ps -u student</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying all processes in different formats</h1>
                </header>
            
            <article>
                
<p>The <kbd>ps</kbd> command can be used display all running processes on a system in different formats, as follows:</p>
<p>Display all the processes running in the system in Unix format.</p>
<p>The <kbd>ps</kbd> command can be used to display all running processes in a simple Unix format with either the <kbd>-A</kbd> option or the <kbd>-e</kbd> option, as shown in the following command line:</p>
<pre><strong>$ ps -A</strong><br/>or<br/><strong>$ ps -e</strong></pre>
<p>The <kbd>ps</kbd> command can be used to display a detailed listing of all the running processes by using the <kbd>-e</kbd> option to show all the processes and the <kbd>-f</kbd> option to show full details of each process in Unix format, as shown in the following command line:</p>
<pre><strong>$ ps -ef</strong></pre>
<p>The output on execution of preceding command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d227967a-e12a-4c2f-b813-8d7a2ed119fd.png" width="1457" height="289"/></p>
<p>In the preceding example, we have limited the output of the <kbd>ps</kbd> command to display only the top five lines using the head command. In subsequent examples, we have used the same technique to limit the output of <kbd>ps</kbd> command for demonstration purposes.</p>
<p>The output shows rows of data with the following columns:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>UID</kbd></p>
</td>
<td>
<p>User ID of the person who ran the command</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PID</kbd></p>
</td>
<td>
<p>Process ID of the command</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PPID</kbd></p>
</td>
<td>
<p>Parent process that started the command</p>
</td>
</tr>
<tr>
<td>
<p><kbd>C</kbd></p>
</td>
<td>
<p>Number of children a process has</p>
</td>
</tr>
<tr>
<td>
<p><kbd>STIME</kbd></p>
</td>
<td>
<p>Start time for the process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TTY</kbd></p>
</td>
<td>
<p>Terminal associated with the process; you will see a question mark <kbd>?</kbd> if a process is not attached to a Terminal</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TIME</kbd></p>
</td>
<td>
<p>Cumulative CPU time consumed by the process and the child processes started by the process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>CMD</kbd></p>
</td>
<td>
<p>The command that was run to start the process</p>
</td>
</tr>
<tr>
<td colspan="2">
<p>Using the <kbd>-F</kbd> option with <kbd>-e</kbd> (<kbd>$ ps -eF</kbd> ) will list further columns:</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PSR</kbd></p>
</td>
<td>
<p>Processor number to which the process is assigned</p>
</td>
</tr>
<tr>
<td>
<p><kbd>SZ</kbd></p>
</td>
<td>
<p>Total amount of memory size in physical pages for the given process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>RSS</kbd></p>
</td>
<td>
<p>Resident set size is the actual physical memory size consumed by a process</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Display all the processes running in system using BSD syntax.</p>
<p>The <kbd>ps</kbd> command can be used with the aux option to display all running processes in BSD syntax, as shown in the following command line. Here, option a lists all of the processes attached to Terminals, option u lists the users of processes, and option <kbd>x</kbd> lists all processes that are not associated with a Terminal:</p>
<pre><strong>$ ps aux</strong></pre>
<p>The output on execution of the preceding command is shown in the following screenshot: </p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6d1532ae-6d36-4f53-b48d-8d84b47d9a78.png" width="1466" height="151"/></p>
<p>The output shows rows of data with the following columns:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>USER</kbd></p>
</td>
<td>
<p>The name of the user associated with the process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PID</kbd></p>
</td>
<td>
<p>The unique numeric process ID assigned to the process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%CPU</kbd></p>
</td>
<td>
<p>Percentage of the CPU used by a process (the length of time the process has been running for, divided by the total CPU time used by the process)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%MEM</kbd></p>
</td>
<td>
<p>Percentage of the RAM memory used by the process (memory used divided by the total memory available)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>VSZ</kbd></p>
</td>
<td>
<p>Virtual memory size expressed in KiB</p>
</td>
</tr>
<tr>
<td>
<p><kbd>RSS</kbd></p>
</td>
<td>
<p>Resident set size is the actual physical memory size consumed by the process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TTY</kbd></p>
</td>
<td>
<p>The Terminal controlling the process; you will see <kbd>?</kbd> if the process is not attached to a Terminal</p>
</td>
</tr>
<tr>
<td>
<p><kbd>STAT</kbd></p>
</td>
<td>
<p>Displays the following process states: </p>
<p><kbd>R</kbd>: Running</p>
<p><kbd>S</kbd>: Sleep interruptible</p>
<p><kbd>D</kbd>: Sleep uninterruptible</p>
<p><kbd>T</kbd>: Stopped</p>
<p><kbd>Z</kbd>: Zombie</p>
<p><kbd>&lt;</kbd>: High priority</p>
<p><kbd>N</kbd>: Low priority</p>
<p><kbd>L</kbd>: Has pages locked into memory</p>
<p><kbd>s</kbd>: Session leader</p>
<p><kbd>l</kbd>: Multithreaded</p>
<p><kbd>+</kbd>: Foreground process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>START</kbd></p>
</td>
<td>
<p>Date or time when the process was started</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TIME</kbd></p>
</td>
<td>
<p>Cumulative CPU time consumed by the process and the child processes started by the process</p>
</td>
</tr>
<tr>
<td>
<p><kbd>CMD</kbd></p>
</td>
<td>
<p>Command used to start the process</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sorting processes based on different parameters</h1>
                </header>
            
            <article>
                
<p>In this section, we will cover different examples to show you how the sorting of processes can be done with the <kbd>ps</kbd> command based on different parameters. The output of each example is shown in the subsequent screenshots.</p>
<ul>
<li>Sort processes in ascending order by the highest CPU utilization:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/adfa6205-dc85-49c3-95e4-057125b6dd1c.png" style="width:45.25em;height:4.75em;" width="1460" height="154"/></p>
<ul>
<li>Sort processes in ascending order by the highest memory utilization:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b7e334a7-6bbd-4663-8570-50e2f7e960b9.png" style="width:45.92em;height:5.00em;" width="1605" height="176"/></p>
<ul>
<li>Combine both the CPU and memory utilization for sorting by a single command:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0f3f70cf-e7c7-4fef-88a6-e7f935e8068a.png" style="width:43.83em;height:7.00em;" width="956" height="153"/></p>
<p>If a zombie process entry is available in the process table, it will appear as exiting or defunct.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying processes by user</h1>
                </header>
            
            <article>
                
<p>To filter processes by user, the <kbd>-u</kbd> option is followed by the username. Multiple usernames can be provided, separated by a comma. In the following example, the <kbd>ps</kbd> command is used to list the processes started by user Apache only, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/60c34509-b0b3-45ea-8e99-59ccac66a75c.png" style="width:35.67em;height:7.75em;" width="804" height="174"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying process information by name</h1>
                </header>
            
            <article>
                
<p>To list process information by process name, use the <kbd>-C</kbd> option, followed by the exact process name, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a135fd94-43df-4eda-9f57-064b942750b5.png" style="width:16.58em;height:9.50em;" width="342" height="197"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying process details by PID</h1>
                </header>
            
            <article>
                
<p>To display process information using PID, use the <kbd>-p</kbd> option, followed by the PID of processes, separated by a comma, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3da3f660-3c0c-47ff-b05e-ca9407c6770a.png" style="width:35.50em;height:5.83em;" width="800" height="132"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying a process hierarchy in a tree style</h1>
                </header>
            
            <article>
                
<p>To display the parent-child relationship between processes, the <kbd>--forest</kbd> option is used, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ea5ac33d-c828-4fd5-8a7a-6434ab6c84cc.png" style="width:37.92em;height:9.50em;" width="805" height="201"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying the child processes of a parent</h1>
                </header>
            
            <article>
                
<p>To display the child processes of a parent using the PID of the main process, we can use the <kbd>--ppid</kbd> option. The main parent process is owned by the root, and child processes are forked and owned by the parent. The example of the <kbd>ps</kbd> command to display the child of a specified parent <kbd>PID</kbd> is shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/57a00456-d200-4547-a44e-48d8aebfa462.png" style="width:15.75em;height:7.67em;" width="361" height="176"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying the thread of a process</h1>
                </header>
            
            <article>
                
<p>To display the thread of a process, the <kbd>-L</kbd> option is used with the <kbd>ps</kbd> command, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5f0262ea-1f87-45b7-9382-beab79e39e96.png" style="width:66.75em;height:12.58em;" width="1398" height="264"/></p>
<p>The output shows rows of data with several columns, all of which have been covered in previous examples, except the <kbd>LWP</kbd> column, which represents the TID, and <strong>NLWP</strong> (short for <strong>Number of Lightweight Processes</strong>), which represents the number of threads in a process here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying the pid of a process if the process name is known</h1>
                </header>
            
            <article>
                
<p>To print only the PIDs of processes whose names are known, we use the <kbd>-C</kbd> option, followed by the exact process name and the <kbd>-o</kbd> option, followed by <kbd>pid=</kbd>, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a802249d-0c48-4504-9efd-1dd27ed0d9da.png" style="width:19.67em;height:8.08em;" width="424" height="174"/></p>
<p>You can look up the meaning of all the labels and the various process state descriptions in the Unix standard and BSD standard from the man page of the <kbd>ps</kbd> command.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the pstree command</h1>
                </header>
            
            <article>
                
<p>This command is used to display the parent-child relationship in hierarchical format. The output of this command is quite similar to the output of the <kbd>ps axjf</kbd> command and the <kbd>ps -ef --forest</kbd> command, as shown in the following command line:</p>
<pre><strong>$ pstree</strong></pre>
<p>The following <span>screenshot </span>displays the tree hierarchy of a single process with PID using the <kbd>pstree</kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f01d7b8e-9c74-472b-bb08-12367fc49564.png" style="width:17.75em;height:7.58em;" width="365" height="156"/></p>
<p>Display the tree hierarchy of a user's processes by executing the command line given:</p>
<pre><strong>$ pstree -p student</strong></pre>
<p>On execution of the preceding command, the PIDs assigned to each process are shown in parentheses after each process name.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding the PID of a running process</h1>
                </header>
            
            <article>
                
<p>Very often, we need to identify a PID to manage it, for example, if you need to stop the execution of a process. Sometimes, you may need to change the priority level of a process. Hence, to communicate with a process, the most commonly used method is using its PID. This section covers multiple commands that are used to find the PID of a running process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the pgrep command</h1>
                </header>
            
            <article>
                
<p>The <kbd>pgrep</kbd> command is used to look up currently running processes based on their name and other attributes, and displays the matching process PID. Its syntax is as follows:</p>
<pre><strong>$ pgrep    [options]    pattern</strong></pre>
<p>The following are examples to explain the use of the <kbd>pgrep</kbd> command:</p>
<p>To list processes with the <kbd>sshd</kbd> command name, which is also owned by root, execute the command line as follows:</p>
<pre><strong>$ pgrep -u root sshd</strong></pre>
<p>To list processes owned by the user <kbd>root</kbd> or <kbd>daemon</kbd>, execute the command line as follows:</p>
<pre class="mce-root"><strong>$ pgrep -u root,daemon</strong></pre>
<p>The <kbd>pgrep</kbd> command can be used to list processes by specifying a pattern containing the process name. The following command line will find the PID of process that has the name of Firefox:</p>
<pre><strong>$ pgrep firef</strong></pre>
<p>The following example shows the usage of the <kbd>pgrep</kbd> command to list all the processes of the user student:</p>
<pre><strong>$ pgrep -U student</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">pidof</h1>
                </header>
            
            <article>
                
<p>The <kbd>pidof</kbd> command can be used to find the process ID of a running program, if the argument provided to the <kbd>pidof</kbd> command is the exact process name, as shown in the following command line:</p>
<pre><strong>$ pidof bash</strong><br/><strong>$ pidof firefox</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The ps command with grep</h1>
                </header>
            
            <article>
                
<p>Practically, it is difficult to remember the exact name of processes running on a Linux system. In scenarios where you do not remember the exact name of a process, the <kbd>pidof</kbd> command will not return the PID in the output. In such cases, the <kbd>ps</kbd> command output can be given as input to the grep filter to find the desired process name, as shown in the following command line:</p>
<pre><strong>$ ps aux | grep &lt;process_name&gt;</strong><br/><strong>$ ps aux | grep sshd</strong></pre>
<p>The second column of output contains the PID of the filtered process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating with processes using signals</h1>
                </header>
            
            <article>
                
<p>Processes communicate with each other using signals. We can also communicate with processes using <kbd>kill</kbd>, <kbd>pkill</kbd>, or the <kbd>killall</kbd> command to pass different signals.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining a signal and its types</h1>
                </header>
            
            <article>
                
<p>A signal is a kind of software interrupt to a process. A signal can also be considered as a notification that needs to be processed for a specific event. <kbd>Kill</kbd>, <kbd>pkill</kbd>, and <kbd>killall</kbd> are programs that are used to deliver these signals to processes. On Linux, every signal name begins with the characters SIG. The signal numbers described in the following table may vary on different Linux hardware platforms, however, in any case, the signal name and meaning will remain the same.</p>
<p>The following table lists the popular signals used for process management, along with their descriptions:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Signal</strong></p>
<p class="CDPAlignCenter CDPAlign"><strong>no.</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Signal</strong></p>
<p class="CDPAlignCenter CDPAlign"><strong>name</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Meaning</strong></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>1</kbd></p>
</td>
<td>
<p><kbd>SIGHUP</kbd></p>
</td>
<td>
<p>Hangup</p>
</td>
<td>
<p>Given when controlling Terminal hangup (closed when user is away).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>2</kbd></p>
</td>
<td>
<p><kbd>SIGINT</kbd></p>
</td>
<td>
<p>Keyboard interrupt</p>
</td>
<td>
<p>Used to terminate a program using the keyboard key combination <em>Ctrl </em>+ <em>C</em>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>3</kbd></p>
</td>
<td>
<p><kbd>SIGQUIT</kbd></p>
</td>
<td>
<p>Keyboard quit</p>
</td>
<td>
<p>Used to terminate a program using the keyboard key combination <em>Ctrl</em> + <em>D</em>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>9</kbd></p>
</td>
<td>
<p><kbd>SIGKILL</kbd></p>
</td>
<td>
<p>Terminate</p>
<p>forcefully</p>
</td>
<td>
<p>Causes the forceful, abrupt termination of a program by the user. Cannot be blocked, ignored, or handled.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>15</kbd></p>
<p>(default)</p>
</td>
<td>
<p><kbd>SIGTERM</kbd></p>
</td>
<td>
<p>Terminate</p>
<p>gracefully</p>
</td>
<td>
<p>Terminates the program gracefully. This signal can be blocked, ignored, or handled. It is the default signal sent by the <kbd>kill</kbd> command.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>18</kbd></p>
</td>
<td>
<p><kbd>SIGCONT</kbd></p>
</td>
<td>
<p>Continue</p>
</td>
<td>
<p>Tells a stopped process to resume.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>19</kbd></p>
</td>
<td>
<p><kbd>SIGSTOP</kbd></p>
</td>
<td>
<p>Stop</p>
</td>
<td>
<p>Suspends a process. This signal can't be blocked or handled.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>20</kbd></p>
</td>
<td>
<p><kbd>SIGTSTP</kbd></p>
</td>
<td>
<p>Keyboard</p>
<p>Stop</p>
</td>
<td>
<p>Used to suspend a process using the keyboard key combination <em>Ctrl</em> + <em>Z</em>. This signal can be blocked, ignored, or handled.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>kill</kbd> command is used to list all of the signals supported by your Linux, system as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c82560f5-ba87-4f7b-9bb1-ae06fcf81c7f.png" style="width:41.08em;height:15.17em;" width="890" height="329"/></p>
<p>Each signal has a default action associated with it, such as the termination of a process, stopping a process, continuing a stopped process, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending signals to processes</h1>
                </header>
            
            <article>
                
<p>There are multiple methods for sending signals to a process. One of the most common is using a keyboard interrupt such as <em>Ctrl</em> + <em>C</em>, <em>Ctrl</em> + <em>D</em>, and so on. Another method is using the <kbd>kill</kbd>, <kbd>killall</kbd>, and <kbd>pkill</kbd> commands.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending signals to processes by PID using the kill command</h1>
                </header>
            
            <article>
                
<p>The <kbd>kill</kbd> command sends a signal to a process by PID. Contrary to its name, the <kbd>kill</kbd> command can be used to send any signal to processes. The default signal sent by the <kbd>kill</kbd> command is <kbd>SIGTERM</kbd>, for example, signal number <kbd>15</kbd>. The syntax of the kill command is as follows:</p>
<pre><strong>$ kill   -&lt;signal_name_or_signal_number&gt;    PID_OF_PROCESS</strong></pre>
<p>The following are examples to explain the usage of <kbd>kill</kbd> command:</p>
<ul>
<li>For sending a default signal to a process to terminate it gracefully, use the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ kill PID</strong></pre>
<ul>
<li>To terminate a process using the signal name, use the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ kill -SIGTERM PID</strong></pre>
<ul>
<li>To terminate a process using the signal number, use the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ kill -15 PID</strong></pre>
<ul>
<li>To terminate a process forcefully, use either of the following commands:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ kill -SIGKILL PID</strong><br/>or<br/><strong>$ kill -9 PID</strong></pre>
<p>This is similar to the operation that we perform using the Task Manager in Windows when we right-click on the process name in the Task Manager and pass the end process command:</p>
<ul>
<li>The <kbd>kill</kbd> command can be used to suspend/stop a process and send it to the background if it is running in the foreground. This can be done by using either of the following commands:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ kill -SIGTSTP  PID</strong><br/>or<br/><strong>$ kill -20 PID</strong></pre>
<ul>
<li>To resume a process if it has been stopped, use either of the following commands:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ kill -SIGCONT PID</strong><br/>or<br/><strong>$ kill -18 PID</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending signals to multiple processes by name</h1>
                </header>
            
            <article>
                
<p>We can also send signals to a process or multiple processes using by their name with the help of the <kbd>killall</kbd> command and the <kbd>pkill</kbd> command, as discussed in the following subsections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">killall</h1>
                </header>
            
            <article>
                
<p>The <kbd>killall</kbd> command is used to send a signal to one or more processes on matching one of the following conditions:</p>
<ul>
<li><strong>Command</strong>: Match exact process name</li>
<li><strong>Owner</strong>: Match exact name of the owner of the process</li>
<li><strong>All system</strong>: System-wide processes</li>
</ul>
<p>Its syntax is as follows:</p>
<pre class="CDPAlignLeft CDPAlign"><strong> $ killall    &lt;process_name&gt;</strong><br/><strong> $ killall   -&lt;signal&gt;    &lt;process_name&gt;</strong><br/><strong> $ killall   -&lt;signal&gt;   -u    &lt;username&gt;    &lt;process_name&gt;</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">pkill</h1>
                </header>
            
            <article>
                
<p>The <kbd>pkill</kbd> command is also used to send a signal to multiple processes on matching a combination of the criteria, which is explained in following examples:</p>
<ul>
<li>Using <kbd>pkill</kbd> with the command pattern: The <kbd>pkill</kbd> command can be used to send a signal to the matching processes name, as shown here:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ pkill   &lt;command_name_pattern&gt;</strong><br/><strong> $ pkill   -&lt;signal_name_or_signal_number&gt;   &lt;command_name_pattern&gt;</strong></pre>
<p>The example of sending a signal to multiple sleep processes using a single <kbd>pkill</kbd> command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a835084d-be8b-41e6-89ed-6a4108a9ae40.png" style="width:22.67em;height:8.75em;" width="463" height="178"/></p>
<ul>
<li>Using the <kbd>pkill</kbd> command with UID: The <kbd>pkill</kbd> command can be used to send a signal to processes owned by the specified Linux user account by specifying its UID, as shown in the following syntax:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ pkill    -u     &lt;username_or_uid&gt;     &lt;command_pattern&gt;</strong></pre>
<ul>
<li>Using the <kbd>pkill</kbd> command with GID: The <kbd>pkill</kbd> command can be used to send a signal to processes owned by the specified Linux group account by specifying its GID, as shown in the following syntax:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ pkill    -g     &lt;groupname_or_gid&gt;    &lt;command_pattern&gt;</strong></pre>
<ul>
<li>Using the <kbd>pkill</kbd> command with Parent PID: The <kbd>pkill</kbd> command can be used to send a signal to all of the child processes of the specified parent process, as shown in the following syntax:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ pkill    -P   PPID    &lt;command_pattern&gt;</strong></pre>
<ul>
<li>Using the <kbd>pkill</kbd> command with Terminal name: The <kbd>pkill</kbd> command can be used to send a signal to processes running from a specific controlling Terminal, as shown in the following syntax:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ pkill   -t   &lt;terminal_name&gt;   -U   UID   &lt;command_pattern&gt;</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monitoring processes and load averages</h1>
                </header>
            
            <article>
                
<p>The load average is the average of the load for a given period of time on each CPU. It takes into account the following:</p>
<ul>
<li>
<p>Actively running processes (including each thread as an individual, separate task) on a CPU core.</p>
</li>
<li>
<p>Runnable processes, waiting for a CPU to become available.</p>
</li>
<li>
<p>Sleeping processes, for example, waiting for some kind of resource (generally disk I/O or network I/O) to become available.</p>
</li>
<li>
<p>Linux counts each physical CPU core and microprocessor hyper-thread as separate execution units, and refers to them as individual CPUs. Each CPU has an independent request queue. We can count the total number of system CPUs using by the following command:</p>
<pre><strong>$ grep "model name" /proc/cpuinfo | wc -l</strong></pre></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding load averages on Linux</h1>
                </header>
            
            <article>
                
<p>The load average of processes are viewed using the <kbd>w</kbd>, <kbd>uptime</kbd>, or <kbd>top</kbd> command, or with gnome-system-monitor in GUI mode. These commands display the load averages by using a combined representation of all CPUs for the last 1, 5, and 15 minutes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">uptime</h1>
                </header>
            
            <article>
                
<p>The <kbd>uptime</kbd> command tells you how long your system has been up and running. However, at the same time, it provides other useful information, such as the number of users currently logged in and the system load average for the past 1, 5, and 15 minutes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6c93dc49-3a08-4ef5-8736-c293f8de198f.png" width="999" height="242"/></p>
<p>When we have more than one CPU, the load average will be divided by the number of CPUs as explained in the preceding screenshot. The increase in load for a short duration is not a problem, however, a continuous spike in the last 5 or 15 minute load averages may be a cause for concern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">w</h1>
                </header>
            
            <article>
                
<p>The <kbd>w</kbd> command is used to display information about the users that are currently logged onto the machine and their running processes. The first line (header) in the output is the same as what we saw in the <kbd>uptime</kbd> output. An example of the <kbd>w</kbd> command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fb21f45c-80fc-476b-a1e9-b8bfc56a47f8.png" style="width:35.42em;height:5.08em;" width="762" height="110"/></p>
<p>The output shows rows of data with the following columns:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Command</strong> </p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span>USER</span></kbd></p>
</td>
<td>
<p><span>User login name</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd>TTY</kbd></p>
</td>
<td>
<p>The controlling Terminal type, listed as pts/N (pseudo-terminal) in GUI, or ttyN on the system console or other directly connected device</p>
</td>
</tr>
<tr>
<td>
<p><kbd>FROM</kbd></p>
</td>
<td>
<p>Remote hostname from which the user has logged in</p>
</td>
</tr>
<tr>
<td>
<p><kbd>LOGIN@</kbd></p>
</td>
<td>
<p>Login time of the user</p>
</td>
</tr>
<tr>
<td>
<p><kbd>IDLE</kbd></p>
</td>
<td>
<p>How long it has been since the user typed any input on that Terminal</p>
</td>
</tr>
<tr>
<td>
<p><kbd>JCPU</kbd></p>
</td>
<td>
<p>CPU time consumption of all the processes attached to tty, including jobs currently running in the background </p>
</td>
</tr>
<tr>
<td>
<p><kbd>PCPU</kbd></p>
</td>
<td>
<p>CPU time consumption of the current processes named in the <kbd>WHAT</kbd> field</p>
</td>
</tr>
<tr>
<td>
<p><kbd>WHAT</kbd></p>
</td>
<td>
<p>The command line of the process currently executing </p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Real-time interactive process monitoring</h1>
                </header>
            
            <article>
                
<p>The <kbd>ps</kbd> command gives static snapshots of processes running on a system. Sometimes, real-time monitoring of a system is also required. The <kbd>top</kbd> command is used to perform real-time monitoring of a system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">top</h1>
                </header>
            
            <article>
                
<p>The <kbd>top</kbd> program provides a continuously updated real-time view of the processes running on a system after every 2 seconds, until its execution is stopped by pressing <em>q</em>. It displays multiple pieces of information, including system uptime, a list of the running tasks, the CPU status, and a memory status summary, followed by the different resources consumed by each process. The <kbd>top</kbd> command is executed as follows:</p>
<pre><strong>$ top</strong></pre>
<p>The output on execution of the preceding command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/708956ef-e200-4b2e-ba7d-b01d3e7f5042.png" style="width:54.58em;height:23.42em;" width="920" height="395"/></p>
<p>The output shows a system information summary, followed by each different processes' information in rows, with the descending order of CPU usage in the following columns:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td colspan="2">
<p class="CDPAlignCenter CDPAlign"><strong>System Information Summary</strong></p>
</td>
</tr>
<tr>
<td colspan="2">
<p>1) The first line displays how long the system has been up, how many users are logged on, and what the load average is.</p>
</td>
</tr>
<tr>
<td colspan="2">
<p>2) The second line displays the total number of processes followed by the number of running, sleeping, stopped, and zombie processes.</p>
</td>
</tr>
<tr>
<td colspan="2">
<p>3) The third line displays the various CPU usage parameters:</p>
</td>
</tr>
<tr>
<td>
<p><kbd>us</kbd></p>
</td>
<td>
<p>Percentage of CPU time used running un-niced user processes</p>
</td>
</tr>
<tr>
<td>
<p><kbd>sy</kbd></p>
</td>
<td>
<p>Percentage of CPU time used running kernel processes</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ni</kbd></p>
</td>
<td>
<p>Percentage of CPU time used running user-niced processes</p>
</td>
</tr>
<tr>
<td>
<p><kbd>id</kbd></p>
</td>
<td>
<p>Percentage of CPU time spent when the kernel handler was idle</p>
</td>
</tr>
<tr>
<td>
<p><kbd>wa</kbd></p>
</td>
<td>
<p>Percentage of CPU time spent waiting for I/O completion</p>
</td>
</tr>
<tr>
<td>
<p><kbd>hi</kbd></p>
</td>
<td>
<p>Percentage of CPU time spent serving hardware interrupts</p>
</td>
</tr>
<tr>
<td>
<p><kbd>si</kbd></p>
</td>
<td>
<p>Percentage of CPU time spent serving software interrupts</p>
</td>
</tr>
<tr>
<td>
<p><kbd>st</kbd></p>
</td>
<td>
<p>Steal time is the percentage of a CPU's idle time used by the virtual machine's hypervisor</p>
</td>
</tr>
<tr>
<td colspan="2">
<p>4) The fourth and fifth lines display memory usage. Line number four displays physical memory and line number five displays virtual memory.</p>
</td>
</tr>
<tr>
<td colspan="2">
<p>5) The sixth line contains the heading for the process information list in descending order of CPU usage. It has the following fields:</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PID</kbd></p>
</td>
<td>
<p>Process ID number.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>USER</kbd></p>
</td>
<td>
<p>Username of the owner of the process.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PR</kbd></p>
</td>
<td>
<p>System priority of the process.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>NI</kbd></p>
</td>
<td>
<p>User priority value for a process, also known as the nice value.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>VIRT</kbd></p>
</td>
<td>
<p>Total memory a process is using. Virtual memory is a combination of resident set, shared memory, and swapped memory.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>RES</kbd></p>
</td>
<td>
<p>Physical memory used by a process.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>SHR</kbd></p>
</td>
<td>
<p>Shared memory used by a process.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>S</kbd></p>
</td>
<td>
<p>Process status codes are displayed here (D,R, S, T, and Z).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%CPU</kbd></p>
</td>
<td>
<p>Percentage of CPU used since the process started.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%MEM</kbd></p>
</td>
<td>
<p>Percentage of memory used by a process.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TIME+</kbd></p>
</td>
<td>
<p>Execution time.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>COMMAND</kbd></p>
</td>
<td>
<p>Command name used to start the process.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>top</kbd> command is like command line Task Manager in Linux. Using top, we can perform interactive monitoring and manage running processes. There are quite a few single-key shortcuts to manage the different attributes of a running process.</p>
<p>The following table lists various keyboard shortcuts that are used to manage the <kbd>top</kbd> command, as well as their descriptions:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"/>
<p class="CDPAlignCenter CDPAlign"/>
<p class="CDPAlignCenter CDPAlign"/>
<p class="CDPAlignCenter CDPAlign"><strong>Keyboard shortcut</strong></p>
<p class="CDPAlignCenter CDPAlign">(on top)</p>
<p class="CDPAlignCenter CDPAlign"/>
<p class="CDPAlignCenter CDPAlign"/>
<p class="CDPAlignCenter CDPAlign"/>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><em>t</em></p>
</td>
<td>
<p>Toggle display of summary information</p>
</td>
</tr>
<tr>
<td>
<p><em>m</em></p>
</td>
<td>
<p>Toggle display of memory information</p>
</td>
</tr>
<tr>
<td>
<p><em>l</em></p>
</td>
<td>
<p>Toggle display of uptime information</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>Toggle display of all CPUs' summary or individual CPU's summary</p>
</td>
</tr>
<tr>
<td>
<p><em>H</em></p>
</td>
<td>
<p>Toggle threads display in summary information of tasks</p>
</td>
</tr>
<tr>
<td>
<p><em>s</em></p>
</td>
<td>
<p>Change the refresh rate of the screen in seconds</p>
</td>
</tr>
<tr>
<td>
<p><em>A</em></p>
</td>
<td>
<p>Sort the process list by the top resource consumers</p>
</td>
</tr>
<tr>
<td>
<p><em>r</em></p>
</td>
<td>
<p>Renice (change the priority) a selected process, by providing PID and then the nice value</p>
</td>
</tr>
<tr>
<td>
<p><em>k</em></p>
</td>
<td>
<p>Send a signal to a specific process (the default signal is to terminate), by providing PID and then a signal number</p>
</td>
</tr>
<tr>
<td>
<p>f</p>
</td>
<td>
<p>Open the configuration screen of the top command</p>
</td>
</tr>
<tr>
<td>
<p>M</p>
</td>
<td>
<p>Sort processes by memory usage, in descending order</p>
</td>
</tr>
<tr>
<td>
<p>P</p>
</td>
<td>
<p>Sort processes by CPU utilization in descending order</p>
</td>
</tr>
<tr>
<td>
<p>? or h</p>
</td>
<td>
<p>Display help for interactive keystrokes</p>
</td>
</tr>
<tr>
<td>
<p>U</p>
</td>
<td>
<p>Filter display for usernames</p>
</td>
</tr>
<tr>
<td>
<p><em>q</em></p>
</td>
<td>
<p>Quit</p>
</td>
</tr>
<tr>
<td>
<p><em>Enter</em>, Space key</p>
</td>
<td>
<p>Immediately refreshes the displayed information</p>
</td>
</tr>
</tbody>
</table>
<p>The following are examples to explain the usage of the <kbd>top</kbd> command:</p>
<ul>
<li>Display the process status of only the specified <kbd>pid</kbd> with the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ top -p pid</strong></pre>
<ul>
<li>Specify a delay between consecutive screen refreshes while running <kbd>top</kbd> commands with the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ top -d 2</strong></pre>
<ul>
<li>Display the <kbd>top</kbd> command's output for specified iterations only by using the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ top n &lt;number&gt;</strong></pre>
<div class="packt_tip">You can read more about sophisticated utilities, such as <kbd>htop</kbd> for process monitoring, which gives you the ability to scroll down vertically and horizontally to view more processes.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing a processes' priority with nice and renice</h1>
                </header>
            
            <article>
                
<p>Linux is a multi-program system. At any given point of time, several processes are running or waiting in a queue on the system, however, a single CPU can actually execute one task at a time. If we have more long process queue, then it might happen that some more important processes spend more time waiting than executing. So, to overcome this problem, Linux allows us to set and modify a processes' priority. Lower-priority processes get less CPU time and higher-priority processes get more CPU time. Using the <kbd>nice</kbd> and <kbd>renice</kbd> command, we can manage the priority of processes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding priority</h1>
                </header>
            
            <article>
                
<p>The priority of a process is known as its <strong>nice</strong> value (or <strong>niceness</strong>). It tells you how much nice (number of CPU cycles used) a process is on CPU. Its value varies from <kbd>-20</kbd> to <kbd>19</kbd>. A lower nice value represents a higherpriority process, which will take more CPU cycles, while a higher nice value represents a lowpriority process that can wait longer and consumes less CPU cycles. So, a nice value of <kbd>-20</kbd> represents the highest priority and a nice value of <kbd>19</kbd> represents the lowest priority. The default value for new processes is generally <kbd>0</kbd>, which is inherited from their parent.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modifying priority</h1>
                </header>
            
            <article>
                
<p>Assigning a low nice value, that is, a higher priority, to a CPU-hungry process will impact the performance of other processes running on the same Linux system. Hence, only root is allowed to give a higher priority to a process, for example, setting negative nice values on running processes.</p>
<p>Normal users can only lower the priority of their processes, that is, they can set only a higher positive value than the existing nice value for a given process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Viewing the priority of a process</h1>
                </header>
            
            <article>
                
<p>The priority of a process can be viewed using different commands in CentOS 7, as follows:</p>
<ul>
<li>Using gnome-system-monitor to display the nice level in GUI mode. This is the GUI Task Manager in CentOS 7. It is invoked by pressing <span class="packt_screen">Application</span> | <span class="packt_screen">System Tools</span> | <span class="packt_screen">System Monitor</span>:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5d89d342-8fbe-4f25-93b8-5596d58ee63e.png" style="width:50.17em;height:37.58em;" width="1022" height="766"/></p>
<ul>
<li>The <kbd>top</kbd> command can also be used to display the priority of processes. It shows two columns, named <kbd>NI</kbd> (displaying the <kbd>nice</kbd> level mapping of processes) and <kbd>PR</kbd> (displaying the priority value mapping in a kernel to a larger priority queue).</li>
<li> The <kbd>ps</kbd> command can also be used to display the <kbd>nice</kbd> level by using <kbd>o</kbd> <span>option </span>to print selected columns, which will also include the nice field, as shown in the following screenshot:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b4d2b30c-de0b-401a-9ed4-7b4822795bf4.png" style="width:29.83em;height:12.17em;" width="652" height="266"/></p>
<div class="packt_infobox">If a minus (<kbd>-</kbd>) symbol is displayed in the output of the <kbd>ps</kbd> command, then it means that a process is running with a different scheduling policy with a higher priority.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modifying the priority of a new process (nice value)</h1>
                </header>
            
            <article>
                
<p>Normally, when a process is started, it gets the default priority value of <kbd>0</kbd>. The <kbd>nice</kbd> command is used to start a process with a different priority. Its syntax is as follows:</p>
<pre><strong>$ nice   -n   &lt;NICELEVEL&gt;   &lt;command&gt;</strong></pre>
<p>An example of changing priority of a process using the <kbd>nice</kbd> command is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/52310257-f130-485f-8fec-686fbedf5a2c.png" style="width:27.08em;height:7.42em;" width="565" height="155"/></p>
<p>Root can set a nice value between (<kbd>-20</kbd> to <kbd>19</kbd>), and an unprivileged, normal user can set a nice value between (<kbd>0</kbd> to <kbd>19</kbd>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modifying the priority of a running process (renice)</h1>
                </header>
            
            <article>
                
<p>The <kbd>renice</kbd> command is used to change the nice level of an existing process. Its syntax is as follows:</p>
<pre><strong>$ renice    -n    &lt;NICELEVEL&gt;   &lt;PID’s&gt;</strong></pre>
<p>In the following screenshot, a standard user is trying to increase the priority of a process by assigning a negative value, hence they are getting Permission denied, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/840d7a82-36cd-4252-8ae9-b73aa99ccabc.png" style="width:36.17em;height:5.00em;" width="804" height="111"/></p>
<p>Now, when a standard user lowers the priority of a process by assigning a positive value, it is set immediately, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c47e5a49-5860-4d2d-8a66-f48823269047.png" style="width:23.42em;height:8.33em;" width="553" height="196"/></p>
<p>Apart from the <kbd>renice</kbd> command, the <kbd>top</kbd> command can also be used to modify the nice value of a running process. The following steps are used to modify a process priority using the <kbd>top</kbd> command:</p>
<ol>
<li>Invoke the <kbd>top</kbd> command</li>
<li>Press <em>r</em> key on the keyboard to bring up the option for specifying a new nice value on the <kbd>top</kbd> command's current interactive session</li>
<li>Enter the new <kbd>nice</kbd> value and PID, followed by pressing the <em>Enter</em> key</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling jobs on the command line</h1>
                </header>
            
            <article>
                
<p>Linux supports executing programs in the foreground as well as in the background. This feature allows you to run multiple programs from a single instance of a shell. This feature is known as job control or job management.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding different terms related to job management</h1>
                </header>
            
            <article>
                
<p>This section describes various terms related to job management on a Terminal.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Jobs management with its associated controlling Terminal</h1>
                </header>
            
            <article>
                
<p>A job is a command that's launched from a Terminal window. Each job can run as an independent background program or as an attached program from a Terminal (also known as the controlling Terminal here). The <kbd>TTY</kbd> field of the <kbd>ps</kbd> command is used to display the controlling Terminal name associated with a program.</p>
<p>Some programs, such as daemons (system services), are started by the system and do not have any controlling Terminal. Hence, these programs are not considered a member of a job and cannot be run in the foreground. Such programs have <kbd>?</kbd> in the <kbd>TTY</kbd> field of the <kbd>ps aux</kbd> command.</p>
<p>When a program is started as a foreground process from a Terminal, then that Terminal cannot be used for anything else, as it is executing that particular foreground process. Take the following command, for example:</p>
<pre><strong>$ sleep 1000</strong></pre>
<p>After execution of the preceding command, the Terminal will not respond to any other program, as it is controlling the sleep program in the frontend for <kbd>1000</kbd> seconds.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Foreground processes or jobs</h1>
                </header>
            
            <article>
                
<p>A foreground process or job is a process that is directly executed from the shell (also known as the <strong>controlling</strong> Terminal here). As long as that foreground job is running, other processes have to wait until it has completed for shell access.</p>
<p>This method of launching programs is fine, as long as a program is short and gets completed in a short period of time. If a program that requires a long time (say, many hours to complete) is launched from the shell in the foreground, it will make that shell unavailable for that number of hours. Such a practice is not suitable for command execution.</p>
<p>A foreground process will have <kbd>+</kbd> appended to its status when its details are viewed using the <kbd>ps</kbd> command. The plus <kbd>+</kbd> symbol means that it is in a foreground process group.</p>
<p>Start a <kbd>sleep</kbd> command in the foreground in one Terminal, as shown in the following command line:</p>
<pre><strong>$ sleep 1000</strong></pre>
<p>The following image list all the processes with specified columns and filter them using the <kbd>grep</kbd> command to display the a list of processes with sleep in their command name:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/061f2025-9dd0-4a0c-a963-7090fc7af202.png" style="width:33.50em;height:5.33em;" width="686" height="109"/></p>
<p>If you want to terminate a foreground program in-between, then use <em>Ctrl</em> + <em>C</em> (interrupt from the keyboard).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title"> Background processes or jobs</h1>
                </header>
            
            <article>
                
<p>For a program that takes a long time to complete, launching it as a background process (job) is the ideal practice. This frees up the shell, making it available for other tasks. We can execute other commands in the Terminal while a program is running as a background job from the controlling Terminal.</p>
<p>By default, all programs are executed as a foreground job from the Terminal. To start a <kbd>job</kbd> in the background from the Terminal, add an and at the end of the command. For example, start a <kbd>sleep</kbd> command in the background from a Terminal, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/421ac252-61ac-4e7e-8345-be53afbede87.png" style="width:16.42em;height:3.08em;" width="346" height="65"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Suspending a foreground process to the background</h1>
                </header>
            
            <article>
                
<p>We can move a foreground process to the background by following these two steps:</p>
<ol>
<li>First, press <em>Ctrl</em> + <em>Z</em>, which moves the process to the background in a Stopped state</li>
<li>Second, enter the <kbd>bg</kbd> command to change state of the last background process to Running from <kbd>Stoppedas</kbd>, as shown in the following <span>screenshot</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/de824493-779c-48aa-b4f5-05fd92632107.png" style="width:22.17em;height:12.00em;" width="486" height="263"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing jobs in the background</h1>
                </header>
            
            <article>
                
<p>A program is started in the background by appending an ampersand (&amp;) to the end of a command. On launching the program in the background, it displays a job ID (unique for the running session) and the PID of the background process, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/32f2a14c-cb0e-48b9-8482-258488b89b2d.png" style="width:16.92em;height:4.33em;" width="335" height="86"/></p>
<p>Use the <kbd>jobs</kbd> command to display the background jobs associated with the shell. The jobs command displays the job ID, state, and command name. If there is more the one background job, the default selection will have <kbd>+</kbd> in front of it, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5fa188c0-65e9-4f2a-9ca2-33b18b489801.png" style="width:21.67em;height:10.75em;" width="486" height="240"/></p>
<p>The <kbd>fg</kbd> command is used to bring a background job to the foreground using its job ID. The job ID and the <kbd>%</kbd> of the program is followed by the job number displayed in square brackets, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a0a80770-4299-428a-9127-085f58961129.png" style="width:23.50em;height:8.08em;" width="491" height="169"/></p>
<p>Send a foreground program to the background by first suspending it using <em>Ctrl </em>+ <em>Z</em> on the Terminal, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/09e7e6cf-2ccc-49ae-9e03-4d27def73246.png" style="width:23.67em;height:14.00em;" width="484" height="286"/></p>
<p>The <kbd>jobs</kbd> command, when used with the <kbd>-l</kbd> option, will also list the program ID. To get some more information, we can use the <kbd>ps</kbd> command with the <kbd>j</kbd> option, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1a1dcca4-d853-4456-8137-e26f62d41fc9.png" style="width:39.33em;height:15.17em;" width="798" height="308"/></p>
<p>The <kbd>bg</kbd> command followed by <kbd>%</kbd> and the job ID is used to start a stopped program in the background, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d1adc34f-5c3e-469c-a6d6-c30e9bb73a2c.png" style="width:22.08em;height:10.83em;" width="490" height="240"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we began by learning what a process is, and what different states and types of processes are in a Linux system. Then, we looked at different methods that exist in CentOS 7 to view running processes. This was followed by understanding how processes communicate with each other and how we can communicate with processes using signals. Thereafter, we learned how to monitor running processes and how to manage their priority using nice values. Finally, we looked at how <kbd>jobs</kbd> (commands) are managed on the command line by launching some applications in the background and switching an application from the background to the foreground, and vice versa.</p>
<p>In the next chapter, we will learn about networking concepts and networking commands in CentOS 7. We will also learn how to perform secure remote logins and backups over a network.</p>


            </article>

            
        </section>
    </div>



  </body></html>