["```\nrbrash@moon:~$\n```", "```\nroot@hostname #\n```", "```\nrbrash@moon:~$ history\n1002 ls\n1003 cd ../\n1004 pwd\n1005 whoami\n1006 history\n```", "```\nrbrash@moon:/$ whoami\nrbrash\nrbrash@moon:/$\n```", "```\n#!/bin/bash\n# Pound or hash sign signifies a comment (a line that is not executed)\nwhoami      #Command returning the current username\npwd         #Command returning the current working directory on the filesystem\nls          # Command returning the results (file listing) of the current working directory\necho “Echo one 1”; echo “Echo two 2” # Notice the semicolon used to delimit multiple commands in the same execution.\n```", "```\n#!/bin/bash\n```", "```\n$ chmod a+x script.sh\n```", "```\n$ bash script.sh          # if the user is currently in the same directory as the script\n$ bash /path/to/script.sh # Full path\n```", "```\n$ ./script.sh # if the user is currently in the same directory as the script\n$ /path/to/script.sh # Full path\n```", "```\nFor Ubuntu or Debian based distributions\n$ sudo apt-get -y install vim\nFor CentOS or RHEL\n$ sudo yum install -y vim\nFor Fedora\n$ sudo dnf install -y vim\n```", "```\n$ pwd\n/home/yourUserName\n$ vim my_first_script.sh\n```", "```\n#!/bin/bash\n# Echo this is my first comment\necho \"Hello world! This is my first Bash script!\"\necho -n \"I am executing the script with user: \"\nwhoami\necho -n \"I am currently running in the directory: \"\npwd\nexit 0\n```", "```\n$ bash my_first_script.sh \nHello world! This is my first Bash script!\nI am executing the script with user: rbrash\nI am currently running in the directory: /home/rbrash\n$ \n```", "```\nPI=3.14\necho \"The value of PI is $PI\"\n```", "```\nThe value of Pi is 3.14\n```", "```\necho \"1\\. The value of PI is $PI\"\necho \"2\\. The value of PI is ${PI}\"\necho \"3\\. The value of PI is\" $PI\n```", "```\n1\\. The value of PI is 3.14\n2\\. The value of PI is 3.14\n3\\. The value of PI is 3.14\n```", "```\necho \"1\\. The value of PI is $PIabc\" # Since PIabc is not declared, it will be empty string\necho \"2\\. The value of PI is ${PI}\"  # Still works because we correctly referred to PI\n```", "```\nPI=\"3.14\" # Notice the double quotes \"\"\n```", "```\nVAR_A=10\nVAR_B=$VAR_A\nVAR_C=${VAR_B}\n```", "```\n#!/bin/bash\n\nPI=3.14\nVAR_A=10\nVAR_B=$VAR_A\nVAR_C=${VAR_B}\n\necho \"Let's print 3 variables:\"\necho $VAR_A\necho $VAR_B\necho $VAR_C\n\necho \"We know this will break:\"\necho \"0\\. The value of PI is $PIabc\"     # since PIabc is not declared, it will be empty string\n\necho \"And these will work:\"\necho \"1\\. The value of PI is $PI\"\necho \"2\\. The value of PI is ${PI}\"\necho \"3\\. The value of PI is\" $PI\n\necho \"And we can make a new string\"\nSTR_A=\"Bob\"\nSTR_B=\"Jane\"\necho \"${STR_A} + ${STR_B} equals Bob + Jane\"\nSTR_C=${STR_A}\" + \"${STR_B}\necho \"${STR_C} is the same as Bob + Jane too!\"\necho \"${STR_C} + ${PI}\"\n\nexit 0\n```", "```\nLets print 3 variables:\n10\n10\n10\nWe know this will break:\n0\\. The value of PI is \nAnd these will work:\n1\\. The value of PI is 3.14\n2\\. The value of PI is 3.14\n3\\. The value of PI is 3.14\nAnd we can make a new string\nBob + Jane equals Bob + Jane\nBob + Jane is the same as Bob + Jane too!\nBob + Jane + 3.14\n```", "```\n$ env\nXDG_VTNR=7\nXDG_SESSION_ID=c2\nCLUTTER_IM_MODULE=xim\nXDG_GREETER_DATA_DIR=/var/lib/lightdm-data/rbrash\nSESSION=ubuntu\nSHELL=/bin/bash\nTERM=xterm-256color\nXDG_MENU_PREFIX=gnome-\nVTE_VERSION=4205\nQT_LINUX_ACCESSIBILITY_ALWAYS_ON=1\nWINDOWID=81788934\nUPSTART_SESSION=unix:abstract=/com/ubuntu/upstart-session/1000/1598\nGNOME_KEYRING_CONTROL=\nGTK_MODULES=gail:atk-bridge:unity-gtk-module\nUSER=rbrash\n....\n```", "```\n$ echo # Comment\n\n$ echo \\# Comment\n# Comment\n```", "```\n#!/bin/bash\nAGE=17\nif [ ${AGE} -lt 18 ]; then\n echo \"You must be 18 or older to see this movie\"\nfi\n```", "```\n#!/bin/bash\nAGE=40\nif [ ${AGE} -lt 18 ]\nthen\n    echo \"You must be 18 or older to see this movie\"\nelse\n    echo \"You may see the movie!\"\n    exit 1\nfi\n```", "```\n#!/bin/bash\nAGE=21\nif [ ${AGE} -lt 18 ]; then\n echo \"You must be 18 or older to see this movie\"\nelif [ ${AGE} -eq 21 ]; then\n echo \"You may see the movie and get popcorn\"\nelse\n echo \"You may see the movie!\"\n exit 1\nfi\n\necho \"This line might not get executed\"\necho:\n```", "```\nYou may see the movie and get popcorn\nThis line might not get executed\n```", "```\n#!/bin/bash\nMY_NAME=\"John\"\nNAME_1=\"Bob\"\nNAME_2=\"Jane\"\nNAME_3=\"Sue\"\nName_4=\"Kate\"\n\nif [ \"${MY_NAME}\" == \"Ron\" ]; then\n    echo \"Ron is home from vacation\"\nelif [ \"${MY_NAME}\" != ${NAME_1}\" && \"${MY_NAME}\" != ${NAME_2}\" && \"${MY_NAME}\" == \"John\" ]; then\n    echo \"John is home after some unnecessary AND logic\"\nelif [ \"${MY_NAME}\" == ${NAME_3}\" || \"${MY_NAME}\" == ${NAME_4}\" ]; then\n    echo \"Looks like one of the ladies are home\"\nelse\n    echo \"Who is this stranger?\"\nfi\nMY_NAME variable will be executed and the string John is home after some unnecessary AND logic will be echoed to the console. In the snippet, the logic flows like this:\n```", "```\n#!/bin/bash\nUSER_AGE=18\nAGE_LIMIT=18\nNAME=\"Bob\" # Change to your username if you want to execute the nested logic\nHAS_NIGHTMARES=\"true\"\n\nif [ \"${USER}\" == \"${NAME}\" ]; then\n    if [ ${USER_AGE} -ge ${AGE_LIMIT} ]; then\n        if [ \"${HAS_NIGHTMARES}\" == \"true\" ]; then\n            echo \"${USER} gets nightmares, and should not see the movie\"\n        fi\n    fi\nelse\n    echo \"Who is this?\"\nfi\n```", "```\n#!/bin/bash\nVAR=10\n\n# Multiple IF statements\nif [ $VAR -eq 1 ]; then\n    echo \"$VAR\"\nelif [ $VAR -eq 2]; then\n    echo \"$VAR\"\nelif [ $VAR -eq 3]; then\n    echo \"$VAR\"\n# .... to 10\nelse\n    echo \"I am not looking to match this value\"\nfi\n```", "```\ncase $THING_I_AM_TO_EVALUATE in\n  1) # Condition to evaluate is number 1 (could be \"a\" for a string too!)\n    echo \"THING_I_AM_TO_EVALUATE equals 1\"\n    ;; # Notice that this is used to close this evaluation\n  *) # * Signified the catchall (when THING_I_AM_TO_EVALUATE does not equal values in the switch)\n    echo \"FALLTHOUGH or default condition\"\nesac # Close case statement\n```", "```\n#!/bin/bash\nVAR=10 # Edit to 1 or 2 and re-run, after running the script as is.\ncase $VAR in\n  1)\n    echo \"1\"\n    ;;\n  2)\n    echo \"2\"\n    ;;\n  *)\n    echo \"What is this var?\"\n    exit 1\nesac\n```", "```\n#!/bin/bash\n\nFILES=( \"file1\" \"file2\" \"file3\" )\nfor ELEMENT in ${FILES[@]}\ndo\n        echo \"${ELEMENT}\"\ndone\n\necho \"Echo\\'d all the files\" \n```", "```\n#!/bin/bash\nCTR=1\nwhile [ ${CTR} -lt 9 ]\ndo\n    echo \"CTR var: ${CTR}\"\n    ((CTR++)) # Increment the CTR variable by 1\ndone\necho \"Finished\"\n```", "```\n#!/bin/bash\nCTR=1\nuntil [ ${CTR} -gt 9 ]\ndo\n    echo \"CTR var: ${CTR}\"\n    ((CTR++)) # Increment the CTR variable by 1\ndone\necho \"Finished\"\n```", "```\n#!/bin/bash\nfunction my_function() {\n    local PARAM_1=\"$1\"\n    local PARAM_2=\"$2\"\n    local PARAM_3=\"$3\"\n    echo \"${PARAM_1} ${PARAM_2} ${PARAM_3}\"\n}\nmy_function \"a\" \"b\" \"c\"\n```", "```\n#!/bin/bash\nFILES=( \"file1\" \"file2\" \"file3\" ) # This is a global variable\n\nfunction create_file() {\n    local FNAME=\"${1}\" # First parameter\n    local PERMISSIONS=\"${2}\" # Second parameter\n    touch \"${FNAME}\"\n    chmod \"${PERMISSIONS}\" \"${FNAME}\"\n    ls -l \"${FNAME}\"\n}\n\nfor ELEMENT in ${FILES[@]}\ndo\n        create_file \"${ELEMENT}\" \"a+x\"\ndone\n\necho \"Created all the files with a function!\"\nexit 0\n```", "```\n#!/bin/bash\n\nfunction create_file() {\n    local FNAME=$1\n    touch \"${FNAME}\"\n    ls \"${FNAME}\" # If output doesn't return a value - file is missing\n}\n\nfunction delete_file() {\n    local FNAME=$1\n    rm \"${FNAME}\"\n    ls \"${FNAME}\" # If output doesn't return a value - file is missing\n}\n```", "```\n#!/bin/bash\n\nsource library.sh # You may need to include the path as it is relative\nFNAME=\"my_test_file.txt\"\ncreate_file \"${FNAME}\"\ndelete_file \"${FNAME}\"\n\nexit 0\n```", "```\n$ bash io_maker.sh\nmy_test_file.txt\nls: cannot access 'my_test_file.txt': No such file or directory\n```", "```\n$ ls ~/this.file.no.exist\nls: cannot access '/home/rbrash/this.file.no.exist': No such file or directory\n$ echo $?\n2\n$ ls ~/.bashrc \n/home/rbrash/.bashrc\n$ echo $?\n0\n```", "```\n$ ls ~/this.file.no.exist\nls: cannot access '/home/rbrash/this.file.no.exist': No such file or directory\n$ TEST=$?\n$ echo $TEST\n2\n```", "```\n#!/bin/bash\nGLOBAL_RET=255\n\nfunction my_function_global() {\n    ls /home/${USER}/.bashrc\n    GLOBAL_RET=$?\n}\nfunction my_function_return() {\n    ls /home/${USER}/.bashrc\n    return $?\n}\nfunction my_function_str() {\n    local UNAME=$1\n    local OUTPUT=\"\"\n    if [ -e /home/${UNAME}/.bashrc ]; then\n        OUTPUT='FOUND IT'\n    else\n        OUTPUT='NOT FOUND'\n    fi\n    echo ${OUTPUT}\n}\n\necho \"Current ret: ${GLOBAL_RET}\"\nmy_function_global \"${USER}\"\necho \"Current ret after: ${GLOBAL_RET}\"\nGLOBAL_RET=255\necho \"Current ret: ${GLOBAL_RET}\"\nmy_function_return \"${USER}\"\nGLOBAL_RET=$?\necho \"Current ret after: ${GLOBAL_RET}\"\n\n# And for giggles, we can pass back output too!\nGLOBAL_RET=\"\"\necho \"Current ret: ${GLOBAL_RET}\"\nGLOBAL_RET=$(my_function_str ${USER})\n# You could also use GLOBAL_RET=`my_function_str ${USER}`\n# Notice the back ticks \"`\"\necho \"Current ret after: $GLOBAL_RET\"\nexit 0\n```", "```\nrbrash@moon:~$ bash test.sh\nCurrent ret: 255\n/home/rbrash/.bashrc\nCurrent ret after: 0\nCurrent ret: 255\n/home/rbrash/.bashrc\nCurrent ret after: 0\nCurrent ret: \nCurrent ret after: FOUND IT\n$\n```", "```\n$ iwconfig\nwlp3s0 IEEE 802.11abgn ESSID:\"127.0.0.1-2.4ghz\" \n          Mode:Managed Frequency:2.412 GHz Access Point: 18:D6:C7:FA:26:B1 \n          Bit Rate=144.4 Mb/s Tx-Power=22 dBm \n          Retry short limit:7 RTS thr:off Fragment thr:off\n          Power Management:on\n          Link Quality=58/70 Signal level=-52 dBm \n          Rx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0\n          Tx excessive retries:0 Invalid misc:90 Missed beacon:0\n\n```", "```\n$ iw dev                # This will give list of wireless interfaces\n$ iw dev wlp3s0 link    # This will give detailed information about particular wireless interface\n```", "```\n$ tail -F /var/log/messages | grep wlp3s0\nNov 10 11:57:13 moon kernel: wlp3s0: authenticate with 18:d6:c7:fa:26:b1\nNov 10 11:57:13 moon kernel: wlp3s0: send auth to 18:d6:c7:fa:26:b1 (try 1/3)\nNov 10 11:57:13 moon kernel: wlp3s0: send auth to 18:d6:c7:fa:26:b1 (try 2/3)\n...\n```", "```\n$ ls /filethatdoesntexist.txt 2> err.txt\n$ ls ~/ > stdout.txt\n$ ls ~/ > everything.txt 2>&1 # Gets stderr and stdout\n$ ls ~/ >> everything.txt 2>&1 # Gets stderr and stdout\n$ cat err.txt\nls: cannot access '/filethatdoesntexist.txt': No such file or directory\n$ cat stdout.txt\n.... # A whole bunch of files in your home directory\n```", "```\n>, 2>, and 2>&1. With the arrows we can redirect the output to any file or even to other programs!\n```", "```\n#!/bin/sh\n\n# Let's run a command and send all of the output to /dev/null\necho \"No output?\"\nls ~/fakefile.txt > /dev/null 2>&1\n\n# Retrieve output from a piped command \necho \"part 1\"\nHISTORY_TEXT=`cat ~/.bashrc | grep HIST`\necho \"${HISTORY_TEXT}\"\n\n# Output the results to history.config\necho \"part 2\"\necho \"${HISTORY_TEXT}\" > \"history.config\"\n\n# Re-direct history.config as input to the cat command\ncat < history.config\n\n# Append a string to history.config\necho \"MY_VAR=1\" >> history.config\n\necho \"part 3 - using Tee\"\n# Neato.txt will contain the same information as the console\nls -la ~/fakefile.txt ~/ 2>&1 | tee neato.txt\n```", "```\nbash myProgram.sh -v 99 --name=Ron -l Brash\n```", "```\n#!/bin/bash\n\nHELP_STR=\"usage: $0 [-h] [-f] [-l] [--firstname[=]<value>] [--lastname[=]<value] [--help]\"\n\n# Notice hidden variables and other built-in Bash functionality\noptspec=\":flh-:\"\nwhile getopts \"$optspec\" optchar; do\n    case \"${optchar}\" in\n        -)\n            case \"${OPTARG}\" in\n                firstname)\n                    val=\"${!OPTIND}\"; OPTIND=$(( $OPTIND + 1 ))\n                    FIRSTNAME=\"${val}\"\n                    ;;\n                lastname)\n                    val=\"${!OPTIND}\"; OPTIND=$(( $OPTIND + 1 ))\n                        LASTNAME=\"${val}\"\n                    ;;\n                help)\n                    val=\"${!OPTIND}\"; OPTIND=$(( $OPTIND + 1 ))\n                    ;;\n                *)\n                    if [ \"$OPTERR\" = 1 ] && [ \"${optspec:0:1}\" != \":\" ]; then\n                        echo \"Found an unknown option --${OPTARG}\" >&2\n                    fi\n                    ;;\n            esac;;\n        f)\n                val=\"${!OPTIND}\"; OPTIND=$(( $OPTIND + 1 ))\n                FIRSTNAME=\"${val}\"\n                ;;\n        l)\n                val=\"${!OPTIND}\"; OPTIND=$(( $OPTIND + 1 ))\n                LASTNAME=\"${val}\"\n                ;;\n        h)\n            echo \"${HELP_STR}\" >&2\n            exit 2\n            ;;\n        *)\n            if [ \"$OPTERR\" != 1 ] || [ \"${optspec:0:1}\" = \":\" ]; then\n                echo \"Error parsing short flag: '-${OPTARG}'\" >&2\n                exit 1\n            fi\n\n            ;;\n    esac\ndone\n\n# Do we have even one argument?\nif [ -z \"$1\" ]; then\n  echo \"${HELP_STR}\" >&2\n  exit 2\nfi\n\n# Sanity check for both Firstname and Lastname\nif [ -z \"${FIRSTNAME}\" ] || [ -z \"${LASTNAME}\" ]; then\n  echo \"Both firstname and lastname are required!\"\n  exit 3\nfi\n\necho \"Welcome ${FIRSTNAME} ${LASTNAME}!\"\n\nexit 0\n```", "```\n$ bash flags.sh \nusage: flags.sh [-h] [-f] [-l] [--firstname[=]<value>] [--lastname[=]<value] [--help]\n$ bash flags.sh -h\nusage: flags.sh [-h] [-f] [-l] [--firstname[=]<value>] [--lastname[=]<value] [--help]\n$ bash flags.sh --fname Bob\nBoth firstname and lastname are required!\nrbrash@moon:~$ bash flags.sh --firstname To -l Mater\nWelcome To Mater!\n```", "```\n$ man mount\n... \nMOUNT(8) System Administration MOUNT(8)\nNAME\n mount - mount a filesystem\nSYNOPSIS\n mount [-l|-h|-V]\n mount -a [-fFnrsvw] [-t fstype] [-O optlist]\n mount [-fnrsvw] [-o options] device|dir\n mount [-fnrsvw] [-t fstype] [-o options] device dir\nDESCRIPTION\n All files accessible in a Unix system are arranged in one big tree, the\n file hierarchy, rooted at /. These files can be spread out over sev‐\n eral devices. The mount command serves to attach the filesystem found\n on some device to the big file tree. Conversely, the umount(8) command\n will detach it again.\n...\n(Press 'q' to Quit)\n$\n```"]