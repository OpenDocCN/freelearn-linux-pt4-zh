<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Twitter Access Control System with Smart Card and RFID"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Twitter Access Control System with Smart Card and RFID</h1></div></div></div><p>Identifying people or objects with a computer may seem like an easy task, but, in reality, there is a lot of technology behind the devices used to accomplish this task.</p><p>In this chapter, we are going to use a <a id="id407" class="indexterm"/>smart card reader and two kinds of RFID readers (a <span class="strong"><strong>Low Frequency</strong></span> <a id="id408" class="indexterm"/>or <span class="strong"><strong>LF</strong></span> reader suitable for short ranges and an <a id="id409" class="indexterm"/>
<span class="strong"><strong>Ultra High Frequency</strong></span> or <span class="strong"><strong>UHF</strong></span> reader suitable for long ranges) in order to show different possibilities to implement a minimal identifying system for access control.</p><p>Once the detection has been done, the system will send a message to our Twitter account informing our followers about what is happening (in a normal case, we may lock or unlock something, but I decided to do something different).</p><div class="section" title="The basics of functioning"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>The basics of functioning</h1></div></div></div><p>The smart cards <a id="id410" class="indexterm"/>and the smart card readers, for example, are complex devices that are used everywhere nowadays, from our credit cards to our smartphones. The term smart card implies a set of technologies, including integrated circuits, microprocessors, memories, antennas, and so on, in the same integrated circuit, to form a microchip that is the heart of a smart card. On the other hand, the smart card readers are complex devices that can communicate with the cards and save data on it or return data to a computer.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note88"/>Note</h3><p>The reader can get more information regarding the smart card<a id="id411" class="indexterm"/> world by taking a look at <a class="ulink" href="https://en.wikipedia.org/wiki/Smart_card.">https://en.wikipedia.org/wiki/Smart_card.</a>
</p></div></div><p>The evolution of smart cards are the <a id="id412" class="indexterm"/>
<span class="strong"><strong>Radio-Frequency Identification</strong></span> (<span class="strong"><strong>RFID</strong></span>) devices that can be used to identify people or objects in a contactless form, starting from a few centimeters to several meters. The RFID readers and the corresponding tags (or transponders) are high technology radio devices that can exchange data to each other in order to accomplish identification tasks.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note89"/>Note</h3><p>The reader can get more information regarding the <span class="strong"><strong>RFID</strong></span>
<a id="id413" class="indexterm"/> world by taking a look at <a class="ulink" href="https://en.wikipedia.org/wiki/Radio-frequency_identification">https://en.wikipedia.org/wiki/Radio-frequency_identification</a>.</p></div></div><p>This time, all the <a id="id414" class="indexterm"/>complexity of this project is inside the hardware devices (the smart card reader and the RFID readers) and their corresponding software managers, so we only have to write the code to get access to them and retrieve the data held in the smart cards or the RFID tags only.</p><p>In order to show different techniques to manage an identification device, we're going to write three programs (one per device) in three different programming languages. However, the result of all programs will be the same: when a well-defined person (or object) has been recognized, a message will be sent to our Twitter account.</p><p>To accomplish this last task, we're going to use a dedicated (and interesting) tool that allows the user to manage a Twitter account from the command line.</p><p>Every identification system has its own characteristics; however:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The solution with the smart card reader can be used, where the identification can be done by inserting a credit card (or something similar) somewhere for identification. This is not suitable for wireless applications. The smart card reader I'm going to use in my prototype is a USB device with a slot where the smart card must be inserted.</li><li class="listitem" style="list-style-type: disc">The second solution, that is, the one with the RFID LF reader, can be used where the identification tasks need wireless, but where the distance between the object to identify and the reader is no more than a few centimeters. These kinds of devices are usually very simple, such as the one I'm going to use in my prototype. The RFID reader is connected with the host by a serial port, and it simply returns a string each time a tag is detected.</li><li class="listitem" style="list-style-type: disc">The last solution is implemented with a RFID UHF reader, that is, with a device that can detect tags in a wireless mode, as the preceding RFID LF reader does, but at a distance of several meters long. These UHF devices can be more complex than the LF ones, such as the one I'm going to use for my prototype. The RFID reader still uses a serial connection to talk with the host, but it implements a more elaborate protocol to exchange data.</li></ul></div></div></div>
<div class="section" title="Setting up the hardware"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Setting up the hardware</h1></div></div></div><p>As just said in the<a id="id415" class="indexterm"/> previous section, this time we have to connect a USB device and two serial devices. Regarding the USB device, the main problem is that it has a nonstandard USB connector, so we have to find a trick to solve the problem (see the following part); while for the serial devices, we have to find two free serial ports on the BeagleBone Black's expansion connectors.</p><p>Regarding this last issue, we should remember that the BeagleBone Black has six on-board serial ports that are disabled by default, except the <code class="literal">/dev/ttyO0</code> device, which is coupled to the serial console. If we do log in into the system, we can easily verify it by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@BeagleBone:~# ls -l /dev/ttyO*</strong></span>
<span class="strong"><strong>crw-rw---- 1 root tty 248, 0 Apr 23 20:20 /dev/ttyO0</strong></span>
</pre></div><p>To enable the other serial ports, we need to modify the kernel settings in order to enable the serial port that we wish to use. The choice of which ports to enable depends on the pins we'd like to use to connect our devices, and the following table may help us in choosing them:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Device</p>
</th><th style="text-align: left" valign="bottom">
<p>TxD</p>
</th><th style="text-align: left" valign="bottom">
<p>RxD</p>
</th><th style="text-align: left" valign="bottom">
<p>RTS</p>
</th><th style="text-align: left" valign="bottom">
<p>CTS</p>
</th><th style="text-align: left" valign="bottom">
<p>Name</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/dev/ttyO1</code>
</p>
</td><td style="text-align: left" valign="top">
<p>P9.24</p>
</td><td style="text-align: left" valign="top">
<p>P9.26</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">UART1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/dev/ttyO2</code>
</p>
</td><td style="text-align: left" valign="top">
<p>P9.21</p>
</td><td style="text-align: left" valign="top">
<p>P9.22</p>
</td><td style="text-align: left" valign="top">
<p>P8.38</p>
</td><td style="text-align: left" valign="top">
<p>P8.37</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">UART2</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/dev/ttyO4</code>
</p>
</td><td style="text-align: left" valign="top">
<p>P9.13</p>
</td><td style="text-align: left" valign="top">
<p>P9.11</p>
</td><td style="text-align: left" valign="top">
<p>P8.33</p>
</td><td style="text-align: left" valign="top">
<p>P8.35</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">UART4</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/dev/ttyO5</code>
</p>
</td><td style="text-align: left" valign="top">
<p>P8.37</p>
</td><td style="text-align: left" valign="top">
<p>P8.38</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">UART5</code>
</p>
</td></tr></tbody></table></div><p>All the devices are suitable for our scope, so I choose to use the two <code class="literal">/dev/ttyO1</code> and <code class="literal">/dev/ttyO2</code> devices, and, to activate them, we can use the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@BeagleBone:~# echo BB-UART1 &gt; /sys/devices/bone_capemgr.9/slots</strong></span>
<span class="strong"><strong>root@BeagleBone:~# echo BB-UART2 &gt; /sys/devices/bone_capemgr.9/slots</strong></span>
</pre></div><p>Now, two new serial ports are ready to be used, as shown by the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ls -l /dev/ttyO*</strong></span>
<span class="strong"><strong>crw-rw---- 1 root tty     248, 0 Apr 23 20:20 /dev/ttyO0</strong></span>
<span class="strong"><strong>crw-rw---T 1 root dialout 248, 1 Apr 23 21:48 /dev/ttyO1</strong></span>
<span class="strong"><strong>crw-rw---T 1 root dialout 248, 2 Apr 23 21:48 /dev/ttyO2</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note90"/>Note</h3><p>The reader can also take a look at the book <span class="emphasis"><em>BeagleBone Essentials</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>, written by the author of this book, in order to have more information regarding how to manage the BeagleBone Black's serial ports needed to communicate with the sensors.</p></div></div><div class="section" title="Setting up the smart card reader"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec73"/>Setting up the smart card reader</h2></div></div></div><p>The smart card reader I<a id="id416" class="indexterm"/> used in this prototype is shown in the following image:</p><div class="mediaobject"><img src="graphics/B00255_09_01.jpg" alt="Setting up the smart card reader"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note91"/>Note</h3><p>The <a id="id417" class="indexterm"/>device can be purchased at the following link (or by surfing the Internet): <a class="ulink" href="http://www.cosino.io/product/http://www.cosino.io/product/smartcard-reader-isoiec-7816">http://www.cosino.io/product/http://www.cosino.io/product/smartcard-reader-isoiec-7816</a>.</p><p>The device is based on the chip<a id="id418" class="indexterm"/> <span class="strong"><strong>Maxim 73S1215F</strong></span>, and its datasheet is available at <a class="ulink" href="http://datasheets.maximintegrated.com/en/ds/73S1215F.pdf">http://datasheets.maximintegrated.com/en/ds/73S1215F.pdf</a>.</p></div></div><p>As stated before, this device has a nonstandard USB connector, so we have to find a trick to connect it to our BeagleBone Black.</p><p>The <span class="emphasis"><em>quick and dirty</em></span> solution can be in using a USB plug type A adapter from an old USB device, which then must be soldered with the board, as shown in the following image:</p><div class="mediaobject"><img src="graphics/B00255_09_02.jpg" alt="Setting up the smart card reader"/></div><p>The connections <a id="id419" class="indexterm"/>must be done according to the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Smart Card reader pin</p>
</th><th style="text-align: left" valign="bottom">
<p>USB plug type A cable</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>VBus</p>
</td><td style="text-align: left" valign="top">
<p>Red</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>D-</p>
</td><td style="text-align: left" valign="top">
<p>White</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>D+</p>
</td><td style="text-align: left" valign="top">
<p>Yellow</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GND</p>
</td><td style="text-align: left" valign="top">
<p>Green</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note92"/>Note</h3><p>The connector pin out<a id="id420" class="indexterm"/> can be retrieved at <a class="ulink" href="https://en.wikipedia.org/wiki/USB">https://en.wikipedia.org/wiki/USB</a> in the <span class="strong"><strong>pin out</strong></span> box on the left.</p></div></div><p>If the connections are correct, once you connect the device to the BeagleBone Black, you should get an output as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>usb usb1: usb wakeup-resume</strong></span>
<span class="strong"><strong>usb usb1: usb auto-resume</strong></span>
<span class="strong"><strong>hub 1-0:1.0: hub_resume</strong></span>
<span class="strong"><strong>hub 1-0:1.0: port 1: status 0101 change 0001</strong></span>
<span class="strong"><strong>hub 1-0:1.0: state 7 ports 1 chg 0002 evt 0000</strong></span>
<span class="strong"><strong>hub 1-0:1.0: port 1, status 0101, change 0000, 12 Mb/s</strong></span>
<span class="strong"><strong>usb 1-1: new full-speed USB device number 2 using musb-hdrc</strong></span>
<span class="strong"><strong>usb 1-1: ep0 maxpacket = 16</strong></span>
<span class="strong"><strong>usb 1-1: skipped 1 descriptor after interface</strong></span>
<span class="strong"><strong>usb 1-1: skipped 1 descriptor after interface</strong></span>
<span class="strong"><strong>usb 1-1: default language 0x0409</strong></span>
<span class="strong"><strong>usb 1-1: udev 2, busnum 1, minor = 1</strong></span>
<span class="strong"><strong>usb 1-1: New USB device found, idVendor=1862, idProduct=0001</strong></span>
<span class="strong"><strong>usb 1-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3</strong></span>
<span class="strong"><strong>usb 1-1: Product: TSC12xxF CCID-DFU Version 2.10</strong></span>
<span class="strong"><strong>usb 1-1: Manufacturer: Teridian Semiconductors</strong></span>
<span class="strong"><strong>usb 1-1: SerialNumber: 123456789</strong></span>
<span class="strong"><strong>usb 1-1: usb_probe_device</strong></span>
<span class="strong"><strong>usb 1-1: configuration #1 chosen from 1 choice</strong></span>
<span class="strong"><strong>usb 1-1: adding 1-1:1.0 (config #1, interface 0)</strong></span>
<span class="strong"><strong>usb 1-1: adding 1-1:1.1 (config #1, interface 1)</strong></span>
<span class="strong"><strong>hub 1-0:1.0: state 7 ports 1 chg 0000 evt 0002</strong></span>
<span class="strong"><strong>hub 1-0:1.0: port 1 enable change, status 00000103</strong></span>
</pre></div><p>Okay, everything <a id="id421" class="indexterm"/>works correctly, but now we need some packages to manage our smart card reader. So, let's install them by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# aptitude install pcsc-tools pcscd libccid</strong></span>
</pre></div><p>Once finished, the <code class="literal">pcsc</code> tool is ready to work.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note93"/>Note</h3><p>The curious reader may take a <a id="id422" class="indexterm"/>look at the following URL for further information on this tool: <a class="ulink" href="http://ludovic.rousseau.free.fr/softwares/pcsc-tools/">http://ludovic.rousseau.free.fr/softwares/pcsc-tools/</a>.</p></div></div><p>Once installed, we can execute it with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# pcsc_scan</strong></span>
<span class="strong"><strong>PC/SC device scanner</strong></span>
<span class="strong"><strong>V 1.4.20 (c) 2001-2011, Ludovic Rousseau &lt;ludovic.rousseau@free.fr&gt;</strong></span>
<span class="strong"><strong>Compiled with PC/SC lite version: 1.8.3</strong></span>
<span class="strong"><strong>Using reader plug'n play mechanism</strong></span>
<span class="strong"><strong>Scanning present readers...</strong></span>
<span class="strong"><strong>Waiting for the first reader...</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip113"/>Tip</h3><p>In case you get the following error instead of the preceding output, you can try to restart the daemon with the <code class="literal">/etc/init.d/pcscd restart</code> command and then execute the <code class="literal">pcsc_scan</code> tool again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SCardEstablishContext: Service not available.</strong></span>
</pre></div></div></div><p>Okay, the <a id="id423" class="indexterm"/>daemon started correctly, but it still didn't recognize our device. In this case, we have to patch the <code class="literal">/etc/libccid_Info.plist</code> configuration file, as shown in the following patch:</p><div class="informalexample"><pre class="programlisting">--- /etc/libccid_Info.plist.orig	2014-04-23 20:39:48.664062641 +0000
+++ /etc/libccid_Info.plist	2014-04-23 20:40:28.705078271 +0000
@@ -325,6 +325,7 @@
       &lt;string&gt;0x08C3&lt;/string&gt;
       &lt;string&gt;0x08C3&lt;/string&gt;
       &lt;string&gt;0x15E1&lt;/string&gt;
+      &lt;string&gt;0x1862&lt;/string&gt;
    &lt;/array&gt;
 
    &lt;key&gt;ifdProductID&lt;/key&gt;
@@ -550,6 +551,7 @@
       &lt;string&gt;0x0401&lt;/string&gt;
       &lt;string&gt;0x0402&lt;/string&gt;
       &lt;string&gt;0x2007&lt;/string&gt;
+      &lt;string&gt;0x0001&lt;/string&gt;
    &lt;/array&gt;
 
    &lt;key&gt;ifdFriendlyName&lt;/key&gt;
@@ -775,6 +777,7 @@
       &lt;string&gt;Precise Biometrics Precise 250 MC&lt;/string&gt;
       &lt;string&gt;Precise Biometrics Precise 200 MC&lt;/string&gt;
       &lt;string&gt;RSA RSA SecurID (R) Authenticator&lt;/string&gt;
+                &lt;string&gt;TSC12xxF&lt;/string&gt;
    &lt;/array&gt;
 
    &lt;key&gt;Copyright&lt;/key&gt;</pre></div><p>After all the modifications are in place, we have to restart the daemon. Now the output should change as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# /etc/init.d/pcscd restart</strong></span>
<span class="strong"><strong>[ ok ] Restarting pcscd (via systemctl): pcscd.service.</strong></span>
<span class="strong"><strong>root@beaglebone:~# pcsc_scan</strong></span>
<span class="strong"><strong>PC/SC device scanner</strong></span>
<span class="strong"><strong>V 1.4.20 (c) 2001-2011, Ludovic Rousseau &lt;ludovic.rousseau@free.fr&gt;</strong></span>
<span class="strong"><strong>Compiled with PC/SC lite version: 1.8.3</strong></span>
<span class="strong"><strong>Using reader plug'n play mechanism</strong></span>
<span class="strong"><strong>Scanning present readers...</strong></span>
<span class="strong"><strong>0: TSC12xxF (123456789) 00 00</strong></span>
<span class="strong"><strong>1: TSC12xxF (123456789) 00 01</strong></span>
<span class="strong"><strong>2: TSC12xxF (123456789) 00 02</strong></span>
<span class="strong"><strong>3: TSC12xxF (123456789) 00 03</strong></span>
<span class="strong"><strong>4: TSC12xxF (123456789) 00 04</strong></span>

<span class="strong"><strong>Wed Apr 23 20:40:56 2014</strong></span>
<span class="strong"><strong>Reader 0: TSC12xxF (123456789) 00 00</strong></span>
<span class="strong"><strong>  Card state: Card removed,</strong></span>
<span class="strong"><strong>Reader 1: TSC12xxF (123456789) 00 01</strong></span>
<span class="strong"><strong>  Card state: Card removed,</strong></span>
<span class="strong"><strong>Reader 2: TSC12xxF (123456789) 00 02</strong></span>
<span class="strong"><strong>  Card state: Card removed,</strong></span>
<span class="strong"><strong>Reader 3: TSC12xxF (123456789) 00 03</strong></span>
<span class="strong"><strong>  Card state: Card removed,</strong></span>
<span class="strong"><strong>Reader 4: TSC12xxF (123456789) 00 04</strong></span>
<span class="strong"><strong>  Card state: Card removed,</strong></span>
</pre></div><p>Great! Now we<a id="id424" class="indexterm"/> can verify that the reader is really working by inserting a card into the socket and by verifying that the tool should print something, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Wed Apr 23 20:52:22 2014</strong></span>
<span class="strong"><strong>Reader 0: TSC12xxF (123456789) 00 00</strong></span>
<span class="strong"><strong>  Card state: Card inserted,</strong></span>
<span class="strong"><strong>  ATR: 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00</strong></span>

<span class="strong"><strong>ATR: 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00</strong></span>
<span class="strong"><strong>+ TS = 3B --&gt; Direct Convention</strong></span>
<span class="strong"><strong>+ T0 = BE, Y(1): 1011, K: 14 (historical bytes)</strong></span>
<span class="strong"><strong>  TA(1) = 11 --&gt; Fi=372, Di=1, 372 cycles/ETU</strong></span>
<span class="strong"><strong>    10752 bits/s at 4 MHz, fMax for Fi = 5 MHz =&gt; 13440 bits/s</strong></span>
<span class="strong"><strong>  TB(1) = 00 --&gt; VPP is not electrically connected</strong></span>
<span class="strong"><strong>  TD(1) = 00 --&gt; Y(i+1) = 0000, Protocol T = 0</strong></span>
<span class="strong"><strong>-----</strong></span>
<span class="strong"><strong>+ Historical bytes: 41 01 38 00 00 00 00 00 00 00 00 01 90 00</strong></span>
<span class="strong"><strong>  Category indicator byte: 41 (proprietary format)</strong></span>

<span class="strong"><strong>Possibly identified card (using /usr/share/pcsc/smartcard_list.txt):</strong></span>
<span class="strong"><strong>3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00</strong></span>
<span class="strong"><strong>   ACS (Advanced Card System) ACOS-1</strong></span>
</pre></div><p>The device is <a id="id425" class="indexterm"/>functioning; however, we need a dedicated program to manage the cards. So, let's install the <code class="literal">python-pyscard</code> package with the usual <code class="literal">aptitude</code> command and then consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">#
# Smart Card Observer
#

class printobserver(CardObserver):
   def update(self, observable, (addedcards, removedcards)):
      for card in addedcards:
         logging.info("-&gt;] " + toHexString(card.atr))
      for card in removedcards:
         logging.info("&lt;-] " + toHexString(card.atr))

#
# The daemon body
#

def daemon_body():
   # The main loop
   logging.info("INFO waiting for card... (hit CTRL+C to stop)")

   try:
      cardmonitor = CardMonitor()
      cardobserver = printobserver()
      cardmonitor.addObserver(cardobserver)

      while True:
         sleep(1000000) # sleep forever
 
   except:
      cardmonitor.deleteObserver(cardobserver)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note94"/>Note</h3><p>The complete code is stored in the <code class="literal">chapter_09/smart_card/smart_card.py</code> script in the book's example code repository.</p></div></div><p>The program defines a <code class="literal">cardmonitor</code> object and then adds its observer with the <code class="literal">addObserver()</code> method in order to be called when a card is inserted or removed.</p><p>If executed, the program gives an output as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/smart_card# ./smart_card.py</strong></span>
<span class="strong"><strong>INFO:root:INFO waiting for card... (hit CTRL+C to stop)</strong></span>
<span class="strong"><strong>INFO:root:-&gt;] 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00</strong></span>
<span class="strong"><strong>INFO:root:&lt;-] 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip114"/>Tip</h3><p>If you<a id="id426" class="indexterm"/> get the following error while executing the command, you need the <code class="literal">python-daemon</code> package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ImportError: No module named daemon</strong></span>
</pre></div><p>You an resolve the issue by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/smart_card# pip install python-daemon</strong></span>
</pre></div></div></div></div><div class="section" title="Setting up the RFID LF reader"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec74"/>Setting up the RFID LF reader</h2></div></div></div><p>As an <a id="id427" class="indexterm"/>RFID LF reader, we can use the device shown in the following image that sends its data through a serial port at the TTL 3.3V level:</p><div class="mediaobject"><img src="graphics/B00255_09_03.jpg" alt="Setting up the RFID LF reader"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note95"/>Note</h3><p>The<a id="id428" class="indexterm"/> device can be purchased at the following link (or by surfing the Internet): <a class="ulink" href="http://www.cosino.io/product/lf-rfid-low-voltage-reader">http://www.cosino.io/product/lf-rfid-low-voltage-reader</a>.</p><p>The datasheet of this device is available at <a class="ulink" href="http://cdn.sparkfun.com/datasheets/Sensors/ID/ID-2LA,%20ID-12LA,%20ID-20LA2013-4-10.pdf">http://cdn.sparkfun.com/datasheets/Sensors/ID/ID-2LA,%20ID-12LA,%20ID-20LA2013-4-10.pdf</a>.</p></div></div><p>It can be<a id="id429" class="indexterm"/> directly connected to our BeagleBone Black to the following pins of the expansion connector <span class="emphasis"><em>P9</em></span>, corresponding to the already-enabled serial device <code class="literal">/dev/ttyO1</code>:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pins</p>
</th><th style="text-align: left" valign="bottom">
<p>RFID LF reader pins - label</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>P9.4 - Vcc</p>
</td><td style="text-align: left" valign="top">
<p>8 - Vcc</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.26 - RxD</p>
</td><td style="text-align: left" valign="top">
<p>6 - TX</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.2 - GND</p>
</td><td style="text-align: left" valign="top">
<p>7 - GND</p>
</td></tr></tbody></table></div><p>After all the pins have been connected, the tag's data will be available on the <code class="literal">/dev/ttyO1</code> device. To quickly verify it, we can use the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@BeagleBone:~# stty -F /dev/ttyO1 9600 raw</strong></span>
<span class="strong"><strong>root@BeagleBone:~# cat /dev/ttyO1</strong></span>
</pre></div><p>Then, when approaching a tag to the reader, we should hear a <span class="emphasis"><em>beep</em></span>, and the corresponding tag's ID should appear to the command line as follows. (The following <code class="literal">cat</code> command is repeated from before for better readability, so you don't need to retype it):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@BeagleBone:~# cat /dev/ttyO1</strong></span>
<span class="strong"><strong>.6F007F4E1E40</strong></span>
</pre></div><p>However, using the <code class="literal">cat</code> command is not the best thing to do for our purposes since its output is not a completely clean ASCII text (see the device's datasheet for further information about this issue); in fact, some <span class="emphasis"><em>dirty</em></span> bytes are received before the tag ID. For example, the dot '<code class="literal">.</code>' before the tag ID is one of these bytes. So, we can imagine writing a dedicated tool to clean the received messages from the device in order to have a clean ASCII ID string. A code snippet of such a tool is as follows:</p><div class="informalexample"><pre class="programlisting"># Read the tags' IDs
cat $dev | while read id ; do
   # Remove the non printable characters and print the data
   echo -n $id | tr '\r' '\n' | tr -cd '[:alnum:]\n'
done</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note96"/>Note</h3><p>The complete code is stored in the <code class="literal">chapter_09/rfid_lf/rfid_lf.sh</code> script in the book's example code repository.</p></div></div><p>The <code class="literal">cat</code> command reads the data from the device addressed by the <code class="literal">dev</code> variable, as in the preceding example; then, the output is passed through the <code class="literal">tr</code> command in order to remove nonprintable <a id="id430" class="indexterm"/>characters. The result is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/rfid_lf# ./rfid_lf.sh /dev/ttyO1</strong></span>
<span class="strong"><strong>6F007F48C199</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip116"/>Tip</h3><p>The curious reader can take a look at the <code class="literal">tr</code>'s man pages for further information about its usage.</p></div></div></div><div class="section" title="Setting up the RFID UHF reader"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec75"/>Setting up the RFID UHF reader</h2></div></div></div><p>As an RFID UHF reader, we<a id="id431" class="indexterm"/> can use the following device that sends its data through a serial port at the TTL 3.3V level:</p><div class="mediaobject"><img src="graphics/B00255_09_04.jpg" alt="Setting up the RFID UHF reader"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note97"/>Note</h3><p>The device can be <a id="id432" class="indexterm"/>purchased at the following link (or by surfing the Internet): <a class="ulink" href="http://www.cosino.io/product/uhf-rfid-long-range-reader">http://www.cosino.io/product/uhf-rfid-long-range-reader</a>.</p><p>The product's information from the manufacturer is available at <a class="ulink" href="http://www.caenrfid.it/en/CaenProd.jsp?mypage=3&amp;parent=59&amp;idmod=818">http://www.caenrfid.it/en/CaenProd.jsp?mypage=3&amp;parent=59&amp;idmod=818</a>.</p></div></div><p>It can be directly connected to our <a id="id433" class="indexterm"/>BeagleBone Black to the following pins of the expansion connector <span class="emphasis"><em>P9</em></span>, which are connected with the already-enabled serial device <code class="literal">/dev/ttyO2</code>:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pins</p>
</th><th style="text-align: left" valign="bottom">
<p>RFID UHF reader pins - label</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>P9.6 - Vcc</p>
</td><td style="text-align: left" valign="top">
<p>1 - +5V</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.21 - TxD</p>
</td><td style="text-align: left" valign="top">
<p>9 - RXD</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.22 - RxD</p>
</td><td style="text-align: left" valign="top">
<p>10 - TXD</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>P9.1 - GND</p>
</td><td style="text-align: left" valign="top">
<p>12 - GND</p>
</td></tr></tbody></table></div><p>After all the pins have been connected, the tag's data will be available at the <code class="literal">/dev/ttyO2</code> device, but to get them, we need extra software. In fact, this device requires a special protocol to communicate with the host, so we need to install a dedicated <span class="strong"><strong>C</strong></span> library to do the trick, as explained in the following part.</p><p>We need to download, compile, and then install three libraries: <code class="literal">libmsgbuff</code>, <code class="literal">libavp</code>, and <code class="literal">libcaenrfid</code>.</p><p>First of all, we need some prerequisite packages. So, let's install them:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# aptitude install git debhelper dctrl-tools</strong></span>
</pre></div><p>Now, we can start downloading the first library with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# git clone http://github.com/cosino/libmsgbuff.git</strong></span>
</pre></div><p>Then, we have to enter in the new directory <code class="literal">libmsgbuff</code> and execute the <code class="literal">autogen.sh</code> command, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cd libmsgbuff</strong></span>
<span class="strong"><strong>root@beaglebone:~/libmsgbuff# ./autogen.sh</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip117"/>Tip</h3><p>It may happen that you get the following errors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>aclocal:configure.ac:11: warning: macro `AM_SILENT_RULES' not found in library</strong></span>
<span class="strong"><strong>aclocal:configure.ac:18: warning: macro `AM_PROG_AR' not found in library</strong></span>
<span class="strong"><strong>configure.ac:11: error: possibly undefined macro: AM_SILENT_RULES</strong></span>
<span class="strong"><strong>      If this token and others are legitimate, please use m4_pattern_allow.</strong></span>
<span class="strong"><strong>      See the Autoconf documentation.</strong></span>
</pre></div><p>In this case, the lines with the macros <code class="literal">AM_SILENT_RULES</code> and <code class="literal">AM_PROG_AR</code> should be deleted, as shown in the following patch:</p><div class="informalexample"><pre class="programlisting"> index dcfd1ce..333e417 100644
--- a/configure.ac
+++ b/configure.ac
@@ -8,14 +8,12 @@ AC_CONFIG_SRCDIR([msgbuff.c])
 AC_CONFIG_HEADERS([configure.h])
 
 AM_INIT_AUTOMAKE([1.9 foreign -Wall -Werror])
-AM_SILENT_RULES([yes])
 
 # Global settings
 AC_SUBST(EXTRA_CFLAGS, ['-Wall -D_GNU_SOURCE -include configure.h'])
 
 # Checks for programs
 AC_PROG_CXX
-AM_PROG_AR
 AC_PROG_AWK
 AC_PROG_CC
 AC_PROG_CPP</pre></div><p>Then, we can safely restart the <code class="literal">autogen.sh</code> command.</p></div></div><p>Then, to<a id="id434" class="indexterm"/> recompile the library, we can use the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/libmsgbuff# ./debian/rules binary</strong></span>
<span class="strong"><strong>dpkg-deb: building package `libmsgbuff0' in `../libmsgbuff0_0.60.0_armhf.deb'</strong></span>
<span class="strong"><strong>.</strong></span>
<span class="strong"><strong>dpkg-deb: building package `libmsgbuff-dev' in `../libmsgbuff-dev_0.60.0_armhf.deb'.</strong></span>
</pre></div><p>Okay, now that the packages are ready we can install them by using the <code class="literal">dpkg</code> command, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/libmsgbuff# dpkg -i ../libmsgbuff0_0.60.0_armhf.deb ../libmsgbuff-dev_0.60.0_armhf.deb</strong></span>
<span class="strong"><strong>Setting up libmsgbuff0 (0.60.0) ...</strong></span>
<span class="strong"><strong>Setting up libmsgbuff-dev (0.60.0) ...</strong></span>
</pre></div><p>Now it's the turn of the second library. The steps are the same as in the preceding example. Once done, move to the parent directory and then download the new sources with the following <code class="literal">git</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# git clone http://github.com/cosino/libavp.git</strong></span>
</pre></div><p>Then, execute the <code class="literal">autogen.sh</code> script in the library's directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# cd libavp</strong></span>
<span class="strong"><strong>root@beaglebone:~/libavp# ./autogen.sh</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip120"/>Tip</h3><p>Again, as in the preceding example, if an <code class="literal">undefined macro</code> error occurs, just apply the same patch as in the preceding example at the current <code class="literal">autogen.sh</code> script.</p></div></div><p>Then, start the following compilation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/libavp# ./debian/rules binary</strong></span>
<span class="strong"><strong>dpkg-deb: building package `libavp0' in `../libavp0_0.80.0_armhf.deb'.</strong></span>
<span class="strong"><strong>dpkg-deb: building package `libavp-dev' in `../libavp-dev_0.80.0_armhf.deb'.</strong></span>
</pre></div><p>And, finally, execute the <code class="literal">dpkg</code> command to install the packages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/libavp# dpkg -i ../libavp0_0.80.0_armhf.deb ../libavp-dev_0.80.0_armhf.deb</strong></span>
</pre></div><p>Okay, for the<a id="id435" class="indexterm"/> last library the procedure is similar, but with a little note. Move to the parent directory. Then, download the code and execute the <code class="literal">autogen.sh</code> script (patch it as before if needed):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# git clone http://github.com/cosino/libcaenrfid.git</strong></span>
<span class="strong"><strong>root@beaglebone:~# cd libcaenrfid/</strong></span>
<span class="strong"><strong>root@beaglebone:~/libcaenrfid# ./autogen.sh</strong></span>
</pre></div><p>Then, we need to create two new files for the BeagleBone Black's architecture (which is named <code class="literal">armhf</code> in Debian). The commands are as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/libcaenrfid# cp src/linux-gnueabi.c src/linux-gnueabihf.c</strong></span>
<span class="strong"><strong>root@beaglebone:~/libcaenrfid# cp src/linux-gnueabi.h src/linux-gnueabihf.h</strong></span>
</pre></div><p>Now we can execute the usual package generation command followed by the installation one, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/libcaenrfid# ./debian/rules binary</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>dpkg-deb: building package `libcaenrfid0' in `../libcaenrfid0_0.91.0_armhf.deb'.</strong></span>
<span class="strong"><strong>dpkg-deb: building package `libcaenrfid-dev' in `../libcaenrfid-dev_0.91.0_armhf.deb'.</strong></span>
<span class="strong"><strong>root@beaglebone:~/libcaenrfid# dpkg -i ../libcaenrfid0_0.91.0_armhf.deb ../libcaenrfid-dev_0.91.0_armhf.deb</strong></span>
</pre></div><p>At this point, the <a id="id436" class="indexterm"/>needed libraries are in place, so we can compile our program to get access to the RFID UHF reader. A snippet of a possible implementation is as follows:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char *argv[])
{
   int i;
   struct caenrfid_handle handle;
   char string[] = "Source_0";
   struct caenrfid_tag *tag;
   size_t size;
   char *str;
   int ret;

   if (argc &lt; 2)
      usage();

      /* Start a new connection with the CAENRFIDD server */
      ret = caenrfid_open(CAENRFID_PORT_RS232, argv[1], &amp;handle);
      if (ret &lt; 0)
         usage();

      /* Set session "S2" for logical source 0 */
      ret = caenrfid_set_srcconf(&amp;handle, "Source_0",
         CAENRFID_SRC_CFG_G2_SESSION, 2);
      if (ret &lt; 0) {
         err("cannot set session 2 (err=%d)", ret);
         exit(EXIT_FAILURE);
      }

      while (1) {
         /* Do the inventory */
         ret = caenrfid_inventory(&amp;handle, string, &amp;tag, &amp;size);
         if (ret &lt; 0) {
            err("cannot get data (err=%d)", ret);
            exit(EXIT_FAILURE);
         }

         /* Report results */
         for (i = 0; i &lt; size; i++) {
            str = bin2hex(tag[i].id, tag[i].len);
            EXIT_ON(!str);

            info("%.*s %.*s %.*s %d",
               tag[i].len * 2, str,
               CAENRFID_SOURCE_NAME_LEN, tag[i].source,
               CAENRFID_READPOINT_NAME_LEN, tag[i].readpoint,
               tag[i].type);

            free(str);
         }

         /* Free inventory data */
         free(tag);
      }

      caenrfid_close(&amp;handle);

      return 0;
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note98"/>Note</h3><p>The complete code is stored in the <code class="literal">chapter_09/rfid_uhf/rfid_uhf.c</code> script in the book's example code repository.</p></div></div><p>The <a id="id437" class="indexterm"/>program simply uses the <code class="literal">caenrfid_open()</code> method to establish a connection with the reader and the <code class="literal">caenrfid_inventory()</code> method to detect the tags. The <code class="literal">caenrfid_set_srcconf()</code> method is used to set an internal special feature in order to avoid multiple readings of the same tag.</p><p>The program can be compiled with the <code class="literal">make</code> command, executed in the <code class="literal">rfid_uhf</code> directory, and the tool can be used as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/rfid_uhf# ./rfid_uhf /dev/ttyO2</strong></span>
</pre></div><p>The program answers with no output in case there are no tags near the reader's antenna, but if we approach some tags we get something as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~/chapter_09/rfid_uhf# ./rfid_uhf /dev/ttyO2</strong></span>
<span class="strong"><strong>rfid_uhf.c[ 110]: main: e280113020002021dda500ab Source_0 Ant0 3</strong></span>
</pre></div><p>Note that, in this case, and contrary to what happens in the RFID LF case, the reader can detect a tag even <a id="id438" class="indexterm"/>a few meters away (the distance depends on the antenna you're using!)</p></div><div class="section" title="The final picture"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec76"/>The final picture</h2></div></div></div><p>The following image<a id="id439" class="indexterm"/> shows the prototype I realized to implement this project and to test the software:</p><div class="mediaobject"><img src="graphics/B00255_09_05.jpg" alt="The final picture"/></div><p>Note that to use the RFID UHF reader, you must use an external power supply, while for the other two readers it is not needed.</p></div></div>
<div class="section" title="Setting up the software"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec52"/>Setting up the software</h1></div></div></div><p>After the <a id="id440" class="indexterm"/>hardware has been set up, most of the job is done; to finish our job, we need to first install a tool to get access to our Twitter account, and then we have to add a mechanism to call it each time a successful identification process is accomplished. So, in the following sections I'm going to show how to install and correctly set up a command line tool to communicate with Twitter and then how to call it in three different programming languages for three different identification systems.</p><p>To simplify the project a bit, we can use a static list of known IDs stored in each program, but you can understand that this list can be easily managed by an external database. So, I leave this implementation as an exercise for you.</p><div class="section" title="Setting up the Twitter utility"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec77"/>Setting up the Twitter utility</h2></div></div></div><p>The utility I'm<a id="id441" class="indexterm"/> going to use to get access to a Twitter account is named with the single character <code class="literal">t</code>. The <code class="literal">t</code> program, as reported on its home page, derives from the Twitter SMS commands:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>The CLI takes syntactic cues from the Twitter SMS commands, but it offers vastly more commands and capabilities than are available via SMS.</em></span></p></blockquote></div><p>In fact, once installed, it uses simple commands to update our Twitter status, follow/unfollow users, retrieve detailed information about a Twitter user, create a list for everyone you're following, and so on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note99"/>Note</h3><p>For a complete reference of<a id="id442" class="indexterm"/> the <code class="literal">t</code> tool, the <a class="ulink" href="https://github.com/sferik/t">https://github.com/sferik/t</a> URL is a good starting point.</p></div></div><p>To install this tool into our BeagleBone Black, we first need the <code class="literal">ruby-dev</code> package with the <code class="literal">aptitude</code> program:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# aptitude install ruby-dev</strong></span>
</pre></div><p>Then, <code class="literal">t</code> is installed with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# gem install t -V</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip121"/>Tip</h3><p>The execution of this command can be very slow! So, be patient and wait.</p></div></div><p>Once the installation has ended, we can execute the program, and if everything works well, a long list of available commands should be displayed as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# t -h</strong></span>
<span class="strong"><strong>Commands:</strong></span>
<span class="strong"><strong>  t accounts                          # List accounts</strong></span>
<span class="strong"><strong>  t authorize                         # Allows an application to request user...</strong></span>
<span class="strong"><strong>  t block USER [USER...]              # Block users.</strong></span>
<span class="strong"><strong>  t delete SUBCOMMAND ...ARGS         # Delete Tweets, Direct Messages, etc.</strong></span>
<span class="strong"><strong>  t direct_messages                   # Returns the 20 most recent Direct Mes...</strong></span>
<span class="strong"><strong>  t direct_messages_sent              # Returns the 20 most recent Direct Mes...</strong></span>
<span class="strong"><strong>  t dm USER MESSAGE                   # Sends that person a Direct Message.</strong></span>
<span class="strong"><strong>  t does_contain [USER/]LIST USER     # Find out whether a list contains a user.</strong></span>
<span class="strong"><strong>  t does_follow USER [USER]           # Find out whether one user follows ano...</strong></span>
<span class="strong"><strong>  ...</strong></span>
</pre></div><p>At this point, as<a id="id443" class="indexterm"/> done for other social networks, we have to create a special application for our Twitter account to get access to our data. To do so, let's<a id="id444" class="indexterm"/> point our browser to the <a class="ulink" href="https://apps.twitter.com/app/new">https://apps.twitter.com/app/new</a> URL. We'll see a form where we can fill out information about our new application. Simply fill in three fields: <span class="strong"><strong>Name</strong></span>, <span class="strong"><strong>Description</strong></span>, and <span class="strong"><strong>Website</strong></span>. Note that the name of the application needs to be unique across all Twitter users and cannot contain the word <code class="literal">twitter</code>, while the website can be arbitrary (for instance, <code class="literal">http://www.mydomain.com</code>), as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B00255_09_06.jpg" alt="Setting up the Twitter utility"/></div><p>Regarding the <a id="id445" class="indexterm"/>
<span class="strong"><strong>Callback URL</strong></span> field, you can leave it blank. Then, click on the checkbox for developer terms agreement at the bottom of the page and then click on the <span class="strong"><strong>Create your Twitter application</strong></span> button.</p><p>Once your application has been successfully created, you will see a page where you can manage your application settings, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B00255_09_07.jpg" alt="Setting up the Twitter utility"/></div><p>Now, go to the<a id="id446" class="indexterm"/> <span class="strong"><strong>Permissions</strong></span> tab and change <span class="strong"><strong>Access</strong></span> type to <span class="strong"><strong>Read, Write and Access direct messages</strong></span> and save.</p><p>The next step is to authorize your application to access your Twitter account. For that, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# t authorize</strong></span>
<span class="strong"><strong>Welcome! Before you can use t, you'll first need to register an</strong></span>
<span class="strong"><strong>application with Twitter. Just follow the steps below:</strong></span>
<span class="strong"><strong>  1. Sign in to the Twitter Application Management site and click</strong></span>
<span class="strong"><strong>     "Create New App".</strong></span>
<span class="strong"><strong>  2. Complete the required fields and submit the form.</strong></span>
<span class="strong"><strong>     Note: Your application must have a unique name.</strong></span>
<span class="strong"><strong>  3. Go to the Permissions tab of your application, and change the</strong></span>
<span class="strong"><strong>     Access setting to "Read, Write and Access direct messages".</strong></span>
<span class="strong"><strong>  4. Go to the API Keys tab to view the consumer key and secret,</strong></span>
<span class="strong"><strong>     which you'll need to copy and paste below when prompted.</strong></span>

<span class="strong"><strong>Press [Enter] to open the Twitter Developer site.</strong></span>
</pre></div><p>Then, once the <span class="emphasis"><em>Enter</em></span> <a id="id447" class="indexterm"/>key has been pressed, the following output is shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>xprop:  unable to open display ''</strong></span>
<span class="strong"><strong>xprop:  unable to open display ''</strong></span>
<span class="strong"><strong>Enter your API key: /usr/bin/xdg-open: 1: eval: www-browser: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: links2: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: elinks: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: links: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: lynx: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: w3m: not found</strong></span>
<span class="strong"><strong>xdg-open: no method available for opening 'https://apps.twitter.com'</strong></span>
</pre></div><p>Apart from the error messages due to the fact that <code class="literal">t</code> cannot execute any browser at all, we have to go to the <span class="strong"><strong>Keys and Access Token</strong></span> tab and enter the key in the <span class="strong"><strong>Consumer Key (API Key)</strong></span> field located under <span class="strong"><strong>Application Settings</strong></span>. Then, the tool will ask for the API secret, so you have to enter the <span class="strong"><strong>Consumer Secret (API Secret)</strong></span> in the same page as before.</p><div class="mediaobject"><img src="graphics/B00255_09_08.jpg" alt="Setting up the Twitter utility"/></div><p>When finished, if<a id="id448" class="indexterm"/> both the keys are valid, the tool will display the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>In a moment, you will be directed to the Twitter app authorization page.</strong></span>
<span class="strong"><strong>Perform the following steps to complete the authorization process:</strong></span>
<span class="strong"><strong>  1. Sign in to Twitter.</strong></span>
<span class="strong"><strong>  2. Press "Authorize app".</strong></span>
<span class="strong"><strong>  3. Copy and paste the supplied PIN below when prompted.</strong></span>

<span class="strong"><strong>Press [Enter] to open the Twitter app authorization page.</strong></span>
</pre></div><p>As before, the tool will try to open the browser again in order to show the Twitter application authorization page, but of course, it cannot, so the following error message is shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>xprop:  unable to open display ''</strong></span>
<span class="strong"><strong>xprop:  unable to open display ''</strong></span>
<span class="strong"><strong>Enter the supplied PIN: /usr/bin/xdg-open: 1: eval: www-browser: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: links2: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: elinks: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: links: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: lynx: not found</strong></span>
<span class="strong"><strong>/usr/bin/xdg-open: 1: eval: w3m: not found</strong></span>
<span class="strong"><strong>xdg-open: no method available for opening 'https://api.twitter.com/oauth/authorize?oauth_callback=oob&amp;oauth_consumer_key=sHSeFMEGPRqRyf9V0UB4LtQOg&amp;oauth_nonce=9T9rSHXiaSiWXkh0ksVE5ioTcop0srz7xMG92VhVI&amp;oauth_signature=oNWj1Lj%225BUmrFkD%252B065axJv6WSeM%253D&amp;oauth_signature_method=HMAC-SHA1&amp;oauth_timestamp=1443370645&amp;oauth_token=J2fp-gAAAAAAhyrAAABAUA-YNw8&amp;oauth_version=1.0'</strong></span>
</pre></div><p>Okay, we just need to<a id="id449" class="indexterm"/> <span class="emphasis"><em>copy and paste</em></span> the preceding URL into our browser on the host PC to finish the job. To be clear, the URL is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>https://api.twitter.com/oauth/authorize?oauth_callback=oob&amp;oauth_consumer_key=sHSeFMEGPRqRyf9V0UB4LtQOg&amp;oauth_nonce=9T9rSHXiaSiWXkh0ksVE5ioTcop0srz7xMG92VhVI&amp;oauth_signature=oNWj1Lj%225BUmrFkD%252B065axJv6WSeM%253D&amp;oauth_signature_method=HMAC-SHA1&amp;oauth_timestamp=1443370645&amp;oauth_token=J2fp-gAAAAAAhyrAAABAUA-YNw8&amp;oauth_version=1.0</strong></span>
</pre></div><p>Then, a new page where your Twitter credentials are to be put should appear, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B00255_09_09.jpg" alt="Setting up the Twitter utility"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip122"/>Tip</h3><p>Sorry for the Italian, but this is what my Twitter account's default language is set to.</p></div></div><p>Put your<a id="id450" class="indexterm"/> Twitter credentials and, if they are correct, the system should give you a PIN to be used to finish the authorization process (see the following screenshot):</p><div class="mediaobject"><img src="graphics/B00255_09_10.jpg" alt="Setting up the Twitter utility"/></div><p>Just <span class="emphasis"><em>copy and paste</em></span> the PIN into the terminal where the tool is running and press <span class="emphasis"><em>Enter</em></span> (again, you <a id="id451" class="indexterm"/>should not care about the error when launching the browser). However, if all steps are correct, the last message from <code class="literal">t</code> should be the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Authorization successful.</strong></span>
</pre></div><p>Great! Now, we are ready to do our first tweet from the BeagleBone Black's command line! The command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# t update 'Hello there! This is my first tweet from the command line!'</strong></span>
<span class="strong"><strong>Tweet posted by @RodolfoGiometti.</strong></span>

<span class="strong"><strong>Run `t delete status 648174339569897474` to delete.</strong></span>
</pre></div><p>The following screenshot shows a snippet of my Twitter account where the recently sent message is published:</p><div class="mediaobject"><img src="graphics/B00255_09_11.jpg" alt="Setting up the Twitter utility"/></div></div><div class="section" title="The smart card implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec78"/>The smart card implementation</h2></div></div></div><p>Let's now <a id="id452" class="indexterm"/>start with the first implementation of our identifying system by getting access to the smart card. The code is written in Python, and it shows a possible implementation of our access control system by using a smart card reader.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip123"/>Tip</h3><p>Note that implementation is very minimal since we limit our attention to the ATR parameter, which cannot be used to uniquely identify a smart card in all circumstances.</p></div></div><p>The program is very similar to the one stored in the <code class="literal">chapter_09/smart_card/smart_card.py</code> file, so I'm going to show only the relevant differences here:</p><div class="informalexample"><pre class="programlisting"># The known IDs
ID2NAME = {
        '11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11': "user1",
        '22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22': "user2",
        '3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00': 'Rodolfo Giometti'
}
...
#
# Smart Card Observer
#

class printobserver(CardObserver):
   def update(self, observable, (addedcards, removedcards)):
      for card in addedcards:
         try:
            id = toHexString(card.atr)
         except:
            pass
         if len(id) == 0:
            continue
         logging.info("got tag ID " + id)

         # Verify that the tag ID is known and then
         # tweet the event
         try:
            name = ID2NAME[id]
        except:
           logging.info("unknow tag ID! Ignored")
           continue
 
        logging.info("Twitting that " + name + " was arrived!")
        call([t_cmd, t_args, name + " was arrived!"])</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note100"/>Note</h3><p>The complete code is stored in the <code class="literal">chapter_09/smart_card/smart_card2twitter.py</code> script in the book's example code repository.</p></div></div><p>The <code class="literal">ID2NAME</code>
<a id="id453" class="indexterm"/> array holds a list of known IDs, that is, our <span class="emphasis"><em>database</em></span> of valid IDs that are associated with well-known people. It's easy here to imagine that using a real database would be a better implementation, but this solution is fine for our teaching purposes.</p><p>The <code class="literal">update()</code> method extracts the smart card's ATR field, and then, instead of simply printing it, it compares the current ID with our internal database, and in case of positive match, it calls the <code class="literal">t</code> tool in order to update the Twitter account.</p></div><div class="section" title="The RFID LF implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec79"/>The RFID LF implementation</h2></div></div></div><p>As in the preceding <a id="id454" class="indexterm"/>example, we have to modify the <code class="literal">chapter_09/rfid_lf/rfid_lf.sh</code> <span class="strong"><strong>Bash</strong></span> script<a id="id455" class="indexterm"/> a bit in order to call the <code class="literal">t</code> tool if the current tag ID is found in the list of the known IDs held by the <code class="literal">ID2NAME</code> array. A snippet of the modified code is as follows:</p><div class="informalexample"><pre class="programlisting"># The known IDs
declare -gA 'ID2NAME=(
   [111111111111]="user1",
   [222222222222]="user2"
   [6F007F4E1E40]="Rodolfo Giometti"
)'
…
# Read the tags' IDs
cat $dev | while read id ; do
   # Remove the non printable characters
   id=$(echo $id | tr -cd '[:alnum:]')
   info "got tag ID $id"

   # Verify that the tag ID is known and then tweet the event
   name=${ID2NAME[$id]}
   if [ -z "$name" ] ; then
      info "unknow tag ID! Ignored"
   else
      info "Twitting that $name was arrived!"
      $t_cmd $t_args "$name was arrived!"
   fi
done</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note101"/>Note</h3><p>The <a id="id456" class="indexterm"/>complete code is stored in the <code class="literal">chapter_09/rfid_lf/rfid_lf2twitter.sh</code> script in the book's example code repository.</p></div></div></div><div class="section" title="The RFID UHF implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec80"/>The RFID UHF implementation</h2></div></div></div><p>The last implementation<a id="id457" class="indexterm"/> is in C<span class="strong"><strong>,</strong></span> and it uses the RFID UHF reader in order to take the identification string. The trick is now well-known; we simply need to modify the <code class="literal">chapter_09/rfid_uhf/rfid_uhf.c</code> program in order to check the current tag ID with the known ones held again in the well-known<code class="literal"> ID2NAME</code> array. The code snippet is as follows:</p><div class="informalexample"><pre class="programlisting">/* The known IDs */
struct associative_array_s {
   char *id;
   char *name;
} ID2NAME[] = {
   { "111111111111111111111111", "user1" },
   { "222222222222222222222222", "user2" },
   { "e280113020002021dda500ab", "Rodolfo Giometti" },
};
...
   /* The main loop */
   while (1) {
      /* Do the inventory */
      ret = caenrfid_inventory(&amp;handle, string, &amp;tag, &amp;size);
      if (ret &lt; 0) {
         err("cannot get data (err=%d)", ret);
         exit(EXIT_FAILURE);
      }

      /* Report results */
      for (i = 0; i &lt; size; i++) {
         str = bin2hex(tag[i].id, tag[i].len);
         EXIT_ON(!str);
         info("got tag ID %.*s", tag[i].len * 2, str);

         for (j = 0; j &lt; ARRAY_SIZE(ID2NAME); j++)
            if (strncmp(str, ID2NAME[j].id,
               tag[i].len * 2) == 0)
            break;
         if (j &lt; ARRAY_SIZE(ID2NAME)) {
            info("Twitting that %s was arrived!",
               ID2NAME[j].name);
            ret = asprintf(&amp;cmd, "%s %s %s was arrived!", t_cmd, t_arg, ID2NAME[j].name);
            EXIT_ON(ret &lt; 1);
            ret = system(cmd);
            EXIT_ON(ret &lt; 0);
            free(cmd);
         } else
         info("unknow tag ID! Ignored");

         free(str);
   }

   /* Free inventory data */
   free(tag);
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note102"/>Note</h3><p>The complete code is stored in the <code class="literal">chapter_09/rfid_uhf/rfid_uhf2twitter.c</code> file in the book's example code repository.</p></div></div><p>Before <a id="id458" class="indexterm"/>executing it, don't forget to compile it!</p></div></div>
<div class="section" title="Final test"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Final test</h1></div></div></div><p>To test our <a id="id459" class="indexterm"/>prototype, we have to run the three different programs presented in the preceding section. As in the previous chapters, I first executed the <code class="literal">chapter_09/SYSINIT.sh</code> file in the book's example code repository as usual to set up all peripherals:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@beaglebone:~# ./SYSINIT.sh</strong></span>
<span class="strong"><strong>done!</strong></span>
</pre></div><p>Then, let's start the smart card program and insert the smartcard as follows:</p><div class="informalexample"><pre class="programlisting">root@beaglebone:~/smart_card# ./smart_card2twitter.py
INFO:root:got tag ID 3B BE 11 00 00 41 01 38 00 00 00 00 00 00 00 00 01 90 00
INFO:root:Twitting that Rodolfo Giometti was arrived!
Tweet posted by @RodolfoGiometti.

Run `t delete status 649586168313552896` to delete.</pre></div><p>Now, press the <span class="emphasis"><em>CTRL</em></span> + <span class="emphasis"><em>C</em></span> keys to stop the program, and let's try the RFID LF program as follows by approaching the relative tag:</p><div class="informalexample"><pre class="programlisting">root@beaglebone:~/rfid_lf# ./rfid_lf2twitter.sh /dev/ttyO1
rfid_lf2twitter.sh: got tag ID 6F007F4E1E40
rfid_lf2twitter.sh: Twitting that Rodolfo Giometti was arrived!
Tweet posted by @RodolfoGiometti.

Run `t delete status 649586168313552896` to delete.</pre></div><p>Again, stop the <a id="id460" class="indexterm"/>program with the <span class="emphasis"><em>CTRL</em></span> + <span class="emphasis"><em>C</em></span> keys, and let's test the last program as follows by approaching the relative tag again:</p><div class="informalexample"><pre class="programlisting">root@beaglebone:~/rfid_uhf# ./rfid_uhf2twitter /dev/ttyO2
rfid_uhf2twitter.c[ 122]: main: Twitting that Rodolfo Giometti was arrived!
Tweet posted by @RodolfoGiometti.

Run `t delete status 649586168313552896` to delete.</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec54"/>Summary</h1></div></div></div><p>In this chapter, we discovered how to publish a message to a Twitter account and three different ways to identify people or objects by using different identification technologies and programming languages.</p><p>In the next chapter, we'll discover how to manage some lights by using a common remote controller (or any infrared capable device). We'll see how our BeagleBone Black board can receive some commands by using our TV remote.</p></div></body></html>