<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 1</h1>
                </header>
            
            <article>
                
<ol>
<li><span>The error is in the second line: There should be no spaces in the variable declaration.</span></li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
var1="Welcome to bash scripting ..." 
echo $var1 </pre>
<ol start="2">
<li>The result will be <kbd>Tuesday</kbd> because the array is zero based.</li>
<li>There are two errors here: the first error is the space in the variable declaration and the second error is the usage of single quotes where we should use backticks instead.</li>
</ol>
<p style="padding-left: 60px">Solution:</p>
<pre style="padding-left: 60px">#!/bin/bash files='ls -la' echo $files</pre>
<ol start="4">
<li>The value of<span> </span><kbd>b</kbd><span> </span>variable will be<span> </span><kbd>c</kbd><span> </span>and the value of<span> </span><kbd>c</kbd><span> </span>will be<span> </span><kbd>a</kbd>.</li>
</ol>
<p style="padding-left: 60px">Since we didn't use dollar signs in the assignment lines, the variable will take the character value instead of the integer value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 2</h1>
                </header>
            
            <article>
                
<ol>
<li>Three</li>
</ol>
<p style="padding-left: 60px">This is because the whole bash shebang is primarily a comment, so there are three lines of comment.</p>
<ol start="2">
<li>There is no space between the option<span> </span><kbd>-b</kbd><span> </span>and its value, so it will be treated as an option.</li>
</ol>
<pre style="padding-left: 60px">-a<br/>-b50<br/>-c</pre>
<ol start="3">
<li>1</li>
</ol>
<p style="padding-left: 60px">Four</p>
<p style="padding-left: 60px">This is because we have five passed parameters and we use the shift to drop a parameter.</p>
<ol start="4">
<li>2</li>
</ol>
<p style="padding-left: 60px"><kbd>-n</kbd></p>
<p style="padding-left: 60px">This is because it's on the left and the<span> </span><kbd>shift</kbd><span> </span>command drops parameters from the left.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 3</h1>
                </header>
            
            <article>
                
<ol>
<li><span> </span><kbd>False</kbd></li>
</ol>
<p style="padding-left: 60px">Since lower-case characters have a higher ASCII order, the statement will return<span> </span><kbd>False</kbd>.</p>
<ol start="2">
<li>Both are correct and will return the same result, which is <kbd>Strings</kbd> are not identical.</li>
<li><kbd>Three</kbd></li>
</ol>
<p style="padding-left: 60px">We can use the following:</p>
<ul>
<li><kbd>-ge</kbd>: Greater than or equal to</li>
<li><kbd>-gt</kbd><span>: Greater than</span></li>
<li><kbd>-ne</kbd><span>: Not equal to</span></li>
</ul>
<ol start="4">
<li>True</li>
</ol>
<p style="padding-left: 60px">Since one test is enough to return true, so we can be sure that the second test will return true.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 4</h1>
                </header>
            
            <article>
                
<ol>
<li>We can make the following changes :</li>
</ol>
<pre style="padding-left: 60px">"Hello message": {<br/>    "prefix": "hello",<br/>    "body": [<br/>      "echo 'Hello ${1|first,second,third|}' "<br/>    ],<br/>    "description": "Hello message"<br/>  }</pre>
<ol start="2">
<li>The <kbd>source</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 5</h1>
                </header>
            
            <article>
                
<ol>
<li>By using<span> </span><kbd>((</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash<br/>num=$(( 25 - 8 ))<br/>echo $num</pre>
<ol start="2">
<li>The problem is with the space in the filename. To fix it, put the filename between quotes:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ rm "my file"</strong></pre>
<ol start="3">
<li>There is no dollar sign before the parentheses:</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong><br/><strong>a=$(( 8 + 4 ))</strong><br/><strong>echo $a</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 6</h1>
                </header>
            
            <article>
                
<ol>
<li><span>No lines. Since the loop output is redirected to a file, nothing will appear on the screen.</span></li>
<li>Four. The loop will start at <kbd>8</kbd><span> and continue until it reaches </span><kbd>12</kbd><span>, it will match the condition which is greater than or equal, and it will break the loop.</span></li>
</ol>
<ol start="3">
<li>The problem is with the comma in the<span> </span><kbd>for</kbd><span> </span><span>loop definition. It should be semicolon instead. So the correct script should be as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash 
for (( v=1; v &lt;= 10; v++ )) 
do 
echo "value is $v" 
done</strong> </pre>
<ol start="4">
<li>Since the decrement statement is outside the loop, the count variable will be the same value, which is <kbd>10</kbd>. It's an endless loop, it will print <kbd>10</kbd> forever, and to stop it, you need to press<em> Ctrl </em>+ <em>C</em>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 7</h1>
                </header>
            
            <article>
                
<ol>
<li><span>Since we used the </span><kbd>$1</kbd><span> variable not </span><kbd>$@</kbd><span>, the function will return the first element only.</span></li>
<li><kbd>50</kbd><span>. Yes, it's a global variable, but because we printed the value before the function call, the variable isn't affected.</span></li>
<li>Missing brackets <kbd>()</kbd><span> </span><span>or adding the keyword function before the function name. It should be written like this:</span></li>
</ol>
<pre style="padding-left: 60px">clean_file() { 
    is_file "$1" 
    BEFORE=$(wc -l "$1") 
    echo "The file $1 starts with $BEFORE" 
    sed -i.bak '/^\s*#/d;/^$/d' "$1" 
    AFTER=$(wc -l "$1") 
    echo "The file $1 is now $AFTER" 
} </pre>
<ol start="4">
<li>The problem is in the function call. We shouldn't use brackets<span> </span><kbd>()</kbd><span> </span>during a function call. Brackets should <span>only</span><span> be used in function definitions. </span>The correct code will be like this:</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
myfunc() { 
arr=$@ 
echo "The array from inside the function: ${arr[*]}" 
}</pre>
<pre style="padding-left: 60px">test_arr=(1 2 3) 
echo "The origianl array is: ${test_arr[*]}" 
myfunc ${test_arr[*]} 
 </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 8</h1>
                </header>
            
            <article>
                
<ol>
<li>None. Because you are searching for Sed with a capital letter which does not exist</li>
<li>None. The delete command <kbd>d</kbd><span> </span><span>only </span><span>deletes lines from the stream, not the file. To delete from the file, you can use the <kbd>-i</kbd> option.</span></li>
<li>Fourth line. Because we used append command <span class="packt_screen">a</span><span>, it will be inserted after the specified position.</span></li>
<li>None, because the <kbd>w</kbd><span> flag is </span><span>only </span><span>used with the substitute command</span><span> </span><kbd>s</kbd><span>.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 9</h1>
                </header>
            
            <article>
                
<ol>
<li>You can use the following command to print line number 50:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sed -n '50 p ' /etc/httpd/conf/httpd.conf</strong>  </pre>
<ol start="2">
<li>You can use following command to change Apache default port <kbd>80</kbd> to <kbd>8080</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sed -i '0,/Listen [0-9]*/s//Listen 8080/' /etc/httpd/conf/httpd.conf</strong>  </pre>
<p style="padding-left: 60px">We search for<span> </span><kbd>Listen</kbd>, where it defines the Apache default port, search for the number beside it, and change it to<span> </span><kbd>Listen 8080</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 10</h1>
                </header>
            
            <article>
                
<ol>
<li>Nothing</li>
</ol>
<p style="padding-left: 60px">You should use the variable name without the dollar sign to print it.</p>
<ol start="2">
<li>Solution: zero</li>
</ol>
<p style="padding-left: 60px">Because you should print<span> </span><kbd>$1</kbd><span> </span>instead of<span> </span><kbd>$2</kbd><span> </span>where<span> </span><kbd>$1</kbd><span> </span>is the first field.</p>
<ol start="3">
<li>The <kbd>while</kbd> loop should iterate with <kbd>i</kbd> value less than <kbd>4</kbd> not <kbd>3</kbd>.</li>
<li><kbd>1</kbd></li>
</ol>
<p style="padding-left: 60px">Because the only user that has UID less than<span> </span><kbd>1</kbd><span> </span>is root (<kbd>UID=0</kbd>), so one line will be printed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 11</h1>
                </header>
            
            <article>
                
<ol>
<li>0 lines</li>
</ol>
<p class="NormalPACKT" style="padding-left: 60px">Because there is a period after the word<span> </span><kbd>awesome</kbd>, if you want to print that line, you can use the following command:</p>
<pre class="NormalPACKT" style="padding-left: 60px"><strong><span class="CodeHighlightedPACKT"><span>$ awk '/awesome\.$/{print $0}' myfile<br/></span></span></strong></pre>
<ol start="2">
<li class="NormalPACKT">2 lines</li>
</ol>
<p class="NormalPACKT" style="padding-left: 60px">Since we search for the line that contains the word<span> </span><kbd>scripting</kbd>. With a period after it followed by any text, this pattern only exists in two lines because the third line doesn't contain a period after the word.</p>
<ol start="3">
<li>3 lines</li>
</ol>
<p style="padding-left: 60px">As we used the question mark that means the character class is not a must for the pattern to match.</p>
<ol start="4">
<li class="NormalPACKT">Nothing</li>
</ol>
<p class="NormalPACKT" style="padding-left: 60px">As we used the pipe symbol, which is an ERE character, and as we used sed, we must use the <kbd>-r</kbd><span> </span>option for sed to turn the extended engine on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 12</h1>
                </header>
            
            <article>
                
<ol>
<li>F<span>ield 1</span></li>
<li>You can use<span> </span><kbd>print NR</kbd><span> </span><span>or alternatively pipe the output to</span><span> </span><kbd>wc -l</kbd></li>
</ol>
<p style="padding-left: 60px">We must use<span> </span><kbd>-l</kbd><span> </span>otherwise, it will count words instead.</p>
<ol start="3"/>
<pre style="padding-left: 60px"><strong>$ awk '{print $1}' access.log | sort | uniq -c</strong></pre>
<ol start="4"/>
<pre style="padding-left: 60px"><strong>$ awk '{print $7}' access.log | grep 'php' | sort | uniq -c | sort -nr | head -n 1</strong> </pre>
<p style="padding-left: 60px">You should use head<span> </span><kbd>-n 1</kbd><span> </span>to get the one page only.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 13</h1>
                </header>
            
            <article>
                
<ol>
<li>Use the <kbd>lastlog</kbd><span> </span>command</li>
</ol>
<pre style="padding-left: 60px"><strong>$ lastlog | awk ' /Never logged/ { print $1}'</strong></pre>
<ol start="2">
<li>Use the <kbd>wc</kbd><span> </span>command</li>
</ol>
<pre style="padding-left: 60px"><strong>$ lastlog | awk ' /Never logged/ { print $1}' | wc -l</strong></pre>
<ol start="3">
<li>Zero. Because the line ends with two asterisks.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 14</h1>
                </header>
            
            <article>
                
<ol>
<li><span>8</span></li>
<li>Since we are using the<span> </span><kbd>sys</kbd><span> </span><span>module, we should import it first.</span></li>
</ol>
<p style="padding-left: 60px">So the correct code should look like this:</p>
<pre style="padding-left: 60px">#!/usr/bin/python3<br/>import sys<br/>print( len(sys.argv))</pre>
<ol start="3">
<li>2</li>
</ol>


            </article>

            
        </section>
    </body></html>