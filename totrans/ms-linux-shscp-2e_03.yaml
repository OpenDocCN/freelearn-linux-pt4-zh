- en: Conditions Attached
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you can make your scripts more interactive using the `read` command, and
    you know how to read parameters and options to lighten your inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that we are now into the fine print of the script. These are the
    details that are written into our scripts using conditions to test if a statement
    should run or not. We are now ready to add some intelligence into our scripts,
    so our scripts become more robust, easier to use, and more reliable. Conditional
    statements can be written with simple command-line lists of `AND` or `OR` commands
    together, or, more often, within traditional `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple decision paths using command-line lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying user input with lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the test shell built-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating conditional statements using `if`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending `if` with `else`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `test` command with the `if` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More conditions with `elif`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using case statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recipe-frontend with `grep`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter03)'
  prefs: []
  type: TYPE_NORMAL
- en: Simple decision paths using command-line lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used command-line lists (`||` and `&&`), both in [Chapter 1](f439f212-0f5f-4c9d-abdb-9f9b8c199a78.xhtml),
    *The What and Why of Scripting with Bash*, and in some of the scripts found in
    [Chapter 2](10a24eea-2218-44cc-a019-e01ee63ad77c.xhtml), *Creating Interactive
    Scripts*. Lists are one of the simplest conditional statements that we can create,
    and so we thought that it was appropriate to use them in the earlier examples
    before fully explaining them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-line lists are two or more statements that are joined using either
    the `AND` or `OR` notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`&&`: `AND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`||`: `OR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the two statements are joined using the `AND` notation, the second command
    only runs if the first command succeeds. Whereas, with the `OR` notation, the
    second command will run only if the first command fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decision on the success or failure of a command is taken by reading the
    exit code from the application. A zero represents a successful application completion
    and anything other than a zero represents a failure. We can test the success or
    failure of an application by reading the exit status by means of the system variables
    `$?`. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to ensure that a script is run from a user''s home directory, we
    can build this into the script''s logic. This can be tested from the command line,
    and it does not have to be in a script. Consider the following command-line example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The double vertical bars denote an `OR` Boolean. This ensures that the second
    statement is only executed when the first statement is not true. In simple terms,
    if we are not currently in the home directory, we will be by the end of the command-line
    list. We will see more on the `test` command soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build this into almost any command that we want and not just test. For
    example, we can query to see if a user is logged into the system, and if they
    are, then we can use the `write` command to directly message their console. Similar
    to before, we can test this in the command line prior to adding it to the script.
    This is shown in the following command-line example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that you should change the user `pi` to your username.
  prefs: []
  type: TYPE_NORMAL
- en: If we use this in a script, it is almost certain that we will replace the username
    with a variable. In general, if we need to refer to the same value more than once,
    then using a variable is a good idea. In this case, we are searching for the `pi`
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we break the command-line list down, we first use the `who` command to
    list the users who are logged on. We pipe the list to `grep` to search for the
    desired username. We are not interested in the output from the search, just its
    success or failure. Bearing this in mind, we redirect all our output to `/dev/null`.
    The double ampersand indicates that the second statement in the list runs only
    if the first returns true. If the `pi` user is logged on, we use `write` to message
    the user. The following screenshot illustrates this command and the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0889d658-e55d-450c-8eb6-d2a47ddcaa43.png)'
  prefs: []
  type: TYPE_IMG
- en: Verifying user input with lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this script, we will ensure that a value has been supplied to the first positional
    parameter. We can modify the `hello2.sh` script that we created in [Chapter 1](f439f212-0f5f-4c9d-abdb-9f9b8c199a78.xhtml),
    *The What and Why of Scripting with Bash*, to check for user input before displaying
    the `hello` text.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy the `hello2.sh` script to `hello4.sh`, or simply create a new
    script from scratch. There will not be a lot of typing and the script will be
    created as `$HOME/bin/hello4.sh`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77473c24-d9fd-4e35-a31c-6cf514493b5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can ensure that the script is executable by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can then run the script with or without arguments. The `test` statement is
    looking for the `$1` variable to be zero bytes. If it is, then we will not see
    the `hello` statement; otherwise, it will print the `hello` message. In simple
    terms, we will see the `hello` message if we supply a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output that you will see when you do not
    supply a parameter to the script, followed by the supplied parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e94c738c-682b-47ca-8375-ac40a123dd45.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the test shell built-in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is probably time for us to pull over to the side of the scripting highway
    and look a little more at the command `test`. This is both a shell built-in and
    a file executable in its own right. Of course, we will have to hit the built-in
    command first, unless we specify the full path to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `test` command is run without any expressions to evaluate, then the
    test will return false. So, if we run the `test` as shown in the following command,
    the exit status will be `1`, even though no error output is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test` command will always return either `True` or `False`, or `0` or `1`,
    respectively. The basic syntax of `test` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can invert the `test` command with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to include multiple expressions, this can be done using `AND` or
    `OR` together, using the `-a` and `-o` options, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write this as a shorthand version, replacing the `test` with square
    brackets to surround the expression, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Testing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can test for the equality or inequality of two strings. For example, one
    of the ways to test the root user is using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also write this using the square bracket notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that you must put a space between each bracket and the inner testing condition
    as previously shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equally, we could test for a non-root account with the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can also test for the zero values or non-zero values of strings. We saw this
    in an earlier example in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test if a string has a value, we can use the `-n` option. We can check to
    see if the current connection is made through SSH by checking for the existence
    of a variable in the user''s environment. We do this by using `test` and square
    brackets in the following two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If this is true, then the connection is made with SSH; if it is false, then
    the connection is not through SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw earlier, testing for a zero string value is useful when deciding
    if a variable is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more simply, we could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A true result for this query means that no input parameters have been supplied
    to the script.
  prefs: []
  type: TYPE_NORMAL
- en: Testing integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as testing string values of bash scripts, we can test for integer values
    and whole numbers. Another way of testing the input of a script is to count the
    numbers of positional parameters and also test if the number is above `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or using the brackets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When in a relationship, the top positional parameters of the `$#` variable represent
    the number of parameters passed to the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many tests that can be done for numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`number1 -eq number2`: This checks if `number1` is equal to `number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number1 -ge number2`: This checks if `number1` is greater than or equal to
    `number2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number1 -gt number2`: This checks if `number1` is greater than `number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number1 -le number2`: This checks if `number1` is smaller than or equal to
    `number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number1 -lt number2`: This checks if `number1` is smaller than `number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number1 -ne number2`: This checks if `number1` is not equal to `number2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing file types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While testing for values, we can test for the existence of a file or file type.
    For example, we may only want to delete a file if it is a symbolic link. We use
    this while compiling a kernel. The `/usr/src/linux` directory should be a symbolic
    link to the latest kernel source code. If we download a newer version before compiling
    the new kernel, we need to delete the existing link and create a new link. Just
    in case someone has created the `/usr/src/linux` directory, we can test if it
    has a link before removing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-h` option tests that the file has a link. Other options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`: This shows that it''s a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e`: This shows that the file exists in any form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x`: This shows that the file is executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: This shows that the file is a regular file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This shows that the file is readable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p`: This shows that the file is a named pipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b`: This shows that the file is a block device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file1 -nt file2`: This checks if `file1` is newer than `file2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file1 -ot file2`: This checks if `file1` is older than `file2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-O file`: This checks if the logged-in user is the owner of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c`: This shows that the file is a character device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More options do exist, so delve into the main pages as you need to. We will
    use different options throughout the book, and thus giving you practical and useful
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Creating conditional statements using if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, it is possible to build simple conditions using command-line
    lists. These conditional statements can be written both with and without a test.
    As the complexity of the tasks increases, it becomes easier to create statements
    using `if`. This will certainly ease both the readability of the script and the
    logic layout. To a degree, it also matches the way in which we think and speak;
    `if` is a semantic in our spoken language in the same way it is within the bash
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though it will take up more than a single line in the script, with an
    `if` statement we can achieve more and make the script more legible. That being
    said, let''s look at creating `if` conditions. The following is an example of
    a script using an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code within the `if` statement will run only when the condition evaluates
    to true, and the end of the `if` block is denoted with `fi` - `if` backward. The
    color coding in `vim` can be useful to aid readability, which you will see in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3c54fe4-dc6f-47c5-b4cf-70fd7e8ec78b.png)'
  prefs: []
  type: TYPE_IMG
- en: Within the script, we can easily add in multiple statements to run when the
    condition is `true`. In our case, this includes exiting the script with an error
    indicated, as well as including the `usage` statement to assist the user. This
    ensures that we only display the `hello` message if we have supplied a name of
    the person to be welcomed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the script execution both with and without the argument in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f8039a1-0737-44e3-afff-0e749ba74e1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following pseudocode shows the syntax of the `if` conditional statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Indenting the code is not required, but it helps readability and is highly recommended.
    Adding the `then` statement to the same line as the `if` statement, again assists
    with the readability of the code, and the semicolon is required to separate the
    `if` from the `then`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending if with else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a script is required to continue regardless of the result of the `if`
    condition, it is often necessary to deal with both conditions of the evaluation,
    what to do when it is `true` as well as `false`. This is where we can make use
    of the `else` keyword. This allows the execution of one block of code when the
    condition is true and another when the condition is evaluated as false. The pseudocode
    for this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we consider extending the `hello5.sh` script that we created earlier, it
    is easily possible to allow for the correct execution, regardless of the parameter
    being present or not. We can recreate this as `hello6.sh`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The script now sets a named variable, which helps readability, and we can assign
    the correct value to `$name` from the input parameter or from the `read` prompt;
    either way the script is working well and starting to take shape.
  prefs: []
  type: TYPE_NORMAL
- en: Test command with the if command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how to use the `test` command or the short version `[ ]`. This
    test returns zero (true) or non-zero (false).
  prefs: []
  type: TYPE_NORMAL
- en: You will see how to check the returned result using the `if` command.
  prefs: []
  type: TYPE_NORMAL
- en: Checking strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `if` command with the `test` command to check if the string
    matches a specific criterion:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if [$string1 = $string2]`: This checks if `string1` is identical to `string2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if [$string1 != $string2]`: This checks if `string1` is not identical to `string2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if [$string1 \< $string2]`: This checks if `string1` is less than `string2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if [$string1 \> $string2]`: This checks if `string1` is greater than `string2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The less than and greater than should be escaped with a backslash as if it shows
    a warning.
  prefs: []
  type: TYPE_NORMAL
- en: '`if [-n $string1]`: This checks if `string1` is longer than zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if [-z $string1]`: This checks if `string1` has zero length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see some examples to explain how `if` statements work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/74dbf900-d13c-41cf-a80c-4e18abd68a4a.png)'
  prefs: []
  type: TYPE_IMG
- en: This `if` statement checks if strings are identical or not; since the strings
    are not identical, because one of them has a capital letter, they are identified
    as not identical.
  prefs: []
  type: TYPE_NORMAL
- en: Note the space between the square brackets and the variables; without this space
    it will show a warning in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The not-equal operator (`!=`) works the same way. Also, you can negate the
    `if` statement and it will work the same way, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The less-than and greater-than operators check if the first string is greater
    than or less than the second string from the ASCII-order perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ff88ad5f-cd5f-4136-be1d-75c2fd803432.png)'
  prefs: []
  type: TYPE_IMG
- en: In the ASCII order, the lower-case characters are higher than the upper case.
  prefs: []
  type: TYPE_NORMAL
- en: Don't get confused if you use the `sort` command to sort a file or similar,
    and find that the sorting order works the opposite way to the `test` command.
    This is because the `sort` command uses the numbering order from the system settings,
    which is the opposite to the ASCII order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the string length, you can use the `-n` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/11a536ac-c91c-40a0-999a-b510d4ae52fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To check for a length of zero, you can use the `-z` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3883875a-03ce-4aa8-886f-86a9e8bf9e4c.png)'
  prefs: []
  type: TYPE_IMG
- en: We have used quotes around the tested strings, even though our string has no
    spaces.
  prefs: []
  type: TYPE_NORMAL
- en: In case you have a string with spaces, you **MUST** use quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Checking files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly, you can check files and directories using the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We used the `-d` test to check if the path is a directory.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the tests work the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Checking numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also, in the same way, we can check numbers using the `test` and the `if` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/1067d6cb-c22a-4133-94a4-7bccbe1c20a2.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, `12` is greater than `10`.
  prefs: []
  type: TYPE_NORMAL
- en: All other numeric tests work the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Combining tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can combine multiple tests and check them using one `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done using the `AND` (`&&`) and `OR` (`||`) commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f63859d4-b6fb-4942-b9fc-06966967efab.png)'
  prefs: []
  type: TYPE_IMG
- en: The `if` statement performs two checks, it checks if the directory exists and
    that the name is not of zero length.
  prefs: []
  type: TYPE_NORMAL
- en: The two tests must return success (zero) to evaluate the next `echo` command.
  prefs: []
  type: TYPE_NORMAL
- en: If one of them fails, the `if` statement goes to the `else` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `OR` (`||`) command, if any of the tests returns success (zero),
    the `if` statement succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0d829e61-aeed-48c1-8224-2a5902974186.png)'
  prefs: []
  type: TYPE_IMG
- en: It is clear enough that if one of the tests returns true, the `if` statement
    returns true for the combined tests.
  prefs: []
  type: TYPE_NORMAL
- en: More conditions with elif
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving on to where we require a greater degree of control, we can use the `elif`
    keyword. Unlike `else`, `elif` requires an additional condition to be tested for
    each `elif`. In this way, we can provide for different circumstances. We can add
    in as many `elif` conditions as required. The following shows some pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A script may make life easier for the operator by providing a simplified selection
    for a more complex piece of code. Even though the script becomes gradually more
    complex to meet the requirements, to the operator the execution is greatly simplified.
    It is our job to enable users to run more complex operations easily from the command
    line when creating scripts. Often, this will necessitate the addition of more
    complexity to our scripts; however, we will be rewarded with the reliability of
    the scripted application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the backup2.sh using elif
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can revisit the script that we created to run the earlier backup. This script,
    `$HOME/bin/backup.sh`, prompts the user for the file type and the directory in
    which to store the backup. The tools used for the backup are `find` and `cp`.
  prefs: []
  type: TYPE_NORMAL
- en: With this new-found knowledge, we can now allow the script to run the backup
    using the command `tar` and the level of compression selected by the operator.
    There is no requirement to select the file type, as the complete home directory
    will be backed up, with the exclusion of the backup directory itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator can select the compression based on three letters: `H`, `M`, and
    `L`. The selection will affect the options passed to the `tar` command and the
    backup file created. The selection of high uses `bzip2` compression, medium uses
    `gzip` compression, and low creates an uncompressed `tar` archive. The logic exists
    in the extended `if` statement that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the user selection, we can configure the correct options for the `tar`
    command. As we have three conditions to evaluate, the `if`, `elif`, and `else`
    statements are appropriate. To see how the variables are configured we can look
    at the following extract from the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete script can be created as `$HOME/bin/backup2.sh` and should comprise
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the script, we need to select `H`, `M`, or `L` in upper case,
    as this is how the selection is made within the script. The following screenshot
    shows the initial script execution, where the selection for `M` has been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5db19093-f5be-42e5-9e7f-8d31490c4835.png)'
  prefs: []
  type: TYPE_IMG
- en: Using case statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than using multiple `elif` statements, a `case` statement may provide
    a simpler mechanism when evaluations are made on a single expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic layout of a `case` statement is listed as follows, using pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The statement layout that we see is not dissimilar to the `switch` statements
    that exist in other languages. In bash, we can use the `case` statement to test
    for simple values, such as strings or integers. Case statements can cater for
    a wide range of letters, such as `[a-f]` or `a` through to `f`, but they cannot
    easily deal with integer ranges such as `[1-20]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `case` statement will first expand the expression and then it will try to
    match it with each item in turn. When a match is found, all the statements are
    executed until the `;;`. This indicates the end of the code for that match. If
    there is no match, the case `else` statement indicated by the `*` will be matched.
    This needs to be the last item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following script `grade.sh`, which is used to evaluate grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The script first uses an `if` statement to check that exactly two arguments
    have been supplied to the script. If they are not supplied, the script will exit
    with an error state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Then we use parameter expansion for the value of the `$2` variable to capitalize
    the input using `^^`. This represents the grade that we supply. Since we are capitalizing
    the input, we first try to match against the letters `A` through to `C`.
  prefs: []
  type: TYPE_NORMAL
- en: We make similar tests for the other supplied grades, `E` through to `F`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the script execution with different grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8e5aec7-d0e4-4654-930d-65d27d51e8fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Recipe – building a frontend with grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a finale to this chapter, we will group a few features that we have learned
    together and build a script that prompts the operator for a filename, a search
    string, and an operation to carry out with the `grep` command. We will create
    the script as `$HOME/bin/search.sh`, and don''t forget to make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by checking for exactly three input arguments using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The next check uses a command-line list to exit the script if the file argument
    is not a regular file, using `test -f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `case` statement allows for three operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Counting the matching lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the matching lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing all but the matching lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the search of the `/etc/ntp.conf` file for lines
    beginning with the string server. We choose the count option in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0138fe56-7b1e-4b12-b8fc-3740b01bfca0.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important and time-consuming tasks in scripting is building
    all of the conditional statements that we need to make the script usable and robust.
    There is an 80/20 rule that is often spoken of. This is where 20 percent of your
    time is spent in writing the main script and 80 percent of the time is spent in
    ensuring that all of the possible eventualities are correctly handled in the script.
    This is what we refer to as the procedural integrity of the script, where we try
    to cover each scenario carefully and accurately.
  prefs: []
  type: TYPE_NORMAL
- en: We started by looking at a simple test with command-line lists. If the actions
    needed are simple, then these provide great functionality and are easily added.
    Where more complexity is required, we add `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `if` statements, we can extend them as required using the `else` and
    `elif` keywords. Don't forget that `elif` keywords need their own conditions to
    evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to use `if` statements with the `test` command, and check strings,
    files, and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how we can use `case` where a single expression needs to be
    evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will seek to understand the importance of reading in
    already prepared code snippets. We will create a sample `if` statement that can
    be saved as a code snippet to be read into the script at the time of editing.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is the result of the following code: `True` or `False`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Which one of the following scripts is correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How many commands can be used as an operator to return `True` in the following
    example?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What is the result of the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-6.html](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-6.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://wiki.bash-hackers.org/commands/classictest](http://wiki.bash-hackers.org/commands/classictest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
