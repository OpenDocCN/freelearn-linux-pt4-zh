- en: Acting Like a Typewriter and File Explorer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic searching for strings and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using wildcards and regexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math and calculations in script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Striping/altering/sorting/deleting/searching strings with Bash only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SED and AWK to remove/replace substrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting your data/output using echo and printf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readying your script for different languages with internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating statistics and reducing duplicates based on file contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using file attributes with conditional logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading delimited data and altered output format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, the previous Bash crash course chapter provided more than a hint
    of the utility and power of Bash. On the other hand, this chapter introduces several
    *bolt-on* technologies to make Bash even more extensive when searching for items
    and text, or automating file explorer/file system operations.
  prefs: []
  type: TYPE_NORMAL
- en: By itself, Bash is merely a powerful scripting language, but much of Bash's
    flexibility comes from being able to "glue" other technologies (tools or languages)
    together to make the output more useful. In other words, Bash is a base platform
    similar to how some auto/car lovers choose a particular platform before making
    their modifications. Will a modified car do everything, even with enhancements?
    Certainly not, but it can make it more powerful or useful in specific cases, and
    at least provides four wheels for movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only do common scripts contain a series of commands for automation, they
    often include **logic** to modify strings such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing trailing characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing sections of words (substrings)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for strings in files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing file types (directory, file, empty, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing small calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the scope of searches or data (filtering)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the contents of variables (strings inside of string variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This logic that modifies, limits, and even replaces input/output data can be
    very powerful when you need to execute broad searches for a specific string or
    when you have copious amounts of data. Terminals chock; full of output or massive
    data files can be very daunting to explore!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one very important concept that still needs to be discussed,
    and that is **recursive** functionality. Recursive functionality can apply to
    script functions, logic, and even a command operation. For example, you can use **grep **to **recursively **crawl
    an entire directory until no more files remain, or you can recursively execute
    a function inside of itself until a condition is met (for example, printing a
    single character at a time within a string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Be careful with recursion (especially with functions), as it can sometimes be
    really slow depending on the complexity of the structure (for example, file system
    or size of files). Also if there is a logic error, you can keep executing functions
    recursively forever!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is all about limiting data, utilizing it, modifying it, internationalizing
    it, replacing it, and even searching for it in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Basic searching for strings and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine searching for a four leaf clover in a big garden. It would be really
    hard (and it is still really hard for computers). Thankfully, words are not images
    and text on a computer is easily searchable depending on the format. The term **format**
    has to be used because if your tool cannot understand a given type of text (**encoding**),
    then you might have trouble recognizing a **pattern** or even detecting that there
    is text at all!
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when you are looking at the console, text files, source code (C,
    C++, Bash, HTML), spreadsheets, XML, and other types, you are looking at it in **ASCII **or **UTF**.
    ASCII is a commonly used format in the `*NIX` world on the console. There is also
    the UTF **encoding scheme**, which is an improvement upon ASCII and can support
    a variety of extended characters that were not present in computing originally.
    It comes in a number of formats such as UTF-8, UTF-16, and UTF32.
  prefs: []
  type: TYPE_NORMAL
- en: When you hear the words encoding and decoding, it is similar to encryption and
    decryption. The purpose is not to hide something, but rather to transform some
    data into something appropriate for the use case. For example, transmission, usage
    with languages, and compression.
  prefs: []
  type: TYPE_NORMAL
- en: ASCII and UTF are not the only types your target data might be in. In various
    types of files, you may encounter different types of encoding of data. This is
    a different problem that's specific to your data and will need additional considerations.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will begin the process of searching for strings and a couple
    of ways to search for some of your own needles in a massive haystack of data.
    Let's dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides having a terminal open (and your favorite text editor, if necessary),
    we only need a couple of core commands such as `grep`, `ls`, `mkdir`, `touch`, `traceroute`, `strings`,
    `wget`, `xargs`, and `find.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that your user already has the correct permissions for your usage
    (and authorized, of course), we will need to generate data to begin searching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the data obtained by recursively **crawling** the Packt Publishing website,
    we can see that inside of **www.packtpub.com **the entire website is available.
    Wow! We also created some test data directories and files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open up a terminal and create the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the script the use of `~/* ?`. This refers to our home directory and
    introduces the `*` wildcard, which allows us to specify anything from that point
    on. There will be more on the concept of wildcards and regexes later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remain in your home directory (`~/`) and run the script, the output
    should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is a bit of a *doozy* because we are leading up to another more
    expansive topic, which is using regexes and wildcards with strings. We introduced
    them, but also showed you that you can search for terms with `${SEARCH_TERM}`or *Packt* specifically
    without their use—it's just more work and more statements. Can you imagine writing
    a specific `grep` statement for each term such as `Packt1`, `Packt2`, `Packt3`,
    and onwards? No fun.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Packt Publishing website as a *baseline* data set, we *grepped* our
    way through the directory using the `grep` command, targeting only our current
    location, our user's home directory. **Grep** is a powerful tool that can be used
    to parse the output of commands and files using patterns, regexs, and user supplied
    parameters. In this case, we did not expect any string to be found matching *Packt* because
    **www.packtpub.com** is *not* the same as **www.Packtpub.com**. Therefore, `result1.txt`
    is an empty file.
  prefs: []
  type: TYPE_NORMAL
- en: Grep and many other utilities can be case-sensitive. To use `grep` in a way
    that's case insensitive, use the `-i` flag.
  prefs: []
  type: TYPE_NORMAL
- en: In the second use of `grep`, we used the recursive flag (`-r`) and found many
    matches. By default, `grep` returns the path (containing the filename) of a match,
    and the line the match occurred within. To find the line number, you can also
    use the flag (`-n`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third example, we demonstrated that `grep` can be used with multiple
    user-supplied arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we are searching using a *brute-force* mechanism, which means
    we'll find it all by using all of our strength, literally. When performing searching
    on large amounts of data, or even when you perform something as seemingly simple
    as a search on the `PacktPublishing` website, more advanced and targeted algorithms
    help you find exactly what you want more efficiently and quicker than what we
    are doing here!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fourth and fifth executed examples, we use the `find`command. We also
    pair it with pipes and the **`xargs` **command as well. By itself, `find` is another
    very powerful CLI utility that can be used to perform search functionality (and
    consequently, damaging things if used irresponsibly/maliciously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `find` command, we are using `-type f`**, **which means that
    we are looking for files only within `${DIRECTORY}`. Then, we pipe the results
    into the `xargs` command for use with grep. Wait! What is xargs!? `Xargs` is a
    command that''s commonly used in tandem with a pipe to pass newline (carriage
    return) data to another command. For example, if we run ls `-l` (with the long
    flag), the results are returned like this (we''ve added the invisible line break
    or `\n` to illustrate this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we piped the results directly into another command that expected an input
    like the following, it would break!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, `someProgram` requires input values separated by a space and *not*
    new lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is why you use `xargs`: to remove or convert the new lines into something
    less problematic.'
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the second `find` command example, you can see that we used the
    `-name` and `! -name` parameters. `-name` is simple; we are looking for a file
    with a specific user-supplied name. In the second `! -name` instance, the `!`means
    without or *not* with that name. This is called **inverted logic**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also used the `*` wildcard again in a different context than in the first
    example using `grep` (again, more on this later). Instead, this time, we used
    the `*` to match anything before the file''s extension (`*.xml` or `*.css`). It
    can even be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following `grep` command, we use an inline subshell execution of the
    `ls` command using wildcards. Then, we take the result by setting `${RES}` to
    `$?`. `$?` is a special variable used to get the return code. Using the value
    within `${RES}`, we can now provide a bit of conditional logic if results are
    found and appropriately `echo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Right before we exited the shell, we thought we would throw in a bonus: you
    can search your past ran commands using the `history` command and `grep`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using wildcards and regexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous section, there was this new concept of recursive functions
    and the introduction of wildcards. This section will extend upon those same fundamental
    primitives to create more advanced searches using regexes and globbing.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will also extend them with a number of built-in Bash features, and some
    one-liners (nifty tricks) to enhance our searches. In short:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A wildcard can be: `*`, `{*.ooh,*.ahh}`, `/home/*/path/*.txt`, `[0-10]`, `[!a]`,
    `?`, `[a,p] m`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A regex can be: `$`, `^`, `*`, `[]`, `[!]`, `|` (be careful to escape this)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Globbing **basically refers to a far more computer-eccentric term, which
    can be simply described in layman terms as **extended pattern matching**. Wildcards
    are the **symbols** used to describe patterns, and **regex** is short for **regular
    expression**, which are terms used to describe the pattern that is to match a
    series of data.'
  prefs: []
  type: TYPE_NORMAL
- en: Globbing in Bash is powerful, but likely not the best place to perform even
    more advanced or intricate pattern matching. In these cases, Python or another
    language/tool might be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can imagine, globbing and pattern matching are really useful, but they
    cannot be used by every utility or application. Usually, though, they can be used
    at the command line with utilities such as `grep`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the `ls` command, which is piped into `grep` with a regex, we can see
    that after we `touch` three files and re-run the command that the regex allowed
    us to correctly filter the output for files starting with a lowercase character,
    which are followed by a single digit.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to further enhance grep (or another command), we could use any
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[:alpha:]`: Alphabetic (case-insensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:lower:]`: Lowercase printable characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:upper:]`: Uppercase printable characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:digit:]`: Numbers in decimal 0 to 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:alnum:]`: Alphanumeric (all digits and alphabetic characters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:space:]`: White space meaning spaces, tabs, and newlines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:graph:]`: Printable characters excluding spaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:print:]`: Printable characters including spaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:punct:]`: Punctuation (for example, a period)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:cntrl:]`: Control characters (non-printable characters like when a signal
    is generated when you use *Ctrl* + *C)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:xdigit:]`: Hexadecimal characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides having a terminal open (and your favorite text editor, if necessary),
    we only need a couple of core commands: `grep`, `tr`, `cut`**, **and `touch`.
    We''re assuming that the `www.packtpub.com` directory that we crawled through
    in the previous step is still available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal, and an editor of your choice to create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside of your script, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, execute the script and your console should be flooded with the output.
    Most importantly, let's look at the last five results. Notice the `Z9(,)` and
    `Z9.test(3)` among the results? This is the power of a regex at work! Okay, so
    we get that we can now create and search for a bunch of folders or files using
    variables, but can I use regexes to find things like variable parameters? Absolutely!
    See the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the console, try the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, in the console, try the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Can we do better using commands like `tr`to remove new lines when finding instances
    of IF that may span multiple lines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s remove a bit more gunk from the screen using `cut`as a finale.
    Usually, the console is `80` characters wide, so let''s add a line number and
    trim the output from `grep`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Entire books have been dedicated to parsing data with regexes, but the key thing
    to note is that regexes are not always the best option for either performance
    or for markup languages like HTML. For example, when parsing HTML, it is best
    to use a parser that is aware of the language itself and any language-specific
    nuances.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have guessed, snooping through lots of data without regexes and wildcards
    can be a nightmare for the uninitiated. An even scarier one might even occur when
    your expressions don't use the correct terms or a valid (and accurate) expression
    to begin with. However, wildcards are quite useful on the command line when trying
    to **craft **strings together, find data quickly, and finding files. Sometimes,
    it the usability of the search result that's irrelevant if I'm merely looking
    to find the filename and rough location/line of a specific occurrence.For example,
    where is this CSS class in what file?
  prefs: []
  type: TYPE_NORMAL
- en: Well, you made it through the script and ran several commands to get a real-world
    idea of how to use regexes and wildcards at a surface level. Let's turn back the
    clock and walk through the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 1, we opened a console, created a simple script, and executed it. The
    output results were then displayed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It could be a lot scarier! Right? In the first line, we begin by chasing down
    some PDFs that start with a capital (uppercase) letter. The line `ls * | grep
    [[:upper:]]*.pdf` uses the `ls`command with a `*` wildcard (for everything) and
    then pipes the output into `grep` with a simple regex. The regex is `[[:upper:]]`
    followed by another **`*`** wildcard to combine the `.pdf` string. This produces
    our search results, which at a minimum will contain `Test.pdf` (my results returned
    PDFs for a popular Linux journal too!).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we perform almost the same search using `ls -l [[:upper:]]* `, but using
    the `ls` directory with a regex will return a large amount of data (if all of
    the folders have contents). It begins in the current directory where the script
    is located, and then marches one directory deep and prints the contents. A neat
    feature is the use of the `-l` flag, which will produce *long* results and print
    the size of the directory in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use `ls` and look for all files beginning with a lowercase character
    and end with the `.test` extension. Little did you know, when you set up this
    recipe, you also saw wildcards and an expansion at work: `touch {a..c}.test` .
    The `touch` command created three files: `a.test`, `b.test`, and `c.test`. The
    `ls` command with this simple regex returns the names of the previous three files.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we use the `ls` command with the (`*`), wildcard and expansion brackets
    to match for file extensions: `ls *.{test,txt}`. It searches for files with any
    name (`*`), which are then concatenated with a period (`.`), followed by either
    `test` or `txt` extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in step 7, we combined a few things we have learned using pipes, `grep`,
    `xargs`, and a regex in the command: `echo "${STR1}" | grep -o [[:punct:]] | xargs
    echo`. The fact that the output from grep will be in `\n` delimited form (new
    lines for each instance found), this will break our intention to have all of the
    values echoed to the console in this form and thereby we need `xargs` to fix the
    output into parameters `echo` can properly use. For example, `echo "item1\n item2\n
    item3\n"` will not work, but with `xargs`, it will look like: `echo "item1"  "item2"
    "item3"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And in the final command, we finally arrive at a *crazier* regex, which in
    truth is actually quite tame: `ls | grep -E "([[:upper:]])([[:digit:]])?.test?."
    | tail -n 5`. It introduces a couple of concepts, including groups (the parentheses),
    (`?`) wildcards, and how you can combine multiple expression components, and `tail`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `grep`, the `-E` (expression flag), and two groups (the expressions inside
    of the parenthesis), we can combine them with the `?` regex operator. This acts
    as a wildcard for a single character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the last five results were returned, starting with a capital
    letter, followed by a number, a character (either `.` or `,`), and then the word
    test and a number. We created one test file called `Z9..test2`. Notice how it
    was not included among the list items? This was because we did not use an expression
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In step 4, we run a particular regex using `grep` and `-oP` flags, `grep -oP
    'name="\K.*?(?=")' www.packtpub.com/index.html`, on top of our recently crawled
    archive of `www.packtpub.com`. The `-o` flag means output only matching values,
    and `-P`is for using the Perl expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Notice all of the values contained with double quotes? It's looking for *any*
    match that matches the pattern `name="anythingGoesHere"`.It's certainly not extremely
    useful by itself, but it illustrates the point of being able to quickly get values
    (for example, what if the name was very specific? You could alter `name=` to another
    value and get the exact same result!).
  prefs: []
  type: TYPE_NORMAL
- en: Following along the same context, in step 5, we can also find *all* occurrences
    of `name=`: `grep -P 'name=' www.packtpub.com/index.html`. This type of command
    is useful for understanding the context of information or merely the existence
    of it; this comes back to the idea of looking for values in CSS, C/C++, and other
    data/source files.
  prefs: []
  type: TYPE_NORMAL
- en: Onward to step 6, we are looking for the title HTML tag. Normally, you should
    use a dedicated HTML parser, but if we wanted to use grep with regexes in a hurry—we
    can! The `tr '\n' ' ' < www.packtpub.com/index.html | grep -o '<title>.*</title>'` command
    uses the translate function (`tr`) to convert the `\n` or newline special character
    into an empty space. This is useful when data has a markup that may span multiple
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our closing step, we end with a bit of fine-tuning when performing broad
    searches. We simply use `grep` to provide us with the line number and filename.
    Using `cut`, we an trim the remaining characters of the output on the console
    (this can be really useful):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Regexes can also be tested online using a number of regex simulators! One popular
    and free tool available online is: [https://regexr.com/](https://regexr.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that some regex functionalities also allow you to nest commands
    within groups! We didn't demonstrate this functionality, but it exists with acceptable
    results in some use cases!
  prefs: []
  type: TYPE_NORMAL
- en: Math and calculations in script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a grueling introduction to the world of wildcards and regexes for searches,
    we're going to move on to being able to perform some basic mathematical operations
    at the console. If you haven't already tried, what happens when you run something
    like the following in the Bash shell? Does it look like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Command not found? Certainly, we know the computer can do *math*, but clearly
    Bash is unable to interpret mathematical operations in this way. We have to ensure
    that Bash is able to **interpret **these operations correctly through the use
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: The `expr` command (antiquated)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **`bc` **command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POSIX Bash shell expansion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another language/program to do the *dirty* work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try again, but using the POSIX Bash shell expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the expected answer of `5`, but where does this go wrong? It goes wrong
    when using division and floats because Bash works primarily with integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: True, `1` divided by `5` is `0`, but there is a remainder missing! And this
    is why we may rely on other methods to perform simple mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: One of the many uses or reasons to use equations and `math` in a script is to
    determine sizes of file system partitions. Can you imagine what may happen if
    a disk becomes too full? Or that we may want to automatically archive a directory
    if it reaches a predetermined size? Of course, this is theoretical, but things
    can and do break if we let a file system silently become full!
  prefs: []
  type: TYPE_NORMAL
- en: The following recipe is about determining the size of a tarball (and contents),
    the remaining available space on the destination partition, and whether the operation
    could continue or be canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is going to take into account a few interesting things:'
  prefs: []
  type: TYPE_NORMAL
- en: Bash can't do everything well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other utilities exist (for example, `bc`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create our own in another language like C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a tarball
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, on small embedded systems, Python might not be available, but Bash
    (or a close relative) and C are. This is where being able to perform math without
    extra programs (that may not be available) can come in handy!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following command to make sure that we have all of the utilities
    installed for this experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a tarball called `archive.tar.gz`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We realize that the purpose of creating/compiling a simple program that is
    not written in Bash may be beyond the scope of this book, but it can be a helpful
    skill. To do this, we will need to install GCC, which is short for the GNU Compiler
    Collection. This sounds terribly complex and we assure you that we did all the
    hard work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command installs the compiler, and now we need the C source code
    (in order to compile a *simple* C program). Open up a console and retrieve the
    code using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This code is also available on Github at [https://github.com/PacktPublishing/Bash-Cookbook](https://github.com/PacktPublishing/Bash-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the code, we will use `gcc` and `-lm` (this refers to `libmath`)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If the compiler completes successfully (which it should), you will be left
    with a utility binary called `mhelper` (or math helper). We can also add this
    to our list of local commands by copying it to `/bin` using `sudo` and `cp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `mhelper` can be used for basic operations such as division, multiplication,
    addition, and subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `mhelper` code is not designed to be particularly robust and to handle specific
    edge cases, but rather to demonstrate that another utility can be used. Python
    and numpy would be an excellent alternatives!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `mhelper` binary, `bc`, and other expressions, we can begin the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by opening a terminal and an editor to create a new script called `mathexp.sh`with
    the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, running the script should produce an output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Great! So we can use Bash size calculations, the `bc` command, and our binary.
    If you want to calculate the radius of a circle (which will certainly get you
    a float value) or a percentage, for example, you will need to be aware of this
    limitation in Bash.
  prefs: []
  type: TYPE_NORMAL
- en: To bring this recipe to a close, it is important to note that the `expr` command
    still exists, but it is deprecated. Using `$(( your equation ))` is recommended
    as the preferred method in new scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same premise using the `mhelper` binary or `$((..))` scripting, you
    can also calculate percentages for situations that need variable output (for example,
    not whole numbers). For example, calculating screen sizes based on percentages
    while a whole number will be desired, you can then round up or down post calculation.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First things first, as this recipe alluded to—we noticed that the Bash shell
    doesn''t like decimal numbers with fractions or even non-whole numbers. Wait,
    math!? Unfortunately, we can''t hide all the details, but in programming, there
    are a couple of concepts that you should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Signed and unsigned numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floats, doubles, and integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first concept is fairly simple—current computers are binary, which means
    they compute using zeros (0) and ones (1). This means that they work in powers
    of 2^. Without getting into a lesson about basic computer science, if you see
    a value (datatype) that is an int (integer) and that it is a 32 bit number, this
    means that the maximum value if it begins at `0` is `4,294,967,295` in decimal
    (2^32). This makes one critical assumption and that is that all numbers (0 included)
    are positive. This positive or negative property is called **sign**! If a datatype
    mentions signed or unsigned—now you know what it means!
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a consequence of whether something is signed and that is that
    the maximum positive or negative value is decreased because one bit is used to
    represent sign. A signed 32 bit int (which can also be referred to as `int32`)
    shall now have a range of `(-)2,147,483,647` to `(+)2,147,483,647`.
  prefs: []
  type: TYPE_NORMAL
- en: As a note from the author, I realize that some of the computer science definitions
    are not computer science correct, meaning that I tweaked some of their meanings
    to make sure the key points got across in *most* general situations.
  prefs: []
  type: TYPE_NORMAL
- en: On another note, Bash only uses integers and you may have already seen that
    when you divide a value like `1/5`, the answer is `0`. True, it is not divisible,
    but the answer is `0.20` as a fraction. We also cannot multiply numbers that have
    a decimal point as well! Therefore, we have to use other programs such as `bc`
    or `mhelper.`
  prefs: []
  type: TYPE_NORMAL
- en: If you are keen on computers, you also know that there are floats, doubles,
    and other datatypes to represent numbers. `Mhelper` and `bc` can help you deal
    with these types of numbers when the concept of integers fails (for example, resulting
    numbers are not whole numbers when dividing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the recipe, and in step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a script that will check the `/home` directory to determine how much
    size is available using the `df` command. Using `tail`, another command that can
    be used to reduce output, we skip the first line of output and pipe all output
    into the `$CURRENT_PART_ALL`variable(or all current partition information).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the contents of the `$CURRENT_PART_ALL` variable are read into an array
    using the `read`command. Notice the use of the re-direction errors: `<<<`. This
    is called a **her****e-string**, which in simple terms expands the variable and
    feeds it into `` `stdin.` ``'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the `/home` partitions storage information is inside of an array, and we
    have a `tarball` (or a file that compresses and contains the contents within),
    where we need to know the size of the contents within the `tarball.` To do this,
    we use a long-winded command with multiple piped commands, which retrieves the
    size of the contained elements and pushes them through the `bc` command.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon determining the size of the elements contained within our archive, we validate
    the calculated size against the remaining available space. This value is inside
    of the `array element[1]`. If the available space is less than equal to the extracted
    files, then exit. Otherwise, print the remaining size after performing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For fun, we combined forking a subshell to retrieve the division results of
    the `mhelper`, which are piped through `bc`. This is so we can determine if there
    is enough space as a mere `boolean` value of true (1) or false (0).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we assume we have enough space, we untar (decompress and extract the contents)
    the `$TARBALL`. If the `tar` command returns a value not equal to `0`, then exit
    with an error. Otherwise, exit with success.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After executing our script, the contents of the tarball (`empty.bin`) should
    be present in the current working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside of the script, we put two different evaluations in the comments, which
    would return floating point values or errors in syntax. We included them for your
    awareness and to drive the main lesson home.
  prefs: []
  type: TYPE_NORMAL
- en: Did we miss anything? Absolutely! We never checked the size of the tarball itself
    and made sure that its size was among the used space when performing a check to
    determine the remaining free space. One should always be careful when performing
    and enforcing size restrictions!
  prefs: []
  type: TYPE_NORMAL
- en: Striping/altering/sorting/deleting/searching strings with Bash only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen inkling of the power of commands available in Linux, and
    some of these are among the most powerful: `sed` and `grep`. However, while we
    can easily use these commands together, *sed by itself* or even using another
    very useful command called `awk`, we can leverage Bash itself to shave time and
    reduce external dependencies in a portable way!'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we do this? Let''s begin with a few examples using this Bash syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see a special way of calling special substring
    functionality using `${...}`, where `VARIABLE` is a string variable within your
    script (or even global), and then the following variable is the `:`.After the
    `:`, there is the `startingPosition` parameter(remember that strings are just
    arrays of characters and each character can be addressed by index), and there
    is another optional semicolon and length parameter (`optionalLength`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ran this script, the output would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'How is this possible, you may ask? Well, its possible with Bash''s equivalent
    of `substr` (a function in C and many other programming languages), and this is
    achieved through the usr of the **`${...}`**syntax. This tells bash to look inside
    for a variable named `VARIABLE` and then for two parameters: to start at byte/character
    `3` (technically `4` because arrays start at element `0` in Bash) and a length
    of `4` (to print only four characters). The result of the echo is `test`.'
  prefs: []
  type: TYPE_NORMAL
- en: Can we do more with this, such as removing the last character? Deleting words?
    Searching? Of course, and all of this is covered in this recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get ready for the exercise by creating some data sets which mimic common
    daily problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these two CSVs, we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the extra spaces on the first two lines of `garbage.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the last character from each line in `garbage.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the case of each character to uppercase in the first two lines of `garbage.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace `Bob` with `Robert` in `employees.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert a `#` at the beginning of each line in `employees.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the exact date of birth column/field in each line of `employees.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal and a new file with your preferred editor. Add in the following
    contents into the new script and save it as `builtin-str.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Execute the script with `bash builtin-str.sh`and notice how we were able to
    strip the last character from a string and even compare strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Again, open a new file called `builtin-strng.sh`and add the following contents
    into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s strip the garbage—remove spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove the last character from each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's turn all of the characters into uppercase!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We will delete the day in the `birth` column. The field to remove is 5 (but
    this is really -4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Execute the script with `bash builtin-strng.sh`and review the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Did you notice all of the opportunities to re-direct input or output? Imagine
    the possibilities! Furthermore, much of the previous script can be performed using
    another tool called AWK instead.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is a bit iterative, but it should *re-iterate*(pardon the pun)
    to demonstrate that Bash has a fair number of functionalities built-in to manipulate
    strings or any structured data. There is a basic assumption though and that is
    based on many OSes using C programs:'
  prefs: []
  type: TYPE_NORMAL
- en: A string is an array of characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characters such as `','` are the same as any other character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, we can evaluate or test for the existence of a character to separate
    fields from lines and even use this to build arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, reviewing the steps in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the script, we have the following output in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We began with the string `STR="1234567890asdfghjkl"`and as the script ran in
    the first step:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we printed out a single character starting at the zero (0)
    position. Remember that this is an array, and position `0` is the starting element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we retrieved the first three characters to arrive at: `123`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, what if we wanted all of the characters after position 3? We would
    used `${STR: 3}` instead of `${STR: 0-3}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, given the preceding point, if we wanted the characters at position 4
    (the forth element in the array, but this is addressed at position three (3) because
    counting begins at zero (0)), we use `${STR: 3: 3}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, to get only the last character, we can use `${STR:-1}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To finish the first script in the recipe, we had three more strings. If we wished
    to compare them to each other, we can do so using conditional logic. Remember
    that bcd is less than BCD.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing strings using simple Bash constructs can be useful when you want to
    write a script that quickly compares filenames for a specified execution. For
    example, run the `001-test.sh` script before `002-test.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second half of the recipe, we begin with a long-winded script to duplicate
    in an easily explained manner. We covered some of the tricks you can use with
    the Bash shell without using AWK and SED:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here is the breakdown of the script, but a brief introduction is required for
    **arrays**, **readarray**, **IFS**, and **oldIFS. **The point of the exercise
    is to not go into a great lesson on arrays (this will happen later), but to know
    that you can use them automatically to create dynamic lists of things such as
    files or lines within a file. They are referred to using the `${ARR[@]}` notation,
    and each element can be referred to by its index value within the square brackets `[...]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readarray` command parses the input into an array using the `IFS` and
    `oldIFS` variables. It separates the data based on a common delimiter (IFS), and
    oldIFS can maintain the old values, should they be altered:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we use read in the `garbage.csv` (`${GB_CSV}`) and then `${#ARR[@]}`
    to retrieve the number of elements in the array. We don't use this value, but
    it is interesting to note the structure of your file and whether it is being read
    in correctly. Then, for each member of the array, we remove the empty spaces by
    counting the number of spaces and then removing them with an additional while
    loop, performing `${i/, /,}`until we're done. The corrected values are then re-inserted
    into the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next step, we use `${i::-1}` and a for loop to remove the last character
    from each line. Then, the result is re-inserted into the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `for` loop and `ARR[$INC]=${i^^}`, all characters in the array are made
    uppercase, and we print out the array using `printf `(more on this later in another
    recipe).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On to `employees.csv`, we read it into the array again using `readarray.` Then,
    we add a hash sign (`#`) to the beginning of each line and re-insert it into the `ARR[$INC]="#${i}"` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we search for the substring `Bob` and replace it with `ARR[$INC]=${i/Bob/Robert} `.
    To use the built-in search and replace functionality, we use the following syntax:
    **`${variable/valueToFind/valueToReplaceWith}`**. Notice that this is also the
    same premise behind the space removal performed in an earlier step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final step is a bit more complicated and a bit *long in the tooth*, meaning
    it could be shortened and performed using another tool such as AWK, but for the
    purpose of an easy to read example—it was written a bit like a C program. Here,
    we want to remove the actual birthday value (0-31), or column 5 (the index is
    4 if we consider that arrays begin at 0). To begin, we iterate through the array
    using a for loop, and then we use read to take the input value as an array, too!
    Then, for each field in the array `${ELEM_ARR[@]}`, we then check to see if it
    is not the first value, and also not the column we wish to remove. We build the
    correct string via concatenation and then re-insert it into the array before printing
    each value using `echo`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrays** are a data construct and the important thing to think about data
    is that it can be manipulated in a number of ways. Just like how we split a file
    line by line to create an array of elements, we can also split those elements
    into arrays of their own!'
  prefs: []
  type: TYPE_NORMAL
- en: Using SED and AWK to remove/replace substrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, when we need to remove a pesky character or remove sections of strings
    upon occurrence, we can always rely on these two powerful commands: `sed`and `awk`.
    And while we saw that Bash does indeed have a similar functionality built-in,
    the full tools are able to offer the same and more complex functionality. So,
    when should we use these tools?
  prefs: []
  type: TYPE_NORMAL
- en: When we care less about the speed that might be gained by using the built-in
    functionality of Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When more complex features are needed (when programming constructs like multi-dimensional
    arrays are required or editing streams)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we are focused on portability (Bash might be embedded or a limited version
    and standalone tools may be required)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete books have been written on both SED and AWK, and you can always find
    far more information online at [https://www.gnu.org/software/sed/](https://www.gnu.org/software/sed/)
    and [https://www.gnu.org/software/gawk/](https://www.gnu.org/software/gawk/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Stream editor** (**SED**) is a handy text manipulation tool that is great
    for one-liners and offers a simple programming language and regex matching. Alternatively,
    AWK is also powerful and arguably more than SED. It offers a more complete programming
    language with a variety of data structures and other constructs. However, it is
    better suited when working with files such as CSVs, which may contain fields or
    structured data, but SED can be better when working with text substitutions when
    working with pipes (for example, `grep X | sed ... > file.txt`).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get ready for this exercise by creating some data sets which mimic common
    daily problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these two CSVs, we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the extra spaces on the first two lines of `garbage.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the last character from each line in `garbage.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the case of each character to uppercase in the first two lines of `garbage.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace `Bob` with `Robert` in `employees.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert a `#` at the beginning of each line in `employees.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the exact date of the birth column/field in each line of `employees.csv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the exercise using Bash only, we are going to perform a similar recipe
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script called `some-strs.sh`with the following content and open a
    new terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Execute the script and review the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another script called `more-strsng.sh` and then execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to add a `#` at the beginning of each line and we will also use the
    `sed` tool on a per file basis. We just want to strip Bob out and change his name
    to Robert by manipulating the file in-place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Examine the results—was it simpler to get the results to the recipes that leverage
    only bash built-in constructs? Likely yes in many situations, IF they are available.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After running the two scripts in this recipe, we can see a few items emerge
    (especially if we compare the built-in Bash functionality for searching, replacing,
    and substrings).
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing `some-strs.sh`, we can see the following output in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have seen the `echo` command used several times, but the `-n`
    flag means that we should not automatically create a new line (or carriage return).
    The `<<<` re-direct for inputting values as a string has also been previously
    used, so this should not be new information. Given that, in the first instance,
    we are using `sed` like this: `sed 's/.//2g' <<< $STR` . This script uses `sed`
    in very simple ways compared to the plethora of ways you can combine pure sed
    with regexs. First, you have the command (`sed`), then the parameters (`'s/.//2g'`),
    and then the input (`<<< $STR`). You can also combine parameters like this: `'s/.//2g;s/','/'.'/g'`
    . To get the first character, we use `sed` in substitute mode (`s/`) and we retrieve
    two characters using (`/2g`), where `g` stands for global pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The reason it is `2g` and not `1g` is that a null byte is returned automatically
    and therefore, if you desire *n* characters then you must specify *n+1* characters.
    To return the first three characters, we merely change the `sed` parameters to
    include `4g` instead of `2g.`
  prefs: []
  type: TYPE_NORMAL
- en: In the next block of the script, we use sed as follows: `sed -r 's/.{3}//'`
    and `sed -r '$s/.{3}//;s/.//4g'` . You can see that in the first execution of
    `sed`, `-r` is used to specify a regex and so we use the regex to return the string
    at position 4 (again, those pesky arrays and strings) and everything beyond. In
    the second instance, we combine starting at the third character but limit the
    output to only 3 characters.
  prefs: []
  type: TYPE_NORMAL
- en: In the third block of script, we want the final character of the string using
    `sed 's/.*\(.$\)/\1/'` and then get the entire string *except* the last character
    using `sed 's/.$//'`. In the first instance, we use grouping and wildcards to
    create the regular expression to return only one character (the last character
    in the string), and in the second instance, we use the `.$` pattern to create
    an expression that returns everything minus the last character.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that search and replace can also be used for deletion
    operations by specifying an empty value to replace. You can also use the `-i`
    flag for in-place edits and to also perform deletion using other flags/parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Onto the next script, and after execution, the console should look similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, in the first block of code, we read in the CSV into an array and for
    each element, we perform a substitution to remove the spaces: `sed ''s/ //g''`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second block, again, we iterate through the array, but we remove the
    last character, `sed  's/.$//'`, and then pipe the output to convert everything
    to uppercase using `sed -e 's/.*/\U&/'`. In the first part of the pipe, we search
    for the last character using `.$` and remove it (the `//`). Then, we use an expression
    to select everything and convert it to upper case using `\U&` (notice that it
    is a special case allowed by GNU sed). Lowercase can be achieved using `\L&` instead.
  prefs: []
  type: TYPE_NORMAL
- en: In the third block, again, we used a for each loop and a subshell, but we didn't
    echo the input into `sed.` Sed also takes input like this using the `<<<` input
    direction. Using `sed -e 's/^/#/'`, we start at the beginning of the string (specified
    by the `^`) and append a `#`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for the last three examples, we perform work on the actual files themselves
    and *not* the arrays loaded into memory by using `sed` with the `-i` flag. This
    is an important distinction as it will have direct consequences on the files used
    as input; this is probably what you desire in your scripts anyway!To replace `Bob`
    with `Robert,` it is the same as removing spaces except we specify the replacement.
    However, we are performing the replacement on the *entire* input CSV file! We
    can also add the hash sign for each line in the file, too.
  prefs: []
  type: TYPE_NORMAL
- en: In the final example, we briefly use AWK to show the power of this utility.
    In this example, we specify the delimiters (FS and OFS) and then we specify the
    fifth column alongside the `gsub sub` command in the AWK language to remove the
    column or field. Begin specifies the rules AWK shall use when parsing input and
    if there are multiple rules, the order received is the order executed.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can print the first column or field using `awk 'BEGIN { FS=","}
    { print $1}'  testdata/employees.csv` and even the first occurrence by specifying
    `NR==1` like this: `awk ' BEGIN { FS=","} NR==1{ print $1}' `. Specifying the
    number or returned records is very useful when using the `grep` command and copious
    amounts of matches are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Again, there is so much you can do with AWK and SED. Combined with regular expressions
    (regexes), explanations and examples of all sorts of usage could fill a book dedicated
    to each command. You can check out the tools available in the documentation on
    the web so that you are aware of some platform differences.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting your data/output using echo and printf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, finding the string or the exact data you are looking for is the
    easy part of your task, but formatting the output data is tricky. For example,
    here are some situations that have subtle elements that need to be altered:'
  prefs: []
  type: TYPE_NORMAL
- en: Echoing output without the newline terminator (\n)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Echoing raw hexadecimal (hex) data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing raw hexadecimal values and printable ASCII characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenating strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escaping specific characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing horizontal rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to tricks, we can also print values to the screen that are also
    floats as well (in addition to the recipe for math). Wait, what is a hexadecimal number?
    Yes, another type of data or at least a representation exists. To understand what
    hexadecimals are, we first need to remember that computers use **binary**, which
    consists of 1s and 0s (ones and zeros). However, binary is not very friendly to
    us humans (we use the decimal format when looking at numbers typically), so other
    representations are sometimes needed, one of which is called **hexadecimal.**
    As you have probably guessed, it is base 16 so it looks like 0x0 to 0xF (0x0,0x1,
    ... ,0x9,0xA,0xB, ..., 0XF). Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, both `printf` and `echo` can be used to print raw
    hex and Unicode characters. Using a Unicode reference, I found the UTF-8 encoding
    for the **skull **character (`F0 9F 92 80`) and then formatted it using `\xFF`.
    Notice where FF is; it is in each **byte**.
  prefs: []
  type: TYPE_NORMAL
- en: What can you do knowing about "raw hex" values? Well, you can send characters
    that the shell can interpret differently, or you can print neat things! See [unicode-table.com](https://unicode-table.com) for
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Wait, another term called a **byte**? Yes, and here is another one called a **bit.** A **bit **is
    the form because it refers to either a 0 or 1, but a **byte is 8 bits** (one byte
    is made up of eight bits! Get it?).
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, depending on the platform or measurement—be aware that 1 kilobyte
    or KB can mean 1,024 Bytes (B) or on many marketing datasheets, 1 KB= 1,000 B.
    Furthermore, when you see Kb—it does NOT mean kilobytes. It means **Kilo** **bits!**
  prefs: []
  type: TYPE_NORMAL
- en: Again, being aware of computational basics such as types of data and conversion
    between basic data forms is a very useful tool to have in your skill set. It might
    even be in a job interview or two!
  prefs: []
  type: TYPE_NORMAL
- en: However, we are getting a bit ahead of ourselves—what is `echo` and `printf`?
    Both are commands which you may have seen earlier in this cookbook that allow
    you to output the contents of variables and more to the console or even to a file. **Echo**
    is far more "straightforward", but **printf** can provide the same and more functionality
    using C style parameters. In fact, one of the main features of printf over echo
    is that printf can format characters, pad them, and even align them.
  prefs: []
  type: TYPE_NORMAL
- en: Alright; let's get to work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this exercise, no extra tools or scripts are required—just you, your terminal,
    and Bash.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up a new script called `echo-mayhem.sh` in your favorite editor and a
    new terminal. Enter the following contents and then execute the script at the
    prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After reviewing the results of `echo-mayhem.sh`, create another script called
    `printf-mayhem` and enter the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Execute the contents of `printf-mayhem.sh` and review the contents for subtle
    differences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While this is a pretty important topic revolving around data types (especially
    when dealing with math or calculations), we broke the solution to this recipe
    up into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 1, echo is pretty straightforward. We have mentioned in the past that
    there are special characters and escapes. `\t` stands for tab `\r\n` a new line
    in Windows (although in Linux, `\n\n` would have sufficed) and again, we could
    print out a fancy UTF character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the results of step 2 are a bit different, as we can see in the following
    code. Let''s explore this a bit more as it looks like it''s a bit more than sloppy
    alignment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in the preceding step after execution, there are a few interesting
    things. The first thing we notice is that `printf` is echo on steroids; it provides
    the same functionality and far more such as alignment, strings being printed with `%s`,
    and decimal places (for example, `%.2f`). As we dig deeper, we can see that we
    can limit the number of decimal places using a % after the `%tag`. Notice the
    single character usually immediately after the `%` sign—this is how you format
    the following parameters. Using a value like `%10f`, we are dedicating 10 spaces
    to the value, or rather, the width of 10 characters. If we use `%-10`, then it
    means we are aligning the value to the left. And besides the near horizontal rule,
    which uses expansion, we also "stepped" our way through the string "No place like
    home!". Using a `while` loop, we print out each ASCII character using (`%-c`)
    with its corresponding hexadecimal value (`%-2X`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that even spaces have a hexadecimal (hex) value, and that is `0x20.` If
    you ran the script and got `"printf-mayhem.sh: line 26: printf: !: invalid number"`,
    this is because you missed the single `'' `in `"''${STR:$TMP_CNT:1}"`. This signifies
    how to interpret the returned value as either a string/character or numeric value.'
  prefs: []
  type: TYPE_NORMAL
- en: Readying your script for different languages with internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great, so you have this awesome script, but it''s written in standard English
    and you would like to target those nice people who speak other languages. In some
    countries like Canada, they (we) have two official languages: English and French.
    Sometimes, the dual-language component is enforced with legislature and localized
    language laws.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around this, let''s imagine a scenario where you are an individual who
    has written a script that prints out specific strings, but in English first. He/she
    wishes to have all of the strings inside of variables so that they can be swapped
    in and out dynamically using system language variables. Here are the basics:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a shell script that utilizes **gettext **and sets the appropriate variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a **po **file that contains the necessary language definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install your output language localization file for your script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run your script with a language that's different than the one you originally
    use (by setting the LANG variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before getting started, though, there are two terms that need to be discussed:
    internationalization (i18n) and localization (L10n). Internationalization is a
    process that enables translation and localisation/adaptation for a specific script
    or program, and localization refers to the process of having adapted the program/application
    for a specific culture.'
  prefs: []
  type: TYPE_NORMAL
- en: The translation of scripts from the start can be an effective way to save time
    and improve the success of multi-lingual efforts. However, be aware that it can
    be a time-consuming process if the developers are fluent in only one language,
    or translation skills are not immediately present.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in English, there are several dialects. In the USA, a product of
    a process or leftover can be called an **artifact**, but in Canadian English,
    it may be called an **artefact**. It could go unnoticed (or ignored), but the
    program could automatically adapt with specific localization.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get ready for the exercise by ensuring that we have the following applications
    and supporting libraries installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, verify your language environment variables (LANG):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We're assuming your environment probably has some form of English set as the
    default (`en_CA:en` is Canadian English)—keep note of the values returned for
    later!
  prefs: []
  type: TYPE_NORMAL
- en: You may need to recover your language and locale settings later if something
    goes wrong. There are many posts on the internet, but a few hints are: `$ export
    LC_ALL="en_US.UTF-8"`; `sudo locale-gen`; and `sudo dpkg-reconfigure locales`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal and create a new script called `hellobonjour.sh`with the
    following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `xgettext` to generate the appropriate strings. We will not use the results,
    but this is how you can generate a minimalist PO file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the already compiled list of strings into the language PO file called
    `hellobonjour_fr.po`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, using `msgfmt`,compile the PO file into a binary language file with the
    `.mo` extension and place it in our arbitrary language folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have your language file in place, create the following script with
    the name of `translator.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing `translator.sh`, review the results for both executions of `translator.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It goes without saying that translation can be a tricky beast, especially when
    managing encoding and when producing results that make sense at the human language
    level. Furthermore, even a slight change in the value within the script can break
    the PO file and the resulting script will not be fully translated (sometimes,
    not even at all).
  prefs: []
  type: TYPE_NORMAL
- en: Take care not to break the *keys* when making modifications to the scripts at
    a later date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step one is fairly straightforward—you just create a script. If you run the
    script, you will see purely an English result, but at least the plural and non-plural
    output is correct. Notice `. gettext.sh`; this line preps `gettext` to prepare
    and to be ran for internationalization/localization. In the script, we also use `gettext`,
    `eval_gettext`, and `eval_ngettext`. These are functions that allow the translation
    to occur. Use `gettext` for simple translations, `eval_gettext` for a translation
    that contains a variable, and `eval_ngettext` when you have translations that
    contain plural objects. As you may have noticed, `eval_ngettext` is a bit more
    complex: `$(eval_ngettext "I have \$COUNT electronic device" "I have \$COUNT electronic
    devices" $COUNT)`. The first parameter for `eval_ngettext` is the singular translation,
    the second is the plural, and the count is the variable used to determine if a
    singular or plural value is used. Variables are referred to in the original script
    with an escape `\$COUNT`, and the translated string that contains the variable
    will appear as `$COUNT` inside of the translation file without the escape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In step two, we create the language file called a PO file using `xgettext`.
    PO is short for Portable Object. Notice that we omitted the header because it
    will produce extra output. It is particularly useful when you want to write notes,
    versions, and even specify the encoding used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instead of writing the translations from scratch, we used our trusty friend
    Google translate to produce a few basic translations and we copy them over the
    output from `xgettext.` Xgettext created almost the same file! Notice `msgid`,
    `msgstr`, `msgplural`, and `msgstr[...]`. `Msgid` and `msgid_plural` are used
    to match the original values as if they were a key. For example, as the script
    runs, `gettext` sees `"I have $COUNT electronic device"`, and then knows to output
    a specific translation that matches that same `msgid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`hellobonjour_fr.po` contains all of our translations, and now we can use a
    command called `msgfmt`, which is used to produce a MO file or Machine Object.
    If you open this file with an editor like `vi`, you will notice that it contains
    a bunch of symbols representing binary and the strings. This file should not be
    edited, but rather the input PO file itself.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we create a file called `translator.sh`. It runs `hellobonjour.sh` and
    contains a few lines that set three important variables: `TEXTDOMAIN`, `TEXTDOMAINDIR`,
    and `LANGUAGE`. `TEXTDOMAIN` is typically the variable used to describe the binary
    or shell script (think of it as a namespace), and `TEXTDOMAINDIR` is the directory
    for `gettext` to look for the translation. Notice that it''s in a local relative
    directory, and not `/usr/share/locale` (which it could be). Finally, we set `LANGUAGE`
    to fr for French.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we execute `translator.sh`, `hellobonjour.sh` is run twice and outputs
    once in English, and the second time in French:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Do not use the old format of $"my string" for translation. It is subject to
    security risks!
  prefs: []
  type: TYPE_NORMAL
- en: Calculating statistics and reducing duplicates based on file contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At first glance, calculating statistics based on the contents of a file might
    not be among the most interesting tasks one could accomplish with Bash scripting,
    however, it can be useful in several circumstances. Let''s imagine that our program
    takes user input from several commands. We could calculate the length of the input
    to determine if it is too little or too much. Alternatively, we could also determine
    the size of a string to determine buffer sizes for a program written in another
    programming language (such as C/C++):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We can use commands like `wc` to calculate the number of occurrences of words,
    total number of lines, and many other actions in conjunction to the functionality
    provided by your script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Better yet, what if we used a command called **strings** to output all printable
    ASCII strings to a file? The strings program will output *every* occurrence of
    a string—even if there are duplicates. Using other programs like `sort` and `uniq`
    (or a combination of the two), we can also sort the contents of a file and reduce
    duplicates if we wanted to calculate the number of *unique* lines within a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know a few basic premises of why we may need to perform some basic
    statistics, let's carry on with the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get ready for the exercise by creating a single dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen most of these concepts already and even `wc`itself in
    one of the previous recipes, so let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed, the output has the filename included. Can we remove
    it with AWK? Absolutely, but we can also remove it with a command called `cut.` The
    `-d` flag stand, for delimiter and we would like to have a field (specified by
    `-f1`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that we have a massive file full of strings. Could we reduce the returned
    results? Of course, but let''s use the `sort` command first to sort the elements
    contained in `testdata/duplicates.txt` and then use `sort` to produce a list of
    only the unique elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overall, no truly abstract concepts were introduced in this script, except for
    counting numbers of occurrences and the benefit of sort. Sorting can be a time-consuming
    process to reduce unneeded or extra data or when the order matters, but it can
    also be rewarding when performing bulk operations, and pre-processing yields faster
    returns overall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Onward and upward to the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running these two `wc`commands will produce both a character and line count
    of the file `testdata/duplicates.txt.` It also begins to show another problem.
    The data can be padded with the filename prefixed with a space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 2, we use `awk` and `cut` to remove the second field. The `cut` command
    is a useful command for trimming strings, which may be delimited or merely using
    hard-coded values such as remove X characters. Using `cut`, `-d` stands for delimiter,
    the space in this example (`'' ''`), and `-f1` stands for field `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final step, we run the `sort` command three times. We run it once to
    merely sort the elements in `testdata/duplicates.txt`, but then we use the `-u` to
    sort and keep only unique elements, and the `final` command counts the number
    of unique elements. Of course, the returned value is `9` because we had 18 lines
    in the original duplicates file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Using file attributes with conditional logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this book, we touched upon various tests for strings, numbers, and
    variables. Using a similar concept built into Bash, we can also use various attributes
    to test against files and directories. This extends upon the introduction conditional
    logic to perform tests on files. Does an example exist? Is it a directory? and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: For a moment, though, couldn't we just use the results from executing and checking
    the return code? Absolutely! This is another method you can use, especially if
    you are using a version of Bash that supports all of Bashes features. It is just
    another way to "skin the rabbit".
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off first with some of the common flags, which return true if:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-e`: The file exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: This is a regular file and not a directory or device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: The file is not empty or zero in size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d`: This is a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This has read permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w`: This has write permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x`:This has execute permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-O`: This is the owner of the file the current user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-G`: This executes the user if they have the same group as yours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f1` (`- nt`, `-ot`, `-ef`) `f2`: Refers to if `f1` is newer than `f2`, older
    than `f2`, or are hard-linked to the same file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is more information available on file test operations in the GNU Bash
    manual:[ https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html](https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get ready for the exercise by creating a few text files and directories,
    and adding some content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This recipe is about performing some simple file tests and to combine some of
    the other knowledge from earlier recipes on conditional logic, but with a twist—using
    user input from the CLI and file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the commands `chmod`, `useradd`, and `chmod`. Chmod is the command you
    may use to change the permissions of files for execution and more.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal and start an editor of your choice and create a new script.
    The following is a code snippet from the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Execute the script and try to access the various files, including the directories
    and files that do not exist. What do you notice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the folder now with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, before digging into the script itself or even the attributes/properties
    of files, we need to know a few things about Linux and its sibling operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Files and directories can be owned. This means that they can have an owner (user)
    and groups associated with their ownership. For this, we can use the `chown` and
    `chgrp`commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files and directories can have different permissions applied to them. This means
    that they may be executable, readable, writable, and/or everything. For this,
    we can use the `chmod`command and the appropriate permission setting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files and directories can also be empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Great! Furthermore, there are two more concepts that need to be introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: The `read`command, which is used to wait for user input and read it into a variable.
    It is also useful for "pause" functionality in scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive functions. Notice that inside of the script unless it exits or the
    user presses *ctl + C*, the script keeps calling a particular function. This is
    recursion and it will continue unless stopped or a limit is applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we also know functions, parameters, input/output, return codes,
    subshells, and conditional logic. You may not have noticed the `!` character,
    and this is used to negate a statement. For example, if we test for the existence
    of `fileops/bobs.txt` using the `-e` test operator, it will return true. Instead,
    we can test for the opposite, which is that `fileops/bobs.txt` is non-existent.
  prefs: []
  type: TYPE_NORMAL
- en: The same logic as inverting or negating statements can also be achieved using
    if/else functionality, but it can sometimes improve script "readability" and "flow".
    Ultimately, the choice to use inversion is up to the script writer.
  prefs: []
  type: TYPE_NORMAL
- en: Great! We have created our script and are ready to execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon executing the script, we are greeted with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If we look back at the setup for this recipe, we know that we created several
    files inside of the directory `fileops/` and that a few of them have different
    permissions, one of which is owned by a user named `Bob`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a few executions (in order) :'
  prefs: []
  type: TYPE_NORMAL
- en: '`fileops/bobs.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileops/write.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileops/exec.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileops/all.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thisDoesNotExist.txt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As `thisDoesNotExist.txt` does not exist, the script abruptly exits and places
    you back at the console prompt. We tested with the various flags, negation, ownership,
    and even our ever useful utility `xargs`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading delimited data and altered output format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every day, we open many files in many different formats. However, when thinking
    about large amounts of data, it is always a good practice to use standard formats.
    One of these is called **Comma Separated Values**, or CSVs, and it uses a comma
    (,) to separate **elements **or **delimit** on each row. This is particularly
    useful when you have large amounts of data or **records**, and that data will
    be used in a scripted fashion. For example, in every school semester, Bob, the
    system administrator, needs to create a series of new users and set their information.
    Bob also gets a standardized CSV (like in the following snippet) from the people
    in charge of attendance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If Bob the administrator wishes to only read this information into an array
    and create users, it is relatively trivial for him to parse a CSV and create each
    record in one single scripted action. This allows Bob to focus his time and effort
    on other important issues such as troubleshooting end-user WiFi issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is a trivial example, these same files may be in different forms
    with **delimiters **(the `,` or `$` sign, for example), different data, and different
    structures. However, each file works on the premise that each line is a record
    that needs to be read into some structure (whatever it may be) in SQL, Bash arrays,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example of a pseudo CSV, there is a header, which may be optional
    (not present), and then several lines (each being a record). Now, for Bob to parse
    the CSV, he has many ways to do this, but he may use specialized functions that
    apply a strategy such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'To read in the data, Bob or yourself may resort to using:'
  prefs: []
  type: TYPE_NORMAL
- en: For loops and arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A form of iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually walking through each line (not efficient)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once any input data has been read in, the next step is to do something with
    the data itself. Is it to be transformed? Is it to be used immediately? Sanitized?
    Stored? Or converted to another format? Just like Bob, there are many things that
    can be performed using the data read in by the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In regards to outputting the data, we can also convert it to XML, JSON, or
    even insert it into a database as SQL. Unfortunately, this process requires being
    able to know at least two things: the format of the input data and the format
    of the output data.'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing common data formats and how they often have validation applied can be
    a great asset when building automated scripts and identifying any changes in the
    future. Enforcement of data validation also has several benefits and can help
    save the day when all of a sudden the script breaks without warning!
  prefs: []
  type: TYPE_NORMAL
- en: This recipe aims at walking you through reading a trivial CSV and outputting
    the data into some arbitrary formats.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get ready for the exercise by creating some data sets which mimic common
    daily problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In Bash, the single quote (') is used for literal strings. In this case, we
    want every part of the string to be present without escaping slashes and double
    quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To operate this script, you have the following applications installed for use
    within the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and create the `data-csv-to-xml.sh` script with the following
    contents. Then, execute the script after saving it using `$ bash data-csv-to-xml.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Examine the output, but be aware that "pretty" XML isn't necessary and in fact,
    we don't even need to have the XML on multiple lines. If pure data is required
    for a web application, the extra new lines and tabs are unnecessary data to be
    transmitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another script named `data-xml-to-json.sh` with the following contents.
    Then, execute the script after saving it using `$  data-xml-to-json.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Review the output and see how it easy it is! Are there areas you could improve
    on in both of the scripts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already discussed several important aspects such as the power of the
    SED and AWK commands, and even CSVs, but we have not discussed the importance
    of being able to **transform** the format and structure of data. CSVs are a fundamental
    and very common format of data, but unfortunately, it isn''t the best choice for
    some applications, so we may use XML or JSON. Here are two scripts (or rather
    one script and one tool) that can convert our original data into various formats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When executing `data-csv-to-xml.sh`, we notice several things: we utilize two
    source template files, which can be altered for flexibility, and then a large
    piped command that leverages sed and AWK. On input, we take each of the CSV values
    and build a `<word lang="x">Y</word>` XML element using the format template inside
    of `word.tpl`, where `$0` is field one and `$1` is field two. The script will
    produce a `words.csv` and output the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In the second script, we merely take `words.xml` as input into the command `xml2json`.
    The output will be in JSON format. Cool hey?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The differences and reasons between all three formats of data (CSV, XML, and
    JSON) is left as an exercise for the reader to discover. Another exercise to explore
    is performing data validation to ensure integrity and constraints on data. For
    example, XML can use XSD schemas to enforce data limits.
  prefs: []
  type: TYPE_NORMAL
