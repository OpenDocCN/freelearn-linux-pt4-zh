<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Allowing Remote Access"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Allowing Remote Access</h1></div></div></div><p>This chapter contains the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Running commands remotely through SSH</li><li class="listitem" style="list-style-type: disc">Configuring a more secure SSH login</li><li class="listitem" style="list-style-type: disc">Securely connecting to SSH without a password</li><li class="listitem" style="list-style-type: disc">Restricting SSH access by user or group</li><li class="listitem" style="list-style-type: disc">Protecting SSH with Fail2ban</li><li class="listitem" style="list-style-type: disc">Confining sessions to a chroot jail</li><li class="listitem" style="list-style-type: disc">Configuring TigerVNC</li><li class="listitem" style="list-style-type: disc">Tunneling VNC connections through SSH</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Introduction</h1></div></div></div><p>The recipes in this chapter will help you provide remote access to your CentOS system in a security-conscious way. You'll learn how to execute commands on a remote system through SSH, configure the OpenSSH SSH server to increase security surrounding remote logins, and use key-based authentication to connect. You'll also learn how to allow or deny access to different users, configure Fail2ban to automatically block suspected IP addresses to protect your server from brute force attacks better, and restrict users to a chroot jail once they've logged in. The concluding recipes show you how to provide remote access to a complete desktop environment using VNC, and how to secure that access by tunneling VNC traffic through an SSH tunnel.</p></div></div>
<div class="section" title="Running commands remotely through SSH"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Running commands remotely through SSH</h1></div></div></div><p>This recipe shows you how to execute one-shot commands on a remote system through <span class="strong"><strong>Secure Shell</strong></span> (<span class="strong"><strong>SSH</strong></span>). Having the ability to run commands without establishing a full interactive session can be convenient because you can avoid running a second terminal; everything can be done directly from the same command line.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec149"/>Getting ready</h2></div></div></div><p>This recipe requires a remote system running the OpenSSH server and a local computer with the OpenSSH SSH client installed (both should be installed by default on CentOS). The examples assume that the remote system is configured with the IP address <code class="literal">192.168.56.100</code>. Also, you will need a user account available on the remote system.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec150"/>How to do it...</h2></div></div></div><p>The following examples show you how to run commands on a remote system from your local system through SSH:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To execute a command remotely, use <code class="literal">ssh</code> and specify the hostname or IP address of the target system followed by the command and its arguments:<pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100 uname -a</strong></span>
</pre></li><li class="listitem" style="list-style-type: disc">To execute the command as a different user, provide a username with the remote system's address:<pre class="programlisting">
<span class="strong"><strong>ssh tboronczyk@192.168.56.100 id -un</strong></span>
</pre></li><li class="listitem" style="list-style-type: disc">If the remote command requires <code class="literal">sudo</code>, supply <code class="literal">ssh</code> with the <code class="literal">-t</code> argument:<pre class="programlisting">
<span class="strong"><strong>ssh -t 192.168.56.100 sudo mount /mnt</strong></span>
</pre></li><li class="listitem" style="list-style-type: disc">Use the <code class="literal">-X</code> argument to forward the remote system's X11 display to execute a graphical program:<pre class="programlisting">
<span class="strong"><strong>ssh -X 192.168.56.100 gnome-calculator</strong></span>
</pre></li><li class="listitem" style="list-style-type: disc">Use quotes when you execute a complex command, for example, a series of commands or when using I/O redirection. This avoids ambiguity between the local and remote shells:<pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100 "tar tvzf archive.tgz &gt; contents.txt"</strong></span>
</pre></li><li class="listitem" style="list-style-type: disc">You can pipe input from the local system to remote commands that read from stdin:<pre class="programlisting">
<span class="strong"><strong>cat foo.txt | ssh 192.168.56.100 "cat &gt; foo.txt"</strong></span>
</pre></li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec151"/>How it works...</h2></div></div></div><p><code class="literal">ssh</code> is used mainly to log in to a remote system and access an interactive shell because it's possible that many people don't know that commands can be executed remotely without a shell. This recipe presented several examples that illustrate how you can use <code class="literal">ssh</code> to run remote commands, each of which follow this general invocation pattern:</p><pre class="programlisting">
<span class="strong"><strong>ssh [options] [user@]host command</strong></span>
</pre><p>Anything provided after the remote host is accepted as the command to execute remotely by <code class="literal">ssh</code> as demonstrated in the following two examples. The first invokes <code class="literal">uname</code> to print information about the remote system such as the kernel, processor, and operating system, and the second runs <code class="literal">id</code> to display the username of the current effective user ID:</p><pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100 uname -a</strong></span>
<span class="strong"><strong>ssh tboronczyk@192.168.56.100 id -un</strong></span>
</pre><p><code class="literal">ssh</code> doesn't launch an interactive shell when running these commands as there's no reason for it to allocate a tty/pseudo-terminal; it acts as the shell itself and routes input and output between the remote and local systems. However, some commands require a terminal to function properly. For example, <code class="literal">sudo</code> uses the terminal to ensure the user's password isn't printed on the screen as they type it. Without a terminal, <code class="literal">sudo</code> refuses to run and reports back that <code class="literal">you must have a tty to run sudo</code>. We can provide the <code class="literal">-t</code> argument when executing such commands to force <code class="literal">ssh</code> to allocate a remote terminal resource:</p><pre class="programlisting">
<span class="strong"><strong>ssh -t 192.168.56.100 sudo mount /mnt</strong></span>
</pre><p>The <code class="literal">-X</code> argument forwards the X11 display and allows us to run graphical programs. The program appears as if it were running in our local desktop environment, although in reality it's running on the remote system:</p><pre class="programlisting">
<span class="strong"><strong>ssh -X 192.168.56.100 "gnome-calculator"</strong></span>
</pre><div class="mediaobject"><img alt="How it works..." src="graphics/image_06_001.jpg"/><div class="caption"><p>Graphical applications can be run using X11 forwarding</p></div></div><p>To make sure an invocation is interpreted how you intend, you may need to quote commands. This is especially true when using I/O redirection or when you are running multiple commands. To see why, consider the following example:</p><pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100 "tar tvzf archive.tgz &gt; contents.txt"</strong></span>
</pre><p><code class="literal">tar</code> outputs a list of files in the archive which is then redirected to create the <code class="literal">contents.txt</code> file. Everything happens remotely—<code class="literal">tar</code> runs on the remote system and the new file is created on the remote system.</p><p>Now, here's the same invocation but without quoting:</p><pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100 tar tvzf archive.tgz &gt; contents.txt</strong></span>
</pre><p><code class="literal">tar</code> still executes remotely, but the local shell interprets the redirect and <code class="literal">contents.txt</code> is created on the local system.</p><p>I/O redirection is possible in both directions. That is, we can pipe input from the local system to the remote system's stdin:</p><pre class="programlisting">
<span class="strong"><strong>cat foo.txt | ssh 192.168.56.100 "cat &gt; foo.txt"</strong></span>
</pre><p>In this example, <code class="literal">foo.txt</code> is read by <code class="literal">cat</code> and the contents are piped to the remote system. There, a remotely running instance of <code class="literal">cat</code> will be waiting to read the input. When it detects the end of the transmission, <code class="literal">cat</code> outputs what it received, which is then redirected to create <code class="literal">foo.txt</code> on the remote system. In essence, we've just made a copy of <code class="literal">foo.txt</code> from the local system to the remote system.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec152"/>See also</h2></div></div></div><p>Refer to the following resources for more information on running commands remotely through SSH:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">ssh</code> manual page (<code class="literal">man 1 ssh</code>)</li><li class="listitem" style="list-style-type: disc">Piping with SSH (<a class="ulink" href="http://linux.icydog.net/ssh/piping.php">http://linux.icydog.net/ssh/piping.php</a>)</li><li class="listitem" style="list-style-type: disc">Commandlinefu.com SSH commands (<a class="ulink" href="http://www.commandlinefu.com/commands/matching/ssh/c3No/sort-by-votes">http://www.commandlinefu.com/commands/matching/ssh/c3No/sort-by-votes</a>)</li></ul></div></div></div>
<div class="section" title="Configuring a more secure SSH login"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Configuring a more secure SSH login</h1></div></div></div><p>SSH is considered a secure alternative to older protocols, such as Telnet, rsh, and rlogin, because it encrypts the connection between the client and server. This encryption protects the traffic from any ne'er-do-wells who may be eavesdropping on the network. However, your system can still fall victim to the denial of service attacks or a malicious user who takes advantage of an idle session that was carelessly left unattended. This recipe takes the first steps in hardening SSH by updating the server's configuration to increase security surrounding remote logins.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec153"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system running the OpenSSH server. Administrative privileges are also required, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec154"/>How to do it...</h2></div></div></div><p>Follow these steps to increase the security of your SSH logins:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the SSH server's configuration file with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/ssh/sshd_config</strong></span>
</pre></li><li class="listitem">Locate the <code class="literal">LoginGraceTime</code> option. Uncomment it and change its value to <code class="literal">30</code> seconds to limit the amount of time users are given to provide their credentials:<pre class="programlisting">
<span class="strong"><strong>LoginGraceTime 30</strong></span>
</pre></li><li class="listitem">Find and uncomment the <code class="literal">PrintLastLog</code> option and change its value to <code class="literal">yes</code> to show the user the time and location of their last login:<pre class="programlisting">
<span class="strong"><strong>PrintLastLog yes</strong></span>
</pre></li><li class="listitem">Uncomment the <code class="literal">Banner</code> option and set its value to <code class="literal">/etc/banner</code> to display a login warning to users:<pre class="programlisting">
<span class="strong"><strong>Banner /etc/banner</strong></span>
</pre></li><li class="listitem">Save your changes and close the configuration file.</li><li class="listitem">Create the <code class="literal">/etc/banner</code> file with the following (or similar) verbiage:<pre class="programlisting">
<span class="strong"><strong>This computer system is for authorized use only. All  activity is &#13;
logged and monitored. Users accessing this  system without &#13;
authority, or in excess of their authority,  may be subject to &#13;
criminal, civil, and administrative  action. Continuing to use &#13;
this system indicates your consent to these terms and conditions &#13;
of use.</strong></span>
</pre></li><li class="listitem">Restart the SSH server for the configuration changes to take effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart sshd.service</strong></span>
</pre></li><li class="listitem">To automatically log out sessions after 10 minutes of inactivity, create the <code class="literal">/etc/profile.d/timeout.sh</code> file with the following:<pre class="programlisting">
<span class="strong"><strong>export TMOUT=600</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec155"/>How it works...</h2></div></div></div><p>The first option we adjusted in the SSH server's configuration file was <code class="literal">LoginGraceTime</code>, to determine how long a user is allowed to enter their username and password. By default, the connection attempt times out if the user doesn't provide their credentials within two minutes. We reduced this time to <code class="literal">30</code> seconds, but you can set a more appropriate value if you find this not to be long enough:</p><pre class="programlisting">
<span class="strong"><strong>LoginGraceTime 30</strong></span>
</pre><p>Then, setting the <code class="literal">PrintLastLog</code> option's value to <code class="literal">yes</code> causes the time and location of the user's last log in to be displayed. This is helpful because an unknown time or location can alert a user if their account has been compromised and is being used for unauthorized access:</p><pre class="programlisting">
<span class="strong"><strong>PrintLastLog yes</strong></span>
</pre><p>Next, we configured a login banner. A strongly-worded warning isn't likely to deter a malicious user, but many organizations require them to be prominently displayed when a user logs in for legal reasons. Such messages are considered to be sufficient notification in some jurisdictions to inform users that their actions are monitored and they should have no expectations of privacy for what they do on the system. This gives the organization better legal standing to prosecute any abuse.</p><p>To display the warning before the login prompt, we set <code class="literal">Banner</code> with the path to a file containing our message. Then we created the file with the desired text:</p><pre class="programlisting">
<span class="strong"><strong>Banner /etc/banner</strong></span>
</pre><div class="mediaobject"><img alt="How it works..." src="graphics/image_06_002.jpg"/><div class="caption"><p>The user is presented with a banner message before logging in to the remote system</p></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p><code class="literal">nroff</code> can be used to justify the banner's text:</p><p>
</p><p><code class="literal">
<code class="literal">
<span class="strong"><strong>(echo -e ".ll 75\n.pl 0\n.nh"; cat) | nroff &gt; /etc/banner</strong></span>
</code>
</code> </p><p>
</p><p><code class="literal">cat</code> reads text from stdin (press <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> + <span class="emphasis"><em>
<span class="strong"><strong>D</strong></span>
</em></span> when you're finished) and both the echo'd instructions and the text are piped to <code class="literal">nroff</code> for formatting.</p><p>
</p><p> <code class="literal">.ll</code> tells <code class="literal">nroff</code> to set the line length at <code class="literal">75</code> characters. It's a good idea to use a value less than <code class="literal">80</code> because the traditional terminal displays <code class="literal">80</code> characters per line.</p><p>
</p><p><code class="literal">.pl</code> sets the page length, and setting it <code class="literal">0</code> prevents <code class="literal">nroff</code> from adding additional whitespace after the text in an attempt to fill the length of some imaginary printed page.</p><p>
</p><p><code class="literal">.nh</code> prevents <code class="literal">nroff</code> from hyphenating words at the end of a line.</p></div></div><p>If you want to display the banner after the user logs in instead of before, you can use the message of the day file instead. In this case, uncomment the <code class="literal">PrintMotd</code> option and set its value to <code class="literal">yes</code> and then save your text in <code class="literal">/etc/motd</code>.</p><p>Finally, we created the <code class="literal">/etc/profile.d/timeout.sh</code> file to set the <code class="literal">TMOUT</code> environment variable. Setting <code class="literal">TMOUT</code> under <code class="literal">/etc/profile.d</code> applies it globally to all users when they log in. To target individual users instead, or if you want to override the global value for specific users, you can place the export in their <code class="literal">~/.bash_profile</code> file:</p><pre class="programlisting">
<span class="strong"><strong>export TMOUT=600</strong></span>
</pre><p>Now with the variable set, bash automatically closes the user's session if it's been inactive for the specified amount of time with the message <code class="literal">timed out waiting for input: auto-logout</code>. The value is given in seconds, with the recipe's example closing idle sessions after 10 minutes.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec156"/>See also</h2></div></div></div><p>Refer to the following resources for more information on tightening security on SSH logins:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">sshd_config</code> manual page (<code class="literal">man 5 sshd_config</code>)</li><li class="listitem" style="list-style-type: disc">RHEL 7 System Administrator's Guide: OpenSSH (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/ch-OpenSSH.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/ch-OpenSSH.html</a>)</li><li class="listitem" style="list-style-type: disc">CentOS Wiki: Securing OpenSSH (<a class="ulink" href="https://wiki.centos.org/HowTos/Network/SecuringSSH">https://wiki.centos.org/HowTos/Network/SecuringSSH</a>)</li><li class="listitem" style="list-style-type: disc">Should I use a login banner? (<a class="ulink" href="http://serverfault.com/questions/24376/should-i-use-a-login-banner-and-if-so-what-should-it-say">http://serverfault.com/questions/24376/should-i-use-a-login-banner-and-if-so-what-should-it-say</a>)</li></ul></div></div></div>
<div class="section" title="Securely connecting to SSH without a password"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Securely connecting to SSH without a password</h1></div></div></div><p>This recipe teaches you how to generate a key pair and set up key-based authentication for SSH sessions, allowing you to secretly connect to a remote system without using a password. Key-based authentication is considered more secure than using a password because a weak password can be easy to guess and a strong password can be easy to forget and more likely to be written down. In either case, an attacker has a fairly good chance of discovering a user's password. With key-based authentication, a user must supply the correct private key file, which is practically impossible to crack or spoof.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec157"/>Getting ready</h2></div></div></div><p>This recipe requires a remote system running the OpenSSH server and a local computer with the OpenSSH SSH client installed. Its examples assume that the remote system is configured with the IP address <code class="literal">192.168.56.100</code>. Also, you will need an available user account on the remote system.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec158"/>How to do it...</h2></div></div></div><p>Follow these steps to set up key-based authentication for SSH sessions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On the local computer, use the <code class="literal">ssh-keygen</code> command to create a pair of authentication keys. Accept the default path/filename for the keys and leave the passphrase empty:<pre class="programlisting">
<span class="strong"><strong>ssh-keygen -b 3072 -C "Timothy Boronczyk"</strong></span>
</pre></li><li class="listitem">Create the <code class="literal">.ssh</code> directory if it doesn't already exist in your remote home directory:<pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100 "mkdir -m 700 .ssh"</strong></span>
</pre></li><li class="listitem">Append the contents of <code class="literal">id_rsa.pub</code> to <code class="literal">.ssh/authorized_keys</code> on the remote system:<pre class="programlisting">
<span class="strong"><strong>cat .ssh/id_rsa.pub | ssh 192.168.56.100 "cat &gt;&gt;  &#13;
       .ssh/authorized_keys"</strong></span>
</pre></li><li class="listitem">Secure the <code class="literal">authorized_keys</code> file's permissions:<pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100 "chmod 640 .ssh/authorized_keys"</strong></span>
</pre></li><li class="listitem">Verify that you can connect to the remote system without providing a password:<pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100</strong></span>
</pre></li><li class="listitem">Repeat steps 2 through 5 for any additional remote systems you want to log in to using key-based authentication.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec159"/>How it works...</h2></div></div></div><p>Key-based authentication is considered more secure than using passwords because it's nearly impractical to crack a suitable encryption key while brute forcing a password is trivial. This recipe used the OpenSSH suite's <code class="literal">ssh-keygen</code> program to generate a new pair of keys, which we then used to authenticate our SSH session:</p><pre class="programlisting">
<span class="strong"><strong>ssh-keygen -b 3072 -C "Timothy Boronczyk"</strong></span>
</pre><p><code class="literal">-C</code> embeds a brief comment in the key which is useful for identifying the owner or purpose of a key and <code class="literal">-b</code> sets the number of bits used for the key's modulus. The more bits used, the larger the number that can be represented, which means greater resistance to cracking attacks. If <code class="literal">-b</code> isn't provided, the default value is 2,048 bits. Based on the estimates of the rate at which computing power increases, 2,048 is generally thought to be suitable until around the year 2030 (researchers developed a successful attack against 1,024-bit keys in 2010). A 3,072-bit key is considered suitable beyond 2030.</p><p>We accepted the suggested <code class="literal">~/.ssh/id_rsa</code> value as the name of the output file when prompted (this is where <code class="literal">ssh</code> looks for our private identity key by default when we connect to a remote server). We also didn't provide a passphrase. If we were to give one, then the key would be encrypted and we'd need to provide the password to decrypt the key every time we wanted to use it.</p><p>When <code class="literal">ssh-keygen</code> is finished, the private key <code class="literal">id_rsa</code> and the public key <code class="literal">id_rsa.pub</code> can be found in the <code class="literal">.ssh</code> directory:</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_06_003.jpg"/><div class="caption"><p>The pair of keys is generated for password-less authentication</p></div></div><p>Then, we created the <code class="literal">.ssh</code> directory in our home directory on the remote system. You can execute the <code class="literal">mkdir</code> command while being logged in to the remote system, otherwise you can execute the command remotely through SSH:</p><pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100 "mkdir -m 700 .ssh"</strong></span>
</pre><p>Next, we added the public key to <code class="literal">.ssh/authorized_keys</code> on the remote system:</p><pre class="programlisting">
<span class="strong"><strong>cat .ssh/id_rsa.pub | ssh 192.168.56.100 "cat &gt;&gt;  .ssh/authorized_keys"</strong></span>
</pre><p>Because proper permissions help ensure the security of your keys, <code class="literal">ssh</code> won't consider them safe to use if the permissions are too lax. The permissions on the <code class="literal">.ssh</code> directory should be read, write, and execute permissions only for the owner (<code class="literal">700</code>), read permissions for the owner and group, and write permissions for the owner (<code class="literal">640</code>) on <code class="literal">authorized_keys</code>. A simple <code class="literal">chmod</code> call ensures that everything is correct:</p><pre class="programlisting">
<span class="strong"><strong>ssh 192.168.56.100 "chmod 640 .ssh/authorized_keys"</strong></span>
</pre><p>When we connect, <code class="literal">ssh</code> sees the <code class="literal">id_rsa</code> file and sends our private key as part of the connection request. The server checks for the corresponding public key in the <code class="literal">authorized_keys</code> file, and if everything matches up then we're authorized and logged in.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec160"/>See also</h2></div></div></div><p>Refer to the following resources for more information on using key-based authentication with OpenSSH:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">RHEL 7 System Administrator's Guide: OpenSSH (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/ch-OpenSSH.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/ch-OpenSSH.html</a>)</li><li class="listitem" style="list-style-type: disc">SSH password versus key authentication (<a class="ulink" href="http://security.stackexchange.com/questions/33381/ssh-password-vs-key-authentication">http://security.stackexchange.com/questions/33381/ssh-password-vs-key-authentication</a>)</li></ul></div></div></div>
<div class="section" title="Restricting SSH access by user or group"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Restricting SSH access by user or group</h1></div></div></div><p>Depending on the role of your system and which user accounts are configured on it, you may not want all of its registered users to have access through SSH. This recipe shows you how to configure the SSH server to restrict remote user access by explicitly granting or denying the users access.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec161"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system running the OpenSSH server. Administrative privileges are also required, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec162"/>How to do it...</h2></div></div></div><p>Follow these steps to restrict users' SSH access:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the SSH server's configuration file with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/ssh/sshd_config</strong></span>
</pre></li><li class="listitem">Find the <code class="literal">PermitEmptyPasswords</code> option. Uncomment it and set its value to <code class="literal">no</code> to disallow accounts with empty passwords:<pre class="programlisting">
<span class="strong"><strong>PermitEmptyPasswords no</strong></span>
</pre></li><li class="listitem">To disallow remote access with the <code class="literal">root</code> account, locate and uncomment the <code class="literal">PermitRootLogin</code> option and set its value to <code class="literal">no</code>:<pre class="programlisting">
<span class="strong"><strong>PermitRootLogin no</strong></span>
</pre></li><li class="listitem">Deny remote access for specific user accounts by adding an entry for <code class="literal">DenyUsers</code>. The option's value should be a space-separated list of usernames you want to deny:<pre class="programlisting">
<span class="strong"><strong>DenyUsers bbarrera jbhuse mbutterfield</strong></span>
</pre></li><li class="listitem">Deny remote access for users who are members of a specific group by adding an entry for <code class="literal">DenyGroups</code>:<pre class="programlisting">
<span class="strong"><strong>DenyGroups users noremote</strong></span>
</pre></li><li class="listitem">Add an <code class="literal">AllowUsers</code> entry to deny access to everyone except those in the list of permitted users:<pre class="programlisting">
<span class="strong"><strong>AllowUsers abell tboronczyk</strong></span>
</pre></li><li class="listitem">Add an <code class="literal">AllowGroups</code> entry to deny access to everyone except those in the list of permitted groups:<pre class="programlisting">
<span class="strong"><strong>AllowGroups itadmin remote</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Restart the SSH server for the changes to take effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart sshd.service</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec163"/>How it works...</h2></div></div></div><p>First, we uncommented <code class="literal">PermitEmptyPasswords</code> and set its value to <code class="literal">no</code>. This prevents user accounts that don't have a password from being used to log in over SSH:</p><pre class="programlisting">
<span class="strong"><strong>PermitEmptyPasswords no</strong></span>
</pre><p>Passwords are the first level of defense in protecting ourselves from malicious attacks using compromised user accounts. Without a strong password, anyone can log in simply by knowing the username. This is a scary thought because usernames can be easily guessed and sometimes are even publicly available in the form of e-mail addresses and so on.</p><p>Next, we uncommented the <code class="literal">PermitRootLogin</code> option and set its value to <code class="literal">no</code>. This prevents <code class="literal">root</code> from establishing an SSH session directly:</p><pre class="programlisting">
<span class="strong"><strong>PermitRootLogin no</strong></span>
</pre><p>Such restrictions were of critical importance when protocols such as Telnet were used because the username and password were often sent across the network in plain text—an attacker could easily monitor the network traffic and capture the password. However, even though SSH makes this concern moot by encrypting its traffic, the password is still vulnerable from brute force cracking attacks. For this reason, it's wise to require users to authenticate using their unprivileged account first and then use <code class="literal">su</code> or <code class="literal">sudo</code> to elevate their privileges when necessary (refer to <a class="link" href="ch03.html" title="Chapter 3. User and Permission Management">Chapter 3</a>, <span class="emphasis"><em>User and Permission Management</em></span>).</p><p>The recipe then presented the <code class="literal">DenyUsers</code>, <code class="literal">DenyGroups</code>, <code class="literal">AllowUsers</code>, and <code class="literal">AllowGroups</code> options as a way to restrict SSH access on a larger scale.</p><p>The <code class="literal">DenyUsers</code> option prohibits specific users from logging in. While other user accounts will be able to access the system remotely, the users listed under <code class="literal">DenyUsers</code> will see the message <code class="literal">Permission Denied</code>. The recipe's example denies access to the users <code class="literal">bbarrera</code>, <code class="literal">jbhuse</code>, and <code class="literal">mbutterfield</code>:</p><pre class="programlisting">
<span class="strong"><strong>DenyUsers bbarrera jbhuse mbutterfield</strong></span>
</pre><p>The <code class="literal">DenyGroups</code> option works similarly, but denies users based on their group membership; the following example denies access to anyone who's a member of the <code class="literal">users</code> group or the <code class="literal">noremote</code> group:</p><pre class="programlisting">
<span class="strong"><strong>DenyGroups users noremote</strong></span>
</pre><p>The denial options are useful for blacklisting a small number of users. To block all users except for a select few, we use the allow options. <code class="literal">AllowUsers</code> denies access to everyone except those specified. <code class="literal">AllowGroups</code> is its counterpart allowing only those users who are members of the specified group:</p><pre class="programlisting">
<span class="strong"><strong>AllowUsers abell tboronczyk</strong></span>
<span class="strong"><strong>AllowGroups itadmin remote</strong></span>
</pre><p>The options can also have values that use <code class="literal">*</code> and <code class="literal">?</code> as wildcards. <code class="literal">*</code> matches zero or more characters and <code class="literal">?</code> matches a single character. For example, the following denies all users:</p><pre class="programlisting">
<span class="strong"><strong>DenyUsers *</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p><code class="literal">AllowUsers</code> and <code class="literal">AllowGroups</code> deny all users/groups except the ones they list. Be careful if you depend on SSH to administer your servers because it's very easy to block yourself with these. Before logging out of your current SSH session, check that you can successfully log in using a second terminal. If there's a problem, you'll still be logged in with the first session and will able to fix the issue.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec164"/>See also</h2></div></div></div><p>Refer to the following for more information on restricting remote SSH access:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">sshd_config</code> manual page (<code class="literal">man 5 sshd_config</code>)</li><li class="listitem" style="list-style-type: disc">RHEL 7 System Administrator's Guide: OpenSSH (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/ch-OpenSSH.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/ch-OpenSSH.html</a>)</li><li class="listitem" style="list-style-type: disc">SSH how to deny all users except for one? (<a class="ulink" href="http://www.linuxquestions.org/questions/linux-security-4/howto-sshd-deny-all-users-except-for-one-368752/">http://www.linuxquestions.org/questions/linux-security-4/howto-sshd-deny-all-users-except-for-one-368752/</a>)</li></ul></div></div></div>
<div class="section" title="Protecting SSH with Fail2ban"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Protecting SSH with Fail2ban</h1></div></div></div><p>A determined attacker may try to brute force a user's password to gain access or attempt repeated logins to consume network and system resources as part of a denial of service attack. Fail2ban can help protect you from such attacks by monitoring a server's log files, identifying suspicious activity, and automatically banning the IP addresses responsible for the activity. This recipe teaches you how to install Fail2ban to safeguard your system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec165"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system running the OpenSSH server. Administrative privileges are also required, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>. The <code class="literal">fail2ban</code> package is hosted by the EPEL repository; if the repository is not already registered, refer to the <span class="emphasis"><em>Registering the EPEL and Remi repositories</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Software Installation Management">Chapter 4</a>, <span class="emphasis"><em>Software Installation Management</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec166"/>How to do it...</h2></div></div></div><p>Follow these steps to protect your system with Fail2ban:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">fail2ban</code> package:<pre class="programlisting">
<span class="strong"><strong>yum install fail2ban</strong></span>
</pre></li><li class="listitem">Create the jail configuration file <code class="literal">/etc/fail2ban/jail.local</code> using the following contents:<pre class="programlisting">
<span class="strong"><strong>[sshd]</strong></span>
<span class="strong"><strong>enabled=true</strong></span>
<span class="strong"><strong>bantime=86400</strong></span>
<span class="strong"><strong>maxretry=5</strong></span>
</pre></li><li class="listitem">Start the Fail2ban service and enable its automatic start-up when the system boots:<pre class="programlisting">
<span class="strong"><strong>systemctl start fail2ban.service</strong></span>
<span class="strong"><strong>systemctl enable fail2ban.service</strong></span>
</pre></li><li class="listitem">To view the <code class="literal">sshd</code> jail's status, use <code class="literal">fail2ban-client</code> with the <code class="literal">status</code> command:<pre class="programlisting">
<span class="strong"><strong>fail2ban-client status sshd</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec167"/>How it works...</h2></div></div></div><p>You've learned how to install Fail2ban and configure automated IP blocking after several failed login attempts. You also learned how to manually ban and unban addresses using <code class="literal">fail2ban-client</code>.</p><p>A Fail2ban jail configuration brings together filter and action definitions to perform an activity whenever certain patterns are observed in a server's log file. Filters specify the pattern definitions for identifying interesting log entries, for example, repeated authentication failures. Actions, on the other hand, define the commands that run when a filter is matched. Fail2ban is shipped with several predefined filters for common servers such as Apache, MySQL, Sendmail, and SSH, and several predefined actions such as managing iptable entries to block and unblock IP addresses, sending e-mail notifications, and triggering DNS updates.</p><p>There are several jails defined in <code class="literal">/etc/fail2ban/jail.conf</code>. To activate the <code class="literal">sshd</code> jail, we created the <code class="literal">jail.local</code> file with entries that override and extend the default jail definition:</p><pre class="programlisting">
<span class="strong"><strong>[sshd]</strong></span>
<span class="strong"><strong>enabled=true</strong></span>
<span class="strong"><strong>bantime=86400</strong></span>
<span class="strong"><strong>maxretry=5</strong></span>
</pre><p>Intuitively, the <code class="literal">enabled</code> option enables or disables the jail. <code class="literal">maxretry</code>, which we set to <code class="literal">5</code>, is the number of failed login attempts permitted before Fail2ban enacts the ban. <code class="literal">bantime</code> sets how long the ban will last, which we set to <code class="literal">86400</code> seconds. With this configuration, users are allowed up to <code class="literal">5</code> failed attempts before their IP address is banned for 24 hours.</p><p>The existing definition from <code class="literal">jail.conf</code> already identifies the default port and the log file location. If you're running SSH on a nonstandard port, you can override the original definition's setting using <code class="literal">port</code>. The location of the SSH's log file can be overridden with <code class="literal">logfile</code>.</p><p><code class="literal">fail2ban-client</code> is used to interact with the Fail2ban service. Its <code class="literal">status</code> command outputs information about the service's current state, and if <code class="literal">status</code> is followed by a jail name then status information about the jail is returned instead. Perhaps of particular interest in the jail's status is a list of IP addresses that have been banned:</p><pre class="programlisting">
<span class="strong"><strong>fail2ban-client status sshd</strong></span>
</pre><div class="mediaobject"><img alt="How it works..." src="graphics/image_06_004.jpg"/><div class="caption"><p>The jail's status output presents the list of banned addresses</p></div></div><p>The client also has <code class="literal">get</code> and <code class="literal">set</code> commands to inspect and update various properties of the running service. For example, <code class="literal">get sshd bantime</code> returns the configured ban duration. <code class="literal">set sshd bantime</code> temporarily updates the duration until the service is restarted.</p><p>You can manually ban an IP address by setting the jail's <code class="literal">banip</code> property:</p><pre class="programlisting">
<span class="strong"><strong>fail2ban-client set sshd banip 10.25.30.107</strong></span>
</pre><p>To manually unban an address, set <code class="literal">unbanip</code>:</p><pre class="programlisting">
<span class="strong"><strong>fail2ban-client set sshd unbanip 10.25.30.107</strong></span>
</pre><p>Being able to manually unban addresses is important in case a legitimate address is banned for some reason. If there are addresses that should never be blocked, perhaps a test integration server executing failed logins on purpose, or perhaps an administrator's computer, you can identify them using the <code class="literal">ignoreip</code> option in your <code class="literal">jail.local</code> configuration file and Fail2ban will avoid banning those addresses:</p><pre class="programlisting">
<span class="strong"><strong>ignoreip=10.25.30.107</strong></span>
</pre></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec168"/>See also</h2></div></div></div><p>Refer to the following resources for more information on Fail2ban:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">fail2ban-client</code> manual page (<code class="literal">man 1 fail2ban-client</code>)</li><li class="listitem" style="list-style-type: disc">Fail2ban Wiki (<a class="ulink" href="http://www.fail2ban.org/wiki/index.php/Main_Page">http://www.fail2ban.org/wiki/index.php/Main_Page</a>)</li><li class="listitem" style="list-style-type: disc">Permanently ban repeat offenders with Fail2ban (<a class="ulink" href="http://stuffphilwrites.com/2013/03/permanently-ban-repeat-offenders-fail2ban/">http://stuffphilwrites.com/2013/03/permanently-ban-repeat-offenders-fail2ban/</a>)</li><li class="listitem" style="list-style-type: disc">Monitoring the Fail2ban log (<a class="ulink" href="http://www.the-art-of-web.com/system/fail2ban-log/">http://www.the-art-of-web.com/system/fail2ban-log/</a>)</li></ul></div></div></div>
<div class="section" title="Confining sessions to a chroot jail"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Confining sessions to a chroot jail</h1></div></div></div><p>This recipe teaches you how to set up a chroot jail. A chroot call changes the user's view of the filesystem hierarchy by setting a particular path as the root; for the user, the path appears as <code class="literal">/</code> and they are unable to traverse beyond it. This creates a sandbox or jail, confining the user to a small branch of the real hierarchy. Chroot jails are commonly used for security purposes, for example, user containment and honeypots and also for application testing and in recovery procedures.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec169"/>Getting ready</h2></div></div></div><p>This recipe requires a CentOS system running the OpenSSH server. Administrative privileges are also required, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec170"/>How to do it...</h2></div></div></div><p>Follow these steps to configure a chroot jail and confine users to it:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the <code class="literal">cpchroot</code> script needed to copy commands and their dependencies into the chroot environment:<pre class="programlisting">
<span class="strong"><strong>curl -Lo ~/cpchroot tinyurl.com/zyzozdp</strong></span>
</pre></li><li class="listitem">Make the script executable using <code class="literal">chmod</code>:<pre class="programlisting">
<span class="strong"><strong>chmod +x ~/cpchroot</strong></span>
</pre></li><li class="listitem">Create the <code class="literal">/jail</code> directory and its subdirectories to mimic a root filesystem:<pre class="programlisting">
<span class="strong"><strong>mkdir -p /jail/{dev,home,usr/{bin,lib,lib64,share}}</strong></span>
<span class="strong"><strong>cd /jail</strong></span>
<span class="strong"><strong>ln -s usr/bin bin</strong></span>
<span class="strong"><strong>ln -s usr/lib lib</strong></span>
<span class="strong"><strong>ln -s usr/lib64 lib64</strong></span>
</pre></li><li class="listitem">Execute the <code class="literal">chroot</code> script to copy the desired programs and commands:<pre class="programlisting">
<span class="strong"><strong>~/cpchroot /jail bash cat cp find grep less ls   &#13;
       mkdir mv pwd rm rmdir</strong></span>
</pre></li><li class="listitem">Copy the <code class="literal">terminfo</code> database:<pre class="programlisting">
<span class="strong"><strong>cp -R /usr/share/terminfo /jail/usr/share</strong></span>
</pre></li><li class="listitem">Create the special device files under <code class="literal">/jail/dev</code> using <code class="literal">mknod</code>:<pre class="programlisting">
<span class="strong"><strong>cd /jail/dev</strong></span>
<span class="strong"><strong>mknod null c 1 3</strong></span>
<span class="strong"><strong>mknod zero c 1 5</strong></span>
<span class="strong"><strong>mknod random c 1 8</strong></span>
</pre></li><li class="listitem">Create a group for chroot'd users:<pre class="programlisting">
<span class="strong"><strong>groupadd sandbox</strong></span>
</pre></li><li class="listitem">Open the <code class="literal">/etc/ssh/sshd_config</code> file with your text editor and add the following to the end of the file:<pre class="programlisting">
<span class="strong"><strong>       Match Group sandbox&#13;
           ChrootDirectory /jail&#13;
</strong></span>
</pre></li><li class="listitem">Save your changes and close the configuration file.</li><li class="listitem">Restart the SSH server for the changes to take effect:<pre class="programlisting">
<span class="strong"><strong>systemctl restart sshd.service</strong></span>
</pre></li></ol></div><p>To create a new chroot'd user, create the user with <code class="literal">useradd</code> and assign them to the <code class="literal">sandbox</code> group:</p><pre class="programlisting">
<span class="strong"><strong>useradd -s /bin/bash -m -G sandbox rdiamond</strong></span>
</pre><p>Then, move their <code class="literal">home</code> directory to reside under the chroot <code class="literal">jail</code>:</p><pre class="programlisting">
<span class="strong"><strong>mv /home/rdiamond /jail/home</strong></span>
</pre><p>To chroot an existing user, assign them to the <code class="literal">sandbox</code> group and move their <code class="literal">home</code> directory to the <code class="literal">jail</code>:</p><pre class="programlisting">
<span class="strong"><strong>usermod -G sandbox bbarrera</strong></span>
<span class="strong"><strong>mv /home/bbarrera /jail/home</strong></span>
</pre></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec171"/>How it works...</h2></div></div></div><p>Identifying and copying dependencies is tedious and error-prone if done manually. So, I've written a helper script to automate the process of finding and cloning programs with their dependencies into the jail. Our first steps were to download the script using <code class="literal">curl</code> and then make it executable using <code class="literal">chmod</code>:</p><pre class="programlisting">
<span class="strong"><strong>curl -Lo ~/cpchroot tinyurl.com/zyzozdp</strong></span>
<span class="strong"><strong>chmod +x ~/cpchroot</strong></span>
</pre><p>The script is hosted on GitHub, but its direct URL was prohibitively long so I used a URL-shortening service to shorten the address. We need to provide <code class="literal">-L</code> for <code class="literal">curl</code> to follow any redirects (the service responds with a redirect to GitHub) and <code class="literal">-o</code> sets the name of the download, in this case <code class="literal">cpchroot</code>, in your <code class="literal">home</code> directory.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>If you're having problems because of the URL-shortening service, you can find the direct link by visiting <a class="ulink" href="https://gist.github.com/tboronczyk/00d77b1baafd13daab3b">https://gist.github.com/tboronczyk/00d77b1baafd13daab3b</a>, clicking on the <span class="strong"><strong>Raw</strong></span> button, and then copying the URL that appears in your browser's address bar.</p></div></div><p>Next, we created the <code class="literal">/jail</code> directory containing a directory structure that mimics the root filesystem. When a user logs in and is chroot'd, they and everything they do will be contained to <code class="literal">/jail</code>. They will not be able to traverse outside that directory, so we need to replicate the directory layout the programs expect:</p><pre class="programlisting">
<span class="strong"><strong>mkdir -p /jail/{dev,home,usr/{bin,lib,lib64,share}}</strong></span>
<span class="strong"><strong>cd /jail</strong></span>
<span class="strong"><strong>ln -s usr/bin bin</strong></span>
<span class="strong"><strong>ln -s usr/lib lib</strong></span>
<span class="strong"><strong>ln -s usr/lib64 lib64</strong></span>
</pre><p>We used <code class="literal">mkdir</code> with the <code class="literal">-p</code> option and took advantage of shell expansion to create most of the layout with a single command. CentOS sets up its top-level <code class="literal">/bin</code>, <code class="literal">/lib</code>, and <code class="literal">/lib64</code> directories as symbolic links to the corresponding directories under <code class="literal">/usr</code>, which we duplicated using <code class="literal">ln</code> within the <code class="literal">/jail</code> directory. The final layout looks like the following one presented:</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_06_005.jpg"/><div class="caption"><p>The layout of the sandbox root mimics that of the host's root filesystem</p></div></div><p>Next, we used the script to copy the desired commands to the jail. The script does the hard work of finding each program's binary and identifies all of the libraries it depends on, and then it copies everything into the appropriate location in the sandboxed filesystem:</p><pre class="programlisting">
<span class="strong"><strong>~/cpchroot /jail bash cat cp find grep less ls mkdir mv pwd rm rmdir</strong></span>
</pre><p>Its first argument is the directory acting as our chroot'd root, and then following that is a list of one or more programs we want to make available to the user. The recipe provides a dozen programs as an example, and you should feel free to add or omit some as you see fit. At a minimum, you need a shell (<code class="literal">bash</code>). I recommend that you include at least <code class="literal">ls</code> and <code class="literal">pwd</code> so that the user can navigate.</p><p>Then, we copied the <code class="literal">terminfo</code> database to the <code class="literal">jail</code>:</p><pre class="programlisting">
<span class="strong"><strong>cp -R /usr/share/terminfo /jail/usr/share/</strong></span>
</pre><p>Some programs, such as <code class="literal">screen</code>, <code class="literal">less</code>, and <code class="literal">vi</code>, use the <code class="literal">terminfo</code> database to make sure their output displays correctly. The database is a collection of files that describe the capabilities of different terminal types, such as the number of lines per screen, how to clear the screen, what colors are supported, and so on. If this information isn't accessible, users will be warned that the <code class="literal">terminal is not fully functional</code> and the output may be garbled.</p><p>To finish making the <code class="literal">jail</code>, we created the <code class="literal">/dev/null</code>, <code class="literal">/dev/zero</code>, and <code class="literal">/dev/random</code> devices with the <code class="literal">mknod</code> command:</p><pre class="programlisting">
<span class="strong"><strong>cd /jail/dev/</strong></span>
<span class="strong"><strong>mknod null c 1 3</strong></span>
<span class="strong"><strong>mknod zero c 1 5</strong></span>
<span class="strong"><strong>mknod random c 1 8</strong></span>
</pre><p><code class="literal">mknod</code> is used to create special files such as character files and block files. These files are special because they can generate data (as is the case with <code class="literal">null</code> and <code class="literal">zero</code>) or represent physical devices and receive data. Both <code class="literal">null</code> and <code class="literal">zero</code> are character files, as indicated by the letter <code class="literal">c</code>, since we read from them one character at a time. Block files, on the other hand, operate with several characters at a time. A physical storage disk is often represented as a block device.</p><p>We also need to provide a major and minor number when creating a character or block device. These values are predefined and understood by the kernel as to how the device file should behave. <code class="literal">1</code> and <code class="literal">3</code> are the major and minor numbers that define a null device. <code class="literal">1</code> and <code class="literal">5</code> define the file as a null byte source. You can see the full list of major and minor number assignments in the Linux Allocated Device document listed in this recipe's <span class="emphasis"><em>See also</em></span> section.</p><p>After the chroot environment was set up, we turned our attention to configure the SSH server. First, we created the <code class="literal">sandbox</code> group, which can be assigned to any user we want contained:</p><pre class="programlisting">
<span class="strong"><strong>groupadd sandbox</strong></span>
</pre><p>Next, we added a <code class="literal">Match</code> block to the SSH server's configuration file targeting the new group:</p><pre class="programlisting">
<span class="strong"><strong>Match Group sandbox</strong></span>
<span class="strong"><strong>    ChrootDirectory /jail</strong></span>
</pre><p><code class="literal">Match</code> starts a new conditional section in the configuration file that applies only when its condition is matched. In this case, we're matching the user's group to <code class="literal">sandbox</code>. When the user is a member of the group, the <code class="literal">ChrootDirectory</code> option is applied and it sets <code class="literal">/jail</code> as the user's root directory. Now when a user connects, anything they do will be confined to the chroot jail, including actions that happen automatically such as launching an interactive shell (<code class="literal">bash</code>).</p><p>Bash tries to place the user in their <code class="literal">home</code> directory after signing in. However, if their <code class="literal">home</code> directory isn't accessible, the user will see the error message <code class="literal">Could not chdir to home directory</code> and find themselves in the root directory. To avoid this, we moved their <code class="literal">home</code> directory into the <code class="literal">jail</code>:</p><pre class="programlisting">
<span class="strong"><strong>mv /home/jbhuse /jail/home/</strong></span>
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>You might be tempted to specify the <code class="literal">home</code> directory when creating a new user, as follows:</p><p>
</p><p><code class="literal">
<span class="strong"><strong>useradd -m -D /jail/home/jbhuse -G sandbox jbhuse</strong></span>
</code></p><p>
</p><p>Unfortunately, this doesn't work. The <code class="literal">home</code> directory is created in the desired location, the user is chroot'd, and the path is viewed in relation to <code class="literal">/jail</code> so that bash looks for <code class="literal">/jail/jail/home/jbhuse</code>. This is why the recipe demonstrates moving the <code class="literal">home</code> directory as a second step. The entry in <code class="literal">/etc/passwd</code> stays, <code class="literal">/home/jbhuse</code> is interpreted as <code class="literal">/jail/home/jbhuse</code>, and all is right with the world.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec172"/>See also</h2></div></div></div><p>Refer to the following for more information on setting up chroot environments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">sshd_config</code> manual page (<code class="literal">man 5 sshd_config</code>)</li><li class="listitem" style="list-style-type: disc">How to Configure SFTP with Chroot (<a class="ulink" href="http://www.unixmen.com/configure-sftp-chroot-rhel-centos-7">http://www.unixmen.com/configure-sftp-chroot-rhel-centos-7</a>)</li><li class="listitem" style="list-style-type: disc">Safely identify dependencies for chrooting (<a class="ulink" href="http://zaemis.blogspot.com/2016/02/safely-identify-dependencies-for-chroot.html">http://zaemis.blogspot.com/2016/02/safely-identify-dependencies-for-chroot.html</a>)</li><li class="listitem" style="list-style-type: disc">Linux allocated devices (<a class="ulink" href="https://www.kernel.org/doc/Documentation/devices.txt">https://www.kernel.org/doc/Documentation/devices.txt</a>)</li></ul></div></div></div>
<div class="section" title="Configuring TigerVNC"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Configuring TigerVNC</h1></div></div></div><p>Virtual Network Computing (VNC) works by capturing the display's frame buffer and making it available across the network. This recipe shows you how to install TigerVNC and configure it to provide remote users access to their graphical desktop environment as if they were physically in front of the system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec173"/>Getting ready</h2></div></div></div><p>This recipe requires two systems, a CentOS system to host the VNC server (remote system) and a local computer with a VNC client to connect to it. It assumes that the remote system is running the OpenSSH SSH server and a graphical desktop environment such as GNOME or KDE. Administrative privileges are required on the remote server, either by logging in with the <code class="literal">root</code> account or through the use of <code class="literal">sudo</code>. The local computer is expected to have a VNC client installed.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec174"/>How to do it...</h2></div></div></div><p>Follow these steps to install and configure TigerVNC:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On the remote system, install the TigerVNC server package:<pre class="programlisting">
<span class="strong"><strong>yum install tigervnc-server</strong></span>
</pre></li><li class="listitem">Copy the example unit file provided with the package to <code class="literal">/etc/systemd/system</code>, adjusting its name to include the username of the person using VNC:<pre class="programlisting">
<span class="strong"><strong>cp /usr/lib/systemd/system/vncserver@.service  &#13;
       /etc/systemd/system/vncserver-tboronczyk@.service</strong></span>
</pre></li><li class="listitem">Open the new unit file with your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/systemd/system/vncserver-tboronczyk@.service</strong></span>
</pre></li><li class="listitem">Replace the <code class="literal">&lt;USER&gt;</code> placeholder that appears in the <code class="literal">[Service]</code> section's <code class="literal">ExecStart</code> and <code class="literal">PIDFile</code> entries:<pre class="programlisting">
<span class="strong"><strong>ExecStart=/usr/sbin/runuser -l tboronczyk -c "/usr/bin/  &#13;
       vncserver %i"</strong></span>
<span class="strong"><strong>PIDFile=/home/tboronczyk/.vnc/%H%i.pid</strong></span>
</pre></li><li class="listitem">Save your changes and close the file.</li><li class="listitem">Repeat steps 2 to 5 for each user who will use VNC to connect to their desktop.</li><li class="listitem">Reload systemd's configuration to make it aware of the new unit files:<pre class="programlisting">
<span class="strong"><strong>systemctl daemon-reload</strong></span>
</pre></li><li class="listitem">Open ports <code class="literal">5900</code> through <code class="literal">5903</code> in the system's firewall to accept incoming VNC requests:<pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-service=vnc- server</strong></span>
<span class="strong"><strong>firewall-cmd --reload</strong></span>
</pre></li><li class="listitem">The users using VNC should set the password they'll use to authenticate with the VNC server using <code class="literal">vncpasswd</code>:<pre class="programlisting">
<span class="strong"><strong>vncpasswd</strong></span>
</pre></li><li class="listitem">When a user wants to connect, specify a display number after <code class="literal">@</code> in the unit's name when starting TigerVNC:<pre class="programlisting">
<span class="strong"><strong>systemctl start vncserver-tboronczyk@:1.service</strong></span>
</pre></li><li class="listitem">Stop the server when it's not in use:<pre class="programlisting">
<span class="strong"><strong>systemctl stop vncserver-tboronczyk@.service</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec175"/>How it works...</h2></div></div></div><p>Along with the VNC server, the <code class="literal">tigervnc-server</code> package installs a <code class="literal">systemd</code> unit file to start and stop the server. However, there's some configuration we need to attend to before using it because the server runs under the user's account to obtain their desktop.</p><p>When TigerVNC starts, it connects to the X server and logs in to the user's desktop just as if the user was sitting in front of the system itself. This means each user needs their own instance of the server running and we need to configure it for each user. We made a copy of the original unit file found under <code class="literal">/usr/lib/systemd/system</code>, one for each user.</p><pre class="programlisting">
<span class="strong"><strong>cp /usr/lib/systemd/system/vncserver@.service /etc/systemd/system/  &#13;
    vncserver-tboronczyk@.service</strong></span>
</pre><p>The name of the copied file contains the username so that we can keep everything organized. They're placed under <code class="literal">/etc/systemd/system</code> because <code class="literal">systemd</code> looks in <code class="literal">/etc/systemd</code> for units before searching <code class="literal">/usr/lib/systemd</code> (in fact, many entries in <code class="literal">/etc/systemd</code> are symbolic links to their original files under <code class="literal">/usr/lib/systemd</code>). So, placing the copies there lets us keep the original intact and safeguards us from loosing our configuration in the event of an upgrade where the original until file is replaced.</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_06_006.jpg"/><div class="caption"><p>This system has VNC access configured for several users</p></div></div><p>We replaced any occurrence of the <code class="literal">&lt;USER&gt;</code> placeholder under the <code class="literal">[SERVICE]</code> section in each configuration file with the appropriate username:</p><pre class="programlisting">
<span class="strong"><strong>ExecStart=/usr/sbin/runuser -l tboronczyk -c "/usr/bin/vncserver %i"</strong></span>
<span class="strong"><strong>PIDFile=/home/tboronczyk/.vnc/%H%i.pid</strong></span>
</pre><p>The command specified in the <code class="literal">ExecStart</code> entry is invoked when we start the server using <code class="literal">systemctl start</code>; it uses <code class="literal">runuser</code> to run TigerVNC under the user's account. The <code class="literal">-l</code> (lowercase L) argument provides the username and <code class="literal">-c</code> specifies the command and its arguments that <code class="literal">runuser</code> will execute. The <code class="literal">PIDFile</code> entry specifies the directory in which the running process will keep track of its process ID.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>Dan Walsh, the author of <code class="literal">runuser</code>, wrote a blog entry entitled <span class="emphasis"><em>runuser vs su</em></span> detailing the backstory behind the command. You can read it online at <a class="ulink" href="http://danwalsh.livejournal.com/55588.html">http://danwalsh.livejournal.com/55588.html</a>.</p></div></div><p>The <code class="literal">@</code> symbol appearing in the filename has special significance to systemd. Anything after it and before the file suffix is passed to the commands in the unit file replacing <code class="literal">%i</code>. This lets us pass limited information to the server, for example, the display number for TigerVNC to run on. When we start the server as shown in the recipe, <code class="literal">:1</code> is given after <code class="literal">@</code>. The value is parsed by systemd and TigerVNC is started on display 1. If we use <code class="literal">:2</code>, the server will start on display 2. We can start multiple instances of TigerVNC for different users or even for the same user as long as the display is different for each:</p><pre class="programlisting">
<span class="strong"><strong>systemctl start vncserver-tboronczyk@:1.service</strong></span>
</pre><p>Traffic for the display's corresponding port should be allowed by the firewall. Display 0 uses port <code class="literal">5900</code>, display 1 uses port <code class="literal">5901</code>, display 2 uses port <code class="literal">5902</code>, and so on. If you're using FirewallD, the predefined <code class="literal">vnc-server</code> service opens ports <code class="literal">5900</code>-<code class="literal">5903</code>:</p><pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-service=vnc-server</strong></span>
</pre><p>If you need additional ports or if you don't need to open the entire range, you can open just what you need using <code class="literal">--add-port</code>:</p><pre class="programlisting">
<span class="strong"><strong>firewall-cmd --zone=public --permanent --add-port=5901/tcp</strong></span>
</pre><p>The user needs to set a VNC password using <code class="literal">vncpasswd</code> before they can connect to the display. The password must be at least six characters long, although only the first eight characters are significant. Moreover, the password is stored in the user's <code class="literal">~/.vnc/</code> directory. In the light of these issues, it's recommended that the user doesn't use the same password as their account password. It's also wise to run the VNC server only when needed since anyone who knows the display number and password can connect to it.</p><p>The user also needs a VNC client to connect from their local computer. CentOS users can install the <code class="literal">tigervnc</code> package to use TigerVNC's client. Other popular clients are Vinagre for Ubuntu, RealVNC for TightVNC on Windows, and Chicken of the VNC for OS X:</p><pre class="programlisting">
<span class="strong"><strong>yum install tigervnc</strong></span>
</pre><p>The IP address or hostname for the remote system and the display (port) that VNC is running are needed to establish the connection. They can be provided in different ways depending on the client, but the standard format accepted by most clients appends the display to the system's address, for example, <code class="literal">192.168.56.100:1</code>. The user will then be prompted for their password, and if all goes well they'll be connected to the remote display:</p><div class="mediaobject"><img alt="How it works..." src="graphics/image_06_007.jpg"/><div class="caption"><p>A user prepares to connect to a remote display using VNC</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec176"/>See also</h2></div></div></div><p>Refer to the following resources for more information on running TigerVNC and how systemd uses <code class="literal">@</code> in filenames:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">TigerVNC (<a class="ulink" href="http://tigervnc.org/">http://tigervnc.org/</a>)</li><li class="listitem" style="list-style-type: disc">RHEL 7 System Administrator's Guide: TigerVNC (<a class="ulink" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/ch-TigerVNC.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/ch-TigerVNC.html</a>)</li><li class="listitem" style="list-style-type: disc">ArchWiki: TigerVNC (<a class="ulink" href="https://wiki.archlinux.org/index.php/TigerVNC">https://wiki.archlinux.org/index.php/TigerVNC</a>)</li><li class="listitem" style="list-style-type: disc">The <code class="literal">@</code> symbol and <code class="literal">systemctl</code> (<a class="ulink" href="http://superuser.com/questions/393423/the-symbol-and-systemctl-and-vsftpd/393429#393429">http://superuser.com/questions/393423/the-symbol-and-systemctl-and-vsftpd/393429#393429</a>)</li><li class="listitem" style="list-style-type: disc">Understanding Systemd Units and Unit Files (<a class="ulink" href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files</a>)</li></ul></div></div></div>
<div class="section" title="Tunneling VNC connections through SSH"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Tunneling VNC connections through SSH</h1></div></div></div><p>The previous recipe showed you how to give remote access to the user's desktop through VNC. However, there are clearly some security concerns if the service is running on an untrusted network. Only the display number and password are required to connect, and the password can be relatively easy for a malicious user to crack given that only the first eight characters are significant. Moreover, the traffic is unencrypted and it may be snooped. To help mitigate these risks, this recipe teaches you how to route the VNC connection through an encrypted SSH tunnel.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec177"/>Getting ready</h2></div></div></div><p>This recipe requires two systems, a CentOS system hosting the VNC server (remote system) and a local computer with a VNC client to connect to it. It assumes that the remote system is running the OpenSSH SSH server and TigerVNC server and is configured with the IP address <code class="literal">192.168.56.100</code>. It also assumes that you have administrative privileges. The VNC server should be configured as described in the previous recipe. The local computer should have the OpenSSH SSH client (<code class="literal">ssh</code>) and a VNC client installed.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec178"/>How to do it...</h2></div></div></div><p>Follow these steps to route VNC connections through an encrypted SSH tunnel:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On the remote server, open a <code class="literal">vncserver@.service</code> configuration file using your text editor:<pre class="programlisting">
<span class="strong"><strong>vi /etc/systemd/system/vncserver-tboronczyk@.service</strong></span>
</pre></li><li class="listitem">Locate the <code class="literal">ExecStart</code> entry and add the <code class="literal">-localhost</code> argument to the <code class="literal">vncserver</code> command invoked by <code class="literal">runuser</code>:<pre class="programlisting">
<span class="strong"><strong>       ExecStart=/usr/sbin/runuser -l tboronczyk -c "/usr/bin/vncserver</strong></span>
<span class="strong"><strong>       -localhost %i"&#13;
</strong></span>
</pre></li><li class="listitem">Save your change and close the file.</li><li class="listitem">Repeat steps 1 to 3 as necessary for the other users' configuration files.</li><li class="listitem">Reload systemd's configuration to make it aware of the updates:<pre class="programlisting">
<span class="strong"><strong>systemctl daemon-reload</strong></span>
</pre></li><li class="listitem">Start the VNC server:<pre class="programlisting">
<span class="strong"><strong>systemctl start vncserver-tboronczyk@:1.service</strong></span>
</pre></li><li class="listitem">On your local system, establish an SSH session to the server with <code class="literal">-L</code> to define the tunnel:<pre class="programlisting">
<span class="strong"><strong>ssh -L 5901:localhost:5901 192.168.56.100</strong></span>
</pre></li><li class="listitem">Connect to the tunnel's local endpoint (<code class="literal">localhost:1</code>) using a VNC client.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec179"/>How it works...</h2></div></div></div><p>This recipe showed you how to secure VNC by tunneling its traffic through SSH. We configured the TigerVNC server to only accept connections from its localhost and then set up a tunnel on the local client side to route traffic through an SSH connection. This helps mitigate some of the aforementioned security risks because proper authentication is needed to establish the tunnel and encrypt the VNC traffic.</p><p>First, you edited the <code class="literal">ExecStart</code> command in the unit files used to start instances of the VNC server. The <code class="literal">-localhost</code> argument to <code class="literal">vncserver</code> instructs the server to communicate only with the local system; any incoming connections originating from the network will be refused:</p><pre class="programlisting">
<span class="strong"><strong>ExecStart=/usr/sbin/runuser -l tboronczyk -c "/usr/bin/vncserver   &#13;
    -localhost %i"</strong></span>
</pre><p>On the client side, the user now needs to establish an SSH tunnel using <code class="literal">ssh</code> before they can connect to the remote display:</p><pre class="programlisting">
<span class="strong"><strong>ssh -L 5901:localhost:5901 192.168.56.100</strong></span>
</pre><p>The <code class="literal">-L</code> argument defines the tunnel as <code class="literal">local-port:target-host:target-port</code>. The target host and port represent the final destination in relation to the server <code class="literal">ssh</code> is connected to. For example, we know that the recipe is running the user's desktop on display 1 which uses port <code class="literal">5901</code>. We also know that TigerVNC server is running on <code class="literal">192.168.56.100</code> but configured to listen only to its localhost. This means, we need to connect to <code class="literal">localhost:5901</code> from <code class="literal">192.168.56.100</code>. Thus, <code class="literal">localhost:5901</code> is the target in relation to that system.</p><p>Once the user has an established tunnel, they can minimize the session's terminal. (Don't close it!) <code class="literal">ssh</code> is connected to the remote system while also listening on the local port (also <code class="literal">5901</code>). On the remote server, <code class="literal">ssh</code> has established a second connection to the target host and port. The VNC client will connect to the local port by using the address <code class="literal">localhost:1</code> where the traffic is then routed through the SSH tunnel to the remote server and then forwarded to the final destination.</p><p>The remote system acts as a gateway as traffic travels through it from the client's tunnel to the final destination. Keep in mind, unless a tunnel to the target has also been created on the remote server, the second leg of the data's journey is not encrypted. This isn't a concern for this recipe because the remote and target hosts are the same. If your final destination is anything other than localhost, ensure that the network is trusted or create a second tunnel.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>Routing traffic with SSH in this fashion can be done to secure other services as well, for example, NFS, FTP, HTTP, POP3, and SMTP. The overall process is the same: configure the server to listen locally and then establish the tunnel on the client.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec180"/>See also</h2></div></div></div><p>Refer to the following resources to learn more about SSH tunneling:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">ssh</code> manual page (<code class="literal">man 1 ssh</code>)</li><li class="listitem" style="list-style-type: disc">Securing network traffic with SSH (<a class="ulink" href="https://security.berkeley.edu/resources/best-practices-how-articles/securing-network-traffic-ssh-tunnels">https://security.berkeley.edu/resources/best-practices-how-articles/securing-network-traffic-ssh-tunnels</a>)</li><li class="listitem" style="list-style-type: disc">SSH tunneling made easy (<a class="ulink" href="http://www.revsys.com/writings/quicktips/ssh-tunnel.html">http://www.revsys.com/writings/quicktips/ssh-tunnel.html</a>)</li></ul></div></div></div></body></html>