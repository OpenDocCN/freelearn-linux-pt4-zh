<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The What and Why of Scripting with Bash</h1>
                </header>
            
            <article>
                
<p>Welcome to the what and why of bash scripting. In this chapter, you will discover the types of shells in Linux and why we chose bash. You will learn what bash is, how to write your first bash script, and how to run it. Also, you will see how to configure Linux editors, such as vim and nano, in order to type your code.</p>
<p>Like in any other scripting language, variables are the basic blocks of coding. You will learn how to declare variables such as integers, strings, and arrays. Furthermore, you will learn how to export these variables and extend their scope outside the running process.</p>
<p>Finally, you will see how to visually debug your code using Visual Studio Code.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Types of Linux shells</li>
<li>What is bash scripting?</li>
<li>The bash command hierarchy</li>
<li>Preparing text editors for scripting</li>
<li>Creating and executing scripts</li>
<li>Declaring variables</li>
<li>Variable scope</li>
<li>Command substitution</li>
<li>Debugging your scripts</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You'll need a running Linux box. It doesn't matter which distribution you use, since all Linux distributions are shipped nowadays with the bash shell.</p>
<p>Download and install Visual Studio Code, which is free from Microsoft. You can download it from here: <a href="https://code.visualstudio.com/"><span class="URLPACKT">https://code.visualstudio.com/</span></a><span class="URLPACKT">.</span></p>
<p>You can use VS Code as an editor instead of vim and nano; it's up to you.</p>
<p>We prefer to use VS Code because it has a lot of features such as code completion, debugging, and many more besides.</p>
<p>Install <kbd>bashdb</kbd>, which is a required package for the bash debug plugin. If you are using a Red Hat-based distribution, you can install it like this:</p>
<pre><strong>$ sudo yum install bashdb </strong> </pre>
<p>If you are using a Debian-based distribution, you can install it like this:</p>
<pre><strong>$ sudo apt-get install bashdb</strong> </pre>
<p>Install the plugin for VS Code, called bash debug, from <a href="https://marketplace.visualstudio.com/items?itemName=rogalmic.bash-debug"><span class="URLPACKT">https://marketplace.visualstudio.com/items?itemName=rogalmic.bash-debug</span></a>. This plugin will be used to debug bash scripts.</p>
<p>The source code for this chapter can be downloaded here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter01">https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter01</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of Linux shells</h1>
                </header>
            
            <article>
                
<p>As you know, Linux consists of some major parts, such as the kernel, the shell, and the GUI interface (Gnome, KDE, and so on).</p>
<p>The shell translates your commands and sends them to the system. Most Linux distributions are shipped with many shells.</p>
<p>Every shell has its own features, and some of them are very popular among developers today. These are some of the popular ones:</p>
<ul>
<li><strong>Sh shell</strong>: This is called the Bourne shell, this was developed at AT&amp;T labs in the 70s by a guy named Stephen Bourne. This shell offers many features.</li>
<li><strong>Bash shell</strong>: Also called the Bourne again shell, this is very popular and compatible with sh shell scripts, so you can run your sh scripts without changing them. We are going to use this shell in this book.</li>
<li><strong>Ksh shell</strong>: Also called the Korn shell, this is compatible with sh and bash. Ksh offers some enhancements over the Bourne shell.</li>
<li><strong>Csh and tcsh</strong>: Linux was built using the C language and that drove developers at Berkeley University to develop a C-style shell in which the syntax is similar to the C language. Tcsh adds some minor enhancements to csh.</li>
</ul>
<p>Now we know the types of shells and we know that we are going to use bash, so what is bash scripting?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is bash scripting?</h1>
                </header>
            
            <article>
                
<p>The basic idea of bash scripting is to execute multiple commands to automate a specific job.</p>
<p>As you might know, you can run multiple commands from the shell by separating them with semi colons (<kbd>;</kbd>):</p>
<pre><strong>ls ; pwd</strong> </pre>
<p>The previous line is a mini bash script.</p>
<p>The first command runs, followed by the result of the second command.</p>
<p>Every keyword you type in bash scripting is actually a Linux binary (program), even the <kbd>if</kbd> statement, or <kbd>else</kbd> or <kbd>while</kbd> loops. All are Linux executables.</p>
<p>You can say that the shell is the glue that binds these commands together.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The bash command hierarchy</h1>
                </header>
            
            <article>
                
<p>When working on the bash shell and when you are sitting comfortably at your prompt eagerly waiting to type a command, you will most likely feel that it is a simple matter of typing and hitting the <em><span class="KeyPACKT">Enter</span></em> key. You should know better than to think this, as things are never quite as simple as we imagine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command type</h1>
                </header>
            
            <article>
                
<p>For example, if we type and enter <kbd>ls</kbd> to list files, it is reasonable to think that we were running the command. It is possible, but we often will be running an alias. Aliases exist in memory as a shortcut to commands or commands with options; these aliases are used before we even check for the file. Bash's built-in <kbd>type</kbd> <span>command </span>can come to our aid here. The <kbd>type</kbd> command will display the type of command for a given word entered at the command line. The types of command are listed as follows:</p>
<ul>
<li>Alias</li>
<li>Function</li>
<li>Shell built-in</li>
<li>Keyword</li>
<li>File</li>
</ul>
<p>This list is also representative of the order in which they are searched. As we can see, it is not until the very end where we search for the executable file <kbd>ls</kbd>.</p>
<p>The following command demonstrates the simple use type:</p>
<pre><strong>$ type ls</strong>
<strong>ls is aliased to 'ls --color=auto'</strong>  </pre>
<p>We can extend this further to display all the matches for the given command:</p>
<pre><strong>$ type -a ls</strong>
<strong>ls is aliased to 'ls --color=auto'</strong>
<strong>ls is /bin/ls</strong> </pre>
<p>If we need to just type in the output, we can use the <kbd>-t</kbd> option. This is useful when we need to test the command type from within a script and only need the type to be returned. This excludes any superfluous information, and thus makes it easier for us humans to read. Consider the following command and output:</p>
<pre><strong>$ type -t ls</strong>
<strong>alias</strong>  </pre>
<p>The output is clear and simple, and is just what a computer or script requires.</p>
<p>The built-in <kbd>type</kbd> can also be used to identify shell keywords such as <kbd>if</kbd>, and <kbd>case</kbd>. The following command shows <kbd>type</kbd> being used against multiple arguments and types:</p>
<pre><strong>$ type ls quote pwd do id</strong>  </pre>
<p>The output of the command is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-254 image-border" src="assets/12fda344-022e-437f-9aaf-c4c200b294e0.png" style="width:24.42em;height:15.25em;"/></div>
<p>You can also see that the function definition is printed when we stumble across a function when using <kbd>type</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command PATH</h1>
                </header>
            
            <article>
                
<p>Linux will check for executables in the <kbd>PATH</kbd> environment only when the full or relative path to the program is supplied. In general, the current directory is not searched unless it is in the <kbd>PATH</kbd>. It is possible to include our current directory within the <kbd>PATH</kbd> by adding the directory to the <kbd>PATH</kbd> variable. This is shown in the following command example:</p>
<pre><strong>$ export PATH=$PATH:.</strong></pre>
<p>This appends the current directory to the value of the <kbd>PATH</kbd> variable; each item in the <kbd>PATH</kbd> is separated using a colon. Now your <kbd>PATH</kbd> has been updated to include the current working directory and, each time you change directories, the scripts can be executed easily. In general, organizing scripts into a structured directory hierarchy is probably a great idea. Consider creating a subdirectory called <kbd>bin</kbd> within your home directory and add the scripts into that folder. Adding <kbd>$HOME/bin</kbd> to your <kbd>PATH</kbd> variable will enable you to find the scripts by name and without the file path.</p>
<p>The following command-line list will only create the directory, if it does not already exist:</p>
<pre><strong>$ test -d $HOME/bin || mkdir $HOME/bin</strong>  </pre>
<p>Although the preceding command-line list is not strictly necessary, it does show that scripting in bash is not limited to the actual script, and we can use conditional statements and other syntax directly at the command line. From our viewpoint, we know that the preceding command will work whether you have the <kbd>bin</kbd> directory or not. The use of the <kbd>$HOME</kbd> variable ensures that the command will work without considering your current filesystem context.</p>
<p>As we work through the book, we will add scripts into the <kbd>$HOME/bin</kbd> directory so that they can be executed regardless of our working directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing text editors for scripting</h1>
                </header>
            
            <article>
                
<p>Throughout the book, we will be working on Linux Mint, and this will include the creation and editing of the scripts. You, of course, can choose the way you wish to edit your scripts and may prefer to make use of a graphical editor, so we will show some settings in gedit. We will make one excursion into a Red Hat system to show screenshots of gedit in this chapter.</p>
<p>Also, we will use Visual Studio Code as a modern GUI editor to edit and debug our scripts.</p>
<p>To help make the command-line editor easier to use, we can enable options and we can persist with these options through hidden configuration files. Gedit and other GUI editors, and their menus, will provide similar functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring vim</h1>
                </header>
            
            <article>
                
<p>Editing the command line is often a must and is part of a developer's everyday life. Setting up common options that make life easier in the editor give us the reliability and consistency we need, a little like scripting itself. We will set some useful options in the vi or vim editor file, <kbd>$HOME/.vimrc</kbd>.</p>
<p>The options we set are detailed in the following list:</p>
<ul>
<li><kbd>set showmode</kbd>: Ensures we see when we are in insert mode</li>
<li><kbd>set nohlsearch</kbd>: Does not highlight the words that we have searched for</li>
<li><kbd>set autoindent</kbd>: We indent our code often; this allows us to return to the last indent level rather than the start of a new line on each line break</li>
<li><kbd>set tabstop=4</kbd>: Sets a tab to be four spaces</li>
<li><kbd>set expandtab</kbd>: Converts tabs to spaces, which is useful when the file moves to other systems</li>
<li><kbd>syntax on</kbd>: Note that this does not use the <kbd>set</kbd> command and is used to turn on syntax highlighting</li>
</ul>
<p>When these options are set, the <kbd>$HOME/.vimrc</kbd> file should look similar to this:</p>
<pre>set showmode 
set nohlsearch 
set autoindent 
set tabstop=4 
set expandtab 
syntax on </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring nano</h1>
                </header>
            
            <article>
                
<p>The nano text editor is increasing in importance and it is the default editor in many systems. Personally, I don't like the navigation or the lack of navigation features that it has. It can be customized in the same way as vim. This time, we will edit the <kbd>$HOME/.nanorc</kbd> file. Your edited file should look something like the following:</p>
<pre>set autoindent 
set tabsize 4 
include /usr/share/nano/sh.nanorc </pre>
<p>The last line enables syntax highlighting for shell scripts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring gedit</h1>
                </header>
            
            <article>
                
<p>Graphical editors, such as gedit, can be configured using the preferences menu, and are pretty straightforward.</p>
<p>Enabling tab spacing to be set to <span class="packt_screen">4</span> spaces and expanding tabs to spaces can be done using the <span class="packt_screen">Preferences</span> | <span class="packt_screen">Editor</span> tab, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/3528cb30-2bce-4f89-b1bb-f35137789872.png" style="width:22.92em;height:30.25em;"/></div>
<div class="packt_tip">You can download the example code files from your account at <a href="http://www.packtpub.com"><span class="URLPACKT">http://www.packtpub.com</span></a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support"><span class="URLPACKT">http://www.packtpub.com/support</span></a> and register to have the files e-mailed directly to you.</div>
<p>Another very useful feature is found on the <span class="packt_screen">Preferences</span> | <span class="packt_screen">Plugins</span> tab. Here, we can enable the <span class="packt_screen">Snippets</span> plugin, which can be used to insert code samples. This is shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/a0a634a5-2b76-4d00-8bf2-4e2fb0b1ec56.png" style="width:21.50em;height:28.33em;"/></div>
<p>For the rest of the book, we will be working on the command line and in vim; feel free to use the editor that you work with best. We have now laid the foundations to create good scripts, and, although whitespace, tabs, and spaces in bash scripts are not significant, a well-laid-out file with consistent spacing is easy to read. When we look at Python later in the book, you will realize that in some languages, the whitespace is significant to the language and it is better to adopt good habits early on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and executing scripts</h1>
                </header>
            
            <article>
                
<p>With our editors primed and ready, we can now move quickly to creating and executing our scripts. If you are reading this book with some prior experience, we will warn you that we are going to start with the basics, but we will also include looking at positional parameters; feel free to move on at your own pace.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hello World!</h1>
                </header>
            
            <article>
                
<p>As you know, it is almost obligatory to begin with a <kbd>Hello World</kbd> script and we will not disappoint as far as this is concerned. We will begin by creating a new script, <kbd>$HOME/bin/hello1.sh</kbd>. The contents of the file should read as in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-255 image-border" src="assets/e3d20671-aca4-40f8-9218-ab2bc5ee82cd.png" style="width:12.25em;height:4.42em;"/></div>
<p>We hope that you haven't struggled with this too much; it is just three lines, after all. We encourage you to run through the examples as you read to really help you instill the information with good hands-on practice.</p>
<ul>
<li><kbd>#!/bin/bash</kbd>: Normally, this is always the first line of the script and is known as the shebang. The shebang starts with a comment, but the system still uses this line. A comment in a shell script has the <kbd>#</kbd> symbol. The shebang instructs the interpreter of the system to execute the script. We use bash for shell scripts, and we may use PHP or Perl for other scripts, as required. If we do not add this line, then the commands will be run within the current shell; it may cause issues if we run another shell.</li>
<li><kbd>echo "Hello World"</kbd>: The <kbd>echo</kbd> command will be picked up in a built-in shell and can be used to write a standard output, <kbd>STDOUT</kbd>; this defaults to the screen. The information to print is enclosed in double quotes; there will be more on quotes later.</li>
<li><kbd>exit 0</kbd>: The <kbd>exit</kbd> command is a built-in shell, and is used to leave or exit the script. The <kbd>exit</kbd> code is supplied as an integer argument. A value of anything other than <kbd>0</kbd> will indicate some type of error in the script's execution.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing the script</h1>
                </header>
            
            <article>
                
<p>With the script saved in our <kbd>PATH</kbd> environment, it still will not execute as a standalone script. We will have to assign and execute permissions for the file, as needed. For a simple test, we can run the file directly with bash. The following command shows you how to do this:</p>
<pre><strong>$ bash $HOME/bin/hello1.sh</strong>  </pre>
<p>We should be rewarded with the <kbd>Hello World</kbd> text being displayed on our screens. This is not a long-term solution, as we need to have the script in the <kbd>$HOME/bin</kbd> directory, specifically, to make running the script easy from any location without typing the full path. We need to add in the execute permissions as shown in the following code:</p>
<pre><strong>$ chmod +x $HOME/bin/hello1.sh</strong> </pre>
<p>We should now be able to run the script simply, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-256 image-border" src="assets/c5577185-d395-4690-b989-b6a37d813110.png" style="width:24.75em;height:6.00em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the exit status</h1>
                </header>
            
            <article>
                
<p>This script is simple, but we still need to know how to make use of the exit codes from scripts and other applications. The command-line list that we generated earlier, while creating the <kbd>$HOME/bin</kbd> directory, is a good example of how we can use the exit code:</p>
<pre><strong>$ command1 || command 2</strong> </pre>
<p>In the preceding example, <kbd>command2</kbd> is executed only if <kbd>command1</kbd> fails in some way. To be specific, <kbd>command2</kbd> will run if <kbd>command1</kbd> exits with a status code other than <kbd>0</kbd>.</p>
<p>Similarly, in the following extract, we will only execute <kbd>command2</kbd> if <kbd>command1</kbd> succeeds and issues an exit code of <kbd>0</kbd>:</p>
<pre><strong>$ command1 &amp;&amp; command2</strong>  </pre>
<p>To read the exit code from our script explicitly, we can view the <kbd>$?</kbd> variable, as shown in the following example:</p>
<pre><strong>$ hello1.sh</strong>
<strong>$ echo $?</strong></pre>
<p>The expected output is <kbd>0</kbd>, as this is what we have added to the last line of the file and there is precious little else that can go wrong to cause the failure to reach that line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ensuring a unique name</h1>
                </header>
            
            <article>
                
<p>We can now create and execute a simple script, but we need to consider the name a little. In this case, <kbd>hello1.sh</kbd> will be good enough and is unlikely to clash with anything else on the system. We should avoid using names that may clash with existing aliases, functions, keywords, and building commands, as well as avoiding names of programs already in use.</p>
<p>Adding the <kbd>sh</kbd> suffix to the file does not guarantee the name will be unique, but, in Linux, where we do not use file extensions, the suffix is part of the filename. This helps you to provide a unique identity to your script. Additionally, the suffix is used by the editor to help you identify the file for syntax highlighting. If you recall, we specifically added the syntax highlighting file <kbd>sh.nanorc</kbd> to the nano text editor. Each of these files is specific to a suffix and subsequent language.</p>
<p>Referring back to the command hierarchy within this chapter, we can use a <kbd>type</kbd> to determine the location and type of file <kbd>hello.sh</kbd>:</p>
<pre><strong>$ type hello1.sh  #To determine the type and path</strong>
<strong>$ type -a hello1.sh  #To print all commands found if the name is NOT unique</strong>
<strong>$ type -t hello1.sh ~To print the simple type of the command</strong>  </pre>
<p>These commands and output can be seen in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-257 image-border" src="assets/62a86b69-105e-4e05-af8b-0c4ba91d7224.png" style="width:27.00em;height:9.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hello Dolly!</h1>
                </header>
            
            <article>
                
<p>It is possible that we might need a little more substance in the script than a simple fixed message. Static message content does have its place, but we can make this script much more useful by building in some flexibility.</p>
<p>In this chapter, we will look at the positional parameters or arguments that we can supply to the script and in the next chapter, we will see how we can make the script interactive and also prompt the user for input at runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the script with arguments</h1>
                </header>
            
            <article>
                
<p>We can run the script with arguments; after all, it's a free world and Linux promotes your freedom to do what you want to do with the code. However, if the script does not make use of the arguments, then they will be silently ignored. The following command shows the script running with a single argument:</p>
<pre><strong>$ hello1.sh fred</strong>  </pre>
<p>The script will still run and will not produce an error. The output will not change either and will print <kbd>Hello World</kbd>:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Argument Identifier</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>$0</kbd></p>
</td>
<td>
<p>The name of the script itself, which is often used in usage statements.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>$1</kbd></p>
</td>
<td>
<p>A positional argument, which is the first argument passed to the script.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>${10}</kbd></p>
</td>
<td>
<p>Where two or more digits are needed to represent the argument position. Brace brackets are used to delimit the variable name from any other content. Single value digits are expected.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>$#</kbd></p>
</td>
<td>
<p>The argument count is especially useful when we need to set the amount of arguments needed for correct script execution.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>$*</kbd></p>
</td>
<td>
<p>Refers to all arguments.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>For the script to make use of the argument, we can change its content a little. Let's first copy the script, add in the execute permissions, and then edit the new <kbd>hello2.sh</kbd>:</p>
<pre><strong>$ cp $HOME/bin/hello1.sh $HOME/bin/hello2.sh</strong>
<strong>$ chmod +x $HOME/bin/hello2.sh</strong>  </pre>
<p>We need to edit the <kbd>hello2.sh</kbd> file to make use of the argument as it is passed at the command line. The following screenshot shows the simplest use of command-line arguments, now allowing us to have a custom message:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-258 image-border" src="assets/5ed6a81a-5951-4afa-a836-ca3d223476c1.png" style="width:11.00em;height:5.42em;"/></div>
<p>Run the script now; we can provide an argument as shown in the following:</p>
<pre><strong>$ hello2.sh fred</strong></pre>
<p>The output should now say <kbd>Hello fred</kbd>. If we do not provide an argument, then the variable will be empty and will just print <kbd>Hello</kbd>. You can refer to the following screenshot to see the execution argument and output:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-259 image-border" src="assets/7bb5ff42-cddd-4513-a670-6e6b43423c75.png" style="width:19.17em;height:4.50em;"/></div>
<p>If we adjust the script to use <kbd>$*</kbd>, all the arguments will print. We will see <kbd>Hello</kbd> and then a list of all the supplied arguments. Edit the script and replace the <kbd>echo</kbd> line as follows:</p>
<pre><strong>echo "Hello $*"</strong></pre>
<p>This will execute the script with the following arguments:</p>
<pre><strong>$ hello2.sh fred wilma betty barney</strong></pre>
<p>And this will result in the output shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-260 image-border" src="assets/612e1eac-7009-47eb-ac8a-b7b86e308f8a.png" style="width:28.00em;height:6.00em;"/></div>
<p>If we want to print <kbd>Hello &lt;name&gt;</kbd>, with each name on a separate line, we will need to wait a little until we cover looping structures. A <kbd>for</kbd> loop is a good way to achieve this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The importance of correct quotes</h1>
                </header>
            
            <article>
                
<p>So far, we have used a simple double-quoting mechanism to encase the strings that we want to use with echo.</p>
<p>In the first script, it does not matter if we use single or double quotes. <kbd>echo "Hello World"</kbd> will be exactly the same as <kbd>echo 'Hello World'</kbd>.</p>
<p>However, this is not the case in the second script, so it is very important to understand the quoting mechanisms available in bash.</p>
<p>As we have seen, using double quotes in <kbd>echo "Hello $1"</kbd> will result in <kbd>Hello fred</kbd> or whatever the supplied value is. Whereas, if we use single quotes in <kbd>echo 'Hello $1'</kbd>, the printed output on the screen will be <kbd>Hello $1</kbd>; that is, we see the variable name and not its value.</p>
<p>The idea of the quotes is to protect special characters, such as a space between the two words; both quotes protect the space from being misinterpreted. The space is normally read as a default field, separated by the shell. In other words, all characters are read by the shell as literals with no special meaning. This has the knock-on effect of the <kbd>$</kbd> symbol printing its literal format rather than allowing bash to expand its value. The bash shell is prevented from expanding the variable's value as it is protected by the single quotes.</p>
<p>This is where the double quote comes to our rescue. The double quote will protect all the characters except the <kbd>$</kbd>, allowing bash to expand the stored value.</p>
<p>If we ever need to use a literal <kbd>$</kbd> within the quoted string, along with variables that need to be expanded, we can use double quotes, but escape the desired <kbd>$</kbd> with the backslash (<kbd>\</kbd>). For example, <kbd>echo "$USER earns \$4"</kbd> would print as <kbd>Fred earns $4</kbd> if the current user were Fred.</p>
<p>Try the following examples at the command line using all quoting mechanisms. Feel free to up your hourly rate as required:</p>
<pre><strong>$ echo "$USER earns $4"</strong>
<strong>$ echo '$USER earns $4'</strong>
<strong>$ echo "$USER earns \$4"</strong>  </pre>
<p>The output is shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-261 image-border" src="assets/5ca3f282-07b0-4866-aeba-a8ae1f28b832.png" style="width:19.92em;height:8.00em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Printing the script name</h1>
                </header>
            
            <article>
                
<p>The <kbd>$0</kbd> variable represents the script name, and this is often used in usage statements. As we are not yet looking at conditional statements, we will get the script name printed above the displayed name.</p>
<p>Edit your script so that it reads like the following complete code block for <kbd>$HOME/bin/hello2.sh</kbd>:</p>
<pre>#!/bin/bash 
echo "You are using $0" 
echo "Hello $*" 
exit 0 </pre>
<p>The output from the command is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-262 image-border" src="assets/225c3633-3e9e-42b9-8484-18d5832db6c3.png" style="width:22.17em;height:5.75em;"/></div>
<p>If we prefer not to print the path and only want the name of the script to show, we can use the <kbd>basename</kbd> command, which extracts the name from the path. Adjust the script so that the second line now reads as follows:</p>
<pre><strong>echo "You are using $(basename $0)"</strong>  </pre>
<p>The <kbd>$(....)</kbd> syntax is used to evaluate the output of the inner command. We first run <kbd>basename $0</kbd> and feed the result into an unnamed variable represented by the <kbd>$</kbd>.</p>
<p>The new output will appear as seen in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-263 image-border" src="assets/011b53df-581f-4da2-aef6-c6bb8916b43d.png" style="width:19.42em;height:4.08em;"/></div>
<p>It is possible to achieve the same results using back quotes; this is less easy to read, but we have mentioned this as you might need to understand and modify the scripts that have been written by others. The alternative to the <kbd>$(....)</kbd> syntax is shown in the following example:</p>
<pre><strong>echo "You are using 'basename $0'"</strong>  </pre>
<p>Please note that the characters used are back quotes and <em>NOT</em> single quotes. On UK and US keyboards, these are found in the top-left corner next to the number <span class="KeyPACKT">1</span> key.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring variables</h1>
                </header>
            
            <article>
                
<p>Just like in any programming language, you can declare variables in bash scripts. So, what are these variables and what are the benefits of using them?</p>
<p>Well, a variable is like a placeholder where you store some value for later use in your code.</p>
<p>There are two kinds of variables you can declare in your script:</p>
<ul>
<li>User-defined variables</li>
<li>Environment variables</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User-defined variables</h1>
                </header>
            
            <article>
                
<p>To declare a variable, just type the name you want and set its value using the equals sign (<kbd>=</kbd>).</p>
<p>Check out this example:</p>
<pre>#!/bin/bash 
name="Mokhtar" 
age=35 
total=16.5 
echo $name  #prints Mokhtar 
echo $age   #prints 35 
echo $total #prints 16.5 </pre>
<p>As you can see, to print the variable's value, you should use the dollar sign (<kbd>$</kbd>) before it.</p>
<p>Note that there are <strong>no spaces</strong> between the variable name and the equals sign, or between the equals sign and the value.</p>
<p>If you forget and type a space in between, the shell will treat the variable as if it were a command, and, since there is no such command, it will show an error.</p>
<p>All of the following examples are incorrect declarations:</p>
<pre># Don't declare variables like this: 
name = "Mokhtar" 
age =35 
total= 16.5 </pre>
<p>Another useful type of user-defined variable is the array. An array can hold multiple values. So, if you have tens of values you want to use, you should use arrays instead of filling your script with variables.</p>
<p>To declare an array, just enclose its elements between brackets, like this:</p>
<pre>#!/bin/bash 
myarr=(one two three four five) </pre>
<p>To access a specific array element, you can specify its index like this:</p>
<pre>#!/bin/bash 
myarr=(one two three four five) 
echo ${myarr[1]} #prints two which is the second element </pre>
<p>The index is zero based.</p>
<p>To print the array elements, you can use an asterisk, like this:</p>
<pre>#!/bin/bash 
myarr=(one two three four five) 
echo ${myarr[*]} </pre>
<p>To remove a specific element from the array, you can use the <kbd>unset</kbd> command:</p>
<pre>#!/bin/bash 
myarr=(one two three four five) 
unset myarr[1] #This will remove the second element 
unset myarr    #This will remove all elements </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Environment variables</h1>
                </header>
            
            <article>
                
<p>So far, we have used variables that we didn't define, such as <kbd>$BASH_VERSION</kbd>, <kbd>$HOME</kbd>, <kbd>$PATH</kbd>, and <kbd>$USER</kbd>. You might wonder, as we didn't declare these variables, where did they come from?</p>
<p>These variables are defined by the shell for your use and they are called environment variables.</p>
<p>There are many environment variables. If you want to list them, you can use the <kbd>printenv</kbd> command.</p>
<p>Also, you can print a specific environment variable by specifying it to the <kbd>printenv</kbd> command:</p>
<pre><strong>$ printenv HOME</strong></pre>
<p>We can use any of these variables in our bash scripts.</p>
<p>Note that all environment variables are written in capital letters, so you can declare your variables as lower case to make it easy to differentiate your variables from environment variables. This is not required, but is preferable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variable scope</h1>
                </header>
            
            <article>
                
<p>Once you have declared your variable, it will be available for use in your entire bash script without any problems.</p>
<p>Let's assume this scenario: you have divided your code into two files and you will execute one of them from inside the other, like this:</p>
<pre># The first script 
#!/bin/bash 
name="Mokhtar" 
./script2.sh # This will run the second script </pre>
<p>The second script looks like this:</p>
<pre># The script2.sh script 
#!/bin/bash 
echo $name </pre>
<p>Suppose that you want to use the <kbd>name</kbd> <span>variable </span>in the second script. If you try to print it, nothing will show up; this is because a variable's scope is only limited to the process that creates it.</p>
<p>To use the <kbd>name</kbd> variable, you can export it using the <kbd>export</kbd> command.</p>
<p>So, our code will be like this:</p>
<pre># The first script 
#!/bin/bash 
name="Mokhtar" 
export name # The variable will be accessible to other processes 
./script2.sh </pre>
<p>Now if you run the first script, it will print the name that came from the first script file.</p>
<p>Keep in mind that the second process or <kbd>script2.sh</kbd> only makes a copy of the variable and never touches the original one.</p>
<p>To prove this, try to change that variable from the second script and try to access that variable value from the first script:</p>
<pre># The first script 
#!/bin/bash 
name="Mokhtar" 
export name 
./script2.sh 
echo $name </pre>
<p>The second script will be like this:</p>
<pre># The first script 
#!/bin/bash 
name="Another name" 
echo $name </pre>
<p>If you run the first script, it will print the modified <kbd>name</kbd> from the second script and then it will print the original <kbd>name</kbd> from the first script. So, the original variable remains as it is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command substitution</h1>
                </header>
            
            <article>
                
<p>So far, we have seen how to declare variables. These variables can hold integers, strings, arrays, or floats, as we have seen, but this is not everything.</p>
<p>A command substitution means storing the output of a command execution in a variable.</p>
<p>As you might know, the <kbd>pwd</kbd> <span>command </span>prints the current working directory. So, we will see how to store its value in a variable.</p>
<p>There are two ways to perform a command substitution:</p>
<ul>
<li>Using the backtick character (<kbd>'</kbd>)</li>
<li>Using the dollar sign format, like this: <kbd>$()</kbd></li>
</ul>
<p>Using the first method, we just surround the command between two backticks:</p>
<pre>#!/bin/bash 
cur_dir='pwd'
echo $cur_dir </pre>
<p>And the second way is written as follows:</p>
<pre>#!/bin/bash 
cur_dir=$(pwd) 
echo $cur_dir </pre>
<p>The output coming from commands can be further processed and actions can be made based on that output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging your scripts</h1>
                </header>
            
            <article>
                
<p>With the scripts as simple as we have seen so far, there is little that can go wrong or need debugging. As the script grows and decision paths are included with conditional statements, we may need to use some level of debugging to analyze the scripts' progress better.</p>
<p>Bash provides two options for us, <kbd>-v</kbd> and <kbd>-x</kbd>.</p>
<p>If we want to look at the verbose output from our script and the detailed information about the way the script is evaluated line by line, we can use the <kbd>-v</kbd> option. This can be within the shebang, but it is often easier to run the script directly with bash:</p>
<pre><strong>$ bash -v $HOME/bin/hello2.sh fred</strong>  </pre>
<p>This is especially useful in this example as we can see how each element of the embedded <kbd>basename</kbd> command is processed. The first step is removing the quotes and then the parentheses. Take a look at the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-264 image-border" src="assets/9e6b913f-2cd8-49b5-af54-4b287f65b0d9.png" style="width:26.25em;height:12.67em;"/></div>
<p>The <kbd>-x</kbd> option, which displays the commands as they are executed, is more commonly used. It's useful to know the decision branch that has been chosen by the script. The following shows this in action:</p>
<pre><strong>$ bash -x $HOME/bin/hello2.sh fred</strong> </pre>
<p>We again see that the <kbd>basename</kbd> is evaluated first, but we do not see the more detailed steps involved in running that command. The screenshot that follows captures the command and output:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-265 image-border" src="assets/cc5c60c6-5587-46d7-ad8f-c3a513ad0e11.png" style="width:27.92em;height:9.83em;"/></div>
<p>The previous method might be hard for beginners or people who have a programming background in which they debugged their code visually.</p>
<p>Another modern way of debugging shell scripts is by using Visual Studio Code.</p>
<p>There is a plugin called <strong>bash debug</strong> that enables you to debug bash scripts visually, as is the case for any other programming language.</p>
<p>You can step into, step over, add watches, and do all the other usual debugging stuff you know.</p>
<p>After installing the plugin, from the <span class="packt_screen">File</span> menu, open your <kbd>shell-scripts</kbd> folder. Then you can configure the debugging process by pressing <em>Ctrl</em> + <em>Shift</em> + <em>P</em> and typing the following:</p>
<pre>Debug:open launch.json</pre>
<p>This will open an empty file; type in the following configurations:</p>
<pre>{ 
    "version": "0.2.0", 
    "configurations": [ 
         
        { 
            "name": "Packt Bash-Debug", 
            "type": "bashdb", 
            "request": "launch", 
            "scriptPath": "${command:SelectScriptName}", 
            "commandLineArguments": "", 
            "linux": { 
                "bashPath": "bash" 
            }, 
            "osx": { 
                "bashPath": "bash" 
            } 
        } 
    ] 
} </pre>
<p>This will create a debug configuration named <kbd>Packt Bash-Debug</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f43d6a8d-4e19-41fa-a3a7-269e73f4c5f8.png"/></div>
<p>Now insert a breakpoint and press <em>F5</em>, or start debugging from the <span class="packt_screen">Debug</span> menu; it will show you the list of <kbd>.sh</kbd> files:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/31f4f7c8-67f5-4b5e-87a9-9597df9a1566.png"/></div>
<p>Select the one you want to debug, and set a breakpoint on any line to test it, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/bbe3ea88-c551-4597-ac6d-21de73704fa0.png"/></div>
<p>You can add watches to watch variables' values while stepping over your lines of code:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ea379cba-8879-47ba-9a8c-223e1473ddee.png"/></div>
<div class="packt_infobox">Note that your script <strong>MUST</strong> start with the bash shebang, <kbd>#!/bin/bash</kbd>.</div>
<p>Now you can enjoy the visual method of debugging. Happy coding!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This marks the end of this chapter and you have no doubt found this useful. Especially for those making a start with bash scripting, this chapter will have established a firm foundation on which you can build your knowledge.</p>
<p>We began by ensuring that bash is secure and not susceptible to shell-shock from embedded functions. With bash secured, we considered the execution hierarchy where aliases, functions, and so on are checked before the command; knowing this can help us plan a good naming structure and a path to locate the scripts.</p>
<p>Then we went on to illustrate the types of Linux shells and we found out what bash scripting is.</p>
<p>Soon, we were writing simple scripts with static content, but we saw how easy it was to add flexibility using arguments. The exit code from the script can be read with the <kbd>$?</kbd> variable and we can create a command-line list using <kbd>||</kbd> and <kbd>&amp;&amp;</kbd>, which depends on the success or failure of the preceding command in the list.</p>
<p>Then we saw how to declare variables and how to use environment variables. We identified the variables' scope and saw how to export them to another process.</p>
<p>Also, we saw how to store commands' output in variables, which is called command substitution.</p>
<p>Finally, we closed the chapter by looking at debugging the script using bash options and VS Code. It's not really required when the script is trivial, but it will be useful later when complexity is added.</p>
<p>In the next chapter, we will create interactive scripts that read the user's input during script execution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the problem with the following code? And how do we fix it?</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
var1 ="Welcome to bash scripting ..." 
echo $var1 </pre>
<ol start="2">
<li>What is the result of the following code?</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
arr1=(Saturday Sunday Monday Tuesday Wednesday) 
echo ${arr1[3]} </pre>
<ol start="3">
<li>What is the problem with the following code? And how do we fix it?</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
files = 'ls -la' 
echo $files </pre>
<ol start="4">
<li>What is the value of the b and c variables in the following code?</li>
</ol>
<pre style="padding-left: 60px">#!/bin/bash 
a=15 
b=20 
c=a 
b=c </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Please see the following for further reading relating to this chapter:</p>
<ul>
<li><a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html"><span class="InternetLink">http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html</span><br/></a></li>
<li><a href="http://tldp.org/LDP/abs/html/varassignment.html"><span class="InternetLink">http://tldp.org/LDP/abs/html/varassignment.html</span><br/></a></li>
<li><a href="http://tldp.org/LDP/abs/html/declareref.html"><span class="InternetLink">http://tldp.org/LDP/abs/html/declareref.html</span><br/></a></li>
</ul>


            </article>

            
        </section>
    </body></html>