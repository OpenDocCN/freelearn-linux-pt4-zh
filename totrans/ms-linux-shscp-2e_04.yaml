- en: Creating Code Snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can write our conditional tests to make decisions. After your hands become
    faster in coding, you will need to save some code pieces for later use, so how
    to save time and effort when writing scripts?
  prefs: []
  type: TYPE_NORMAL
- en: If you like using the command line, but also like some of the features associated
    with using graphical **integrated development environments** (**IDEs**), then
    this chapter may reveal some new ideas to you. We can create shortcuts for commonly
    used script elements using the vi or vim text editors from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Abbreviations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using code snippets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating snippets using VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: Abbreviations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already taken one short sojourn into the `~/.vimrc` file and we will
    now revisit this file to look at abbreviations or `abbr` controls. This file acts
    as the run control mechanism for the vim text editor, which is likely to be installed
    on your Linux distribution. Older distributions or Unix variants may have the
    original vi text editor and will make use of the `~/.exrc` file. If you are uncertain
    of the identity of your version of vi and the correct run control file to use,
    simply enter the `vi` command. If a blank page opens, it is indeed vi. However,
    if a new blank document opens with the vim splash screens, then you are using
    the improved vim or vi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abbreviations allow for a shortcut string to be used in place of a longer string.
    These abbreviations can be set during a vim session from the last line mode but are
    often set in the control file. The shebang can be easily represented by an abbreviation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic syntax of an abbreviation is shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this abbreviation, we just need to type `_sh` while in the edit mode.
    On pressing the *Enter* key after the shortcut code, the full text for the shebang
    is printed. In reality, pressing any key after the `abbr` code will expand the
    shortcut, not just pressing the *Enter* key. Simple elements like this can add
    a lot to the experience of using vim as our text editor. The following screenshot
    shows the updated `~/.vimrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18a71227-66b4-4c86-92c2-be640ebb9c92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are not limited to the single abbreviation code, as we can add more `abbr`
    entries, for example, to support the shebang for Perl scripts at the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the underscore is not required, but the aim is to keep the shortcut
    code unique and not to have a typed error. We are also not limited to a single
    line, although this is where abbreviations are most used. Consider the following
    abbreviation for an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Although this does work, the formatting of the `if` statement will not be perfect
    and multiline abbreviations are far from ideal. This is where we may consider
    using code snippets that we have prepared in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Using code snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we mean by the term *code snippets* is a prepared code that we can read
    into our current script. This is especially easy with vim being able to read the
    contents of other text files during editing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we need to read the contents of a file called `if` located
    in `$HOME/snippets`, we will use the following key sequences in vim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The contents of this file are read into the current document below the current
    cursor position. In this way, we can make the code snippets as complex as we need
    and maintain the correct indentations to aide readability and consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will make it our duty to always create a snippets directory in our `home`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is not required to share the directory, so it is good practice to set the
    mode to `700` or private to the user when it is being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating snippets, it is your choice to use a pseudo-code or real examples.
    My preference is to use real examples that are edited to reflect the requirements
    of the recipient script. The contents of a simple `if` snippet will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the layout to create an `if` statement with a practical example.
    In this case, we check to see whether `$1` is unset and send an error to the user
    before exiting the script. The key is in keeping the snippet short to limit the
    changes that need to be made but make it easily understood and expandable as required.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing color to the Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are to display text messages to the users and operators executing the
    scripts, we can provide colors to help in message interpretation. Using red as
    a synonym for errors and green to indicate success makes it easier to add functionality
    to our scripts. Not all but certainly a vast majority of Linux Terminals support
    color. The built-in command `echo`, when used with the `-e` option, can display
    color to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display a text in red, we can use the `echo` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows both the code and the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3756bd4f-60e1-4b74-a125-7bc0accd7f75.png)'
  prefs: []
  type: TYPE_IMG
- en: The red text will bring immediate attention to the text and the potential failure
    of the script execution. The use of color in this way adheres to the basic principles
    of application design. If you find the code cumbersome, then simply use friendly
    variables to represent the colors and the reset code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, we used red and the final reset code to set the text
    back to the shell default. We could easily create variables for these color codes
    and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `\033` value is the escape character and `[31m` is the color code for red.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to take care while using variables, to ensure that they are properly
    delimited from the text. Modifying the earlier example, we can see how this is
    easily achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We use the brace brackets to ensure that the `RED` variable is identified and
    separated from the `Error` word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Saving the variable definitions to the `$HOME/snippets/color` file will allow
    them to be used in other scripts. Interestingly, we don''t need to edit this script;
    we can use the command `source` to read these variables definitions into the script
    at runtime. Within the recipient script, we need to add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the shell built-in `source` command will read the color variables into
    the script that is executing at runtime. The following screenshot shows a modified
    version of the `hello5.sh` script that we now call `hello7.sh`, which makes use
    of these colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9aa3334f-1525-472a-86f4-10a53c330ed5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the effect this has when we execute the script. In the following
    screenshot, you will see the execution and output both with and without a supplied
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71142b64-9bff-498c-82f2-2c13189ee3bf.png)'
  prefs: []
  type: TYPE_IMG
- en: We can easily identify the success and failure of the script through the color-coded
    output; the green `Hello fred` where we supply the parameter, and the red `Usage`
    statement where we have not provided the required name.
  prefs: []
  type: TYPE_NORMAL
- en: Creating snippets using VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those who love graphical IDEs, you can use VS Code as an editor for your
    shell scripts. We used it as a debugger in [Chapter 1](f439f212-0f5f-4c9d-abdb-9f9b8c199a78.xhtml),
    *The What and Why of Scripting with Bash*. Now we will see one of its capabilities
    as an editor.
  prefs: []
  type: TYPE_NORMAL
- en: You can create your own snippets in VS Code as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to File | Preferences | User Snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Then start to type `shell`. This will open the `shellscript.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file has two brackets ready to enter your snippets between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d01fff83-5f0a-42a7-aea0-6e15120a8809.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a snippet, type the following between the brackets on the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9400bc9c-4f58-43f0-bb77-33d4d76e651b.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use the following template and modify it based on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Try to use prefixes different to the shell scripting keywords to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open any `.sh` file and start to type `welcome`, the autocompletion
    will show you the snippet we have just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f87376e6-2924-4f8e-9b50-79fc8ba9e4de.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use any prefix you want; in our case, we used `welcome` so the autocompletion
    starts with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add many lines to your snippet body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can use placeholders in your snippet body to simplify code editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Placeholders are written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the previous snippet and add a placeholder like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When you start to type `welcome` and after you choose the snippet, you will
    notice that the cursor will stop at the exact position of the placeholder waiting
    for your input.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use choices if you forget what to type in these editable places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After you choose this snippet in your code and hit *Enter*, you should see
    the cursor waiting for your input with your choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24439a99-2597-4a4b-991c-13a3279e1e97.png)'
  prefs: []
  type: TYPE_IMG
- en: That's very helpful!
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can add a default value for the placeholder so this value will be
    written if you hit *Tab*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To any administrator, script reuse will always be upmost in the quest for efficiency.
    Using vim at the command line can make for very quick and effective editing of
    a script and we can save typing in the use of abbreviations. These are best set
    within a user's personal `.vimrc` file and are defined with the `abbr` control.
    Beyond abbreviations, we can see the sense in using code snippets. These are pre-prepared
    blocks of code that can be read into the current script.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we had a look at the value in using color at the command line where a
    script will provide feedback. In the first look, these color codes are not the
    friendliest, but we can simplify the process by using variables. We created variables
    with color codes and saved them to a file and by using source command, these variables
    will be available to our current environment.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to create code snippets using VS Code and how to add placeholders
    to simplify our code editing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at other mechanisms that we can use to write
    test expressions simplifying the use of integers and variables.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code creates a snippet which prints one line. How do you make
    the snippet with choices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Which command should you use to make your code snippets available for your use
    in the shell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://code.visualstudio.com/docs/editor/userdefinedsnippets](https://code.visualstudio.com/docs/editor/userdefinedsnippets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://brigade.engineering/sharpen-your-vim-with-snippets-767b693886db](https://brigade.engineering/sharpen-your-vim-with-snippets-767b693886db)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
