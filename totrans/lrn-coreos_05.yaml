- en: Chapter 5. Discovering Services Running in a Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When there are large numbers of members in a deployment, it's very important
    for the system to have easy manageability with the least human intervention possible.
    Human interventions tend to have human errors associated with them, making the
    system unstable. Imagine a scenario where there is a load balancer, which distributes
    HTTP traffic to multiple servers. If any servers go down or come up, it's very
    important that the load balancer knows about a node or service addition or deletion
    automatically without manual intervention, else it will be a nightmare managing
    such deployments. Service discovery ensures that the load balancer is aware of
    the currently active instances of services; based on this, it can take routing
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains the need and mechanism for the discovery of services running
    on a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction and necessity of service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mechanism for discovery of services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction and necessity of service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a CoreOS environment, all of the user applications will be deployed as services
    inside a container. For most of these, user applications need to work coherently
    and hence, a mechanism is needed to discover these services and service parameters.
    Service discovery via etcd provides a way to publish the services and the required
    parameters with a service to other services in the system. The service discovery
    mechanism is not only useful for service parameter discovery but also involves
    the detection of the change of state of a member (the addition of a new member
    or the removal of a member running a service or a member going down), the state
    of the service (the service providing an application comes up or goes down), and
    service parameters (like the IP and port on which the service is provided, database
    connection end points, and so on). It is a requirement that the service information
    is available across all members at all times, which means that the mechanism for
    service discovery should be replicated and made available through multiple members
    to avoid single point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanism for service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Features provided by the CoreOS services `etcd` and `fleetd` can be used to
    discover services. The following figure explains the typical mechanism used for
    service discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mechanism for service discovery](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapters, we have seen how `etcd` and `fleetd` can be used to
    discover the member nodes in a cluster. The etcd service is not limited for node
    discovery. It can be used to discover or publish information related to applications
    or services. The subsequent sections in this chapter cover how to publish and
    discover service-related information using etcd.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of member nodes in the cluster: frontend service nodes
    and backend service nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The frontend service handles all service requests and routes the request to
    the `backend` service for actual processing. This is the simplified but typical
    architecture for any high-capacity system. In the frontend service nodes, the
    following services will be running:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Discovery` service'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd` service'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fleetd` service'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend or route service
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backend service nodes are responsible for running the services that are being
    scheduled or routed by the frontend service nodes. In the backend service nodes,
    the following services will be running:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Register` service: If simple discovery is required, this can be included in
    the backend service unit file as `ExeStartPost`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd` service'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fleetd` service'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend or actual service
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fleetd` and `etcd` services are already discussed in detail in previous
    chapters. The Register service running in backend nodes updates the service information
    in the etcd key-value store, which will be published to the discovery service.
    The discovery services running in the frontend nodes are used to discover the
    backend member service information using etcd key-value store information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the complete flow of discovery step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Frontend` member is started. The fleetd service kicks in and schedules
    the `Frontend` and `Discovery` service . Service level affinity is used to ensure
    that both of them run together on a member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Discovery` service uses the `etcd` key-value store feature to look for
    backend member information. It also sets up a watch so that it comes to know of
    any changes in the service discovery information. We will learn about reading,
    writing, and setting up a watch on etcd later in this chapter. Since backend members
    are not started, no service information is available yet, so the discovery service
    is in wait mode looking for any updates in service information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the `backend` member is started. The `fleetd` service again kicks in
    and schedules the `Backend` and `Register` service. Here, also, service level
    affinity is used to ensure that both of them run together on a member. The Register
    service updates the service information in the `etcd` key-value store. This service
    information is useful for the frontend member. Service information can be endpoint
    information like IP and port, service type, or any other metadata necessary for
    the frontend to take an informed decision on scheduling the request. It's also
    important that a time to live is set on such data and the data is being periodically
    rewritten on etcd. Setting time to live on data ensures that service data also
    gets removed when service terminates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the `Discovery` service on the frontend member has set up a watch on etcd,
    it comes to know about new service instance additions. It then updates the frontend
    service that adds the service instance. Based on the information available, the
    frontend service can start scheduling the incoming request to the service instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once other members are started, service discovery keeps on happening as explained
    in the previous step and the frontend service becomes aware of more and more service
    instances for the scheduling request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, assume one of the members went down. The service information gets erased
    from `etcd` after the time to live if they are not updated again. The same will
    happen when the member is up and running but the backend service goes down and
    is not able to come up again. In this scenario, `fleetd` will bring down the Register
    service also, since they are bound together. If they don't come up further on
    the member, the service parameter will again expire on `etcd` after time to live.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter deletion is again detected by the `Discovery` service and the information
    passed to the `Frontend` service. The `Frontend` service now knows that there
    is one less service instance to work on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this is only a conceptual representation of the whole process. There
    is no restriction that your frontend application and discovery services should
    be two separate applications or services. There is a possibility that your frontend
    application could also contain the discovery services. When you use a third party
    or readymade frontend application like `HAProxy`, then you may need to write a
    thin discovery service or you can also use `confd`, another readymade application
    for discovery. Similarly, the backend service and register service can be fused
    together or you can use another readymade application, `forest`, to directly update
    `etcd` without writing a register service.
  prefs: []
  type: TYPE_NORMAL
- en: Operations of etcd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`etcd` provides the following three operations for manipulating the key-value
    store:'
  prefs: []
  type: TYPE_NORMAL
- en: etcd write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: etcd read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: etcd watch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two main interfaces provided by CoreOS to perform the preceding `etcd`
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`etcdctl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST-based interface. `cURL` can be used to invoke REST APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations using etcdctl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`etcdctl` is a command-line client of `etcd`. Using `etcdctl`, you can read,
    write, and watch the key-value store of etcd. `etcdctl` can be used as a standalone
    tool for configuring the key-value store or can also be used in scripts. `etcdctl`
    sends the request message to the `etcd` service and waits for the response from
    etcd. `etcdctl` can return any one of the following return codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Return value | Semantics |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Success |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Malformed etcdctl arguments |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Failed to connect to host |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Failed to auth (client cert rejected, ca validation failure, and so on)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 400 error from etcd |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 500 error from etcd |'
  prefs: []
  type: TYPE_TB
- en: etcd write using etcdctl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The etcd write service will be used by the backend nodes to publish the service
    information using the key-value data store to the frontend services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following write operations are possible using `etcdctl`. The following
    table lists the command options provided by `etcdctl` with syntax and examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operations | Command syntax | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Setting value for a key | `etcdctl set <key> <value>` | `$ etcdctl set /foo/bar
    "foo bar"` |'
  prefs: []
  type: TYPE_TB
- en: '| Setting value for a key with expiry in seconds | `etcdctl set <key> <value>
    –ttl` | `$ etcdctl set /foo/bar "foo bar" –ttl 10` |'
  prefs: []
  type: TYPE_TB
- en: '| Conditionally setting value for a key based on the previous value | `etcdctl
    set /<key> <old-value> --swap-with-value <new-value>` | `$ etcdctl set /foo/bar
    "foo bar" --swap-with-value "bar foo"` |'
  prefs: []
  type: TYPE_TB
- en: '| Creating a new key | `etcdctl mk <key> <value>` | `$ etcdctl mk /foo/bar
    "foo bar"` |'
  prefs: []
  type: TYPE_TB
- en: '| Creating a new directory | `etcdctl mkdir <dir>` | `$ etcdctl mkdir /foo/bar`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Updating value for a key | `etcdctl update <key> <value>` | `$ etcdctl set
    /foo/bar "bar foo"` |'
  prefs: []
  type: TYPE_TB
- en: '| Deleting a key | `etcdctl rm <key>` | `$ etcdctl rm /foo/bar` |'
  prefs: []
  type: TYPE_TB
- en: '| Deleting a key and all its child key recursively | `etcdctl rm <key> --recursive`
    | `$ etcdctl rm /foo/bar –recursive` |'
  prefs: []
  type: TYPE_TB
- en: '| Conditionally deleting a key | `etcdctl rm <key> --with-value <value>` |
    `$ etcdctl rm /foo/bar --with-value "foo bar"` |'
  prefs: []
  type: TYPE_TB
- en: '| Deleting a directory | `etcdctl rmdir <dir>` | `$ etcdctl rmdir /foo/bar`
    |'
  prefs: []
  type: TYPE_TB
- en: etcd read using etcdctl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `etcd read` service will be used by the frontend nodes to discover the service
    information using the key-value data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following read operations are possible using `etcdctl`. The following table
    lists the command options provided by `etcdctl` with syntax and examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operations | Command syntax | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieving a key-value | `etcdctl get <key>` | `$ etcdctl get /foo/bar``foo
    bar` |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieving a key-value with additional metadata | `etcdctl -o extended get
    <key>` | `$ etcdctl -o extended get /foo/bar`Key: /foo/barModified-Index: 72TTL:
    0Etcd-Index: 72Raft-Index: 5611Raft-Term: 1foo bar |'
  prefs: []
  type: TYPE_TB
- en: '| Creating a new key | `etcdctl mk <key> <value>` | `$ etcdctl mk /foo/bar
    "foo bar"` |'
  prefs: []
  type: TYPE_TB
- en: '| Listing the directory | `etcdctl ls` | `$ etcdctl ls``/foo` |'
  prefs: []
  type: TYPE_TB
- en: '| Listing the directory recursively | `etcdctl ls –recursive` | `$ etcdctl
    ls --recursive``/foo``/foo/bar` |'
  prefs: []
  type: TYPE_TB
- en: With our `testservices` example, the following command is used to read the parameters
    using `etcdctl`. Note that we are using the `ls` command here to get the list
    of services and then querying on a specific service instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: etcd watch using etcdctl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `etcd` `watch` service will be used by the frontend nodes to monitor or
    watch for any change in the key-value data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following watch operations are possible using `etcdctl`. The following
    table lists the command options provided by `etcdctl` with syntax and examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operations | Command syntax | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Watching for any change in the key-value. | `etcdctl watch <key>` | `$ etcdctl
    watch /foo/bar` |'
  prefs: []
  type: TYPE_TB
- en: '| Continuously watching any change in the key-value. In this case, etcdctl
    hangs forever until *Ctrl* + *C* and it prints the value when there is a change
    in the key-value. | `etcdctl watch <key> --forever` | `$ etcdctl watch /foo/bar
    --forever``foo bar` |'
  prefs: []
  type: TYPE_TB
- en: '| Continuously watching any change in the key-value and executes a program
    when there is a change in the key-value. | `etcdctl exec-watch <key> --sh -c program
    to execute` | `$ etcdctl exec-watch -- sh -c env &#124; grep ETCD` |'
  prefs: []
  type: TYPE_TB
- en: Example of etcd using etcdctl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Until now, we have seen how a service parameter can be published and discovered
    in theoretical fashion. Now it's time for some practical work. Let's start off
    by getting ourselves familiar with the etcd key-value store features used for
    discovery and how to use them with an example of a service called `testservices`,
    which publishes the IP address and port number on which this service is running.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `testservices` is the directory where all the new service information
    is added. IP is the IP of the member and `5555` is the port (chosen for this example)
    on which a service is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the command to write the IP address and port on which a service
    is added with the key as IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An optional parameter, `–ttl 30`, is added to set the lifetime for the key as
    30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our example, we have chosen to show how to write the IP address and port
    number key to the key-store. Please note that there are various ways to learn
    about the IP address on which a service is running programmatically. The environment
    variables `COREOS_PRIVATE_IPV4` and `COREOS_PUBLIC_IPV4` can be used or the `ipconfig`
    command can be used to find out the IP address assigned for the member.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the parameters published by `testservices`, the following command should
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To watch these parameters the following command should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The following are the commands to write entries that we queried using `etcdctl`
    before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Operations using cURL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**cURL**, often referred to as `curl`, is a command-line tool used to transfer
    data to and from application servers using various protocols. cURL supports a
    range of protocols including **HTTPS**, **HTTP**, **FTPS**, **FTP**, **SCP**,
    **TFTP**, **SFTP**, **DAP**, **LDAP**, **DICT**, **TELNET**, **IMAP**, **FILE**,
    **POP3**, **SMTP**, and **RTSP**. It is often used for getting or sending files
    using URL like syntax. Like `etcdctl`, curl can also be used as a standalone tool
    for configuring the key-value store or can also be used in scripts. All the operations
    that can be done using `etcdctl` can also be done using curl. curl also provides
    more operations to manipulate the key-value store. curl sends a request message
    to the etcd service and waits for the response. The response contains the following
    parameters/attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Action: The action field represents the type of curl request sent. The action
    can take the value as `get, set, create, delete, update, expire, watch`, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node: The `node` field represents the directories of the key-value store. It
    consists of key, value, `createIndex`, and `modifiedIndex`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `key` field represents the key of the key-value store.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `value` field represents the value of the key-value store.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Every node has a field called `index`, which will be incremented for each change
    to `etcd`. The `createdIndex` field is filled with this index.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modifiedIndex` also represents the index of the node. However, this represents
    the number of operations that are applied over this node, which changes the value
    of this key-value store.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample output of a `curl set` command is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: etcd read using curl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following read operations are possible using curl. The following table
    lists the command options provided by curl with syntax and examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operations | Command syntax | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieving a key-value | `curl -L <URL>` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Retrieving a key-value recursively | `curl -L <URL> ? ?recursive=true&sorted=true`
    | `curl -L ''http://127.0.0.1:4001/v2/keys/foo/bar?recursive=true&sorted=true''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: etcd write using curl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following write operations are possible using `curl`. The following table
    lists the command options provided by curl with syntax and examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operations | Command syntax | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Setting value for a key | `curl –L <URL> -XPUT -d value=<value>` | `curl
    -L http://127.0.0.1:4001/v2/keys/foo/bar -XPUT -d value="foo bar"`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting value for a key with expiry in seconds | `curl –L <URL> -XPUT -d
    value=<value> -d ttl=<value>` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar
    -XPUT -d value="foo bar" –d ttl=5`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Updating value for a key | `curl –L <URL> -XPUT -d value=<value>` | `curl
    -L http://127.0.0.1:4001/v2/keys/foo/bar -XPUT -d value="foo bar2"`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Deleting a key | `curl –L <URL> -XDELETE` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar
    -XDELETE`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: etcd watch using curl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following watch operations are possible using `curl`. The following table
    lists the command options provided by curl with syntax and examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operations | Command syntax | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Watching for any change in the key-value | `curl –L <URL>?wait=true` | `curl
    -L http://127.0.0.1:4001/v2/keys/foo/bar?wait=true` |'
  prefs: []
  type: TYPE_TB
- en: Example using curl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's see how to use curl with our `testservices` that want to publish the IP
    address and port number in which this service is running.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `testservices` is the directory where all the new service information
    is added. IP is the IP of the member and `5555` is the port (chosen for this example)
    on which a service is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the command to write the IP address and port on which a service
    is added with the key as IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the parameters published by `testservices`, the following command should
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To watch these parameters, the following command should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: HAProxy and service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we use service discovery to create a web service that has multiple
    backend nodes with HAProxy frontend and then load balancing the service requests.
    HAProxy is a commonly used load balancer for TCP and HTTP-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by understanding a typical HAProxy configuration. We are not going
    to cover the HAProxy configuration exhaustively, but will only concentrate on
    the configurations that are relevant for service discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This configuration instructs HAProxy to bind to port `80` and forward HTTP traffic
    to the servers `172.17.18.10` and `172.17.18.102` in a round robin fashion. When
    we have information on every backend server, we can configure HAProxy statically
    and the setup will work. But imagine a scenario where the information on the IP
    is not available. For example, when IPs are allocated dynamically or the number
    of nodes keeps increasing as the traffic to the server increases. We can use service
    discovery to keep HAProxy updated with the addition and deletion of the backend
    dynamically. We will make ourselves familiar with another tool called confd. We
    will use confd as a discovery service. confd has the capability of watching the
    etcd key store, it then prepares a configuration file based on the template and
    copies the configuration file to the location required by the applications, and
    invokes a command asking an application to reload the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: confd requires a template application configuration file in the directory `/etc/confd/templates`
    and a confd configuration file in the directory `/etc/confd/conf.d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the configuration file `testconfd.toml` for confd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This configuration file mentions that the HAProxy template filename is `haproxy.cfg.tmpl`.
    The configuration file prepared based on the template file has to be copied to
    `/etc/haproxy/haproxy.cfg`. The configuration file also mentions that the etcd
    key is `/testservice/backend`. Finally, it invokes the command to reload HAProxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how the template file `haproxy.cfg.tmpl` would look for the
    HAProxy configuration file we have seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The range directive loops through etcd keys and prepares the entries for each
    name. The base directive used is very similar to the base-name utility of Linux.
    For the etcd keys written in this chapter before, the corresponding entries would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, coming to the backend servers, we can add the command (`etcdctl` or `curl`)
    to update the system IP address in etcd using `ExeStartPost`. confd would then
    update the frontend HAProxy with the new configuration as and when backend servers
    come up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood discovery services, why it is very important
    while developing services or applications in a CoreOS environment, how to publish
    a service and its parameters, and how to watch for changes in the state of the
    services. We also learned about the two important tools, etcdctl and curl, that
    are widely used for service discovery, with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how different services running inside a CoreOS
    cluster can communicate with each other using service chaining mechanisms.
  prefs: []
  type: TYPE_NORMAL
