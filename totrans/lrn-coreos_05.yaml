- en: Chapter 5. Discovering Services Running in a Cluster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：发现运行在集群中的服务
- en: When there are large numbers of members in a deployment, it's very important
    for the system to have easy manageability with the least human intervention possible.
    Human interventions tend to have human errors associated with them, making the
    system unstable. Imagine a scenario where there is a load balancer, which distributes
    HTTP traffic to multiple servers. If any servers go down or come up, it's very
    important that the load balancer knows about a node or service addition or deletion
    automatically without manual intervention, else it will be a nightmare managing
    such deployments. Service discovery ensures that the load balancer is aware of
    the currently active instances of services; based on this, it can take routing
    decisions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署中有大量成员时，系统需要具备易于管理的特性，且尽量减少人工干预。人工干预往往会带来人为错误，使系统不稳定。设想一个场景：有一个负载均衡器，将HTTP流量分发到多个服务器。如果任何服务器宕机或上线，负载均衡器必须自动知道节点或服务的增加或删除，而无需人工干预，否则管理这样的部署将是一场噩梦。服务发现确保负载均衡器能够了解当前活跃的服务实例；基于此，它可以做出路由决策。
- en: This chapter explains the need and mechanism for the discovery of services running
    on a cluster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了发现运行在集群中的服务的需求和机制。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introduction and necessity of service discovery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现的介绍和必要性
- en: Mechanism for discovery of services.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现机制
- en: Introduction and necessity of service discovery
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现的介绍和必要性
- en: In a CoreOS environment, all of the user applications will be deployed as services
    inside a container. For most of these, user applications need to work coherently
    and hence, a mechanism is needed to discover these services and service parameters.
    Service discovery via etcd provides a way to publish the services and the required
    parameters with a service to other services in the system. The service discovery
    mechanism is not only useful for service parameter discovery but also involves
    the detection of the change of state of a member (the addition of a new member
    or the removal of a member running a service or a member going down), the state
    of the service (the service providing an application comes up or goes down), and
    service parameters (like the IP and port on which the service is provided, database
    connection end points, and so on). It is a requirement that the service information
    is available across all members at all times, which means that the mechanism for
    service discovery should be replicated and made available through multiple members
    to avoid single point of failure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在CoreOS环境中，所有用户应用程序都将作为服务部署在容器内。对于大多数应用程序，用户应用需要协同工作，因此需要一种机制来发现这些服务及其参数。通过etcd进行服务发现提供了一种将服务及其所需参数发布给系统中其他服务的方法。服务发现机制不仅对服务参数的发现有用，还涉及成员状态的检测（如新成员的加入、提供服务的成员的移除或成员宕机），以及服务状态（如提供应用的服务启动或停止）和服务参数（如服务提供的IP和端口、数据库连接端点等）。服务信息必须在所有成员之间始终可用，这意味着服务发现机制应通过多个成员进行复制，并始终可用，以避免单点故障。
- en: Mechanism for service discovery
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现机制
- en: 'Features provided by the CoreOS services `etcd` and `fleetd` can be used to
    discover services. The following figure explains the typical mechanism used for
    service discovery:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS 服务`etcd`和`fleetd`提供的功能可以用于发现服务。下图解释了用于服务发现的典型机制：
- en: '![Mechanism for service discovery](img/00022.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![服务发现机制](img/00022.jpeg)'
- en: In the previous chapters, we have seen how `etcd` and `fleetd` can be used to
    discover the member nodes in a cluster. The etcd service is not limited for node
    discovery. It can be used to discover or publish information related to applications
    or services. The subsequent sections in this chapter cover how to publish and
    discover service-related information using etcd.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到如何使用`etcd`和`fleetd`来发现集群中的成员节点。etcd服务不仅限于节点发现，还可以用于发现或发布与应用程序或服务相关的信息。本章接下来的部分将介绍如何使用etcd发布和发现与服务相关的信息。
- en: 'There are two kinds of member nodes in the cluster: frontend service nodes
    and backend service nodes.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中有两种类型的成员节点：前端服务节点和后端服务节点。
- en: 'The frontend service handles all service requests and routes the request to
    the `backend` service for actual processing. This is the simplified but typical
    architecture for any high-capacity system. In the frontend service nodes, the
    following services will be running:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端服务处理所有的服务请求，并将请求路由到`backend`服务进行实际处理。这是任何高容量系统的简化但典型的架构。在前端服务节点中，将运行以下服务：
- en: '`Discovery` service'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Discovery`服务'
- en: '`etcd` service'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`服务'
- en: '`fleetd` service'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fleetd`服务'
- en: Frontend or route service
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端或路由服务
- en: 'Backend service nodes are responsible for running the services that are being
    scheduled or routed by the frontend service nodes. In the backend service nodes,
    the following services will be running:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端服务节点负责运行前端服务节点调度或路由的服务。在后端服务节点中，将运行以下服务：
- en: '`Register` service: If simple discovery is required, this can be included in
    the backend service unit file as `ExeStartPost`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Register`服务：如果需要简单的服务发现，可以将其包含在后端服务单元文件中的`ExeStartPost`中。'
- en: '`etcd` service'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`服务'
- en: '`fleetd` service'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fleetd`服务'
- en: Backend or actual service
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端或实际服务
- en: The `fleetd` and `etcd` services are already discussed in detail in previous
    chapters. The Register service running in backend nodes updates the service information
    in the etcd key-value store, which will be published to the discovery service.
    The discovery services running in the frontend nodes are used to discover the
    backend member service information using etcd key-value store information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`fleetd`和`etcd`服务已经在前面的章节中详细讨论过。运行在后端节点的Register服务会更新服务信息到etcd键值存储，这些信息将发布到发现服务。运行在前端节点的发现服务用于通过etcd键值存储信息来发现后端成员的服务信息。'
- en: 'Let''s understand the complete flow of discovery step by step:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步了解发现的完整流程：
- en: The `Frontend` member is started. The fleetd service kicks in and schedules
    the `Frontend` and `Discovery` service . Service level affinity is used to ensure
    that both of them run together on a member.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动了`Frontend`成员。fleetd服务启动并调度`Frontend`和`Discovery`服务。使用服务级亲和性来确保它们一起运行在同一个成员上。
- en: The `Discovery` service uses the `etcd` key-value store feature to look for
    backend member information. It also sets up a watch so that it comes to know of
    any changes in the service discovery information. We will learn about reading,
    writing, and setting up a watch on etcd later in this chapter. Since backend members
    are not started, no service information is available yet, so the discovery service
    is in wait mode looking for any updates in service information.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Discovery`服务使用`etcd`键值存储功能来查找后端成员信息。它还设置了一个监视，以便了解服务发现信息的任何变化。我们将在本章稍后了解如何读取、写入并设置etcd的监视。由于后端成员尚未启动，因此没有可用的服务信息，因此发现服务处于等待模式，等待服务信息的任何更新。'
- en: One of the `backend` member is started. The `fleetd` service again kicks in
    and schedules the `Backend` and `Register` service. Here, also, service level
    affinity is used to ensure that both of them run together on a member. The Register
    service updates the service information in the `etcd` key-value store. This service
    information is useful for the frontend member. Service information can be endpoint
    information like IP and port, service type, or any other metadata necessary for
    the frontend to take an informed decision on scheduling the request. It's also
    important that a time to live is set on such data and the data is being periodically
    rewritten on etcd. Setting time to live on data ensures that service data also
    gets removed when service terminates.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动了其中一个`backend`成员。`fleetd`服务再次启动并调度`Backend`和`Register`服务。这里同样使用服务级亲和性来确保它们一起运行在同一个成员上。Register服务将服务信息更新到`etcd`键值存储中。这些服务信息对前端成员很有用。服务信息可以是端点信息，如IP和端口、服务类型或任何其他元数据，这些都对前端在调度请求时做出明智决定非常必要。设置数据的生存时间并定期重写数据到etcd上也很重要。为数据设置生存时间可确保当服务终止时，服务数据也会被移除。
- en: Since the `Discovery` service on the frontend member has set up a watch on etcd,
    it comes to know about new service instance additions. It then updates the frontend
    service that adds the service instance. Based on the information available, the
    frontend service can start scheduling the incoming request to the service instance.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于前端成员上的`Discovery`服务已经在etcd上设置了监视，它可以得知新的服务实例的增加。然后，它会更新前端服务，添加该服务实例。根据可用的信息，前端服务可以开始将传入的请求调度到该服务实例。
- en: Once other members are started, service discovery keeps on happening as explained
    in the previous step and the frontend service becomes aware of more and more service
    instances for the scheduling request.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦其他成员启动，服务发现会继续按前面步骤所述进行，前端服务将意识到更多的服务实例用于调度请求。
- en: Now, assume one of the members went down. The service information gets erased
    from `etcd` after the time to live if they are not updated again. The same will
    happen when the member is up and running but the backend service goes down and
    is not able to come up again. In this scenario, `fleetd` will bring down the Register
    service also, since they are bound together. If they don't come up further on
    the member, the service parameter will again expire on `etcd` after time to live.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，假设某个成员出现故障。如果服务信息在超时时间后没有再次更新，它会从 `etcd` 中删除。类似地，当成员恢复正常，但后端服务出现故障且无法再次启动时，`fleetd`
    会关闭注册服务，因为它们是绑定在一起的。如果它们在成员上无法再次启动，服务参数将在超时时间后再次在 `etcd` 上过期。
- en: Parameter deletion is again detected by the `Discovery` service and the information
    passed to the `Frontend` service. The `Frontend` service now knows that there
    is one less service instance to work on.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数删除会被 `Discovery` 服务检测到，并将信息传递给 `Frontend` 服务。现在，`Frontend` 服务知道有一个服务实例被删除了。
- en: Note that this is only a conceptual representation of the whole process. There
    is no restriction that your frontend application and discovery services should
    be two separate applications or services. There is a possibility that your frontend
    application could also contain the discovery services. When you use a third party
    or readymade frontend application like `HAProxy`, then you may need to write a
    thin discovery service or you can also use `confd`, another readymade application
    for discovery. Similarly, the backend service and register service can be fused
    together or you can use another readymade application, `forest`, to directly update
    `etcd` without writing a register service.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是整个过程的概念性表示。并没有限制你的前端应用程序和发现服务必须是两个独立的应用或服务。你的前端应用程序也可能包含发现服务。当你使用第三方或现成的前端应用程序如
    `HAProxy` 时，你可能需要编写一个简化的发现服务，或者你也可以使用 `confd`，这是另一个现成的发现应用程序。同样，后端服务和注册服务可以结合在一起，或者你可以使用另一个现成的应用程序
    `forest`，直接更新 `etcd`，而无需编写注册服务。
- en: Operations of etcd
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: etcd 操作
- en: '`etcd` provides the following three operations for manipulating the key-value
    store:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`etcd` 提供以下三种操作来操作键值存储：'
- en: etcd write
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd 写操作
- en: etcd read
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd 读取
- en: etcd watch
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd 监听
- en: 'There are two main interfaces provided by CoreOS to perform the preceding `etcd`
    operations:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS 提供了两种主要的接口来执行前述 `etcd` 操作：
- en: '`etcdctl`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcdctl`'
- en: REST-based interface. `cURL` can be used to invoke REST APIs.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 REST 的接口。可以使用 `cURL` 来调用 REST API。
- en: Operations using etcdctl
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 etcdctl 的操作
- en: '`etcdctl` is a command-line client of `etcd`. Using `etcdctl`, you can read,
    write, and watch the key-value store of etcd. `etcdctl` can be used as a standalone
    tool for configuring the key-value store or can also be used in scripts. `etcdctl`
    sends the request message to the `etcd` service and waits for the response from
    etcd. `etcdctl` can return any one of the following return codes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`etcdctl` 是 `etcd` 的命令行客户端。使用 `etcdctl`，你可以读取、写入和监听 `etcd` 的键值存储。`etcdctl`
    可以作为配置键值存储的独立工具使用，也可以在脚本中使用。`etcdctl` 会向 `etcd` 服务发送请求消息，并等待来自 etcd 的响应。`etcdctl`
    可以返回以下任一返回码：'
- en: '| Return value | Semantics |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 返回值 | 语义 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Success |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 成功 |'
- en: '| 1 | Malformed etcdctl arguments |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1 | etcdctl 参数格式错误 |'
- en: '| 2 | Failed to connect to host |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 无法连接到主机 |'
- en: '| 3 | Failed to auth (client cert rejected, ca validation failure, and so on)
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 认证失败（客户端证书被拒绝，CA 验证失败等） |'
- en: '| 4 | 400 error from etcd |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 来自 etcd 的 400 错误 |'
- en: '| 5 | 500 error from etcd |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 来自 etcd 的 500 错误 |'
- en: etcd write using etcdctl
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 etcdctl 进行 etcd 写操作
- en: The etcd write service will be used by the backend nodes to publish the service
    information using the key-value data store to the frontend services.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: etcd 写操作服务将被后端节点用于通过键值数据存储发布服务信息到前端服务。
- en: 'The following write operations are possible using `etcdctl`. The following
    table lists the command options provided by `etcdctl` with syntax and examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `etcdctl` 可以执行以下写操作。下表列出了 `etcdctl` 提供的命令选项，包括语法和示例：
- en: '| Operations | Command syntax | Example |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 命令语法 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Setting value for a key | `etcdctl set <key> <value>` | `$ etcdctl set /foo/bar
    "foo bar"` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 设置一个键的值 | `etcdctl set <key> <value>` | `$ etcdctl set /foo/bar "foo bar"`
    |'
- en: '| Setting value for a key with expiry in seconds | `etcdctl set <key> <value>
    –ttl` | `$ etcdctl set /foo/bar "foo bar" –ttl 10` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 设置一个带有过期时间（秒）的键值 | `etcdctl set <key> <value> –ttl` | `$ etcdctl set /foo/bar
    "foo bar" –ttl 10` |'
- en: '| Conditionally setting value for a key based on the previous value | `etcdctl
    set /<key> <old-value> --swap-with-value <new-value>` | `$ etcdctl set /foo/bar
    "foo bar" --swap-with-value "bar foo"` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 基于先前值有条件地设置键的值 | `etcdctl set /<key> <old-value> --swap-with-value <new-value>`
    | `$ etcdctl set /foo/bar "foo bar" --swap-with-value "bar foo"` |'
- en: '| Creating a new key | `etcdctl mk <key> <value>` | `$ etcdctl mk /foo/bar
    "foo bar"` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个新键 | `etcdctl mk <key> <value>` | `$ etcdctl mk /foo/bar "foo bar"` |'
- en: '| Creating a new directory | `etcdctl mkdir <dir>` | `$ etcdctl mkdir /foo/bar`
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个新目录 | `etcdctl mkdir <dir>` | `$ etcdctl mkdir /foo/bar` |'
- en: '| Updating value for a key | `etcdctl update <key> <value>` | `$ etcdctl set
    /foo/bar "bar foo"` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 更新一个键的值 | `etcdctl update <key> <value>` | `$ etcdctl set /foo/bar "bar foo"`
    |'
- en: '| Deleting a key | `etcdctl rm <key>` | `$ etcdctl rm /foo/bar` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 删除一个键 | `etcdctl rm <key>` | `$ etcdctl rm /foo/bar` |'
- en: '| Deleting a key and all its child key recursively | `etcdctl rm <key> --recursive`
    | `$ etcdctl rm /foo/bar –recursive` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 递归删除一个键及其所有子键 | `etcdctl rm <key> --recursive` | `$ etcdctl rm /foo/bar –recursive`
    |'
- en: '| Conditionally deleting a key | `etcdctl rm <key> --with-value <value>` |
    `$ etcdctl rm /foo/bar --with-value "foo bar"` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 有条件地删除一个键 | `etcdctl rm <key> --with-value <value>` | `$ etcdctl rm /foo/bar
    --with-value "foo bar"` |'
- en: '| Deleting a directory | `etcdctl rmdir <dir>` | `$ etcdctl rmdir /foo/bar`
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 删除一个目录 | `etcdctl rmdir <dir>` | `$ etcdctl rmdir /foo/bar` |'
- en: etcd read using etcdctl
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: etcd 使用etcdctl进行读取
- en: The `etcd read` service will be used by the frontend nodes to discover the service
    information using the key-value data store.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`etcd read`服务将由前端节点用于通过键值数据存储来发现服务信息。'
- en: 'The following read operations are possible using `etcdctl`. The following table
    lists the command options provided by `etcdctl` with syntax and examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`etcdctl`可以执行的读取操作。下表列出了`etcdctl`提供的命令选项、语法和示例：
- en: '| Operations | Command syntax | Example |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 命令语法 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Retrieving a key-value | `etcdctl get <key>` | `$ etcdctl get /foo/bar``foo
    bar` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 检索一个键值 | `etcdctl get <key>` | `$ etcdctl get /foo/bar``foo bar` |'
- en: '| Retrieving a key-value with additional metadata | `etcdctl -o extended get
    <key>` | `$ etcdctl -o extended get /foo/bar`Key: /foo/barModified-Index: 72TTL:
    0Etcd-Index: 72Raft-Index: 5611Raft-Term: 1foo bar |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 带有附加元数据的检索键值 | `etcdctl -o extended get <key>` | `$ etcdctl -o extended get
    /foo/bar`键：/foo/bar修改索引：72TTL：0Etcd索引：72Raft索引：5611Raft任期：1foo bar |'
- en: '| Creating a new key | `etcdctl mk <key> <value>` | `$ etcdctl mk /foo/bar
    "foo bar"` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个新键 | `etcdctl mk <key> <value>` | `$ etcdctl mk /foo/bar "foo bar"` |'
- en: '| Listing the directory | `etcdctl ls` | `$ etcdctl ls``/foo` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 列出目录 | `etcdctl ls` | `$ etcdctl ls``/foo` |'
- en: '| Listing the directory recursively | `etcdctl ls –recursive` | `$ etcdctl
    ls --recursive``/foo``/foo/bar` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 递归列出目录 | `etcdctl ls –recursive` | `$ etcdctl ls --recursive``/foo``/foo/bar`
    |'
- en: With our `testservices` example, the following command is used to read the parameters
    using `etcdctl`. Note that we are using the `ls` command here to get the list
    of services and then querying on a specific service instance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`testservices`示例，以下命令用于通过`etcdctl`读取参数。请注意，我们在这里使用`ls`命令获取服务列表，然后查询特定的服务实例。
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: etcd watch using etcdctl
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: etcd 使用etcdctl进行监视
- en: The `etcd` `watch` service will be used by the frontend nodes to monitor or
    watch for any change in the key-value data store.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`etcd`的`watch`服务将由前端节点用于监控或观察键值数据存储中的任何变化。'
- en: 'The following watch operations are possible using `etcdctl`. The following
    table lists the command options provided by `etcdctl` with syntax and examples:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`etcdctl`可以执行的监视操作。下表列出了`etcdctl`提供的命令选项、语法和示例：
- en: '| Operations | Command syntax | Example |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 命令语法 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Watching for any change in the key-value. | `etcdctl watch <key>` | `$ etcdctl
    watch /foo/bar` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 监视键值的任何变化。 | `etcdctl watch <key>` | `$ etcdctl watch /foo/bar` |'
- en: '| Continuously watching any change in the key-value. In this case, etcdctl
    hangs forever until *Ctrl* + *C* and it prints the value when there is a change
    in the key-value. | `etcdctl watch <key> --forever` | `$ etcdctl watch /foo/bar
    --forever``foo bar` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 持续监控键值的任何变化。在此情况下，etcdctl 会一直挂起，直到按下*Ctrl* + *C*，并且当键值发生变化时，它会打印该值。 | `etcdctl
    watch <key> --forever` | `$ etcdctl watch /foo/bar --forever``foo bar` |'
- en: '| Continuously watching any change in the key-value and executes a program
    when there is a change in the key-value. | `etcdctl exec-watch <key> --sh -c program
    to execute` | `$ etcdctl exec-watch -- sh -c env &#124; grep ETCD` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 持续监视密钥值的任何变化，并在密钥值发生变化时执行程序。 | `etcdctl exec-watch <key> --sh -c 要执行的程序`
    | `$ etcdctl exec-watch -- sh -c env &#124; grep ETCD` |'
- en: Example of etcd using etcdctl
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用etcdctl的etcd示例
- en: Until now, we have seen how a service parameter can be published and discovered
    in theoretical fashion. Now it's time for some practical work. Let's start off
    by getting ourselves familiar with the etcd key-value store features used for
    discovery and how to use them with an example of a service called `testservices`,
    which publishes the IP address and port number on which this service is running.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经以理论方式了解了如何发布和发现服务参数。现在是时候进行一些实际操作了。让我们从熟悉用于发现的etcd键值存储功能开始，并通过一个名为`testservices`的服务示例来展示如何使用它，该服务发布了该服务运行的IP地址和端口号。
- en: Here, `testservices` is the directory where all the new service information
    is added. IP is the IP of the member and `5555` is the port (chosen for this example)
    on which a service is running.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`testservices`是添加所有新服务信息的目录。IP是成员的IP地址，`5555`是服务运行的端口（此示例中选择的端口）。
- en: 'The following is the command to write the IP address and port on which a service
    is added with the key as IP:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于将IP地址和端口（使用IP作为键）写入的命令：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An optional parameter, `–ttl 30`, is added to set the lifetime for the key as
    30 seconds.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数`–ttl 30`被添加，用于设置密钥的生命周期为30秒。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In our example, we have chosen to show how to write the IP address and port
    number key to the key-store. Please note that there are various ways to learn
    about the IP address on which a service is running programmatically. The environment
    variables `COREOS_PRIVATE_IPV4` and `COREOS_PUBLIC_IPV4` can be used or the `ipconfig`
    command can be used to find out the IP address assigned for the member.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们选择展示如何将IP地址和端口号键写入到密钥存储中。请注意，了解服务运行的IP地址有多种方式。可以使用环境变量`COREOS_PRIVATE_IPV4`和`COREOS_PUBLIC_IPV4`，或者使用`ipconfig`命令来查找为成员分配的IP地址。
- en: 'To get the parameters published by `testservices`, the following command should
    be used:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`testservices`发布的参数，请使用以下命令：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To watch these parameters the following command should be used:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要监视这些参数，应使用以下命令：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following are the commands to write entries that we queried using `etcdctl`
    before.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们之前使用`etcdctl`查询的命令，用于写入条目。
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Operations using cURL
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用cURL的操作
- en: '**cURL**, often referred to as `curl`, is a command-line tool used to transfer
    data to and from application servers using various protocols. cURL supports a
    range of protocols including **HTTPS**, **HTTP**, **FTPS**, **FTP**, **SCP**,
    **TFTP**, **SFTP**, **DAP**, **LDAP**, **DICT**, **TELNET**, **IMAP**, **FILE**,
    **POP3**, **SMTP**, and **RTSP**. It is often used for getting or sending files
    using URL like syntax. Like `etcdctl`, curl can also be used as a standalone tool
    for configuring the key-value store or can also be used in scripts. All the operations
    that can be done using `etcdctl` can also be done using curl. curl also provides
    more operations to manipulate the key-value store. curl sends a request message
    to the etcd service and waits for the response. The response contains the following
    parameters/attributes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**cURL**，通常称为`curl`，是一个命令行工具，用于通过各种协议将数据传输到应用服务器或从服务器传输数据。cURL支持多种协议，包括**HTTPS**、**HTTP**、**FTPS**、**FTP**、**SCP**、**TFTP**、**SFTP**、**DAP**、**LDAP**、**DICT**、**TELNET**、**IMAP**、**FILE**、**POP3**、**SMTP**和**RTSP**。它通常用于使用类似URL的语法获取或发送文件。像`etcdctl`一样，curl也可以作为独立工具配置键值存储，或者在脚本中使用。所有可以使用`etcdctl`完成的操作，也可以使用curl完成。curl还提供了更多操作来操作键值存储。curl向etcd服务发送请求消息并等待响应。响应包含以下参数/属性：'
- en: 'Action: The action field represents the type of curl request sent. The action
    can take the value as `get, set, create, delete, update, expire, watch`, and so
    on.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作：操作字段表示发送的curl请求的类型。操作可以取值为`get, set, create, delete, update, expire, watch`等。
- en: 'Node: The `node` field represents the directories of the key-value store. It
    consists of key, value, `createIndex`, and `modifiedIndex`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点：`node`字段表示键值存储的目录。它由键、值、`createIndex`和`modifiedIndex`组成。
- en: The `key` field represents the key of the key-value store.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`字段表示键值存储的键。'
- en: The `value` field represents the value of the key-value store.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`字段表示键值存储的值。'
- en: Every node has a field called `index`, which will be incremented for each change
    to `etcd`. The `createdIndex` field is filled with this index.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点都有一个名为 `index` 的字段，每次更改 `etcd` 时，该字段的值会递增。`createdIndex` 字段则填充此索引。
- en: '`modifiedIndex` also represents the index of the node. However, this represents
    the number of operations that are applied over this node, which changes the value
    of this key-value store.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modifiedIndex` 还表示节点的索引。然而，它表示对该节点应用的操作次数，这会改变此键值存储的值。'
- en: 'A sample output of a `curl set` command is shown as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl set` 命令的示例输出如下：'
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: etcd read using curl
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 curl 读取 etcd
- en: 'The following read operations are possible using curl. The following table
    lists the command options provided by curl with syntax and examples:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以使用 curl 执行的读取操作。下表列出了 curl 提供的命令选项及其语法和示例：
- en: '| Operations | Command syntax | Example |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 命令语法 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Retrieving a key-value | `curl -L <URL>` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '| 获取键值 | `curl -L <URL>` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar`'
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Retrieving a key-value recursively | `curl -L <URL> ? ?recursive=true&sorted=true`
    | `curl -L ''http://127.0.0.1:4001/v2/keys/foo/bar?recursive=true&sorted=true''`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '| 递归地获取键值 | `curl -L <URL> ? ?recursive=true&sorted=true` | `curl -L ''http://127.0.0.1:4001/v2/keys/foo/bar?recursive=true&sorted=true''`'
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: etcd write using curl
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 curl 写入 etcd
- en: 'The following write operations are possible using `curl`. The following table
    lists the command options provided by curl with syntax and examples:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下写入操作可以通过 `curl` 执行。下表列出了 curl 提供的命令选项及其语法和示例：
- en: '| Operations | Command syntax | Example |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 命令语法 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Setting value for a key | `curl –L <URL> -XPUT -d value=<value>` | `curl
    -L http://127.0.0.1:4001/v2/keys/foo/bar -XPUT -d value="foo bar"`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '| 设置键值 | `curl –L <URL> -XPUT -d value=<value>` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar
    -XPUT -d value="foo bar"`'
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Setting value for a key with expiry in seconds | `curl –L <URL> -XPUT -d
    value=<value> -d ttl=<value>` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar
    -XPUT -d value="foo bar" –d ttl=5`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '| 设置带过期时间的键值（秒） | `curl –L <URL> -XPUT -d value=<value> -d ttl=<value>` | `curl
    -L http://127.0.0.1:4001/v2/keys/foo/bar -XPUT -d value="foo bar" –d ttl=5`'
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Updating value for a key | `curl –L <URL> -XPUT -d value=<value>` | `curl
    -L http://127.0.0.1:4001/v2/keys/foo/bar -XPUT -d value="foo bar2"`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '| 更新键值 | `curl –L <URL> -XPUT -d value=<value>` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar
    -XPUT -d value="foo bar2"`'
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Deleting a key | `curl –L <URL> -XDELETE` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar
    -XDELETE`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '| 删除键 | `curl –L <URL> -XDELETE` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar
    -XDELETE`'
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: etcd watch using curl
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 curl 监听 etcd
- en: 'The following watch operations are possible using `curl`. The following table
    lists the command options provided by curl with syntax and examples:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以使用 `curl` 执行的监听操作。下表列出了 curl 提供的命令选项及其语法和示例：
- en: '| Operations | Command syntax | Example |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 命令语法 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Watching for any change in the key-value | `curl –L <URL>?wait=true` | `curl
    -L http://127.0.0.1:4001/v2/keys/foo/bar?wait=true` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 监听键值的任何变化 | `curl –L <URL>?wait=true` | `curl -L http://127.0.0.1:4001/v2/keys/foo/bar?wait=true`
    |'
- en: Example using curl
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 curl 的示例
- en: Let's see how to use curl with our `testservices` that want to publish the IP
    address and port number in which this service is running.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 curl 配合我们的 `testservices`，它希望发布此服务运行的 IP 地址和端口号。
- en: Here, `testservices` is the directory where all the new service information
    is added. IP is the IP of the member and `5555` is the port (chosen for this example)
    on which a service is running.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`testservices` 是添加所有新服务信息的目录。IP 是成员的 IP 地址，`5555` 是服务运行的端口（在本示例中选择）。
- en: 'The following is the command to write the IP address and port on which a service
    is added with the key as IP:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将服务添加到指定 IP 地址和端口的命令，键值为 IP：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To get the parameters published by `testservices`, the following command should
    be used:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 `testservices` 发布的参数，应使用以下命令：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To watch these parameters, the following command should be used:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要监听这些参数，应该使用以下命令：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: HAProxy and service discovery
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HAProxy 和服务发现
- en: In this section, we use service discovery to create a web service that has multiple
    backend nodes with HAProxy frontend and then load balancing the service requests.
    HAProxy is a commonly used load balancer for TCP and HTTP-based applications.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用服务发现创建一个具有多个后端节点的 Web 服务，前端通过 HAProxy 进行负载均衡并处理服务请求。HAProxy 是一个常用于
    TCP 和 HTTP 应用的负载均衡器。
- en: 'Let''s start by understanding a typical HAProxy configuration. We are not going
    to cover the HAProxy configuration exhaustively, but will only concentrate on
    the configurations that are relevant for service discovery:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解一个典型的 HAProxy 配置开始。我们不会全面覆盖 HAProxy 配置，而是专注于与服务发现相关的配置：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This configuration instructs HAProxy to bind to port `80` and forward HTTP traffic
    to the servers `172.17.18.10` and `172.17.18.102` in a round robin fashion. When
    we have information on every backend server, we can configure HAProxy statically
    and the setup will work. But imagine a scenario where the information on the IP
    is not available. For example, when IPs are allocated dynamically or the number
    of nodes keeps increasing as the traffic to the server increases. We can use service
    discovery to keep HAProxy updated with the addition and deletion of the backend
    dynamically. We will make ourselves familiar with another tool called confd. We
    will use confd as a discovery service. confd has the capability of watching the
    etcd key store, it then prepares a configuration file based on the template and
    copies the configuration file to the location required by the applications, and
    invokes a command asking an application to reload the configuration.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置指示 HAProxy 绑定到端口 `80` 并以轮询方式将 HTTP 流量转发到服务器 `172.17.18.10` 和 `172.17.18.102`。当我们获得每个后端服务器的信息时，可以静态配置
    HAProxy，设置就会生效。但假设有一个场景，其中没有可用的 IP 信息。例如，当 IP 动态分配时，或者随着服务器流量的增加，节点数量不断增加。我们可以使用服务发现来动态地保持
    HAProxy 更新，处理后端服务器的增删。接下来，我们将熟悉另一个工具——confd，我们将使用 confd 作为服务发现工具。confd 能够监视 etcd
    键值存储，然后基于模板准备配置文件并将其复制到应用所需的位置，最后调用命令让应用重新加载配置。
- en: confd requires a template application configuration file in the directory `/etc/confd/templates`
    and a confd configuration file in the directory `/etc/confd/conf.d`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: confd 需要在目录 `/etc/confd/templates` 中一个模板应用配置文件，并在目录 `/etc/confd/conf.d` 中一个
    confd 配置文件。
- en: 'The following is the configuration file `testconfd.toml` for confd:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `testconfd.toml` 文件的配置，用于 confd：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This configuration file mentions that the HAProxy template filename is `haproxy.cfg.tmpl`.
    The configuration file prepared based on the template file has to be copied to
    `/etc/haproxy/haproxy.cfg`. The configuration file also mentions that the etcd
    key is `/testservice/backend`. Finally, it invokes the command to reload HAProxy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置文件提到 HAProxy 模板文件名为 `haproxy.cfg.tmpl`。根据模板文件准备的配置文件必须复制到 `/etc/haproxy/haproxy.cfg`。配置文件还提到
    etcd 键为 `/testservice/backend`。最后，它会调用命令来重新加载 HAProxy。
- en: 'The following is how the template file `haproxy.cfg.tmpl` would look for the
    HAProxy configuration file we have seen before:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们之前见过的 HAProxy 配置文件 `haproxy.cfg.tmpl` 的模板文件内容：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The range directive loops through etcd keys and prepares the entries for each
    name. The base directive used is very similar to the base-name utility of Linux.
    For the etcd keys written in this chapter before, the corresponding entries would
    be:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: range 指令用于遍历 etcd 键，并为每个名称准备条目。所使用的 base 指令与 Linux 的 base-name 工具有些相似。对于本章前面提到的
    etcd 键，对应的条目如下：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, coming to the backend servers, we can add the command (`etcdctl` or `curl`)
    to update the system IP address in etcd using `ExeStartPost`. confd would then
    update the frontend HAProxy with the new configuration as and when backend servers
    come up.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于后端服务器，我们可以添加命令（`etcdctl` 或 `curl`）通过 `ExeStartPost` 更新系统 IP 地址到 etcd。然后，confd
    会在后端服务器启动时更新前端 HAProxy 配置。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood discovery services, why it is very important
    while developing services or applications in a CoreOS environment, how to publish
    a service and its parameters, and how to watch for changes in the state of the
    services. We also learned about the two important tools, etcdctl and curl, that
    are widely used for service discovery, with some examples.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们理解了发现服务的重要性，尤其在 CoreOS 环境中开发服务或应用时，如何发布服务及其参数，如何监控服务状态的变化。我们还了解了广泛用于服务发现的两个重要工具：etcdctl
    和 curl，并且通过一些示例学习了它们的使用。
- en: In the next chapter, we will learn how different services running inside a CoreOS
    cluster can communicate with each other using service chaining mechanisms.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何通过服务链机制使运行在 CoreOS 集群中的不同服务能够相互通信。
