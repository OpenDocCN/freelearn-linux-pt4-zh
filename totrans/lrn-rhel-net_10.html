<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Securing the System with SELinux" id="aid-2G3F81"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Securing the System with SELinux</h1></div></div></div><p>All too often you will find a tutorial or a blog that will advise you to disable SELinux. This will be in order to get a particular feature of vservice working. In many cases, people have to do is to follow the blog or tutorial instructions because very little is known about SELinux. The aim of this chapter is to provide you a remedy to this and help you become more familiar with how SELinux works. This chapter will provide you with the protection that SELinux provides so that next time you are better equipped to deal with a blog that metaphorically advises you to leave the keys in the ignition of your parked car.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">What is SELinux</li><li class="listitem">Understanding SELinux</li><li class="listitem">Working with the targeted policy type</li><li class="listitem">Policies in SELinux</li><li class="listitem">SELinux tools</li><li class="listitem">Troubleshooting SELinux</li></ul></div><div class="section" title="What is SELinux"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec78"/>What is SELinux</h1></div></div></div><p>SELinux is <a id="id372" class="indexterm"/>a <span class="strong"><strong>MAC</strong></span> (<span class="strong"><strong>Mandatory Access Control</strong></span>) system working together with the existing <span class="strong"><strong>DAC</strong></span> (<span class="strong"><strong>Discretionary Access Control</strong></span>) list we are familiar with, such as the file permissions list.</p><div class="note" title="Note"><h3 class="title"><a id="tip31"/>Tip</h3><p>SELinux can only restrict permissions; it cannot add permissions. If the DAC does not allow access, SELinux cannot allow.</p></div><p>In order to work with labeled objects, access is granted based on these labels and controlled via policies. All objects—such as users, processes, and files—have labels. The label that you have or (more often) the process that you run must match the label supplied to the resource that you need to access. In simple terms, think of this like bathrooms; humans with the label MEN have access to the bathroom labeled MEN. In Linux terms, the Apache web server process is labeled as <code class="literal">httpd_t</code> and can access files with the <code class="literal">httpd_sys_content_t</code> label. In this way, your system is protected against a rogue or <span class="strong"><strong>pwned</strong></span> (compromised) web <a id="id373" class="indexterm"/>server as the scope of files that has access to it is limited by SELinux.</p><p>SELinux is maintained by Red Hat, NSA, and Secure Computing, so it has a rich pedigree. It comprises of four major components that we will investigate in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Modes</li><li class="listitem">Labels</li><li class="listitem">Policy types</li><li class="listitem">Policy packages</li></ul></div><p>To help you work with SELinux, we will install some additional packages. These RPM packages are shown in the following command line. For ease of layout, we have added line breaks:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo yum install policycoreutils-python policycoreutils-gui \</strong></span>
<span class="strong"><strong> setools-console setools-gui setroubleshoot \</strong></span>
<span class="strong"><strong> setroubleshoot-server</strong></span>
</pre></div></div></div>
<div class="section" title="Understanding SELinux"><div class="titlepage" id="aid-2H1VQ2"><div><div><h1 class="title"><a id="ch10lvl1sec79"/>Understanding SELinux</h1></div></div></div><p>Let's start pulling the <a id="id374" class="indexterm"/>covers off SELinux and discover a little more about what makes these controls work, starting with SELinux modes.</p><div class="section" title="Modes"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec58"/>Modes</h2></div></div></div><p>To begin with, we will <a id="id375" class="indexterm"/>discuss three modes that we can run with SELinux. These modes are <a id="id376" class="indexterm"/>illustrated for you in the following figure:</p><div class="mediaobject"><img src="../Images/image00304.jpeg" alt="Modes"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="The disabled mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec05"/>The disabled mode</h3></div></div></div><p>When <a id="id377" class="indexterm"/>SELinux is disabled, SELinux is not used and the objects are NOT labeled. In the disabled mode, we rely solely on the original DAC. If we later need to enable SELinux, the boot process is lengthened because all the objects need to be relabeled again. Disabling SELinux completely like this is probably not a good idea, but should it be required, it can be set in the /<code class="literal">etc/selinux/config</code> file by changing the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SELINUX=disabled</strong></span>
</pre></div><p>One reason this is not a great idea is that a reboot is required for this to take effect. As mentioned before, files need to be relabeled if SELinux is enabled later. We can force a relabel if all filesystem objects are running by running the the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># fixfiles relabel</strong></span>
</pre></div><p>Alternatively, we can create the <code class="literal">/.autorelabel</code> file, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># touch /.autorelabel</strong></span>
</pre></div></div><div class="section" title="The permissive mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec06"/>The permissive mode</h3></div></div></div><p>If you are <a id="id378" class="indexterm"/>having issues with a service and want to check whether SELinux is a possible culprit, you may prefer to set SELinux in the permissive mode. In this way, SELinux is still enabled and the objects maintain their labels; however, events are not blocked, but logged to the <code class="literal">/var/log/audit/audit.log</code> file.</p><p>To enter the permissive mode, we can perform this while the system is running without performing a reboot on your system. The following line illustrates how this is achieved:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># setenforce Permissive</strong></span>
</pre></div><p>If the change is made in this way, then on a reboot, the permissive mode is applied from <code class="literal">/etc/selinux/config</code>. To set the mode permanently to permissive, we should set the permissive mode in the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SELINUX=permissive</strong></span>
</pre></div><p>Although I do feel that setting the mode to permissive is acceptable as a quick and simple test, the more you know about SELinux, the less likely you are to move from the Enforcing mode where your protection is guaranteed. In this chapter, you will learn how to correct issues and even add a process to be permissive rather than the whole system.</p><p>It's also possible to set permissive or enforcing modes via the boot loader, adding the following commands at the <a id="id379" class="indexterm"/>end of the kernel line (where <code class="literal">0</code> is off or permissive and <code class="literal">1</code> is on or enforcing):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>enforcing=0</strong></span>
<span class="strong"><strong>enforcing=1</strong></span>
</pre></div></div><div class="section" title="The enforcing mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec07"/>The enforcing mode</h3></div></div></div><p>The enforcing <a id="id380" class="indexterm"/>mode is very similar to the permissive mode, where you can switch between permissive and enforcing on the command line with the <code class="literal">setenforce</code> command. As the name suggests, SELinux is enforced in this mode and reported to the log file as well.</p><p>To interrogate your current SELinux mode, you can issue the <code class="literal">getenforce</code> command. If you have installed additional tools, you will also be able to run the <code class="literal">sestatus</code> command, which is part of the <code class="literal">policycoreutils</code> package. This command displays the current mode and the mode from the configuration file; the output of <code class="literal">sestatus</code> is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00305.jpeg" alt="The enforcing mode"/></div><p style="clear:both; height: 1em;"> </p></div></div><div class="section" title="Labels"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec59"/>Labels</h2></div></div></div><p>As mentioned <a id="id381" class="indexterm"/>previously, when SELinux is in the permissive or enforcing <a id="id382" class="indexterm"/>mode, all objects—such as files, users, and processes—have labels. When accessing resources, these labels are compared to see whether the match is compatible.</p><p>Each label consists of four colon delimited values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The SELinux user</li><li class="listitem">The SELinux role</li><li class="listitem">The SELinux type</li><li class="listitem">The SELinux level</li></ul></div><p>In general, a level is only used in very secure government environments, where the secrecy level of the user must match the secrecy level of the document or resource. The idea here is that the President will be able to read anything, but only write to documents that match his security <a id="id383" class="indexterm"/>level. This even prevents him from writing to documents holding <a id="id384" class="indexterm"/>a lower security level. Of course, this can be read by lower authorized people and can perhaps be a security breach.</p><p>Using the <code class="literal">ls</code> command, we can list the label of a file using the <code class="literal">–Z</code> option. The following command is an example of listing the SELinux label from the <code class="literal">/etc/hosts</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls –Z /etc/hosts</strong></span>
</pre></div><p>The output should look similar to the following screenshot:</p><div class="mediaobject"><img src="../Images/image00306.jpeg" alt="Labels"/></div><p style="clear:both; height: 1em;"> </p><p>After reading the label, we can determine the following values that are read from left to right from the previous screenshot:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td valign="top">
<p>The SELinux user</p>
</td><td valign="top">
<p>
<code class="literal">system_u</code>
</p>
</td></tr><tr><td valign="top">
<p>The SELinux role</p>
</td><td valign="top">
<p>
<code class="literal">object_r</code>
</p>
</td></tr><tr><td valign="top">
<p>The SELinux type</p>
</td><td valign="top">
<p>
<code class="literal">net_conf_t</code>
</p>
</td></tr><tr><td valign="top">
<p>The SELinux level</p>
</td><td valign="top">
<p>
<code class="literal">s0</code>
</p>
</td></tr></tbody></table></div><p>To read a label from a Linux user perspective, we can use the <code class="literal">id –Z &lt;username&gt; </code>command. The following screenshot shows this for the currently logged in user, where the <code class="literal">&lt;username&gt;</code> field can be left blank:</p><div class="mediaobject"><img src="../Images/image00307.jpeg" alt="Labels"/></div><p style="clear:both; height: 1em;"> </p><p>Similarly, we can examine the label of a process using the <code class="literal">–Z</code> option with the <code class="literal">ps</code> command, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ps -eZ | grep ssh</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00308.jpeg" alt="Labels"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Policy types"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec60"/>Policy types</h2></div></div></div><p>The default SELinux <a id="id385" class="indexterm"/>policy type is targeted, but three policy types are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Minimum</li><li class="listitem">Targeted</li><li class="listitem">MLS</li></ul></div><p>They are all contained in packages that match the <code class="literal">selinux-policy-minimum</code>, <code class="literal">selinux-policy-targeted</code>, and <code class="literal">selinux-policy-mls</code> names.</p><div class="section" title="Minimum"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec08"/>Minimum</h3></div></div></div><p>As the name suggests, this <a id="id386" class="indexterm"/>is designed as a minimum configuration for SELinux. As strange as it may sound, this is for situations where you want to target just one service, such as the Apache web server. Starting with the basics, it's easy to include additional policies in your <code class="literal">Minimum</code> type. The following command shows how we can use <code class="literal">semodule</code> to add the Apache policy:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># semodule -i /usr/share/selinux/minimum/Apache.pp.bz2</strong></span>
</pre></div><p>To configure SELinux to use the <code class="literal">Minimum</code> policy, we set the <code class="literal">SELINUXTYPE</code> directive using the <code class="literal">/etc/selinux/config</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SELINUXTYPE=minimum</strong></span>
</pre></div></div><div class="section" title="Targeted"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec09"/>Targeted</h3></div></div></div><p>This is the default policy <a id="id387" class="indexterm"/>type; by default, many policies are included. On the <a id="id388" class="indexterm"/>demo system, there are 395 policies installed other than the basic policy. We can use <code class="literal">semodule</code> to list all modules:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># semodule -l</strong></span>
</pre></div></div><div class="section" title="MLS"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec10"/>MLS</h3></div></div></div><p>The multi-level <a id="id389" class="indexterm"/>security or MLS policy type will allow you to add additional levels of security. These can be interrogated <a id="id390" class="indexterm"/>from labels to help you control access to resources. This is generally used only in high security <a id="id391" class="indexterm"/>deployments. Outside of MLS, the level element of a label is not used. To enable MLS, the <code class="literal">/etc/selinux/config</code> file is configured with the following directive:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SELINUXTYPE=mls</strong></span>
</pre></div></div></div><div class="section" title="Policies"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec61"/>Policies</h2></div></div></div><p>Once policies are <a id="id392" class="indexterm"/>installed, individual policies are installed in the appropriate policy type directory; for the default targeted policy, enter <code class="literal">/etc/selinux/targeted/modules/active/modules/</code>. Policy files have the <code class="literal">.pp</code> suffix.</p></div></div>
<div class="section" title="Working with the targeted policy type" id="aid-2I0GC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec80"/>Working with the targeted policy type</h1></div></div></div><p>The default policy type is <a id="id393" class="indexterm"/>targeted. As such, most SELinux deployments will work with this policy type. In the case of the targeted policy type, the primary attribute from the label used for enforcement is <code class="literal">type</code>. For this reason, the targeted policy type is often known as TE or <code class="literal">type</code> enforcement. The following image highlights the importance of the type attribute of a label in the targeted policy type:</p><div class="mediaobject"><img src="../Images/image00309.jpeg" alt="Working with the targeted policy type"/></div><p style="clear:both; height: 1em;"> </p><p>Using the <code class="literal">seinfo</code> command, which is part of the <code class="literal">setools-console</code> package, we can display specific information about the current SELinux environment. Let's take a look at the available types that we can work with. To list all types, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># seinfo -t</strong></span>
</pre></div><p>Wow, there are a lot. If we count them, we have around 4500 on RHEL 7; on RHEL 6, there were 3500. These two figures are just a simple illustration of how much the SELinux product is growing and its continued uptake, but Linux software developers.</p><p>We can also see how to import the type attribute in a label with the user attribute:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># seinfo -u</strong></span>
</pre></div><p>Here, the numbers are not so impressive; it's just 8. These are not Linux users, but SELinux users; Linux users can be mapped to SELinux users to help control access to resources. To display any mapping, we can use <code class="literal">semanage</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># semanage login -l</strong></span>
</pre></div><p>Without any mapping being set up, we will see that the root is mapped to <code class="literal">unconfined_u</code> because this is the default. This setting means that all other user accounts without any specific mapping will be mapped to the <code class="literal">unconfined_u</code> SELinux user, which means that we are ignoring the user attribute in the label as it's unconfined on SELinux. Similarly, let's look at the ROLE <a id="id394" class="indexterm"/>attribute using <code class="literal">seinfo</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># seinfo -r</strong></span>
</pre></div><p>The output should indicate 14 roles; again, this is not a large number. The role attribute is not heavily used in the targeted policy type.</p><div class="section" title="Unconfined domains"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec62"/>Unconfined domains</h2></div></div></div><p>The <code class="literal">TYPE</code> attribute is <a id="id395" class="indexterm"/>often referred to as the <code class="literal">DOMAIN</code> when set on a process; remember that we can view the SELinux label of a running process using the following process status command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ps -eZ</strong></span>
</pre></div><p>Many processes started in a user space will also be unconfined perhaps to the <code class="literal">TYPE</code> attribute set to <code class="literal">unconfined_t</code>. If processes started in the user space are generally unconfined, we can say that services, especially network facing services, will be enforced in some way and this is very much representative of why SELinux is here: to protect against attack from exposure to a network. It's not only the <code class="literal">aunconfined_t</code> tag that is unconfined by SELinux. To display all unconfined types or domains, we can use <code class="literal">seinfo</code> running as root again as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># seinfo -aunconfined_domain_type  -x</strong></span>
</pre></div><p>The <code class="literal">-a</code> option tells <code class="literal">seinfo</code> that we are searching for an attribute; this attribute needs to be pushed up next to the option with no additional white spaces. The <code class="literal">-x</code> attribute expands to show all <code class="literal">TYPEs</code> that have the attribute, rather than just listing the attribute itself. The output should confirm that it is mainly domains that will be non-network facing that are unconfined, such as <code class="literal">bootloader_t</code>.</p><p>The following screenshot displays the start of the output from my system. In total, there were 86 unconfined domains; this is not bad considering that we started with 4500 types in all:</p><div class="mediaobject"><img src="../Images/image00310.jpeg" alt="Unconfined domains"/></div><p style="clear:both; height: 1em;"> </p><p>When policies are enforced, the default level of access is denied; this means that rules must exist in the policy package in order to allow access to users, roles, or types. Having the default access denied ensures security if a given scenario is not considered; on the flip side, this also means that access needs to be added if your given scenario has not been considered. A level of administration may be required to tune the environment to your needs; however, once set <a id="id396" class="indexterm"/>up, you have a secure system that will continue to run reliably with a lessened exposure to risk.</p><p>Of course, although the default auction in a policy is to deny access to a resource, there are many thousands of <code class="literal">allow rules</code> supplied within these polices by default. Using the <code class="literal">sesearch</code> command, we can display them; sending results to the <code class="literal">wc</code> command can count the number of rules. The following commands illustrate this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sesearch --allow #display all allow rules</strong></span>
<span class="strong"><strong># sesearch --allow | grep wc -l #count the output</strong></span>
</pre></div><p>On my system, there are over 100,000 rules created by default. If we want to look at this in a little more detail, we can search for the <code class="literal">httpd_sys_content_t</code> string. There are many rules with this label, but if we look at just one, the easiest is to consider is the last one with the command tail. Here, we can see that access is granted to resources with <code class="literal">httpd_sys_content_t</code> to process with the <code class="literal">ftpd_t</code> label. In simple terms, the FTP server has access to your website content, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sesearch --allow | grep httpd_sys_content_t | tail -n 1 </strong></span>
<span class="strong"><strong>allow ftpd_t httpd_sys_content_t : dir { getattr search open } ;</strong></span>
</pre></div><p>Now, we have a little more understanding of the default targeted policy type, so let's take a look at how to use some of the tools and see SELinux at work.</p></div></div>
<div class="section" title="SELinux tools" id="aid-2IV0U1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec81"/>SELinux tools</h1></div></div></div><p>Let's take a <a id="id397" class="indexterm"/>look <a id="id398" class="indexterm"/>at SELinux tools.</p><div class="section" title="chcon and restorecon"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec63"/>chcon and restorecon</h2></div></div></div><p>Two of the main <a id="id399" class="indexterm"/>tools that we can use to help manage SELinux are <code class="literal">chcon</code> and <code class="literal">restorecon</code>. The <code class="literal">chcon</code> command helps to change the SELinux context or TYPE of <a id="id400" class="indexterm"/>what will most often be a single or perhaps sometimes a few files that can be referenced easily together with some form of wildcard. The <code class="literal">restorecon</code> command can be used to reset a file or directory and its contents to their default SELinux context. These default settings for directories are stored in the <code class="literal">/etc/selinux/targeted/contexts/files/file-context</code> file.</p><p>With <code class="literal">grep</code>, we can <a id="id401" class="indexterm"/>search for <code class="literal">httpd_sys_content_t</code>, whereas in the output, we should see the default label for files under <code class="literal">/var/www</code>. This is the directory were we would expect to find web server content:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep httpd_sys_content_t \ </strong></span>
<span class="strong"><strong>/etc/selinux/targeted/contexts/files/file_contexts</strong></span>
</pre></div><p>The output of the preceding command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/var/www(/.*)? system_u:object_r:httpd_sys_content_t:s0</strong></span>
</pre></div><p>We can now try to <a id="id402" class="indexterm"/>break the system by changing the SELinux context of the <code class="literal">index.html</code> page. We can do this with the <code class="literal">chcon</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># chcon -t user_home_t /var/www/html/index.html</strong></span>
</pre></div><p>Now, if we navigate to the website using the <code class="literal">localhost</code> URL, we should have an access denied message of some description. This is because we have set the <code class="literal">TYPE</code> of the file to <code class="literal">user_home_t</code>; access is not permitted to the <code class="literal">httpd_t</code> context in which the web server runs. The following screenshot shows the use of <code class="literal">chcon</code> and the subsequent denial message:</p><div class="mediaobject"><img src="../Images/image00311.jpeg" alt="chcon and restorecon"/></div><p style="clear:both; height: 1em;"> </p><p>Of course, we can fix this manually by setting the type back to <code class="literal">httpd_sys_content_t</code> using <code class="literal">chcon</code>; however, if we are unsure of the correct context, we can run the <code class="literal">restorecon</code> command, as shown in the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># restorecon /var/www/html/index.html</strong></span>
</pre></div><p>Accessing the web page should now work. Technically, we can achieve the same effect as achieved with <code class="literal">restorecon</code> by relabeling the complete filesystem at reboot by creating the <code class="literal">/.autorelabel</code> file; as <a id="id403" class="indexterm"/>you can imagine, this is a little overkill and will take a <a id="id404" class="indexterm"/>while. The effect of this though is to run <a id="id405" class="indexterm"/>
<code class="literal">restorecon</code> <a id="id406" class="indexterm"/>across the complete filesystem.</p></div><div class="section" title="Boolean values"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec64"/>Boolean values</h2></div></div></div><p>There are also simple <a id="id407" class="indexterm"/>Boolean values that we can toggle on and off as required, to help tune our system to work the way we need to match our environment. On the RHEL 7.1 system used in the book, we have 294 Boolean values that can be adjusted. We can display these with the simple <code class="literal">getsebool</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># getsebool -a</strong></span>
</pre></div><p>We will drill down a little further and list those associated with the <code class="literal">httpd</code> process. We can see this in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00312.jpeg" alt="Boolean values"/></div><p style="clear:both; height: 1em;"> </p><p>To change a Boolean value, we can use the <code class="literal">setsebool</code> command which can be a temporary or permanent fix. The use of the <code class="literal">-P</code> option is required if we want the change the Boolean value to be permanent. This also will take a while because the active policy is written to and recompiled.</p><p>If we return to the earlier setting where the <code class="literal">index.html</code> page was set with context to user home directories, we can remedy with <code class="literal">setsebool</code>. If the situation was not appropriate to change the context, for example, if we need to host user home directories on the web server temporarily until the next boot, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># setsebool httpd_read_user_content on</strong></span>
</pre></div><p>If we need this to be set permanently, we will use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># setsebool -P httpd_read_user_content on</strong></span>
</pre></div><p>The temporary setting is shown in the following screenshot. It also shows successful access to the web page that still has the incorrect context set:</p><div class="mediaobject"><img src="../Images/image00313.jpeg" alt="Boolean values"/></div><p style="clear:both; height: 1em;"> </p><p>Using these Booleans can go a <a id="id408" class="indexterm"/>long way in resolving issues you may have with SELinux.</p></div></div>
<div class="section" title="Troubleshooting SELinux" id="aid-2JTHG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec82"/>Troubleshooting SELinux</h1></div></div></div><p>Let's take a <a id="id409" class="indexterm"/>look at different ways of troubleshooting SELinux.</p><div class="section" title="The log file"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec65"/>The log file</h2></div></div></div><p>If we were left uncertain as <a id="id410" class="indexterm"/>to the problem that was causing errors that we encountered before with the web server, then our troubleshooting should always start with log files. For SELinux, this is the <code class="literal">/var/log/audit/audit.log</code> file. Logging in from SELinux will be marked as <span class="strong"><strong>AVC</strong></span> (<span class="strong"><strong>Access Vector Cache</strong></span>). We <a id="id411" class="indexterm"/>can search the log file with <code class="literal">grep</code> using something similar to the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep AVC /var/log/audit/audit.log</strong></span>
</pre></div><p>However, more appropriately, there is also the <code class="literal">ausearch</code> command that we can use. If an error has just occurred, we can use the <code class="literal">recent</code> time start code to help reduce returned results. This is a shortcut for displaying errors within the last 10 minutes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ausearch -m avc -ts recent</strong></span>
</pre></div><p>Other than this, we can supply an actual time, date, or both. In the following example, we will use <code class="literal">16:00</code> as the starting time to search. In the absence of the date, today's date is implied as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ausearch -m avc -ts 16:00</strong></span>
</pre></div><p>Taking a look at the output <a id="id412" class="indexterm"/>from the command in the following screenshot, we can see that the process and resource have incompatible labels:</p><div class="mediaobject"><img src="../Images/image00314.jpeg" alt="The log file"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="The audit2allow command"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec66"/>The audit2allow command</h2></div></div></div><p>Now, even after <a id="id413" class="indexterm"/>having checked the log file, you still may not be entirely clear about the cause of the problem or its possible fix. For help, you can try the <a id="id414" class="indexterm"/>
<code class="literal">audit2allow</code> command. If used with the <code class="literal">-w</code> option, an explanation of the problem along with possible solutions are included in the output. We still examine the log, but this time we will pipe the output through to the <code class="literal">audit2allow</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ausearch -m avc -ts 16:00 | audit2allow -w</strong></span>
</pre></div><p>The output from the test system looked like this when we had reset the original Boolean value:</p><div class="mediaobject"><img src="../Images/image00315.jpeg" alt="The audit2allow command"/></div><p style="clear:both; height: 1em;"> </p><p>We can see that the suggestion matches the Boolean setting we had previously shown works. If the problem was more complex than changing a Boolean value, we could create a new policy package <a id="id415" class="indexterm"/>using the <code class="literal">-M</code> option. Then using <a id="id416" class="indexterm"/>
<code class="literal">semodule</code>, we would import the <code class="literal">.pp</code> file as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ausearch -m avc -ts 16:00 | audit2allow -M web.local</strong></span>
<span class="strong"><strong># semodule -i web.local.pp</strong></span>
</pre></div></div><div class="section" title="Permissive domains"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec67"/>Permissive domains</h2></div></div></div><p>We can see that <a id="id417" class="indexterm"/>there are some pretty powerful tools designed to help with our SELinux deployments, but if all else fails, there is another option called <span class="strong"><strong>Permissive domains</strong></span>.</p><p>Rather than <a id="id418" class="indexterm"/>setting the SELinux mode to Permissive, we can turn the Permissive status on for just a single domain or process context. By default, permissive domains are enabled and these are known as built-in permissive domains. Domains that we add are customized domains.</p><p>Although the web server is a major network facing attach vector, maybe if we cannot get SELinux working with <code class="literal">httpd</code>, but we do not want to risk SELinux disabled for the rest of the system. We can turn on the permissive behavior for <code class="literal">httpd_t</code> using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># semanage permissive -a httpd_t</strong></span>
</pre></div><p>Should we need to remove this behavior later, we can reverse it with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># semanage permissive -d httpd_t</strong></span>
</pre></div><p>In both cases, we will write to the active policy; this will take a little time.</p></div></div>
<div class="section" title="Summary" id="aid-2KS221"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec83"/>Summary</h1></div></div></div><p>In this chapter, you learned how to manage SELinux. I certainly hope that you have a much fuller understanding of the mechanism involved. The aim of SELinux is to protect a system, especially where network-facing services are involved. Disabling or setting the Permissive mode for SELinux is, in general, the wrong approach. With this, you should now be be able to choose the correct solution.</p><p>In the next chapter, we will look at the new firewalling mechanism included on RHEL 7 and the improvements made from the standard <code class="literal">IPtables</code> mechanism used in the past. Again, we hope that we can convince you of the benefits of <code class="literal">firewalld</code> and keep the service enabled.</p></div></body></html>