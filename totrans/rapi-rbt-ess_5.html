<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Path Planning and Your Biped"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Path Planning and Your Biped</h1></div></div></div><p>Now that your biped is up and mobile and able to find barriers, you can now start to have it move around autonomously. However, you'll want to have your robot planed his path, that is, if it knows where it has started and the desired end point, it can move from the starting point to the end point.</p><p>In this chapter, you will be learning about:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to add a compass to your biped, so you'll have a sense of direction</li><li class="listitem" style="list-style-type: disc">Learning some basic path planning techniques for your robot</li></ul></div><div class="section" title="Connecting a digital compass to the Raspberry Pi"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Connecting a digital compass to the Raspberry Pi</h1></div></div></div><p>One<a id="id208" class="indexterm"/> of the important pieces of information<a id="id209" class="indexterm"/> that might be useful for your robot, it if is going to plan its own path, is its direction of travel. So, let's learn how to hook up a digital compass to the Raspberry Pi.</p><p>There<a id="id210" class="indexterm"/> are several chips that provide digital compass capability; one of the most common is the <span class="strong"><strong>HMC5883L 3-Axis Digital Compass chip</strong></span>. This chip is packaged onto a module by several companies, but almost all of them result in a<a id="id211" class="indexterm"/> similar interface. The following is a picture of one the <span class="strong"><strong>GY-271 HMC5883L Triple Axis Compass Magnetometer Sensor Module</strong></span>, which is available from a number of online retailers:</p><div class="mediaobject"><img src="graphics/B04591_05_01.jpg" alt="Connecting a digital compass to the Raspberry Pi"/></div><p>This<a id="id212" class="indexterm"/> type of digital compass uses magnetic<a id="id213" class="indexterm"/> sensors to discover the earth's magnetic field. The output of these sensors is then made accessible to the outside world through a set of registers that allow the user to set things such as the sample rate, and continuous or single sampling. The <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> directions are output-using registers as well.</p><p>The connections to this chip are straightforward and the device communicates with the Raspberry Pi by using the I2C bus, a standard serial communications bus. The I2C interface is a synchronous serial interface and provides more performance than an asynchronous Rx/Tx serial interface. The SCL data line provides a clock, while the data flows on the SDA line. The bus also provides addressing so that more than one device can be connected to the master device at the same time. On the back of the module, the connections are labeled, as shown in the following image:</p><div class="mediaobject"><img src="graphics/B04591_05_02.jpg" alt="Connecting a digital compass to the Raspberry Pi"/></div><p>You'll<a id="id214" class="indexterm"/> then connect the device to the GPIO<a id="id215" class="indexterm"/> pins on Raspberry Pi. The following<a id="id216" class="indexterm"/> is the pin out of Raspberry Pi:</p><div class="mediaobject"><img src="graphics/B04591_05_03.jpg" alt="Connecting a digital compass to the Raspberry Pi"/></div><p>Connect your device to the VCC on the device to Pin 1 (3.3 V) on Raspberry Pi. Connect GND to Pin 9 (GND). Connect SCL on the device to Pin 5 (GPIO 3) and SDA to Pin 3 (GPIO 2) on<a id="id217" class="indexterm"/> the device. Notice that you<a id="id218" class="indexterm"/> will not connect the <span class="strong"><strong>Data Ready</strong></span> (<span class="strong"><strong>DRDY</strong></span>) line. Now, you <a id="id219" class="indexterm"/>are ready to communicate with the device.</p></div></div>
<div class="section" title="Accessing the compass programmatically"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Accessing the compass programmatically</h1></div></div></div><p>In <a id="id220" class="indexterm"/>order to access the compass capability, you'll need to enable the I2C library on Raspberry. If you used the IR sensor and ADC additional hardware in <a class="link" href="ch04.html" title="Chapter 4. Avoiding Obstacles Using Sensors">Chapter 4</a>, <span class="emphasis"><em>Avoiding Obstacles Using Sensors</em></span>, you will have already done <a id="id221" class="indexterm"/>this. If not, follow these instructions to enable the I2C interface:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run <code class="literal">raspi-config</code>. Select the <span class="strong"><strong>Configure advanced settings</strong></span>, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/B04591_05_04.jpg" alt="Accessing the compass programmatically"/></div><p>From the next selection page, select the Enable/disable automatic loading of the I2C interface, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04591_05_05.jpg" alt="Accessing the compass programmatically"/></div><p>Then<a id="id222" class="indexterm"/> select <span class="strong"><strong>yes</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04591_05_06.jpg" alt="Accessing the compass programmatically"/></div><p>You'll<a id="id223" class="indexterm"/> also want to edit the file <code class="literal">/etc/modules</code> and add the lines <code class="literal">i2c-bcm2708</code> and <code class="literal">i2c-dev</code>,  as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04591_05_07.jpg" alt="Accessing the compass programmatically"/></div><p>And one final edit, change the last line in <code class="literal">/boot/config.txt</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04591_05_08.jpg" alt="Accessing the compass programmatically"/></div><p>Now, reboot Raspberry Pi.</p></li><li class="listitem">With<a id="id224" class="indexterm"/> the device connected, you can see if the system knows about your device. To do this, type the following command:<div class="mediaobject"><img src="graphics/B04591_05_09.jpg" alt="Accessing the compass programmatically"/></div><p>You can see the device at <span class="strong"><strong>1e</strong></span>.</p></li><li class="listitem">Now you communicate with your digital compass. To do this, you'll need to create a <a id="id225" class="indexterm"/>Python program. But before you create your Python code, you'll want to download a library that will make this all much easier. To do this, first create a directory a directory called <code class="literal">compass</code> and <code class="literal">cd</code> to that directory. Then, type <code class="literal">git clone https://github.com/quick2wire/quick2wire-python-api.git</code> to download the <code class="literal">quick2wire-python-api</code> library. Finally, type <code class="literal">git clone https://bitbucket.org/thinkbowl/i2clibraries.git</code> to get the i2clibraries.<p>You'll also need to set some environment variables. Do this by going to your home directory and editing the <code class="literal">.bashrc</code> file, adding these two lines at the end:</p><div class="mediaobject"><img src="graphics/B04591_05_10.jpg" alt="Accessing the compass programmatically"/></div></li><li class="listitem">Now, you can create the following Python code:<div class="mediaobject"><img src="graphics/B04591_05_11.jpg" alt="Accessing the compass programmatically"/></div></li><li class="listitem">Now,<a id="id226" class="indexterm"/> run the code by typing <code class="literal">python3 compass.py</code> command and you should see:<div class="mediaobject"><img src="graphics/B04591_05_12.jpg" alt="Accessing the compass programmatically"/></div><p>Now, you can add direction to your project! As you move the device around, you should see the <span class="strong"><strong>Heading</strong></span> value change.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>This is a basic program; you can find out more about other features that are available <a id="id227" class="indexterm"/>with this library at <a class="ulink" href="http://think-bowl.com/raspberry-pi/i2c-python-library-3-axis-digital-compass-hmc5883l-with-the-raspberry-pi/">http://think-bowl.com/raspberry-pi/i2c-python-library-3-axis-digital-compass-hmc5883l-with-the-raspberry-pi/</a>.</p></div></div><p>One<a id="id228" class="indexterm"/> final step in developing your compass code is to make it a file where the functions can then be imported to a different Python program. To do this, edit the file so that all of the code is in functions, as shown by the following:</p><div class="mediaobject"><img src="graphics/B04591_05_13.jpg" alt="Accessing the compass programmatically"/></div><p>Then you'll be able to use the import capability of Python to import this functionality into a different Python file.</p></li></ol></div></div>
<div class="section" title="Dynamic path planning for your robot"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Dynamic path planning for your robot</h1></div></div></div><p>Now that you can see barriers and also know direction, you'll want to do dynamic path planning. Dynamic path planning simply means that you don't have a knowledge of the entire <a id="id229" class="indexterm"/>world with all the possible barriers before you encounter them. Your robot will have to decide how to proceed while it is in the middle and actually moving. This can be a complex topic, but there are some basics that you can start to understand and apply as you ask your robot to move around its environment. Let's first address the problem of knowing where you want to go and needing to execute a path without barriers, and then adding in barriers.</p><div class="section" title="Basic path planning"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec10"/>Basic path planning</h2></div></div></div><p>In order<a id="id230" class="indexterm"/> to talk about dynamic path planning, that is, planning a path where you don't know what barriers you might encounter, you'll need a framework to understand where your robot is as well as to determine the location of the goal. One common framework is an <span class="emphasis"><em>x</em></span>-<span class="emphasis"><em>y</em></span> grid. The following is a drawing<a id="id231" class="indexterm"/> of such a grid:</p><div class="mediaobject"><img src="graphics/B04591_05_14.jpg" alt="Basic path planning"/></div><p>There are three key points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The lower left point is a fixed reference position. The directions <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> are also fixed, and all other positions will be measured with respect to this position and these directions.</li><li class="listitem" style="list-style-type: disc">Another important point is the starting location of your robot. Your robot will then keep track of its location by using its <span class="emphasis"><em>x</em></span> coordinate, or position itself with respect to some fixed reference position in the <span class="emphasis"><em>x</em></span> direction, and its <span class="emphasis"><em>y</em></span> coordinate, its position with respect to some fixed reference position in the <span class="emphasis"><em>y</em></span> direction to the goal. It will use the compass to keep track of these directions.</li><li class="listitem" style="list-style-type: disc">The <a id="id232" class="indexterm"/>third important point is the position of the goal, also given in <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates with respect to the fixed reference position. If you know the starting location and the starting angle of your robot ,you can plan an optimum (shortest distance) path to this goal. To do this, you can use the goal location and the robot location, and some fairly simple math to calculate the distance and angle from the robot to the goal.<p>To <a id="id233" class="indexterm"/>calculate the distance, use the following equation:</p><div class="mediaobject"><img src="graphics/B04591_05_24.jpg" alt="Basic path planning"/></div><p>Use the following equation to tell your robot how far to travel to the goal. A second equation will tell your robot the angle it needs to travel:</p><div class="mediaobject"><img src="graphics/B04591_05_26.jpg" alt="Basic path planning"/></div><p>The following is a graphical representation of these two pieces of information:</p><div class="mediaobject"><img src="graphics/B04591_05_17.jpg" alt="Basic path planning"/></div></li></ul></div><p>Now that you have a goal angle and distance, you can program your robot to move. To do this, you <a id="id234" class="indexterm"/>will write a program to do path planning and call the movement functions that you created in <a class="link" href="ch03.html" title="Chapter 3. Motion for the Biped">Chapter 3</a>, <span class="emphasis"><em>Motion for the Biped</em></span>. You will, however, need to know the distance that your robot travels in a step so that you can tell your robot how far to travel in steps, not distance units.</p><p>You'll also need to be able to translate the distance that might be covered by your robot in a turn; however, this distance may be too small to be of any importance. If you then know the angle and the distance, you can move your robot to the goal.</p><p>The <a id="id235" class="indexterm"/>following are the steps you will program:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Calculate the distance in units that your robot will need to travel in order to reach the goal. Convert this to number of steps to achieve this distance.</li><li class="listitem">Calculate the angle that your robot will need to travel to reach the goal. You'll use the compass and your robot turn functions in order to achieve this angle.</li><li class="listitem">Now, call the step functions the proper number of times required to move your robot the correct distance.</li></ol></div><p>That's it. Now, we will use some very simple Python code that executes this by using functions to move the robot forward and turn the robot. In this case, it makes sense to create a file called <code class="literal">robotLib.py</code> with all of the functions that do the actual servo settings to step the biped robot forward and turn the robot. You'll then import these functions using the <code class="literal">from robotLib import * </code>statement, and your Python program can call these <a id="id236" class="indexterm"/>functions. This makes the path planning Python program much smaller and more manageable. You'll do the same thing with the <code class="literal">compass</code> program, using the <code class="literal">from compass import *</code> command.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>For<a id="id237" class="indexterm"/> more information on how to import the functions from one Python file to another, refer to <a class="ulink" href="http://www.tutorialspoint.com/python/python_modules.htm">http://www.tutorialspoint.com/python/python_modules.htm</a>.</p></div></div><p>The following is a listing of the program:</p><div class="mediaobject"><img src="graphics/B04591_05_18.jpg" alt="Basic path planning"/></div><p>In this program, the user enters the goal location and the robot first decides the shortest direction to the desired angle by reading the angle. To make it simple, the robot is placed in the grid with it heading in the direction of angle 0. If the goal angle is less than 180 degrees, the robot will turn right. If it is greater than 180 degrees, the robot will turn left. The robot <a id="id238" class="indexterm"/>turns until the desired angle and its measured angle are within a few degrees. Then, the robot takes the number of steps to reach the goal.</p></div><div class="section" title="Avoiding obstacles"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec11"/>Avoiding obstacles</h2></div></div></div><p>Planning <a id="id239" class="indexterm"/>paths without obstacles, as has been shown, is quite easy. However, it becomes a bit more challenging when your robot needs to walk around obstacles. Let's look at an instance where there is an obstacle in the path that you calculated previously. It might look like the following:</p><div class="mediaobject"><img src="graphics/B04591_05_19.jpg" alt="Avoiding obstacles"/></div><p>You can still use the same path planning algorithm to find the starting angle; however, you'll now need to use your sonar sensor to detect the obstacle. When your sonar sensor detects the obstacle, you'll need to stop and recalculate a path to avoid the barrier, and then recalculate the desired path to the goal. One very simple way to do this, when your robot senses a barrier, is to turn right 90 degrees, go a fixed distance, and then recalculate the optimum path. When you turn back to move toward the target, if you sense no barrier, you will be able to move along the optimum path.</p><p>However, if your robot encounters the obstacle again, it will repeat the process, until it reaches <a id="id240" class="indexterm"/>the goal. In this case, using these rules, the robot will travel the following path:</p><div class="mediaobject"><img src="graphics/B04591_05_20.jpg" alt="Avoiding obstacles"/></div><p>There is one more step you'll need to take before adding the sonar sensor's capability to your robot. You'll need to change the sonar sensor code so that it can be added to the Python code as a library. The following is that code:</p><div class="mediaobject"><img src="graphics/B04591_05_21.jpg" alt="Avoiding obstacles"/></div><p>You'll <a id="id241" class="indexterm"/>also import this code using the <code class="literal">from compass import *</code> statement. You'll also be using the time library and the <code class="literal">time.sleep</code> command to add delay between different statements in the code. And the following is the first part of the code that uses all of this to detect the barrier, turn to the right, then first part of the Python code that utilizes the sonar sensor:</p><div class="mediaobject"><img src="graphics/B04591_05_22.jpg" alt="Avoiding obstacles"/></div><p>And <a id="id242" class="indexterm"/>the following is the final piece of the code:</p><div class="mediaobject"><img src="graphics/B04591_05_22.jpg" alt="Avoiding obstacles"/></div><p>Now,<a id="id243" class="indexterm"/> this algorithm is quite simple; there are others that have much more complex responses to barriers. You can also see that by adding sonar sensors to the sides your robot could actually sense when the barrier has ended. You could also provide more complex decision processes about which way to <a id="id244" class="indexterm"/>turn to avoid an object. Again, there are many different path finding algorithms. See <a class="ulink" href="http://www.academia.edu/837604/A_Simple_Local_Path_Planning_Algorithm_for_Autonomous_Mobile_Robots">http://www.academia.edu/837604/A_Simple_Local_Path_Planning_Algorithm_for_Autonomous_Mobile_Robots</a> for an example of this. These more complex algorithms can be explored by using the basic functionality that you have built in this chapter.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Summary</h1></div></div></div><p>You've now added path planning to your robot's capability. Your robot can now not only move from point A to point B, but can also avoid barriers that might be in the way. In the next chapter, you'll learn how to add a webcam to your biped. This will introduce a whole new set of ways for your robot to experience the world around it.</p></div></body></html>