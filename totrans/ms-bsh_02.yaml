- en: Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符
- en: What we have looked at so far is tinkering with values returned from variable
    expansions and descriptors used in a tricky way. So, something nice, but we could
    not do much more, since we do not have a way to actually relate values, compare
    or even modify at our will.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的是处理来自变量扩展和描述符的值，并以巧妙的方式使用它们。因此，这是一个不错的操作，但我们还不能做太多，因为我们没有办法真正关联值、进行比较，甚至按我们的意图修改它们。
- en: Here is where the operators come in to play, and we will see how to modify the
    value of a variable so that it will hold a value and, over time, modify to gather
    new information. So, let's start from something simple, from basic math then move
    on to something more complex.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是操作符发挥作用的地方，我们将看到如何修改变量的值，以便它能持有一个值，并随着时间推移逐步修改并收集新的信息。所以，让我们从简单的开始，先从基础数学入手，然后逐步过渡到更复杂的内容。
- en: 'One last thing we have to bear in mind before proceeding is that the operators
    follow an order of precedence:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们必须记住的一件事是，操作符遵循一个优先级顺序：
- en: The compound logical operators `-a`, `-o`, and `&&` have a low precedence
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合逻辑操作符 `-a`、`-o` 和 `&&` 的优先级较低
- en: 'The arithmetic operators have the following precedence:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术操作符的优先级如下：
- en: Multiply
  id: totrans-6
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘
- en: Divide
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除
- en: Add
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加
- en: Subtract
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减
- en: The evaluation of operators with equal precedence is from left to right
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有相同优先级的操作符按从左到右的顺序进行求值
- en: Arithmetic operators
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术操作符
- en: Arithmetic operators do what you think they do, that is, add, subtract, divide,
    and so on. It is something we are familiar with even without specific programming
    knowledge. Let's see each of them and how they can be used to manipulate the value
    of variables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 算术操作符做的就是你想的那样，也就是加、减、除等。即使没有特定的编程知识，我们也很熟悉这些操作。让我们来看一下它们每一个是如何用来操作变量的值的。
- en: Before proceeding, keep in mind that for a shell script, a number is a decimal
    unless you prefix that with a `0` for the octal, a `0x` for a hexadecimal number,
    or a `base#number` for a number that evaluates on the base.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请记住，对于 shell 脚本，数字默认是十进制，除非在前面加上 `0` 表示八进制，`0x` 表示十六进制，或者使用 `base#number`
    来表示基数为 base 的数值。
- en: The + operator
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: + 操作符
- en: 'This is like what we see at primary school; this operator allows us to add
    an integer to the value of the variable, as we can see in the following example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像我们在小学时学到的内容；这个操作符允许我们将一个整数加到变量的值上，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now time to invoke the script:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候调用脚本了：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you have probably noted, we used a double parenthesis construct `$(( ))`
    to perform this arithmetic expansion and evaluation: in short, it is as we said,
    expand and evaluate, then return the value. It is a common notation in binary
    operators and also allows us to quote special characters as if we''d enclosed
    them into double quotes, so we are not compelled to escape that. The only exception
    is the double quote, which still must be escaped. Do not worry; we will read more
    about special characters and how to quote them later on.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们使用了双括号结构 `$(( ))` 来执行这种算术扩展和求值：简而言之，就是扩展并求值，然后返回值。这是二进制操作符中常见的符号，它还允许我们像用双引号括起来一样引用特殊字符，因此我们不必强制进行转义。唯一的例外是双引号，它仍然需要进行转义。别担心，我们稍后会进一步了解特殊字符以及如何引用它们。
- en: 'Now, just try to run the script and give no numbers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试运行脚本并且不提供数字：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The number `99` is not an assignment, just a default value we were returned
    in case the variable held no usable values, but the first and second variables
    have no assignment so adding one value to the other leads us to `0`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 `99` 不是赋值，它只是我们在变量没有有效值的情况下返回的默认值，但第一个和第二个变量没有赋值，因此将一个值加到另一个值上会导致 `0`。
- en: The - operator
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- 操作符'
- en: 'Well, in this case, we are going to subtract something from the value of the
    variable with a little caveat: this is a left-associative operation, with the
    evaluation order from left to right, and this means that we are subtracting the
    value at the right of the minus sign from the value on the left:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，在这种情况下，我们将从变量的值中减去一些东西，有一个小的警告：这是一个左结合操作，从左到右进行求值，这意味着我们正在将减号右侧的值从左侧的值中减去：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The * operator
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '* 操作符'
- en: 'To multiply, we do not need to care about the order; one value is multiplied
    for another one, no matter which direction we take:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于乘法，我们不需要关注顺序；一个值与另一个值相乘，无论我们采取哪个方向：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The / operator
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: / 操作符
- en: 'Division is another operation left-associative, so we divide the number on
    the left of the division character by the number on the right:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除法是另一个左关联的运算，因此我们将除号左边的数字除以右边的数字：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The % operator
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '% 运算符'
- en: 'The modulo operator gives us the remainder of the division between two integers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 模除运算符给我们提供了两个整数相除的余数：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The ** operator
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '** 运算符'
- en: 'As we saw at school, exponentiation is a number multiplied by itself as many
    times as imposed by the exponent:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在学校看到的那样，指数运算是一个数乘以它自己若干次，次数由指数决定：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, we are facing a left-associative operation and the order matters.
    Be aware that, in any case, the variables are expanded before the evaluation takes
    place with all the operators we have seen so far. We are using both `$a` and`${a}`
    to get you used to what you will face in real life, looking at the scripts you
    will find on the Internet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们面对的是一个左关联操作，顺序很重要。请注意，在任何情况下，变量会在评估之前展开，所有我们到目前为止看到的运算符都会被应用。我们使用了`$a`和`${a}`，是为了让你习惯在实际生活中，查看你在互联网上会遇到的脚本。
- en: Assignment operators
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: We have seen how to manipulate the value assigned to a variable and an integer
    so far, and then reassign this value to another variable or the same one. But
    why use two operations when you can alter the value of a variable and reassign
    it at the same time using the assignment operators?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何操作赋值给变量的值和整数，然后将这个值重新赋给另一个变量或相同的变量。但为什么要使用两个操作，而不是同时使用赋值运算符来修改变量的值并重新赋值呢？
- en: The += operator
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: += 运算符
- en: 'This operator adds a quantity to the value of the variable and assigns the
    outcome to the variable itself, but to clarify its use, let''s rewrite one of
    the examples we''ve seen before:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符将一个数量加到变量的值上，并将结果赋值给变量本身，但为了澄清它的用法，让我们重写我们之前见过的一个例子：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 加法
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now, let''s run it, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按如下方式运行它：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Easy! And we did not have to reassign the value of 200 explicitly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单！我们不需要显式地重新赋值200。
- en: The -= operator
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -= 运算符
- en: 'Actually, this is very similar to the the former operator, only in this case,
    we do a subtraction and reassign the value. Let''s rewrite our last script with
    the operator and see what happens:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这与前一个运算符非常相似，只是在这种情况下，我们做了减法并重新赋值。让我们用运算符重写我们的最后一个脚本，看看会发生什么：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *= operator
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*= 运算符'
- en: 'In this case, we are multiplying the value of the variable for the given number
    and reassigning:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将变量的值乘以给定的数字，并重新赋值：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Nice!  Indeed, we reached one of boundaries of the modern Bash: in the past,
    the value held by a variable could be represented by a 32-bit signed long, but
    from version 2.05b onward it switched to a 64-bit signed integer in the following
    range of:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！ 事实上，我们已经达到了现代Bash的一个边界：过去，变量保存的值可以用一个32位带符号长整型表示，但从2.05b版本开始，它切换到一个64位带符号整数，范围如下：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Remember that values containing a comma are interpreted as a character string.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，包含逗号的值会被解释为字符字符串。
- en: The /= operator
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /= 运算符
- en: 'In this case, we are dividing the value of the variable for a given number
    and reassigning the new value to it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将变量的值除以给定的数字，并重新赋值新值：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The %= operator
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '%= 运算符'
- en: 'With modulo assignment, we divide the value of the variable for a given number
    and reassign the remainder. Let''s just modify a couple of lines in our script:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模赋值，我们将变量的值除以给定的数字，并重新赋值余数。我们只需修改我们脚本中的几行：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And execute it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行它：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The ++ or -- operators
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ++ 或 -- 运算符
- en: 'This is the unary operator `++` (or `--`), which allows us to increase/decrease
    the value of a variable of `1` and reassign it, but be careful, the position of
    the operator matters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个一元运算符`++`（或`--`），它允许我们将变量的值增加/减少`1`并重新赋值，但要小心，运算符的位置很重要：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Can you figure out what happened? Simply, in the first case, the first operator
    returned the value and, only after, added 1 to it; in the second case, first it
    added 1 to the value and then returned it. Pay attention to this operator because
    it is widely used inside loops to count the cycles and eventually break out from
    them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你能弄清楚发生了什么吗？简单来说，在第一个例子中，第一个运算符返回了值，然后才加了1；在第二个例子中，它首先加了1到值，然后返回它。请注意这个运算符，因为它在循环内部广泛使用，用于计数循环次数并最终跳出循环：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We instance a variable named counter with a value of `10`, then we define a
    loop, which while the counter value is greater than `0`, it prints the value of
    the counter and decreases it, reassigning it. At each cycle, the variable value
    is printed and then lowered by  `1`. Once the counter reaches `0`, the while condition
    is no longer valid and the loop stops:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化一个名为`counter`的变量，初始值为`10`，然后定义一个循环，当`counter`的值大于`0`时，打印`counter`的值并将其减少，每次减少`1`。每个循环周期中，变量的值被打印，然后减小。当`counter`达到`0`时，`while`条件不再有效，循环停止：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Bitwise operators
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算符
- en: Bitwise operators are useful when dealing with bit masks, but in normal practice,
    they are not so easy to use, and so you will not encounter them very often. However,
    since they are available in Bash we are going to have a look at them with some
    examples.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符在处理位掩码时非常有用，但在日常实践中，它们并不那么容易使用，因此你不太可能经常遇到它们。然而，由于它们在Bash中可用，我们将通过一些示例来查看它们。
- en: Left shift (<<)
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 左移 (<<)
- en: 'The bitwise left shift operators simply multiplies by 2 a value for each shift
    position; the following example will make everything more clear:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算左移运算符每移位一次就将值乘以`2`；以下示例将使一切变得更清楚：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What happened? As we said before, the bitwise operators work on a bit mask,
    so let's start converting the integer `10` to its binary representation in 16-bit
    and using a power of 2 table to check the values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？正如我们之前所说，位运算符作用于位掩码，那么我们就从将整数`10`转换为其16位二进制表示开始，并使用一个`2`的幂表来检查其值。
- en: 'In this case, a simple method to represent a decimal in a binary form is to
    use the power of two notations, starting with dividing our integer in a sum of
    power of two numbers. In our example, the highest power of two that fits into
    `10` is `2³`, which is `8`, plus `2¹`,that is, `2`. So, among the powers of two
    we select only  `23` and `21` and we can represent this in a table like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，表示十进制数的二进制形式的简单方法是使用二的幂表示法，从将整数分解为幂和数的和开始。在我们的示例中，适合`10`的最大二的幂是`2³`，即`8`，加上`2¹`，即`2`。因此，在二的幂中，我们只选择`23`和`21`，并可以像下面的表格那样表示：
- en: '| **2⁷** | **2⁶** | **2⁵** | **2⁴** | **2³** | **2²** | **2¹** | **2⁰** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **2⁷** | **2⁶** | **2⁵** | **2⁴** | **2³** | **2²** | **2¹** | **2⁰** |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
- en: '| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |'
- en: '|  |  |  |  | 8 |  | 2 |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  | 8 |  | 2 |  |'
- en: If we mark with a `1` the powers of `2`, we used to represent the number `10`
    and with `0` those unused, the result will be `1010`, or `00001010` if we use
    8-bit to represent the number.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`1`标记`2`的幂，表示我们用来表示数字`10`的部分，用`0`标记未使用的部分，结果将是`1010`，或者如果使用8位表示数字，则为`00001010`。
- en: 'What we are going to do now is to shift all the digits to the left by one position,
    but this gives us an issue with the right end digit, which has no digit on its
    right to take over its place. So, for the last right slot, we will use a `0`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的是将所有数字向左移动一个位置，但这会给我们带来一个问题，即右边的数字没有右边的数字可以替代它的位置。所以，对于最后一个右边的槽，我们将使用一个`0`：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
- en: '|  |  |  | 16 |  | 4 |  |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | 16 |  | 4 |  |  |'
- en: 'And this number, converted into decimal, is `20`. So now, let''s see what  `echo$((x<<2))` turns
    into:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个数字转换为十进制后是`20`。所以现在，让我们看看`echo$((x<<2))`会变成什么：
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |'
- en: '|  |  | 32 |  | 8 |  |  |  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 32 |  | 8 |  |  |  |'
- en: 'So, we have `40`. Now it is time to go over `$((x<<3))`, moving out the first
    one on the left, adding a trailing `0` and adding a sign bit at the beginning:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们得到了`40`。现在是时候进行`$((x<<3))`，将第一个`1`移出左侧，添加一个尾随的`0`并在开头添加一个符号位：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 |'
- en: '|  | 64 |  | 16 |  |  |  |  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  | 64 |  | 16 |  |  |  |  |'
- en: 'We reached `80`; now, let''s go for `$((x<<4))`, same procedure:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们达到了`80`；现在，让我们进行`$((x<<4))`，使用相同的步骤：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |'
- en: '| 128 |  | 32 |  |  |  |  |  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 128 |  | 32 |  |  |  |  |  |'
- en: Well, `160` is the result, as you can imagine. So now we know a really fast
    method to multiply a number by the power of two, but what if we want to divide?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，`160` 就是结果，正如你能想象的那样。所以现在我们知道了一种非常快速的方式来将一个数字乘以二的幂，但是如果我们想要除法呢？
- en: Right shift (>>)
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 右移 (>>)
- en: 'The bitwise right shift is a great method to divide a number by `2` at each
    position, so division by power of `2`, shifting the bit to the right. Note that
    this operation pads on the left with the most significant bit, that is the sign
    bit, so everything will be padded by one, but the following example will make
    everything easier:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按位右移是将数字除以 `2` 的一种很好的方法，每次右移一位，即通过二的幂进行除法。请注意，这个操作会在左边填充最高有效位，也就是符号位，所以所有的位都会填充为
    `1`，但下面的例子会让一切变得更简单：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, let''s start with `160`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从 `160` 开始：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |'
- en: '| 128 |  | 32 |  |  |  |  |  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 128 |  | 32 |  |  |  |  |  |'
- en: 'What we will do now is to shift one position to the right:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们做的是将其右移一位：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 |'
- en: '|  | 64 |  | 1 |  |  |  |  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  | 64 |  | 1 |  |  |  |  |'
- en: 'Now we have `80`, but again, one position to the left:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到 `80`，但再次，左移一位：
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |'
- en: '|  |  | 32 |  | 8 |  |  |  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 32 |  | 8 |  |  |  |'
- en: Now, as an exercise, calculate by yourself the remaining values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为练习，自己计算剩下的值。
- en: Bitwise AND
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按位与
- en: 'This is the bitwise AND operator; it is similar to a logical AND but works
    on the bit mask on the binary representation of the integer. The binary bits are
    read from left to right and compared between the two numbers: if, in the same
    position of each number, we find a `1`, the result will be `1`, otherwise it will
    be `0`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是按位与运算符，它类似于逻辑与，但它在整数的二进制表示的位掩码上进行操作。二进制位从左到右读取，并在两个数字之间进行比较：如果在每个数字的相同位置上找到一个
    `1`，结果将是 `1`，否则将是 `0`：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'How did we come to such a value? Let''s create a matrix with the binary values
    of `50` and `20`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何得到这个值的？让我们创建一个包含 `50` 和 `20` 二进制值的矩阵：
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
- en: '| 20 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
- en: '| & | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| & | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |'
- en: The result is the binary `00010000`, which in decimal is `16`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是二进制 `00010000`，十进制是 `16`。
- en: Bitwise OR (|)
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按位或（|）
- en: 'The bitwise OR operator is similar to an inclusive OR and checks two integers
    using their binary representation: if there is at least a `1` on the same position
    for each number, the result will be `1`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 按位或运算符类似于包含性或，它通过二进制表示检查两个整数：如果在相同位置上每个数字都有一个 `1`，结果将是 `1`：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we can see from the following table:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从下面的表格中看到的：
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
- en: '| 20 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
- en: '| &#124; | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 |'
- en: Bitwise XOR (^)
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按位异或 (^)
- en: 'This is what we would call exclusive OR or XOR: the result will be `1` only
    if at the same slot, there is only a `1`, and if there are two `1`, the result
    will be `0`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所谓的异或（XOR）：只有在同一位置上只有一个 `1` 时，结果才为 `1`，如果有两个 `1`，结果将是 `0`：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, let''s check again with our matrix:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们再次检查我们的矩阵：
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
- en: '| 20 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
- en: '| ^ | 0 | 0 | 1 | 0 | 0 | 1 | 1 | 0 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| ^ | 0 | 0 | 1 | 0 | 0 | 1 | 1 | 0 |'
- en: And that is, `36`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 而结果就是 `36`。
- en: Bitwise NOT (~)
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按位非（~）
- en: 'The bitwise NOT is a unary operator, and this means it is used with just one
    operator, flipping the bit used to represent the integer in binary notation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按位非是一个一元运算符，这意味着它只与一个操作符一起使用，翻转用于表示整数的二进制位：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Have a look at the following table:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的表格：
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
- en: '| ~ | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| ~ | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |'
- en: '|  | -128 | 64 |  |  | 8 | 4 |  | 1 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  | -128 | 64 |  |  | 8 | 4 |  | 1 |'
- en: 'We have to keep in mind that the most significant bit on the left for a signed
    integer (and this is a signed integer, even though we do not write `+50` because
    Bash represents integer with a sign long at 64-bit) holds the sign value. So,
    flipping the first significant bit actually inverted the value. As the rule of
    thumb, the bitwise NOT leads to the same result as of a two''s complement of the
    number minus 1:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，对于一个带符号的整数（尽管我们没有写`+50`，因为Bash以64位符号长整型表示整数），最左边的最高位表示符号值。因此，翻转第一个有效位实际上反转了该值。经验法则是，按位取反的结果等于该数的二进制补码减去1：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
- en: '| 30 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |'
- en: '| ~ | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| ~ | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |'
- en: '|  | -128 | 64 | 32 |  |  |  |  | 1 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  | -128 | 64 | 32 |  |  |  |  | 1 |'
- en: 'However, we can also calculate the bitwise by not first converting the integer
    in binary, inverting the digits and adding to the result a `1` in binary notation
    in a so-called two''s complement:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以通过不首先将整数转换为二进制，直接取反位并在结果中加上一个`1`来计算按位运算，这就是所谓的二进制补码：
- en: '| **50** | **0** | **0** | **1** | **1** | **0** | **0** | **1** | **0** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **50** | **0** | **0** | **1** | **1** | **0** | **0** | **1** | **0** |'
- en: '| invert | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 反转 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |'
- en: '| add 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 加1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |'
- en: '| -51 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| -51 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |'
- en: So, as you can see, in the two's complement, binaries with the leftmost bit
    set to `1` have a negative value; those starting with `0` are positive integers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你所看到的，在二进制补码中，最左边的位为`1`的二进制数是负数，而以`0`开头的是正整数。
- en: Logical operators
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Here, we come to something really useful for our scripts, a bunch of operators
    that will enable us to perform some tests and react as a consequence. So, we will
    be able to make our script react to a some change or user input and be more flexible.
    Let's see what is available.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们进入了一些对我们的脚本非常有用的内容，一些操作符将使我们能够执行测试并做出响应。因此，我们将能够让脚本对某些变化或用户输入作出反应，变得更加灵活。让我们看看有哪些操作符可用。
- en: Logical NOT (!)
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑非（!）
- en: 'The NOT operator is used to test whether an expression is true and holds true
    when the expression is false:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 非运算符用于测试表达式是否为真，当表达式为假时它为真：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s go back to one of our previous scripts and make it more user-friendly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前的一个脚本，并让它变得更加用户友好：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What we are doing here is asking the user for a number between `10` and `12`.
    We read the value from its input and evaluate it: if the user inputs a value that
    is not equal to `11`, then we write a boo sentence; otherwise, we have found our
    number. Do not worry; we will have a look at `if...then...else` later in this
    book, just take `if` for what it is a simple conditional. Let''s run the script
    and see what happens when we input the right answer and when we fail the input:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的事情是要求用户输入一个介于`10`和`12`之间的数字。我们从用户的输入中读取值并进行评估：如果用户输入的值不等于`11`，那么我们输出一个“错误”语句；否则，我们找到了我们的数字。别担心，我们将在本书后面讨论`if...then...else`，现在只需将`if`理解为一个简单的条件语句。让我们运行脚本，看看当我们输入正确答案和错误答案时会发生什么：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Great! The script became quite interactive, and its output changes based on
    the conditions we imposed and the input we gave.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！脚本变得非常互动，根据我们施加的条件和给出的输入，它的输出发生了变化。
- en: Logical AND
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑与
- en: 'The AND operator tests the success of two or more expressions and holds true
    if all the conditions are true. This comes in handy to make our script a bit more
    complex so that we must pass at least a couple of conditions to make something
    trigger:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与运算符测试两个或多个表达式的成功性，当所有条件都为真时，它为真。这个操作符非常有用，可以让我们的脚本变得更加复杂，这样我们必须满足至少几个条件才能触发某些操作：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this case, we ask for a couple of conditions that must hold true at the
    same time: the number given by the user must be equal or greater than `10` and
    lesser or equal than `20`. Let''s see:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们要求几个条件必须同时成立：用户输入的数字必须大于等于`10`并且小于等于`20`。让我们看看：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Yes, `10` is good, since it is equal to `10` and less than `20`. Both conditions
    are true at the same time. We have the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，`10`是有效的，因为它等于`10`且小于`20`。这两个条件同时为真。我们有如下代码：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With `11`, we are OK, because it is more than `10` but at the same time, less
    than `20`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`11`，我们是OK的，因为它大于`10`且小于`20`：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Still a valid answer because it is more than `10` and less than `20`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然是一个有效的答案，因为它大于`10`且小于`20`：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This should be the last valid answer. The value is above `10` and equal to
    `20`, but `20` is our upper limit, so one more and we are out of our boundaries:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是最后一个有效的答案。值大于`10`并等于`20`，但是`20`是我们的上限，再多一个就超出了我们的边界：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here we are: above `10` but also above `20`, and our second condition holds
    true only if the value is less than or equal to `20`. So, just one condition is
    true, the other is false, and `21` is not the number we were looking for.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是：大于`10`但也大于`20`，而且只有当值小于等于`20`时，第二个条件才成立。所以，只有一个条件成立，另一个不成立，`21`不是我们要找的数字。
- en: Logical OR (||)
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑“或”运算符（||）
- en: 'The OR operator tests the success of two or more expressions and holds true
    if at least one condition is true:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: OR运算符测试两个或多个表达式的成功，并且如果至少一个条件成立，它就成立：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What we see here are a few interesting things. First, we used a compound condition
    test so that we can now check between four different conditions, grouped by 2\.
    Our test holds true if the user give us a number that is equal to or higher than
    `10` and at the same time, lower than or equal to `20`, or if he types a number
    that is equal to or higher than `50`, and at the same time lower or equal to `100`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了一些有趣的事情。首先，我们使用了复合条件测试，现在可以在四个不同的条件之间进行检查，按 2 分组。如果用户给我们的数字大于等于`10`且小于等于`20`，或者他输入一个大于等于`50`且小于等于`100`的数字，我们的测试就成立。
- en: Note that we had to use the test command with double brackets `[[`; this is
    a Bash improvement over the single bracket, and it should be preferred over this
    last one. To be true, the `[` is an actual binary, a command you can find into
    the operating system and `[[` is a keyword available only in Bash, **Zsh** and
    **Korn** shell.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不得不使用带双括号`[[`的测试命令；这是Bash对单括号的改进，应该优先使用。实际上，`[` 是一个实际的二进制命令，你可以在操作系统中找到，而
    `[[` 只是Bash、**Zsh** 和 **Korn** shell 中可用的关键字。
- en: There are quite a few interesting improvements with the double bracket. As an
    example, it does not suffer from word splitting or glob expansion, so deals better
    with spaces and empty strings and you do not have to quote your variables. Other
    advantages are that you do not have to escape any parenthesis inside the double
    brackets, and you can also use `!`, `&&`, and`||` inside them to combine different
    expressions. We used the `[]` test operator in our examples just to get used to
    them, but you will see in most of the scripts, you will encounter that the brackets
    are usually adopted for file or string test, whereas for testing numbers, you
    will prefer using the arithmetic operations `$(())`because the first is deprecated
    for arithmetic operations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 双括号有一些非常有趣的改进。例如，它不会受到词分割或通配符扩展的影响，因此能更好地处理空格和空字符串，且你不需要给变量加引号。其他优点包括你不必在双括号内转义任何括号，并且你可以在其中使用`!`、`&&`和`||`来组合不同的表达式。在我们的示例中使用了`[]`测试运算符，只是为了熟悉它们，但你会发现，在大多数脚本中，你通常会遇到括号用于文件或字符串测试，而测试数字时，你更喜欢使用算术操作`$(())`，因为前者在算术操作中已被弃用。
- en: Comma operator (,)
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逗号运算符（,）
- en: 'One last operator that actually does not fit into any other category is the
    comma operator, which is used to chain together arithmetic operations. All the
    operations are evaluated, but only the value from the last one is returned:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个实际上不属于任何其他类别的运算符是逗号运算符，它用于将算术操作连接起来。所有操作都会被评估，但只有最后一个操作的值会被返回：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Operators evaluation order and precedence in decreasing relevance
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符评估顺序和优先级，按降序排列
- en: 'Operators are evaluated in a precise order and we must keep this in mind when
    working with them. It is not so easy to remember what is evaluated before and
    what after, so the following table will help us to keep in mind the order and
    precedence of operators:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符的评估顺序是非常精确的，在使用它们时我们必须牢记这一点。记住哪个先评估哪个后评估并不容易，所以下面的表格将帮助我们记住运算符的顺序和优先级：
- en: '| **Operator** | **Evaluation order** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **评估顺序** |'
- en: '| ++ -- | Unary operators for incrementing/decrementing, evaluated from left
    to right |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| ++ -- | 用于递增/递减的单目运算符，从左到右评估 |'
- en: '| +- !~ | Unary plus and minus, evaluated from right to left |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| +- !~ | 单目加号和减号，从右到左评估 |'
- en: '| * / % | Multiplication, division, modulo, are evaluated from left to right
    and are evaluated after |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| * / % | 乘法、除法、取余，从左到右进行计算，并且在之后进行计算 |'
- en: '| + - | Addition and subtraction are evaluated from left to right |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| + - | 加法和减法从左到右进行计算 |'
- en: '| <<>> | Bitwise shift are evaluated from left to right |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| <<>> | 位移运算符从左到右进行计算 |'
- en: '| <= =><> | Comparison operators, from left to right |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| <= =><> | 比较运算符，从左到右 |'
- en: '| == != | Equality operators, from left to right |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| == != | 等式运算符，从左到右 |'
- en: '| & | Bitwise AND, from left to right |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| & | 位运算 AND，从左到右 |'
- en: '| ^ | Bitwise XOR, from left to right |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| ^ | 位运算 XOR，从左到右 |'
- en: '| &#124; | Bitwise OR, from left to right |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | 位运算 OR，从左到右 |'
- en: '| && | Logic AND, from left to right |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑 AND，从左到右 |'
- en: '| &#124;&#124; | Logic OR, from left to right |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑 OR，从左到右 |'
- en: '| = += -+ */ /= %= &= ^= <<= =>> }= | Assignment operators, from left to right
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| = += -+ */ /= %= &= ^= <<= =>> }= | 赋值运算符，从左到右 |'
- en: Exit codes
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出代码
- en: We have already seen that when a program encounters issues it *exits*, usually
    with an error message. What does exits means? Simply that the code execution terminates
    and the program, or the script, returns an exit code that informs the system of
    what happened. This is very handy for us, since we can trap the exit code of a
    program and decide what to do based on its value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当程序遇到问题时，它会*退出*，通常会带有错误信息。退出意味着什么呢？简单来说，就是代码执行终止，程序或脚本返回一个退出代码，通知系统发生了什么。这对我们非常有用，因为我们可以捕获程序的退出代码，根据其值决定接下来要做什么。
- en: '| 0 | Success |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 成功 |'
- en: '| 1 | Failure |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 失败 |'
- en: '| 2 | Misuse of builtin |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 内建命令滥用 |'
- en: '| 126 | Command not executable |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 126 | 命令不可执行 |'
- en: '| 127 | Command not found |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 127 | 命令未找到 |'
- en: '| 128 | Invalid argument |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 无效参数 |'
- en: '| 128+x | Fatal error exit with signal x |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 128+x | 致命错误，退出时信号 x |'
- en: '| 130 | Execution terminated by Ctrl +C |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 130 | 执行被 Ctrl + C 终止 |'
- en: '| 255 | Exit state out of boundary (0-255) |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 255 | 退出状态超出边界（0-255） |'
- en: 'So, maybe you already guessed, each execution terminates with an exit code,
    whether successful or not, with an error message or silently:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，或许你已经猜到，每次执行都会以退出代码结束，无论成功与否，是否带有错误信息或静默退出：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As you can see, the exit code is `0` because the command was executed without
    issues. Now, let''s try this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，退出代码是 `0`，因为命令没有出现问题地执行完毕。现在，让我们尝试这个：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is a `command not found` as we just typed a meaningless bunch of characters.
    Now a while cycle will not terminate until we press Ctrl + C.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个`command not found`，因为我们刚刚输入了一串无意义的字符。现在，除非我们按下 Ctrl + C，否则 while 循环不会终止。
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You will see your screen filling up with a column of infinite 1\. Press Ctrl
    + C and you will see:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到屏幕上充满了一列无限的 1。按下 Ctrl + C，你会看到：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, let''s check the exit code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查退出代码：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s create a never-ending script:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个永无止境的脚本：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Although true is a never-ending cycle, since the condition is always true,
    it will print to the `stdout` the PID of the shell, which the script is running
    in. Let''s open a second terminal and launch the script from the first; you will
    see the same PID repeated indefinitely:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 true 是一个永无止境的循环，因为条件始终为真，它将打印当前 shell 的 PID 到 `stdout`，脚本就在这个 shell 中运行。让我们打开第二个终端，并从第一个终端启动脚本；你将看到相同的
    PID 无限重复：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, from the second terminal, using the same user or root user, issue:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从第二个终端，使用相同的用户或 root 用户，执行：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Go back to the first terminal, and you see your script terminated:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第一个终端，你将看到你的脚本已终止：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Time to check the exit status of the script:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候检查脚本的退出状态了：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Which is `128 + 9`, `9` being the signal we used to kill the process. Let''s
    run the script again:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `128 + 9`，`9` 是我们用来杀死进程的信号。让我们再次运行脚本：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now kill it from the second terminal with:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过第二个终端使用以下命令结束它：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Back to the first terminal to check the exit code of the script:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第一个终端，检查脚本的退出代码：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: And `143` is exactly `128 + 15`, as we expected.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `143` 正好是 `128 + 15`，如我们预期的那样。
- en: Exiting a script
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出脚本
- en: 'So far, we have seen how a script terminated with the exit status of the last
    command issued, and how a `$?`  allows us to read the exit value. This is possible
    because every command returns an exit code, whether issued on the command line
    or from inside a script, and even functions that we can think of as a compound
    of commands return a value. Now we are going to see how a script can return an
    exit code on its own, despite of the result of the last command issued:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到脚本如何根据最后一个命令的退出状态来终止，以及`$?`如何让我们读取退出值。这是可能的，因为每个命令都会返回一个退出代码，无论是在命令行中发出的命令，还是在脚本内部发出的命令，甚至我们可以将其视为多个命令的组合的函数也会返回一个值。现在，我们将看到脚本如何根据其自身的情况返回一个退出码，而不依赖于最后一个命令的结果：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We took one of our previous scripts and added this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拿取了之前的一个脚本并加上了这个：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you can see, we used the command `exit` followed by a positive number to
    give an exit code. Remember that you can use any code between:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了`exit`命令，并跟随一个正整数来给出退出码。记住，你可以使用任何介于以下范围内的代码：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With the exclusion of the reserved values, we saw in the previous chapter.
    Now, let''s run the script:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 除去上一章中我们看到的保留值后，现在让我们运行脚本：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here we are. Instead of having a `0` as the script exit value, since the last
    instruction was successful, we have a `20`, provided by the exit command.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。由于最后的指令成功，脚本退出值是`0`，但因为`exit`命令的存在，我们得到了`20`作为退出值。
- en: 'Let''s modify the script a bit so that the exit will be just above our `echo`
    command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微修改一下脚本，使得退出命令位于我们的`echo`命令之前：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note a couple of things:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下几点：
- en: We are using both `$(())` and `(())`. The first is an arithmetic expansion and
    gives us a number, the second is a command that gives us an exit status so we
    can read *if it is true (0)* that the value of counter is less than value of `exit_at`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了`$(())`和`(())`。第一个是算术扩展，会给我们一个数字，第二个是一个命令，它会返回一个退出状态，以便我们可以读取*如果它为真（0）*，即计数器的值小于`exit_at`的值。
- en: We used a condition to break out of this infinite loop. Once the value of counter
    is less than the value of `exit_at`, we exit the whole script with a code of `18`,
    regardless of the fact that the last command, the evaluation of the `if` condition
    got a value of 1, so was a failure.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了一个条件来跳出这个无限循环。一旦计数器的值小于`exit_at`的值，我们就使用`18`的退出码退出整个脚本，而不管最后一个命令，即`if`条件的评估是失败的（值为1）。
- en: 'And now, execute the following script:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下脚本：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here we are. The script exited once it passed the boundary of `5`, so the remaining
    five `echo` commands were not executed at all and we got `18` as the exit value.
    So, now you have a handy loop that you can use to iterate over items and stop
    when a condition is reached.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。脚本一旦超过`5`的边界就退出了，所以剩下的五个`echo`命令根本没有被执行，我们得到了`18`作为退出值。所以，现在你有了一个方便的循环，可以用它遍历项目，并在满足某个条件时停止。
- en: 'We said that the `exit` command prevents the further execution of a script
    and the previous example gave us a glimpse of it, but let''s modify our previous
    loop script moving the `exit 20` command to some lines earlier:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾说过，`exit`命令会阻止脚本的进一步执行，之前的示例让我们对这一点有所了解，但现在让我们修改之前的循环脚本，把`exit 20`命令移动到前面几行：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s execute it:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行它：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Well, no output and the exit value is `20`. The script had no time to reach
    the echo line, it was forced to exit well before. Now, let''s see how our `exit`
    command masquerades the exit code from a command not found:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没有输出，退出值为`20`。脚本没有时间到达`echo`这一行，它被迫在之前就退出了。现在，让我们看看`exit`命令是如何掩盖一个“命令未找到”的退出码的：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Have a loop at the line under `echo`, that is, a bunch of characters without
    any sense, so it will throw an error for sure:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`echo`下方的那一行，也就是一堆没有任何意义的字符，它肯定会引发一个错误：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: It did, we had errors at each cycle, but the overall exit code is still `20`,
    since we forced this using the `exit` command.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实有用，在每个循环中我们都有错误，但总体的退出码仍然是`20`，因为我们通过`exit`命令强制了这一点。
- en: What are the benefits we can get from the usage of the `exit` command? Well,
    we just saw a nice and easy counter that can be useful to iterate over numbers,
    items, arrays, lists, but in a broader way, we can use the exit codes to check
    the result of a function we created, of a command we invoked and based on the
    value we get, react accordingly. To do this, though, we need to a way to verify
    and react, to check whether a condition is met or not, and based on that, to do
    something or something else, we need to have a closer look at the `if...else`
    statement and at the tests operators.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`exit`命令我们能获得哪些好处？嗯，我们刚刚看到了一个简单易用的计数器，它可以在遍历数字、项目、数组、列表时非常有用，但从更广泛的角度来看，我们可以利用退出码检查我们创建的函数的结果，检查我们调用的命令的结果，并根据得到的值做出相应的反应。不过，要做到这一点，我们需要一种方法来验证并做出反应，检查一个条件是否满足，然后根据结果执行某些操作或其他操作。为了做到这一点，我们需要更深入地了解`if...else`语句以及测试运算符。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In the previous chapter, we had a look at the variable; now we have just looked
    at how to correlate them. Assigning values and being able to perform some math
    or logic operations on them gives us more flexibility, since we do not just collect
    something, but transform it into something different and new. We also learned
    that exit codes can sometimes be pitfalls, trapping us with red herrings, and
    this tells us something important: never take anything as a given, always double-check
    what you are writing in your code, and always try to catch all the possible outcomes
    and exceptions. It seems like something obvious, but being such  common sense,
    we tend to overlook this simple but effective code style advice.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，我们学习了变量；现在我们刚刚了解了如何关联它们。为变量赋值并能够对其进行一些数学或逻辑运算为我们提供了更多的灵活性，因为我们不仅仅是收集某些东西，而是将其转化为不同且全新的东西。我们还了解到，退出码有时可能成为陷阱，迷惑我们并引导我们误入歧途，这告诉我们一个重要的事情：永远不要把任何事情视为理所当然，始终仔细检查你在代码中写的内容，并始终尝试捕捉所有可能的结果和例外情况。这个看似显而易见，但由于它是如此常识，我们往往忽视了这种简单却有效的编码风格建议。
