- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we have looked at so far is tinkering with values returned from variable
    expansions and descriptors used in a tricky way. So, something nice, but we could
    not do much more, since we do not have a way to actually relate values, compare
    or even modify at our will.
  prefs: []
  type: TYPE_NORMAL
- en: Here is where the operators come in to play, and we will see how to modify the
    value of a variable so that it will hold a value and, over time, modify to gather
    new information. So, let's start from something simple, from basic math then move
    on to something more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing we have to bear in mind before proceeding is that the operators
    follow an order of precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: The compound logical operators `-a`, `-o`, and `&&` have a low precedence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The arithmetic operators have the following precedence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Divide
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtract
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The evaluation of operators with equal precedence is from left to right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arithmetic operators do what you think they do, that is, add, subtract, divide,
    and so on. It is something we are familiar with even without specific programming
    knowledge. Let's see each of them and how they can be used to manipulate the value
    of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, keep in mind that for a shell script, a number is a decimal
    unless you prefix that with a `0` for the octal, a `0x` for a hexadecimal number,
    or a `base#number` for a number that evaluates on the base.
  prefs: []
  type: TYPE_NORMAL
- en: The + operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is like what we see at primary school; this operator allows us to add
    an integer to the value of the variable, as we can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now time to invoke the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have probably noted, we used a double parenthesis construct `$(( ))`
    to perform this arithmetic expansion and evaluation: in short, it is as we said,
    expand and evaluate, then return the value. It is a common notation in binary
    operators and also allows us to quote special characters as if we''d enclosed
    them into double quotes, so we are not compelled to escape that. The only exception
    is the double quote, which still must be escaped. Do not worry; we will read more
    about special characters and how to quote them later on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just try to run the script and give no numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The number `99` is not an assignment, just a default value we were returned
    in case the variable held no usable values, but the first and second variables
    have no assignment so adding one value to the other leads us to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The - operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, in this case, we are going to subtract something from the value of the
    variable with a little caveat: this is a left-associative operation, with the
    evaluation order from left to right, and this means that we are subtracting the
    value at the right of the minus sign from the value on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The * operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To multiply, we do not need to care about the order; one value is multiplied
    for another one, no matter which direction we take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The / operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Division is another operation left-associative, so we divide the number on
    the left of the division character by the number on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The % operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The modulo operator gives us the remainder of the division between two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The ** operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw at school, exponentiation is a number multiplied by itself as many
    times as imposed by the exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are facing a left-associative operation and the order matters.
    Be aware that, in any case, the variables are expanded before the evaluation takes
    place with all the operators we have seen so far. We are using both `$a` and`${a}`
    to get you used to what you will face in real life, looking at the scripts you
    will find on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to manipulate the value assigned to a variable and an integer
    so far, and then reassign this value to another variable or the same one. But
    why use two operations when you can alter the value of a variable and reassign
    it at the same time using the assignment operators?
  prefs: []
  type: TYPE_NORMAL
- en: The += operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This operator adds a quantity to the value of the variable and assigns the
    outcome to the variable itself, but to clarify its use, let''s rewrite one of
    the examples we''ve seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s run it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Easy! And we did not have to reassign the value of 200 explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The -= operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actually, this is very similar to the the former operator, only in this case,
    we do a subtraction and reassign the value. Let''s rewrite our last script with
    the operator and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The *= operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this case, we are multiplying the value of the variable for the given number
    and reassigning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice!  Indeed, we reached one of boundaries of the modern Bash: in the past,
    the value held by a variable could be represented by a 32-bit signed long, but
    from version 2.05b onward it switched to a 64-bit signed integer in the following
    range of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Remember that values containing a comma are interpreted as a character string.
  prefs: []
  type: TYPE_NORMAL
- en: The /= operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this case, we are dividing the value of the variable for a given number
    and reassigning the new value to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The %= operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With modulo assignment, we divide the value of the variable for a given number
    and reassign the remainder. Let''s just modify a couple of lines in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The ++ or -- operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the unary operator `++` (or `--`), which allows us to increase/decrease
    the value of a variable of `1` and reassign it, but be careful, the position of
    the operator matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you figure out what happened? Simply, in the first case, the first operator
    returned the value and, only after, added 1 to it; in the second case, first it
    added 1 to the value and then returned it. Pay attention to this operator because
    it is widely used inside loops to count the cycles and eventually break out from
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We instance a variable named counter with a value of `10`, then we define a
    loop, which while the counter value is greater than `0`, it prints the value of
    the counter and decreases it, reassigning it. At each cycle, the variable value
    is printed and then lowered by  `1`. Once the counter reaches `0`, the while condition
    is no longer valid and the loop stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Bitwise operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitwise operators are useful when dealing with bit masks, but in normal practice,
    they are not so easy to use, and so you will not encounter them very often. However,
    since they are available in Bash we are going to have a look at them with some
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Left shift (<<)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bitwise left shift operators simply multiplies by 2 a value for each shift
    position; the following example will make everything more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What happened? As we said before, the bitwise operators work on a bit mask,
    so let's start converting the integer `10` to its binary representation in 16-bit
    and using a power of 2 table to check the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, a simple method to represent a decimal in a binary form is to
    use the power of two notations, starting with dividing our integer in a sum of
    power of two numbers. In our example, the highest power of two that fits into
    `10` is `2³`, which is `8`, plus `2¹`,that is, `2`. So, among the powers of two
    we select only  `23` and `21` and we can represent this in a table like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **2⁷** | **2⁶** | **2⁵** | **2⁴** | **2³** | **2²** | **2¹** | **2⁰** |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  | 8 |  | 2 |  |'
  prefs: []
  type: TYPE_TB
- en: If we mark with a `1` the powers of `2`, we used to represent the number `10`
    and with `0` those unused, the result will be `1010`, or `00001010` if we use
    8-bit to represent the number.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are going to do now is to shift all the digits to the left by one position,
    but this gives us an issue with the right end digit, which has no digit on its
    right to take over its place. So, for the last right slot, we will use a `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | 16 |  | 4 |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'And this number, converted into decimal, is `20`. So now, let''s see what  `echo$((x<<2))` turns
    into:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 32 |  | 8 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'So, we have `40`. Now it is time to go over `$((x<<3))`, moving out the first
    one on the left, adding a trailing `0` and adding a sign bit at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 64 |  | 16 |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'We reached `80`; now, let''s go for `$((x<<4))`, same procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 128 |  | 32 |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: Well, `160` is the result, as you can imagine. So now we know a really fast
    method to multiply a number by the power of two, but what if we want to divide?
  prefs: []
  type: TYPE_NORMAL
- en: Right shift (>>)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bitwise right shift is a great method to divide a number by `2` at each
    position, so division by power of `2`, shifting the bit to the right. Note that
    this operation pads on the left with the most significant bit, that is the sign
    bit, so everything will be padded by one, but the following example will make
    everything easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s start with `160`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 128 |  | 32 |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'What we will do now is to shift one position to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 64 |  | 1 |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Now we have `80`, but again, one position to the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 32 |  | 8 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: Now, as an exercise, calculate by yourself the remaining values.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise AND
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the bitwise AND operator; it is similar to a logical AND but works
    on the bit mask on the binary representation of the integer. The binary bits are
    read from left to right and compared between the two numbers: if, in the same
    position of each number, we find a `1`, the result will be `1`, otherwise it will
    be `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'How did we come to such a value? Let''s create a matrix with the binary values
    of `50` and `20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| & | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: The result is the binary `00010000`, which in decimal is `16`.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise OR (|)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bitwise OR operator is similar to an inclusive OR and checks two integers
    using their binary representation: if there is at least a `1` on the same position
    for each number, the result will be `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| &#124; | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Bitwise XOR (^)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is what we would call exclusive OR or XOR: the result will be `1` only
    if at the same slot, there is only a `1`, and if there are two `1`, the result
    will be `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s check again with our matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| ^ | 0 | 0 | 1 | 0 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: And that is, `36`.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise NOT (~)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bitwise NOT is a unary operator, and this means it is used with just one
    operator, flipping the bit used to represent the integer in binary notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| ~ | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | -128 | 64 |  |  | 8 | 4 |  | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'We have to keep in mind that the most significant bit on the left for a signed
    integer (and this is a signed integer, even though we do not write `+50` because
    Bash represents integer with a sign long at 64-bit) holds the sign value. So,
    flipping the first significant bit actually inverted the value. As the rule of
    thumb, the bitwise NOT leads to the same result as of a two''s complement of the
    number minus 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|  | **128** | **64** | **32** | **16** | **8** | **4** | **2** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 30 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| ~ | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | -128 | 64 | 32 |  |  |  |  | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'However, we can also calculate the bitwise by not first converting the integer
    in binary, inverting the digits and adding to the result a `1` in binary notation
    in a so-called two''s complement:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **50** | **0** | **0** | **1** | **1** | **0** | **0** | **1** | **0** |'
  prefs: []
  type: TYPE_TB
- en: '| invert | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| add 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| -51 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: So, as you can see, in the two's complement, binaries with the leftmost bit
    set to `1` have a negative value; those starting with `0` are positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we come to something really useful for our scripts, a bunch of operators
    that will enable us to perform some tests and react as a consequence. So, we will
    be able to make our script react to a some change or user input and be more flexible.
    Let's see what is available.
  prefs: []
  type: TYPE_NORMAL
- en: Logical NOT (!)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NOT operator is used to test whether an expression is true and holds true
    when the expression is false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to one of our previous scripts and make it more user-friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is asking the user for a number between `10` and `12`.
    We read the value from its input and evaluate it: if the user inputs a value that
    is not equal to `11`, then we write a boo sentence; otherwise, we have found our
    number. Do not worry; we will have a look at `if...then...else` later in this
    book, just take `if` for what it is a simple conditional. Let''s run the script
    and see what happens when we input the right answer and when we fail the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Great! The script became quite interactive, and its output changes based on
    the conditions we imposed and the input we gave.
  prefs: []
  type: TYPE_NORMAL
- en: Logical AND
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AND operator tests the success of two or more expressions and holds true
    if all the conditions are true. This comes in handy to make our script a bit more
    complex so that we must pass at least a couple of conditions to make something
    trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we ask for a couple of conditions that must hold true at the
    same time: the number given by the user must be equal or greater than `10` and
    lesser or equal than `20`. Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, `10` is good, since it is equal to `10` and less than `20`. Both conditions
    are true at the same time. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With `11`, we are OK, because it is more than `10` but at the same time, less
    than `20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Still a valid answer because it is more than `10` and less than `20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be the last valid answer. The value is above `10` and equal to
    `20`, but `20` is our upper limit, so one more and we are out of our boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are: above `10` but also above `20`, and our second condition holds
    true only if the value is less than or equal to `20`. So, just one condition is
    true, the other is false, and `21` is not the number we were looking for.'
  prefs: []
  type: TYPE_NORMAL
- en: Logical OR (||)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OR operator tests the success of two or more expressions and holds true
    if at least one condition is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: What we see here are a few interesting things. First, we used a compound condition
    test so that we can now check between four different conditions, grouped by 2\.
    Our test holds true if the user give us a number that is equal to or higher than
    `10` and at the same time, lower than or equal to `20`, or if he types a number
    that is equal to or higher than `50`, and at the same time lower or equal to `100`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we had to use the test command with double brackets `[[`; this is
    a Bash improvement over the single bracket, and it should be preferred over this
    last one. To be true, the `[` is an actual binary, a command you can find into
    the operating system and `[[` is a keyword available only in Bash, **Zsh** and
    **Korn** shell.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few interesting improvements with the double bracket. As an
    example, it does not suffer from word splitting or glob expansion, so deals better
    with spaces and empty strings and you do not have to quote your variables. Other
    advantages are that you do not have to escape any parenthesis inside the double
    brackets, and you can also use `!`, `&&`, and`||` inside them to combine different
    expressions. We used the `[]` test operator in our examples just to get used to
    them, but you will see in most of the scripts, you will encounter that the brackets
    are usually adopted for file or string test, whereas for testing numbers, you
    will prefer using the arithmetic operations `$(())`because the first is deprecated
    for arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Comma operator (,)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One last operator that actually does not fit into any other category is the
    comma operator, which is used to chain together arithmetic operations. All the
    operations are evaluated, but only the value from the last one is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Operators evaluation order and precedence in decreasing relevance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operators are evaluated in a precise order and we must keep this in mind when
    working with them. It is not so easy to remember what is evaluated before and
    what after, so the following table will help us to keep in mind the order and
    precedence of operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Evaluation order** |'
  prefs: []
  type: TYPE_TB
- en: '| ++ -- | Unary operators for incrementing/decrementing, evaluated from left
    to right |'
  prefs: []
  type: TYPE_TB
- en: '| +- !~ | Unary plus and minus, evaluated from right to left |'
  prefs: []
  type: TYPE_TB
- en: '| * / % | Multiplication, division, modulo, are evaluated from left to right
    and are evaluated after |'
  prefs: []
  type: TYPE_TB
- en: '| + - | Addition and subtraction are evaluated from left to right |'
  prefs: []
  type: TYPE_TB
- en: '| <<>> | Bitwise shift are evaluated from left to right |'
  prefs: []
  type: TYPE_TB
- en: '| <= =><> | Comparison operators, from left to right |'
  prefs: []
  type: TYPE_TB
- en: '| == != | Equality operators, from left to right |'
  prefs: []
  type: TYPE_TB
- en: '| & | Bitwise AND, from left to right |'
  prefs: []
  type: TYPE_TB
- en: '| ^ | Bitwise XOR, from left to right |'
  prefs: []
  type: TYPE_TB
- en: '| &#124; | Bitwise OR, from left to right |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logic AND, from left to right |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logic OR, from left to right |'
  prefs: []
  type: TYPE_TB
- en: '| = += -+ */ /= %= &= ^= <<= =>> }= | Assignment operators, from left to right
    |'
  prefs: []
  type: TYPE_TB
- en: Exit codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen that when a program encounters issues it *exits*, usually
    with an error message. What does exits means? Simply that the code execution terminates
    and the program, or the script, returns an exit code that informs the system of
    what happened. This is very handy for us, since we can trap the exit code of a
    program and decide what to do based on its value.
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | Success |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Failure |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Misuse of builtin |'
  prefs: []
  type: TYPE_TB
- en: '| 126 | Command not executable |'
  prefs: []
  type: TYPE_TB
- en: '| 127 | Command not found |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | Invalid argument |'
  prefs: []
  type: TYPE_TB
- en: '| 128+x | Fatal error exit with signal x |'
  prefs: []
  type: TYPE_TB
- en: '| 130 | Execution terminated by Ctrl +C |'
  prefs: []
  type: TYPE_TB
- en: '| 255 | Exit state out of boundary (0-255) |'
  prefs: []
  type: TYPE_TB
- en: 'So, maybe you already guessed, each execution terminates with an exit code,
    whether successful or not, with an error message or silently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the exit code is `0` because the command was executed without
    issues. Now, let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It is a `command not found` as we just typed a meaningless bunch of characters.
    Now a while cycle will not terminate until we press Ctrl + C.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see your screen filling up with a column of infinite 1\. Press Ctrl
    + C and you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check the exit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a never-ending script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Although true is a never-ending cycle, since the condition is always true,
    it will print to the `stdout` the PID of the shell, which the script is running
    in. Let''s open a second terminal and launch the script from the first; you will
    see the same PID repeated indefinitely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from the second terminal, using the same user or root user, issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the first terminal, and you see your script terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to check the exit status of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is `128 + 9`, `9` being the signal we used to kill the process. Let''s
    run the script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now kill it from the second terminal with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to the first terminal to check the exit code of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: And `143` is exactly `128 + 15`, as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: Exiting a script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how a script terminated with the exit status of the last
    command issued, and how a `$?`  allows us to read the exit value. This is possible
    because every command returns an exit code, whether issued on the command line
    or from inside a script, and even functions that we can think of as a compound
    of commands return a value. Now we are going to see how a script can return an
    exit code on its own, despite of the result of the last command issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We took one of our previous scripts and added this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used the command `exit` followed by a positive number to
    give an exit code. Remember that you can use any code between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With the exclusion of the reserved values, we saw in the previous chapter.
    Now, let''s run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here we are. Instead of having a `0` as the script exit value, since the last
    instruction was successful, we have a `20`, provided by the exit command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the script a bit so that the exit will be just above our `echo`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Note a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: We are using both `$(())` and `(())`. The first is an arithmetic expansion and
    gives us a number, the second is a command that gives us an exit status so we
    can read *if it is true (0)* that the value of counter is less than value of `exit_at`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used a condition to break out of this infinite loop. Once the value of counter
    is less than the value of `exit_at`, we exit the whole script with a code of `18`,
    regardless of the fact that the last command, the evaluation of the `if` condition
    got a value of 1, so was a failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And now, execute the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here we are. The script exited once it passed the boundary of `5`, so the remaining
    five `echo` commands were not executed at all and we got `18` as the exit value.
    So, now you have a handy loop that you can use to iterate over items and stop
    when a condition is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'We said that the `exit` command prevents the further execution of a script
    and the previous example gave us a glimpse of it, but let''s modify our previous
    loop script moving the `exit 20` command to some lines earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, no output and the exit value is `20`. The script had no time to reach
    the echo line, it was forced to exit well before. Now, let''s see how our `exit`
    command masquerades the exit code from a command not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a loop at the line under `echo`, that is, a bunch of characters without
    any sense, so it will throw an error for sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: It did, we had errors at each cycle, but the overall exit code is still `20`,
    since we forced this using the `exit` command.
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits we can get from the usage of the `exit` command? Well,
    we just saw a nice and easy counter that can be useful to iterate over numbers,
    items, arrays, lists, but in a broader way, we can use the exit codes to check
    the result of a function we created, of a command we invoked and based on the
    value we get, react accordingly. To do this, though, we need to a way to verify
    and react, to check whether a condition is met or not, and based on that, to do
    something or something else, we need to have a closer look at the `if...else`
    statement and at the tests operators.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we had a look at the variable; now we have just looked
    at how to correlate them. Assigning values and being able to perform some math
    or logic operations on them gives us more flexibility, since we do not just collect
    something, but transform it into something different and new. We also learned
    that exit codes can sometimes be pitfalls, trapping us with red herrings, and
    this tells us something important: never take anything as a given, always double-check
    what you are writing in your code, and always try to catch all the possible outcomes
    and exceptions. It seems like something obvious, but being such  common sense,
    we tend to overlook this simple but effective code style advice.'
  prefs: []
  type: TYPE_NORMAL
