["```\nroot@arm:~# ./bin/gpio_set.sh 60 in\n\n```", "```\nroot@arm:~# while true ; do cat /sys/class/gpio/gpio60/value | grep 0 ; done\n\n```", "```\nroot@arm:~# while true ; do cat /sys/class/gpio/gpio60/value | grep 0 ; done\n0\n0\n0\n0\n0\n...\n\n```", "```\nroot@arm:~# ./bin/gpio_set.sh 68 out 1\n\n```", "```\nroot@arm:~# echo 0 > /sys/class/gpio/gpio68/value\nroot@arm:~# echo 1 > /sys/class/gpio/gpio68/value\n\n```", "```\n$ git am --whitespace=nowarn 0001-Add-support-for-Homebrew-GPIO-Port-Receiver-Transmit.patch\n\n```", "```\n$ git log -1\ncommit be816108417ce82c7114ebd578ac32a45aef934a\nAuthor:     Rodolfo Giometti <giometti@linux.it>\nAuthorDate: Sun Oct 11 08:43:49 2015 +0200\nCommit:     Rodolfo Giometti <giometti@linux.it>\nCommitDate: Thu Oct 22 14:53:44 2015 +0200\n\n Add support for Homebrew GPIO Port Receiver/Transmitter\n\n Signed-off-by: Rodolfo Giometti <giometti@linux.it>\n\n```", "```\n/*\n * Module parameters\n */\n\n/* Set the default GPIO input pin */\nstaticintgpio_in = -1;\nMODULE_PARM_DESC(gpio_in, \"GPIO input/receiver pin number \"\n                   \"(warning: it MUST be an interrupt capable pin!)\");\nmodule_param(gpio_in, int, S_IRUGO);\n\n/* Set the default GPIO output pin */\nstaticintgpio_out = -1;\nMODULE_PARM_DESC(gpio_out, \"GPIO output/transmitter pin number\");\nmodule_param(gpio_out, int, S_IRUGO);\n\n/* Set the sense mode: -1 = auto, 0 = active high, 1 = active low */\nstaticint sense = -1;\nMODULE_PARM_DESC(sense, \"Override autodetection of IR receiver circuit: \"\"0 = active high, 1 = active low (default -1 = auto)\");\nmodule_param(sense, int, S_IRUGO);\n\n/* Use softcarrier by default */\nstatic unsigned int softcarrier = 1;\nMODULE_PARM_DESC(softcarrier, \"Software carrier: 0 = off, 1 = on (default on)\");\nmodule_param(softcarrier, uint, S_IRUGO);\n```", "```\nstatic const struct file_operationslirc_fops = {\n        .owner          = THIS_MODULE,\n        .write          = lirc_write,\n        .unlocked_ioctl = lirc_ioctl,\n        .read           = lirc_dev_fop_read,\n        .poll           = lirc_dev_fop_poll,\n        .open           = lirc_dev_fop_open,\n        .release        = lirc_dev_fop_close,\n        .llseek         = no_llseek,\n};\n```", "```\n /*  \n   * Check for valid gpio pin numbers \n   */ \n   ret = gpio_request(gpio_in, LIRC_GPIO_NAME \" ir/in\"); \n   if (ret) { \n      pr_err(\"failed to request GPIO %u\\n\", gpio_in); \n      return -EINVAL; \n   } \n   ret = gpio_direction_input(gpio_in); \n   if (ret) { \n      pr_err(\"failed to set pin direction for gpio_in\\n\"); \n      ret = -EINVAL; \n      goto exit_free_gpio_in; \n   } \n   pr_info(\"got GPIO %d for receiving\\n\", gpio_in); \n   /* Is GPIO in pin IRQ capable? */ \n   irq = gpio_to_irq(gpio_in); \n   if (irq < 0) { \n      pr_err(\"failed to map GPIO %d to IRQ\\n\", gpio_in); \n      ret = -EINVAL;\n      goto exit_free_gpio_in; \n   } \n   ret = request_irq(irq, (irq_handler_t) irq_handler, IRQF_TRIGGER_FALLING | IRQF_TRIGGER_ RISING, LIRC_GPIO_NAME, (void *) 0); \n   if (ret < 0) { \n      pr_err(\"unable to request IRQ %d\\n\", irq); \n      goto exit_free_gpio_in; \n   } \n   pr_info(\"got IRQ %d for GPIO %d\\n\", irq, gpio_in); \n   if (gpio_out >= 0) { \n      ret = gpio_request(gpio_out, LIRC_GPIO_NAME \" ir/ out\"); \n      if (ret) { \n         pr_err(\"failed to request GPIO %u\\n\", gpio_ out); \n         goto exit_free_irq; \n      } \n      ret = gpio_direction_output(gpio_out, 0); \n      if (ret) { \n         pr_err(\"failed to set pin direction for gpio_ out\\n\"); \n         ret = -EINVAL; \n         goto exit_free_gpio_out; \n      } \n      pr_info(\"got GPIO %d for transmitting\\n\", gpio_out); \n   } \n```", "```\n     /* Set the sense mode */\n     if (sense != -1) {\n             pr_info(\"manually using active %s receiver on GPIO %d\\n\",\n                     sense ? \"low\" : \"high\", gpio_in);\n     } else {\n             /* wait 1/2 sec for the power supply */\n             msleep(500);\n\n             /*\n              * probe 9 times every 0.04s, collect \"votes\" for\n              * active high/low\n              */\n             nlow = 0;\n             nhigh = 0;\n             for (i = 0; i < 9; i++) {\n                     if (gpio_get_value(gpio_in))\n                             nlow++;\n                     else\n                             nhigh++;\n                     msleep(40);\n             }\n             sense = (nlow >= nhigh ? 1 : 0);\n             pr_info(\"auto-detected active %s receiver on GPIO pin %d\\n\",\n                     sense ? \"low\" : \"high\", gpio_in);\n     }\n```", "```\n     /*\n      * Setup the LIRC driver\n      */\n\n     ret = lirc_buffer_init(&rbuf, sizeof(int), RBUF_LEN);\n     if (ret < 0) {\n          pr_err(\"unable to init lirc buffer!\\n\");\n             ret = -ENOMEM;\n             goto exit_free_gpio_out;\n     }\n\n     ret = platform_driver_register(&lirc_gpio_driver);\n     if (ret) {\n             pr_err(\"error in lirc register\\n\");\n             goto exit_free_buffer;\n        }\n\n        lirc_gpio_dev = platform_device_alloc(LIRC_GPIO_NAME, 0);\n        if (!lirc_gpio_dev) {\n                pr_err(\"error on platform device alloc!\\n\");\n                ret = -ENOMEM;\ngoto exit_driver_unreg;\n        }\n\n        ret = platform_device_add(lirc_gpio_dev);\n        if (ret) {\n                pr_err(\"error on platform device add!\\n\");\ngoto exit_device_put;\n        }\n\n        driver.features = LIRC_CAN_REC_MODE2;\n        if (gpio_out >= 0) {\n                driver.features |= LIRC_CAN_SET_SEND_DUTY_CYCLE |\n                          LIRC_CAN_SET_SEND_CARRIER |\n                          LIRC_CAN_SEND_PULSE;\n        }\n\n        driver.dev = &lirc_gpio_dev->dev;\n        driver.minor = lirc_register_driver(&driver);\n\n        if (driver.minor < 0) {\n                pr_err(\"device registration failed!\");\n                ret = -EIO;\ngoto exit_device_put;\n        }\n\n        pr_info(\"driver registered!\\n\");\n\n        return 0;\n```", "```\n$ ./build_kernel.sh\n\n```", "```\n-----------------------------\nScript Complete\neewiki.net: [user@localhost:~$ export kernel_version=3.13.11-bone12]\n-----------------------------\n\n```", "```\n$ ./tools/install_kernel.sh\n\n```", "```\nroot@arm:~# uname -a\nLinux arm 3.13.11-bone12 #1 SMP Sun Oct 11 09:15:46 CEST 2015 armv7l GNU/Linux\n\n```", "```\nroot@arm:~# modprobe lirc_gpio gpio_in=60\n\n```", "```\nERROR: could not insert 'lirc_gpio': Invalid argument\n\n```", "```\nlirc_dev: IR Remote Control driver registered, major 241\nlirc_gpio: module is from the staging directory, the quality is unknown, you have been warned.\nlirc_gpio: got GPIO 60 for receiving\nlirc_gpio: got IRQ 204 for GPIO 60\nlirc_gpio: auto-detected active low receiver on GPIO pin 60\nlirc_gpio lirc_gpio.0: lirc_dev: driver lirc_gpio registered at minor = 0\nlirc_gpio: driver registered!\n\n```", "```\nroot@arm:~/chapter_10# ls -l /dev/lirc*\ncrw-rw---T 1 root video 241, 0 Aug 13 16:35 /dev/lirc0\n\n```", "```\nroot@arm:~# aptitude install lirc\n...\nSetting up lirc (0.9.0~pre1-1) ...\n[ ok ] No valid /etc/lirc/lircd.conf has been found..\n[ ok ] Remote control support has been disabled..\n[ ok ] Reconfigure LIRC or manually replace /etc/lirc/lircd.conf to enable..\n\n```", "```\nroot@arm:~# mode2 --driver default --device /dev/lirc0\n\n```", "```\nspace 3333126\npulse 8985\nspace 4503\npulse 564\nspace 535\npulse 564\nspace 561\npulse 542\nspace 551\n...\n\n```", "```\nroot@arm:~# irrecord --driver default --device /dev/lirc0 myremote.conf\n\n```", "```\nirrecord -  application for recording IR-codes for usage with lirc\n\nCopyright (C) 1998,1999 Christoph Bartelmus(lirc@bartelmus.de)\n\nThis program will record the signals from your remote control\nand create a config file for lircd.\n\nA proper config file for lircd is maybe the most vital part of this\npackage, so you should invest some time to create a working config\nfile. Although I put a good deal of effort in this program it is often\nnotpossible to automatically recognize all features of a remote\ncontrol. Often short-comings of the receiver hardware make it nearly\nimpossible. If you have problems to create a config file READ THE\nDOCUMENTATION of this package, especially section \"Adding new remote\ncontrols\" for how to get help.\n\nIf there already is a remote control of the same brand available at\nhttp://www.lirc.org/remotes/ you might also want to try using such a\nremote as a template. The config files already contain all\nparameters of the protocol used by remotes of a certain brand and\nknowing these parameters makes the job of this program much\neasier. There are also template files for the most common protocols\navailable in the remotes/generic/ directory of the source\ndistribution of this package. You can use a template files by\nproviding the path of the file as command line parameter.\n\nPlease send the finished config files to <lirc@bartelmus.de> so that I\ncan make them available to others. Don't forget to put all information\nthat you can get about the remote control in the header of the file.\n\nPress RETURN to continue.\n\n```", "```\nNow start pressing buttons on your remote control.\n\nIt is very important that you press many different buttons and hold them\ndown for approximately one second. Each button should generate at least one dot but in no case more than ten dots of output.\nDon't stop pressing buttons until two lines of dots (2x80) have been\ngenerated.\n\nPress RETURN now to start recording.\n\n```", "```\n....................................................................\nFound const length: 107736\n\n```", "```\nPlease keep on pressing buttons like described above.\n............irrecord: signal too long\nCreating config file in raw mode.\nNow enter the names for the buttons.\n\n```", "```\nPlease enter the name for the next button (press <ENTER> to finish recording)\n\n```", "```\nKEY_0\n\nNow hold down button \"KEY_0\".\nGot it.\nSignal length is 67\n\n```", "```\nroot@arm:~# irrecord --list-namespace\nKEY_0\nKEY_102ND\nKEY_1\nKEY_2\nKEY_3\nKEY_4\nKEY_5\nKEY_6\nKEY_7\nKEY_8\nKEY_9\nKEY_A\nKEY_AB\n...\n\n```", "```\nPlease enter the name for the next button (press <ENTER> to finish recording)\nKEY_1\n\nNow hold down button \"KEY_1\".\nGot it.\nSignal length is 67\n\nPlease enter the name for the next button (press <ENTER> to finish recording)\nKEY_2\n\nNow hold down button \"KEY_2\".\nGot it.\nSignal length is 67\n\nPlease enter the name for the next button (press <ENTER> to finish recording)\nKEY_3\n\nNow hold down button \"KEY_3\".\nGot it.\nSignal length is 67\n\n```", "```\nPlease enter the name for the next button (press <ENTER> to finish recording)\n\nroot@arm:~#\n\n```", "```\n# Please make this file available to others\n# by sending it to <lirc@bartelmus.de>\n#\n# this config file was automatically generated\n# using lirc-0.9.0-pre1(default) on Wed Aug 13 15:54:26 2014\n#\n# contributed by\n#\n# brand:                       myremote.conf\n# model no. of remote control:\n# devices being controlled by this remote:\n#\n\nbegin remote\n\n  name  myremote.conf\n  flags RAW_CODES\n  eps            30\n  aeps          100\n\n  gap          96036\n\nbegin raw_codes\n\n          name KEY_0\n             8998    4478     566     541     570     541\n              570     541     570     542     570     541\n              570     541     570     541     578     533\n              570     541     570     541     570     542\n              570     540     570    1679     571     541\n              570     541     569     543     569     542\n              570     541     570    1679     570    1678\n              571     541     570     541     570     542\n              570     540     570    1679     570    1679\n              570     541     571     540     571    1685\n              563    1679     570    1678     571    1678\n              571   47910    9003    2231     570\n\n          name KEY_1\n             8969    4507     537     571     539     571\n              540     572     539     572     539     572\n              540     571     540     572     546     565\n              539     572     540     571     540     571\n              540     571     540    1709     540     572\n              539     572     546     566     538    1709\n              540    1709     540     572     539     572\n              539     572     539     573     545     566\n              538     572     539     573     538     572\n              539    1710     540    1709     539    1712\n              539    1709     539    1709     539    1710\n              539   47930    8983    2261     539\n...\n```", "```\nroot@arm:~# lircd --nodaemon --device /dev/lirc0 --driver default --uinput myremote.conf\nlircd-0.9.0-pre1[2235]: lircd(default) ready, using /var/run/lirc/lircd\n\n```", "```\nroot@arm:~# evtest\nNo device specified, trying to scan all of /dev/input/event*\nAvailable devices:\n/dev/input/event0:      lircd\nSelect the device event number [0-0]:\n\n```", "```\nInput driver version is 1.0.1\nInput device ID: bus 0x0 vendor 0x0 product 0x0 version 0x0\nInput device name: \"lircd\"\nSupported events:\n Event type 0 (EV_SYN)\n Event type 1 (EV_KEY)\n Event code 1 (KEY_ESC)\n Event code 2 (KEY_1)\n Event code 3 (KEY_2)\n Event code 4 (KEY_3)\n ...\n Event code 237 (KEY_BLUETOOTH)\n Event code 238 (KEY_WLAN)\n Event code 239 (KEY_UWB)\n Event code 240 (KEY_UNKNOWN)\n Event type 20 (EV_REP)\nProperties:\nTesting ... (interrupt to exit)\n\n```", "```\nEvent: time 1445765562.506427, type 1 (EV_KEY), code 11 (KEY_0), value 1\nEvent: time 1445765562.506427, -------------- SYN_REPORT ------------\n...\nEvent: time 1445765566.745716, type 1 (EV_KEY), code 2 (KEY_1), value 1\nEvent: time 1445765566.745716, -------------- SYN_REPORT ------------\n...\nEvent: time 1445765568.216621, type 1 (EV_KEY), code 3 (KEY_2), value 1\nEvent: time 1445765568.216621, -------------- SYN_REPORT ------------\n...\nEvent: time 1445765569.357041, type 1 (EV_KEY), code 4 (KEY_3), value 1\nEvent: time 1445765569.357041, -------------- SYN_REPORT ------------\n...\n\n```", "```\nroot@arm:~# aptitude install evtest\n\n```", "```\nGPIO = [-1, -1, 69, 44, 45, -1, -1, -1, -1, -1, -1, 68]\n```", "```\nroot@arm:~# pip install evdev\n\n```", "```\n#\n# Local functions\n#\n\ndef gpio_get(gpio):\n   fd = open(\"/sys/class/gpio/gpio\" + str(gpio) + \"/value\", \"r\")\n   val = fd.read()\n   fd.close()\nreturn int(val)\n\ndef gpio_set(gpio, val):\n   fd = open(\"/sys/class/gpio/gpio\" + str(gpio) + \"/value\", \"w\")\n   v = fd.write(str(val))\n   fd.close()\n\ndef usage():\n   print(\"usage: \", NAME, \" [-h] <inputdev>\", file=sys.stderr)\n   sys.exit(2);\n\n#\n# Main\n#\n\ntry:\n   opts, args = getopt.getopt(sys.argv[1:], \"h\",\n      [\"help\"])\nexcept getopt.GetoptError, err:\n   # Print help information and exit:\n   print(str(err), file=sys.stderr)\n   usage()\n\nfor o, a in opts:\n   if o in (\"-h\", \"--help\"):\n      usage()\n   else:\n      assert False, \"unhandled option\"\n\n# Check command line\nif len(args) < 1:\n   usage()\n\n# Try to open the input device\ntry:\n   dev = InputDevice(args[0])\nexcept:\n   print(\"invalid input device\", args[0], file=sys.stderr)\n   sys.exit(1);\n\nlogging.info (dev)\nlogging.info(\"hit CTRL+C to stop\")\n\n# Start the main loop\nfor event in dev.read_loop():\n    if event.type == ecodes.EV_KEY and event.value == 1:\n           # Get the key code and convert it to the corresponding GPIO\n           code = event.code\n           if code < 0 or code > len(GPIO):\n                   gpio = -1\n           else:\n                   gpio = GPIO[code]\n           logging.info(\"got code %d -> GPIO%d\" % (code, gpio))\n\n           if gpio > 0:\n                   # Get current GPIO status and invert it\n                   status = gpio_get(gpio)\n                   status = 1 - status\n                   gpio_set(gpio, status)\n                   logging.info(\"turning GPIO%d %d -> %d\" %\n                           (gpio, 1 - status, status))\n           else:\n                  logging.info(\"invalid button\")\n```", "```\nroot@arm:~# ./read_events.py /dev/input/event0\nINFO:root:device /dev/input/event0, name \"lircd\", phys \"\"\nINFO:root:hit CTRL+C to stop\nINFO:root:got code 2 -> GPIO68\nINFO:root:turning GPIO68 1 -> 0\nINFO:root:got code 3 -> GPIO69\nINFO:root:turning GPIO69 1 -> 0\nINFO:root:got code 3 -> GPIO69\nINFO:root:turning GPIO69 0 -> 1\nINFO:root:got code 2 -> GPIO68\nINFO:root:turning GPIO68 0 -> 1\n\n```", "```\nroot@arm:~# evtest\nNo device specified, trying to scan all of /dev/input/event*\nAvailable devices:\n/dev/input/event0:   lircd\n/dev/input/event1:   HID 04d9:1203\nSelect the device event number [0-1]:\n\n```", "```\nEvent: time 1445766356.367407, type 4 (EV_MSC), code 4 (MSC_SCAN), value 70027\nEvent: time 1445766356.367407, type 1 (EV_KEY), code 11 (KEY_0), value 1\nEvent: time 1445766356.367407, -------------- SYN_REPORT ------------\n...\nEvent: time 1445766365.537391, type 4 (EV_MSC), code 4 (MSC_SCAN), value 7001e\nEvent: time 1445766365.537391, type 1 (EV_KEY), code 2 (KEY_1), value 1\nEvent: time 1445766365.537391, -------------- SYN_REPORT ------------\n...\nEvent: time 1445766367.437377, type 4 (EV_MSC), code 4 (MSC_SCAN), value 7001f\nEvent: time 1445766367.437377, type 1 (EV_KEY), code 3 (KEY_2), value 1\nEvent: time 1445766367.437377, -------------- SYN_REPORT ------------\n...\nEvent: time 1445766369.537383, type 4 (EV_MSC), code 4 (MSC_SCAN), value 70020\nEvent: time 1445766369.537383, type 1 (EV_KEY), code 4 (KEY_3), value 1\nEvent: time 1445766369.537383, -------------- SYN_REPORT ------------\n...\n\n```", "```\nroot@arm:~# ./read_events.py /dev/input/event1\nINFO:root:device /dev/input/event1, name \"HID 04d9:1203\", phys \"usb-musb-hdrc.1.auto-1/input0\"\nINFO:root:hit CTRL+C to stop\nINFO:root:got code 11 -> GPIO68\nINFO:root:turning GPIO68 1 -> 0\nINFO:root:got code 2 -> GPIO69\nINFO:root:turning GPIO69 1 -> 0\nINFO:root:got code 3 -> GPIO44\nINFO:root:turning GPIO44 1 -> 0\nINFO:root:got code 4 -> GPIO45\nINFO:root:turning GPIO45 1 -> 0\n\n```", "```\nroot@beaglebone:~# ./SYSINIT.sh\ndone!\n\n```", "```\nroot@arm:~# lircd --device /dev/lirc0 --driver default --uinputmyremote.conf\n\n```", "```\nroot@arm:~# ./read_events.py /dev/input/event0\n\n```"]