- en: AWK Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stream editor is not alone in its family and has a big brother, AWK. In
    this chapter, we will run through the basics of AWK and explore the power of the
    AWK programming language. We will learn why we need and love AWK and how we can
    make use of some of the basic features before we start putting AWK to practical
    use in the next two chapters. As we work our way through this, we will cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The history behind AWK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and filtering content from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWK variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further filtering to display users by UID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWK control files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter10](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter10)'
  prefs: []
  type: TYPE_NORMAL
- en: The history behind AWK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `awk` command is a command suite mainstay in both UNIX and Linux. The UNIX
    `awk` command was first developed by Bell Labs in the 1970s and is named after
    the surnames of the main authors: Alfred Aho, Peter Weinberger, and Brian Kernighan.
    The `awk` command allows access to the AWK programming language, which is designed
    to process data within text streams.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many implementations of AWK:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gawk**: Also known as GNU AWK, it is a free version of AWK and used by many
    developers; we will use it in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mawk**: Another implementation made by a guy named Mike Brennan. This implementation
    only includes a few gawk features; it was designed for speed and performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tawk**: Or Thompson AWK, is an implementation that works on Solaris, DOS,
    and Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BWK awk**: Also known as nawk, it is used by OpenBSD and macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `awk` interpreter that we will use in this book is `gawk` but
    there is a symbolic link for it with the name `awk`. So `awk` and `gawk` are the
    same command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can ensure this by listing the `awk` binary to see where it points to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d405e0c-371f-412a-8d9a-f1e2c554d4d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To demonstrate the programming language that is provided with `awk`, we should
    create a `Hello World` program. We know this is compulsory for all languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Not only can we see that this code will print the ubiquitous hello message,
    we can also generate header information with the `BEGIN` block. Later, we will
    see that we
  prefs: []
  type: TYPE_NORMAL
- en: can create summary information with an `END` code block by allowing for a main
  prefs: []
  type: TYPE_NORMAL
- en: code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the output of this basic command in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/757972a8-7d3e-4d0f-a5a1-fd273419035c.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying and filtering content from files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, of course we all want to be able to print a little more than just `Hello
    World`. The `awk` command can be used to filter content from files and, if needed,
    very large files. We should begin by printing the complete file before filtering
    it. In this way, we will get a feel for the syntax of the command. Later, we will
    see how we can add this control information into `awk` files to ease the command
    line. Using the following command, we will print all the lines from the `/etc/passwd`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to using the `$0` variable with the `print` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'AWK provides us with some ready-to-use variables to extract data such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$0` for the entire line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$1` for the first field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$2` for the second field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$3` for the third field and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we will need to specify that in this file the field separator used
    is a colon, since it's the field separator in `/etc/passwd` file. The `awk` default
    delimiter is a space or any amount of spaces or tabs and newlines. There are two
    ways to specify the input delimiter; these are displayed in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example is easy and simple to use. The `-F` option works well, especially
    where we do not need any additional header information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also do this within the `BEGIN` block; this is useful when we want
    to use the `BEGIN` block to display header information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can see this clearly in the preceding example, in which we named the `BEGIN`
    block and all of the code within it is corralled by the brace brackets. The main
    block has no name and is enclosed within the brace brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'After seeing the `BEGIN` block and the main code blocks, we will now look at
    the `END` code block. This is often used to display summary data. For example,
    if we want to print the total lines in the `passwd` file, we can make use of the
    `END` block. The code with the `BEGIN` and `END` blocks is processed just once,
    whereas the main block is processed for each line. The following example adds
    to the code we have written so far to include the total line count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `awk` internal variable `NR` maintains the number of processed lines. If
    we want, we can add some additional text to this. This can be used to annotate
    the summary data. We can also make use of the single quotes that are used with
    the AWK language; they will allow us to spread the code across multiple lines.
    Once we have opened the single quotes, we can add newlines to the command line
    right until we close the quote. This is demonstrated in the next example where
    we have extended the summary information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not wish to end our AWK experience here, we can easily display a running
    line count with each line, as well as the final total. This is shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot captures this command and shows a partial output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2719bbfb-dc6e-4bbe-9eed-82ab0735eb19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first example with `BEGIN`, we saw that there is no reason why we cannot
    use the `END` code block in isolation without a main code block. If we need to
    emulate the `wc -l` command, we can use the following `awk` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be the line count from the file. The following screenshot shows
    both the use of the `awk` command and the `wc` command to count the lines in the
    `/etc/passwd` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f32eb6df-a407-48aa-a1ec-4bcca857381c.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the output does tally with `28` lines and our code has worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature that we can practice with is working on selected lines only.
    For example, if we want to print only the first five lines, we will use the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to print lines `8` through to `12`, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use regular expressions to match the text in the lines. Take a
    look at the following example where we look at the lines that end in the word
    `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The example and the output it produces are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9950942-4576-4d57-9e76-00db300f4232.png)'
  prefs: []
  type: TYPE_IMG
- en: So if you want to use a regex pattern, you should use two slashes and write
    the pattern between them, `/bash$/`.
  prefs: []
  type: TYPE_NORMAL
- en: AWK variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to use data fields such as `$1` and `$2`. Also, we saw the `NR` field,
    which holds the number of processed lines, but there are more built-in variables
    that AWK offers to simplify work more and more.
  prefs: []
  type: TYPE_NORMAL
- en: '`FIELDWIDTHS`: Specifies the field width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RS`: Specifies the record separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FS`: Specifies the field separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OFS`: Specifies the output separator, which is a space by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORS`: Specifies the output separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILENAME`: Holds the processed file name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NF`: Holds the line being processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FNR`: Holds the record which is processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IGNORECASE`: Ignores character case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These variables can help you a lot in many cases. Let''s assume that we have
    the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can say that we have two records for two persons and each record contains
    three fields. Let's assume that we need to print the name and the phone number.
    So how do we make AWK process them correctly?
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the fields are separated by a newline (`\n`) and the records are
    separated by empty lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we set the `FS` to (`\n`) and the `RS` to empty text, the fields will
    be identified correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/361093cf-f70e-4c2d-8ce3-648beef07edb.png)'
  prefs: []
  type: TYPE_IMG
- en: The result appears valid and appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, you can use the `OFS` and `ORS` for the output report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b76f1ab8-5aa2-4e3d-b1fa-bc8c7ea452d2.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use any text that fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that `NR` holds the number of the processed line and `FNR` looks the
    same from the definition, but let''s explore the following example to see the
    difference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s process this file using AWK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/11a00d9b-6945-4e95-a407-1cf18b195699.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we processed the file twice for testing purposes only to see what the value
    of the FNR variable is.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the value starts from 1 for every processing cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the whether `NR` variable is used in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c86fa85a-2ff9-47c0-bf4b-305d06baacd6.png)'
  prefs: []
  type: TYPE_IMG
- en: The `NR` variable preserves its value during the entire processing while `FNR`
    started from 1.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can define your own variables to use in AWK programming, as with any programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define the variable using any text, but it **MUST** not start with
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7fc7426a-2318-4abe-9a6d-9fefe5f77c3d.png)'
  prefs: []
  type: TYPE_IMG
- en: You can define any type of variables and use it the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define numbers like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/df63184b-d9ca-4954-a84e-1b50e59f3e07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Or perform string concatenation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/16df7c1c-1c6e-47d4-80d3-7c4212e44a0e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, AWK is a powerful scripting language.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWK supports conditional statements such as `if` and `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The if command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assume you have the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s filter the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/298b58b8-5aa1-410f-adfc-52221e3062e9.png)'
  prefs: []
  type: TYPE_IMG
- en: The `if` statement checks every value and, if it's greater than `50`, it will
    print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `else` clauses like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/046f7d64-582c-4377-b9fd-cc5fbbcf910b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t use brackets `{}` to enclose your statements, you can type them
    on the same line with a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can save this code into a file and assign it to the `awk` command
    using the `-f` option, as we will see later on this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWK processes every line of your file, but what if you want to iterate over
    the fields of each line itself?
  prefs: []
  type: TYPE_NORMAL
- en: You can iterate over fields using a `while` loop when using AWK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now let's iterate over the fields using a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0d7658dd-f966-4a9c-9f9c-1a2ccebdc975.png)'
  prefs: []
  type: TYPE_IMG
- en: The `while` loop iterates over the fields; we get the mean value for every row
    and print it.
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use `for` loops to iterate over values when using AWK like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a3f8945c-372b-47c5-9299-864315bba4a2.png)'
  prefs: []
  type: TYPE_IMG
- en: We achieved the same result but using the `for` loop this time.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have remained faithful to the `print` command so far, as we have been limited
    in what we require from the output. If we want to print out, say, the username,
    UID, and default shell, we need to start formatting the output just a little.
    In this case, we can organize the output in well-shaped columns. Without formatting,
    the command we use will look similar to the following example, where we use commas
    to separate the field that we want to print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use the `BEGIN` block here, as we can make use of it to print column headers
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the problem a little better, take a look at the following screenshot,
    which illustrates uneven column widths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bf6ec22-7ba9-47e6-a607-20d508c24e25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The issue that we have in the output is that the columns do not align, as the
    username is an inconsistent length. To improve on this, we can use the `printf`
    function where we can specify the column width. The syntax for the `awk` statements
    will be similar to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `printf` formatting is included within double quotes. We also need to include
    the newline with the `\n`. The `printf` function does not add a newline automatically,
    whereas the `print` function does. We print the three fields; the first accepts
    string values and is set to `10` characters wide. The middle field accepts up
    to 4 numbers and we finish with the default shell field where we allow up to `17`
    string characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the output can be improved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97206a9b-bc3b-48e5-8680-e5ab77c9d1dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can further enhance this by adding header information. Although the code
    starts to look untidy at this stage, we will later see how we can resolve this
    with AWK control files. The following example shows the header information being
    added to the `Begin` block. The semicolon is used to separate the two statements
    in the `BEGIN` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see how this improves the output even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b0843bd-5e5c-4978-86d2-cd2dfb8dbf4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapter, we saw how we can augment the output with the use
    of colors in the shell. We may also use color from within AWK by adding our own
    functions. In the next code example, you will see that AWK allows us to define
    our own functions to facilitate more complex operations and isolate the code.
    We will now modify the previous code to include green output in the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the function within `awk` allows color to be added where we require,
    in this case, green text. It is easy to create functions to define other colors.
    The code and output are included in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbbf8c9f-4f3b-4285-8792-ce9d95340d39.png)'
  prefs: []
  type: TYPE_IMG
- en: Further filtering to display users by UID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been able to build our skills with AWK, piece by piece, and what we
    have learned has been useful. We can take these tiny steps and add them to start
    creating something a little more usable. Perhaps we want to print just standard
    users; these are usually users higher than 500 or 1,000 depending on your particular
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Linux Mint distribution that I am using for this book, standard users
    start with UID `1000`. The UID is the third field. This is really a simple matter
    of using the value of the third field as the range operator. We can see this in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can show users whose UID is `101` or lower with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These just give you an idea of some of the possibilities available with AWK.
    The reality is that we can play all day with our arithmetic comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen that, with some of these examples, the `awk` statements become
    a little long. This is where we can implement the `awk` control files. Let's take
    a look at these straightaway before we get lost in a morass of syntax.
  prefs: []
  type: TYPE_NORMAL
- en: AWK control files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as with `sed`, we can simplify the command line by creating and including
    control files. This also makes editing the command later more easily achievable.
    The control files contain all the statements that we want `awk` to execute. The
    main thing that we must consider with `sed`, `awk`, and shell scripts is modularization;
    creating reusable elements that can be used to isolate and reuse the codes. This
    saves us time and work and we get more time for the tasks that we enjoy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an example of an `awk` control file, we should revisit the formatting
    of the `passwd` file. Creating the following file will encapsulate the `awk` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can save this file as `passwd.awk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being able to encompass all `awk` statements in the one file is very convenient
    and the execution becomes clean and tidy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This certainly encourages more complex `awk` statements and allows you to extend
    more functionality to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we defined a function called `green`. This leads into
    taking about some built-in functions that come with `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'AWK comes with many built-in functions such as mathematical functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sin(x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cos(x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqrt(x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp(x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log(x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rand()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, there are built-in functions that can be used in string manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope that you have a better and clearer understanding of what you can use
    the AWK tool for. This is a data-processing tool that runs through text files,
    line by line, and processes the code you add. The main block runs for each line
    that matches the row criteria, whereas the `BEGIN` and `END` block code is executed
    just once.
  prefs: []
  type: TYPE_NORMAL
- en: You've learned how to use AWK built-in variables and how to define your own
    variables and use them.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you have learned how to use the `if`, `while` , and `for` loop to iterate
    over data fields.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss regular expressions and how to use them
    in `sed` and AWK to gain a lot of power.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the output of the following command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume you have the following file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you run the following command against this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How many numbers will be printed?
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you have the following file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And you run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with the previous code?
  prefs: []
  type: TYPE_NORMAL
- en: How many lines will be printed from the following command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://likegeeks.com/awk-command/](https://likegeeks.com/awk-command/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.gnu.org/software/gawk/manual/gawk.html](https://www.gnu.org/software/gawk/manual/gawk.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
