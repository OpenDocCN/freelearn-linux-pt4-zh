- en: Introducing the Stream Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw that we could make use of `sed` to edit files
    from within our scripts. The `sed` command is the **stream editor** (**sed**)
    and opens the file line by line to search or edit the file content. Historically,
    this goes way back to Unix, where systems may not have had enough RAM to open
    very large files. Using `sed` was absolutely required to carry out edits. Even
    today, we will use `sed` to make changes and display data from files with hundreds
    and thousands of entries. It is simpler and easier and more reliable than a human
    trying to do the same thing. Most importantly, as we have seen, we can use `sed`
    in scripts to edit the files automatically; no human interaction is required.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at `grep` and searching the files for text. The `re`
    in the `grep` command is short for **regular expression**. Even though we are
    not looking at scripting in this chapter, we will be covering some very important
    tools that we can use with scripts. In the next chapter, we will see the practical
    implementation of `sed` in scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the moment though, we have enough to deal with and we will cover the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `grep` to display text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basics of `sed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other `sed` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple `sed` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: Using grep to display text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be beginning this journey by looking at the `grep` command. This will
    enable us to grasp some simple concepts of searching through the text before moving
    onto more complex regular expressions and editing files with `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Global regular expression print** (**grep**), or what we more commonly call
    the `grep` command, is a command-line tool used to search globally (across all
    the lines in a file) and print the result to `STDOUT`. The search string is a
    regular expression.'
  prefs: []
  type: TYPE_NORMAL
- en: The `grep` command is such a common tool that it has many simple examples and
    numerous occasions where we can use it each day. In the following sections, we
    have included some simple and useful examples with explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying received data on an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will print just the received data from the `eth0` interface.
  prefs: []
  type: TYPE_NORMAL
- en: This is the interface that is my primary network connection. If you are uncertain
    of your interface name, you can use the `ifconfig -a` command to display all the
    interfaces and choose the correct interface name on your system. If `ifconfig` is
    not found, try typing the full path, `/sbin/ifconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using just the `ifconfig eth0` command, a heap of data can be printed to the
    screen. To show just the packets received, we can isolate the lines that contain
    `RX packets` (`RX` for received). This is where `grep` comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the pipe or vertical bars, we can take the output of the `ifconfig` command
    and send it to the input of the `grep` command. In this case, `grep` is searching
    for a very simple string, `RX packets`. The search string is case sensitive, so
    we need to get this right or use the `-i` option with `grep` to run the search
    as case insensitive, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A case-insensitive search is especially useful when searching for options in
    a configuration file, which often have mixed cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the result of the initial command in the following screenshot, confirming
    that we have been able to isolate just the single line of output, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8438d3b5-445f-4d50-8a68-889898da93e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying user account data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The local user account database in Linux is the `/etc/passwd` file and this
    is readable by all user accounts. If we want to search for the line that contains
    our own data, we can use either our own login name in the search or use parameter
    expansion and the `$USER` variable. We can see this in the following command example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the input to `grep` comes from the `/etc/passwd` file and we
    search for the value of the `$USER` variable. Again, in this case, it is a simple
    text, but it is still the regular expression, just without any operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, we include the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ff2f0ae-977a-46df-a95f-c006907cbdb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can extend this a little using this type of query as a condition within
    a script. We can use this to check whether a user account exists before trying
    to create a new account. To keep the script as simple as possible and to ensure
    that administrative rights are not required, creating the account will display
    just the prompt and conditional test in the following command-line example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `grep` search now makes use of the `$REPLY` variable populated by `read`.
    If I enter the name `pi`, a message will be displayed and we will exit because
    my user account is also called `pi`. There is no need to display the result from
    `grep`; we are just looking for a return code that is either `true` or `false`.
    To ensure that we do not see any unnecessary output if the user is in the file,
    we redirect the output from `grep` to the special device file `/dev/null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run this from the command line, you should start a new bash
    shell first. You can do this by simply typing `bash`. In this way, when the `exit`
    command runs, it will not log you out but close the newly opened shell. We can
    see this happening and the results when specifying an existing user in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c29fad8-fd65-4e0c-a125-d5f9ba5a5666.png)'
  prefs: []
  type: TYPE_IMG
- en: Listing the number of CPUs in a system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another really useful feature is that `grep` can count the matching lines and
    not display them. We can use this to count the number of CPUs or CPU cores we
    have on a system. Each core or CPU is listed with a name in the `/proc/cpuinfo`
    file. We can then search for the text `name` and count the output; the `-c` option
    used is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'My CPU has four cores, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f673d39b-5ba9-4ca7-b698-f8db3cc7cf4f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we use the same code on another PC Model B that has a single core, we will
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3f6e13c-3be6-4c29-98d8-451c4e4abada.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can again make use of this in a script to verify that enough cores are available
    before running a CPU-intensive task. To test this from the command line, we can
    use the following code, which we execute on a PC with just a single core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We only run `bash` at the start to ensure that we are not logged out of the
    system with the `exit` command. If this was in a script, this would not be required,
    as we would exit the script and not our shell session.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running this on the Model B that has a single core, we can see the results
    of the script and also the indication that we do not have the required number
    of cores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66ea3316-be5c-4656-a61b-ac09d22bfb89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you had a requirement to run this check in more than one script, then you
    could create a function in a shared script and source the script holding the shared
    functions within the script that needs to be checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If a parameter is passed to the function, then it is used as the required number
    of cores; otherwise, we set the value to `2` as the default. If we define this
    as a function in the shell on the Model B PC and display the details with the
    `type` command, we should see this as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72902c0e-93bd-4831-b49e-449be6dab03a.png)'
  prefs: []
  type: TYPE_IMG
- en: If we run this on a single-core system and specify the requirement of just a
    single core, we will see that there is no output when we meet the requirement.
    If we do not specify the requirement, then it will default to `2` cores and we
    will fail to meet the requirement and we will exit the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the output of the function when run with the argument of `1`, and
    then without arguments, in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c5a8da0-78fa-48dc-95d7-0344f1d7d994.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see how useful even the basics of `grep` can be within the scripts and
    how we can use what we have learned to start creating usable modules to add to
    our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing CSV files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now look at creating a script to parse or format a CSV file. The formatting
    of the file will add new lines, tabs, and color to the output, so that it is more
    readable. We can then use `grep` to display single items from the CSV file. The
    practical application here is a catalog system based on the CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: The CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CSV file, or list of comma-separated values, will come from the file named
    `tools` that we have in a current directory. This is a catalog of products that
    we sell. The file content is shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a simple demonstration, so we don''t expect too much data, but
    each item in the catalog consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Units in stock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see that we have a drill that costs $99 and we have five units in stock.
    If we list the file with `cat`, it is not very friendly; however, we can write
    a script to display the data in a more appealing way. We can create a new script
    called `$HOME/bin/parsecsv.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s work through this file and look at the pertinent elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Element** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `OLDIFS="$IFS"` | The `IFS` variable stores the file separator and this is
    normally a white space character. We can store the old `IFS` so that we can restore
    it later at the end of the script, ensuring that we return the same environment
    once the script is complete, no matter how the script is run. |'
  prefs: []
  type: TYPE_TB
- en: '| `IFS=","` | We set the separator to a comma to match what we need with a
    CSV file. |'
  prefs: []
  type: TYPE_TB
- en: '| `while read product price quantity` | We enter a `while` loop to populate
    three variables that we need: `product`, `price`, and `quantity`. The `while`
    loop will read the input file, line by line, and populate each of the variables.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `echo ...` | The `echo` command displays the product name in blue with double
    underscores underneath. The other variables are printed on new lines and tabbed
    in. |'
  prefs: []
  type: TYPE_TB
- en: '| `done <"$1"` | This is where we read the input file, which we pass as an
    argument to the script. |'
  prefs: []
  type: TYPE_TB
- en: 'The script is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73d3bb8d-86ef-4d5e-a388-f6d53837cf3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can execute the script with the `tools` catalog file located in the current
    directory using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To look at how this will display, we can view the partial output in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6483bdcd-d888-4054-99ff-46c6329beaac.png)'
  prefs: []
  type: TYPE_IMG
- en: We are now starting to get the idea that we have a lot of power at the command
    line to format files in a more readable way and a plain text file does not need
    to be plain.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating catalog entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we need to search for one entry, then we need more than just one line. The
    entry is in three lines. So, if we search for the hammer, we need to go to the
    hammer line and the two lines that follow. We do this by using the `-A` option
    to `grep`, which is short for after. We need to display the matching line and
    two lines after. This will be expressed by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/138263c8-066a-464d-8227-be5b83fab47a.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the basics of sed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having built a little foundation, we can now start to look at some of the operations
    of `sed`. The commands will be supplied with most Linux systems and are core commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will dive directly into some simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `p` operator will print the matched pattern. In this case, we have not
    specified a pattern so we will match everything. Printing the matched lines without
    suppressing `STDOUT` will duplicate lines. The result of this operation is to
    print all the lines in the `passwd` file twice. To print the modified lines only,
    we use the `-n` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Brilliant!! We have just reinvented the `cat` command. We can now specifically
    work with just a range of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have reinvented the `head` command, but we can also specify the range
    in a regex pattern to recreate the `grep` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/080ac37c-aaf2-4c0c-8ea4-e43815d5219c.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the caret character (`^`) means the beginning of the line, which means
    the line must start with the word `root`. Don't worry; we will explain all these
    regex characters in a separate chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The substitute command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the `p` command for printing the pattern space. The `p` is actually
    a flag for the `substitute` command `s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `substitute` command is written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three common flags used with the `substitute` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`p`: Print the original content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: Global replacement for all occurrences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: Filename: send results to a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now look at the `substitute` command or `s`. With this command, we can
    replace one string with another. Again, by default, we send the output to the
    `STDOUT` and do not edit the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the default shell of the user `pi`, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue the earlier instance using the `p` command to print the matched
    pattern and use the `-n` option to suppress `STDOUT`. We search for lines beginning
    with `pi`. This represents the username. We then issue the `s` command to substitute
    text in those matched lines. This takes two arguments: the first is the text to
    search for and the second represents the text used to replace the original. In
    this case, we look for `bash` and replace it with `sh`. This is simple and does
    work but it may not be reliable in the long term. We can see the output in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c01033a-453d-4ca3-af9f-ea35cf25eb02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We must emphasize that, currently, we are not editing the file and are just
    displaying it to the screen. The original `passwd` file remains untouched and
    we can run this as a standard user. I mentioned in the previous example that the
    search may be less than reliable as the string we are searching for is `bash`.
    This is very short and perhaps it can be included elsewhere on a matched line.
    Potentially, someone''s last name may be `Tabash`, which includes the string `bash`.
    We can extend the search to look for `/bin/bash` and replace it with `/bin/sh`.
    However, this introduces another problem: the default delimiter is the forward
    slash, so we will have to escape each forward slash we use in the search and replace
    strings, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an option but it is not a tidy option. A better solution is to know
    that the first delimiter we use defines the delimiters. In other words, you can
    use any character as a delimiter. Using the `@` symbol may be a good idea in this
    scenario, as it does not appear in either the search or the replace string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a more reliable search and a readable command line to work with,
    which is always a good thing. We replace just the first occurrence on each line
    of `/bin/bash` with `/bin/sh`. If we need to replace more than the first occurrence,
    we add the `g` command, for global, at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In our case, it is not required but it is good to know.
  prefs: []
  type: TYPE_NORMAL
- en: Global replacement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we have the following sample file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to use `sed` against this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `sed` to replace the word `sed` with `Linux sed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d8e338d-a79f-4c4c-a95f-9f82c9257a9e.png)'
  prefs: []
  type: TYPE_IMG
- en: If you check the result carefully, you will notice that `sed` modified the first
    word of each line only.
  prefs: []
  type: TYPE_NORMAL
- en: This may not be what you want if you want to replace all occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: Here comes the `g` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use it and see the results again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e0182d41-cc6b-406e-a384-cd2e63b5891c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now all occurrences are modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can port these modifications to a file using the `w` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can limit the number of occurrences from the same line, so we can
    modify the first two occurrences from each line only like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So, if there is a third occurrence, it will be neglected.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting substitution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how the `g` flag modifies all occurrences in the same line and this goes
    for the entire file lines.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to limit our edits to a specific line? Or a specific line range?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify the ending line or the line range like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will only modify the second line of the file. The following
    command will modify only the third to the fifth lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will modify from the second line to the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Editing the file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `w` flag, we can write our edits to a file, but what if we want to
    edit the file itself? We can use the `-i` option. We will need permissions to
    work with the file but we can make a copy of the file to work with, so we don't
    harm any system file or require additional access.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can copy the `passwd` file locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We finish with the `cd` command to ensure that we are working in the `home`
    directory and the local `passwd` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-i` option is used to run an in-place update. We will not need the `-n`
    option or the `p` command when editing the file. As such, the command is as simple
    as the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There will be no output to the command but the file will now reflect the change.
    The following screenshot shows the command usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc381b57-41d5-43fe-9dec-3df1719d5d99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We should make a backup before we make the change by appending a string directly
    after the `-i` option and without any spaces. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to see this, we can reverse the search and replace strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will set the local `passwd` file to be the same as it was before and we
    will have a `passwd.bak` with the previous set of changes. This keeps us safe
    with a rollback option if we need it.
  prefs: []
  type: TYPE_NORMAL
- en: Other sed commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sed` offers a lot of commands that can be used to insert, change, delete,
    and transform text with ease. Let''s see some examples of how to use these commands
    with `sed`.'
  prefs: []
  type: TYPE_NORMAL
- en: The delete command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `delete` command `d` to delete lines or a range of lines from
    your stream. The following command will delete the third line from the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will delete the third to the fifth line from the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will delete from the fourth line to the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the deletion happens only to the stream, not the actual file. So
    if you want to delete from the actual file, you can use the `-i` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The insert and append commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The insert, `i`, and append, `a`, commands work the same way with just a slight
    difference.
  prefs: []
  type: TYPE_NORMAL
- en: The `insert` command inserts the specified text before the specified line or
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The `append` command inserts the specified text after the specified line or
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our sample 02 file will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert a line, you need to use the insert command `i` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To append a line, you need to use the append command `a` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the result and check the inserted line position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea97ee51-6d18-42d4-b795-9dded617d565.png)'
  prefs: []
  type: TYPE_IMG
- en: The change command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to substitute occurrences using the `substitute` command `s`. So
    what is the `change` command and how is it different?
  prefs: []
  type: TYPE_NORMAL
- en: The `change` command, `c`, is used for changing the entire line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change a line, you can use the `change` command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/303cee92-4e7c-4a95-8036-978c2df042db.png)'
  prefs: []
  type: TYPE_IMG
- en: We replaced the second line with a new line.
  prefs: []
  type: TYPE_NORMAL
- en: The transform command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `transform` command is used to replace any letter or a number with another,
    for example, capitalizing letters or transforming numbers into different numbers.
  prefs: []
  type: TYPE_NORMAL
- en: It works like the `tr` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8ef01a7a-a694-4d1b-b3ff-f1cc6342f8a1.png)'
  prefs: []
  type: TYPE_IMG
- en: The transformation applies to the entire stream and can't be limited.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple sed commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all the previous examples, we only applied one `sed` command to our stream.
    What about running multiple `sed` commands?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do that by using the `-e` option and separating the commands with a
    semicolon like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b52e69e1-6b89-44bb-a835-9783f777a7b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can enter every command on a separate line and you will achieve the
    same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `sed` command offers great flexibility; if you use it well, you will gain
    a lot of power.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another great chapter that you have firmly under your belt and I hope it was
    really useful to you. Although we wanted to concentrate on using `sed`, we started
    with how powerful `grep` can be, both inside and outside our scripts. Although
    we have only just touched on `sed`, we will start extending this in the next chapter,
    where we will expand upon what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we learned how to substitute text and how to limit and globalize the substitution
    and how to save the editing stream using `-i`.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to insert, append, delete, and transform text using `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to run multiple `sed` commands using the `-e` option.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to automate Apache Virtual Hosts, how
    to create new virtual hosts automatically, and other cool stuff. The workhorse
    of all these operations will be `sed` and `sed` scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you have a file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And suppose you use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How many lines will be substituted?
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have the same file that was used in the previous question and you
    use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How many lines will be deleted from the file?
  prefs: []
  type: TYPE_NORMAL
- en: What is the location of the inserted line in the following example?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you have the same previous sample file and you run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How many lines will be saved to the output file?
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please see the following for further reading relating to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.gnu.org/software/sed/manual/sed.html](https://www.gnu.org/software/sed/manual/sed.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://linux.die.net/man/1/sed](https://linux.die.net/man/1/sed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
