- en: Introducing the Stream Editor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍流编辑器
- en: In the previous chapter, we saw that we could make use of `sed` to edit files
    from within our scripts. The `sed` command is the **stream editor** (**sed**)
    and opens the file line by line to search or edit the file content. Historically,
    this goes way back to Unix, where systems may not have had enough RAM to open
    very large files. Using `sed` was absolutely required to carry out edits. Even
    today, we will use `sed` to make changes and display data from files with hundreds
    and thousands of entries. It is simpler and easier and more reliable than a human
    trying to do the same thing. Most importantly, as we have seen, we can use `sed`
    in scripts to edit the files automatically; no human interaction is required.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到可以利用`sed`在脚本中编辑文件。`sed`命令是**流编辑器**（**sed**），它逐行打开文件来搜索或编辑文件内容。历史上，这一命令源于Unix系统，那时系统可能没有足够的内存来打开非常大的文件。使用`sed`进行编辑是必须的。即使在今天，我们仍然会使用`sed`来修改和显示包含数百或数千条条目的文件数据。它比人工尝试做同样的事更简单、更容易、更可靠。最重要的是，正如我们所见，我们可以在脚本中使用`sed`来自动编辑文件，不需要人工干预。
- en: We will start by looking at `grep` and searching the files for text. The `re`
    in the `grep` command is short for **regular expression**. Even though we are
    not looking at scripting in this chapter, we will be covering some very important
    tools that we can use with scripts. In the next chapter, we will see the practical
    implementation of `sed` in scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看`grep`并在文件中搜索文本开始。`grep`命令中的`re`是**正则表达式**（regular expression）的缩写。尽管我们在本章中不涉及脚本编写，但我们将介绍一些非常重要的工具，这些工具可以与脚本一起使用。在下一章中，我们将看到`sed`在脚本中的实际应用。
- en: 'For the moment though, we have enough to deal with and we will cover the following
    topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但此刻我们有足够的内容可以处理，我们将在本章中讨论以下主题：
- en: Using `grep` to display text
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`grep`显示文本
- en: Understanding the basics of `sed`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`sed`的基础知识
- en: Other `sed` commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他`sed`命令
- en: Multiple `sed` commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个`sed`命令
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter can be downloaded here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在这里下载：
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter08)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter08)'
- en: Using grep to display text
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用grep显示文本
- en: We will be beginning this journey by looking at the `grep` command. This will
    enable us to grasp some simple concepts of searching through the text before moving
    onto more complex regular expressions and editing files with `sed`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习`grep`命令开始。这将帮助我们掌握一些基本的文本搜索概念，然后再深入学习更复杂的正则表达式和使用`sed`编辑文件。
- en: '**Global regular expression print** (**grep**), or what we more commonly call
    the `grep` command, is a command-line tool used to search globally (across all
    the lines in a file) and print the result to `STDOUT`. The search string is a
    regular expression.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局正则表达式打印**（**grep**），或者我们更常称之为`grep`命令，是一个命令行工具，用于在全局范围内（跨文件中的所有行）搜索并将结果打印到`STDOUT`。搜索字符串是一个正则表达式。'
- en: The `grep` command is such a common tool that it has many simple examples and
    numerous occasions where we can use it each day. In the following sections, we
    have included some simple and useful examples with explanations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`命令是如此常用的工具，它有许多简单的示例和我们每天可以使用它的多种场合。在接下来的部分，我们包含了一些简单且实用的示例，并附有解释。'
- en: Displaying received data on an interface
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示接口上接收到的数据
- en: In this example, we will print just the received data from the `eth0` interface.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将仅打印从`eth0`接口接收到的数据。
- en: This is the interface that is my primary network connection. If you are uncertain
    of your interface name, you can use the `ifconfig -a` command to display all the
    interfaces and choose the correct interface name on your system. If `ifconfig` is
    not found, try typing the full path, `/sbin/ifconfig`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的主要网络连接接口。如果你不确定你的接口名称，可以使用`ifconfig -a`命令来显示所有接口，并选择系统中正确的接口名称。如果找不到`ifconfig`，尝试输入完整路径`/sbin/ifconfig`。
- en: 'Using just the `ifconfig eth0` command, a heap of data can be printed to the
    screen. To show just the packets received, we can isolate the lines that contain
    `RX packets` (`RX` for received). This is where `grep` comes in:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用`ifconfig eth0`命令，就可以将大量数据打印到屏幕上。为了只显示接收到的包，我们可以隔离包含`RX packets`（`RX`代表接收）的行。这就是`grep`派上用场的地方：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using the pipe or vertical bars, we can take the output of the `ifconfig` command
    and send it to the input of the `grep` command. In this case, `grep` is searching
    for a very simple string, `RX packets`. The search string is case sensitive, so
    we need to get this right or use the `-i` option with `grep` to run the search
    as case insensitive, as shown in the following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道符或竖线，我们可以将`ifconfig`命令的输出发送到`grep`命令的输入。在这个例子中，`grep`正在搜索一个非常简单的字符串`RX packets`。搜索字符串是区分大小写的，因此我们需要确保正确，或者使用`grep`的`-i`选项使搜索不区分大小写，如下例所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A case-insensitive search is especially useful when searching for options in
    a configuration file, which often have mixed cases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不区分大小写的搜索在查找配置文件中的选项时尤其有用，因为这些选项通常包含大小写混合的情况。
- en: 'We can see the result of the initial command in the following screenshot, confirming
    that we have been able to isolate just the single line of output, as shown:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到初始命令的结果，确认我们已经成功提取了仅有的单行输出，如下所示：
- en: '![](img/8438d3b5-445f-4d50-8a68-889898da93e2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8438d3b5-445f-4d50-8a68-889898da93e2.png)'
- en: Displaying user account data
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示用户帐户数据
- en: 'The local user account database in Linux is the `/etc/passwd` file and this
    is readable by all user accounts. If we want to search for the line that contains
    our own data, we can use either our own login name in the search or use parameter
    expansion and the `$USER` variable. We can see this in the following command example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的本地用户帐户数据库是`/etc/passwd`文件，所有用户帐户都可以读取此文件。如果我们想查找包含我们自己数据的那一行，我们可以在搜索中使用我们自己的登录名，或者使用参数扩展和`$USER`变量。我们可以在下面的命令示例中看到这一点：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the input to `grep` comes from the `/etc/passwd` file and we
    search for the value of the `$USER` variable. Again, in this case, it is a simple
    text, but it is still the regular expression, just without any operators.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`grep`的输入来自`/etc/passwd`文件，我们搜索的是`$USER`变量的值。同样，在这个例子中，它是一个简单的文本，但它依然是正则表达式，只是没有任何操作符。
- en: 'For completeness, we include the output in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们在下面的截图中包含了输出：
- en: '![](img/5ff2f0ae-977a-46df-a95f-c006907cbdb3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ff2f0ae-977a-46df-a95f-c006907cbdb3.png)'
- en: 'We can extend this a little using this type of query as a condition within
    a script. We can use this to check whether a user account exists before trying
    to create a new account. To keep the script as simple as possible and to ensure
    that administrative rights are not required, creating the account will display
    just the prompt and conditional test in the following command-line example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这种类型的查询作为条件，在脚本中稍微扩展它。我们可以用它来检查一个用户帐户是否存在，然后再尝试创建一个新帐户。为了保持脚本尽可能简单，并确保不需要管理员权限，创建帐户的命令行示例将仅显示提示符和条件测试：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `grep` search now makes use of the `$REPLY` variable populated by `read`.
    If I enter the name `pi`, a message will be displayed and we will exit because
    my user account is also called `pi`. There is no need to display the result from
    `grep`; we are just looking for a return code that is either `true` or `false`.
    To ensure that we do not see any unnecessary output if the user is in the file,
    we redirect the output from `grep` to the special device file `/dev/null`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`搜索现在使用了由`read`填充的`$REPLY`变量。如果我输入`pi`，系统将显示一条消息，并且我们将退出，因为我的用户帐户也叫`pi`。无需显示`grep`的结果；我们只需要寻找一个返回值，是真还是假。为了确保我们不会看到任何不必要的输出，如果用户在文件中，我们将`grep`的输出重定向到特殊设备文件`/dev/null`。'
- en: 'If you want to run this from the command line, you should start a new bash
    shell first. You can do this by simply typing `bash`. In this way, when the `exit`
    command runs, it will not log you out but close the newly opened shell. We can
    see this happening and the results when specifying an existing user in the following
    screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从命令行运行此操作，首先应该启动一个新的bash shell。你可以通过简单地输入`bash`来做到这一点。这样，当`exit`命令执行时，它不会让你登出，而是关闭新打开的shell。我们可以在以下截图中看到这一过程以及指定现有用户时的结果：
- en: '![](img/3c29fad8-fd65-4e0c-a125-d5f9ba5a5666.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c29fad8-fd65-4e0c-a125-d5f9ba5a5666.png)'
- en: Listing the number of CPUs in a system
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出系统中的CPU数量
- en: 'Another really useful feature is that `grep` can count the matching lines and
    not display them. We can use this to count the number of CPUs or CPU cores we
    have on a system. Each core or CPU is listed with a name in the `/proc/cpuinfo`
    file. We can then search for the text `name` and count the output; the `-c` option
    used is shown in the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能是，`grep`可以计算匹配的行数，而不显示它们。我们可以用它来计算系统上有多少个CPU或CPU核心。每个核心或CPU都会在`/proc/cpuinfo`文件中列出一个名称。然后，我们可以搜索`name`文本并计算输出；在下面的示例中展示了使用的`-c`选项：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'My CPU has four cores, as shown in the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我的CPU有四个核心，如以下输出所示：
- en: '![](img/f673d39b-5ba9-4ca7-b698-f8db3cc7cf4f.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f673d39b-5ba9-4ca7-b698-f8db3cc7cf4f.png)'
- en: 'If we use the same code on another PC Model B that has a single core, we will
    see the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在另一个只有单核心的PC Model B上使用相同的代码，我们将看到以下输出：
- en: '![](img/a3f6e13c-3be6-4c29-98d8-451c4e4abada.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f6e13c-3be6-4c29-98d8-451c4e4abada.png)'
- en: 'We can again make use of this in a script to verify that enough cores are available
    before running a CPU-intensive task. To test this from the command line, we can
    use the following code, which we execute on a PC with just a single core:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次在脚本中利用这个方法，确保在运行CPU密集型任务之前有足够的核心可用。要在命令行中测试此功能，我们可以使用以下代码，在只有一个核心的PC上执行：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We only run `bash` at the start to ensure that we are not logged out of the
    system with the `exit` command. If this was in a script, this would not be required,
    as we would exit the script and not our shell session.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开始时只运行`bash`，以确保我们不会因为`exit`命令而退出系统。如果这是一个脚本中的操作，那么就不需要此步骤，因为我们会退出脚本，而不是退出shell会话。
- en: 'By running this on the Model B that has a single core, we can see the results
    of the script and also the indication that we do not have the required number
    of cores:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Model B（单核心）的系统上运行此脚本时，我们可以看到脚本的结果，以及一个指示我们没有所需核心数的提示：
- en: '![](img/66ea3316-be5c-4656-a61b-ac09d22bfb89.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66ea3316-be5c-4656-a61b-ac09d22bfb89.png)'
- en: 'If you had a requirement to run this check in more than one script, then you
    could create a function in a shared script and source the script holding the shared
    functions within the script that needs to be checked:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在多个脚本中运行此检查，你可以在共享脚本中创建一个函数，并在需要检查的脚本中源化包含共享函数的脚本：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a parameter is passed to the function, then it is used as the required number
    of cores; otherwise, we set the value to `2` as the default. If we define this
    as a function in the shell on the Model B PC and display the details with the
    `type` command, we should see this as shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数传递给函数，则将其作为所需的核心数；否则，我们将默认值设置为`2`。如果我们在Model B PC的shell中定义这个函数，并使用`type`命令显示其详细信息，我们应该能看到如下截图所示：
- en: '![](img/72902c0e-93bd-4831-b49e-449be6dab03a.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72902c0e-93bd-4831-b49e-449be6dab03a.png)'
- en: If we run this on a single-core system and specify the requirement of just a
    single core, we will see that there is no output when we meet the requirement.
    If we do not specify the requirement, then it will default to `2` cores and we
    will fail to meet the requirement and we will exit the shell.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在单核心系统上运行此脚本，并指定只需要一个核心，我们会看到在满足要求时没有输出。如果我们没有指定要求，它将默认为`2`个核心，并且我们将无法满足要求，最后会退出shell。
- en: 'We can see the output of the function when run with the argument of `1`, and
    then without arguments, in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当传递参数`1`运行函数时的输出，以及没有传递参数时的输出，见下图：
- en: '![](img/2c5a8da0-78fa-48dc-95d7-0344f1d7d994.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c5a8da0-78fa-48dc-95d7-0344f1d7d994.png)'
- en: We can see how useful even the basics of `grep` can be within the scripts and
    how we can use what we have learned to start creating usable modules to add to
    our scripts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，即使是`grep`的基本用法在脚本中也非常有用，并且我们如何利用学到的内容开始创建可用的模块来添加到我们的脚本中。
- en: Parsing CSV files
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析CSV文件
- en: We will now look at creating a script to parse or format a CSV file. The formatting
    of the file will add new lines, tabs, and color to the output, so that it is more
    readable. We can then use `grep` to display single items from the CSV file. The
    practical application here is a catalog system based on the CSV files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何创建一个脚本来解析或格式化CSV文件。文件的格式化将会在输出中添加新行、制表符和颜色，使其更加易读。然后，我们可以使用`grep`来显示CSV文件中的单个条目。这里的实际应用是基于CSV文件的目录系统。
- en: The CSV file
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV文件
- en: 'The CSV file, or list of comma-separated values, will come from the file named
    `tools` that we have in a current directory. This is a catalog of products that
    we sell. The file content is shown in the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 文件，或者说逗号分隔值列表，将来自当前目录中的名为 `tools` 的文件。这个文件是我们销售的产品目录。文件内容如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is just a simple demonstration, so we don''t expect too much data, but
    each item in the catalog consists of the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的演示，因此我们不期望有太多数据，但目录中的每个项目包括以下内容：
- en: Name
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Price
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格
- en: Units in stock
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存单位
- en: 'We can see that we have a drill that costs $99 and we have five units in stock.
    If we list the file with `cat`, it is not very friendly; however, we can write
    a script to display the data in a more appealing way. We can create a new script
    called `$HOME/bin/parsecsv.sh`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有一台售价 99 美元的钻孔机，并且库存有五个。如果我们用 `cat` 列出文件，显示效果并不友好；然而，我们可以编写一个脚本，以更吸引人的方式显示数据。我们可以创建一个名为
    `$HOME/bin/parsecsv.sh` 的新脚本：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s work through this file and look at the pertinent elements:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起来分析一下这个文件，看看其中的相关元素：
- en: '| **Element** | **Meaning** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **元素** | **含义** |'
- en: '| `OLDIFS="$IFS"` | The `IFS` variable stores the file separator and this is
    normally a white space character. We can store the old `IFS` so that we can restore
    it later at the end of the script, ensuring that we return the same environment
    once the script is complete, no matter how the script is run. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `OLDIFS="$IFS"` | `IFS` 变量存储文件分隔符，通常是空格字符。我们可以保存旧的 `IFS`，以便在脚本结束时恢复它，确保脚本完成后环境保持不变，无论脚本如何运行。
    |'
- en: '| `IFS=","` | We set the separator to a comma to match what we need with a
    CSV file. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `IFS=","` | 我们将分隔符设置为逗号，以便与 CSV 文件匹配。 |'
- en: '| `while read product price quantity` | We enter a `while` loop to populate
    three variables that we need: `product`, `price`, and `quantity`. The `while`
    loop will read the input file, line by line, and populate each of the variables.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `while read product price quantity` | 我们进入一个 `while` 循环，用来填充我们需要的三个变量：`product`、`price`
    和 `quantity`。`while` 循环会逐行读取输入文件，并填充每个变量。 |'
- en: '| `echo ...` | The `echo` command displays the product name in blue with double
    underscores underneath. The other variables are printed on new lines and tabbed
    in. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `echo ...` | `echo` 命令将产品名称显示为蓝色，并在下方加上双下划线。其他变量会打印在新行上，并缩进显示。 |'
- en: '| `done <"$1"` | This is where we read the input file, which we pass as an
    argument to the script. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `done <"$1"` | 这里我们读取输入文件，该文件作为参数传递给脚本。 |'
- en: 'The script is shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本如下所示：
- en: '![](img/73d3bb8d-86ef-4d5e-a388-f6d53837cf3e.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73d3bb8d-86ef-4d5e-a388-f6d53837cf3e.png)'
- en: 'We can execute the script with the `tools` catalog file located in the current
    directory using the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令执行脚本，使用当前目录中的 `tools` 目录文件：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To look at how this will display, we can view the partial output in the following
    screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看该文件的显示效果，我们可以查看以下截图中的部分输出：
- en: '![](img/6483bdcd-d888-4054-99ff-46c6329beaac.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6483bdcd-d888-4054-99ff-46c6329beaac.png)'
- en: We are now starting to get the idea that we have a lot of power at the command
    line to format files in a more readable way and a plain text file does not need
    to be plain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始意识到，在命令行中我们有很大的能力来格式化文件，使其更易读，纯文本文件也不一定非得是单纯的文本。
- en: Isolating catalog entries
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离目录条目
- en: 'If we need to search for one entry, then we need more than just one line. The
    entry is in three lines. So, if we search for the hammer, we need to go to the
    hammer line and the two lines that follow. We do this by using the `-A` option
    to `grep`, which is short for after. We need to display the matching line and
    two lines after. This will be expressed by the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要搜索某个条目，那么我们需要的不仅仅是单行内容。这个条目有三行。因此，如果我们要查找锤子，我们需要去到锤子的那一行以及接下来的两行。我们可以使用
    `grep` 的 `-A` 选项来实现这一点，`-A` 是 "after" 的缩写。我们需要显示匹配的行以及后面两行。这可以通过以下代码实现：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is displayed in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了这一点：
- en: '![](img/138263c8-066a-464d-8227-be5b83fab47a.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/138263c8-066a-464d-8227-be5b83fab47a.png)'
- en: Understanding the basics of sed
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `sed` 的基础
- en: Having built a little foundation, we can now start to look at some of the operations
    of `sed`. The commands will be supplied with most Linux systems and are core commands.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了一些基础之后，我们现在可以开始查看一些 `sed` 的操作。大多数 Linux 系统都会提供这些命令，并且它们是核心命令。
- en: 'We will dive directly into some simple examples:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接深入一些简单的例子：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `p` operator will print the matched pattern. In this case, we have not
    specified a pattern so we will match everything. Printing the matched lines without
    suppressing `STDOUT` will duplicate lines. The result of this operation is to
    print all the lines in the `passwd` file twice. To print the modified lines only,
    we use the `-n` option:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`p`操作符将打印匹配的模式。在这种情况下，我们没有指定模式，因此将匹配所有内容。在不抑制`STDOUT`的情况下打印匹配的行将会重复行。此操作的结果是将`passwd`文件中的所有行打印两次。为了仅打印修改后的行，我们使用`-n`选项：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Brilliant!! We have just reinvented the `cat` command. We can now specifically
    work with just a range of lines:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！！我们刚刚重新发明了`cat`命令。现在我们可以专门处理一系列行：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we have reinvented the `head` command, but we can also specify the range
    in a regex pattern to recreate the `grep` command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重新发明了`head`命令，但我们也可以在正则表达式模式中指定范围来重现`grep`命令：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see this demonstrated in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到这个演示：
- en: '![](img/080ac37c-aaf2-4c0c-8ea4-e43815d5219c.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/080ac37c-aaf2-4c0c-8ea4-e43815d5219c.png)'
- en: Note that the caret character (`^`) means the beginning of the line, which means
    the line must start with the word `root`. Don't worry; we will explain all these
    regex characters in a separate chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，插入符号（`^`）表示行的开头，这意味着行必须以单词`root`开头。别担心，我们将在单独的章节中解释所有这些正则表达式字符。
- en: The substitute command
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换命令
- en: We have seen the `p` command for printing the pattern space. The `p` is actually
    a flag for the `substitute` command `s`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了用于打印模式空间的`p`命令。实际上，`p`是`substitute`命令`s`的一个标志。
- en: 'The `substitute` command is written like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`substitute`命令的写法如下：'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are three common flags used with the `substitute` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个常用的标志与`substitute`命令一起使用：
- en: '`p`: Print the original content'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`: 打印原始内容'
- en: '`g`: Global replacement for all occurrences'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`: 对所有出现进行全局替换'
- en: '`w`: Filename: send results to a file'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`: 文件名：将结果发送到文件'
- en: We will now look at the `substitute` command or `s`. With this command, we can
    replace one string with another. Again, by default, we send the output to the
    `STDOUT` and do not edit the file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下`substitute`命令或`s`。使用这个命令，我们可以将一个字符串替换为另一个字符串。同样，默认情况下，我们将输出发送到`STDOUT`而不编辑文件。
- en: 'To replace the default shell of the user `pi`, we can use the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要更换用户`pi`的默认 shell，可以使用以下命令：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We continue the earlier instance using the `p` command to print the matched
    pattern and use the `-n` option to suppress `STDOUT`. We search for lines beginning
    with `pi`. This represents the username. We then issue the `s` command to substitute
    text in those matched lines. This takes two arguments: the first is the text to
    search for and the second represents the text used to replace the original. In
    this case, we look for `bash` and replace it with `sh`. This is simple and does
    work but it may not be reliable in the long term. We can see the output in the
    following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用`p`命令打印匹配的模式，并使用`-n`选项来抑制`STDOUT`。我们搜索以`pi`开头的行，这代表用户名。然后我们使用`s`命令来替换这些匹配的行中的文本。这需要两个参数：第一个是要搜索的文本，第二个表示用来替换原始文本的文本。在这种情况下，我们查找`bash`并将其替换为`sh`。这很简单并且有效，但长期来看可能不是很可靠。我们可以在以下截图中看到输出：
- en: '![](img/5c01033a-453d-4ca3-af9f-ea35cf25eb02.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c01033a-453d-4ca3-af9f-ea35cf25eb02.png)'
- en: 'We must emphasize that, currently, we are not editing the file and are just
    displaying it to the screen. The original `passwd` file remains untouched and
    we can run this as a standard user. I mentioned in the previous example that the
    search may be less than reliable as the string we are searching for is `bash`.
    This is very short and perhaps it can be included elsewhere on a matched line.
    Potentially, someone''s last name may be `Tabash`, which includes the string `bash`.
    We can extend the search to look for `/bin/bash` and replace it with `/bin/sh`.
    However, this introduces another problem: the default delimiter is the forward
    slash, so we will have to escape each forward slash we use in the search and replace
    strings, which is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须强调，目前我们并没有编辑文件，只是将其显示在屏幕上。原始的`passwd`文件保持不变，我们可以以标准用户身份运行此命令。在前面的示例中，我提到搜索可能不够可靠，因为我们搜索的字符串是`bash`。这个字符串很短，也许在其他匹配的行中也可以找到它。可能某人的姓氏可能是`Tabash`，其中包含字符串`bash`。我们可以扩展搜索范围，查找`/bin/bash`并将其替换为`/bin/sh`。但是，这引入了另一个问题：默认的分隔符是斜杠，所以我们必须转义每个用于搜索和替换字符串中的斜杠，具体如下：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is an option but it is not a tidy option. A better solution is to know
    that the first delimiter we use defines the delimiters. In other words, you can
    use any character as a delimiter. Using the `@` symbol may be a good idea in this
    scenario, as it does not appear in either the search or the replace string:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个选项，但它并不整洁。更好的解决方案是了解我们使用的第一个定界符定义了定界符。换句话说，您可以使用任何字符作为定界符。在这种情况下，使用`@`符号可能是一个好主意，因为它既不出现在搜索字符串中，也不出现在替换字符串中：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We now have a more reliable search and a readable command line to work with,
    which is always a good thing. We replace just the first occurrence on each line
    of `/bin/bash` with `/bin/sh`. If we need to replace more than the first occurrence,
    we add the `g` command, for global, at the end:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了更可靠的搜索和更易读的命令行，这是一个好事。我们只替换了每行的第一个`/bin/bash`为`/bin/sh`。如果需要替换第一个以上的出现，我们在末尾添加`g`命令，表示全局替换：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In our case, it is not required but it is good to know.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，这是不必要的，但知道这一点是很有帮助的。
- en: Global replacement
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局替换
- en: 'Let''s assume that we have the following sample file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下示例文件：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s try to use `sed` against this file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在这个文件上使用`sed`：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we use `sed` to replace the word `sed` with `Linux sed`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`sed`将单词`sed`替换为`Linux sed`：
- en: '![](img/4d8e338d-a79f-4c4c-a95f-9f82c9257a9e.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d8e338d-a79f-4c4c-a95f-9f82c9257a9e.png)'
- en: If you check the result carefully, you will notice that `sed` modified the first
    word of each line only.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细检查结果，您会注意到`sed`只修改了每行的第一个词。
- en: This may not be what you want if you want to replace all occurrences.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想替换所有出现，这可能不是您想要的效果。
- en: Here comes the `g` flag.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`g`标志。
- en: 'Let''s use it and see the results again:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用它并查看结果：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/e0182d41-cc6b-406e-a384-cd2e63b5891c.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0182d41-cc6b-406e-a384-cd2e63b5891c.png)'
- en: Now all occurrences are modified.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的出现都已被修改。
- en: 'You can port these modifications to a file using the `w` flag:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`w`标志将这些修改应用到文件中：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, you can limit the number of occurrences from the same line, so we can
    modify the first two occurrences from each line only like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以限制同一行中出现的次数，因此我们可以仅修改每行的前两个出现，如下所示：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, if there is a third occurrence, it will be neglected.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果有第三次出现，它将被忽略。
- en: Limiting substitution
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制替换
- en: We saw how the `g` flag modifies all occurrences in the same line and this goes
    for the entire file lines.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`g`标志如何修改同一行中的所有出现，这适用于整个文件的所有行。
- en: What if we want to limit our edits to a specific line? Or a specific line range?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想限制编辑到特定行？或者特定的行范围呢？
- en: 'We can specify the ending line or the line range like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样指定结束行或行范围：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding command will only modify the second line of the file. The following
    command will modify only the third to the fifth lines:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令只会修改文件的第二行。以下命令将仅修改第三行到第五行：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following command will modify from the second line to the end of the file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将从第二行修改到文件末尾：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Editing the file
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑文件
- en: Using the `w` flag, we can write our edits to a file, but what if we want to
    edit the file itself? We can use the `-i` option. We will need permissions to
    work with the file but we can make a copy of the file to work with, so we don't
    harm any system file or require additional access.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`w`标志，我们可以将编辑内容写入文件，但如果我们想直接编辑文件本身怎么办？我们可以使用`-i`选项。我们需要有权限操作该文件，但可以先复制文件来操作，这样我们就不会损害任何系统文件，也不需要额外的权限。
- en: 'We can copy the `passwd` file locally:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`passwd`文件复制到本地：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We finish with the `cd` command to ensure that we are working in the `home`
    directory and the local `passwd` file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`cd`命令来确保我们在`home`目录下工作，并且在本地`passwd`文件中操作。
- en: 'The `-i` option is used to run an in-place update. We will not need the `-n`
    option or the `p` command when editing the file. As such, the command is as simple
    as the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`选项用于执行就地更新。当编辑文件时，我们不需要`-n`选项或`p`命令。因此，命令变得像以下示例一样简单：'
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There will be no output to the command but the file will now reflect the change.
    The following screenshot shows the command usage:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令不会输出任何内容，但文件现在会反映出更改。以下截图展示了命令的使用：
- en: '![](img/dc381b57-41d5-43fe-9dec-3df1719d5d99.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc381b57-41d5-43fe-9dec-3df1719d5d99.png)'
- en: 'We should make a backup before we make the change by appending a string directly
    after the `-i` option and without any spaces. This is shown in the following example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更改之前，我们应该通过在`-i`选项后直接添加一个字符串（不留空格）来备份。这在以下示例中展示：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we want to see this, we can reverse the search and replace strings:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要查看这个，我们可以反转搜索并替换字符串：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will set the local `passwd` file to be the same as it was before and we
    will have a `passwd.bak` with the previous set of changes. This keeps us safe
    with a rollback option if we need it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使本地的 `passwd` 文件与之前相同，并且我们将有一个带有先前更改集的 `passwd.bak`。这样，如果需要，我们就有回滚选项。
- en: Other sed commands
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他 `sed` 命令
- en: '`sed` offers a lot of commands that can be used to insert, change, delete,
    and transform text with ease. Let''s see some examples of how to use these commands
    with `sed`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed` 提供了许多命令，可以轻松插入、更改、删除和转换文本。让我们看看如何使用这些命令与 `sed` 的一些示例。'
- en: The delete command
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除命令
- en: 'You can use the `delete` command `d` to delete lines or a range of lines from
    your stream. The following command will delete the third line from the stream:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `delete` 命令 `d` 从流中删除行或一系列行。以下命令将删除流中的第三行：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following command will delete the third to the fifth line from the stream:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将从流中删除第三到第五行：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This command will delete from the fourth line to the end of the file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将删除从第四行到文件末尾的内容：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that the deletion happens only to the stream, not the actual file. So
    if you want to delete from the actual file, you can use the `-i` option:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，删除仅发生在流中，而不是实际文件。因此，如果要从实际文件中删除，可以使用 `-i` 选项：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The insert and append commands
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入和追加命令
- en: The insert, `i`, and append, `a`, commands work the same way with just a slight
    difference.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`，`i` 和 `append`，`a` 命令以几乎相同的方式工作，只有轻微的差异。'
- en: The `insert` command inserts the specified text before the specified line or
    pattern.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 命令在指定行或模式前插入指定文本。'
- en: The `append` command inserts the specified text after the specified line or
    pattern.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 命令在指定行或模式后插入指定文本。'
- en: Let's see some examples.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个例子。
- en: 'Our sample 02 file will be like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例 02 文件将会是这样：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To insert a line, you need to use the insert command `i` like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入一行，您需要使用 `insert` 命令 `i` 如下：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To append a line, you need to use the append command `a` like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一行，您需要使用如下的 `append` 命令 `a`：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Look at the result and check the inserted line position:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 查看结果并检查插入行的位置：
- en: '![](img/ea97ee51-6d18-42d4-b795-9dded617d565.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea97ee51-6d18-42d4-b795-9dded617d565.png)'
- en: The change command
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改命令
- en: We saw how to substitute occurrences using the `substitute` command `s`. So
    what is the `change` command and how is it different?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到如何使用 `substitute` 命令 `s` 替换出现次数。那么 `change` 命令是什么，它又有什么不同？
- en: The `change` command, `c`, is used for changing the entire line.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`change` 命令，`c`，用于更改整行。'
- en: 'To change a line, you can use the `change` command like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改一行，您可以使用 `change` 命令如下：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](img/303cee92-4e7c-4a95-8036-978c2df042db.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/303cee92-4e7c-4a95-8036-978c2df042db.png)'
- en: We replaced the second line with a new line.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用新行替换了第二行。
- en: The transform command
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换命令
- en: The `transform` command is used to replace any letter or a number with another,
    for example, capitalizing letters or transforming numbers into different numbers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform` 命令用于将任何字母或数字替换为另一个，例如大写字母或将数字转换为不同的数字。'
- en: It works like the `tr` command.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理类似于 `tr` 命令。
- en: 'You can use it like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样使用它：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![](img/8ef01a7a-a694-4d1b-b3ff-f1cc6342f8a1.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ef01a7a-a694-4d1b-b3ff-f1cc6342f8a1.png)'
- en: The transformation applies to the entire stream and can't be limited.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 转换适用于整个流，不能限制。
- en: Multiple sed commands
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个 `sed` 命令
- en: In all the previous examples, we only applied one `sed` command to our stream.
    What about running multiple `sed` commands?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有先前的例子中，我们只对我们的流应用了一个 `sed` 命令。那么如何运行多个 `sed` 命令呢？
- en: 'You can do that by using the `-e` option and separating the commands with a
    semicolon like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `-e` 选项，并用分号分隔命令来做到这一点，如下所示：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](img/b52e69e1-6b89-44bb-a835-9783f777a7b7.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b52e69e1-6b89-44bb-a835-9783f777a7b7.png)'
- en: 'Also, you can enter every command on a separate line and you will achieve the
    same result:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以将每个命令输入到单独的行中，结果将相同：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `sed` command offers great flexibility; if you use it well, you will gain
    a lot of power.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed` 命令提供了很大的灵活性；如果使用得当，您将获得很多的权力。'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Another great chapter that you have firmly under your belt and I hope it was
    really useful to you. Although we wanted to concentrate on using `sed`, we started
    with how powerful `grep` can be, both inside and outside our scripts. Although
    we have only just touched on `sed`, we will start extending this in the next chapter,
    where we will expand upon what we have learned.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个你已经牢牢掌握的章节，希望它对你真的有用。虽然我们希望专注于使用`sed`，但我们首先介绍了`grep`在脚本内部和外部的强大功能。尽管我们仅仅触及了`sed`的表面，我们将在下一个章节中扩展这些内容，深入讲解我们所学的知识。
- en: Also, we learned how to substitute text and how to limit and globalize the substitution
    and how to save the editing stream using `-i`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们学习了如何替换文本、如何限制和全局化替换操作，以及如何使用`-i`选项保存编辑流。
- en: We learned how to insert, append, delete, and transform text using `sed`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用`sed`插入、追加、删除和转换文本。
- en: Finally, we learned how to run multiple `sed` commands using the `-e` option.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用`-e`选项运行多个`sed`命令。
- en: In the next chapter, we will learn how to automate Apache Virtual Hosts, how
    to create new virtual hosts automatically, and other cool stuff. The workhorse
    of all these operations will be `sed` and `sed` scripts.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个章节中，我们将学习如何自动化 Apache 虚拟主机，如何自动创建新的虚拟主机，以及其他一些很酷的操作。这些操作的核心工具将是`sed`和`sed`脚本。
- en: Questions
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Suppose you have a file with the following content:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有一个包含以下内容的文件：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And suppose you use the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 并假设你使用了以下命令：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How many lines will be substituted?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将有多少行会被替换？
- en: 'Suppose you have the same file that was used in the previous question and you
    use the following command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有和前一个问题中相同的文件，并且你使用了以下命令：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How many lines will be deleted from the file?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将有多少行会从文件中删除？
- en: What is the location of the inserted line in the following example?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下示例中，插入的行位于哪个位置？
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Suppose you have the same previous sample file and you run the following command:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有一个和之前相同的示例文件，并且你执行了以下命令：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How many lines will be saved to the output file?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将有多少行被保存到输出文件中？
- en: Further reading
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Please see the following for further reading relating to this chapter:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下内容，获取与本章相关的进一步阅读材料：
- en: '[https://www.gnu.org/software/sed/manual/sed.html](https://www.gnu.org/software/sed/manual/sed.html)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.gnu.org/software/sed/manual/sed.html](https://www.gnu.org/software/sed/manual/sed.html)'
- en: '[https://linux.die.net/man/1/sed](https://linux.die.net/man/1/sed)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linux.die.net/man/1/sed](https://linux.die.net/man/1/sed)'
