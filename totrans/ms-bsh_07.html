<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Plug into the Real World</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We are moving into the real world now, creating something that can turn out handy for your daily routine; during this process, we will have a look at the common pitfalls in coding and how to make our script reliable. Be it a short or long script, we must always ask ourselves the same questions:</span></span></p>
<ul class="calibre12">
<li class="calibre13">What do we really want to accomplish?</li>
<li class="calibre13">How much time do we have?</li>
<li class="calibre13">Do we have all the resources needed?</li>
<li class="calibre13">Do we have the knowledge required for the task?</li>
</ul>
<p class="calibre1"><span><span>We will start coding with a Nagios plugin, which will give us a broad understanding of how this monitoring system is and how to make a script dynamically interact with other programs.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is Nagios?</h1>
                
            
            <article>
                
<p class="calibre1"><span><span><strong class="calibre2">Nagios</strong> is one of the most widely adopted open source IT infrastructure monitoring tools, whose main interesting feature is the fact that it does not know how to monitor anything. Well, it sounds like a joke, but actually Nagios can be defined as an evaluating core, which takes some information as input and reacts accordingly. How is this information gathered? It is not the main concern of this tool and this leads us to an interesting point: Nagios leaves the task of getting the monitored data to an external plugin, which knows the following details:</span></span></p>
<ul class="calibre12">
<li class="calibre13">How to connect to the monitored services</li>
<li class="calibre13">How to collect the data from the monitored services</li>
<li class="calibre13">How to evaluate the data</li>
</ul>
<p class="calibre1"><span><span>Inform Nagios if the values gathered are beyond or in the boundaries to raise an alarm.</span></span></p>
<p class="calibre1"><span><span>So, a plugin does a lot of things and one would ask oneself what does Nagios do then? Imagine it as an exchange pod where information is flowing in and out and decisions are taken based on the configurations set; the core triggers the plugin to monitor a service; the plugin itself returns some information and Nagios takes a decision about:</span></span></p>
<ul class="calibre12">
<li class="calibre13">Whether to raise an alarm</li>
<li class="calibre13"><span><span>Send a notification</span></span></li>
<li class="calibre13"><span><span>Whom to notify</span></span></li>
<li class="calibre13"><span><span>For how long</span></span></li>
<li class="calibre13"><span><span>What, if any action is taken in order to get back to</span></span> normality</li>
</ul>
<p class="calibre1"><span><span>The core Nagios program does everything except actually knock at the door of a service, ask for information, and decide whether this information shows some issues or not.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Active and passive checks</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>To understand how to code a plugin, we have first to grasp how, on a broad scale, a Nagios check works. There are two different kinds of checks.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Active checks</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Based on a time range, or manually triggered, an active check sees a plugin actively connecting to a service and collecting information. A typical example could be for a plugin to check the disk space: once invoked, it interfaces with (usually) the operating system, executes a <kbd class="calibre9">df</kbd> command, works on the output, extracts the value related to the disk space, evaluates it against some thresholds, and reports back a status, such as </span></span><span>OK</span><span><span>,</span></span> <span>WARNING</span><span><span>,</span></span> <span>CRITICAL</span>, or <span>UNKNOWN</span><span><span>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Passive checks</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>In this case, Nagios does not trigger anything but waits to be contacted by some means by the service, which must be monitored. It seems quite confusing, but let's make a real-life example. How would you monitor if a disk backup has been completed successfully? One quick answer would be: knowing when the backup task starts and how long it lasts, we can define a time and invoke a script to check the task at that given hour.</span></span></p>
<p class="calibre1"><span><span>Nice, but when we plan something, we must have a full understanding of how real life goes, and a backup is not our little pet in the living room, it's rather a beast, which does what it wants. A backup can last a variable amount of time depending on an unpredictable factor.</span></span></p>
<p class="calibre1"><span><span>For instance, your typical backup task would copy 1 TB of data in 2 hours, starting at 03:00, out of a 6 TB disk. So, the next backup task would start at 03:00+02:00=05:00 AM, give or take some minutes. And you set up an active check for it at 05:30, and it works well for a couple of months. Then, one early morning, you receive a notification on your smartphone that the backup is in <span>CRITICAL</span>. You wake up, connect to the backup console and see that at 06:00 in the morning, you a</span></span>re asleep and the backup task has not even been started by the console. Then, you have to wait until 08:00 AM until some of your colleagues show up at the office to find out that the day before the disk, your backup has been filled with 2 extra TB of data due to an unscheduled data transfer. So, the backup task preceding the one you are monitoring lasted not for a couple of hours but 6 hours, and the task you are monitoring then started at 09:30 AM.</p>
<p class="calibre1">Long story short, your active check has been fired up too early; that is why it failed. Maybe your are tempted to move your schedule some hours ahead, but simply do not do it, as these time slots are not sliding frames. If you move your check ahead, you should then move all the checks for the subsequent tasks ahead. You do it in one week, the project manager will ask someone to delete the 2 TB excess (useless for the project now), and your schedules will be 2 hours ahead, making your monitoring useless. So, as we insisted before, planning and analyzing the context is the key factor in making a good script and, in this case, a good plugin. We have a service that does not run 24/7 like a web service or a mail service; what is specific to the backup is that it is run periodically, but we do not know exactly when.</p>
<p class="calibre1">The best approach to this kind of monitoring is letting the service itself notify us when it finished its task and what was its outcome. This is usually accomplished using the ability of most backup programs to send a <strong class="calibre2">Simple Network Monitoring Protocol</strong> (<strong class="calibre2">SNMP</strong>) trap to a destination to inform it of the outcome; and in our case it would be the Nagios server, which would have been configured to receive the trap and analyze. Add to this an event horizon so that if you do not receive the specific trap in, let's say, 24 hours, we raise an alarm anyway and you are covered: whenever the backup task gets completed or when it times out, we receive a notification.</p>
<div class="packt_figure"><span><span><img class="image-border7" src="../images/00012.jpeg"/></span></span></div>
<div class="packt_figref"><span><span>Nagios notifications flowchart</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Returning code and thresholds</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>Before coding a plugin, we must face some concepts that will be the stepping stone of our Nagios code base, one of these being the return codes of the plugin itself. As we already discussed, once the plugin collects the data about how the service is going, it evaluates these data and determines if the situation falls under one of the following status:</span></span></p>
<table class="table">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><strong class="calibre2">Return code</strong></p>
</td>
<td class="calibre8">
<p class="calibre1"><strong class="calibre2">Status</strong></p>
</td>
<td class="calibre8">
<p class="calibre1"><strong class="calibre2">Description</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">0</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><span>OK</span></p>
</td>
<td class="calibre8">
<p class="calibre1">The plugin checked the service and the results that are inside the acceptable range.</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">1</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><span>WARNING</span></p>
</td>
<td class="calibre8">
<p class="calibre1">The plugin checked the service and the results that are above a <span>WARNING</span> threshold. We must keep an eye on the service.</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">2</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><span>CRITICAL</span></p>
</td>
<td class="calibre8">
<p class="calibre1">The plugin checked the service and the results that are above a <span>CRITICAL</span> threshold or the service not responding. We must react now.</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">3</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><span>UNKNOWN</span></p>
</td>
<td class="calibre8">
<p class="calibre1">Either we passed the wrong arguments to the plugin or there is some internal error in it.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre1"> </p>
<p class="calibre1"><span><span>So, our plugin will check a service, evaluate the results, and based on a threshold, will return to Nagios one of the values listed in the tables and a meaningful message, like we can see in the description column in the following screenshot:</span></span></p>
<div class="packt_figure"><img class="image-border2" src="../images/00013.jpeg"/></div>
<p class="calibre1"><span><span>Notice the service check in red and the message in the preceding screenshot.</span></span></p>
<p class="calibre1"><span><span>In the screenshot, we can see that some checks are green, meaning okay, and they have an explicative message in the description section. What we see in this section is the output of the plugin written in the <kbd class="calibre9">stdout</kbd>; and it is what we will craft as a response to Nagios.</span></span></p>
<p class="calibre1"><span><span>Pay attention to the <span>SSH</span> check: it is red and is failing because it is checking the service at the default port, which is <kbd class="calibre9">22</kbd>, but on this server the <kbd class="calibre9">ssh</kbd> daemon is listening on a different port. This leads us to a consideration: our plugin will need a command line parser able to receive some configuration options and some threshold limits as well, because we need to know what to check, where to check, and what are the acceptable working limits for a service:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">Where</strong>: In Nagios, there can be a host without service checks (except for the implicit host alive carried on by a ping), but no services without a host to be performed onto. So, any plugin must receive on the command line the indication of the host to be run against, be it a dummy host but there must be one.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">How</strong>: This is where our coding comes in; we will have to write the lines of code that instruct the plugin how to connect to the server, query, collect, and parse the answer.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">What</strong>: We must instruct the plugin, usually with some meaningful options on the command line, on what are the acceptable working limits so that it can evaluate them and decide to notify us with an <span>OK</span>, <span>WARNING</span></span></span>,<span><span><span> </span>or <span>CRITICAL</span> message.</span></span></li>
</ul>
<p class="calibre1"><span><span>That is all for our script: who to notify, when, how, how many times, and so forth. These are tasks carried on by the core; a Nagios plugin is unaware of all of this. What it really must know for effective monitoring is what are the correct values that identify a working service. We can pass to our script two different kinds of value:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">Range</strong>: This is a series of numeric values with a starting and ending point, like from 3 to 7 or from one number to infinite</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Threshold</strong>: It is a range with an associated alert level</span></span></li>
</ul>
<p class="calibre1"><span><span>So, when our plugins perform checks, they collect a numeric value that is within or outside a range, based on the threshold we impose; then, based on the evaluation, it replies to Nagios with a return code and a message. How do we specify some ranges on the command line? Essentially in the following way:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">[@] start_value:end_value</strong>
</pre>
<p class="calibre1"><span><span>If the range starts from <kbd class="calibre9">0</kbd>, the part from <kbd class="calibre9">:</kbd> to the left can be omitted. The <kbd class="calibre9">start_value</kbd> must always be a lower number than <kbd class="calibre9">end_value</kbd>.</span></span></p>
<p class="calibre1"><span><span>If the range starts with </span></span><kbd class="calibre9">start_value</kbd>, it means from that number to infinity. Negative infinity can be specified using <kbd class="calibre9">~</kbd>.</p>
<p class="calibre1"><span><span>An alert is generated when the collected value resides outside the range specified, comprised of the endpoints.</span></span></p>
<p class="calibre1"><span><span>If <kbd class="calibre9">@</kbd> is specified, the alert is generated if the value resides inside the range.</span></span></p>
<p class="calibre1">Let's see some practical examples of how we would call our script, imposing some thresholds:</p>
<table class="table">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><strong class="calibre2">Plugin call</strong></p>
</td>
<td class="calibre8">
<p class="calibre1"><strong class="calibre2">Meaning</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">./my_plugin -c 10</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><span>CRITICAL</span> if less than <kbd class="calibre9">0</kbd> or higher than <kbd class="calibre9">10</kbd></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">./my_plugin -w 10:20</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><span>WARNING</span> if less than <kbd class="calibre9">10</kbd> or higher than <kbd class="calibre9">20</kbd></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">/my_plugin -w ~:15 -c 16</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><span>WARNING</span> if between -infinite and <kbd class="calibre9">15</kbd>, critical from <kbd class="calibre9">16</kbd> and higher</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">./my_plugin -c 35:</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><span>CRITICAL</span> if the value collected is below <kbd class="calibre9">35</kbd></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">./my_plugin -w @100:200</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><span>CRITICAL</span> if the value is from <kbd class="calibre9">100</kbd> to <kbd class="calibre9">200</kbd>, <span>OK</span> otherwise</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre1"> </p>
<p class="calibre1"><span><span>We covered the basic requirements for our plugin that in its simplest form should be called with the following syntax:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">./my_plugin -h hostaddress|hostname -w value -c value</strong>
</pre>
<p class="calibre1"><span><span>We already talked about the need to relate a check to a host; we can do this either by using a hostname or hostaddress. It is up to us what to use, but we will not fill in this piece of information, because it will be drawn by the service configuration as a standard macro. We just introduced a new concept, service configuration, which is essential in making our script work in Nagios, so let's briefly see what we are talking about. A caveat before starting our journey on Nagios configurations: this is not a book on Nagios, so we will not cover all the complex bits and parts. We will touch all the topics needed to make our script do its job and with a working Nagios installation; we will be able to activate our new plugin quickly. Let's see now how to configure a plugin to make it work under Nagios, so then we will be able to focus on our script without any distractions.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Command and service definitions</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>At the base of everything in Nagios is a plugin, the minion who carries out the job of retrieving the information, evaluating it, raising the alarm, and providing a meaningful message. Left alone, Nagios does not know how to call a plugin, what options to pass to it or how to handle it, so we need a command definition, which defines how the script will be called.</span></span></p>
<p class="calibre1"><span><span>Let's take as an example the command definition for the <kbd class="calibre9">ssh</kbd> service check, which is failing because the port used for the check is not the one the daemon is listening on:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># 'check_ssh' command definition<br class="title-page-name"/></strong><strong class="calibre2">define command{<br class="title-page-name"/></strong><strong class="calibre2">command_name check_ssh<br class="title-page-name"/></strong><strong class="calibre2">command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$'<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>We can see here a command definition named </span></span><kbd class="calibre9"><span><span>command_name check_ssh</span></span></kbd>.</p>
<p class="calibre1"><span><span>Let's keep <kbd class="calibre9">check_ssh</kbd> in mind, because it will be the handle we will use to refer to this command definition later on. As we can see, this definition is really short; it defines a handle, and, most importantly, the command line to call the plugin. In this case, it is really easy: the plugin accepts the host address and that is enough for a basic check. Look at  </span></span><span><span><kbd class="calibre9">$HOSTADDRESS$</kbd>. </span></span><span><span>This is one of the so-called <strong class="calibre2">Nagios standard macros:</strong> essentially a place holder, which will be instantiated by Nagios with the host address of the host you will associate the service making use of this command. Nothing complicated so far, let's move onto the service definition, making use of this command definition:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># check that ssh services are running<br class="title-page-name"/></strong><strong class="calibre2">define service {<br class="title-page-name"/></strong><strong class="calibre2">use generic-service<br class="title-page-name"/></strong><strong class="calibre2">host_name localhost<br class="title-page-name"/></strong><strong class="calibre2">service_description SSH<br class="title-page-name"/></strong><strong class="calibre2">check_command check_ssh<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>The <kbd class="calibre9">ssh</kbd> service definition introduces something new, and this is the inheritance of properties by the Nagios objects. As we discussed previously, the script carries out the checking, evaluation, and alarm raising; the core does all the rest, and lots of stuff. Looking at this service definition, it does not seem a lot, but focus on the first line named </span></span><span><span><kbd class="calibre9">use generic-service</kbd>. </span></span><span><span>This rings a bell. Looking at the definition, it seems that <kbd class="calibre9">generic-service</kbd> is actually a template, doesn't it?</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># generic service template definition<br class="title-page-name"/></strong><strong class="calibre2">define service{<br class="title-page-name"/></strong><strong class="calibre2">name generic-service ; The 'name' of this service template<br class="title-page-name"/></strong><strong class="calibre2">active_checks_enabled 1 ; Active service checks are enabled<br class="title-page-name"/></strong><strong class="calibre2">passive_checks_enabled 1 ; Passive service checks are enabled/accepted<br class="title-page-name"/></strong><strong class="calibre2">parallelize_check 1 ; Active service checks should be parallelized (disabling this can lead to major performance problems)<br class="title-page-name"/></strong><strong class="calibre2">obsess_over_service 1 ; We should obsess over this service (if necessary)<br class="title-page-name"/></strong><strong class="calibre2">check_freshness 0 ; Default is to NOT check service 'freshness'<br class="title-page-name"/></strong><strong class="calibre2">notifications_enabled 1 ; Service notifications are enabled<br class="title-page-name"/></strong><strong class="calibre2">event_handler_enabled 1 ; Service event handler is enabled<br class="title-page-name"/></strong><strong class="calibre2">flap_detection_enabled 1 ; Flap detection is enabled<br class="title-page-name"/></strong><strong class="calibre2">failure_prediction_enabled 1 ; Failure prediction is enabled<br class="title-page-name"/></strong><strong class="calibre2">process_perf_data 1 ; Process performance data<br class="title-page-name"/></strong><strong class="calibre2">retain_status_information 1 ; Retain status information across program restarts<br class="title-page-name"/></strong><strong class="calibre2">retain_nonstatus_information 1 ; Retain non-status information across program restarts<br class="title-page-name"/></strong><strong class="calibre2"> notification_interval 0 ; Only send notifications on status change by default.<br class="title-page-name"/></strong><strong class="calibre2">is_volatile 0<br class="title-page-name"/></strong><strong class="calibre2">check_period 24x7<br class="title-page-name"/></strong><strong class="calibre2">normal_check_interval 5<br class="title-page-name"/></strong><strong class="calibre2">retry_check_interval 1<br class="title-page-name"/></strong><strong class="calibre2">max_check_attempts 4<br class="title-page-name"/></strong><strong class="calibre2">notification_period 24x7<br class="title-page-name"/></strong><strong class="calibre2">notification_options w,u,c,r<br class="title-page-name"/></strong><strong class="calibre2">contact_groups admins<br class="title-page-name"/></strong><strong class="calibre2">register 0 ; <br class="title-page-name"/>DONT REGISTER THIS DEFINITION - ITS NOT A REAL SERVICE, JUST A TEMPLATE!<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>Well, as we can see, there is a lot we can define service-wise, just so much to clutter a service definition so we hide the complexity in a template and recall it, like sourcing a library. Once the template is imported, all its definition will apply to the service that called it and if we want to modify some values from the template, we just write them in the service definition with the new values, because if we have multiple definitions with the same name and different values, the closest to the final object wins. So, a definition at the service level wins over a definition in the template. We will not explain all the definitions in the template, as they are not useful for our goal, since our script will rely on the generic service definition without any alterations.</span></span></p>
<p class="calibre1"><span><span>Let's go back to the service definition and have a look at the second line </span></span><span><span><kbd class="calibre9">host_name</kbd> localhost. </span></span><span><span>We already mentioned the fact that each service check must refer to one (or more) host, so here is where we see what host this service applies to. We could also have used </span></span><span><span><kbd class="calibre9">hostgroup_name name_of_the_hostgroup</kbd>.</span></span></p>
<p class="calibre1"><span><span>To apply a single check to multiple hosts enclosed in a host group definition. Let's move onto the </span></span><span><span><kbd class="calibre9">service_description</kbd> ssh. A</span></span><span><span>s for the command definition, this is the handle used to refer to this service definition throughout Nagios:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">check_command check_ssh</strong>
</pre>
<p class="calibre1"><span><span>This is where we call the command definition passing optional arguments. In our predefined configuration, there are no parameters to give to the command, so nothing special. With this line, the service definition recalls the syntax defined in the command definition called by the handled, and optionally passes some arguments to it. All the configurations for services, commands, hosts, and templates follow the same structure:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">define object {<br class="title-page-name"/></strong><strong class="calibre2">definitions_1 <br class="title-page-name"/></strong><strong class="calibre2">definitions_2 <br class="title-page-name"/></strong><strong class="calibre2">definitions_n<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>You can then have the different definitions on one files closed in their snippets.</span></span></p>
<p class="calibre1"><span><span>We just saw how the ssh check works in Nagios, but it actually does not work, since it throws us an error. What we would need is a way to change the port that the service is being checked on. How do we accomplish this task? By simply bearing in mind that the actual plugin is the star here, it will drive all our efforts, so let's invoke it and see what it has to say. Let's have a look at the command line definition:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$'</strong>
</pre>
<p class="calibre1"><span><span>From here, we know where the script is, so let's call it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ /usr/lib/nagios/plugins/check_ssh <br class="title-page-name"/></strong><strong class="calibre2">check_ssh: Could not parse arguments<br class="title-page-name"/></strong><strong class="calibre2">Usage:<br class="title-page-name"/></strong><strong class="calibre2">check_ssh [-4|-6] [-t &lt;timeout&gt;] [-r &lt;remote version&gt;] [-p &lt;port&gt;] &lt;host&gt;</strong>
</pre>
<p class="calibre1"><span><span>What we see here is that the script accepts some arguments and options on the command line, but each script is usually coded with a full help message invoked by a <kbd class="calibre9">-h</kbd> option:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ /usr/lib/nagios/plugins/check_ssh -h<br class="title-page-name"/></strong><strong class="calibre2">check_ssh v2.1.1 (monitoring-plugins 2.1.1)<br class="title-page-name"/></strong><strong class="calibre2">Copyright (c) 1999 Remi Paulmier &lt;remi@sinfomic.fr&gt;<br class="title-page-name"/></strong><strong class="calibre2">Copyright (c) 2000-2007 Monitoring Plugins Development Team<br class="title-page-name"/></strong><strong class="calibre2">&lt;devel@monitoring-plugins.org&gt;<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">Try to connect to an SSH server at specified server and port<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">Usage:<br class="title-page-name"/></strong><strong class="calibre2">check_ssh [-4|-6] [-t &lt;timeout&gt;] [-r &lt;remote version&gt;] [-p &lt;port&gt;] &lt;host&gt;<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">Options:<br class="title-page-name"/></strong><strong class="calibre2">-h, --help<br class="title-page-name"/></strong><strong class="calibre2">Print detailed help screen<br class="title-page-name"/></strong><strong class="calibre2">-V, --version<br class="title-page-name"/></strong><strong class="calibre2">Print version information<br class="title-page-name"/></strong><strong class="calibre2">--extra-opts=[section][@file]<br class="title-page-name"/></strong><strong class="calibre2">Read options from an ini file. See </strong><strong class="calibre2">https://www.monitoring-plugins.org/doc/extra-opts.html<br class="title-page-name"/></strong><strong class="calibre2">for usage and examples.<br class="title-page-name"/></strong><strong class="calibre2">-H, --hostname=ADDRESS<br class="title-page-name"/></strong><strong class="calibre2">Host name, IP Address, or unix socket (must be an absolute path)<br class="title-page-name"/></strong><strong class="calibre2">-p, --port=INTEGER<br class="title-page-name"/></strong><strong class="calibre2">Port number (default: 22)<br class="title-page-name"/></strong><strong class="calibre2">-4, --use-ipv4<br class="title-page-name"/></strong><strong class="calibre2">Use IPv4 connection<br class="title-page-name"/></strong><strong class="calibre2">-6, --use-ipv6<br class="title-page-name"/></strong><strong class="calibre2">Use IPv6 connection<br class="title-page-name"/></strong><strong class="calibre2">-t, --timeout=INTEGER<br class="title-page-name"/></strong><strong class="calibre2">Seconds before connection times out (default: 10)<br class="title-page-name"/></strong><strong class="calibre2">-r, --remote-version=STRING<br class="title-page-name"/></strong><strong class="calibre2">Warn if string doesn't match expected server version (ex: OpenSSH_3.9p1)<br class="title-page-name"/></strong><strong class="calibre2">-P, --remote-protocol=STRING<br class="title-page-name"/></strong><strong class="calibre2">Warn if protocol doesn't match expected protocol version (ex: 2.0)<br class="title-page-name"/></strong><strong class="calibre2">-v, --verbose<br class="title-page-name"/></strong><strong class="calibre2">Show details for command-line debugging (output may be truncated by<br class="title-page-name"/></strong><strong class="calibre2">the monitoring system)<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">Send email to help@monitoring-plugins.org if you have questions regarding </strong><strong class="calibre2">use of this software. To submit patches or suggest improvements, send email </strong><strong class="calibre2">to devel@monitoring-plugins.org</strong>
</pre>
<p class="calibre1"><span><span>Let's keep in mind this help, because it is something we will have to implement in our plugin. Anyway, what we see, among other options is that we can actually change the port the service is being checked on using the option: </span></span><span><span><kbd class="calibre9">-p</kbd>.</span></span></p>
<p class="calibre1"><span><span>Let's check where our <kbd class="calibre9">ssh</kbd> server is listening for connections:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ netstat -tapn | grep ssh<br class="title-page-name"/></strong><strong class="calibre2">tcp 0 0 0.0.0.0:1472 0.0.0.0:* LISTEN 685/sshd <br class="title-page-name"/></strong><strong class="calibre2">tcp6 0 0 :::1472 </strong>
</pre>
<p class="calibre1"><span><span>Now we know that our <kbd class="calibre9">ssh</kbd> daemon is listening on port </span></span><span><span><kbd class="calibre9">1472</kbd>. </span></span><span><span>So we have to make a manual check to be sure on how to invoke the plugin with the new parameters and values:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ /usr/lib/nagios/plugins/check_ssh -H localhost -p 1472<br class="title-page-name"/></strong><strong class="calibre2">SSH OK - OpenSSH_6.7p1 Debian-5+deb8u3 (protocol 2.0) | time=0.011048s;;;0.000000;10.000000</strong>
</pre>
<p class="calibre1"><span><span>It worked we processed </span></span><span><span><kbd class="calibre9">-H localhost</kbd> </span></span><span><span>to identify which host we are executing our check against and </span></span><span><span><kbd class="calibre9">-p 1472</kbd> </span></span><span><span>to query the correct port for this <kbd class="calibre9">ssh</kbd> daemon configuration. Now, let's pay attention to the reply from the plugin:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">SSH OK - OpenSSH_6.7p1 Debian-5+deb8u3 (protocol 2.0) | time=0.011048s;;;0.000000;10.000000</strong>
</pre>
<p class="calibre1">This is the standard structure of the message provided by a Nagios plugin:</p>
<ol class="calibre15">
<li value="1" class="calibre13">The name of the service (SSH).</li>
<li value="2" class="calibre13">Service status (OK).</li>
<li value="3" class="calibre13">Message given by the service being checked (or a message we crafted ourselves).</li>
</ol>
<p class="calibre1">Then there is something we never saw before:</p>
<pre class="codepackt">
<strong class="calibre2">| time=0.011048s;;;0.000000;10.000000</strong>
</pre>
<p class="calibre1"><span><span>This is a pipe, followed by one or more labels, time in our example, and some values usually related to how the service is working. Whatever is written, it is not a Nagios concern, since it will not process this part of the output line. These values are there for third-party applications such as <kbd class="calibre9">pnp4nagios</kbd> or Nagios graph to process them and eventually draw out some performance graphics.</span></span></p>
<div class="packt_figure"><img class="image-border8" src="../images/00014.jpeg"/></div>
<div class="packt_figref"><span><span>Nagios shows the performance data but does not really make use of it</span></span></div>
<p class="calibre1"><span><span>We will see later how a graph for a service looks like, now let's remember one thing: the output of a plugin is usually one line long and even though you have a multiline output, it is always better to stick to a simple message.</span></span></p>
<p class="calibre1"><span><span>Now, let's go back to the definition of the SSH service check, and let's see how to modify it to enable a different port check. This is the <kbd class="calibre9">check_ssh</kbd> command that we have already seen:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># 'check_ssh' command definition<br class="title-page-name"/></strong><strong class="calibre2">define command{<br class="title-page-name"/></strong><strong class="calibre2">command_name check_ssh<br class="title-page-name"/></strong><strong class="calibre2">command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$'<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>To enable the definition of an arbitrary port check, we have to modify the <kbd class="calibre9">command_line</kbd> row so that it will accept the new <kbd class="calibre9">-p</kbd> parameter with an argument:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># 'check_ssh' command definition<br class="title-page-name"/></strong><strong class="calibre2">define command{<br class="title-page-name"/></strong><strong class="calibre2">command_name check_ssh<br class="title-page-name"/></strong><strong class="calibre2">command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$' -p $ARG1$<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>What we did is simple: we just added a <kbd class="calibre9">-p</kbd> followed by </span></span><span><span><kbd class="calibre9">$ARG1$</kbd>. </span></span><span><span>What is this new bit? In Nagios, you can pass whatever arguments you want to a script, and you refer to them using a positional variable. Think of <kbd class="calibre9">$ARG1$</kbd> as  <kbd class="calibre9">$1</kbd> for a standard bash script; it identifies the first argument passed to the command line. Bear in mind that options like <kbd class="calibre9">-p</kbd> are not counted as arguments. So <kbd class="calibre9">$ARG2$</kbd> will be the second positional argument, <kbd class="calibre9">$ARG3$</kbd> the third, and so on. Do not forget the leading and trailing dollar signs. So, we modified the way Nagios can call the plugin, and now we can pass it an extra argument. What is left is to actually provide the extra argument to the script; this is done by modifying the service definition for <kbd class="calibre9">ssh</kbd>. We previously had this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># check that ssh services are running<br class="title-page-name"/></strong><strong class="calibre2">define service {<br class="title-page-name"/></strong><strong class="calibre2">use generic-service<br class="title-page-name"/></strong><strong class="calibre2">host_name localhost<br class="title-page-name"/></strong><strong class="calibre2">service_description SSH<br class="title-page-name"/></strong><strong class="calibre2">check_command check_ssh<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>This definition must be modified so that we can store and pass the port number to the command, so this is how we do it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># check that ssh services are running<br class="title-page-name"/></strong><strong class="calibre2">define service {<br class="title-page-name"/></strong><strong class="calibre2">use generic-service<br class="title-page-name"/></strong><strong class="calibre2">host_name localhost<br class="title-page-name"/></strong><strong class="calibre2">service_description SSH<br class="title-page-name"/></strong><strong class="calibre2">check_command check_ssh!1472<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>The exclamation mark (<kbd class="calibre9">!</kbd>) after the command name is a standard field separator and identifies the different positional arguments passed to the plugin. Let's make an example modifying the <kbd class="calibre9">command_line</kbd> of <kbd class="calibre9">ssh</kbd> to accept it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">-p 1472<br class="title-page-name"/></strong><strong class="calibre2">-4<br class="title-page-name"/></strong><strong class="calibre2">-P 2.0<br class="title-page-name"/></strong><strong class="calibre2">-t 30</strong>
</pre>
<p class="calibre1"><span><span>We must modify the command line to accept five parameters instead of one:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># 'check_ssh' command definition<br class="title-page-name"/></strong><strong class="calibre2">define command{<br class="title-page-name"/></strong><strong class="calibre2">command_name check_ssh<br class="title-page-name"/></strong><strong class="calibre2">command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$' -p $ARG1$ -$ARG2$ -r $ARG3$ -P $ARG4$ -t $ARG5$<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>The modification is quite straightforward, we just wrote down all the switches and their arguments using the positional <kbd class="calibre9">$ARGn$</kbd> variables. Now that the command line is ready to accept the new values, we must fill in the placeholders:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># check that ssh services are running<br class="title-page-name"/></strong><strong class="calibre2">define service {<br class="title-page-name"/></strong><strong class="calibre2">use generic-service<br class="title-page-name"/></strong><strong class="calibre2">host_name localhost<br class="title-page-name"/></strong><strong class="calibre2">service_description SSH<br class="title-page-name"/></strong><strong class="calibre2">check_command check_ssh!1472!4!2.0!30<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>Not so complicated; each argument must be written in the order expected by the command line:</span></span></p>
<table class="table">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">-p</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">-</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">-P</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">-t</kbd></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">1472</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">4</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">2.0</kbd></p>
</td>
<td class="calibre8">
<p class="calibre1"><kbd class="calibre9">30</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="calibre1"><span><span>One thing to bear in mind is that the standard macros do not play a positional parameters so they do not have to be taken in to account when counting the slot indexes.</span></span></p>
<p class="calibre1"><span><span>Now that we have all the bits in order, with the right switches and values, we have to write our new configuration down. Okay, but where? The location of the configuration files differs from distribution to distribution and the way the files are fragmented too: some distributions have commands and service definitions inside a host file along with the host definition, some others have fragmented in single files. How do we deal with it? Let the Nagios process tell you how it reads the information:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ ps ax | grep nagios<br class="title-page-name"/></strong><strong class="calibre2">803 ? SNs 0:02 /usr/sbin/nagios3 -d /etc/nagios3/nagios.cfg<br class="title-page-name"/></strong><strong class="calibre2">2502 pts/1 S+ 0:00 grep nagios</strong>
</pre>
<p class="calibre1"><span><span>A <kbd class="calibre9">ps</kbd> command shows us that Nagios is reading its main configuration directives from</span></span><span><span><kbd class="calibre9">/etc/nagios3/nagios.cfg</kbd>. </span></span><span><span>So, it is worth having a look at it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Commands definitions<br class="title-page-name"/></strong><strong class="calibre2">cfg_file=/etc/nagios3/commands.cfg<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># Debian also defaults to using the check commands defined by the debian<br class="title-page-name"/></strong><strong class="calibre2"># nagios-plugins package<br class="title-page-name"/></strong><strong class="calibre2">cfg_dir=/etc/nagios-plugins/config<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># Debian uses by default a configuration directory where nagios3-common,<br class="title-page-name"/></strong><strong class="calibre2"># other packages and the local admin can dump or link configuration<br class="title-page-name"/></strong><strong class="calibre2"># files into.<br class="title-page-name"/></strong><strong class="calibre2">cfg_dir=/etc/nagios3/conf.d<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># OBJECT CONFIGURATION FILE(S)<br class="title-page-name"/></strong><strong class="calibre2"># These are the object configuration files in which you define hosts,<br class="title-page-name"/></strong><strong class="calibre2"># host groups, contacts, contact groups, services, etc.<br class="title-page-name"/></strong><strong class="calibre2"># You can split your object definitions across several config files<br class="title-page-name"/></strong><strong class="calibre2"># if you wish (as shown below), or keep them all in a single config file.<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># You can specify individual object config files as shown below:<br class="title-page-name"/></strong><strong class="calibre2">#cfg_file=/etc/nagios3/objects/commands.cfg<br class="title-page-name"/></strong><strong class="calibre2">#cfg_file=/etc/nagios3/objects/contacts.cfg<br class="title-page-name"/></strong><strong class="calibre2">#cfg_file=/etc/nagios3/objects/timeperiods.cfg<br class="title-page-name"/></strong><strong class="calibre2">#cfg_file=/etc/nagios3/objects/templates.cfg<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># Definitions for monitoring a Windows machine<br class="title-page-name"/></strong><strong class="calibre2">#cfg_file=/etc/nagios3/objects/windows.cfg<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># Definitions for monitoring a router/switch<br class="title-page-name"/></strong><strong class="calibre2">#cfg_file=/etc/nagios3/objects/switch.cfg<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># Definitions for monitoring a network printer<br class="title-page-name"/></strong><strong class="calibre2">#cfg_file=/etc/nagios3/objects/printer.cfg<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># You can also tell Nagios to process all config files (with a .cfg<br class="title-page-name"/></strong><strong class="calibre2"># extension) in a particular directory by using the cfg_dir<br class="title-page-name"/></strong><strong class="calibre2"># directive as shown below:<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">#cfg_dir=/etc/nagios3/servers<br class="title-page-name"/></strong><strong class="calibre2">#cfg_dir=/etc/nagios3/printers<br class="title-page-name"/></strong><strong class="calibre2">#cfg_dir=/etc/nagios3/switches<br class="title-page-name"/></strong><strong class="calibre2">#cfg_dir=/etc/nagios3/routers</strong>
</pre>
<p class="calibre1"><span><span>This is a standard section in the Nagios main configuration file, and you will find it in each and every installation, so pay attention to the lines that are not commented out by a <kbd class="calibre9">#</kbd> character:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Commands definitions<br class="title-page-name"/></strong><strong class="calibre2">cfg_file=/etc/nagios3/commands.cfg<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># Debian also defaults to using the check commands defined by the debian<br class="title-page-name"/></strong><strong class="calibre2"># nagios-plugins package<br class="title-page-name"/></strong><strong class="calibre2">cfg_dir=/etc/nagios-plugins/config<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># Debian uses by default a configuration directory where nagios3-common,<br class="title-page-name"/></strong><strong class="calibre2"># other packages and the local admin can dump or link configuration<br class="title-page-name"/></strong><strong class="calibre2"># files into.<br class="title-page-name"/></strong><strong class="calibre2">cfg_dir=/etc/nagios3/conf.d</strong>
</pre>
<p class="calibre1"><span><span>So, from the main configuration file, we can see that the configurations are stored in one file and two directories. Since we are dealing with a command plugin modification, we start from </span></span><span><span><kbd class="calibre9">cfg_dir=/etc/nagios-plugins/config</kbd>. </span></span></p>
<p class="calibre1"><span><span>Looking for a file that cold bear an <kbd class="calibre9">ssh</kbd> configuration, let's move to </span></span><span><span><kbd class="calibre9">root:~$ cd /etc/nagios-plugins/config</kbd> </span></span><span><span>and <kbd class="calibre9">grep</kbd> for <kbd class="calibre9">ssh</kbd> in each file:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ egrep -lr ssh *<br class="title-page-name"/></strong><strong class="calibre2">disk.cfg<br class="title-page-name"/></strong><strong class="calibre2">ssh.cfg</strong>
</pre>
<p class="calibre1"><span><span>Just <kbd class="calibre9">egrep -l</kbd> will print only the names of the files where a match has been found; if you are not sure and want to see the actual matched line, use <kbd class="calibre9">-ir</kbd> instead of <kbd class="calibre9">-lr</kbd> , and you will see a lot more information. Anyway, between the two files, it seems pretty clear that the one we will have to modify is </span></span><span><span><kbd class="calibre9">ssh.cfg</kbd>.</span></span></p>
<p class="calibre1"><span><span>Let's open it and go to the end of the file, adding our new command definition:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">define command{<br class="title-page-name"/></strong><strong class="calibre2">command_name check_ssh_arguments<br class="title-page-name"/></strong><strong class="calibre2">command_line /usr/lib/nagios/plugins/check_ssh '$HOSTADDRESS$' -p $ARG1$ -$ARG2$ -P $ARG3$ -t $ARG4$<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>As appears evident, we changed <kbd class="calibre9">command_name</kbd>; since there cannot be two command definitions with the same handle, we just chose something unique for our purposes. It will not be displayed to users, so it does not need to be fancy, just useful and meaningful. Let's save the file and proceed to define a new service configuration; from the main configuration file, it seems quite clear we have to look into </span></span><span><span><kbd class="calibre9">cfg_dir=/etc/nagios3/conf.d</kbd>. </span></span></p>
<p class="calibre1"><span><span>So, let's move to this directory: </span></span><span><span><kbd class="calibre9">root:~$ cd /etc/nagios3/conf.d</kbd>, </span></span><span><span>and <kbd class="calibre9">grep</kbd> for <kbd class="calibre9">ssh</kbd> again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ egrep -lr ssh *<br class="title-page-name"/></strong><strong class="calibre2">hostgroups_nagios2.cfg<br class="title-page-name"/></strong><strong class="calibre2">services_nagios2.cfg</strong>
</pre>
<p class="calibre1"><span><span>In this case, it is not clear what is bearing what, so an extended <kbd class="calibre9">grep</kbd> will be handy:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ egrep -ir ssh *<br class="title-page-name"/></strong><strong class="calibre2">hostgroups_nagios2.cfg:# A list of your ssh-accessible servers<br class="title-page-name"/></strong><strong class="calibre2">hostgroups_nagios2.cfg: hostgroup_name ssh-servers<br class="title-page-name"/></strong><strong class="calibre2">hostgroups_nagios2.cfg: alias SSH servers<br class="title-page-name"/></strong><strong class="calibre2">services_nagios2.cfg:# check that ssh services are running<br class="title-page-name"/></strong><strong class="calibre2">services_nagios2.cfg: hostgroup_name ssh-servers<br class="title-page-name"/></strong><strong class="calibre2">services_nagios2.cfg: service_description SSH<br class="title-page-name"/></strong><strong class="calibre2">services_nagios2.cfg: check_command check_ssh</strong>
</pre>
<p class="calibre1"><span><span>Now, it is clear that <kbd class="calibre9">hostgroups_nagios.cfg</kbd> bears the configurations related to the host groups, and among those, the configuration of the group of hosts that are being checked for the <kbd class="calibre9">ssh</kbd> service. The second file, <kbd class="calibre9">services_nagios2.cfg</kbd>, holds the configuration for the ssh service check, so let's open it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># check that ssh services are running<br class="title-page-name"/></strong><strong class="calibre2">define service {<br class="title-page-name"/></strong><strong class="calibre2">hostgroup_name ssh-servers<br class="title-page-name"/></strong><strong class="calibre2">service_description SSH<br class="title-page-name"/></strong><strong class="calibre2">check_command check_ssh<br class="title-page-name"/></strong><strong class="calibre2">use generic-service<br class="title-page-name"/></strong><strong class="calibre2">notification_interval 0 ; set &gt; 0 if you want to be re-notified<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>Here is the <kbd class="calibre9">ssh</kbd> service check configuration we were looking for. In a production environment, we would have to estimate the impact of our configuration, since if we now modify this definition, it will apply to all the servers we are checking against. Notice </span></span><span><span><kbd class="calibre9">hostgroup_name ssh-servers</kbd>, w</span></span><span><span>e are checking a group of servers being this group populated by one or one thousand servers is not important.</span></span></p>
<p class="calibre1"><span><span>In a production or a staging scenario, we would have to see which servers we are checking for the ssh service, understand if our modifications will have some odd effects on some of them, and if so, tear these servers out of the new check and create a special group for them using the old definition for them. In our case, since this is a demo installation and has <kbd class="calibre9">localhost</kbd> as the only group member, we can just modify the existing configuration and go with it:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># check that ssh services are running<br class="title-page-name"/></strong><strong class="calibre2">define service {<br class="title-page-name"/></strong><strong class="calibre2">hostgroup_name ssh-servers<br class="title-page-name"/></strong><strong class="calibre2">service_description SSH<br class="title-page-name"/></strong><strong class="calibre2">check_command check_ssh_arguments!1472!4!2.0!30<br class="title-page-name"/></strong><strong class="calibre2">use generic-service<br class="title-page-name"/></strong><strong class="calibre2">notification_interval 0 ; set &gt; 0 if you want to be renotified<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>This definition is quite similar to the one we crafted before; just here we are in a real scenario. Nagios is configured to apply this check on a hostgroup instead of a single server, but since the hostgroup is made by one server only, the localhost, the two definitions have the same scope. What we are left with is to force Nagios to reload the definitions so that our new configurations will be read by the core. A reload or restart will suffice:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">service nagios3 reload</strong>
</pre>
<p class="calibre1"><span><span>Now edit the </span></span><span><span><kbd class="calibre9">/etc/nagios3/nagios.cfg</kbd> </span></span><span><span>file and enable the following configuration bit:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">check_external_commands=1</strong>
</pre>
<p class="calibre1"><span><span>With <kbd class="calibre9">0</kbd> meaning disabled and <kbd class="calibre9">1</kbd> enabled, we just told Nagios to accept external command, so we can reload the configuration </span></span><span><span><kbd class="calibre9">service nagios3 reload</kbd>,</span></span><span><span> go to the service name, and enter the server details page. Here we just have to click on </span></span><span><span><span>Re-schedule the next check of this service.</span> </span></span></p>
<p class="calibre1"><span><span>Let's select <span>Force check and commit</span>; a new check will be forced whatever schedule is at play.</span></span></p>
<p class="calibre1">In the Debian and Ubuntu standard Nagios installation, you could face <kbd class="calibre9">Error: Could not stat() command file '/var/lib/nagios3/rw/nagios.cmd'! </kbd></p>
<p class="calibre1">When you try to force a check. You can solve it with the following procedure:</p>
<pre class="codepackt">
<strong class="calibre2">service nagios3 stop<br class="title-page-name"/></strong><strong class="calibre2">dpkg-statoverride --update --add nagios www-data 2710 /var/lib/nagios3/rw<br class="title-page-name"/></strong><strong class="calibre2">dpkg-statoverride --update --add nagios nagios 751 /var/lib/nagios3<br class="title-page-name"/></strong><strong class="calibre2">service nagios3 start</strong>
</pre>
<p class="calibre1"><span><span>If you face any issues with your plugin, enable <kbd class="calibre9">debug</kbd> mode in </span></span><kbd class="calibre9">/etc/nagios3/nagios.cfg</kbd>  by <span><span>setting the following configuration bit:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">debug_level=-1<br class="title-page-name"/></strong><strong class="calibre2">debug_verbosity=2</strong>
</pre>
<p class="calibre1"><span><span>This will generate a lot of information written in the <kbd class="calibre9">debug</kbd> file, which in our installation is in </span></span><span><span><kbd class="calibre9">/var/log/nagios3/nagios.debug</kbd> </span></span><span><span>file, which is important to understand what is going on, but they will slow down the system a bit, so we must keep the debug on only for the time it is needed, then we must revert to the normal logging.</span></span></p>
<p class="calibre1"><span><span>A Nagios reload will enforce the activation of the new configuration. But let's have a look at what the debug log has to say about our new modified command:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">[1489655900.213562] [016.0] [pid=13954] Checking service 'SSH' on host 'localhost'...<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.213602] [2320.2] [pid=13954] Raw Command Input: /usr/lib/nagios/plugins/check_ssh -p $ARG1$ -$ARG2$ -P $ARG3$ -t $ARG4$ '$HOSTADDRESS$'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.213787] [2320.2] [pid=13954] Expanded Command Output: /usr/lib/nagios/plugins/check_ssh -p $ARG1$ -$ARG2$ -P $ARG3$ -t $ARG4$ '$HOSTADDRESS$'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.213825] [2048.1] [pid=13954] Processing: '/usr/lib/nagios/plugins/check_ssh -p $ARG1$ -$ARG2$ -P $ARG3$ -t $ARG4$ '$HOSTADDRESS$''<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.213839] [2048.2] [pid=13954] Processing part: '/usr/lib/nagios/plugins/check_ssh -p '<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.213846] [2048.2] [pid=13954] Not currently in macro. Running output (37): '/usr/lib/nagios/plugins/check_ssh -p '<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.213906] [2048.2] [pid=13954] Uncleaned macro. Running output (41): '/usr/lib/nagios/plugins/check_ssh -p 1472'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.213911] [2048.2] [pid=13954] Just finished macro. Running output (41): '/usr/lib/nagios/plugins/check_ssh -p 1472'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.213921] [2048.2] [pid=13954] Not currently in macro. Running output (43): '/usr/lib/nagios/plugins/check_ssh -p 1472 -'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214051] [2048.2] [pid=13954] Uncleaned macro. Running output (44): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214064] [2048.2] [pid=13954] Just finished macro. Running output (44): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214074] [2048.2] [pid=13954] Not currently in macro. Running output (48): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P '<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214109] [2048.2] [pid=13954] Uncleaned macro. Running output (51): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214114] [2048.2] [pid=13954] Just finished macro. Running output (51): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214123] [2048.2] [pid=13954] Not currently in macro. Running output (55): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t '<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214161] [2048.2] [pid=13954] Uncleaned macro. Running output (57): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214175] [2048.2] [pid=13954] Just finished macro. Running output (57): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214200] [2048.2] [pid=13954] Not currently in macro. Running output (59): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 ''<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214263] [2048.2] [pid=13954] Uncleaned macro. Running output (68): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214276] [2048.2] [pid=13954] Just finished macro. Running output (68): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1'<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214299] [2048.2] [pid=13954] Not currently in macro. Running output (69): '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1''<br class="title-page-name"/></strong><strong class="calibre2">[1489655900.214310] [2048.1] [pid=13954] Done. Final output: '/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1''</strong>
</pre>
<p class="calibre1"><span><span>It is clear how Nagios builds up the command line piece by piece, so we can understand how it parses all our definitions and how it allocates the value we passed through the service definition itself. If we take the last row, copy and paste the command line of the final output, and execute it on the server, we are monitoring the service onto this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">/usr/lib/nagios/plugins/check_ssh -p 1472 -4 -P 2.0 -t 30 '127.0.0.1'<br class="title-page-name"/></strong><strong class="calibre2">SSH OK - OpenSSH_6.7p1 Debian-5+deb8u3 (protocol 2.0) | time=0.015731s;;;0.000000;30.000000</strong>
</pre>
<p class="calibre1"><span><span>We get the service checked, a status (<span><span>OK</span></span></span></span>)<span><span>, and performance data as well:</span></span></p>
<div class="packt_figure"><img class="image-border9" src="../images/00015.jpeg"/></div>
<div class="packt_figref"><span><span>Our SSH service check now works and we have performance data too.</span></span></div>
<p class="calibre1"><span><span>Performance data is a useful bit of information that can give you some ready-made projections on service running pattern, once you plot it on a chart. With such data and charts we can do this:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">Adopt a service capacity management strategy</strong>: Since we can easily forecast the consumption curve for a service, we can predict when it will be time to upgrade the hardware needed to provision it.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Find out usage patterns</strong>: A service can be used in a uneven pattern. For example, a company mail server is most used during office hours and less during the night or weekends; disk space for a data warehouse server is used more during the data consolidation batches than during other moments. So, a service that appears adequate while you are checking it can be under-equipped in other moments: a graph will show you how the usage curve moves over time.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Find failures at a glance</strong>: Watching at the gaps into the graph, you can easily spot service interruptions, and selecting the piece of graph you want to inspect can be exploded in detail.</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Create fancy reports for management</strong>: Seems a joke but busy management prefers to have a comprehensive glance at services than pages and pages of numeric data.</span></span></li>
</ul>
<p class="calibre1"><span><span>So, let's quickly see how to install one of this graphing tools. Since this is not a book on Nagios, we will not go into much detail, but we are going to see only what is needed to enable this third-party service and have our plugin performance data graphed.</span></span></p>
<p class="calibre1"><span><span>Let's start editing the </span></span><span><span><kbd class="calibre9">/etc/nagios3/nagios.cfg</kbd> file. </span></span></p>
<p class="calibre1"><span><span>Look for the following snippets of configuration and modify them so the final result will be this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">process_performance_data=1<br class="title-page-name"/></strong><strong class="calibre2">host_perfdata_command=process-host-perfdata<br class="title-page-name"/></strong><strong class="calibre2">service_perfdata_command=process-service-perfdata</strong>
</pre>
<p class="calibre1"><span><span>We enabled the performance processing data and defined the name of the commands, which will deal with them; the next logical step is to define the commands we just pointed out. Edit the </span></span><span><span><kbd class="calibre9">/etc/nagios3/commands.cfg</kbd> file a</span></span><span><span>nd add the following snippet:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># ‘process-host-perfdata' command definition<br class="title-page-name"/></strong><strong class="calibre2">define command{<br class="title-page-name"/></strong><strong class="calibre2">command_name process-host-perfdata<br class="title-page-name"/></strong><strong class="calibre2">command_line /usr/bin/perl /usr/lib/pnp4nagios/libexec/process_perfdata.pl -d HOSTPERFDATA<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/></strong><strong class="calibre2"># ‘process-service-perfdata' command definition<br class="title-page-name"/></strong><strong class="calibre2">define command{<br class="title-page-name"/></strong><strong class="calibre2">command_name process-service-perfdata<br class="title-page-name"/></strong><strong class="calibre2">command_line /usr/bin/perl /usr/lib/pnp4nagios/libexec/process_perfdata.pl<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<div class="packt_infobox">We are working on a Debian installation, so the paths and file names may differ when using some other distribution or installing from sources.</div>
<p class="calibre1"><span><span>Comment out any pre-existing snippets sporting </span></span><span><span><kbd class="calibre9">command_name process-host-perfdata</kbd> and </span></span><span><span><kbd class="calibre9">command_name process-service-perfdata</kbd>.</span></span></p>
<p class="calibre1"><span><span>We will use the new ones, as the old ones are useless for our purposes, so again comment them out. Now that we have the command in place and the data will be processed as intended, we have to tell Nagios how to trigger the chart visualization. So, time to edit </span></span><span><span><kbd class="calibre9">/etc/nagios3/conf.d/services_nagios2.cfg</kbd> </span></span><span><span>and modify the previously edited ssh service check configuration so that now it appears as this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># check that ssh services are running<br class="title-page-name"/></strong><strong class="calibre2">define service {<br class="title-page-name"/></strong><strong class="calibre2">hostgroup_name ssh-servers<br class="title-page-name"/></strong><strong class="calibre2">service_description SSH<br class="title-page-name"/></strong><strong class="calibre2">check_command check_ssh_arguments!1967!4!2.0!30<br class="title-page-name"/></strong><strong class="calibre2">action_url /pnp4nagios/index.php/graph?host=$HOSTNAME$&amp;srv=$SERVICEDESC$<br class="title-page-name"/></strong><strong class="calibre2">use generic-service<br class="title-page-name"/></strong><strong class="calibre2">notification_interval 0 ; set &gt; 0 if you want to be renotified<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>We added an action URL configuration line so that Nagios will draw a small clickable icon close to the service name. So, let's restart Nagios</span></span><span><span> </span></span><span><span>and go to the service page just to find out something new:</span></span></p>
<div class="packt_figure"><img class="image-border10" src="../images/00016.jpeg"/></div>
<div class="packt_figref"><span><span>Adding the action_url string to any service configurations will make this new icon appear</span></span></div>
<p class="calibre1"><span><span>The icon is clickable, so we just click it and the result is similar to the one in the next screenshot:</span></span></p>
<div class="packt_figure"><img class="image-border11" src="../images/00017.jpeg"/></div>
<div class="packt_figref"><span><span>SSH service check performance data are now graphed</span></span></div>
<p class="calibre1">From now on, our performance data will be graphed, so our Nagios environment is ready to host our first Nagios plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Our first Nagios plugin</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>It's time now to start working to our first Nagios plugin, and it does not really matter what we are going check here, since what we are interested in is how to deal with the exchange between Nagios and the plugin, more than how and what we are going to monitor. Once we are done with the script, we will be able to reuse its framework to create whatever script we want, so let's start.</span></span></p>
<p class="calibre1"><span><span>Our project involves checking the status of the local disk using the <span><span><span><strong class="calibre2">Self-Monitoring, Analysis, and Reporting Technology </strong></span></span></span></span></span>(<span><span><span><span><span><strong class="calibre2">S.M.A.R.T.</strong></span></span></span></span></span>),<span><span><span><span><span> which we can think of as a system embedded in most hard disks and solid state disks, whose task is to anticipate and prevent issues and failures. So, a plugin able to query the S.M.A.R.T. system can be used to trap some forthcoming failures, notify the user, and even take advantage of the response mechanism in Nagios to trigger some scripts or programs, for example copying all the data from the soon to fail disk to somewhere else before it get lost.</span></span></span></span></span></p>
<p class="calibre1"><span><span><span><span><span>Our first step in this project will be installing the </span></span></span></span></span><span><span><kbd class="calibre9">smartmontools</kbd> </span></span><span><span><span><span><span>package in our distribution. In Debian and Ubuntu, the package is called <kbd class="calibre9">smartmontools</kbd>; it can be different in other distribution. What we are looking for is a package holding the <kbd class="calibre9">smartctl</kbd> utility.</span></span></span></span></span></p>
<p class="calibre1"><span><span><span><span><span>This is the program our plugin will rely on, and it is the actual utility querying the for the disk information, so our first step will be to find which disks are attached to our system:</span></span></span></span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ lsblk -d<br class="title-page-name"/></strong><strong class="calibre2">sda 8:0 0 119.2G 0 disk <br class="title-page-name"/></strong><strong class="calibre2">sr0 11:0 1 1024M 0 rom</strong>
</pre>
<p class="calibre1"><span><span>Here we are; our system has one disk and its name is </span></span><span><span><kbd class="calibre9">sda</kbd>. </span></span><span><span>If we want to find out something more about our disk, we can install <kbd class="calibre9">hwinfo</kbd> and run it as root:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ hwinfo --disk<br class="title-page-name"/></strong><strong class="calibre2">27: IDE 00.0: 10600 Disk <br class="title-page-name"/></strong><strong class="calibre2">[Created at block.245]<br class="title-page-name"/></strong><strong class="calibre2">Unique ID: 3OOL.eNwxL8uda61<br class="title-page-name"/></strong><strong class="calibre2">Parent ID: w7Y8.FuT6qrC8mT0<br class="title-page-name"/></strong><strong class="calibre2">SysFS ID: /class/block/sda<br class="title-page-name"/></strong><strong class="calibre2">SysFS BusID: 0:0:0:0<br class="title-page-name"/></strong><strong class="calibre2">SysFS Device Link: /devices/pci0000:00/0000:00:1f.2/ata1/host0/target0:0:0/0:0:0:0<br class="title-page-name"/></strong><strong class="calibre2">Hardware Class: disk<br class="title-page-name"/></strong><strong class="calibre2">Model: "TS128GSSD720"<br class="title-page-name"/></strong><strong class="calibre2">Device: "TS128GSSD720"<br class="title-page-name"/></strong><strong class="calibre2">Revision: "2"<br class="title-page-name"/></strong><strong class="calibre2">Serial ID: "REDACTED"<br class="title-page-name"/></strong><strong class="calibre2">Driver: "ahci", "sd"<br class="title-page-name"/></strong><strong class="calibre2">Driver Modules: "ahci"<br class="title-page-name"/></strong><strong class="calibre2">Device File: /dev/sda<br class="title-page-name"/></strong><strong class="calibre2">Device Files: /dev/sda, /dev/disk/by-id/ata-TS128GSSD720_REDACTED<br class="title-page-name"/></strong><strong class="calibre2">Device Number: block 8:0-8:15<br class="title-page-name"/></strong><strong class="calibre2">BIOS id: 0x80<br class="title-page-name"/></strong><strong class="calibre2">Geometry (Logical): CHS 15566/255/63<br class="title-page-name"/></strong><strong class="calibre2">Size: 250069680 sectors a 512 bytes<br class="title-page-name"/></strong><strong class="calibre2">Capacity: 119 GB (128035676160 bytes)<br class="title-page-name"/></strong><strong class="calibre2">Config Status: cfg=new, avail=yes, need=no, active=unknown<br class="title-page-name"/></strong><strong class="calibre2">Attached to: #20 (SATA controller)</strong>
</pre>
<p class="calibre1"><span><span>Now that we have been introduced to our disk, we have to see if it is polite enough to answer our S.M.A.R.T requests:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ smartctl --all /dev/sda<br class="title-page-name"/></strong><strong class="calibre2">smartctl 6.4 2014-10-07 r4002 [x86_64-linux-3.16.0-4-amd64] (local build)<br class="title-page-name"/></strong><strong class="calibre2">Copyright (C) 2002-14, Bruce Allen, Christian Franke, www.smartmontools.org<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">=== START OF INFORMATION SECTION ===<br class="title-page-name"/></strong><strong class="calibre2">Model Family: SandForce Driven SSDs<br class="title-page-name"/></strong><strong class="calibre2">Device Model: TS128GSSD720<br class="title-page-name"/></strong><strong class="calibre2">Serial Number: REDACTED<br class="title-page-name"/></strong><strong class="calibre2">LU WWN Device Id: 0 023280 000000000<br class="title-page-name"/></strong><strong class="calibre2">Firmware Version: 5.0.2<br class="title-page-name"/></strong><strong class="calibre2">User Capacity: 128,035,676,160 bytes [128 GB]<br class="title-page-name"/></strong><strong class="calibre2">Sector Size: 512 bytes logical/physical<br class="title-page-name"/></strong><strong class="calibre2">Rotation Rate: Solid State Device<br class="title-page-name"/></strong><strong class="calibre2">Device is: In smartctl database [for details use: -P show]<br class="title-page-name"/></strong><strong class="calibre2">ATA Version is: ATA8-ACS, ACS-2 T13/2015-D revision 3<br class="title-page-name"/></strong><strong class="calibre2">SATA Version is: SATA 3.0, 6.0 Gb/s (current: 3.0 Gb/s)<br class="title-page-name"/></strong><strong class="calibre2">Local Time is: Fri Mar 17 16:34:30 2017 GMT<br class="title-page-name"/></strong><strong class="calibre2">SMART support is: Available - device has SMART capability.<br class="title-page-name"/></strong><strong class="calibre2">SMART support is: Enabled<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">=== START OF READ SMART DATA SECTION ===<br class="title-page-name"/></strong><strong class="calibre2">SMART overall-health self-assessment test result: PASSED<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">General SMART Values:<br class="title-page-name"/></strong><strong class="calibre2">...</strong><strong class="calibre2"><br class="title-page-name"/></strong><strong class="calibre2">Self-test execution status: (0) The previous self-test routine completed </strong><strong class="calibre2">without error or no self-test has ever </strong><strong class="calibre2">been run.<br class="title-page-name"/></strong><strong class="calibre2">...</strong><strong class="calibre2"><br class="title-page-name"/></strong><strong class="calibre2">SMART Attributes Data Structure revision number: 10<br class="title-page-name"/></strong><strong class="calibre2">Vendor Specific SMART Attributes with Thresholds:<br class="title-page-name"/></strong><strong class="calibre2">ID# ATTRIBUTE_NAME FLAG VALUE WORST THRESH TYPE UPDATED WHEN_FAILED RAW_VALUE<br class="title-page-name"/></strong><strong class="calibre2">...</strong><strong class="calibre2"><br class="title-page-name"/></strong><strong class="calibre2">SMART Error Log not supported<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">SMART Self-test Log not supported<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">SMART Selective self-test log data structure revision number 1<br class="title-page-name"/></strong><strong class="calibre2">SPAN MIN_LBA MAX_LBA CURRENT_TEST_STATUS<br class="title-page-name"/></strong><strong class="calibre2">...<br class="title-page-name"/></strong><strong class="calibre2">Selective self-test flags (0x0):<br class="title-page-name"/></strong><strong class="calibre2">After scanning selected spans, do NOT read-scan remainder of disk.<br class="title-page-name"/></strong><strong class="calibre2">If Selective self-test is pending on power-up, resume after 0 minute delay.</strong>
</pre>
<p class="calibre1"><span><span>That is a lot of information taken from you hard disk and, bottom line, most of it is useless to you. For the sake of our little project, we will take just a little information into account and this is here:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">SMART overall-health self-assessment test result: PASSED<br class="title-page-name"/></strong><strong class="calibre2">194 Temperature_Celsius 0x0022 036 060 000 Old_age Always - 36 (Min/Max 12/60)<br class="title-page-name"/></strong><strong class="calibre2">Self-test execution status: ( 0) The previous self-test routine completed</strong>
</pre>
<p class="calibre1"><span><span>So, our plugin will take just these three pieces of information into account with three different thresholds:</span></span></p>
<table class="table">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1"><strong class="calibre2">Control</strong></p>
</td>
<td class="calibre8">
<p class="calibre1"><strong class="calibre2">OK</strong></p>
</td>
<td class="calibre8">
<p class="calibre1"><strong class="calibre2">WARNING</strong></p>
</td>
<td class="calibre8">
<p class="calibre1"><strong class="calibre2">CRITICAL</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1">SMART overall-health self-assessment test result</p>
</td>
<td class="calibre8">
<p class="calibre1">PASSED</p>
</td>
<td class="calibre8"/>
<td class="calibre8">
<p class="calibre1">!CRITICAL</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1">Temperature</p>
</td>
<td class="calibre8">
<p class="calibre1">40:</p>
</td>
<td class="calibre8">
<p class="calibre1">@41:49</p>
</td>
<td class="calibre8">
<p class="calibre1">:50</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre1">Self-test execution status</p>
</td>
<td class="calibre8">
<p class="calibre1">0</p>
</td>
<td class="calibre8"/>
<td class="calibre8">
<p class="calibre1">!0</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre1"> </p>
<p class="calibre1"><span><span>We start planning our script. For the <kbd class="calibre9">overall-health</kbd>, we have an OK value, but no <span>WARNING</span> since whatever value we have different from <kbd class="calibre9">PASSED</kbd> means to us a critical situation. For the temperature, we can adjust the threshold to our working environment. Usually a value up to 40 degrees Celsius is considered optimal. From 41 to 50 is deemed acceptable, meaning it can cause some damage to the disk in the long run, so we are in a <span>WARNING</span> condition--not yet</span></span> lethal, <span><span>but we must keep an eye on it.</span></span></p>
<p class="calibre1"><span><span>Everything from 50 Celsius and above is considered extremely dangerous to the health of your disk, so we shall trigger a CRITICAL condition and have someone to react as soon as possible. <kbd class="calibre9">Self-test execution status</kbd> tells us if the last self test on the drive was successful or completed with errors, and so anything other than 0 (successful) will trigger a critical condition.</span></span></p>
<p class="calibre1"><span><span>We identified the information that will trigger the status in Nagios; we planned our threshold, now before actually writing the plugin we need to find a way to reliably collect the data that will be evaluated against the threshold. Here some regular expressions will come in handy, so let's start with the overall health, calling the  <kbd class="calibre9">smartcl</kbd> utility with a filter:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ smartctl --all /dev/sda | grep -i overall-health | awk '{print $6}'<br class="title-page-name"/></strong><strong class="calibre2">PASSED</strong>
</pre>
<p class="calibre1"><span><span>This simple one liner gets the full output from <kbd class="calibre9">smartctl</kbd>, then pipes it to the input of <kbd class="calibre9">grep</kbd>, which selects and outputs only the line containing the words <kbd class="calibre9">overall-health</kbd>. The output is finally passed to <kbd class="calibre9">awk</kbd>, which takes the input and</span></span> divides<span><span> it into columns, each field separated by blanks, and then prints out the sixth field, which shows <kbd class="calibre9">PASSED</kbd>. Then something like this would trap the result of the overall check:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ H_CHECK=$(smartctl --all /dev/sda | grep -i overall-health | awk '{print $6}')</strong>
</pre>
<p class="calibre1"><span><span>In fact, we can double-check this with the following line:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ H_CHECK=$(smartctl --all /dev/sda | grep overall-health | awk '{print $6}') ; echo $H_CHECK<br class="title-page-name"/></strong><strong class="calibre2">PASSED</strong>
</pre>
<p class="calibre1"><span><span>That is, the command substitution got the output of the whole command line into the <kbd class="calibre9">H_CHECK</kbd> variable, and we could print it too.</span></span></p>
<p class="calibre1"><span><span>One recommendation here. When it comes to variables, you can use whatever notation you want, it is up to you, but bear in mind some rules of thumb:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span><strong class="calibre2">Keep the variable name short and meaningful</strong></span></span>:<span><span><strong class="calibre2"> </strong>A variable name like <kbd class="calibre9">THIS_IS_THE.OVER-ALL.RESULT</kbd> will clutter your code, so <kbd class="calibre9">H_HEALTH</kbd> is compact and meaningful</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Use lower, capital, or camelcase like <kbd class="calibre9">OverAllHealth</kbd>, but be consistent with your choice</strong></span></span>:<span><span><strong class="calibre2"> </strong>Stick to whatever you chose throughout your script, so it will be easier to identify variables in your code</span></span></li>
<li class="calibre13"><span><span><strong class="calibre2">Do not use keywords, utility of built-in names, or anything reserved for your variable names</strong></span></span>:<span><span><strong class="calibre2"> </strong>It will make your script unreliable</span></span></li>
</ul>
<p class="calibre1"><span><span>Now it is time to get the value of the temperature in our disk:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ smartctl --all /dev/sda | grep -i Temperature | awk '{print $10}'<br class="title-page-name"/></strong><strong class="calibre2">35</strong>
</pre>
<p class="calibre1"><span><span>So, let's get this into a variable:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ T_CHECK=$(smartctl --all /dev/sda | grep -i Temperature | awk '{print $10}') ; echo $T_CHECK<br class="title-page-name"/></strong><strong class="calibre2">35</strong>
</pre>
<p class="calibre1"><span><span>Finally, we have to check for</span></span> <kbd class="calibre9">Self-test execution status</kbd><span><span>:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ smartctl --all /dev/sda | grep -i "Self-test execution status" | awk '{print $5}' | tr -d ")"</strong>
</pre>
<p class="calibre1"><span><span>And trap the resulting value in a variable:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">S_CHECK=$(smartctl --all /dev/sda | grep -i "Self-test execution status" | awk '{print $5}' | tr -d ")") ; echo $S_CHECK<br class="title-page-name"/></strong><strong class="calibre2">0</strong>
</pre>
<p class="calibre1"><span><span>Now that we have a way to gather the information we want, it is time to put some boundaries on our investigations. What if the disk does not exist? What if it does not support S.M.A.R.T.? And our script will need to call <kbd class="calibre9">smartctl</kbd> as root, so we will get advantage of <kbd class="calibre9">sudo</kbd> to ease the process. So, let's start with the first lines of the script, which holds the sha-bang, license, author, and first variables. Remember to change the code to whatever suits you:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">#!/bin/bash<br class="title-page-name"/></strong><strong class="calibre2"># License: GPL<br class="title-page-name"/></strong><strong class="calibre2">#<br class="title-page-name"/></strong><strong class="calibre2"># Author: Giorgio Zarrelli &lt;zarrelli@linux.it&gt;<br class="title-page-name"/></strong><strong class="calibre2">#<br class="title-page-name"/></strong><strong class="calibre2"># This program is free software; you can redistribute it and/or modify<br class="title-page-name"/></strong><strong class="calibre2"># it under the terms of the GNU General Public License version 2 as<br class="title-page-name"/></strong><strong class="calibre2"># published by the Free Software Foundation.<br class="title-page-name"/></strong><strong class="calibre2">#<br class="title-page-name"/></strong><strong class="calibre2"># This program is distributed in the hope that it will be useful,<br class="title-page-name"/></strong><strong class="calibre2"># but WITHOUT ANY WARRANTY; without even the implied warranty of<br class="title-page-name"/></strong><strong class="calibre2"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br class="title-page-name"/></strong><strong class="calibre2"># GNU General Public License for more details.<br class="title-page-name"/></strong><strong class="calibre2">#<br class="title-page-name"/></strong><strong class="calibre2"># You should have received a copy of the GNU General Public License<br class="title-page-name"/></strong><strong class="calibre2"># along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br class="title-page-name"/></strong><strong class="calibre2">#</strong>
</pre>
<p class="calibre1"><span><span>This is the sha-bang and a licence with author, nothing special, so let's move on:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">SMARTCTL="/usr/sbin/smartctl"</strong>
</pre>
<p class="calibre1"><span><span>Since the path for each utility we use the command substitution with which: this latter will give us back the path to the utility. The only drawback is that it will give no path if the utility is not in the <kbd class="calibre9">$PATH</kbd> environment of the user, but this is not a big deal except for <kbd class="calibre9">smartctl</kbd>, which is not in<kbd class="calibre9">$PATH</kbd> ; we just give the full path manually. We do not check <kbd class="calibre9">echo</kbd> command, since it is a built-in:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Nagios return codes<br class="title-page-name"/></strong><strong class="calibre2">STATE_OK=0<br class="title-page-name"/></strong><strong class="calibre2">STATE_WARNING=1<br class="title-page-name"/></strong><strong class="calibre2">STATE_CRITICAL=2<br class="title-page-name"/></strong><strong class="calibre2">STATE_UNKNOWN=3</strong>
</pre>
<p class="calibre1"><span><span>Who remembers the correct status codes returned by a Nagios plugin? Better have them stored in some handy variables:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Default WARNING and CRITICAL values<br class="title-page-name"/></strong><strong class="calibre2">WARNING_THRESHOLD=${WARNING_THRESHOLD:=41}<br class="title-page-name"/></strong><strong class="calibre2">CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=50}</strong>
</pre>
<p class="calibre1"><span><span>Now, a bit of a caution. If the script does not receive a value for the <span>WARNING</span> and <span>CRITICAL</span> thresholds, it will be assigned automatically from a predefined value.</span></span></p>
<p class="calibre1"><span><span>Now that we have some headings in place, let's check if our utilities are correctly pointed to by the variables:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Check if we have all the system tools we need<br class="title-page-name"/></strong><strong class="calibre2">path_exists()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">for i in "$@"<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">if [ -e "$i" ];<br class="title-page-name"/></strong><strong class="calibre2">then <br class="title-page-name"/></strong><strong class="calibre2">echo "$i is a valid path"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "$i is not reachable, is this the correct path?"<br class="title-page-name"/></strong><strong class="calibre2">exit 1<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/></strong><strong class="calibre2">path_exists "$SMARTCTL"</strong>
</pre>
<p class="calibre1"><span><span>This is the first function of our script, and its job is quite straightforward: it checks if the path pointed by <kbd class="calibre9">#SMARTCTL</kbd> leads to a file; if not, it prints a <span>WARNING</span> message and exits with an error. In our prototype, we print a message even if the path is valid, but in the final stage, we will put a debug condition to activate or deactivate this kind of extra message, since Nagios does not accept such a message. We will also have a debug option that will make visible the inner computation of our script, if needed. Let's test what's done so far, making the script executable and running:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">/bin/echo is a valid path<br class="title-page-name"/></strong><strong class="calibre2">/usr/sbin/smartctl is a valid path</strong>
</pre>
<p class="calibre1"><span><span>Now let's check adding two fake variables to the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">TEST1=""<br class="title-page-name"/></strong><strong class="calibre2">TEST2="/blah/blah"</strong>
</pre>
<p class="calibre1"><span><span>Now let's check again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">path_exists "$SMARTCTL" "TEST1" "TEST2"</strong>
</pre>
<p class="calibre1"><span><span>And then run the script again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">/bin/echo is a valid path<br class="title-page-name"/></strong><strong class="calibre2">/usr/sbin/smartctl is a valid path<br class="title-page-name"/></strong><strong class="calibre2">TEST1 is not reachable, is this the correct path?</strong>
</pre>
<p class="calibre1"><span><span>The script exits at the first variable that does not hold a correct path to a file, so let's delete it, remove it from the function, and run the script again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./check_my_smart.sh ; echo $?<br class="title-page-name"/></strong><strong class="calibre2">/bin/echo is a valid path<br class="title-page-name"/></strong><strong class="calibre2">/usr/sbin/smartctl is a valid path<br class="title-page-name"/></strong><strong class="calibre2">TEST2 is not reachable, is this the correct path?<br class="title-page-name"/></strong><strong class="calibre2">1</strong>
</pre>
<p class="calibre1"><span><span>Again, the script exits at the first variable met that does not hold a path to a file with an error code; and we printed it on the standard out. This behavior suits us since we want the script to stop its execution if something prevents it from running correctly, and we want meaningful advice, so we can amend it using the hints it provides. We do not need fake variables anymore, so let's clear them out.</span></span></p>
<p class="calibre1"><span><span>Next, check whether the disk we are inspecting really exists, so let's add some more stuff to our script. First, a variable to hold the path to the disk we want to monitor:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Disk to check<br class="title-page-name"/></strong><strong class="calibre2">DISK=${DISK:="/dev/sda"}</strong>
</pre>
<p class="calibre1"><span><span>Then, let's check if the path we just specified leads to a real block device:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Check for the path to bring us to a block device with SMART capability<br class="title-page-name"/></strong><strong class="calibre2">disk_exists()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">if [ -b "$DISK" ] <br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "$DISK is a block device"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "$DISK does not point a block device"<br class="title-page-name"/></strong><strong class="calibre2">fi <br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>A simple file test on the path tells us whether this is a block device or not. Is it enough just to know if a path leads to a block device? No, because a disk is a block device, but a block device is not necessarily a disk, it can be a tape drive for instance. Anyway, we do not need a specific test looking for a disk, since the next function will check S.M.A.R.T. capabilities for the device. Only a S.M.A.R.T.-enabled hard disk will pass this test, and no other kinds of block device have this capability, so here we will sort out which is which. Before proceeding, let's write a verbosity switch for our functions so that we will be able to print informative messages on <kbd class="calibre9">stdout</kbd>. Let's start creating a variable, which will hold the status value for the verbosity switch:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Enable verbose; 0 for disabled, 1 for enabled<br class="title-page-name"/></strong><strong class="calibre2">VERB=${VERB:=1}</strong>
</pre>
<p class="calibre1"><span><span>And now, let's rewrite the <kbd class="calibre9">path_exists</kbd> function:</span></span></p>
<pre class="codepackt">
path_exists()<br class="title-page-name"/>{<br class="title-page-name"/>for i in "$@"<br class="title-page-name"/>do<br class="title-page-name"/>if [ -e "$i" ];<br class="title-page-name"/>then <br class="title-page-name"/>(( VERB )) &amp;&amp; echo "$i is a valid path"<br class="title-page-name"/>:<br class="title-page-name"/>else<br class="title-page-name"/>if (( VERB ));<br class="title-page-name"/>then<br class="title-page-name"/>echo "$i is not reachable, is this the correct path?"<br class="title-page-name"/>exit 1<br class="title-page-name"/>fi<br class="title-page-name"/>fi<br class="title-page-name"/>done<br class="title-page-name"/>}
</pre>
<p class="calibre1"><span><span>Well, time to test the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">/bin/echo is a valid path<br class="title-page-name"/></strong><strong class="calibre2">/usr/sbin/smartctl is a valid path<br class="title-page-name"/></strong><strong class="calibre2">/dev/sda is a block device</strong>
</pre>
<p class="calibre1"><span><span>All the messages are printed out, but what happens if we change the value of verbosity to <kbd class="calibre9">0</kbd> like </span></span><span><span><kbd class="calibre9">VERB=${VERB:=0}</kbd>? </span></span></p>
<p class="calibre1"><span><span>Let's call the script again:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">zarrelli:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">/dev/sda is a block device</strong>
</pre>
<p class="calibre1"><span><span>All the messages from the <kbd class="calibre9">path_exists</kbd> function are now silenced. How did we do it? Simply using the the arithmetic <kbd class="calibre9">(( ))</kbd> operator, which returns true as exit status if it evaluates to a non-zero value. We used two different ways to manage the verbosity:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">(( VERB )) &amp;&amp; echo "$i is a valid path"</strong>
</pre>
<p class="calibre1"><span><span>This compact notation has a smaller impact on the flow of our script and is prefered when we have to execute a short list of commands. In this case, if <kbd class="calibre9">$VERB</kbd> evaluates to not zero, a simple echo is executed, so this notation fits the case. When we have to execute a longer list of commands, we can choose a more readable notation:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">if (( VERB ));<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "$i is not reachable, is this the correct path?"<br class="title-page-name"/></strong><strong class="calibre2">command_2<br class="title-page-name"/></strong><strong class="calibre2">command_n<br class="title-page-name"/></strong><strong class="calibre2">fi</strong>
</pre>
<p class="calibre1"><span><span>In this case, we can append more commands under the echo, and they all will be executed if <kbd class="calibre9">$VERB</kbd> evaluates to a non-zero value: cascading more commands on a list will make the code more readable and easy to maintain. But, well, the second verbose switch is not really useful because that part of the code traps an issue and comes into play when the path does not point to a file, and we always want to see an error message when we have an issue, regardless of the verbosity.</span></span></p>
<p class="calibre1"><span><span>So, clear it out, as it was just an example:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">if (( VERB ));<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "$i is not reachable, is this the correct path?"<br class="title-page-name"/></strong><strong class="calibre2">fi</strong>
</pre>
<p class="calibre1"><span><span>Now, let's add the verbosity switch to the <kbd class="calibre9">disk_exists</kbd> function:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">disk_exists()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">if [ -b "$DISK" ] <br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">(( VERB )) &amp;&amp; echo "$DISK is a block device"<br class="title-page-name"/></strong><strong class="calibre2">:<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "$DISK does not point a block device"<br class="title-page-name"/></strong><strong class="calibre2">exit 1<br class="title-page-name"/></strong><strong class="calibre2">fi <br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>Notice (<kbd class="calibre9">:</kbd>) in the code. It is a placeholder for us to fill in with a S.M.A.R.T. capability checking code. As of now, if the path leads to a block device, the script does nothing (<kbd class="calibre9">:</kbd>). How do we check if a device is S.M.A.R.T. enabled? We can rely on the <kbd class="calibre9">smartctl</kbd> output:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ smartctl -a /dev/sda | grep "^SMART support is:"<br class="title-page-name"/></strong><strong class="calibre2">SMART support is: Available - device has SMART capability.<br class="title-page-name"/></strong><strong class="calibre2">SMART support is: Enabled</strong>
</pre>
<p class="calibre1"><span><span>Great, the output of <kbd class="calibre9">smartctl</kbd> sports two lines, on one we have the info about whether the device has S.M.A.R.T. capability or not and the second informs us whether it is enabled or not.</span></span></p>
<p class="calibre1"><span>Be wary while working with the output of a command: it can change upon different versions, so always check first the full output of the command itself before trying to trap some information.</span></p>
<p class="calibre1"><span><span>Once we know where to look, it is just a simple matter to trap the bits of information we want:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ SMART=$(smartctl -a /dev/sda | grep "^SMART support is:" | awk '{print $4}') ; echo $SMART<br class="title-page-name"/></strong><strong class="calibre2">Available Enabled</strong>
</pre>
<p class="calibre1"><span><span>Cutting the output of <kbd class="calibre9">smartctl</kbd> and grabbing the content of the fourth field only gave us the two keywords we were looking for:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">Available<br class="title-page-name"/></strong><strong class="calibre2">Enabled</strong>
</pre>
<p class="calibre1"><span><span>Both of them must be in the output for our check to pass, so let's rewrite the first part of our script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Retrieve the full path to the system utilities <br class="title-page-name"/></strong><strong class="calibre2">AWK=$(which awk)<br class="title-page-name"/></strong><strong class="calibre2">ECHO=$(which echo)<br class="title-page-name"/></strong><strong class="calibre2">GREP=$(which grep)<br class="title-page-name"/></strong><strong class="calibre2">SMARTCTL="/usr/sbin/smartctl"<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># AWK field to print<br class="title-page-name"/></strong><strong class="calibre2">A_FIELD='{print $4}'</strong>
</pre>
<p class="calibre1"><span><span>We will make use of <kbd class="calibre9">awk</kbd> and <kbd class="calibre9">grep</kbd>, so we added them to a couple of handy variables. Notice that we are parsing the output of the utility (<kbd class="calibre9">smartctl</kbd>) and this can change in the future releases of the program, so we store in variables the fields we are working on. This way, if the output-related keywords change, we will modify them just once in our script. Now, just before the <kbd class="calibre9">disk_exists</kbd> function, we create a new code snippet:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">smart_enabled()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2"> SMART=($($SMARTCTL -a "$1" | "$GREP" "$IS_SMART" | "$AWK" "$A_FIELD"))<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>We are just putting in a function that we did on the command line, but now, we store the output into an array. We start with simple constructs and check whether they work correctly. Once we are confident, we move to more complex solutions. Now, we must call the function with an argument; let's do it at the end of the script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">path_exists "$SMARTCTL"<br class="title-page-name"/></strong><strong class="calibre2">disk_exists "$DISK"<br class="title-page-name"/></strong><strong class="calibre2">smart_enabled "$DISK"</strong>
</pre>
<p class="calibre1"><span><span>So far, so good. Our script is grabbing the two keywords we were looking for. Now, we can go further and work on the keyword so that if they are not in the output of <kbd class="calibre9">smartctl</kbd>, our script will exit with an error; and we start adding something at the beginning of our script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># SMART CAPABILITY INDICATOR<br class="title-page-name"/></strong><strong class="calibre2">IS_SMART="^SMART support is:"<br class="title-page-name"/></strong><strong class="calibre2">SMART_IND=(Available Enabled)</strong>
</pre>
<p class="calibre1"><span><span>The <kbd class="calibre9">SMART_IND</kbd> array contains the keyword we need to trap to be sure we have a drive with S.M.A.R.T. capabilities, so now we have to craft our function to take an advantage of this new array:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">smart_enabled()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">SMART=($($SMARTCTL -a "$1" | "$GREP" "$IS_SMART" | "$AWK" "$A_FIELD"))<br class="title-page-name"/></strong><strong class="calibre2">for i in "${SMART[@]}"<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">for j in "${SMART_IND[@]}"<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">if [[ "$i" == "$j" ]];<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">(( COUNTER++ ))<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">if (( COUNTER != ${#SMART_IND[@]} ))<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">ALT_SMART="$($SMARTCTL -a "$1" | "$GREP" "$ALT_IS_SMART")"</strong><strong class="calibre2">             if ! [[ -z $ALT_SMART ]]<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">(( VERB )) &amp;&amp; echo "$DISK has SMART capability"</strong><strong class="calibre2">                       smart_check "$B_SEL" "$DISK"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">(( VERB )) &amp;&amp; echo "Check the device, it seems it does not support SMART"<br class="title-page-name"/></strong><strong class="calibre2">(( VERB )) &amp;&amp; echo "The counter matched: $COUNTER times"</strong><strong class="calibre2">            echo<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_UNKNOWN"<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">(( VERB )) &amp;&amp; echo "$DISK has SMART capability"</strong><strong class="calibre2">                  smart_check "$B_SEL" "$DISK"<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1">So, basically we grep the output of <kbd class="calibre9">smartctl</kbd> on the <kbd class="calibre9">IS_SMART</kbd> value, then hold the results in the <kbd class="calibre9">IS_SMART</kbd> array. We have two nested loops: the outer cycles through the values of <kbd class="calibre9">IS_SMART</kbd> and the inner through the values of <kbd class="calibre9">SMART_IND</kbd>. Every time two indicators match, a counter is incremented. At the end of the loop, if the counter is not equal to the length of <kbd class="calibre9">SMART_IND</kbd>, we know that we could not match the exact number of indicators. In some cases, you will not have that nice smart support string, so we can use an alternative indicator to match, in case the first string is not shown:</p>
<pre class="codepackt">
<strong class="calibre2">ALT_IS_SMART="=== START OF SMART DATA SECTION ==="</strong>
</pre>
<p class="calibre1">Maybe less, maybe more, better to exit with an error and check.</p>
<p class="calibre1"><span><span>Now, let's see what happens if we run this script on a system with a disk, which does not support SMART:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">/bin/echo is a valid path<br class="title-page-name"/></strong><strong class="calibre2">/usr/sbin/smartctl is a valid path<br class="title-page-name"/></strong><strong class="calibre2">/dev/sda is a block device<br class="title-page-name"/></strong><strong class="calibre2">Check the device, it seems it does not support SMART<br class="title-page-name"/></strong><strong class="calibre2">The counter matched: 0 times</strong>
</pre>
<p class="calibre1"><span><span>Fair enough, when the script detects no SMART capabilities, it exits cleanly giving us a meaningful message. Now, since the smart check can be carried on only if there is a valid disk, we will call the <kbd class="calibre9">smart_enabled</kbd> function from inside the <kbd class="calibre9">disk_exists</kbd> function. So, let's move the <kbd class="calibre9">smart_enabled</kbd> function call from the bottom of our script to the <kbd class="calibre9">disk_exists</kbd> function:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">disk_exists()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">if [ -b "$DISK" ] <br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">(( VERB )) &amp;&amp; echo "$DISK is a block device"<br class="title-page-name"/></strong><strong class="calibre2">smart_enabled "$DISK"<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "$DISK does not point a block device"<br class="title-page-name"/></strong><strong class="calibre2">exit 1<br class="title-page-name"/></strong><strong class="calibre2">fi <br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span>To be available inside the <kbd class="calibre9">disk_exists</kbd> function, the <kbd class="calibre9">smart_enable</kbd> function must be defined beforehand.</span></p>
<p class="calibre1"><span><span>We made a good amount of checks, now it is time to create our check function, which will deal with three different times of measurements:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span>Overall health</span></span></li>
<li class="calibre13"><span><span>Temperature</span></span></li>
<li class="calibre13"><span><span>Self-test</span></span></li>
</ul>
<p class="calibre1"><span><span>So, our function must accept at least three parameters:</span></span></p>
<ul class="calibre12">
<li class="calibre13"><span><span>The type of check</span></span></li>
<li class="calibre13"><span><span>Warning threshold</span></span></li>
<li class="calibre13"><span><span>Critical threshold</span></span></li>
</ul>
<p class="calibre1"><span><span>Let's start with something easy, implementing just the overall-check monitoring, starting with some new variables:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># AWK field to print<br class="title-page-name"/></strong><strong class="calibre2">A_FIELD='{print $4}'<br class="title-page-name"/></strong><strong class="calibre2">H_FIELD='{print $6}'<br class="title-page-name"/></strong><strong class="calibre2"># SMART check keywords<br class="title-page-name"/></strong><strong class="calibre2">H_KEY="overall-health"<br class="title-page-name"/></strong><strong class="calibre2"># SMART matches<br class="title-page-name"/></strong><strong class="calibre2">H_MATCH="PASSED"<br class="title-page-name"/></strong><strong class="calibre2">Now, just before the smart_enabled function, let's create a new function:<br class="title-page-name"/></strong><strong class="calibre2">smart_check()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">H_CHECK=$($SMARTCTL -a "$1" | "$GREP" "$H_KEY" | "$AWK" "$H_FIELD")<br class="title-page-name"/></strong><strong class="calibre2">if [[ "$H_CHECK" == "$H_MATCH" ]];<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART OK: Overall-health check $H_MATCH"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_OK"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART CRITICAL: Overall-health check NOT $H_MATCH"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_CRITICAL"<br class="title-page-name"/></strong><strong class="calibre2">fi <br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>Nothing really difficult, we just grep the output, put it into a variable, and see whether it matches our anchor (</span></span><kbd class="calibre9">PASSED</kbd><span><span>). If it does, the script exits with a <kbd class="calibre9">STATE_OK</kbd> value, and if not, it throws <kbd class="calibre9">STATE_CRITICAL</kbd>. Let's have a look, but change the verbosity to <kbd class="calibre9">0</kbd> beforehand:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ ./check_my_smart.sh<br class="title-page-name"/></strong><strong class="calibre2">SMART OK: Overall-health check PASSED</strong>
</pre>
<p class="calibre1"><span><span>This is an acceptable plugin response, and if we passed this to Nagios, it would show a green OK field on the web UI, so we reached a milestone: we have our first good plugin reply. Now, since all the errors must be trapped by Nagios, let's allocats </span></span><span><span><kbd class="calibre9">exit 1</kbd> </span></span><span><span>with this: </span></span></p>
<pre class="codepackt">
<strong class="calibre2">echo “SMART UNKNOWN: Please check the plugin”<br class="title-page-name"/></strong><strong class="calibre2">exit “$STATE_UNKNOWN”</strong>
</pre>
<p class="calibre1"><span><span>So, all the previous error message must now become optional like in the <kbd class="calibre9">path_exists()</kbd> function: </span></span></p>
<pre class="codepackt">
<strong class="calibre2">path_exists()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">for i in "$@"<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">if [ -e "$i" ];<br class="title-page-name"/></strong><strong class="calibre2">then <br class="title-page-name"/></strong><strong class="calibre2">(( VERB )) &amp;&amp; echo "$i is a valid path"<br class="title-page-name"/></strong><strong class="calibre2">disk_exists "$DISK"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">(( VERB )) &amp;&amp; echo "$i is not reachable, is this the correct path?"<br class="title-page-name"/></strong><strong class="calibre2">echo “SMART UNKNOWN: Please check the plugin”<br class="title-page-name"/></strong><strong class="calibre2">echo “SMART UNKNOWN: Please check the plugin”<br class="title-page-name"/></strong><strong class="calibre2">exit “$STATE_UNKNOWN”<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">done<br class="title-page-name"/></strong><strong class="calibre2">} </strong>
</pre>
<p class="calibre1"><span><span>We can see a slight change in the function; since we called <kbd class="calibre9">disk_exists</kbd> from inside <kbd class="calibre9">path_exists()</kbd>, we chained the functions so that when we have a successful outcome, we call the next function in a row.</span></span></p>
<p class="calibre1"><span><span>Great, we have a function to check the <kbd class="calibre9">overall-health</kbd> parameter, and it also gives us a correct Nagios message and exit code; but this is one out of three possible checks, so we have to make this one element in our series. So, what should we do if we want to make this a part of a wider range of tests? Since these are three checks only, we can easily group them in a <kbd class="calibre9">if/then/elif/fi</kbd> construct, but let's start with a new variable:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># BRANCH selector<br class="title-page-name"/></strong><strong class="calibre2">B_SEL=${B_SEL:="HEALTH"}</strong>
</pre>
<p class="calibre1"><span><span>This is a branch selector; if we do not specify anything, it will take the value of <kbd class="calibre9">HEALTH</kbd> and trigger one of the three checks; now let's see the new code:</span></span></p>
<pre class="codepackt">
smart_check()<br class="title-page-name"/>{<br class="title-page-name"/>if (("$#" != 2));<br class="title-page-name"/>then<br class="title-page-name"/>echo<br class="title-page-name"/>exit "$STATE_UNKNOWN"<br class="title-page-name"/>else<br class="title-page-name"/>if [[ "$1" == "HEALTH" ]];<br class="title-page-name"/>then<br class="title-page-name"/>H_CHECK=$($SMARTCTL -a "$2" | "$GREP" "$H_KEY" | "$AWK" "$H_FIELD")    if [[ "$H_CHECK" == "$H_MATCH" ]];<br class="title-page-name"/>then<br class="title-page-name"/>echo "SMART OK: Overall-health check $H_MATCH"<br class="title-page-name"/>exit "$STATE_OK"<br class="title-page-name"/>else<br class="title-page-name"/>echo "SMART CRITICAL: Overall-health check NOT $H_MATCH"<br class="title-page-name"/>exit "$STATE_CRITICAL"<br class="title-page-name"/>fi<br class="title-page-name"/>elif [[ "$1" == "TEMPERATURE" ]];<br class="title-page-name"/>then<br class="title-page-name"/>if (( $(echo "scale=2; "$WARNING_THRESHOLD" &gt;= "$CRITICAL_THRESHOLD"" | $BC ) )) ;<br class="title-page-name"/>then<br class="title-page-name"/>echo "SMART UNKNOWN: The value of WARNING ($WARNING_THRESHOLD) must be lower than CRITICAL ($CRITICAL_THRESHOLD)"                            exit "$STATE_UNKNOWN"<br class="title-page-name"/>else<br class="title-page-name"/>T_CHECK=$($SMARTCTL -a "$2" | "$GREP" "$T_KEY" | "$AWK" "$T_FIELD")   if ! [[ "$T_CHECK" = *[[:digit:]]* ]];<br class="title-page-name"/>then<br class="title-page-name"/>echo "SMART UNKNOWN: The $T_KEY check is not available on $DISK"<br class="title-page-name"/>exit "$STATE_UNKNOWN"<br class="title-page-name"/>fi<br class="title-page-name"/>if (( T_CHECK &lt; WARNING_THRESHOLD ));<br class="title-page-name"/>then<br class="title-page-name"/>echo "SMART OK: Temperature is $T_CHECK | TEMP=$T_CHECK"<br class="title-page-name"/>exit "$STATE_OK"<br class="title-page-name"/>elif (( T_CHECK &lt; CRITICAL_THRESHOLD ));<br class="title-page-name"/>then<br class="title-page-name"/>echo "SMART WARNING: Temperature is $T_CHECK | TEMP=$T_CHECK"<br class="title-page-name"/>exit "$STATE_WARNING"<br class="title-page-name"/>else<br class="title-page-name"/>echo "SMART CRITICAL: Temperature is $T_CHECK | TEMP=$T_CHECK"<br class="title-page-name"/>exit "$STATE_CRITICAL"<br class="title-page-name"/>fi<br class="title-page-name"/>fi<br class="title-page-name"/>elif [[ "$1" == "SELFCHECK" ]];<br class="title-page-name"/>then<br class="title-page-name"/>S_CHECK=$($SMARTCTL -a "$2" | "$GREP" "$S_KEY" | "$AWK" "$S_FIELD" | "$TR" -d "$S_DEL")<br class="title-page-name"/>if ! [[ "$S_CHECK" = *[[:digit:]]* ]];                               then<br class="title-page-name"/>echo "SMART UNKNOWN: The $S_KEY check is not available on $DISK"<br class="title-page-name"/>exit "$STATE_UNKNOWN"<br class="title-page-name"/>fi<br class="title-page-name"/>if (( S_CHECK == S_MATCH ));<br class="title-page-name"/>then<br class="title-page-name"/>echo "SMART OK: Overall-health check $S_MATCH"<br class="title-page-name"/>exit "$STATE_OK"<br class="title-page-name"/>else<br class="title-page-name"/>echo "SMART CRITICAL: Overall-health check NOT $S_MATCH"<br class="title-page-name"/>exit "$STATE_CRITICAL"<br class="title-page-name"/>fi<br class="title-page-name"/>else<br class="title-page-name"/>echo<br class="title-page-name"/>exit "$STATE_UNKNOWN"<br class="title-page-name"/>fi<br class="title-page-name"/>fi<br class="title-page-name"/>}
</pre>
<p class="calibre1"><span><span>The new code checks for how many arguments have been passed as input, if they are not exactly two, it throws an error and exit with  <kbd class="calibre9">STATE_UNKNOWN</kbd>. If we have two arguments, then it goes on checking if the first argument is a function selector and what its value. We filled in just the first function, created some placeholders for the other two, and got a catchall in case none of the acceptable values for a function selector have been entered.</span></span></p>
<p class="calibre1"><span><span>We can now proceed with the self-check function, which is quite similar to the <kbd class="calibre9">overall-health</kbd>, but first some variables:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">TR=$(which tr)<br class="title-page-name"/></strong><strong class="calibre2">S_FIELD='{print $5}'<br class="title-page-name"/></strong><strong class="calibre2">S_KEY="Self-test execution status"<br class="title-page-name"/></strong><strong class="calibre2">S_MATCH=0</strong>
</pre>
<p class="calibre1"><span><span>You can already figure out what these are used for; we just to have to keep in mind we are using a lot of variable to customize the commands as much as we can, since we are working with a utility output, and this output can change from version to version. It usually stays quite the same over minor releases, but by using plenty of variable, we will be able to modify our script quickly if needed:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">eelif [[ "$1" == "SELFCHECK" ]];<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">S_CHECK=$($SMARTCTL -a "$2" | "$GREP" "$S_KEY" | "$AWK" "$S_FIELD" | "$TR" -d "$S_DEL")<br class="title-page-name"/></strong><strong class="calibre2">if ! [[ "$S_CHECK" = *[[:digit:]]* ]];<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART UNKNOWN: The $S_KEY check is not available on $DISK"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_UNKNOWN"<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">if (( S_CHECK == S_MATCH ));<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART OK: Overall-health check $S_MATCH"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_OK"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART CRITICAL: Overall-health check NOT $S_MATCH"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_CRITICAL"<br class="title-page-name"/></strong><strong class="calibre2">fi</strong><strong class="calibre2">                          </strong>
</pre>
<p class="calibre1"><span><span>We filled in our placeholder. This function is similar to the first one, the only real difference is the arithmetic evaluation performed and a check on the value to match and that must be a number. Calling the function with the <kbd class="calibre9">SELFCHECK</kbd> keyword will show us this:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">SMART OK: Overall-health check 0</strong>
</pre>
<p class="calibre1"><span><span>Great, now it is time for the last check, which is quite different from the other two, since it requires a check against some thresholds. We start with some variables as usual:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">BC=$(which bc)<br class="title-page-name"/></strong><strong class="calibre2">T_FIELD='{print $10}'<br class="title-page-name"/></strong><strong class="calibre2">T_KEY="Temperature" </strong>
</pre>
<p class="calibre1"><span><span>And now we use the code itself:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">elif [[ "$1" == "TEMPERATURE" ]];<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">if (( $(echo "scale=2; "$WARNING_THRESHOLD" &gt;= "$CRITICAL_THRESHOLD"" | $BC ) )) ;<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART UNKNOWN: The value of WARNING ($WARNING_THRESHOLD) must be lower than CRITICAL ($CRITICAL_THRESHOLD)"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_UNKNOWN"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">T_CHECK=$($SMARTCTL -a "$2" | "$GREP" "$T_KEY" | "$AWK" "$T_FIELD")<br class="title-page-name"/></strong><strong class="calibre2">if ! [[ "$T_CHECK" = *[[:digit:]]* ]];<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART UNKNOWN: The $T_KEY check is not available on $DISK"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_UNKNOWN"<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">if (( T_CHECK &lt; WARNING_THRESHOLD ));<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART OK: Temperature is $T_CHECK | TEMP=$T_CHECK"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_OK"<br class="title-page-name"/></strong><strong class="calibre2">elif (( T_CHECK &lt; CRITICAL_THRESHOLD ));<br class="title-page-name"/></strong><strong class="calibre2">then<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART WARNING: Temperature is $T_CHECK | TEMP=$T_CHECK"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_WARNING"<br class="title-page-name"/></strong><strong class="calibre2">else<br class="title-page-name"/></strong><strong class="calibre2">echo "SMART CRITICAL: Temperature is $T_CHECK | TEMP=$T_CHECK"<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_CRITICAL"<br class="title-page-name"/></strong><strong class="calibre2">fi<br class="title-page-name"/></strong><strong class="calibre2">fi</strong><strong class="calibre2">                                                                    fi</strong><strong class="calibre2">                                                            fi         </strong>
</pre>
<p class="calibre1"><span><span>This is a bit more complex than the other two checks. First, we check that the value of <kbd class="calibre9">WARNING_THRESHOLD</kbd> is lower than <kbd class="calibre9">CRITICAL_THRESHOLD</kbd>; and we do it using a small command line calculator and an arithmetic evaluation. Then, we check that <kbd class="calibre9">T_CHECK</kbd> holds a numeric value since we are talking about degrees Celsius (the hard disk temperature is commonly reported in Celsius). Once we are free from such hindrances, we can proceed to check the value of <kbd class="calibre9">T_CHECK</kbd> against the threshold in the following way:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">$T_CHECK &lt; $WARNING_THRESHOLD IS OK<br class="title-page-name"/></strong><strong class="calibre2">$T_CHECK &lt; $CRITICAL_THRESHOLD IS WARNING<br class="title-page-name"/></strong><strong class="calibre2">EVERYTHING ELSE IS CRITICAL</strong>
</pre>
<p class="calibre1"><span><span>Let's test the script with different values for the <span>WARNING</span> and <span>CRITICAL</span> thresholds:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">WARNING_THRESHOLD=${WARNING_THRESHOLD:=41}<br class="title-page-name"/></strong><strong class="calibre2">CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=50}</strong><strong class="calibre2">ro<br class="title-page-name"/>ot:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">SMART WARNING: Temperature is 41 | TEMP=41<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">WARNING_THRESHOLD=${WARNING_THRESHOLD:=45}<br class="title-page-name"/></strong><strong class="calibre2">CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=50}<br class="title-page-name"/></strong><strong class="calibre2">root:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">SMART OK: Temperature is 41 | TEMP=41<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">WARNING_THRESHOLD=${WARNING_THRESHOLD:=35}<br class="title-page-name"/></strong><strong class="calibre2">CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=40}<br class="title-page-name"/></strong><strong class="calibre2">root:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">SMART CRITICAL: Temperature is 41 | TEMP=41<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">WARNING_THRESHOLD=${WARNING_THRESHOLD:=50}<br class="title-page-name"/></strong><strong class="calibre2">CRITICAL_THRESHOLD=${CRITICAL_THRESHOLD:=40}<br class="title-page-name"/></strong><strong class="calibre2">root:~$ ./check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">SMART UNKNOWN: The value of WARNING (50) must be lower than CRITICAL (40)</strong>
</pre>
<p class="calibre1"><span><span>As we can see, our thresholds are set pretty well and the same is for the precedence of values, so we are quite fine. Notice the performance data; since this is a temperature indicator, we can later have it plotted on Nagios if we wish. The last step here is to create a command line parser to get all the required values:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Print help and usage<br class="title-page-name"/></strong><strong class="calibre2">print_help()<br class="title-page-name"/></strong><strong class="calibre2">{<br class="title-page-name"/></strong><strong class="calibre2">cat &lt;&lt; HERE<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">MY SMART CHECK v1.0<br class="title-page-name"/></strong><strong class="calibre2">-------------------<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">Please enter one or more of the following options:<br class="title-page-name"/></strong><strong class="calibre2">-d | --disk<br class="title-page-name"/></strong><strong class="calibre2">eg. /dev/sda<br class="title-page-name"/></strong><strong class="calibre2">-t | --test<br class="title-page-name"/></strong><strong class="calibre2">HEALTH<br class="title-page-name"/></strong><strong class="calibre2">TEMPERATURE<br class="title-page-name"/></strong><strong class="calibre2">SELFCHECK<br class="title-page-name"/></strong><strong class="calibre2">-w | --warning<br class="title-page-name"/></strong><strong class="calibre2">eg. -w 41<br class="title-page-name"/></strong><strong class="calibre2">-c | --critical<br class="title-page-name"/></strong><strong class="calibre2">eg. -c 50<br class="title-page-name"/></strong><strong class="calibre2">HERE<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>We started with the print usage. In case the user does input some wrong options, we give them a hint of what to do:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ ./check_my_smart.sh -T ITISWRONG<br class="title-page-name"/></strong><strong class="calibre2">Unknown argument: -T<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"> MY SMART CHECK v1.0<br class="title-page-name"/></strong><strong class="calibre2">-------------------<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2">Please enter one or more of the following options:<br class="title-page-name"/></strong><strong class="calibre2">-d | --disk<br class="title-page-name"/></strong><strong class="calibre2">eg. /dev/sda<br class="title-page-name"/></strong><strong class="calibre2">-m | --module<br class="title-page-name"/></strong><strong class="calibre2">HEALTH<br class="title-page-name"/></strong><strong class="calibre2">TEMPERATURE<br class="title-page-name"/></strong><strong class="calibre2">SELFCHECK<br class="title-page-name"/></strong><strong class="calibre2">-w | --warning<br class="title-page-name"/></strong><strong class="calibre2">eg. -w 41<br class="title-page-name"/></strong><strong class="calibre2">-c | --critical<br class="title-page-name"/></strong><strong class="calibre2">eg. -c 50</strong>
</pre>
<p class="calibre1"><span><span>Nice, isn't it? But how do we call that function and manage the input? Let's see:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># Parse parameters on the command line<br class="title-page-name"/></strong><strong class="calibre2">while (( $# &gt; 0 ))<br class="title-page-name"/></strong><strong class="calibre2">do<br class="title-page-name"/></strong><strong class="calibre2">case "$1" in<br class="title-page-name"/></strong><strong class="calibre2">-h | --help)<br class="title-page-name"/></strong><strong class="calibre2">print_help<br class="title-page-name"/></strong><strong class="calibre2">exit "${STATE_OK}"<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">-d | --disk)<br class="title-page-name"/></strong><strong class="calibre2">shift<br class="title-page-name"/></strong><strong class="calibre2">DISK="$1"<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">-m | --module)<br class="title-page-name"/></strong><strong class="calibre2">shift<br class="title-page-name"/></strong><strong class="calibre2">B_SEL="$1"<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">-w | --warning)<br class="title-page-name"/></strong><strong class="calibre2">shift<br class="title-page-name"/></strong><strong class="calibre2">WARNING_THRESHOLD="$1"<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">-c | --critical)<br class="title-page-name"/></strong><strong class="calibre2">shift<br class="title-page-name"/></strong><strong class="calibre2">CRITICAL_THRESHOLD="$1"<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">*) echo "Unknown argument: $1"<br class="title-page-name"/></strong><strong class="calibre2">print_help<br class="title-page-name"/></strong><strong class="calibre2">exit "$STATE_UNKNOWN"<br class="title-page-name"/></strong><strong class="calibre2">;;<br class="title-page-name"/></strong><strong class="calibre2">esac<br class="title-page-name"/></strong><strong class="calibre2">shift<br class="title-page-name"/></strong><strong class="calibre2">done</strong>
</pre>
<p class="calibre1"><span><span>What do we do in this block? While the number of arguments on the command line is higher than zero, we parse the command line itself, and check the options using the case construct. Every time we match a value, we instantiate a variable and shift the command line, so we are ready to process the next option; this is our command line parser.</span></span></p>
<p class="calibre1"><span><span>Now that our plugin is ready to serve our purposes, we have to copy it to the plugins directory </span></span><kbd class="calibre9">root:~$ cp check_my_smart.sh /usr/lib/nagios/plugins/</kbd>; n<span><span>ow let's check the ownership and access right to it. The one shown here should suffice:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">root:~$ cd /usr/lib/nagios/plugins/<br class="title-page-name"/></strong><strong class="calibre2">root:~$ ls -lah check_my_smart.sh <br class="title-page-name"/></strong><strong class="calibre2">-rwxr-xr-x 1 root root 6.2K Mar 22 09:32 check_my_smart.sh</strong>
</pre>
<p class="calibre1"><span><span>Once the script is in place, we have to tell Nagios how to call it, so a command definition is needed. Let's move to the command configurations directory </span></span><span><span><kbd class="calibre9">cd /etc/nagios-plugins/config/</kbd> </span></span><span><span>and create the </span></span><span><kbd class="calibre9">check_my_smart.cfg</kbd> </span><span><span>file with the following content:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># 'check_my_smart' command definition<br class="title-page-name"/></strong><strong class="calibre2">define command{<br class="title-page-name"/></strong><strong class="calibre2">command_name check_my_smart<br class="title-page-name"/></strong><strong class="calibre2">command_line /usr/lib/nagios/plugins/check_my_smart.sh -d $ARG1$ -m $ARG2$ $ARG3$ $ARG4$<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<div class="packt_infobox"><span class="calibre30">We won't repeat it, but always check for the user access rights on files. If you are not confident about which rights to use, look at the similar files in the directory you are working on. But be aware of what you concede.</span></div>
<p class="calibre1"><span><span>We are going to use <kbd class="calibre9">sudo</kbd> since the <kbd class="calibre9">smartctl</kbd> utility needs the root privileges to access disk information. The disk and module options must be given on the service configuration, but the <span>WARNING</span> and <span>CRITICAL</span> values are optional. Time to modify </span></span><span><span><kbd class="calibre9">/etc/sudoers</kbd> and </span></span><span><span>add the following line:</span></span></p>
<pre class="codepackt">
<strong class="calibre2"># SMART Nagios plugin sudo<br class="title-page-name"/></strong><strong class="calibre2">nagios ALL=(root) NOPASSWD: /usr/sbin/smartctl</strong>
</pre>
<p class="calibre1"><span><span>So, the Nagios user now is able to call the <kbd class="calibre9">smartctl</kbd> utility as root without being asked for any passwords. This, though, requires a little change in our script:</span></span></p>
<pre class="codepackt">
<strong class="calibre2">SUDO=$(which sudo)<br class="title-page-name"/></strong><strong class="calibre2">SMARTCTL="$SUDO /usr/sbin/smartctl"</strong>
</pre>
<p class="calibre1"><span><span>This will enable our script to call <kbd class="calibre9">smartctl</kbd> as the root user. A little homework: try to trap and deal with the chance we did not enable <kbd class="calibre9">sudo</kbd> for the Nagios user. How would your manage this problem? Let's move on and write our services definitions in </span></span><span><span><kbd class="calibre9">/etc/nagios3/conf.d/localhost_nagios2.cfg</kbd>, </span></span><span><span>and add the following lines:</span></span></p>
<p class="calibre1"> </p>
<pre class="codepackt">
<strong class="calibre2"># SMART - Check overall-health<br class="title-page-name"/></strong><strong class="calibre2">define service{<br class="title-page-name"/></strong><strong class="calibre2">use generic-service <br class="title-page-name"/></strong><strong class="calibre2">host_name localhost<br class="title-page-name"/></strong><strong class="calibre2">service_description SMART - oveall-health<br class="title-page-name"/></strong><strong class="calibre2">check_command check_my_smart!/dev/sda!HEALTH<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># SMART - Check self-test<br class="title-page-name"/></strong><strong class="calibre2">define service{<br class="title-page-name"/></strong><strong class="calibre2">use generic-service <br class="title-page-name"/></strong><strong class="calibre2">host_name localhost<br class="title-page-name"/></strong><strong class="calibre2">service_description SMART - self-test<br class="title-page-name"/></strong><strong class="calibre2">check_command check_my_smart!/dev/sda!SELFCHECK<br class="title-page-name"/></strong><strong class="calibre2">}<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre2"># SMART - Check temperature<br class="title-page-name"/></strong><strong class="calibre2">define service{<br class="title-page-name"/></strong><strong class="calibre2">use generic-service <br class="title-page-name"/></strong><strong class="calibre2">host_name localhost<br class="title-page-name"/></strong><strong class="calibre2">service_description SMART - temperature<br class="title-page-name"/></strong><strong class="calibre2">action_url /pnp4nagios/index.php/graph?host=$HOSTNAME$&amp;srv=$SERVICEDESC$<br class="title-page-name"/></strong><strong class="calibre2">check_command check_my_smart!/dev/sda!TEMPERATURE!-w 41!-c 50<br class="title-page-name"/></strong><strong class="calibre2">}</strong>
</pre>
<p class="calibre1"><span><span>We configured three new service checks, but only one needs an <kbd class="calibre9">action_url</kbd> , as only the temperature check gives us some values that change over time and can be usefully graphed. Now, all that is left is to restart Nagios using </span></span><span><span><kbd class="calibre9">service nagios3 restart</kbd> </span></span><span><span>and check whether everything is fine, as we can see in the following screenshot:</span></span></p>
<div class="packt_figure"><img class="image-border12" src="../images/00018.jpeg"/></div>
<div class="packt_figref"><span><span>Our new three checks are online and the disk seems a bit overheated.</span></span></div>
<p class="calibre1"><span><span>Let's just check whether our temperature check is producing some performance data and it is being graphed:</span></span></p>
<div class="packt_figure"><img class="image-border13" src="../images/00019.jpeg"/></div>
<p class="calibre1"><span><span>We are keeping an eye on the temperature, thanks to our new graph.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1"><span><span>We just saw how to handle a problem in a real scenario by analyzing our goal, planning the methods and tools we needed to accomplish it, and taking care of the issues on the path to our solution. We worked on our outcome in small steps, consecutive and joined all the bits once ready, so we did not face a cumbersome whole big problem, but solved what we encountered at each step by learning how to proceed and avoid overthinking. Now, we are ready to proceed and work on something quite useful nowadays: our personal Slack poster utility.</span></span></p>
<p class="calibre1"> </p>


            </article>

            
        </section>
    </body></html>