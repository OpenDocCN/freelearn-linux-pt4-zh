<html><head></head><body>
<p id="filepos708963" class="calibre_"><span class="calibre1"><span class="bold">Chapter 10. CoreOS and Containers – Troubleshooting and Debugging</span></span></p><p class="calibre_8">Both CoreOS and Containers pose some special challenges in troubleshooting and there are ways to overcome this problem. CoreOS, being a Container-optimized OS, does not support a package manager, and this prevents the installation of some of the Linux debugging tools. This can be <a/>overcome by running the Linux tools in a Container with a tool called <span class="bold">Toolbox</span> provided by CoreOS. Containers run in their own namespaces, and the regular Linux tools do not give enough information to debug Containers. This problem is solved by tools such as <tt class="calibre2">cadvisor</tt> and <tt class="calibre2">sysdig</tt>. Logging is another important tool to debug system-level issues, and there are a few vendors such as LogEntries trying to solve this problem for Containers.</p><p class="calibre_8">In this chapter, we will cover the following topics:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">Using CoreOS Toolbox and other CoreOS utilities to debug the CoreOS system</li><li value="2" class="calibre_13">Monitoring a Container using <tt class="calibre2">sysdig</tt> and <tt class="calibre2">cadvisor</tt></li><li value="3" class="calibre_13">Docker remote API support</li><li value="4" class="calibre_13">Docker logging drivers</li><li value="5" class="calibre_13">Using LogEntries to do central Container log monitoring</li></ul><div class="mbp_pagebreak" id="calibre_pb_219"/>


<p id="filepos710611" class="calibre_14"><span class="calibre1"><span class="bold">CoreOS Toolbox</span></span></p><p class="calibre_8">As CoreOS does<a/> not support a package manager, it is difficult to install custom<a/> tools for debugging problems, such as tcpdump, strace, and others. CoreOS provides you with a toolbox script that can start a Ubuntu or Fedora container with system-level privileges on top of which we can run Linux system tools, such as tcpdump to monitor and debug the CoreOS host.</p><p class="calibre_8">To start Toolbox, run <tt class="calibre2">/usr/bin/toolbox</tt> from the CoreOS shell.</p><p class="calibre_8">The following process output in the CoreOS host system shows that Toolbox has started with system-level privileges:</p><p class="calibre_9"><img src="images/00359.jpg" class="calibre_385"/></p><p class="calibre_8">
</p><p class="calibre_8">Toolbox by default uses the Fedora image. The following output shows you Fedora inside the Toolbox container:</p><p class="calibre_9"><img src="images/00361.jpg" class="calibre_386"/></p><p class="calibre_8">
</p><p class="calibre_8">Tcpdump is not present in<a/> the default Fedora image. I was able to install <tt class="calibre2">tcpdump</tt> using <tt class="calibre2">yum</tt> and monitor the <tt class="calibre2">eth0</tt> interface from inside the Toolbox container. This shows one example of how Toolbox can be used.</p><p class="calibre_8">To change the default Linux image that CoreOS Toolbox uses, we can specify a custom image in <tt class="calibre2">~/.toolboxrc</tt>.</p><p class="calibre_8">The following is an example <tt class="calibre2">.toolboxrc</tt>, where we are asking Toolbox to use a Ubuntu image:</p><p class="calibre_8"><tt class="calibre2">TOOLBOX_DOCKER_IMAGE=ubuntu<br class="calibre4"/>TOOLBOX_DOCKER_TAG=14.04</tt></p><p class="calibre_8">If we start Toolbox after the preceding change, Toolbox will start a Ubuntu image with system-level privileges. The following is the Ubuntu image running as part of starting Toolbox:</p><p class="calibre_9"><img src="images/00363.jpg" class="calibre_387"/></p><p class="calibre_8">
</p><p class="calibre_8">We can specify the image selection in the <tt class="calibre2">cloud-config</tt> so that <tt class="calibre2">.toolboxrc</tt> is automatically written as<a/> part of the Container startup. The following is a sample <tt class="calibre2">cloud-config</tt> section where we specified <tt class="calibre2">.toolboxrc</tt> with Ubuntu as the default Toolbox Container image:</p><p class="calibre_8"><tt class="calibre2">-write_files:<br class="calibre4"/>  - path: /home/core/.toolboxrc<br class="calibre4"/>    owner: core<br class="calibre4"/>    content: |<br class="calibre4"/>      TOOLBOX_DOCKER_IMAGE=ubuntu<br class="calibre4"/>      TOOLBOX_DOCKER_TAG=14.04</tt></p><div class="mbp_pagebreak" id="calibre_pb_220"/>


<p id="filepos713588" class="calibre_"><span class="calibre1"><span class="bold">Other CoreOS debugging tools</span></span></p><p class="calibre_8">We covered basic CoreOS debugging in <a href="index_split_048.html#filepos153225">Chapter 2</a>, <span class="italic">Setting Up the CoreOS Lab</span> in the <span class="italic">Basic debugging</span> section. The<a/> following are a few utilities that can be used:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">The <tt class="calibre2">journalctl</tt> utility can be used to check the logs of all systemd services</li><a/><li value="2" class="calibre_13">The <tt class="calibre2">systemctl</tt> utility can be used to check the status of all the services</li><li value="3" class="calibre_13">The <tt class="calibre2">cloud-config</tt> validator tool can be used to validate the <tt class="calibre2">cloud-config</tt> before using it with CoreOS</li><li value="4" class="calibre_13">Utilities such as Etcd, Fleet, Flannel, and Locksmith have their own debugging capabilities that can be turned on if necessary</li></ul><div class="mbp_pagebreak" id="calibre_pb_221"/>


<p id="filepos714659" class="calibre_"><span class="calibre1"><span class="bold">Container monitoring</span></span></p><p class="calibre_8">As Containers run<a/> in their own namespaces, traditional Linux monitoring tools such as top, ps, tcpdump, and lsof from the host system do not help monitor the activity happening within a Container or between Containers. This makes it complex to<a/> troubleshoot Containers. Before we discuss tools available for Container monitoring, let's see the major items that we need to monitor:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">The CPU usage by a Container and processes running inside a Container</li><li value="2" class="calibre_13">The memory usage by a Container and processes running inside a Container</li><li value="3" class="calibre_13">Network access for both incoming and outgoing connections</li><li value="4" class="calibre_13">File I/O performed by Containers</li></ul><p class="calibre_8">The following are some approaches to monitor Containers:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">Install monitoring software in the Container: This defeats the Container model where a Container runs a single microservice and is also not scalable.</li><a/><li value="2" class="calibre_13">Install monitoring software in the host machine where the Container runs: This approach makes it difficult to install specialized software on a cluster OS like CoreOS as they allow only applications to run as Containers and not allow installing software in the base OS.</li><li value="3" class="calibre_13">Install monitoring software as a Container with system-level privileges: This is the most preferred approach.</li></ul><p class="calibre_8">Docker provides you with the <tt class="calibre2">docker stats</tt> command that provides basic CPU, memory, and I/O usage on a per Container basis. We covered <tt class="calibre2">docker stats</tt> in <a href="index_split_164.html#filepos509414">Chapter 7</a>, <span class="italic">Container Integration with CoreOS – Docker and Rkt</span>. The data provided by Docker commands is very basic. There are many open source and commercial Container monitoring tools, such as cadvisor, sysdig, Data dog, newrelic, Prometheus, and Scout that provide more visibility in Containers. In this chapter, we will cover cadvisor and sysdig.</p><div class="mbp_pagebreak" id="calibre_pb_222"/>


<p id="filepos717198" class="calibre_9"><span class="calibre3"><span class="bold">Sysdig</span></span></p><p class="calibre_8">Sysdig is an open source project that provides Linux system-level visibility with built-in native support for Containers. Sysdig can be used for host monitoring <a/>as well as Container monitoring.</p><p class="calibre_8">The following diagram shows the Sysdig architecture:</p><p class="calibre_9"><img src="images/00297.jpg" class="calibre_388"/></p><p class="calibre_8">
</p><p class="calibre_8">The following are<a/> some notes on the Sysdig architecture:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">Sysdig can monitor the host system, VM, and Containers.</li><a/><li value="2" class="calibre_13">Sysdig can monitor different Container runtime like Docker, Rkt and LXC.</li><li value="3" class="calibre_13">The Sysdig documentation calls sysdig as <tt class="calibre2">strace + tcpdump + htop + iftop + lsof + awesome sauce</tt>.</li><li value="4" class="calibre_13">The Sysdig probe is a kernel module that needs to be installed in the host machine to do the monitoring. Sysdig has made the installation of this module very simple, and it works in regular Linux systems as well as in Container-based OSes, such as CoreOS and Rancher.</li><li value="5" class="calibre_13">Since sysdig directly monitors all Kernel system calls, sysdig provides more detailed monitoring data compared to other monitoring tools.</li><li value="6" class="calibre_13">A Sysdig container can be run on the host system and monitors the host processes as well as Containers running in the host system.</li><li value="7" class="calibre_13">Sysdig can monitor CPU, memory, network IO, and file IO. Sysdig provides various options to fine-tune the monitor query to provide relevant data.</li><li value="8" class="calibre_13">The Sysdig open source version has the sysdig CLI and csysdig, which has an ncurses-based interface. Csysdig is similar to htop, where we get an interactive text-based interface.</li><li value="9" class="calibre_13">The Sysdig cloud is the commercial version of Sysdig where data from multiple hosts and Containers are aggregated in a single location in the cloud and can be accessed as a SaaS application. The Sysdig cloud can be accessed from the cloud or installed on-premise.</li></ul><p class="calibre_8">Sysdig can be started as a<a/> Container. The following command shows you how to start the sysdig container:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">docker run -i -t --name sysdig --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro sysdig/sysdig</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">For more details on Sysdig installation, please refer <a href="http://www.sysdig.org/install/">http://www.sysdig.org/install/</a>. The following command shows you a running sysdig container in a CoreOS system:</p><p class="calibre_9"><img src="images/00367.jpg" class="calibre_389"/></p><p class="calibre_8">
</p><p id="filepos720630" class="calibre_9"><span class="calibre3"><span class="bold">Examples of Sysdig</span></span></p><p class="calibre_8">The following output<a/> shows you a list of Containers running in a CoreOS system on which we will try out some simple sysdig commands:</p><p class="calibre_9"><img src="images/00369.jpg" class="calibre_390"/></p><p class="calibre_8">
</p><p class="calibre_8">The following command shows the top processes consuming the CPU. The output lists the PID in the host machine as well as the container. The <tt class="calibre2">topprocs_cpu</tt> utility is a chisel. In sysdig terms, each chisel is a script with some predefined task:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">sysdig -pc -c topprocs_cpu</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00371.jpg" class="calibre_391"/></p><p class="calibre_8">
</p><p class="calibre_8">The following<a/> command lists the top containers using network IO:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">sysdig -pc -c topcontainers_net</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00373.jpg" class="calibre_392"/></p><p class="calibre_8">
</p><p class="calibre_8">The following command lists the top containers using file IO:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">sysdig -c topcontainers_file</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00375.jpg" class="calibre_393"/></p><p class="calibre_8">
</p><p class="calibre_8">The Sysdig spy command is useful to monitor all the external interactions to the host or Container. The following output shows the command executed in an nginx container when we used the exec command and performed <tt class="calibre2">ps</tt> in the container:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">sysdig -pc -c spy_users</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following <a/>screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00378.jpg" class="calibre_394"/></p><p class="calibre_8">
</p><p class="calibre_8">The preceding output shows that the <tt class="calibre2">docker exec</tt> and <tt class="calibre2">ps</tt> commands were executed.</p><p id="filepos723537" class="calibre_9"><span class="calibre3"><span class="bold">Csysdig</span></span></p><p class="calibre_8">Csysdig is a text based UI for Sysdig. Csysdig is implemented as a customizable Curses UI. All operations that can be done through sysdig can also be done with csysdig. The csysdig user interface can be customized to show different views and the output can be filtered based on different user inputs.</p><p class="calibre_8">Csysdig can be started using the following command:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">Cssysdig –pc (pc option gives container details)</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following output shows different views possible in csysdig:</p><p class="calibre_9"><img src="images/00381.jpg" class="calibre_395"/></p><p class="calibre_8">
</p><p class="calibre_8">The following <a/>output lists the containers running in the host. This is available in the Container view:</p><p class="calibre_9"><img src="images/00391.jpg" class="calibre_391"/></p><p class="calibre_8">
</p><p class="calibre_8">Once we select a specific container, the following output shows the processes running in the <a/>container:</p><p class="calibre_9"><img src="images/00387.jpg" class="calibre_396"/></p><p class="calibre_8">
</p><p id="filepos725097" class="calibre_9"><span class="calibre3"><span class="bold">The Sysdig cloud</span></span></p><p class="calibre_8">The sysdig cloud is<a/> a commercial solution from Sysdig where the sysdig data from the host machine is sent to a central server where the container and host monitoring data are collated from different hosts. The sysdig cloud can either be run on Sysdig's servers or as an on-premise solution.</p><p class="calibre_8">The sysdig cloud is available<a/> on a 15-day trial period. I tried out the Sysdig cloud trial version and installed Sysdig in a CoreOS cluster running in AWS.</p><p class="calibre_8">The following are the steps to install the Sysdig cloud and how to use it:</p><div class="calibre_11"> </div><ol class="calibre_30"><li value="1" class="calibre_13">Register and create on online account in the Sysdig cloud. As part of registration, Sysdig will provide an access key.</li><a/><li value="2" class="calibre_13">The access key provided by Sysdig needs to be used in the host machine. Sysdig will use the access key to associate the hosts that are part of the same account.</li><li value="3" class="calibre_13">When sysdig is started on the host machine, the sysdig agent will talk to the Sysdig server in the cloud and export the monitoring data.</li><li value="4" class="calibre_13">The Sysdig cloud can also integrate with AWS. If we provide the AWS access key, Sysdig can automatically pull in AWS VM monitoring data as well.</li></ol><p class="calibre_8">The following is the CoreOS service unit file to start the sysdig-agent service in the host machine, which talks to the Sysdig cloud. The access key needs to be filled in appropriately. This unit starts the sysdig cloud agent in all the nodes of the CoreOS cluster as the <tt class="calibre2">Global</tt> option is set in X-Fleet:</p><p class="calibre_8"><tt class="calibre2">[Unit]<br class="calibre4"/>Description=Sysdig Cloud Agent<br class="calibre4"/>After=docker.service<br class="calibre4"/>Requires=docker.service<br class="calibre4"/><br class="calibre4"/>[Service]<br class="calibre4"/>TimeoutStartSec=0<br class="calibre4"/>ExecStartPre=-/usr/bin/docker kill sysdig-agent<br class="calibre4"/>ExecStartPre=-/usr/bin/docker rm sysdig-agent<br class="calibre4"/>ExecStartPre=/usr/bin/docker pull sysdig/agent<br class="calibre4"/>ExecStart=/usr/bin/docker run --name sysdig-agent --privileged --net host --pid host -e ACCESS_KEY=&lt;access key&gt; -e TAGS=[role:web,location:bangalore] -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro sysdig/agent<br class="calibre4"/>ExecStop=/usr/bin/docker stop sysdig-agent<br class="calibre4"/><br class="calibre4"/>[X-Fleet]<br class="calibre4"/>Global=true</tt></p><p class="calibre_8">The following<a/> is my three-node CoreOS cluster:</p><p class="calibre_9"><img src="images/00389.jpg" class="calibre_397"/></p><p class="calibre_8">
</p><p class="calibre_8">The following command can be <a/>used to start the sysdig agent on the CoreOS machine:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">fleetctl start docker-sysdig.service</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following output shows the running sysdig-agent container in one of the CoreOS nodes:</p><p class="calibre_9"><img src="images/00392.jpg" class="calibre_33"/></p><p class="calibre_8">
</p><p class="calibre_8">The following output in the Sysdig cloud shows the registered hosts along with the running containers. Here, we can see the three hosts and the Containers running in each host along with their CPU, memory, network IO, and file IO:</p><p class="calibre_9"><img src="images/00394.jpg" class="calibre_398"/></p><p class="calibre_8">
</p><p class="calibre_8">The following output shows the summary view:</p><p class="calibre_9"><img src="images/00396.jpg" class="calibre_326"/></p><p class="calibre_8">
</p><p class="calibre_8">The following<a/> output shows the dashboard output for a single Container with its associated processes. We have picked the sysdig container for the following output:</p><p class="calibre_9"><img src="images/00398.jpg" class="calibre_399"/></p><p class="calibre_8">
</p><p id="filepos729733" class="calibre_9"><span class="calibre3"><span class="bold">Kubernetes integration</span></span></p><p class="calibre_8">Sysdig recently added a feature to integrate with Kubernetes, where Sysdig is aware of Kubernetes logical<a/> constructs, such as the master node, minion node, Pods, replication controllers, labels, and so on. Sysdig gets this awareness by querying the Kubernetes API server. By combining the data collected from Containers and the<a/> Kubernetes API server, Sysdig and the Sysdig cloud can group information at Kubernetes' level. For example, we can view the CPU and memory usage either on the Kubernetes pod or replication controller basis. Sysdig has plans to integrate with other orchestration engines such as Mesos and Swarm in the future. Sysdig also has plans to integrate with other Container runtime such as Rkt.</p><div class="mbp_pagebreak" id="calibre_pb_223"/>


<p id="filepos730632" class="calibre_9"><span class="calibre3"><span class="bold">Cadvisor</span></span></p><p class="calibre_8">Cadvisor is an open <a/>source tool from Google to monitor Containers as well as the host system on which the<a/> Container is running. Google developed cadvisor for its own Container system and later extended its support to Docker containers.</p><p class="calibre_8">The following are some notes on cadvisor:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">It monitors CPU, memory, network, and file I/O for both the host system as well as Containers.</li><li value="2" class="calibre_13">It can work with Docker and other Container runtimes.</li><li value="3" class="calibre_13">It can be started as a Container in the host system with no special changes necessary in the host system.</li><li value="4" class="calibre_13">The cadvisor container starts a simple web server, using which we can access the dashboards using a simple GUI.</li><a/><li value="5" class="calibre_13">It provides REST API for programmatic access.</li><li value="6" class="calibre_13">Cadvisor stores the history for only a small duration. It is necessary to use cadvisor with backends such as InfluxDB (<a href="https://influxdata.com/">https://influxdata.com/</a>) and Prometheus (<a href="https://prometheus.io/">https://prometheus.io/</a>) to maintain the history.</li></ul><p class="calibre_8">The following command can be used to start the Docker cadvisor Container:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">docker run \</span></tt><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">  --volume=/:/rootfs:ro \</span></tt><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">  --volume=/var/run:/var/run:rw \</span></tt><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">  --volume=/sys:/sys:ro \</span></tt><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">  --volume=/var/lib/docker/:/var/lib/docker:ro \</span></tt><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">  --publish=8080:8080 \</span></tt><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">  --detach=true \</span></tt><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">  --name=cadvisor \</span></tt><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">  google/cadvisor:latest</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following output shows a running cadvisor container in the CoreOS system:</p><p class="calibre_9"><img src="images/00400.jpg" class="calibre_192"/></p><p class="calibre_8">
</p><p class="calibre_8">The following screenshot is a GUI snapshot showing processes and the CPU usage for a container:</p><p class="calibre_9"><img src="images/00012.jpg" class="calibre_400"/></p><p class="calibre_8">
</p><p class="calibre_8">The following output shows the REST API subtypes supported by cadvisor:</p><p class="calibre_9"><img src="images/00405.jpg" class="calibre_401"/></p><p class="calibre_8">
</p><p class="calibre_8">The following are some<a/> examples of a REST API provided by cadvisor with the details that they provide. This link, <a href="https://github.com/google/cadvisor/blob/master/docs/api.md">https://github.com/google/cadvisor/blob/master/docs/api.md</a>, gives the details of all the<a/> supported REST APIs. All the following commands return output in the JSON format.</p><p class="calibre_8">The following command gives the host detail:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">curl -X GET http://172.17.8.102:8080/api/v1.3/machine | jq .</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following command gives the Container performance detail:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">curl -X GET http://172.17.8.102:8080/api/v1.3/containers/ | jq .</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following command gives the Docker container nginx performance detail:</p><p class="calibre_8"><tt class="calibre2"><span class="bold">curl -X GET http://172.17.8.102:8080/api/v1.3/docker/nginx | jq .</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">Cadvisor provides you <a/>with limited information compared to sysdig as cadvisor relies mainly on Docker-provided statistics. Additionally, cadvisor provides only limited history on statistics, and so it is necessary to integrate cadvisor with other tools such as Influxdb to maintain a longer history.</p><div class="mbp_pagebreak" id="calibre_pb_224"/>


<p id="filepos735314" class="calibre_"><span class="calibre1"><span class="bold">The Docker remote API</span></span></p><p class="calibre_8">The Docker remote<a/> API can be used to access the Docker engine with the REST API. This can be used for programmatic access to Docker.</p><p class="calibre_8">The following section of CoreOS <tt class="calibre2">cloud-config</tt> can be used to enable the Docker remote API listening on TCP port <tt class="calibre2">2375</tt>:</p><p class="calibre_8"><tt class="calibre2">    - name: docker-tcp.socket<br class="calibre4"/>      command: start<br class="calibre4"/>      enable: true<br class="calibre4"/>      content: |<br class="calibre4"/>        [Unit]<br class="calibre4"/>        Description=Docker Socket for the API<br class="calibre4"/>        [Socket]<br class="calibre4"/>        ListenStream=2375<br class="calibre4"/>        Service=docker.service<br class="calibre4"/>        BindIPv6Only=both<br class="calibre4"/>        [Install]<br class="calibre4"/>        WantedBy=sockets.target</tt></p><p class="calibre_8">The following are some examples of accessing the Docker remote API:</p><p class="calibre_8">List the running Containers:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">docker -H tcp://172.17.8.102:2375 ps</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00407.jpg" class="calibre_402"/></p><p class="calibre_8">
</p><p class="calibre_8">List the Container images:</p><p class="calibre_8">The following command can be used to list Container images in the JSON format:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">curl -X GET http://172.17.8.101:2375/images/json | jq .</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following <a/>screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00410.jpg" class="calibre_403"/></p><p class="calibre_8">
</p><p class="calibre_8">List Docker engine details: </p><p class="calibre_8">The following command is equivalent to <tt class="calibre2">docker info</tt>:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">curl -X GET http://172.17.8.101:2375/info | jq .</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">List particular Container statistics:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">curl -X GET http://172.17.8.101:2375/containers/26b225ec6a8e/stats | jq .</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">List the Docker version:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">curl -X GET http://172.17.8.102:2375/version | jq .</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">List the Docker events:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">curl -X GET http://172.17.8.102:2375/events</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following command deletes the specific <tt class="calibre2">busybox</tt> container:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">curl -X DELETE http://172.17.8.102:2375/images/busybox</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following <a/>screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00412.jpg" class="calibre_404"/></p><p class="calibre_8">
</p><p class="calibre_8">List specific Container logs sent to stdout: </p><p class="calibre_8">The Container ID is specified as an argument for the following command:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">curl -X GET http://172.17.8.101:2375/containers/5ab9abb4787e/logs?stdout=1</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">If we need secure access to the Docker remote API, we can do it using TLS, and the Docker daemon supports this.</p><div class="mbp_pagebreak" id="calibre_pb_225"/>


<p id="filepos739645" class="calibre_"><span class="calibre1"><span class="bold">Container logging</span></span></p><p class="calibre_8">When Containers<a/> send the output to stdout or stderr, it needs to be logged. This is useful to monitor errors and events and also to maintain the history of the Container application. With Containers, there are some<a/> special challenges with respect to logging:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">Typically, Containers run a microservice, and we don't want the logging process running inside a container as this defeats the Container model.</li><li value="2" class="calibre_13">With microservices, a single application can be split into multiple containers running across different hosts. It is necessary to collate logs from multiple containers to make meaningful conclusions. This enforces the need to have a central logging server rather than doing container monitoring on the host where the container is running.</li></ul><p class="calibre_8">We covered Container monitoring in the previous section. When Container logs are correlated with the Container monitoring data, we can get a better understanding of the system and easily narrow down any system wide issues.</p><p class="calibre_8">I found the following two approaches widely used for centralized Container logging:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">ELK stack (Elastic search, Logstash, and Kibana): Elastic search is used as a central log repository, Logstash is used as an agent to export Container data, and Kibana is used as a logging GUI frontend. I have not covered the ELK stack in this chapter. The links in the references section provide details on setting up the ELK stack for Container logging.</li><a/><li value="2" class="calibre_13">LogEntries: LogEntries combines the Container agent, frontend, and central logging server for a single integrated solution.</li><a/></ul><p class="calibre_8">There are also <a/>other tools such as AWS Cloudwatch (<a href="https://aws.amazon.com/cloudwatch/">https://aws.amazon.com/cloudwatch/</a>), Loggly (<a href="https://www.loggly.com">https://www.loggly.com</a>), Elastic (<a href="http://www.elastic.io/">http://www.elastic.io/</a>), and Sematext Logsene (<a href="https://sematext.com/logsene/">https://sematext.com/logsene/</a>) that provide logging capability for Containers. When using AWS cloudwatch for Container monitoring, we get custom hooks based on the AWS environment, and it also integrates well with their other cloud monitoring options.</p><div class="mbp_pagebreak" id="calibre_pb_226"/>


<p id="filepos742443" class="calibre_9"><span class="calibre3"><span class="bold">Docker logging drivers</span></span></p><p class="calibre_8">Docker supports the<a/> following log drivers as of Docker 1.7:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13"><tt class="calibre2">None</tt>: No logging.</li><a/><li value="2" class="calibre_13"><tt class="calibre2">Json-file</tt>: Logs are stored as a file in the JSON format. This is the default logging option.</li><a/><li value="3" class="calibre_13"><tt class="calibre2">Syslog</tt>: Logs are sent to the syslog server.</li><li value="4" class="calibre_13"><tt class="calibre2">Journald</tt>: Logs are sent to the journald daemon. Journald is integrated with systemd.</li><li value="5" class="calibre_13"><tt class="calibre2">Gelf</tt>: This writes log messages to the GELF endpoint, such as Graylog or Logstash.</li><li value="6" class="calibre_13"><tt class="calibre2">Fluentd</tt>: This writes log messages to fluentd.</li><li value="7" class="calibre_13"><tt class="calibre2">Awslogs</tt>: This is the Amazon cloudwatch logging driver.</li></ul><p id="filepos743600" class="calibre_14"><span class="calibre3"><span class="bold">The JSON-file driver</span></span></p><p class="calibre_8">The following command <a/>starts a Docker container with the json-file log driver with the maximum number of files limited to 100, each file not exceeding 1 MB:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">docker run --name busyboxjsonlogger --log-driver=json-file --log-opt max-size=1m --log-opt max-file=100 -d busybox /bin/sh -c "while true; do echo hello world ; sleep 5 ; done"</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">In the preceding <tt class="calibre2">busyboxjsonlogger</tt> Container, we are continuously sending <tt class="calibre2">hello world</tt> output to stdout. The following output shows the <tt class="calibre2">docker logs</tt> output for <tt class="calibre2">busyboxjsonlogger</tt>, where we can see the <tt class="calibre2">hello world</tt> output:</p><p class="calibre_9"><img src="images/00414.jpg" class="calibre_405"/></p><p class="calibre_8">
</p><p class="calibre_8">The following command can be executed to find out the location of the json log file:</p><p class="calibre_9"><img src="images/00416.jpg" class="calibre_320"/></p><p class="calibre_8">
</p><p class="calibre_8">Using the preceding path, we<a/> can directly dump the json logs, which gives additional information such as timestamp, stream type, and so on:</p><p class="calibre_9"><img src="images/00418.jpg" class="calibre_41"/></p><p class="calibre_8">
</p><p id="filepos745307" class="calibre_9"><span class="calibre3"><span class="bold">The Syslog driver</span></span></p><p class="calibre_8">The Syslog driver is useful to<a/> collate messages from multiple containers into a single server running the syslog daemon.</p><p class="calibre_8">The following command can be used to start the syslog server as a container. This command exposes the syslog server to port <tt class="calibre2">5514</tt> in the host machine:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">docker run -d -v /tmp:/var/log/syslog -p 5514:514/udp  --name rsyslog voxxit/rsyslog</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following command can be used to start a container with the syslog driver option that sends the logs to the syslog server specified earlier:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">docker run --log-driver=syslog --log-opt syslog-address=udp://127.0.0.1:5514 --log-opt syslog-facility=daemon --log-opt tag="mylog" --name busyboxsysloglogger -d busybox /bin/sh -c "while true; do echo hello world ; sleep 5 ; done"</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following output shows the syslog from the syslog server:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">docker exec rsyslog tail –f /var/log/messages</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following <a/>screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00008.jpg" class="calibre_373"/></p><p class="calibre_8">
</p><p id="filepos747038" class="calibre_9"><span class="calibre3"><span class="bold">The journald driver</span></span></p><p class="calibre_8">The journald logging<a/> driver sends container logs to the systemd journal. Log entries can be retrieved using the <tt class="calibre2">journalctl</tt> command. This works well in a CoreOS environment where journald is used for all the other logging.</p><p class="calibre_8">The following command starts a container with the journal driver:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">docker run --name busyboxjournallogger --log-driver=journald -d busybox /bin/sh -c "while true; do echo hello world ; sleep 5 ; done"</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following command shows the logs from journalctl with <tt class="calibre2">CONTAINER_NAME</tt> used as a filter:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">journalctl CONTAINER_NAME=busyboxjournallogger</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00360.jpg" class="calibre_406"/></p><p class="calibre_8">
</p><p class="calibre_8">The following command shows the journalctl logs in the JSON format:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">journalctl -o json CONTAINER_NAME=busyboxjournallogger --no-pager</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following screenshot is the output of the preceding command:</p><p class="calibre_9"><img src="images/00377.jpg" class="calibre_309"/></p><p class="calibre_8">
</p><div class="mbp_pagebreak" id="calibre_pb_227"/>


<p id="filepos748909" class="calibre_9"><span class="calibre3"><span class="bold">Logentries</span></span></p><p class="calibre_8">LogEntries can <a/>be used to collect logs from the host system running containers, export them to the central logging server, and analyze logs from a central <a/>server. The following diagram describes the components of the LogEntries Container architecture:</p><p class="calibre_9"><img src="images/00368.jpg" class="calibre_407"/></p><p class="calibre_8">
</p><p class="calibre_8">The following are some<a/> notes on the LogEntries Container architecture:</p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">The LogEntries container runs in the host system. It uses the Docker API to collect Container statistics, logs, and events, and transports them to a central server.</li><li value="2" class="calibre_13">The token-based system can be used to aggregate Container logs from multiple hosts. For a Container dataset belonging to a single domain, we can create a token from LogEntries and use this token in every individual host of the domain. The LogEntries agent in each host talks to the LogEntries server with this token. LogEntries aggregates log sets based on the token.</li><li value="3" class="calibre_13">As LogEntries collects Container statistics, it also displays some Container monitoring data in addition to logs.</li><li value="4" class="calibre_13">LogEntries provides extensions using Community packs. Community packs provide a way to share Search Queries, Tags, Alerts, and Widgets easily. Community packs follow a JSON structure and can be easily imported in the Logentries account via the LogEntries UI.</li><li value="5" class="calibre_13">LogEntries has both free and paid subscriptions. A paid subscription gives additional storage and enterprise-level features.</li><a/></ul><p id="filepos750962" class="calibre_14"><span class="calibre3"><span class="bold">Exporting CoreOS journal logs</span></span></p><p class="calibre_8">CoreOS uses journalctl to<a/> store logs from all services. The following Container (<a href="https://github.com/kelseyhightower/journal-2-logentries">https://github.com/kelseyhightower/journal-2-logentries</a>) can be used to send journal entries to the<a/> LogEntries server using SSL.</p><p class="calibre_8">The following are<a/> the steps necessary to export journalctl logs from CoreOS nodes:</p><div class="calibre_11"> </div><ol class="calibre_30"><li value="1" class="calibre_13">Create a token from logentries.</li><li value="2" class="calibre_13">Use the token either in a service file or inside a <tt class="calibre2">cloud-config</tt> as an option while starting the <tt class="calibre2">journal-2-logentries</tt> container. An alternate option is to update the token in etcd, which all the nodes in a CoreOS cluster can use.</li><li value="3" class="calibre_13">Update the token in etcd (for example, <tt class="calibre2">etcdctl set /logentries.com/token &lt;token&gt;</tt>).</li></ol><p class="calibre_8">The following service file can be used to start the <tt class="calibre2">journal-2-logentries</tt> container in all the CoreOS nodes of the cluster:</p><p class="calibre_8"><tt class="calibre2">[Unit]<br class="calibre4"/>Description=Forward Systemd Journal to logentries.com<br class="calibre4"/><br class="calibre4"/>[Service]<br class="calibre4"/>TimeoutStartSec=0<br class="calibre4"/>ExecStartPre=-/usr/bin/docker kill journal-2-logentries<br class="calibre4"/>ExecStartPre=-/usr/bin/docker rm journal-2-logentries<br class="calibre4"/>ExecStartPre=/usr/bin/docker pull quay.io/kelseyhightower/journal-2-logentries<br class="calibre4"/>ExecStart=/usr/bin/bash -c \<br class="calibre4"/>"/usr/bin/docker run --name journal-2-logentries \<br class="calibre4"/>-v /run/journald.sock:/run/journald.sock \<br class="calibre4"/>-e LOGENTRIES_TOKEN=$(etcdctl get /logentries.com/token) \<br class="calibre4"/>quay.io/kelseyhightower/journal-2-logentries"<br class="calibre4"/><br class="calibre4"/>[X-Fleet]<br class="calibre4"/>Global=true</tt></p><p class="calibre_8">As the logentries<a/> container uses <tt class="calibre2">journald.sock</tt>, it is necessary to export that socket using the following unit in the <tt class="calibre2">cloud-config</tt>:</p><p class="calibre_8"><tt class="calibre2">    - name: systemd-journal-gatewayd.socket<br class="calibre4"/>      command: start<br class="calibre4"/>      enable: yes<br class="calibre4"/>      content: |<br class="calibre4"/>         [Unit]<br class="calibre4"/>         Description=Journal Gateway Service Socket<br class="calibre4"/>         [Socket]<br class="calibre4"/>         ListenStream=/var/run/journald.sock<br class="calibre4"/>         Service=systemd-journal-gatewayd.service<br class="calibre4"/>         [Install]<br class="calibre4"/>         WantedBy=sockets.target</tt></p><p class="calibre_8">The following output<a/> shows the <tt class="calibre2">journal-2-logentries</tt> service running in all the CoreOS nodes of the cluster:</p><p class="calibre_9"><img src="images/00157.jpg" class="calibre_113"/></p><p class="calibre_8">
</p><p class="calibre_8">The following output shows the <tt class="calibre2">journal-2-logentries</tt> Container running in one of the nodes:</p><p class="calibre_9"><img src="images/00376.jpg" class="calibre_125"/></p><p class="calibre_8">
</p><p class="calibre_8">The following screenshot shows the LogEntries server frontend with journal logs from CoreOS nodes:</p><p class="calibre_9"><img src="images/00409.jpg" class="calibre_60"/></p><p class="calibre_8">
</p><p id="filepos754740" class="calibre_9"><span class="calibre3"><span class="bold">Container logs</span></span></p><p class="calibre_8">LogEntries can be used to <a/>export Container logs, events, and statistics. Container events could be container start, create, stop, and die events. Container logs are the stdout and stderr logs. Container statistics are CPU, memory, file, and network IO related details.</p><p class="calibre_8">The following are the steps necessary to export Container statistics and logs from CoreOS nodes:</p><div class="calibre_11"> </div><ol class="calibre_30"><li value="1" class="calibre_13">Create a token from Logentries.</li><li value="2" class="calibre_13">Use the token either in a service file or as an option while starting the docker-logentries container. An alternate option is to update the token in etcd, which all the nodes in the CoreOS cluster can use.</li><li value="3" class="calibre_13">Update the token in etcd (for example, <tt class="calibre2">etcdctl set /logentries.com/token &lt;token&gt;</tt>).</li><li value="4" class="calibre_13">To view Docker container statistics, it is necessary to use the Docker community pack. This is a JSON file and can be downloaded from <a href="https://community.logentries.com/packs/">https://community.logentries.com/packs/</a>. The following instructions (<a href="https://logentries.com/doc/community-packs/">https://logentries.com/doc/community-packs/</a>) can be used to import the Docker community pack in logentries.</li><a/></ol><p class="calibre_8">The following command can be used to start the <tt class="calibre2">docker-logentries</tt> container:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">docker run -v /var/run/docker.sock:/var/run/docker.sock logentries/docker-logentries -t &lt;token&gt;</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following service file can be used to start the <tt class="calibre2">docker-logentries</tt> container in all CoreOS nodes:</p><p class="calibre_8"><tt class="calibre2">[Unit]<br class="calibre4"/>Description=Forward Forward Container logs/stats to logentries.com<br class="calibre4"/><br class="calibre4"/>[Service]<br class="calibre4"/>TimeoutStartSec=0<br class="calibre4"/>ExecStartPre=-/usr/bin/docker kill docker-logentries<br class="calibre4"/>ExecStartPre=-/usr/bin/docker rm docker-logentries<br class="calibre4"/>ExecStartPre=/usr/bin/docker pull logentries/docker-logentries<br class="calibre4"/>ExecStart=/usr/bin/bash -c \<br class="calibre4"/>"/usr/bin/docker run --name docker-logentries \<br class="calibre4"/>-v /var/run/docker.sock:/var/run/docker.sock \<br class="calibre4"/>-e LOGENTRIES_TOKEN=$(etcdctl get /logentries.com/token) \<br class="calibre4"/>logentries/docker-logentries"<br class="calibre4"/><br class="calibre4"/>[X-Fleet]<br class="calibre4"/>Global=true</tt></p><p class="calibre_8">The following output <a/>shows the <tt class="calibre2">docker-logentries</tt> service running on all CoreOS nodes:</p><p class="calibre_9"><img src="images/00388.jpg" class="calibre_216"/></p><p class="calibre_8">
</p><p class="calibre_8">The following output shows the <tt class="calibre2">docker-logentries</tt> container running on one of the nodes:</p><p class="calibre_9"><img src="images/00187.jpg" class="calibre_408"/></p><p class="calibre_8">
</p><p class="calibre_8">I created a bunch of Containers, and stopped and deleted a few to generate different Container events and logs.</p><p class="calibre_8">The following output shows the Dashboard output that's received from the Docker community pack. The dashboard shows a summary of Container events along with Container monitoring data:</p><p class="calibre_9"><img src="images/00397.jpg" class="calibre_409"/></p><p class="calibre_8">
</p><p class="calibre_8">The following output<a/> shows the log set view, which also shows the specific containers created with each Container create event. In the following picture, we can see the create events for the Redis, WordPress, and MySQL containers:</p><p class="calibre_9"><img src="images/00029.jpg" class="calibre_410"/></p><p class="calibre_8">
</p><p class="calibre_8">To show the logging <a/>capability of LogEntries, I started the following container, which keeps sending <tt class="calibre2">hello world</tt> to stdout periodically:</p><p class="calibre_8"><tt class="calibre2"><br class="calibre4"/></tt><tt class="calibre2"><span class="bold">docker run -d busybox /bin/sh -c "while true; do echo hello world; sleep 5; done"</span></tt><tt class="calibre2"><br class="calibre4"/></tt></p><p class="calibre_8">The following output shows logs filtered by the <tt class="calibre2">busybox</tt> container name where we can see the stdout:</p><p class="calibre_9"><img src="images/00406.jpg" class="calibre_411"/></p><p class="calibre_8">
</p><div class="mbp_pagebreak" id="calibre_pb_228"/>


<p id="filepos759846" class="calibre_"><span class="calibre1"><span class="bold">Summary</span></span></p><p class="calibre_8">In this chapter, we covered ways to monitor and debug CoreOS systems as well as Docker Containers. Rather than approaching Containers and the host system as two separate entities, monitoring tools need to approach Containers and the host system as one entity and be able to provide both Container view as well as system view and correlate between the data. As Containers get deployed in hundreds and thousands across hosts, monitoring solutions need to be very scalable. There are a lot of developments happening with debugging and troubleshooting CoreOS systems and Docker Containers; multiple companies are trying to solve this problem. Companies such as Sysdig and Logentries have nice solutions to solve monitoring and logging problems. In the next chapter, we will cover production considerations for CoreOS, Docker Containers, and microservices.</p><div class="mbp_pagebreak" id="calibre_pb_229"/>


<p id="filepos760839" class="calibre_"><span class="calibre1"><span class="bold">References</span></span></p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">CoreOS Toolbox: <a href="https://github.com/coreos/toolbox">https://github.com/coreos/toolbox</a> and <a href="http://thepracticalsysadmin.com/change-coreos-default-toolbox/">http://thepracticalsysadmin.com/change-coreos-default-toolbox/</a></li><a/><li value="2" class="calibre_13">Cadvisor: <a href="https://github.com/google/cadvisor">https://github.com/google/cadvisor</a></li><li value="3" class="calibre_13">Comparing Container monitoring options: <a href="http://rancher.com/comparing-monitoring-options-for-docker-deployments/">http://rancher.com/comparing-monitoring-options-for-docker-deployments/</a></li><a/><li value="4" class="calibre_13">Sysdig: <a href="https://sysdig.com/coreos-sysdig-part-1-digging-into-coreos-environments/">https://sysdig.com/coreos-sysdig-part-1-digging-into-coreos-environments/</a>, <a href="https://sysdig.com/sysdig-coreos-part-2-troubleshooting-flannel-networking-confd/">https://sysdig.com/sysdig-coreos-part-2-troubleshooting-flannel-networking-confd/</a>, <a href="http://www.sysdig.org/">http://www.sysdig.org/</a>, and <a href="https://github.com/draios/sysdig">https://github.com/draios/sysdig</a></li><li value="5" class="calibre_13">Sysdig and Kubernetes integration: <a href="https://sysdig.com/monitoring-kubernetes-with-sysdig-cloud/">https://sysdig.com/monitoring-kubernetes-with-sysdig-cloud/</a> and <a href="https://sysdig.com/digging-into-kubernetes-with-sysdig/">https://sysdig.com/digging-into-kubernetes-with-sysdig/</a></li><a/><li value="6" class="calibre_13">Customizing the Docker remote API: <a href="https://coreos.com/os/docs/latest/customizing-docker.html">https://coreos.com/os/docs/latest/customizing-docker.html</a></li><a/><li value="7" class="calibre_13">The Docker logging driver: <a href="http://docs.docker.com/engine/reference/logging/overview/">http://docs.docker.com/engine/reference/logging/overview/</a></li><a/><li value="8" class="calibre_13">LogEntries:<a href="https://logentries.com">https://logentries.com</a></li><li value="9" class="calibre_13">Docker logging with ELK: <a href="http://technologyconversations.com/2015/05/18/centralized-system-and-docker-logging-with-elk-stack/">http://technologyconversations.com/2015/05/18/centralized-system-and-docker-logging-with-elk-stack/</a> and <a href="http://evanhazlett.com/2014/11/Logging-with-ELK-and-Docker/">http://evanhazlett.com/2014/11/Logging-with-ELK-and-Docker/</a></li><a/><li value="10" class="calibre_13">Docker logging with JSON and Syslog: <a href="https://medium.com/@yoanis_gil/logging-with-docker-part-1-b23ef1443aac#.ehjyv77n7">https://medium.com/@yoanis_gil/logging-with-docker-part-1-b23ef1443aac#.ehjyv77n7</a></li><a/></ul><div class="mbp_pagebreak" id="calibre_pb_230"/>


<p id="filepos763920" class="calibre_"><span class="calibre1"><span class="bold">Further reading and tutorials</span></span></p><div class="calibre_11"> </div><ul class="calibre_12"><li value="1" class="calibre_13">Centralizing logs from a CoreOS cluster: <a href="https://blog.logentries.com/2015/03/how-to-centralize-logs-from-coreos-clusters/">https://blog.logentries.com/2015/03/how-to-centralize-logs-from-coreos-clusters/</a></li><a/><li value="2" class="calibre_13">Docker logging enhancements with 1.7: <a href="https://blog.logentries.com/2015/06/the-state-of-logging-on-docker-whats-new-with-1-7/">https://blog.logentries.com/2015/06/the-state-of-logging-on-docker-whats-new-with-1-7/</a></li><a/><li value="3" class="calibre_13">Logging on Docker webinar: <a href="https://vimeo.com/123341629">https://vimeo.com/123341629</a></li><a/><li value="4" class="calibre_13">The dark arts of Container monitoring: <a href="https://www.youtube.com/watch?v=exna5ntTCpY">https://www.youtube.com/watch?v=exna5ntTCpY</a></li><a/><li value="5" class="calibre_13">Sysdig and Logentries webinar: <a href="https://www.youtube.com/watch?v=wNxteOCv5eE">https://www.youtube.com/watch?v=wNxteOCv5eE</a></li><a/><li value="6" class="calibre_13">Docker stats API: <a href="https://blog.logentries.com/2015/02/what-is-the-docker-stats-api/">https://blog.logentries.com/2015/02/what-is-the-docker-stats-api/</a> and <a href="http://blog.scoutapp.com/articles/2015/06/22/monitoring-docker-containers-from-scratch">http://blog.scoutapp.com/articles/2015/06/22/monitoring-docker-containers-from-scratch</a></li><a/><li value="7" class="calibre_13">Sysdig Container visibility: <a href="https://sysdig.com/let-light-sysdig-adds-container-visibility/">https://sysdig.com/let-light-sysdig-adds-container-visibility/</a></li><a/><li value="8" class="calibre_13">The Docker remote API: <a href="http://blog.flux7.com/blogs/docker/docker-tutorial-series-part-8-docker-remote-api">http://blog.flux7.com/blogs/docker/docker-tutorial-series-part-8-docker-remote-api</a> and <a href="http://blog.flux7.com/blogs/docker/docker-tutorial-series-part-9-10-docker-remote-api-commands-for-images">http://blog.flux7.com/blogs/docker/docker-tutorial-series-part-9-10-docker-remote-api-commands-for-images</a></li><a/><li value="9" class="calibre_13">Protecting the Docker daemon: <a href="https://docs.docker.com/engine/articles/https/">https://docs.docker.com/engine/articles/https/</a></li><a/></ul><div class="mbp_pagebreak" id="calibre_pb_231"/>
</body></html>