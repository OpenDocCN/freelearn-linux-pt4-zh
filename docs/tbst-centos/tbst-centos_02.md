# 第二章：故障排除活动进程

对 CentOS 7 中底层活动进程的深入理解是任何故障排除人员的必要技能。从高负载平均值到响应时间缓慢，从系统过载到死掉或将死的进程，每台服务器都会经历开始变得迟缓、表现不佳或无法响应的时刻，因此，它将需要你立即关注。

在本章中，我们将：

+   了解内存管理、交换空间、交换性和抖动

+   了解如何使用`vmstat`、`top`和`ps`命令分析活动进程

+   了解如何使用`iotop`、`iostat`和`lsof`监控服务器

+   了解系统负载和`systemd`

+   了解如何查找进程 ID、识别父进程 ID 和孤儿进程，并启动各种类型的`kill`信号

# 通过内存管理和交换空间调整服务器性能

无论你怎么看，内存使用问题始终是系统生命周期中的关键问题。无论你是在维护系统健康状态还是排除特定服务或应用程序的故障，你都需要记住，内存的使用是系统的关键资源。基于这一原因，我们将首先通过以下方式调用`free`命令：

```
# free -m

```

前面命令的主要元素看起来将类似于以下内容：

```
 Total    used    free    shared    buffers    cached
Mem:      1837     274    1563         8          0       108
-/+ buffers/cache: 164    1673
Swap:     2063       0    2063

```

在所示示例中，我使用了`-m`选项来确保输出的结果以兆字节为单位进行格式化。这样可以更容易阅读，但为了排除故障，我们不需要尝试理解每个显示的数字值，而是将原始输出的范围缩小，突出显示相关问题区域：

```
-/+ buffers/cache: 164    1673

```

这一行的重要性在于，它考虑了相关的缓冲区和缓存，以说明当前使用了多少内存以及多少内存被保留。第一个值表示使用的内存量，第二个值则告诉我们应用程序可用的内存量。在所示示例中，这意味着使用了 164 MB 内存，剩余 1673 MB 内存可用。

记住这一点，我请你注意最后一行，以便我们可以研究交换空间的重要性：

```
Swap:     2063       0    2063

```

交换通常发生在内存使用影响性能时。正如我们从前面的示例中看到的，第一个值告诉我们系统交换总量为 2063 MB，第二个值表示使用了多少交换空间（0 MB），而第三个值显示系统整体上还有多少交换空间可用（2063 MB）。因此，是的，基于此示例数据，我们可以得出结论：这是一个健康的系统，当前没有使用交换空间，但在这里，我们利用这段时间来进一步了解系统的交换空间。

首先，我们将重新访问`proc`目录，并通过输入以下命令来揭示交换空间的总大小和已用大小：

```
# cat /proc/swaps

```

假设你理解了显示的输出，那么你可以通过以下命令来调查系统使用的交换性水平：

```
# cat /proc/sys/vm/swappiness

```

完成后，你现在应该会看到一个介于 0 到 100 之间的数字值。该数字值是百分比，意味着例如如果你的系统值为 30，它将在 RAM 占用率达到 70%时开始使用交换内存。

所有 Linux 系统的默认值通常设置在 30 到 60 之间，但你可以使用以下命令中的任何一个来临时更改和修改系统的交换性。

你可以通过输入以下命令，将`X`的值替换为 1 到 100 之间的数字值来实现：

```
# echo X > /proc/sys/vm/swappiness

```

或者，更具体地说，也可以通过以下方式实现：

```
# sysctl -w vm.swappiness=X

```

如果你在任何时候改变主意，你有两个选项来确保没有做出永久更改。你可以重复执行前面两条命令中的任何一条，将值恢复到原来的状态，或者进行一次完整的系统重启。

另一方面，如果你想让更改生效并持久化，那么你应该编辑`/etc/sysctl.conf`文件，并以如下方式添加你的交换性偏好：

```
vm.swappiness=X

```

完成后，只需保存并关闭文件，以确保更改生效。

交换性值控制内核将进程从物理 RAM 移到交换磁盘的倾向。这是内存管理的一部分，但需要意识到，交换并不会立即发生，因为交换性值实际上是以百分比的形式表示的。因此，交换的过程应该更多地视为在使用缓存时的偏好度量，正如每个管理员都知道的那样，你可以通过使用命令`swapoff -a`和`swapon -a`来清除交换，以达到所需的效果。

黄金法则是要意识到，系统的交换性（swappiness）接近最大值（100）时，它会倾向于开始交换不活跃的页面。这是因为值为 100 代表着 RAM 的占用率为 0%。相比之下，系统的交换性越接近最低值（0），发生交换的可能性就越小，因为 0 代表着 RAM 的占用率为 100%。

一般来说，我们大多数人可能都会同意，拥有大量 RAM 的系统并不需要激进的交换。但为了让事情变得更加复杂，让我们换个角度来看。我们都知道，桌面电脑会从较低的交换性值中受益，但在某些情况下，你可能也会发现，拥有大量 RAM 的系统（运行批处理作业）也可能受益于适度到激进的交换，这与一个尝试做很多事情但仅使用少量 RAM 的系统类似。所以，实际上，并没有硬性规定；交换的使用应根据具体系统的需求，而不是寻找一个可以普遍适用的单一解决方案。

更进一步，在修改交换值时应特别小心，因为未被应用程序使用的内存会作为磁盘缓存使用。在这种情况下，通过减少交换性，你实际上是在增加该应用程序不被交换出去的概率，从而减少磁盘缓存的整体大小，这可能会导致磁盘访问变慢。然而，如果增加交换的优先级，由于硬盘比内存模块慢，它可能会导致整个系统响应时间变慢。交换操作可能会令人困惑，但了解这些之后，我们也能体会到交换性的隐含讽刺。正如牛顿的第三定律所说，*每一个动作都会有一个相等且相反的反应*，而找到最优的交换性值可能需要一些额外的实验。

# 使用 vmstat 管理内存

另一种内存管理的方式可以通过使用`vmstat`命令来实现。`vmstat`被认为是与内存、进程和分页相关的摘要报告功能，输入以下命令即可看到其运行：

```
# vmstat -a

```

使用`-a`选项调用所有活动和非活动内存时，`vmstat`输出中最有意义的列可以描述如下：

+   `si`: 该列显示从磁盘交换进来的值

+   `so`: 该列显示交换到磁盘的值

+   `bi`: 该列显示发送到块设备的值

+   `bo`: 该列显示从块设备接收的值

+   `us`: 该列显示用户时间

+   `sy`: 该列显示系统时间

+   `id`: 该列显示空闲时间

显示刚开始看起来可能会有些困惑，但对于我们的目的来说，我们需要集中注意以下在交换列下的几列：

```
free           si   so
1645452          0    0

```

其中`free`显示当前的空闲内存分配，`si`显示页面调入，而`so`提供页面调出。遗憾的是，单纯通过这种方式查看它，发现它对我们的需求有些局限，因此最有效的查看方法是通过在原始命令中添加延迟选项来管理输出，如下所示：

```
# vmstat X N

```

在这里，`X`是以秒为单位的数字时间值，`N`表示我们希望调用`vmstat`的次数；此代码格式的工作示范如下：

```
# vmstat 3 5

```

在这个示例中，我添加了值`3`和`5`，其中第一个数字表示延迟的秒数，第二个数字表示调用的结果次数。在这种情况下，`vmstat 3 5`将以`3`秒的延迟运行`vmstat`，并将显示`5`次更新，如下所示：

```
free        si    so
1645452       0     0
1645452       0     0
1645452       0     0
1645452       0     0
1645452       0     0

```

或者，你可以通过简化命令格式，减少复杂性，保持`vmstat`每`N`秒运行一次：

```
# vmstat N

```

所以，通过运行`vmstat 10`，`vmstat`会每`10`秒刷新一次所有活动的报告。然而，如果你需要了解事件发生的时间，可以使用`-t`选项，如下所示，调用一个带有时间戳的类似报告：

```
# vmstat -t X N

```

最后，由于默认的`vmstat`命令会以千字节为单位生成报告，为避免混淆，通常最好使用以下表达式让`vmstat`以兆字节为单位显示报告：

```
# vmstat -S M X N

```

当你启动一个应用程序并且信息被“调入”时，通常会发生页面调入（`si`）。然而，偶尔或间歇性的页面调出（`so`）也会发生，尤其是在内核释放内存的时期。定期的页面调出（`so`）或页面调出的增长是我们不希望看到的。如果这些事件的频率呈指数增长，那么这些事件就会表现为通常称为“抖动”的行为。

抖动是指系统在管理页面调度的时间超过了为应用程序或服务提供支持的时间。这不一定是一个严重的事件，但它表明故障排除人员应重新评估某些操作的价值，并考虑将它们分散到工作日的不同时间段进行处理。你总是可以为系统购买更多的 RAM，这可能在短期内有所帮助，但这并不能缩小问题的根源，也无法阻止事件的重复发生。因此，为了让我们的工作稍微轻松一点，下一步是使用`top`命令。

# 使用`top`命令检查系统负载

可以随时通过输入以下命令调用`top`命令：

```
# top

```

`top`命令是检查系统负载（RAM/MEM 和 CPU）的标准命令。它包含许多与内核相关的任务信息；显示内容会实时更新，最高负载因素以 CPU 或 MEM 的百分比表示。然而，重要的是要意识到，`top`可能会将这些值显示为超过预期的百分位范围。这是因为所有单独的核心都以百分比表示，且这些核心的多个实例会被加总。例如，一个双核系统可能会显示第一个核心为 70%，第二个核心为 60%，在这种情况下，`top`可能会显示合计 130%的结果，但你将无法得知每个核心的具体值。

你可以使用*M*键按内存对`top`进行排序，但正如你所见，`top`不仅会显示空闲内存的数量（如通过`free`命令看到的那样），它还会提供你在做某些操作和任务判断时可能需要的交换区细节。此外，你还可以通过定制输出内容来扩展`top`的功能，以显示特定用户，如下所示：

```
# top -u <username>

```

正如你所注意到的，`top` 会自动刷新；因此，在做出任何决定之前，尝试观察它几分钟。为了帮助这个过程，你可以要求 `top` 在 `10` 次循环后退出，如下所示：

```
# top -n 10

```

使用 `top` 时，你应该始终注意某些进程是由 `child-processes`（子进程）生成的，这些进程往往会单独显示（`httpd` 和 `php-fpm` 是这方面的典型例子），你可以预期这些服务会消耗最多的内存。

尽管可以看到一系列子进程使用了大量的内存，但你应该避免将 `%MEM` 列的数值相加，因为这些进程通常使用共享内存。因此，在很多情况下，你应该注意到所显示的值可能会具有误导性，出于这个原因，`top` 提供的结果不应作为你在做出最终决定之前唯一的依据。

你可以通过查看手册来了解更多关于 `top` 命令的信息，如下所示：

```
$ man top

```

# 使用 `iotop` 监控磁盘 I/O

每个管理员都知道，系统可能因为磁盘 I/O 活动过于繁重而开始变慢。然而，作为故障排除人员，你可能希望知道是哪些进程或（在多用户系统中）哪些用户是罪魁祸首，正因如此，你会想要使用 `iotop`——一个实时显示最消耗 I/O 的进程列表的工具，它以类似 `top` 的界面呈现。

首先，你需要通过输入以下命令来安装 `iotop`：

```
# yum install iotop

```

下载非常小，要开始一个发现会话，只需使用以下命令：

```
# iotop

```

运行没有任何参数的 `iotop` 会列出所有现有的进程，无论它们是否有磁盘 I/O 活动，因此，如果你只希望 `iotop` 报告那些有磁盘 I/O 活动的进程，你应该改用以下命令：

```
# iotop –o

```

输出非常详细，因为它的工作方式类似于 `top` 命令，所以熟悉后你会感到得心应手。然而，与 `top` 不同，`iotop` 显示了所有进程和线程的列表，以及磁盘活动的测量（总磁盘读取和实际磁盘读取），以便你可以快速识别哪些进程正在影响服务器上的当前 I/O 活动。

你可以通过查看手册了解更多关于 `iotop` 的信息，如下所示：

```
$ man iotop

```

# 使用 `ps` 命令检查进程

对于大多数希望更全面了解其系统中运行的进程的故障排除人员，我们可以使用 `ps` 命令，如下所示：

```
# ps aux | less

```

另外，信息可以以用户友好的树状视图模式显示，如下所示：

```
# ps axjf | less

```

如果你希望获得更少的细节，可以尝试：

```
# ps auxf | less

```

当然，我们可以在`ps`命令中使用更多的选项。例如，命令可以通过管道传输并与`grep`或`tail`结合使用，你还可以使用诸如`ps -e`这样的显式语句（显示系统中的所有进程）。或者，你也可以通过输入以下命令来定位特定进程：

```
# ps aux | grep <process_name>

```

此外，你甚至可以扩展其用法，显示所有进程（除了以 root 身份运行的进程），通过以下变化：

```
# ps -U root -u root -N

```

对于特定用户，你可以使用：

```
# ps -u <username> u

```

最后，你可以获得更多的安全信息，并将结果输出到文本文件中，方式如下：

```
# ps axZ > /path/to/filename.txt

```

基于这一点，我想你会同意说`ps`不仅有用，而且它的灵活性和可定制性使其成为故障排除工具箱中一个重要的工具。`ps`命令可以用于显示系统当前进程的快照，但对于本章来说，我们更关心的是`ps`命令还能为我们提供相关的进程 ID。通常简化称为`PID`，这个关键信息将在我们稍作岔开后重新提到，我们将深入了解系统负载。

# 使用 iostat 和 lsof 检查性能

在已经发现`vmstat`可以用于提供与内存管理相关的统计信息后，解决与性能相关的问题时，过载的 CPU 是另一个需要关注的领域。为此，我们可以像下面这样使用`iostat`命令：

```
# iostat

```

然而，要显示更互动的 CPU 利用率报告，你可以使用`–c`选项（并提供一个以秒为单位的数值，如 5 秒），像这样：

```
# iostat –c 5

```

大多数列应该是自解释的，但如果系统变得繁忙，你会看到`%iowait`的增加，这用于报告任何 I/O 请求完成等待时间的增加。基于此，如果服务器正在传输或复制大量文件，你可能还会注意到额外的时间花费在系统级别，因为文件将被移动进出相关的磁盘分区。在尝试监控存储设备以寻找可能的瓶颈时，`iostat`与数值参数结合使用是特别有用的，如下所示：

```
# iostat 5

```

正如你所看到的，要检查读/写操作，我们只是简单地为`iostat`添加了一个轮询选项。当然，你可以将这些知识与运行`vmstat –d`或`vmstat –p <partition_name>`命令获得的见解结合使用，但通过使用`–t`选项，你还可以为该命令添加时间戳，像这样：

```
# iostat –t 5

```

你应该知道`iostat`报告会持续运行，直到该进程被取消。然而，通过这些观察，现在使用`top`和其他所有命令应该会让你感到更加满意。使用以下命令的技巧特别受欢迎，因为你可以通过`lsof`命令查看打开的文件列表：

```
# lsof | less

```

### 注意

使用 `lsof` 时，重要的是要注意，第一列将显示使用相关文件的命令、该命令的进程 ID（`PID`）、用户以及打开的文件名。

因此，考虑到这一点，并意识到本章中讨论的每个命令都是相互关联的，我们回到系统负载这一重要话题。

# 计算系统负载

系统负载是衡量计算机系统当前正在执行的处理量的指标。它不是衡量计算机性能的完美方式，但它确实为故障排除人员提供了修复系统所需的附加证据。

与负载计算最常相关的表达式是：

*实际负载 = 总负载（运行时间）/ CPU 数量*

如你所知，CPU 数量已知，你可以通过查看 `top` 命令的结果或输入以下命令来计算运行时间：

```
# uptime

```

前述命令的输出可能如下所示：

```
09:59:41 up  2:36,  1 user,  load average: 0.01, 0.02, 0.05

```

服务器负载是基于 1 分钟、5 分钟和 15 分钟的读取时间表示的数值。因此，通过查看前述输出中的最后三个值，我们可以看到，对于该系统，平均负载为 `0.01`（1 分钟时），`0.02`（5 分钟时）和 `0.05`（15 分钟时）。

当前，示例系统没有出现疲劳的迹象，但由于高负载的原因可能各异，这并不意味着该机器的当前状态在工作日内不会发生变化。高负载可能是数据库连接、磁盘输入输出、编码不良、网站访问频率、电力消耗大的应用程序或电子商务网站、脚本攻击、垃圾邮件、批处理作业等原因引起的。如果你遇到这种情况，只需运行 `top` 命令，并按常规方式开始排查系统。大多数情况下，可以找到短期解决方案（尤其是在网站在高峰时段接收到大量访问时），但只有长期计划才能防止这种情况再次发生。

在故障排查负载时，重要的是要知道，当负载增加时，处理器会排队，如果有多个处理器，负载会均匀分布到服务器的各个核心上以平衡工作负载。通常认为，服务器的理想负载值应设置为 1\。这并不意味着一旦达到或超过此值就需要立即按下“紧急按钮”，但如果你在一段时间内开始看到双位数的响应，那么是的，期望服务器（负载值 > 1）可能会在工作负载（负载值 > 10）的压力下开始出现问题。

因此，考虑到这一点，我们回到进程 ID 的话题。

# 使用 pgrep 和 systemctl 查找进程 ID

与其使用 `ps`，另一种查找特定进程 ID 的方法是使用 `pgrep` 命令，如下所示：

```
# pgrep <servicename>

```

在大多数情况下，使用此命令将显示进程 ID 或`PID`。但是，采用这种方法时，输出也可能提供多个值。所以请记住，如果某个应用程序（如`httpd`或`ssh`）提供了一个或多个进程 ID，你可以安全地假设最小的数字（代表系统生成的第一个`PID`）是最重要的。这个值被称为`PPID`或父进程 ID。

另一方面，一种更简洁的方法可以通过利用`systemd`，使用以下命令：

```
# systemctl status <service_name>.service

```

前述命令的输出将类似于以下示例，正如我们所见，Apache 的主`PID`是`2413`：

```
httpd.service - The Apache HTTP Server
 Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled)
 Active: active (running) since Sun 2014-12-14 01:26:37 GMT; 2min 56s ago
 Main PID: 2413 (httpd)
 Status: "Total requests: 0; Current requests/sec: 0; Current traffic:   0 B/sec"
 CGroup: /system.slice/httpd.service
 ├─2413 /usr/sbin/httpd -DFOREGROUND
 ├─2414 /usr/sbin/httpd -DFOREGROUND
 ├─2415 /usr/sbin/httpd -DFOREGROUND
 ├─2416 /usr/sbin/httpd -DFOREGROUND
 ├─2417 /usr/sbin/httpd -DFOREGROUND
 └─2418 /usr/sbin/httpd -DFOREGROUND

```

Linux 注重选项，没错，有许多方法可以获取所需的进程 ID（`PID`）或父进程 ID（`PPID`），但我们不会遍历所有选项（包括旧的和新的）。单就速度而言，我想你会同意，利用`systemd`命令有其自身的优势。

# 更多关于 systemd 的信息

`systemd`系统和服务管理器负责控制 CentOS 7 上如何管理服务。现在的情况发生了很大变化，结果是，你需要认识到，脚本的位置已经更改为`/usr/lib/systemd/systemd`，而旧的命令将被弃用到一定程度（最终）它们将被彻底移除。

例如，当使用`systemd`检查状态或启动或停止服务时，你可以使用以下命令之一：

```
# systemctl status <service_name>.service
# systemctl stop <service_name>.service
# systemctl start <service_name>.service

```

此外，与其使用`chkconfig`来启用和禁用引导序列中的服务，现在你应该使用：

```
# systemctl enable <service_name>.service
# systemctl disable <service_name>.service

```

你可能对这种方法持有不同意见，但与其纠结于变化的主题，不如考虑如何利用新命令让故障排除变得更加轻松。为此，我们将从一个简单的方法开始：列出当前所有服务，使用以下命令：

```
# systemctl list-units --type service

```

现在，一切都被称为单元，认识到这一点后，相同的命令还可以修改为显示所有挂载：

```
# systemctl list-units --type mount

```

与此同时，调用以下命令可以列出所有服务的依赖项：

```
# systemctl list-dependencies <service_name>.service

```

此外，`systemd`还自带了自己的`top`版本，若要查看与特定服务相关的进程，可以使用`system-cgtop`命令，如下所示：

```
# systemd-cgtop

```

正如你会注意到的，这个命令提供了所有相关进程的总结，并显示了路径、任务数量、CPU 使用百分比、内存分配以及相对的输入和输出。它的工作方式类似于`top`，但不同的是，它的使用可以修改为输出递归的服务内容列表，如下所示：

```
# systemd-cgls

```

输出将类似于以下内容：

```
 ├─smb.service
 │ ├─2472 /usr/sbin/smbd
 │ └─2473 /usr/sbin/smbd
 ├─httpd.service
 │ ├─2394 /usr/sbin/httpd -DFOREGROUND
 │ ├─2395 /usr/sbin/httpd -DFOREGROUND
 │ ├─2396 /usr/sbin/httpd -DFOREGROUND
 │ ├─2397 /usr/sbin/httpd -DFOREGROUND
 │ ├─2398 /usr/sbin/httpd -DFOREGROUND
 │ └─2399 /usr/sbin/httpd -DFOREGROUND
 ├─polkit.service
 │ └─875 /usr/lib/polkit-1/polkitd --no-debug
 ├─auditd.service
 │ └─672 /sbin/auditd -n

```

所以，正如我们所看到的，在许多方面，`systemd`虽然冗长，但它确实在试图获取有关活动进程的某些信息时节省了我们的时间。在这个阶段，重要的是要意识到，我们只触及了`systemd`的皮毛，但就本章的目的而言，我相信你继续使用它的过程将会既富有成效又愉快。

# 发出终止信号

想要了解进程 ID 的最常见原因是将这些信息传递给`kill`命令。进程 ID 确实有其他用途，但我们的主要关注点是通过发出终止信号（`SIGTERM`）来移除有问题的服务或应用程序，如下所示：

```
# kill pid_of_process

```

`kill`信号指示进程终止，从而使相关进程能够执行一些基本的清理操作，并以有序的方式退出。这种方法被称为“安全终止”。然而，根据你的具体情况，更好的解决方案可能是强制让服务或应用程序挂起，从而启用守护进程的自动重新加载，如下所示：

```
# kill -1 pid_of_process

```

这个命令被称为`SIGHUP`或`挂起`命令。另一方面，如果进程似乎崩溃了，并且安全终止或重新加载操作无法产生任何效果，那么通过传递以下命令，你将能够直接终止该进程：

```
# kill -9 pid_of_process

```

在此命令中使用选项`9`表示发出一个信号终止（`SIGKILL`），与原始的终止命令（`SIGTERM`）不同，这个替代版本直接发给内核，从而以更为突然的方式终止进程。此命令没有清理操作或安全退出，因此它被称为“强制终止”。

最后，为了进一步解决“强制终止”问题，使用`pkill`命令也是完全合适的，语法如下：

```
# pkill -9 httpd

```

另外，你可以使用`pgrep`命令确保所有与相关搜索词相关的进程被移除：

```
# pgrep httpd

```

所以，涵盖了`kill`命令的最常见用法后，剩下的技巧之一是基于需要处理孤儿进程。

# 处理孤儿进程

孤儿进程并不是常见的问题，但它们确实会发生，解决这些问题的第一步是通过匹配显示的`PID`或`PPID`与`init`进程本身使用的 ID。使用`ps`命令可以显示，二者的`PPID`都等于`1`。说实话，你可能会意识到孤儿进程和守护进程之间几乎没有区别，唯一的区别是孤儿进程是由于错误产生的。因此，这里的黄金法则是记住，通过一个相对简单的技巧可以识别孤儿进程，并且它可以通过标准方式终止。

孤儿进程可能由多种原因引起，尽管它们已经被 `init` 进程采纳，你仍然会发现它们在执行命令。因此，孤儿进程是潜在的危险，因为它们会继续占用系统资源，导致系统资源短缺。在某些情况下，过多的孤儿进程可能会导致 `init` 进程过载，并造成系统挂起。虽然这种情况不常见，但删除这些错误的守护进程对于故障排除人员来说是一个重要任务，如果你的系统容易发生这种情况，那么你应该时刻关注它。

# 总结

本章的目的是阐明一些关于故障排除活动进程的概念，在这方面，我们已经涵盖了 `swap`、`vmstat`、`top`、`ps`、进程 ID、`kill` 和 `pkill` 等内容。当然，除了这些工具，你还可以使用更多其他工具，但对于大多数故障排除人员（无论是初学者还是有经验的），了解如何监控和测量内存使用情况；确定服务器负载；关注耗电的应用程序、服务或用户；删除孤儿进程；以及使用 `systemd`，这将对你大有帮助，之后我们可以继续考虑如何故障排除网络问题。

# 参考资料

+   Red Hat Enterprise Linux 7 系统管理员指南: [`access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/chap-Managing_Services_with_systemd.html`](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/chap-Managing_Services_with_systemd.html)

+   Swappiness 维基百科页面: [`en.wikipedia.org/wiki/Swappiness`](http://en.wikipedia.org/wiki/Swappiness)

+   `vmstat` 命令维基百科页面: [`en.wikipedia.org/wiki/Vmstat`](http://en.wikipedia.org/wiki/Vmstat)

+   `iostat` 命令维基百科页面: [`en.wikipedia.org/wiki/Iostat`](http://en.wikipedia.org/wiki/Iostat)

+   `lsof` 命令维基百科页面: [`en.wikipedia.org/wiki/Lsof`](http://en.wikipedia.org/wiki/Lsof)

+   `kill` 命令维基百科页面: [`en.wikipedia.org/wiki/Kill_(command)`](http://en.wikipedia.org/wiki/Kill_(command))

+   `pkill` 命令维基百科页面: [`en.wikipedia.org/wiki/Pkill`](http://en.wikipedia.org/wiki/Pkill)

+   SysVinit 到 Systemd 备忘单: [`fedoraproject.org/wiki/SysVinit_to_Systemd_Cheatsheet`](https://fedoraproject.org/wiki/SysVinit_to_Systemd_Cheatsheet)

+   孤儿进程维基百科页面: [`en.wikipedia.org/wiki/Orphan_process`](http://en.wikipedia.org/wiki/Orphan_process)
