# 第一章：CentOS 故障排除基础

**CentOS**，即**社区企业操作系统**，以其强大、稳定和无故障的特性而闻名，特别适合作为服务器操作系统。被各类组织广泛使用，CentOS 在全球许多关键任务环境中都能找到其身影。然而，随着服务器需要按需运行且不中断地提供服务，某些时候，需要冷静但果断的手段来恢复服务，或对现有应用程序进行最后的调整，以确保能够尽快恢复到“正常工作状态”。

*“服务器已经崩溃，所有的麻烦即将爆发。”*

在一个不完美的世界里，事情可能会出错（并且不可避免地出错），但正是你对 CentOS 7 的整体理解以及它所提供的信心，构成了你故障排除技能的基础。记住，故障排除是一个调查过程，最终会得出诊断结果。所有系统都是不同的，对同一情况的处理方法也会根据系统的目的有所不同。因此，考虑到这一点，重要的是要意识到本书的前提并不是基于具体的操作步骤，而是更多地关注使用的工具和你将要遇到并与之互动的资源。

在本章中，我们将：

+   学习如何在 CentOS 上安装一些基本工具

+   探索如何使用`lscpu`和`lspci`收集基于硬件的系统信息

+   进一步了解`dmesg`的重要性及其与内核的交互

+   了解更常见的日志文件及其如何影响日志输出

+   学习如何使用`grep`、`tail`、`cat`、`less`、`truncate`等命令行功能操作任何类型的文件

# 安装一些基本工具

本书假设你已经能够访问与服务器故障排除相关的基本工具。将提及一些较为冷僻的工具，并会提供相应的使用说明；然而，对于那些可能有或没有基本工具箱的读者，作为 root 用户，你可能想要从运行以下命令开始：

```
# yum groupinstall "Base" "Development Libraries" "Development Tools"

```

该操作（如果确认执行）将开始下载并安装 CentOS 服务器系统的常用开发工具、库和基础组件。它还包含 RPM 所需的相关工具、额外的文本编辑器以及编译自定义包所需的包。

### 注意

在开始时安装这些软件包是可选的，所有这些软件包都可以根据需要单独安装。然而，在灾难恢复规划至关重要的环境中，考虑到服务器在任何问题发生之前就应具备一切所需，值得一提。

所以，在为系统准备好必要的工具和实用程序后，我们将正式开始，仔细查看硬件。为了做到这一点，建议你继续以 root 权限访问相关系统。

# 收集硬件信息

从原则上讲，大多数人倾向于建议将所有系统信息分为硬件或软件两类。这种方法确实有助于简化问题，但在本章中，我将通过一些方式推测，在某些情况下，硬件和软件的相互作用可能是问题的根源。

因此，在开始故障排除之前，始终考虑收集系统信息是获得更多洞察和熟悉度的推荐方法。这样来看：收集硬件信息的实践并不是必须的，但这种类型的调查可能有助于你寻找最终的诊断结果。

首先，我们将通过以下命令运行一个简单的基于 CPU 的硬件报告：

```
# cat /proc/cpuinfo

```

如你所见，此命令的目的是输出与 CPU 型号、家族、架构、缓存等相关的所有信息。`/proc` 方法一直是一个不错的传统，但使用以下命令通常被认为是更好的做法，并且更易于使用：

```
# lscpu

```

此命令将查询系统，并以以下方式输出与 CPU 相关的所有信息：

```
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                2
On-line CPU(s) list:   0,1
Thread(s) per core:    1
Core(s) per socket:    2
Socket(s):             1
NUMA node(s):          1
Vendor ID:             GenuineIntel
CPU family:            6
...

```

另一方面，与其查询所有内容，你可以使用 `grep`（这是我们稍后会回到的主题）来指定条件，从而获取任何相关信息，像这样：

```
# lscpu | grep op-mode

```

因此，完成这些操作并记录结果以备将来参考后，我们将继续进行调查，通过以下方式运行简单的硬件报告，使用 `lspci` 命令：

```
# lspci

```

该命令的输出可能类似于以下信息：

```
00:00.0 Host bridge: Intel Corporation 82P965/G965 Memory Controller Hub (rev 02)
00:01.0 PCI bridge: Intel Corporation 82G35 Express PCI Express Root Port (rev 02)
00:05.0 Ethernet controller: Red Hat, Inc Virtio network device
00:0a.0 PCI bridge: Digital Equipment Corporation DECchip 21150
00:0e.0 RAM memory: Red Hat, Inc Virtio memory balloon
00:1d.0 USB controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 02)
00:1d.7 USB controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB2 EHCI Controller (rev 02)
00:1e.0 PCI bridge: Intel Corporation 82801 PCI Bridge (rev f2)
00:1f.0 ISA bridge: Intel Corporation 82801HB/HR (ICH8/R) LPC Interface Controller (rev 02)

```

`lspci` 命令提供有关服务器的 PCI 设备的所有相关信息，进一步的信息可以通过使用 `-v` 选项或其他 `-vv` / `-vvv` 选项来扩展，具体取决于你所需的详细程度：

```
# lspci -v
# lspci -vv
# lspci -vvv

```

默认情况下，上述命令将提供所有所需的信息，以便确认设备是否受到当前系统中任何模块的支持。预计你只需要在实施硬件升级后、新安装系统时，或者尝试熟悉新环境时执行此操作。然而，为了进一步简化此过程，你会高兴地知道，还可以使用“树状视图模式”。这个功能的目的是输出相关的设备 ID，并展示这些值如何与相应的总线相关联。

要做到这一点，输入以下命令：

```
# lspci -t

```

作为一名故障排除员，您会知道每个设备都必须维护一个唯一的标识符，因为 CentOS 与其他操作系统一样，将使用该标识符将驱动程序绑定到该设备。`lspci`命令通过扫描`/sys`树来检测所有连接的设备，这些设备可以包括连接端口、设备类型和类别，仅举几例。完成此操作后，`lspci`命令将查阅`/usr/share/hwdata/pci.ids`，以提供它所显示的可读条目。

例如，您可以通过输入以下带有`-k`选项的`lspci`命令来显示内核驱动程序/模块，像这样：

```
# lspci -k

```

自然，在任何基于硬件的故障排除调查中，您都会想查看系统日志以获取更多线索，但正如我们所看到的，`lscpu`和`lspci`命令在尝试发现系统中所需的硬件信息时尤其有用。

您可以随时通过查看相应的车载手册来了解更多关于这些命令的信息：

```
$ man lscpu
$ man lspci

```

同时，如果您想要更多练习，一个简单的测试就是插入一个 USB 闪存驱动器，并通过仔细查看`/var/log/messages`中的枚举信息来分析您自己得到的结果。

### 注意

请记住，如果您确实尝试了这个操作，您所看到的是系统在插入 USB 驱动器后的反应；您不一定是在查看 USB 驱动器本身；关于 USB 的信息可以通过`lsusb`获得。

另一方面，就像我们可以将`grep`与`lscpu`一起使用一样，如果您已经习惯了这种类型的调查，那么您可能会想知道，您还可以将`grep`与`lspci`命令一起使用，以下面这种方式来发现更多关于 RAID 控制器的信息：

```
# lspci | grep -i raid

```

现在，我相信您不会感到惊讶，知道还有许多与获取硬件信息相关的命令。这些包括（但不限于）`lsmod`、`dmidecode`、`hdparm`、`df -h`，甚至是`lsblk`，以及在本书中将提到的许多其他命令。它们都很有用，但对于那些不想记住它们的人，可以通过简单地阅读`/proc`和`/sys`目录中的文件找到大量信息，像这样：

```
# find /proc | less
# find /sys | less

```

因此，在我们继续之前，你现在应该知道，当你处理硬件分析时，提升你的技能是通过长时间接触服务器来实现的。我这么说的原因是基于这样一种观点：一个简单的安装过程几乎可以立即识别出这些问题，但没有这个便利的情况下，随着时间的推移，硬件可能需要更换或维护。RAID 电池组会故障，内存模块会故障，有时可能是某个特定驱动程序在最近一次重启时没有完全加载。在这种情况下，你可能会发现内核正以如此高的频率向系统发送随机消息，以至于它表明一个完全不同的问题导致了故障。所以，是的，硬件故障排除需要耐心和观察力，这也是为什么对`lscpu`和`lspci`命令的快速回顾成为我们故障排除 CentOS 7 的引言。

# 理解 dmesg

在我们深入探讨日志文件的主题之前，我想花几分钟时间讨论一下`dmesg`命令的重要性。

`dmesg`命令用于记录与硬件检测和配置过程相关的内核消息。我此时不打算深入讲解技术细节，但重要的是要意识到，这些信息来源于内核环形缓冲区；这个条件不仅在硬件故障排除时非常有帮助，而且也为理解系统硬件如何反映在可能的软件诊断上提供了证据，反之亦然。

`dmesg`文件位于`/var/log/`目录中，但与该目录中其他文件不同，查看`dmesg`文件内容的基本语法如下：

```
# dmesg | less

```

你可以像往常一样翻页查看结果，但如果你希望让时间戳更容易阅读，你可能希望像这样调用`-T`选项：

```
# dmesg -T | less

```

这些命令将向我们提供与启动过程中加载到内核中的所有硬件驱动程序相关的信息。这些信息将包括它们的状态（成功或失败），如果记录到失败，它甚至会提供一个错误消息，描述失败发生的原因。然而，由于该文件可能非常庞大，你应该使用`grep`查询`dmesg`以简化这些信息并简化输出。

为此，只需根据你的需求定制以下语法：

```
# dmesg -T | grep -i memory

```

这个命令将显示所有与服务器相关的总内存和共享内存细节的相关信息。当然，类似的方法也可以用来读取 USB 设备、直接内存访问（DMA）或甚至 tty 的具体信息。

例如，你可以查询 `dmesg` 来以以下方式显示与任何以太网端口相关的硬件信息：

```
# dmesg –T | grep -i eth0

```

根据你的系统配置，输出将类似于以下内容：

```
[Sun Apr 19 04:56:57 2015] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready

```

为了扩展这一方法，你可以修改之前的命令，以发现内核是否已检测到特定的硬盘。为此，请输入：

```
# dmesg –T | grep sda

```

或者，你可以使用 `-i` 选项忽略搜索 `tty` 引用时的大小写敏感性：

```
# dmesg | grep -i tty

```

正如你将看到的，`dmesg` 文件的输出非常冗长，文件中包含的信息可以用于故障排除几乎任何问题，从网络卡到存储问题。`dmesg` 文件可能不会直接给出你想要的答案，但它提供了一个拼图的另一部分，当与一些常见的 CentOS 操作系统日志文件中的信息结合使用时，它会帮助你找到解决方案。

# 理解日志文件

默认情况下，所有 CentOS 系统日志文件都可以在 `/var/log` 中找到，可以通过输入以下命令获取当前服务器的完整清单：

```
# find /var/log

```

话虽如此，每个系统都是不同的，为了简化操作，你会发现一些常见的日志文件（与 CentOS 7 最小化安装相关的）包括：

+   `/var/log/messages`：该文件包含与 CentOS 使用的许多本地服务相关的信息。包括（但不限于）内核日志、网络管理器、引导过程、邮件服务、`cron` 任务以及许多没有自己日志文件的其他服务。在许多方面，这个记录可以被认为是某种全球性日志文件，出于习惯，它可能会成为你在任何故障排除过程中首先访问的文件。

+   `/var/log/boot.log`：该文件包含系统启动时报告的信息。

+   `/var/log/maillog`：该文件包含由系统默认邮件服务器报告的信息。

+   `/var/log/secure`：该文件包含与认证和授权权限相关的信息。

+   `/var/log/wtmp`：该文件包含与用户登录记录相关的信息。

+   `/var/log/btmp`：该文件包含与登录失败尝试相关的信息。

+   `/var/log/cron`：该文件包含与 cron（和 anacron）相关的信息。

+   `/var/log/lastlog`：该文件包含与包含所有最后登录信息的二进制日志相关的信息。

+   `/var/log/yum.log`：该文件包含与 Yum 相关的信息，并报告与服务器包管理工具相关的任何活动。

现在，在继续之前，我想提醒你这些文件的重要性，因为通常建议将 `/var/log` 存储在与 `/`（根目录）不同的分区中。

一个完美的系统应为`/tmp`、`/usr`等目录维护单独的分区，但确实也有可能在某些情况下，日志文件不得不与`/`（根）分区存储在同一分区上。因此，请记住，如果有这样的机会，您可能需要考虑将这些目录存储在一个独立的文件系统和独立的物理卷上（如果可能），因为这被认为是保持系统安全性、完整性和性能的良好实践。

然而，话虽如此，仍然需要认识到，许多其他软件包会在其他位置创建和存储日志文件。您甚至可能需要自行指定这些位置，因此应该记住，并非所有日志都位于`/var/log`目录下。

例如，如果相关服务器托管一个或多个网站，并将所有相关的 Apache 虚拟主机信息存储在特定的`/home`目录中，那么相关的日志文件可能会存储在如下位置：

```
/path/to/virtualhost/domain1/log/access_log
/path/to/virtualhost/domain1/log/error_log

```

许多其他软件包也面临同样的问题，原因在于这些软件包可能没有写入该目录所需的权限，而其他软件包则设计为将所有日志活动保存在其自己的安装目录中。因此，根据您的系统特性，您可能需要花些时间分析服务器的安装结构，以便找到适当的日志文件。

# 阅读日志文件并影响输出

查看或读取日志文件非常容易，且根据个人偏好，查看这些文件的基本语法可以用以下任意一种格式表达：

```
# less /var/log/filename
# more /var/log/filename
# cat /var/log/filename
# cat /var/log/filename | less
# cat /var/log/filename | more

```

### 注意

请记住，根据系统配置，您可能需要根用户权限才能查看特定的日志文件。试图更改任何系统文件时，也可能需要类似的权限，因此，我们将继续以根用户身份操作。然而，使用`sudo`或`su`（切换用户）的用户应相应地调整指令。

日志文件在不同的应用程序和服务之间可能有所不同，但这些文件的主要目的是记录事件的时间和日期以及安全级别，并提供一条消息或一般描述。大多数消息将是某种类型的常规通知或警告，但在某些情况下，也会捕获错误。

例如，您可能会看到如下内容：

```
Dec  4 12:49:05 localhost postfix/postfix-script[1909]: starting the Postfix mail system

```

这样的消息很普通，仅仅解释发生了什么以及何时发生。是的，你可以放心地忽略它们，但由于你看到的消息数量较多，有些人可能会觉得系统对一些事情过于敏感，导致日志文件被低级信息淹没。对于很多人来说，这些信息可能没有实际用途，但在某些情况下，你可能会认为提供的信息不够详细，可能需要更多的信息。最终，只有你能决定最适合你的需求。所以，为了举个例子，假设我们要提高日志敏感度来排查系统问题。

为此，我们将首先运行以下命令：

```
# cat /proc/sys/kernel/printk

```

前面的命令输出允许你查看当前的内核设置，典型系统中会是如下所示：

```
4       4       1       7

```

这里存在一个关系，重要的是你理解`printk`维护着四个数值，这些数值控制与错误消息日志记录相关的多个设置，同时每个错误消息也有其专属的日志级别，用来定义该消息的重要性。

日志级别值可以总结如下：

+   `0`：内核紧急

+   `1`：内核警报；必须立即采取行动

+   `2`：内核状态被认为是关键的

+   `3`：一般内核，错误条件

+   `4`：一般内核，警告条件

+   `5`：内核正常但重要的情况通知

+   `6`：内核信息性消息

+   `7`：内核调试级别消息

所以，基于以上信息，`4`、`4`、`1` 和 `7` 的日志级别值告诉我们，接下来显而易见的是：

+   第一个值（`4`）称为控制台日志级别。这个数值定义了打印到控制台的消息的最低优先级，意味着优先级越低，日志级别数字越高。

+   第二个值（`4`）确定了所有没有专属日志级别的消息的默认日志级别。

+   第三个值（`1`）确定了整体控制台日志级别的最低可能日志级别配置。优先级越低，日志级别数字越高。

+   第四个也是最后一个值（`7`）确定了整体控制台日志级别的默认值。同样，优先级越低，日志级别数字越高。

因此，你现在可以考虑通过配置文件`/etc/sysctl.conf`来修改日志级别。这个文件使你能够对默认设置进行细微调整，并且可以通过你喜欢的文本编辑器以以下方式访问：

```
# nano /etc/sysctl.conf

```

要进行所需的更改，请使用以下语法：

```
kernel.printk = X X X X

```

这里，`X`的实际值是从前面描述的选项中获取的日志级别设置。

例如，你可以通过添加以下行来改变消息数量：

```
kernel.printk = 5 4 1 7

```

当然，这样的修改意味着对内核的更改，因此重启是必要的。所以，完成这一步后，你会发现运行`cat /proc/sys/kernel/printk`的输出现在应该反映新的值。然而，作为补充的警告，考虑到执行此操作（是的，你可以轻松地撤销任何已做的更改），重要的是要意识到关于更改这些设置的有效性存在许多问题。换个角度看：这可能完全不帮助你，因此在进行这些更改之前，你应始终阅读相关资料，以确认做出这一修改是否符合你的总体目的。

要查看内建的手册，只需使用以下命令：

```
$ man sysctl

```

另一方面，对于服务器上许多其他服务和应用程序，你将有额外的调查途径需要考虑，这些途径通常是由相关服务或应用程序本身设置的。

一个常见的例子是 Apache。因此，如果你在调试与该服务相关的 Web 问题时，你可能会倾向于打开`httpd`配置文件，如下所示：

```
# nano /etc/httpd/conf/httpd.conf

```

查找或搜索以下行：

```
LogLevel warn

```

然后，替换该指令为更合适的设置（在保存文件并重启服务之前）。在这种情况下，你可以使用：

```
LogLevel debug

```

幸运的是，知道大多数服务和应用程序确实支持一种调试模式，以改善日志输出，这是一件好事。这将使日志文件更加详细并且在排除服务器故障时更容易处理，但在我们结束这个话题之前，有一个小的注意事项……

当你处理日志文件时，应该意识到这些日志文件中包含的信息并不总是足以帮助你诊断当前的问题或发现问题的根本原因。日志文件不仅可能缺少必要的信息，还可能包含未知的错误和误导性的消息。毕竟，日志文件仅包含一系列（主要是）预定义的消息或包中的断点，这些消息是由程序员设计的，用于备注可能发生过或已经发生的已知事件。

### 注意

**记住……**

在影响日志文件输出时，详细的输出可能会引发性能或安全问题，而详细的日志记录还可能对 CPU 或磁盘 I/O 操作造成不必要的负担。

根据这些情况，没有固定的规则，因为我们也知道日志文件是有局限性的。所以，最终你将依赖于敏锐的观察力和大量的耐心，仅仅基于这些原因，你必须始终学会“整体倾听服务器”。

这样说吧：答案在那儿，但可能不在日志文件中。坚持不懈和冷静（但坚定）的态度将最终胜出，而这一点将贯穿本书的每一页。

# 使用 tail 监控日志文件

所以，掌握了之前的信息，并且知道日志文件通常通过指定事件发生的时间、严重程度和预定的消息来描述事件，成功的关键在于能够处理这些记录并以某种方式操作它们，使它们为我们提供完成任务所需的信息。

在故障排除过程中，你将使用的最有用的命令之一是 `tail`。以下是一个命令行表达式，可以用来读取日志文件的最后几行：

```
# tail -n 100 /var/log/maillog

```

同样，`tail` 也可以用来获取最近添加的行，像这样：

```
# tail -f /var/log/maillog

```

使用此命令不仅可以为你提供日志文件的最新视图，还能确保所有更新立即显示，这为你提供了一种在实时环境中阅读日志文件的即时方式。这种方法可以被描述为解决 Apache、Postfix、Nginx、MySQL 以及你的服务器可能使用的其他许多应用程序或服务故障的完美方式。

例如，你可以像这样查看 Apache 的 `access_log`：

```
# tail -f /var/log/httpd/access_log

```

为了进一步拓展这个功能，假设你想获取日志文件中的最后 3,000 行，知道它将无法适应你的 shell 窗口。为了满足这个需求，你可以像这样使用管道将结果与 `less` 命令结合：

```
# tail -n 3000 /var/log/messages | less

```

在这种情况下，你现在可以根据需要分页结果，但使用这种技术几次后，我想你会同意，它比使用通用的 `cat` 命令要灵活得多；除非，当然，你想做一些非常具体的事情。

# 使用 `cat`、`less` 和 `more`

`cat` 命令已经陪伴我们很长时间了，回到之前我们讨论的硬件和 `/proc` 目录的内容，你可以使用 `cat` 命令查看服务器 CPU 的详细信息：

```
# cat /proc/cpuinfo

```

如果你想了解更多关于服务器内存的信息，你可以使用：

```
# cat /proc/meminfo

```

然后，你总是可以通过输入以下命令来了解更多关于你的设备的信息：

```
# cat /proc/devices

```

尽管 `cat` 非常有用，但它也因将整个内容输出到屏幕上而闻名，如果文件超过 1,000 行，可能会显得有些笨拙。因此，在这种情况下，另一种选择是使用 `less` 和 `more` 命令，以分页的方式查看特定的（静态）文件，如下所示：

```
# less /var/log/messages
# more /var/log/messages

```

然而，由于 `more` 命令相对较旧，大多数人会认为 `less` 更加优越。`less` 命令类似于 `more`，但 `less` 允许你在分页结果之间前后导航。所以，是的，这是一个老笑话，但从现在起，并且在任何可能的情况下，始终记住，`less` 确实意味着 `more`。

例如，`less` 允许你搜索特定的字符串。为此，只需像这样使用 `less` 打开以下文件：

```
# less /var/log/messages

```

现在，在屏幕的左下角，输入 `/`，后面跟着一个字符串值，像这样：

```
/error

```

输出现在将调整为突出显示搜索结果，如果你想查看更多选项，只需在 `less` 打开时按 *H* 键。

# 使用 grep

现在，让我们考虑一下需要在服务器的日志文件中查找特定关键字的情况。

在这种情况下，你将使用名为 `grep` 的命令，这也是当你想对服务器上的几乎任何文件执行高级基于字符串的搜索时，非常有用的技巧。

假设你想在邮件日志文件中查找一个特定的电子邮件地址。为此，你可以如下使用 `grep` 命令：

```
# grep "user@domain.tld" /var/log/maillog

```

更进一步，`grep` 还可以用于递归地搜索一个或多个文件中的内容。

例如，如果你想要在日志文件目录中查找一个 IP 地址（`XXX.XXX.XXX.XXX`），你可以将 `grep` 命令与 `-R` 选项结合使用，如下所示：

```
# grep -R "XXX.XXX.XXX.XXX" /var/log/

```

类似地，你可以通过 `-n` 选项为输出添加行号，如下所示：

```
# grep -Rn "XXX.XXX.XXX.XXX" /var/log/

```

此外，你还会注意到，在多文件搜索时，每个搜索结果都会显示文件名，但通过使用 `-h` 选项，你可以禁用此功能，如下所示：

```
# grep -Rh "XXX.XXX.XXX.XXX" /var/log/

```

你可以通过 `-i` 选项忽略大小写，如下所示：

```
# grep -Ri "XXX.XXX.XXX.XXX" /var/log/

```

更进一步，`grep` 还可以用来对搜索结果的内容进行排序，只需在原始命令末尾添加 `sort` 命令即可实现按字母顺序（从 a 到 z）排序，如下所示：

```
# grep -R "XXX.XXX.XXX.XXX" /var/log/ | sort 

```

通过添加 `-r` 选项，你可以实现反向字母排序（从 z 到 a），如下所示：

```
# grep -R "XXX.XXX.XXX.XXX" /var/log/ | sort -

```

最后，如果你希望搜索多个值，你可以像这样使用 `–E` 参数（但不要在管道符之间包含不必要的空格）：

```
# grep -E "term 1|term 2|term 3" /var/log/messages

```

当然，`grep` 的功能远不止这些，但为了故障排除的目的，我现在想要引起你注意的最后一个命令，`diff` 命令，在确定两个文件之间的差异时非常有用。

# 使用 diff

`diff` 命令通常不被认为是与日志文件相关的工具，除非你是在为特定目的比较备份文件。然而，`diff` 命令在比较应用程序的变化时非常有用。

例如，`diff` 命令可以让你比较两个 Apache 配置文件之间的差异，但通过使用 `-u` 选项，你还可以包含额外的信息，比如时间和日期：

```
# diff -u /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.backup

```

现在，根据文件的大小和服务器的速度，任务可能需要几秒钟（甚至几分钟）才能完成。是的，我知道我们有点偏离了日志文件的主题，但我相信随着时间的推移，你会发现这个命令非常有用。

例如，你可能想要使用 `–rq` 选项来比较两个文件夹的内容，这样可以让比较变得递归，如下所示：

```
# diff –rq /path/to/folder1 /path/to/folder2

```

要了解更多关于 `diff` 命令的信息，只需输入以下命令查看手册：

```
$ man diff

```

# 使用截断

因此，既然我们已经展示了处理日志文件的简便性，我们应该始终记住，像这样的记录会随着时间的推移而增长，正因如此，它们可能会变得难以处理。事实上，你应该意识到，过大的日志文件可能会影响系统性能。考虑到这一点，监控任何日志轮换过程并根据需要定期调整是一个好主意。

此外，考虑到日志轮换在中高负载环境中的重要性，我建议你有效地管理这个过程。然而，在这种过程中影响较小的情况下，下面的防护技术将允许你通过键入以下任一命令来清理日志文件：

```
# cat /dev/null > /path/to/file

```

或者更准确地说，你可以像这样使用`truncate`命令：

```
# truncate --size 0 /path/to/file

```

这个过程被称为截断，如前所述，这应该是最后的手段，因为之前的命令会删除文件中包含的所有数据。所以记住，如果文件包含你未来可能需要查看的重要信息，请在使用`truncate`之前先进行备份。

# 总结

本章旨在介绍故障排除 CentOS 7 的主题，目的是让你了解这一主题，而不是让你背负一堆不适合你当前情况或需求的规则、指令或流程。我们知道，故障排除是一个过程，第一章已经帮助你了解了一些概念和方法，接下来的每一页都会确保你更接近于轻松应对你即将诊断和修复的服务器。所以，是的，旅程刚刚开始，我们现在将讨论如何排查正在运行的进程。

# 参考资料

+   Red Hat 客户门户: [`access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/`](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/)

+   Syslog 严重性级别: [`en.wikipedia.org/wiki/Syslog#Severity_levels`](http://en.wikipedia.org/wiki/Syslog#Severity_levels)

+   Dmesg 维基页面: [`en.wikipedia.org/wiki/Dmesg`](http://en.wikipedia.org/wiki/Dmesg)

+   Cat 维基页面: [`en.wikipedia.org/wiki/Cat_(Unix)`](http://en.wikipedia.org/wiki/Cat_(Unix))

+   Grep 维基页面: [`en.wikipedia.org/wiki/Grep`](http://en.wikipedia.org/wiki/Grep)

+   Diff 维基页面: [`en.wikipedia.org/wiki/Diff_utility`](http://en.wikipedia.org/wiki/Diff_utility)

+   Tail 维基页面: [`en.wikipedia.org/wiki/Tail`](http://en.wikipedia.org/wiki/Tail)

+   Less 维基页面: [`en.wikipedia.org/wiki/Less_(Unix)`](http://en.wikipedia.org/wiki/Less_(Unix))
