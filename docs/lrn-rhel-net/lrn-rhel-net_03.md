# 第三章 配置关键网络服务

必须说，拥有一个网络是非常棒且充实的；然而，使用该网络的原因必须受到挑战并且得到理解。没有人会仅仅为了拥有一个网络而拥有网络，因此我们必须为我们的网络带来服务，以赋予其目的、意义和存在的理由。

当然，我们可以添加许多种类的服务，其中许多将在本书中涉及。首先，我们将关注以下主题：

+   DNS（名称解析）

+   DHCP（IP 地址分配）

+   NTP / PTP（时间服务）

+   SMTP（电子邮件）

# 域名系统

**域名系统**（**DNS**）服务器帮助我们将友好的计算机名称（如[www.packtpub.com](http://www.packtpub.com)）解析为不太人性化的 IP 地址（如`83.166.169.231`）。通过这种方式，人类只需猜测地址或 DNS 名称就能访问许多计算机系统。在 UNIX 计算机的早期，访问仅限于少数学术系统时，主机名是通过**网络信息服务**（**NIS**）分发的；一台中央计算机维护一个映射主机名到 IP 地址的文件。然后，这个文件被推送到客户端订阅者。尽管这种方法有效，但显然不可扩展。

1988 年，DNS 服务器的第一个版本由四位来自加利福尼亚大学伯克利分校（UCB）的研究生开发。这款软件目前由**ISC**（**互联网系统联盟**）维护。即使在今天，它仍然被称为**伯克利互联网域名系统**（**BIND**）。

在 Red Hat Enterprise Linux 7.1 中，随附的 DNS 服务器或 bind 版本为 9.9.4。安装完成后，可以通过输入以下命令来验证版本：

```
$ named -V

```

DNS 服务器可以安装并运行，而无需更改配置。在这种模式下，它将作为*仅本地缓存*服务器运行。当以这种方式操作时，服务器可以解析互联网中的名称，但不会托管任何自己的记录。此外，在没有配置更改的设置中，只有本地主机能够查询服务器。在其最简单的形式下，缓存-only 服务器仍然有用，但为了使其有用，至少需要打开访问控制列表，以允许来自本地网络的查询。通过这种方式，局域网中的计算机可以从本地服务器解析名称。仅有一个服务器需要访问互联网进行名称解析，从而减少了组织的互联网足迹。

## 安装和配置仅缓存 DNS 服务器

首先，我们将在系统上安装`bind`软件包，并将其配置为解析本地网络中主机的名称。除了对配置文件进行简单修改外，其他操作几乎不需要，但这将帮助我们入门。

要从控制台安装`bind`，请输入以下命令：

```
$ sudo yum install bind

```

安装完软件包后，我们现在需要编辑`/etc/named.conf`配置文件：

```
$ sudo vi /etc/named.conf

```

我们将按如下方式编辑三个现有的行：

+   `listen-on port 53 { 127.0.0.1; };` 更改为以下内容：

    ```
    listen-on port 53 { any; };
    ```

+   `listen-on-v6 port 53 { ::1; };` 更改为以下内容：

    ```
    listen-on-v6 port 53 { none; };
    ```

+   `allow-query { localhost; };` 更改为以下内容：

    ```
    allow-query { localhost; 192.168.40.0/24; };
    ```

我们所做的更改在此解释：

+   允许 DNS 服务器监听所有 IPv4 接口。

+   禁止 DNS 服务器监听 IPv6，除非您需要它监听 IPv6。

+   允许来自我本地网络的查询

+   调整地址范围以匹配您的网络和子网掩码。

进行这些更改后，我们将能够保存它们。在启动服务器之前，我们可以测试这些更改。为此，我们将使用以下命令：

```
$ sudo named-checkconf

```

输出应该是静默的。只有在配置中出现错误时才会输出。如果您需要输出，您可以使用 `-p` 选项：

```
$ sudo named-checkconf -p

```

使用此选项，我们将看到由服务解释的配置选项。如果存在错误，我们只会看到错误，而不是配置。

我们现在可以使用 `systemctl` 命令启动并启用 DNS 服务；命令执行的顺序不重要：

```
$ sudo systemctl start named
$ sudo systemctl enable named

```

出于这些实验的目的，目前我们将不运行防火墙。您可以通过以下命令检查系统：

```
$ sudo systemctl status firewalld

```

如果它正在运行，那么要么停止防火墙（如果不需要的话），要么启用 UDP 和 TCP 端口 `53` 上的 DNS 流量，允许它进入系统。要停止并禁用防火墙，请使用以下命令：

```
$ sudo systemctl stop firewalld
$ sudo systemctl disable firewalld

```

从本地系统，我们可以使用我们的 DNS 服务器测试名称解析；我们将使用我们服务器的 IP 地址来证明它能从网络中访问，而不仅仅是从本地别名访问。您可以使用相同的命令并确保序列末尾的`@address`指向您的服务器地址：

```
$ dig www.packtpub.com @192.168.40.3

```

### 提示

在这里，使用您 DNS 服务器的 IP 地址替代我们使用的地址。

您现在应该在输出中看到 **ANSWER** 部分，详细列出 Packt 服务器的地址。

如果您在同一网络上有其他系统，您可以使用相同的命令验证它是否确实适用于网络中的任何主机。

在这一阶段，我们将拥有一个配置为仅缓存模式的工作 DNS。

## 配置客户端使用此服务器

之前我们使用 `dig` 命令测试 DNS 查询时，我们硬编码了使用的名称服务器，忽略了客户端配置。传统上，客户端配置文件是 `/etc/resolv.conf`。我们仍然可以使用它，但在更多现代的 Linux 系统中，这通常会被 NetworkManager 服务覆盖，该服务会从接口配置中读取名称服务器。这样，我们就可以为不同的连接配置文件使用不同的 DNS 服务器。当然，DNS 也适用于其他操作系统，包括您的 Microsoft Windows 台式机和 Apple iPhone。通常，DNS 服务器列表由 **DHCP** 服务（**动态主机配置协议**）分配，影响所有 DHCP 客户端的配置。稍后我们将在本章中讨论 DHCP。

在 RHEL 7.1 上，我们可以使用以下命令来显示活动连接：

```
$ nmcli con show active

```

我的活动连接显示为 `eno16777736`；这与我们在第二章，*配置网络设置*中使用的系统相同，我们在该章节中讨论了现代 Linux 系统中一致的网络设备名称。

我们可以使用 `nmcli` 命令修改此配置的 DNS 服务器：

```
$ sudo nmcli con modify eno16777736 ipv4.dns "192.168.40.3"

```

如果正在修改的连接涉及传统的 `ifcfg-` 脚本，那么相应的文件也会通过前面的 `nmcli` 命令进行编辑。这就是我们修改的连接情况。我们可以通过查看 `nmcli` 修改的文件来查看更改：

```
$ sudo cat /etc/sysconfig/network-scripts/ifcfg-eno16777736

```

要实施更改，我们可以通过以下方式重新启动 `NetworkManager` 服务：

```
$ sudo systemctl restart NetworkManager

```

我们现在可以使用 dig 命令执行 DNS 查询，而无需指定服务器的地址：

```
$ dig www.packtpub.com

```

在这里，我们已经能够配置本地客户端，从本地配置的 DNS 服务器解析主机名。

### 提示

作为一种快速解决方案，编辑 `/etc/resolv.conf` 文件是可行的，但如果不通过 NetworkManager 服务进行更改，可能会被覆盖。

## 配置 DNS 区域

配置本地 DNS 服务器的一个原因是为本地服务器的名称查找提供集中式配置。接下来我们将介绍如何配置一个 DNS 区域，为本地服务器提供名称解析。我们将配置一个名为 `tup.local.` 的区域；使用本地域后缀将确保该区域仅在我们配置的 DNS 服务器上可用。

作为一个仅缓存的 DNS 服务器，我们目前没有托管 DNS 区域。DNS 区域只是一个文本文件，包含主机名与 IP 地址的映射。我们可以查看在 `/etc/named.conf` 文件中托管了哪些区域。区域文件存储在 `/var/named` 目录中。

### 引用 /etc/named.conf 中的区域

在 BIND 配置文件中，我们必须指向区域文件。以下示例演示了如何实现这一点：

使用以下命令打开 `named.conf`：

```
$ sudo vi /etc/named.conf

```

在文件末尾添加以下部分：

```
zone "tup.local." IN {
  type master;
  file "named.tup";
};
```

### 提示

不要忘记域名后的点：`tup.local`。

配置并保存文件后，我们可以像之前一样检查配置文件：

```
$ sudo named-checkconf

```

### 创建区域文件

我们已配置 DNS 服务器指向`named.tup`文件。默认情况下，该文件需要存在于 RHEL 7.1 的`/var/named/`目录中。该目录位置由`named.conf`文件主选项中的目录指令决定。此摘录来自`/etc/named.conf`文件，显示了目录根的配置：

```
directory       "/var/named";
```

首先，创建一个空的区域文件，并设置权限，使其可以被 DNS 服务器读取。`touch`命令将创建一个空文件。我们将权限设置为用户所有者可读/写，组所有者仅可读。最后，我们将文件的组所有者权限设置为`named`（DNS 服务器使用的组）：

```
$ sudo touch /var/named/named.tup
$ sudo chmod 640 /var/named/named.tup
$ sudo chgrp named /var/named/named.tup

```

文件和权限到位后，我们可以使用`sudo`以 root 身份编辑文件，使其与以下截图类似：

![创建区域文件](img/image00206.jpeg)

我们可以逐行解释上面的截图如下：

+   `$ORIGIN tup.local.`：这设置了 DNS 域名的名称，所有未以点号结尾的名称将附加此域名。

+   `$TTL 1D`：该指令设置记录从缓存中检索的默认时间**TTL**（**生存时间**）。该值通常以秒为单位，但我们可以使用字母来定义更大的单位，例如`H`表示小时，`D`表示天，甚至`W`表示周。也可以在单独的 DNS 记录中覆盖此默认值。TTL 值越大，传播更改到互联网的时间越长，因为记录可能会在 TTL 时间段内仍从缓存中提供。TTL 设置得越短，传播更改的时间越短，但服务器上的查询次数会增加。

+   `@ IN SOA ns1 root ( … )`：这设置了`**Start Of Authority**`（**SOA**）记录，适用于`tup.local.` DNS 域名。`@`符号表示该域，SOA 记录设置为`ns1.tup.local`计算机。`记住`$ORIGIN`以及电子邮件联系地址是`root@tup.local.`。括号中包含了该域使用的序列号和超时时间。过期记录由`$TTL`指令覆盖（如果它被使用）。

+   `NS ns1`：这设置了域的名称服务器记录。如果我们有额外的从属服务器，可以在区域中添加更多的 NS 记录。

+   `ns1 A 192.168.40.3`：这设置了`ns1.tup.local.`服务器的 IP 地址映射到我们在系统中设置的 IP 地址。单个`A`表示 IPv4 地址映射，而`AAAA`表示 IPv6 地址映射。

编辑完成后，我们可以检查区域的语法和完整性。在命令行中，输入以下命令：

```
$ sudo named-checkzone tup.local. /var/named/named.tup

```

输出应类似于演示系统中的以下截图：

![创建区域文件](img/image00207.jpeg)

在编辑了`/etc/named.conf`文件并实现了新的区域`/var/named/named.tup`数据库文件后，我们现在准备重新启动服务。我们还使用`named-checkconf`命令检查了`named.conf`，并使用`named-checkzone`命令检查了区域文件，因此我们可以放心我们所做的更改是完整的；考虑到这一点，我们将使用`systemctl`重新启动服务：

```
$ sudo systemctl restart named

```

我们现在可以使用`dig`或甚至只是`ping`来检查区域的操作：

```
$ ping ns1.tup.local
$ dig ns1.tup.local

```

虽然我们只添加了一个记录，但没有任何阻止我们根据需要添加更多记录的原因。序列号通常会在区域更改后递增，但它更多地用于指示更改发生的时间。从属服务器应同步这些更改。如果你只有主服务器，则不需要递增序列号。本章后面，我们将添加一个**MX**或**邮件交换**记录，以支持在外部域中使用电子邮件传递。

# 配置 DHCP 服务器

**DHCP**（**动态主机配置协议**）服务器用于为网络主机分配 IP 地址，而不需要为每个主机静态分配记录。当然，这在客用设备——如手机和平板电脑——连接到网络时特别有用。

在 Red Hat Enterprise Linux 7 上，一个 DHCP 服务器可以同时提供 IPv4 和 IPv6 配置。每个配置都有自己的独立文件：IPv4 配置文件是`/etc/dhcp/dhcpd.conf`，IPv6 配置文件是`/etc/dhcpd/dhcpd6.conf`。此外，如果你习惯于以前版本的 Red Hat，不再需要在`/etc/sysconfig/dhcp`中配置接口。RHEL 7 会自动监听所有与`dhcpd.conf`或`dhcpd6.conf`文件中子网定义匹配的接口。换句话说，DHCP 服务器监听 DHCP 请求的接口将匹配那些在定义的 DHCP 子网内有地址的接口。

### 提示

如果你没有在同一系统上配置 DNS 服务器，你需要在服务启动之前创建一个空的租约文件，如以下命令所示：

```
$ sudo touch /var/lib/dhcpd/dhcpd.leases

```

你可以使用以下命令行安装 DHCP 服务器：

```
$ sudo yum install dhcp

```

在这个示例中，我们将通过编辑`/etc/dhcp/dhcpd.conf`文件来配置服务器发放 IPv4 地址配置。配置文件将是空的，除了几条注释。一个简单的配置如下所示，这将与我们在演示系统中使用的配置相匹配：

```
$ sudo vi /etc/dhcp/dhcpd.conf

```

生成的文件应类似于以下屏幕截图：

![配置 DHCP 服务器](img/image00208.jpeg)

让我们逐行解释前面的屏幕截图：

+   `option domain-name "tup.local";`：这将配置要附加到客户端名称的域名。

+   `option domain-name-servers 192.168.40.3;`：这设置了 DNS 服务器。如果使用多个服务器，地址之间用空格分隔。

+   `default-lease-time 86400;`：这是一个以秒为单位的值，我们用它来设置 DHCP 租约时间。值 `86400` 表示一天。最大租约时间是类似的，但仅在客户端请求租约时间时使用。

+   `ddns-update-style none;`：此命令禁用动态 DNS，根据该设置，DHCP 服务器将为获得 IP 地址的客户端创建 DNS 记录。

+   `log-facility local7;`：此命令设置 DHCP 使用的 syslog 功能。日志文件中的条目将显示为来自 `local7` 功能。DHCP 没有自己的功能条目。

+   接下来是子网定义，我们在此描述网络、子网掩码、地址以及将为子网发放的选项。

完成此操作后，我们应该熟悉接下来的步骤。在此，我们使用系统启动并启用该服务：

```
$ sudo systemctl enable dhcpd
$ sudo systemctl start dhcpd

```

### 提示

如果你在一个已经存在 DHCP 服务器的网络上运行，需要确保在启动自己的服务器之前停止该服务器。这包括可以通过其自己的 DHCP 服务在其私人网络上发放地址的 VMware Player 和 Virtual Box 等应用程序。如有需要，请参考你的虚拟化软件获取更多帮助。

如果你的网络中有额外的 RHEL 7 客户端，可以通过以下命令强制它们续订 DHCP 租约：

```
$ sudo dhclient -r <interface>

```

下面是一个示例：

```
$ sudo dhclient -r enp12s0

```

上述命令将会续订插入到 PCI 总线地址为 `12` 且插槽为 `0` 的以太网 PCI 卡上的 DHCP 租约。如果你的服务器已经发放了租约，你可以通过以下命令检查租约文件。该文件可以作为普通用户读取：

```
$ cat /var/lib/dhcpd/dhcpd.leases

```

以下截图显示了来自演示 RHEL 7.1 系统的租约，以及名为 `trusty` 主机的租约：

![配置 DHCP 服务器](img/image00209.jpeg)

在配置了 DHCP 服务器后，我们将继续了解如何使用 DNS 和 DHCP 服务器配置基本的网络服务。我们会通过查看时间服务使其更加完善。

# 在 RHEL 7 上配置时间服务

网络中的一个基本服务是提供准确的时间。这对于与 Active Directory 或其他基于 Kerberos 的机制进行身份验证以及使日志文件中的时间戳具有实际意义是必需的。

**网络时间协议**（**NTP**）使用 UDP 协议和传统的端口 `123`。该协议规定自 1900 年 1 月 1 日午夜以来已经过去的秒数。NTP 是 32 位的，这意味着最大时间将于 2036 年到达；然而，由于仅使用时间戳之间的差异，而不是实际时间，因此日期不会出现问题，不像 UNIX 时间在 2038 年结束时会出现较为严重的问题。

一旦时间服务启动并与另一个时间源同步，只要时间被认为是正常的，客户端时间就可以调整为与服务器的时间匹配。异常时间指的是服务器提供的时间与客户端之间的偏差超过 1000 秒。通过这种时间正常性，客户端可以防止与不可信的时间源同步。

也可以部署 **精确时间协议** (**PTP**)。这需要硬件或软件支持，支持的设备包括 **网络接口卡** (**NIC**)。首先，我们将查看常见的 NTP 实现，然后再讨论 PTP。

在 RHEL 7 上提供 NTP 服务可以通过 `chronyd` 或 `ntpd` 守护进程本身实现。默认情况下启用 `chronyd` 守护进程；然而，这主要是为桌面和经常与网络断开连接的机器设计的。`chronyd` 的时间同步速度比 `ntpd` 快，因此更适合那些频繁启动或经常挂起的机器。由于 `ntpd` 支持更多的认证选项并能在网络上传播时间，因此仍然是服务器的首选。

为了在时间服务器不可用时也能保持准确时间，`chronyd` 和 `ntpd` 都可以实现漂移文件。漂移文件保存在客户端，并显示本地硬件时钟与远程时间源频率之间的偏移。

NTP 基于一个服务器层次结构。每个服务器都分配一个层次编号。可能的起始值范围从 0 到 15。层次 16 表示时间服务不可用。层次 0 的时间服务器从物理时间源（如 GPS 时钟或原子钟）获取时间。层次 1 的服务器从层次 0 服务器获取时间，以此类推。

## 实现 chronyd

如本节介绍所提到的，`chronyd` 在我们为本书使用的 RHEL 7.1 系统上默认启用。我们可以在以下截图中查看该服务的 `systemctl` 状态子命令输出：

![实现 chronyd](img/image00210.jpeg)

从之前的 `sudo systemctl status` 输出中可以看到，`chronyd` 被描述为一个 NTP 客户端/服务器。这与我们从传统的 `ntpd` 守护进程中预期的类似。如果 `chronyd` 也作为服务运行，那么我们应该监听 `123` 端口。我们可以使用 `netstat` 命令来显示这一点。如果我们使用根权限执行该命令，我们还会看到持有该端口的服务是 `chronyd`。`-p` 选项显示此信息，但需要根权限。

我们运行以下命令：

```
$ sudo netstat -aunp | grep 123

```

输出如以下截图所示：

![实现 chronyd](img/image00211.jpeg)

超越`systemctl status`输出所能显示的内容，我们可以使用`chronyc`命令行工具查看更多关于`chronyd`同步状态的细节。希望你现在能看到命名中的模式：`chronyd`是服务或守护进程，而`chronyc`是命令行工具。

为了显示选定的服务器以及同步状态，我们将使用以下命令：

```
$ chronyc tracking

```

以下截图显示了`chronyc`命令的输出。如果仔细观察输出，你会看到命令及其后续的输出：

![实现 chronyd](img/image00212.jpeg)

`Reference ID`显示了当前用于同步时间的服务器。`Frequency`显示为`ppm`（百万分之一）。这表示系统时钟在未同步的情况下可能出错的速率。这里的值`0.8`意味着，如果 1,000,000 秒内没有同步，时钟将有`0.8`秒的误差；这并不算太糟。`Update Interval`显示了我们当前同步的频率。这个值比`ntpd`限制的 2 ^ 10 秒（1024 秒）要大得多。鉴于我们时钟的精度，这个间隔是完全可以接受的。

使用以下命令，我们可以显示所有已配置的同步服务器：

```
$ chronyc sources

```

如果我们希望在屏幕上显示列的含义，可以使用`-v`选项。输出结果如下所示：

![实现 chronyd](img/image00213.jpeg)

如果我们想要与自己的本地时间服务器同步，可以编辑`/etc/chrony.conf`配置文件。合理的做法是将你网络中的一个服务器分配为时间服务器，并将该服务器作为网络的时间参考。然后，这个单独的服务器可以与外部时间源同步。这样可以确保网络中所有服务器的时间准确，同时保持较小的互联网带宽，从而限制需要访问互联网时间服务器的服务器数量。

配置文件中的`server`指令定义了潜在的同步伙伴。为了偏向本地服务器，可以使用`prefer`选项。以下截图展示了我编辑后的文件，在文件中我保留了原始条目中的一个，并添加了自己的本地时间源：

![实现 chronyd](img/image00214.jpeg)

为了使任何更改生效，应该重启`chronyd`服务：

```
$ sudo systemctl restart chronyd

```

同步频率将从较低的频率开始，逐渐上升，直到匹配偏移频率的精度。在重启后不久，检查`chronyc`跟踪的输出会显示`Update Frequency`为 64 秒；然而，随着时间的推移，这个间隔会增加。

## 实现 ntpd

如果你想恢复到传统的`ntpd`守护进程提供时间服务，你可以安装`ntp`包。传统包的主要优点是广播选项和更强的**ACL**（**访问控制列表**）。要安装该包，可以使用以下命令：

```
$ sudo yum install ntp

```

配置文件位于`/etc/ntp.conf`，它与`chrony`文件不同。当我们像编辑`chrony.conf`一样编辑`ntp.conf`时，我们将能够像之前一样配置本地服务器，如下图所示：

![Implementing ntpd](img/image00215.jpeg)

我们在此找到的额外 ACL 是使用`restrict`关键字定义的。虽然本地主机地址不受任何限制，但其他所有人都受到默认限制的影响。

默认的限制在此处进行了解释：

+   `nomodify`：这阻止通过 NTP 协议对配置进行任何更改。

+   `notrap` ：这阻止了`ntpdc`控制陷阱，控制陷阱是由远程日志程序使用的。

+   `nopeer` ：这阻止了对等关联的创建，其中每个对等方都会进行 50%的调整。

+   `noquery` ：这可以防止访问时间服务器状态的信息。不要将其与阻止访问时间服务器混淆。此选项仍然允许客户端进行正常的 NTP 时间查询。如果你想限制对时间服务的访问，请使用`noserve`。

当你对`/etc/ntp.conf`文件中的更改感到满意时，我们需要首先停止并禁用`chronyd`服务，然后启用并启动`ntpd`服务：

```
$ sudo systemctl stop chronyd
$ sudo systemctl disable chronyd
$ sudo systemctl enable ntpd
$ sudo systemctl start ntpd

```

要查询服务的状态，我们将使用`ntpq -p`命令。输出如下图所示，指示在我的系统中用于同步的服务器是`192.168.0.3`（由星号标记）：

![Implementing ntpd](img/image00216.jpeg)

## 在 RHEL 7 上实现 PTP

**精确时间协议** (**PTP**) 与 NTP 一样用于在网络上同步时钟，但与 NTP 不同，如果 PTP 与硬件支持一起使用，可以实现亚微秒级的精度；PTP 的支持来自于你的 NIC，可以是软件或硬件形式。`linuxptp`包提供了`ptp4l`和`phc2sys`程序（Linux 的 PTP 和物理时钟到系统时钟）。然而，`phc2sys`仅在硬件时间戳情况下需要。虽然在 NIC 内实现，但许多网络组件（包括交换机）支持软件或硬件模式的 PTP，从而使服务器能够与其交换机同步时间。这个过程比传统的 NTP 更加自动化，并且每个时钟运行最好的主控软件，能够选择最佳主机进行同步。它最适合企业网络，因为交换机会经常为它们所服务的设备提供时间。

许多网络接口卡（NIC）支持软件时间戳，但要查询自己的接口，请使用以下命令，它将显示所选接口的时间戳能力：

```
$ ethtool -T eno16777736

```

调整前面的命令以匹配您希望查询的接口。对于软件支持，我们需要在输出中找到以下行：

+   `SOF_TIMESTAMPING_SOFTWARE`

+   `SOF_TIMESTAMPING_TX_SOFTWARE`

+   `SOF_TIMESTAMPING_RX_SOFTWARE`

对于硬件支持，我们需要以下选项：

+   `SOF_TIMESTAMPING_RAW_HARDWARE`

+   `SOF_TIMESTAMPING_TX_HARDWARE`

+   `SOF_TIMESTAMPING_RX_HARDWARE`

我系统的输出显示如下截图：

![在 RHEL 7 上实现 PTP](img/image00217.jpeg)

要在系统上安装 `linuxptp`，我们可以使用以下命令从标准 Red Hat 仓库进行安装：

```
$ sudo yum install linuxptp

```

服务可以通过命令行进行简单测试。但在此之前，我们应该停止正在运行的 NTP。以下命令展示了这一操作：

```
$ sudo systemctl disable ntpd
$ sudo systemctl stop ntpd

```

要从命令行启动服务，而不是作为守护进程运行，我们可以使用以下命令验证它是否正常工作：

```
$ sudo ptp4l -i eno16777736 -m -S

```

这会使用我们通过 `-i` 选项指定的接口启动服务，我们通过 `-m` 选项要求将输出显示到屏幕上，并通过 `-S` 选项设置软件模式。

服务将在 UDP 端口 `319` 和 `320` 上监听。以下截图显示了该命令的输出：

![在 RHEL 7 上实现 PTP](img/image00218.jpeg)

一旦我们对配置感到满意，我们可以创建启动配置文件并调整 `sysconfig` 文件。我们将从 `sysconfig` 文件开始：

```
$ sudo vi /etc/sysconfig/ptp4l

```

删除行尾的接口选项。文件应与以下截图相同：

![在 RHEL 7 上实现 PTP](img/image00219.jpeg)

接下来，我们将重命名现有配置，并创建一个最小化配置，支持我们从命令行使用的相同选项，如下所示：

```
$ sudo mv /etc/ptp4l.conf /etc/ptp4l.conf.orig
$ sudo vi /etc/ptp4l.conf

```

`ptp4l.conf` 文件应类似于调整接口，以便与您系统上的接口匹配。以下截图显示了我系统上的 `ptp4l.conf` 文件：

![在 RHEL 7 上实现 PTP](img/image00220.jpeg)

现在我们准备将 `ptp4l` 实现为服务。使用 `systemctl` 命令，我们可以启用并启动该服务，如下所示的命令：

```
$ sudo systemctl enable ptp4l
$ sudo systemctl start ptp4l

```

使用 `systemctl` 的 `status` 子命令，和前面的命令一样，我们将看到类似以下的输出，指示服务已启动并正在寻找时钟公告：

![在 RHEL 7 上实现 PTP](img/image00221.jpeg)

当服务器运行时，它可能会监听其他时钟公告，然后协商确定哪一个将成为主时钟。在以下从演示系统拍摄的截图中，我们可以查看 `systemctl status` 命令的输出。从日志中提取的内容表明了新主时钟的选举过程：

![在 RHEL 7 上实现 PTP](img/image00222.jpeg)

我们现在已经看到如何使用 NTP、Cronyd 或 PTP 在 Linux 上实现时间服务。拥有准确的时间后，我们可以继续进行电子邮件和 **SMTP**（**简单邮件传输协议**）的配置。

# 在 RHEL 7 上实现电子邮件投递

当前版本的 RHEL 默认使用的 SMTP 服务器是 Postfix；原来的 Sendmail 包仍然可以使用，但不再是默认选择。

在使用默认设置时，电子邮件服务器仅监听本地主机或回环地址是正常现象。这样，本地电子邮件投递在开箱即用时即可实现。这被许多服务使用，包括 `crond` 作业调度管理器。如果我们希望 Postfix 启用监听所有接口并接收来自远程系统的消息，则需要进行一些配置。

首先，我们将备份并整理主要配置文件。许多软件包倾向于过度注释它们的配置文件。这可能导致一些问题：你认为已经实施了某个更改，然而该更改可能已在后续设置中出现，而且你可能没有注意到。默认配置文件 `/etc/postfix/main.cf` 中有 679 行。我们将备份该文件，以保留注释和文档，但同时也会创建一个新文件，其行数不到原文件的 10%。以下命令展示了如何操作：

```
$ sudo sed -i.bak '/^#/d;/^$/d' /etc/postfix/main.cf

```

这将文件的行数从 679 行减少到 25 行，便于操作。我们现在可以在没有任何干扰的情况下编辑此文件。我们将向 `/etc/postfix/main.cf` 文件中添加两行新内容并编辑两行现有内容。该文件需要以 root 用户权限进行编辑。

我们将编辑 `inet_interfaces = localhost` 行，使其读取如下：

```
inet_interfaces = all
```

这将使 SMTP 服务能够在所有接口上监听，而不仅仅是回环地址。

我们还需要确保接收来自正确主机和域的电子邮件。这是通过 `mydestination` 指令来控制的；然而，我们需要在 `mydestination` 行之前添加 `myhostname` 和 `mydomain` 指令。这是我们要添加的两行内容。我们还需要将 `$mydomain` 添加到现有的 `mydestination` 行。在我的系统中，这些行设置如下：

```
myhostname = ns1.tup.local
mydomain = tup.local
mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain
```

以下截图显示了已实施这些更改的文件顶部几行：

![在 RHEL 7 上实现电子邮件投递](img/image00223.jpeg)

完成这些编辑后，我们可以保存文件并重新启动 SMTP 服务。以下命令展示了如何重新启动 Postfix SMTP 服务：

```
$ sudo systemctl restart postfix

```

## 向 DNS 服务器添加 MX 记录

如果我们要接收某个域的电子邮件，则需要一个 MX 记录（邮件交换记录），该记录会被添加到我们在本节前面创建的 DNS 数据库中。之前用于 `tup.local.` DNS 域的文件是 `/var/named/named.tup`。我们为 MX 或邮件交换记录添加的记录应类似于以下内容：

```
tup.local.  MX  10  ns1
```

使用此设置，我们将配置 MX（邮件交换）优先级为 10\. 如果存在多个电子邮件服务器记录，优先级最低的 MX 记录将是首先使用的电子邮件服务器。

更新后的区域文件显示在以下截图中：

![将 MX 记录添加到 DNS 服务器](img/image00224.jpeg)

在这些更新到位后，我们可以检查区域并重启服务器。为方便起见，命令在这里列出：

```
$ sudo named-checkzone tup.local /var/named/named.tup
$ sudo systemctl restart named

```

我们可以通过以下命令验证 DNS 是否正常工作：

```
$ dig -t MX tup.local

```

为了测试电子邮件的发送，我们应该能够向该域发送电子邮件：

```
$ mail root@tup.local

```

我们将被提示输入`Subject`信息，然后可以输入我们希望的电子邮件。要结束一封电子邮件，我们将在邮件中仅包含一个句号或点字符，其他内容不填写。这应该被传递到你系统上的根目录，并被识别为该域的电子邮件服务器。

要更详细地查看消息系统的工作情况，我们可以查看日志文件。要查看最近的活动，我们可以使用如下的`tail`命令：

```
$ sudo tail /var/log/maillog

```

现在我们已经有了一个简单的电子邮件服务器，与时间、DNS 和 DHCP 服务配套使用。

# 总结

在本章中，你学习了如何配置一些常见的与 Linux 相关的基础网络服务。我们从如何使用 DNS 设置名称解析开始，并通过向 DNS 添加电子邮件服务器记录结束。了解了 DNS 后，我们紧接着学习了与 D 相关的内容，研究了 DHCP，从而为网络提供 IP 配置。这将我们带入了与`chronyd`、`ntpd`和`ptp4l`等不同时间服务的复杂性。最后，在本章末，我们查看了 RHEL 7 上 Postfix SMTP 服务器的简单配置。这应该能为你提供一个简单的概览，帮助你了解在日常使用 Enterprise Linux 时会接触到的服务。

在下一章中，我们将了解 RHEL 7 和 7.1 中的新功能，并学习如何设置 iSCSI 存储服务。你会发现 ISCSI 目标现在是基于内核的，与 RHEL 6 中的旧版 iSCSI 目标服务工作方式截然不同。
