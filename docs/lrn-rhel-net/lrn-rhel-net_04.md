# 第四章：实现 iSCSI SAN

在 RHEL 7 中，您可能会注意到一个非常大的变化，相比于早期版本，iSCSI 目标服务现在是内核的一部分。这是随着 Linux 内核版本 3.x.x 的发布而来的，这一版本出现在最新的 Raleigh（北卡罗来纳州）企业产品中。iSCSI 服务器或目标的管理和配置已经完全改进。您将很快学习如何与网络上的设备共享磁盘和分区。在这个过程中，我们将研究如何配置以下先决条件：

+   iSCSI 目标（服务器）

+   使用 LVM 的逻辑卷

+   安装 `targetd` 服务和 `targetcli` 工具

+   使用 `targetcli` 管理 iSCSI 目标

+   iSCSI 发起客户端

# iSCSI 目标（服务器）

iSCSI 目标是一个使磁盘空间能够在网络上共享的软件。该服务共享磁盘而非文件系统，并建立了 **存储区域网络**（**SAN**）。这种 SAN 存储可以让服务器共享相同的磁盘，这在其他网络服务集群并需要访问共享磁盘的场景中通常是必要的。通常情况下，任何时刻只有一个服务器可以访问每个共享磁盘。iSCSI 目标可以共享整个磁盘，但通过使用 LVM 实现的逻辑卷来共享客户端所需的确切空间通常更高效。除了共享块设备外，还可以创建文件，并通过目标服务器将文件空间作为磁盘共享。

磁盘 IO 通过标准网络连接传输到 iSCSI 服务器。因此，网络连接越快，存储性能越好。虽然 iSCSI 在 1 GB 以太网网络上也能工作，但企业级应用推荐使用 10 GB 以太网。尽管如此，对于家庭或小型办公室的使用，您会发现 1 GB 网络速度应该足够（尤其是当您能为 iSCSI 流量定义一个单独的网络段来与其他网络流量隔离时）。目标默认使用的 TCP 端口是 `3260`。

# 使用 LVM 管理逻辑卷

尽管我们可以共享整个磁盘空间或磁盘分区，但实际上，只共享客户端服务所需的磁盘空间才更有意义。例如，如果 Web 服务器需要 20 GB 的空间来存储网站文件，我们可以只共享那部分空间，而不是共享整个可能达到 TB 级别的磁盘。为此，我们将创建逻辑卷并将其作为块设备共享。为了实现 LVM，我们需要创建三个对象：

+   **物理卷**：表示原始磁盘空间，作为磁盘分区。当我们使用分区时，分区类型应该设置为 `Linux LVM`，ID 为 `8E`，使用 `fdisk` 分区工具进行设置。

+   **卷组**：将物理卷聚合在一起，以便可以将磁盘空间分配给逻辑卷。

+   **逻辑卷**：表示可以共享的块设备。它占用了从卷组分配的空间。

在我们将用于本课程的演示 RHEL 7.1 系统上，我当前连接了三块磁盘。我们可以使用第三块磁盘的部分空间来配置 LVM 系统。我们将从分区第三块磁盘（当前未分区）开始，以便将该磁盘的一部分用于 LVM，另一部分用于其他文件系统。

## 磁盘分区

使用`fdisk`命令，我们可以根据需要分区磁盘。我们将使用一个扩展分区并在其中创建逻辑分区。这纯粹是为了允许我们在这里以及后续章节中使用多个分区：

```
$ sudo fdisk /dev/sdc

```

使用时请注意设备名称！

当你运行`fdisk`命令时，会显示一个菜单。可以使用`m`命令查看菜单选项，但我们可以使用`n`来创建一个新分区，然后用`e`创建扩展分区。我们将按默认设置接受分区号、起始和结束扇区。我们将设置扩展分区使用整个磁盘。

现在，我们将再次使用`n`创建另一个新分区，这次我们选择`l`表示逻辑分区。分区号将默认为`5`，因此在我的情况下是`/dev/sdc5`。我们可以接受默认的起始扇区，但将结束扇区限制为 200M，使用`+200M`设置。以下截图展示了此设置：

![磁盘分区](img/image00225.jpeg)

在输入了设置并仍然处于交互式`fdisk`命令下时，我们可以使用`t`选项设置类型。默认情况下，这将设置为`83`。当你输入`t`时，它会提示你输入分区号，默认是`5`。为了输入分区代码，我们将使用`8e`代表 LVM。接着，我们将使用`p`打印配置，然后使用`w`保存更改并退出程序。

## 创建物理卷

到目前为止，我们已经为 LVM 创建了一个分区，但它还没有成为任何 LVM 系统的一部分。为了标记它为可用，我们将使用`pvcreate`命令：

```
$ sudo pvcreate /dev/sdc5

```

要在系统上显示 LVM 物理卷，可以使用`pvs`命令或以 root 用户身份运行`pvscan`命令。`sudo pvscan`的输出如下截图所示：

![创建物理卷](img/image00226.jpeg)

输出显示我们系统上已经使用 LVM，因为在 RHEL 及许多其他系统中这是默认设置。新的`PV`显示为`/dev/sdc5`，但尚未属于任何**卷组**（**VG**）。

## 创建卷组

由于我们已经有了一个卷组，我们将使用该卷组并通过`vgextend`命令扩展它，以包括新的 PV。我们希望将这个卷组保持独立，仅用于与 iSCSI 目标共享的空间。因此，我们将使用`vgcreate`命令创建一个新的卷组，如下例所示：

```
$ sudo vgcreate iscsi /dev/sdc5

```

使用此命令，我们将创建一个名为`iscsi`的新卷组，并使用`/dev/sdc5`作为 PV。

与物理卷类似，我们可以使用 `vgscan` 或 `vgs` 来显示可用的卷组信息。`sudo vgs` 命令的输出如下所示的截图：

![创建卷组](img/image00227.jpeg)

从上述输出中，我们可以看到我们新创建的名为 `iscsi` 的 `VG` 有一个连接的单个 `PV`，但是尚无逻辑卷 (`LV`)，我们接下来将创建它们。

## 创建逻辑卷

**逻辑卷** (**LVs**) 是我们可以在本地使用或（在我们的情况下）通过 iSCSI 共享的块设备单元。我们使用 `lvcreate` 命令创建 LVs。例如：

```
$ sudo lvcreate -n web -L 100M iscsi

```

通常情况下，我们不会使用所有可用空间，只会使用 Web 团队为其新的 Web 容量所请求的空间。 `-L` 选项设置我们分配的大小。我们将分配`100M`； `-n` 设置名称为 Web，在这种情况下，`VG` 名称附加在命令字符串的末尾。

此命令将在 `/dev` 目录中创建一个块设备，但通常通过符号链接访问此设备。将创建以下两个符号链接：

+   `/dev/mapper/iscsi-web`

+   `/dev/iscsi/web`

在我们的情况下，这些链接到 `/dev/dm-2` 块设备。在您的系统上，实际的块设备名称将取决于您拥有多少现有的 LVs。这就是为什么操作系统使用符号链接的原因，因为这个名称是可以确定的，而实际的块设备名称并不是那么确定的。

如果您能意识到这里的模式，您会意识到，为了显示系统上 LVs 的信息，我们可以使用 `lvs` 或 `lvscan`。`sudo lvscan` 命令的输出如下所示的截图：

![创建逻辑卷](img/image00228.jpeg)

在此阶段，我们拥有一个可以与网络上的服务器共享的工作块设备。现在，我们将查看如何在 RHEL 7.1 上配置 iSCSI 目标。

# 安装 `targetd` 服务和 `targetcli` 工具

要在 RHEL 7 上管理基于内核的 iSCSI 目标服务，我们需要安装 `targetd` 和 `targetcli` 包，如下所示的命令：

```
$ sudo yum install targetd targetcli

```

从输出中，我们可以看到安装了额外的软件包；然而，更有趣的是看到 Python 如何作为管理 iSCSI 的主要工具。以下截图是命令行输出的一部分：

![安装 `targetd` 服务和 `targetcli` 工具](img/image00229.jpeg)

尽管 iSCSI 目标作为内核的一部分运行，但 `targetd` 包提供了一个服务。此服务用于加载 iSCSI 目标配置。这就是 `targetd` 的全部功能，因此我们无需启动此服务；只需确保 `targetd` 已启用自动启动，如下命令所示：

```
$ sudo systemctl enable targetd

```

### 提示

一旦系统启动时启用了 `targetd` 服务，它确保执行 `targetcli restoreconfig` 命令。它还确保在启动时加载当前配置。

我们现在已经安装了 `targetcli` iSCSI 目标和 `targetd` 服务的管理工具，该服务提供了一种机制，可以在启动时读取配置。接下来，我们将介绍如何使用 `targetcli` 配置目标。

# 使用 targetcli 管理 iSCSI 目标

`targetcli` 命令是一个用于查看、编辑、保存和加载 iSCSI 目标配置的 shell。当你查看配置时，你会发现 `targetcli` 提供了一种类似于文件系统的层级结构。

要启动 `targetcli` shell，我们将以 root 用户身份使用 `sudo` 运行此命令。你会看到，在首次运行命令时，会创建一个首选项文件。以下截图说明了这一点：

![使用 targetcli 管理 iSCSI 目标](img/image00230.jpeg)

如前面的输出所示，你可以输入 `help` 来显示可以输入的命令列表。要查看可用的配置对象，我们可以使用 `ls` 命令。输出如下所示：

![使用 targetcli 管理 iSCSI 目标](img/image00231.jpeg)

我们将从 `backstores` 对象开始，以便我们可以将其添加到 LVM 块设备的配置中，除了 `fileio` 后端存储外。顾名思义，这将是文件系统中的一个文件；我们可以将其作为虚拟磁盘共享到网络中。

## 创建存储后端存储

我们将从 `targetcli` 配置的根目录开始；这应该正是我们所在的位置，但我们始终可以使用 `pwd` 命令来显示我们的工作目录。如果需要，我们可以通过 `cd /` 命令将其切换到配置的根目录。

### 提示

在使用 `targetcli` 命令时，我们可以像在 Bash 中一样使用 *CTRL* + *L* 来清除屏幕，但最重要的是，*Tab* 键补全功能可以使用，所以我们不需要输入对象和属性的完整名称或路径。

要在我们在本节前面创建的 LVM LV 上创建一个新的 `block` 后端存储。如果我们回忆一下，这个路径是 `/dev/iscsi/web`：

```
/> backstore/block/ create web_lv /dev/iscsi/web

```

这将创建一个名为 `web_lv` 的块后端存储。再次使用 `ls` 命令将列出层级结构中的其他对象。在以下截图中，我们看到后端存储的创建及随后的列出：

![创建存储后端存储](img/image00232.jpeg)

我们还将添加一个名为 `fileio` 的新后端存储。新后端存储的创建与配置根目录类似：

```
/> backstores/fileio create file_store /tmp/fs 100M

```

该命令将创建后端存储和物理文件，我们将其用作虚拟磁盘。如果文件已存在，我们省略大小参数。如果我们再次选择使用 `ls` 命令，这两个对象都会显示在列表中。

其他后端存储类型包括 `pscsi` 和 `ramdisk`。这些代表 `Passthrough SCSI` 连接，指向物理 iSCSI 设备，以及 `基于内存的磁盘`，这些磁盘可以像 `fileio` 一样，使用 `targetcli` 动态创建。

# 创建 iSCSI 目标

我们在主列表中看到的 iSCSI 对象代表了 iSCSI 目标及其属性。首先，我们将创建一个具有默认名称的简单 iSCSI 目标。然后我们可以删除该对象，并查看如何使用正确的命名约定创建我们自己的目标：

```
/> iscsi/ create

```

这将创建一个 iSCSI 目标，并监听 TCP 端口 `3260`。此时没有连接任何 LUN 或后端存储，**IQN**（**iSCSI 合格名称**）将由系统生成。我们可以随时添加后端存储，但大多数情况下，我们希望使用自定义名称。因此，在这种情况下，我们将删除该对象。我的系统上生成的 IQN 是 `iqn.2003-01.org.linux-iscsi.redhat7.x8664:sn.ce1ebea336a2`，但不要忘记我们可以使用 *Tab* 键完成输入。因此，我们在删除或编辑时不需要写出完整的名称。以下命令显示了这一点，但它可能在显示或打印时换行，最终作为一行代码执行：

```
/> iscsi/ delete iqn.2003-01.org.linux-iscsi.redhat7.x8664:sn.ce1ebea336a2

```

我们现在将通过提供自定义 IQN 来创建一个 iSCSI 目标。为此，我们像之前一样创建对象，但这次指定通常包含日期和反向 DNS 名称的名称。以下命令是我们在本书中使用的示例：

```
/> iscsi/ create iqn.2015-01.com.tup.rhel7:web

```

IQN 以 `iqn` 开头，后面跟着创建的年份和月份以及反向 DNS 名称。我们可以通过在末尾加上 `:web` 来添加目标描述，表示这是一个面向 Web 服务器的目标。

我们可以通过使用 `ls` 命令并添加我们想要列出的对象层次结构来过滤显示的内容。例如，要列出目标，我们将使用 `ls iscsi` 命令。

该命令的输出如下面的截图所示：

![创建 iSCSI 目标](img/image00233.jpeg)

现在我们有了目标的自定义名称，但我们仍然需要添加 LUN 或逻辑单元，以使 **SAN**（**存储区域网络**）生效。

## 向 iSCSI 目标添加 LUN

留在 `targetcli` shell 中，我们现在将转到我们的目标和 **TPG**（**目标门户组**）对象。与文件系统类似，这通过使用 `cd` 命令来实现，如以下命令所示：

```
/> cd iscsi/iqn.2015-01.com.tup.rhel:web/tpg1/

```

我们可以从这里运行 `ls`，但是内容已经包含在之前从配置根目录运行的列表中了。我们有一个门户，监听所有 IPv4 接口的 TCP 端口 `3260`。目前，我们没有 `acls` 或 `luns`。要添加 LUN，我们将使用以下命令，它将利用 LVM 块后端存储：

```
/iscsi/iqn.20...rhel:web/tpg1> luns/ create /backstores/block/web_lv

```

这还会有一个额外的副作用，激活一个后端存储。可以通过列出 `/backstores` 对象来查看这一点。命令和输出如下所示：

![向 iSCSI 目标添加 LUN](img/image00234.jpeg)

## 添加 ACL

我们不需要添加 ACL，但通常我们只想让一个主机，可能是一个虚拟集群设备来访问 LUN。如果没有 ACL，我们需要设置一个属性，以防 LUN 默认变为只读。

要创建 ACL，我们限制 LUN 对指定的发起者名称或我们在**访问控制列表**（**ACL**）中提到的名称的访问。发起者是 iSCSI 客户端，并将在发起者的`/etc/iscsi/initiatorname.iscsi`文件中配置一个唯一的客户端 IQN。如果该文件不存在，你需要安装`iscsi-initiator-utils`包。配置发起者名称的文件名在 Linux 客户端中是统一的，但在其他操作系统中会有所不同。要添加 ACL，我们将保持当前的配置层级：`/iscsi/iqn….:web/tpg1`，并发出以下命令，再次作为一行写出：

```
/iscsi/iqn.20...rhel:web/tpg1> acls/ create iqn.2015-01.com.tup.web:web

```

这个 ACL 限制了对 ACL 中列出的发起者的访问。如果你更改发起者的名称，请小心，因为 ACL 也需要更新。发起者是 iSCSI 客户端。

使用`ls`命令从当前配置层级中，我们看到类似于以下截图的输出，输出中还包括创建 ACL 的命令：

![添加 ACL](img/image00235.jpeg)

如果不添加 ACL，LUN 将为只读。如果需要使 LUN 可写，你需要使用以下命令来设置所需的属性：

```
/iscsi/iqn.20...rhel:web/tpg1> set attribute demo_mode_write_protect=0

```

现在，iSCSI 目标已配置。退出`targetcli`应保存此配置，但你可能会觉得手动保存更为安全。

为此，请返回到配置的根目录并输入`saveconfig`命令，如下例所示：

```
/iscsi/iqn.20...rhel:web/tpg1> cd /
/> saveconfig
/> exit

```

### 提示

我们在本章前面启用的`targetd`服务从`targetcli`运行`restoreconfig`命令。此命令用于在系统启动时加载配置。

配置保存后，我们可以迁移到客户端，查看 iSCSI 发起者并观察 SAN 上磁盘共享的工作情况。

# 与 iSCSI 发起者一起工作

RHEL 7 上的 iSCSI 发起者或客户端是通过`iscsi-initiator-utils`包安装的；你可以使用`yum`命令验证该包是否已安装在系统上，如以下示例所示：

```
$ yum list iscsi-initiator-utils

```

如果显示为`已安装`，那么一切正常，但如果显示为`可用`，你需要安装它。

为了进行本练习，我们将使用一个独立的 RHEL 7 系统作为发起者，并将其连接到现有目标。我们需要在新的 RHEL 7 系统上编辑`/etc/iscsi/initiatorname.iscsi`文件，确保名称与本章早些部分我们添加到 ACL 中的名称匹配；我们可以使用`cat`命令显示此内容，如以下截图所示：

![与 iSCSI 发起者一起工作](img/image00236.jpeg)

我们将使用主要客户端工具：`iscsiadm`。这个工具是与前述包一起安装的。要发现目标上的 iSCSI LUN，我们将使用以下命令：

```
$ sudo iscsiadm --mode discovery --type sendtargets \
--portal 192.168.40.3 --discover

```

输出应类似于以下行：

```
192.168.40.3:3260,1 iqn.2015-01.com.tup.rhel7:web

```

现在，我们已经看到我们可以连接到 iSCSI 目标，并让其向我们发送已配置的 LUN。接下来，我们应该连接到此 LUN，并使用相同的命令，添加以下选项：

```
sudo iscsiadm --mode node \ 
--targetname iqn.2015-01.com.tup.rhel7:web \ 
--portal 192.168.40.3 --login

```

以下截图显示了命令及其输出：

![使用 iSCSI 发起器](img/image00237.jpeg)

对于发起端来说，共享的 LUN 现在就是一块磁盘。我们可以以正常方式对这块磁盘进行分区和格式化。我们将使用 `lsblk` 来列出各种连接的块设备。在该系统上，我们可以看到它作为 `/dev/sdc` 连接，并且与我们分配的 `100M` 大小匹配，如下截图所示：

![使用 iSCSI 发起器](img/image00238.jpeg)

使用传统的 `fdisk` 或 `parted` 命令，我们可以创建一个分区，然后格式化它以便在此系统上本地使用。由于我们在本章中使用了 `fdisk` 来交互式创建 LVM 分区，现在我们将直接从命令行使用 `parted` 来管理它。

该命令需要一个磁盘标签才能创建分区表。此标签可以设置为 `msdos` 或 `gpt`。`fdisk` 命令会自动创建 `msdos` 标签，但这是因为它只能处理传统的 `msdos` 分区表。`parted` 可以同时支持 `msdos` 和 `gpt`（GUID 分区表）。`parted` 命令还允许通过交互式或直接从命令行创建分区，因此它是可脚本化的。这里有一个额外的复杂性，即无法显示开始新分区的扇区。因此，我们需要计算出最佳的起始扇区。

一旦你知道了某种类型磁盘的这一信息，对于类似的磁盘，它将是相同的。

要确定磁盘的起始扇区，我们将从两个文件中读取值：`/sys/block/sdc/queue/optimal_io_size`，然后将其除以 `/sys/block/sdc/queue/physical_block_size`。

在演示系统上，这与 *4194304 / 512 = 8192* 相关；可以使用 `cat` 命令作为普通用户从文件中读取这些值。一旦我们了解了最佳对齐细节，就可以通过以下命令为磁盘打标签并创建分区：

```
$ sudo parted /dev/sdc mklabel msdos
$ sudo parted /dev/sdc mkpart primary 8192s 100%

```

我们创建一个单一的分区：`/dev/sdc1`。当我们从最佳起始扇区开始时，该分区将使用 100% 的磁盘空间。

配置完成后，我们可以将分区格式化为所选择的文件系统，并以正常方式挂载它。`iscsid` 后台服务已启用，但仅在需要时运行。重启后，连接将重新建立到远程 iSCSI 存储服务器，以便`/dev/sdc1` 分区在客户端上保持不变。只要发起端没有更改默认设置，便会发生这种情况。你应该检查`/etc/iscsi/iscsid.conf`文件，并确保设置如下：

```
node.startup = automatic

```

在这种配置下，这是 RHEL 7 的默认设置，`iscsid` 服务将在启动时重新连接。

# 总结

在本章中，我们已经看到 RHEL 7 如何准备好作为企业网络中的 SAN 服务器，利用基于新内核的 iSCSI 目标服务器。服务器的管理现在是通过基于 Python 的工具来完成的，例如`targetcli`，而`targetd`服务则负责在启动时加载配置。我们经常通过逻辑卷按需提供磁盘存储。我们还了解了如何使用 LVM 的三个组件来实现这一点：物理卷、卷组和逻辑卷。

在创建并共享我们的存储之后，我们查看了第二个 RHEL 7 系统，以及如何将其连接为 iSCSI 发起端，利用 iSCSI 目标上的共享存储。最初是使用`iscsiadm`来管理连接，但这些连接通过`iscsid`服务得以持久化。

在下一章，我们将介绍**BTRFS**（**更好的文件系统**），它在 RHEL 7 中首次亮相。我相信你一定会对这个文件系统所提供的功能感到印象深刻。
