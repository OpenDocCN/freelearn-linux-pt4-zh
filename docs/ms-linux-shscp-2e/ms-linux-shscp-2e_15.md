# 第十五章：评估

# 第一章

1.  错误出在第二行：变量声明中不应该有空格。

```
#!/bin/bash 
var1="Welcome to bash scripting ..." 
echo $var1 
```

1.  结果将是`Tuesday`，因为数组是从零开始的。

1.  这里有两个错误：第一个错误是变量声明中的空格，第二个错误是使用了单引号，而应该使用反引号。

解决方案：

```
#!/bin/bash files='ls -la' echo $files
```

1.  变量`b`的值将是`c`，而变量`c`的值将是`a`。

由于我们在赋值行中没有使用美元符号，变量将会取字符值而不是整数值。

# 第二章

1.  三

这是因为整个 bash shebang 主要是注释，所以有三行注释。

1.  选项`-b`和它的值之间没有空格，因此它将被视为一个选项。

```
-a
-b50
-c
```

1.  1

四

这是因为我们传递了五个参数，并且使用了 shift 来丢弃一个参数。

1.  2

`-n`

这是因为它在左侧，而`shift`命令会从左侧移除参数。

# 第三章

1.  `False`

由于小写字符的 ASCII 顺序较高，因此该语句会返回`假`。

1.  两者都是正确的，并且会返回相同的结果，即`字符串`不相等。

1.  `三`

我们可以使用以下内容：

+   `-ge`：大于或等于

+   `-gt`：大于

+   `-ne`：不等于

1.  真

由于一个测试足以返回真值，因此我们可以确定第二个测试也会返回真值。

# 第四章

1.  我们可以进行以下更改：

```
"Hello message": {
    "prefix": "hello",
    "body": [
      "echo 'Hello ${1|first,second,third|}' "
    ],
    "description": "Hello message"
  }
```

1.  `source`命令。

# 第五章

1.  使用`((`：

```
#!/bin/bash
num=$(( 25 - 8 ))
echo $num
```

1.  问题出在文件名中的空格。要修复它，请将文件名用引号括起来：

```
$ rm "my file"
```

1.  在括号前面没有美元符号：

```
#!/bin/bash
a=$(( 8 + 4 ))
echo $a
```

# 第六章

1.  没有行。因为循环输出被重定向到文件中，所以屏幕上不会显示任何内容。

1.  四。循环将从`8`开始，直到达到`12`，它会匹配大于或等于的条件，并会中断循环。

1.  问题出在`for`循环定义中的逗号，应该改为分号。因此，正确的脚本如下：

```
#!/bin/bash 
for (( v=1; v <= 10; v++ )) 
do 
echo "value is $v" 
done 
```

1.  由于递减语句在循环外部，计数变量将保持相同的值，即`10`。这是一个无限循环，它将永远打印`10`，要停止它，你需要按*Ctrl*+*C*。

# 第七章

1.  由于我们使用了`$1`变量，而不是`$@`，该函数将只返回第一个元素。

1.  `50`。是的，它是一个全局变量，但由于我们在函数调用之前打印了它的值，变量不会受到影响。

1.  缺少括号`()`或在函数名之前没有添加关键字 function。应该这样写：

```
clean_file() { 
    is_file "$1" 
    BEFORE=$(wc -l "$1") 
    echo "The file $1 starts with $BEFORE" 
    sed -i.bak '/^\s*#/d;/^$/d' "$1" 
    AFTER=$(wc -l "$1") 
    echo "The file $1 is now $AFTER" 
} 
```

1.  问题出在函数调用中。我们在函数调用时不应该使用括号`()`，括号应该仅用于函数定义中。正确的代码应该是这样的：

```
#!/bin/bash 
myfunc() { 
arr=$@ 
echo "The array from inside the function: ${arr[*]}" 
}
```

```
test_arr=(1 2 3) 
echo "The origianl array is: ${test_arr[*]}" 
myfunc ${test_arr[*]} 

```

# 第八章

1.  无。因为你在搜索大写的 Sed，而它是不存在的。

1.  无。删除命令`d`仅删除流中的行，而不是文件中的行。要删除文件中的行，可以使用`-i`选项。

1.  第四行。因为我们使用了追加命令 a，它将在指定位置之后插入。

1.  没有，因为`w`标志仅与替换命令`s`一起使用。

# 第九章

1.  你可以使用以下命令打印第 50 行：

```
$ sed -n '50 p ' /etc/httpd/conf/httpd.conf  
```

1.  你可以使用以下命令将 Apache 的默认端口`80`更改为`8080`：

```
$ sed -i '0,/Listen [0-9]*/s//Listen 8080/' /etc/httpd/conf/httpd.conf  
```

我们搜索`Listen`，它定义了 Apache 的默认端口，查找旁边的数字并将其更改为`Listen 8080`。

# 第十章

1.  什么都没有

你应该使用变量名而不是美元符号来打印它。

1.  解决方案：零

因为你应该打印`$1`而不是`$2`，其中`$1`是第一个字段。

1.  `while`循环应该以`i`值小于`4`而不是`3`进行迭代。

1.  `1`

因为唯一的用户 UID 小于`1`的是 root（`UID=0`），所以将打印一行。

# 第十一章

1.  0 行

因为`awesome`后面有一个句点，如果你想打印那一行，可以使用以下命令：

```
$ awk '/awesome\.$/{print $0}' myfile 
```

1.  2 行

因为我们搜索包含`scripting`单词的行，并且该单词后面跟着句点和任意文本，这个模式只出现在两行中，因为第三行的`scripting`后面没有句点。

1.  3 行

因为我们使用了问号，这意味着字符类不是模式匹配的必要条件。

1.  什么都没有

因为我们使用了管道符，它是一个 ERE 字符，并且我们使用了 sed，所以我们必须使用`-r`选项来启用 sed 的扩展引擎。

# 第十二章

1.  字段 1

1.  你可以使用`print NR`，或者将输出通过管道传递给`wc -l`

我们必须使用`-l`，否则它将计算单词数。

```
$ awk '{print $1}' access.log | sort | uniq -c
```

```
$ awk '{print $7}' access.log | grep 'php' | sort | uniq -c | sort -nr | head -n 1 
```

你应该使用 head `-n 1`来只获取一页。

# 第十三章

1.  使用`lastlog`命令

```
$ lastlog | awk ' /Never logged/ { print $1}'
```

1.  使用`wc`命令

```
$ lastlog | awk ' /Never logged/ { print $1}' | wc -l
```

1.  零，因为该行以两个星号结尾。

# 第十四章

1.  8

1.  由于我们正在使用`sys`模块，我们应该先导入它。

所以正确的代码应该是这样的：

```
#!/usr/bin/python3
import sys
print( len(sys.argv))
```

1.  2
