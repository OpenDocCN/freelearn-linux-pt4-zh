# 第五章：调试、追踪和分析

在本章中，我们将涵盖以下配方：

+   分析核心转储

+   本地 GDB 调试

+   跨平台 GDB 调试

+   使用 strace 进行应用程序调试

+   使用内核的性能计数器

+   使用静态内核追踪

+   使用动态内核追踪

+   使用动态内核事件

+   探索 Yocto 的追踪和分析工具

+   使用 perf 进行追踪和分析

+   使用 SystemTap

+   使用 OProfile

+   使用 LTTng

+   使用 blktrace

# 介绍

嵌入式 Linux 产品的调试不仅是开发过程中常见的任务，在部署后的生产系统中也同样重要。

嵌入式 Linux 中的应用程序调试与传统嵌入式设备中的调试不同，因为我们没有一个操作系统和应用程序共享相同地址空间的平坦内存模型。相反，我们有一个虚拟内存模型，Linux 操作系统共享地址空间，并为运行中的进程分配虚拟内存区域。

在这种模型中，内核和用户空间调试使用的机制有所不同。例如，传统的基于 JTAG 的硬件调试器在内核调试中非常有用，但除非它了解用户空间进程的内存映射，否则无法调试用户空间应用程序。

应用程序调试通过使用用户空间调试服务来进行。我们已经看到过这种方法在 Eclipse GDB 中使用的 TCF 代理的实例。另一个常用的代理是**gdbserver**，我们将在本章中使用它。

最后，我们将探索追踪和分析的领域。追踪是对频繁的系统事件进行低级别的日志记录，而这些捕获的日志的统计分析被称为分析。

我们将使用嵌入式 Linux 和 Yocto 提供的某些工具来追踪和分析我们的系统，使其达到最大潜力。

# 分析核心转储

即使经过广泛的质量保证测试，嵌入式系统在现场也可能发生故障，需要进行调试。此外，故障往往不是可以在实验室环境中轻松重现的，因此我们只能在生产环境中调试，通常是已经硬化过的系统。

假设我们已经设计了符合上述情境的系统，我们的第一个调试选择通常是提取尽可能多的关于故障系统的信息——例如，通过获取并分析有问题进程的核心转储。

## 做好准备

在调试嵌入式 Linux 系统的过程中，我们可以使用与标准 Linux 系统相同的工具箱。工具之一使得应用程序在崩溃时可以将内存核心转储到磁盘。这要求我们有足够的磁盘空间来存储应用程序的完整内存映射，并且磁盘写入速度足够快，避免系统停滞。

一旦生成内存核心转储，我们使用主机的 GDB 来分析核心转储。GDB 需要有调试信息可用。调试信息可以包含在可执行文件本身中——例如，当我们安装`-dbg`版本的包，或者我们配置项目不剥离二进制文件——也可以保存在一个单独的文件中。要将调试信息与可执行文件分开安装，我们使用`dbg-pkgs`功能。默认情况下，这将把包的调试信息安装到与可执行文件本身相同位置的`.debug`目录中。要为目标镜像中的所有包添加调试信息，我们需要在`conf/local.conf`配置文件中添加以下内容：

```
EXTRA_IMAGE_FEATURES += "dbg-pkgs"
```

然后我们可以构建一个适当的工具链，与我们的文件系统匹配，就像我们在第四章中的*准备和使用 SDK*食谱中看到的那样。核心转储包含崩溃时正在使用的可执行文件和库的构建 ID，因此将工具链与目标镜像匹配非常重要。

## 如何操作...

我们可以使用`ulimit`工具显示系统范围内的资源限制。我们关注的是核心文件的大小，默认情况下设置为零，以避免创建应用程序核心转储。在我们失败的系统中，最好在测试环境中，使应用程序在崩溃时通过以下命令生成内存核心转储：

```
$ ulimit -c unlimited

```

然后你可以通过以下命令验证更改：

```
$ ulimit -a
-f: file size (blocks)             unlimited
-t: cpu time (seconds)             unlimited
-d: data seg size (kb)             unlimited
-s: stack size (kb)                8192
-c: core file size (blocks)        unlimited
-m: resident set size (kb)         unlimited
-l: locked memory (kb)             64
-p: processes                      5489
-n: file descriptors               1024
-v: address space (kb)             unlimited
-w: locks                          unlimited
-e: scheduling priority            0
-r: real-time priority             0

```

在这个示例中，我们将在一个真实的段错误场景中使用`wvdial`应用程序。目的是展示核心转储分析的使用方法，而不是调试应用程序本身；因此，不提供应用程序特定配置和系统设置的详细信息。不过，作为一个真实的崩溃，示例具有更强的说明性。

要在目标上运行`wvdial`，请使用以下代码：

```
# wvdial
--> WvDial: Internet dialer version 1.61
--> Initializing modem.
--> Sending: ATZ
ATZ
OK
--> Sending: ATQ0 V1 E1 S0=0 &C1 &D2 +FCLASS=0
ATQ0 V1 E1 S0=0 &C1 &D2 +FCLASS=0
OK
--> Sending: AT+CGDCONT=1,"IP","internet"
AT+CGDCONT=1,"IP","internet"
OK
--> Modem initialized.
--> Idle Seconds = 3000, disabling automatic reconnect.
Segmentation fault (core dumped)

```

应用程序将在相同的文件夹中创建一个核心文件，你可以将其复制到主机系统进行分析。

### 提示

你也可以通过向正在运行的进程发送`SIGQUIT`信号来模拟核心转储。例如，你可以通过以下方式强制`sleep`命令生成核心转储：

```
 $ ulimit -c unlimited
 $ sleep 30 &
 $ kill -QUIT <sleep-pid>

```

## 它是如何工作的...

一旦获得核心转储，使用主机中的交叉 GDB 加载它，并通过以下步骤获取一些有用的信息，比如回溯：

1.  首先在主机中设置环境：

    ```
    $ cd /opt/poky/1.7.1/
    $ source environment-setup-cortexa9hf-vfp-neon-poky-linux- gnueabi

    ```

1.  然后你可以启动交叉 GDB 调试器，传递一个调试版本的应用程序。调试版本存储在与未剥离的二进制文件相同位置的`sysroot`文件中，但在`.debug`目录下。

    以下是完整的 GDB 横幅，但在以后的示例中将省略。

    ```
    $ arm-poky-linux-gnueabi-gdb /opt/yocto/fsl-community- bsp/wandboard-quad/tmp/work/cortexa9hf-vfp-neon-poky-linux- gnueabi/wvdial/1.61-r0/packages-split/wvdial- dbg/usr/bin/.debug/wvdial core
    GNU gdb (GDB) 7.7.1
    Copyright (C) 2014 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
    and "show warranty" for details.
    This GDB was configured as "--host=x86_64-pokysdk-linux -- target=arm-poky-linux-gnueabi".
    Type "show configuration" for configuration details.
    For bug reporting instructions, please see:
    <http://www.gnu.org/software/gdb/bugs/>.
    Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.
    For help, type "help".
    Type "apropos word" to search for commands related to "word"...
    Reading symbols from /opt/yocto/fsl-community-bsp/wandboard- quad/tmp/work/cortexa9hf-vfp-neon-poky-linux- gnueabi/wvdial/1.61-r0/packages-split/wvdial- dbg/usr/bin/.debug/wvdial...done.
    [New LWP 1050]

    warning: Could not load shared library symbols for 14 libraries, e.g. /usr/lib/libwvstreams.so.4.6.
    Use the "info sharedlibrary" command to see the complete listing.
    Do you need "set solib-search-path" or "set sysroot"?
    Core was generated by `wvdial'.
    Program terminated with signal SIGSEGV, Segmentation fault.
    #0  0x76d524c4 in ?? ()
    ```

1.  现在将 GDB 指向工具链`sysroot`的所在位置：

    ```
    (gdb) set sysroot /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi/
    Reading symbols from /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi/usr/lib/libwvstreams.so.4.6...Reading symbols from /opt/poky/1.7.1/sysroots/cortexa9hf-vfp-neon-poky-linux- gnueabi/usr/lib/.debug/libwvstreams.so.4.6...done.
    done.
    Loaded symbols for /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi/usr/lib/libwvstreams.so.4.6
    Reading symbols from /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi/usr/lib/libwvutils.so.4.6...Reading symbols from /opt/poky/1.7.1/sysroots/cortexa9hf-vfp-neon- poky-linux-gnueabi/usr/lib/.debug/libwvutils.so.4.6...done.
    done.
    [...]
    Loaded symbols for /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi/lib/libdl.so.2
    ```

1.  现在你可以使用以下命令查询 GDB 获取应用程序的回溯：

    ```
    (gdb) bt
    #0  0x76d524c4 in WvTaskMan::_stackmaster () at utils/wvtask.cc:416
    #1  0x00000000 in ?? ()
    ```

## 另见

+   GDB 的使用文档可以在[`www.gnu.org/software/gdb/documentation/`](http://www.gnu.org/software/gdb/documentation/)找到。

# 本地 GDB 调试

在像 Wandboard 这样强大的设备上，本地调试也是调试间歇性故障的一个选择。本食谱将探讨本地调试方法。

## 准备工作

对于本地开发和调试，Yocto 提供了 `-dev` 和 `-sdk` 目标镜像。为了将开发工具添加到 `-dev` 镜像中，我们可以使用 `tools-sdk` 功能。我们还需要安装调试信息和调试工具，方法是将 `dbg-pkgs` 和 `tools-debug` 功能添加到镜像中。例如，对于 `core-image-minimal-dev`，我们可以将以下内容添加到 `conf/local.conf` 文件中：

```
EXTRA_IMAGE_FEATURES += "tools-sdk dbg-pkgs tools-debug"
```

要准备一个开发就绪的 `core-image-minimal-dev` 目标镜像版本，我们将执行以下命令：

```
$ cd /opt/yocto/fsl-community-bsp/
$ source setup-environment wandboard-quad
$ bitbake core-image-minimal-dev

```

我们接下来将把开发镜像写入目标设备。

## 如何做...

一旦目标设备启动，您可以通过本地 GDB 使用以下步骤启动 `wvdial` 应用程序：

1.  在目标设备的命令提示符中，使用应用程序作为参数启动 GDB 调试器：

    ```
    $ gdb wvdial

    ```

1.  现在指示 GDB 运行应用程序：

    ```
    (gdb) run
    Starting program: /usr/bin/wvdial
    Cannot access memory at address 0x0
    Cannot access memory at address 0x0

    Program received signal SIGILL, Illegal instruction.
    0x7698afe8 in ?? () from /lib/libcrypto.so.1.0.0
    (gdb) sharedlibrary libcrypto
    Symbols already loaded for /lib/libcrypto.so.1.0.0
    ```

1.  然后请求打印回溯信息：

    ```
    (gdb) bt
    #0  0x7698afe8 in ?? () from /lib/libcrypto.so.1.0.0
    #1  0x769878e8 in OPENSSL_cpuid_setup () from /lib/libcrypto.so.1.0.0
    #2  0x76fe715c in ?? () from /lib/ld-linux-armhf.so.3
    Cannot access memory at address 0x48535540
    ```

    这不是您在分析核心转储时获得的相同回溯信息。那么这里发生了什么？线索在于 libcrypto，它是 OpenSSL 库的一部分。OpenSSL 通过尝试每个功能并捕获非法指令错误来探测系统的功能。因此，您在启动过程中看到的 `SIGILL` 信号是正常的，您应该指示 GDB 继续执行。

1.  指示 GDB 继续执行：

    ```
    (gdb) c
    Continuing.
    --> WvDial: Internet dialer version 1.61
    --> Initializing modem.
    --> Sending: ATZ
    ATZ
    OK
    --> Sending: ATQ0 V1 E1 S0=0 &C1 &D2 +FCLASS=0
    ATQ0 V1 E1 S0=0 &C1 &D2 +FCLASS=0
    OK
    --> Sending: AT+CGDCONT=1,"IP","internet"
    AT+CGDCONT=1,"IP","internet"
    OK
    --> Modem initialized.
    --> Idle Seconds = 3000, disabling automatic reconnect.

    Program received signal SIGSEGV, Segmentation fault.
    0x76db74c4 in WvTaskMan::_stackmaster() () from /usr/lib/libwvbase.so.4.6
    ```

该结果现在与您在前一个食谱中看到的核心转储兼容。

## 还有更多...

在调试应用程序时，有时通过减少编译器使用的优化级别会非常有用。这会降低应用程序的性能，但通过提高调试信息的准确性，有助于调试。您可以通过将以下代码行添加到 `conf/local.conf` 文件中来配置构建系统，减少优化并添加调试信息：

```
DEBUG_BUILD = "1"
```

通过使用此配置，优化级别从 `FULL_OPTIMIZATION (-O2)` 降低到 `DEBUG_OPTIMIZATION (-O -fno-omit-frame-pointer)`。但有时这还不够，您可能希望在没有优化的情况下进行构建。您可以通过全局或针对特定食谱覆盖 `DEBUG_OPTIMIZATION` 变量来实现这一点。

## 另请参见

+   接下来的 *交叉 GDB 调试* 食谱中的调试优化构建示例

# 交叉 GDB 调试

当我们在主机上运行交叉编译的 GDB，并连接到在目标设备上运行的本地 gdbserver 时，这被称为交叉调试。这与我们之前在 *使用 Eclipse IDE* 食谱中看到的场景相同，唯一不同的是 Eclipse 使用 **目标通信框架**（**TCF**）。交叉调试的优势在于不需要目标镜像上的调试信息，因为这些信息已经在主机上可用。

本食谱将展示如何使用交叉 GDB 和 gdbserver。

## 准备工作

要在目标镜像中包含 gdbserver，你可以使用 `-sdk` 镜像，或者通过将以下内容添加到 `conf/local.conf` 配置文件中，向镜像中添加 `tools-debug` 功能：

```
EXTRA_IMAGE_FEATURES += "tools-debug"
```

为了让 GDB 能访问共享库和可执行文件的调试信息，请在 `conf/local.conf` 文件中添加以下内容：

```
EXTRA_IMAGE_FEATURES += "dbg-pkgs"
```

在目标上运行的镜像与工具链的 `sysroot` 需要匹配。例如，如果你使用的是 `core-image-minimal` 镜像，则工具链需要在同一项目中生成，且：

```
$ bitbake -c populate_sdk core-image-minimal

```

这将生成一个包含二进制文件和库调试信息的 `sysroot`。

## 如何操作...

一旦工具链安装完成，你可以在目标机上使用 gdbserver 运行待调试的应用程序——在本例中是 `wvdial`——并执行以下步骤：

1.  使用应用程序作为参数启动 gdbserver：

    ```
    # gdbserver localhost:1234 /usr/bin/wvdial
    Process wvdial created; pid = 879
    Listening on port 1234

    ```

    gdbserver 启动并在 localhost 上监听一个随机的 1234 端口，等待远程 GDB 的连接。

1.  在主机上，你现在可以使用最近安装的工具链来设置环境：

    ```
    $ cd /opt/poky/1.7.1/
    $ source environment-setup-cortexa9hf-vfp-neon-poky-linux- gnueabi

    ```

    然后你可以启动跨平台 GDB，传递给它应用程序的调试版本的绝对路径，该版本位于 `sysroot` 中的 `.debug` 目录下：

    ```
    $ arm-poky-linux-gnueabi-gdb /opt/poky/1.7.1/sysroots/cortexa9hf-vfp-neon-poky-linux- gnueabi/usr/bin/.debug/wvdial
    Reading symbols from /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi/usr/bin/.debug/wvdial...done.
    (gdb)

    ```

1.  接下来，配置 GDB 将所有文件视为可信，以便它自动加载所需的内容：

    ```
    (gdb) set auto-load safe-path /
    ```

1.  正如你所知，`wvdial` 会生成一个 `SIGILL` 信号，打断我们的调试会话，指示 GDB 在遇到该信号时不要停止：

    ```
    (gdb) handle SIGILL nostop
    ```

1.  然后你可以通过以下命令连接到 `1234` 端口的远程目标：

    ```
    (gdb) target remote <target_ip>:1234
    Remote debugging using 192.168.128.6:1234
    Cannot access memory at address 0x0
    0x76fd7b00 in ?? ()
    ```

1.  首先要做的是设置 `sysroot`，使 GDB 能找到动态加载的库：

    ```
    (gdb) set sysroot /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi
    Reading symbols from /opt/poky/1.7.1/sysroots/cortexa9hf- vfp-neon-poky-linux-gnueabi/lib/ld-linux- armhf.so.3...done.
    Loaded symbols for /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi/lib/ld-linux-armhf.so.3
    ```

1.  输入 `c` 以继续程序的执行。你将看到 `wvdial` 在目标机上继续执行：

    ```
    --> WvDial: Internet dialer version 1.61
    --> Initializing modem.
    --> Sending: ATZ
    ATZ
    OK
    --> Sending: ATQ0 V1 E1 S0=0 &C1 &D2 +FCLASS=0
    ATQ0 V1 E1 S0=0 &C1 &D2 +FCLASS=0
    OK
    --> Sending: AT+CGDCONT=1,"IP","internet"
    AT+CGDCONT=1,"IP","internet"
    OK
    --> Modem initialized.
    --> Idle Seconds = 3000, disabling automatic reconnect.

    ```

1.  然后你会看到 GDB 在主机上拦截到 `SIGILL` 和 `SEGSEGV` 信号：

    ```
    Program received signal SIGILL, Illegal instruction.

    Program received signal SIGSEGV, Segmentation fault.
    0x76dc14c4 in WvTaskMan::_stackmaster () at utils/wvtask.cc:416
    416     utils/wvtask.cc: No such file or directory.
    ```

1.  现在你可以请求查看回溯信息：

    ```
    (gdb) bt
    #0  0x76dc14c4 in WvTaskMan::_stackmaster () at utils/wvtask.cc:416
    #1  0x00000000 in ?? ()
    ```

    虽然有限，这个回溯仍然对调试应用程序有所帮助。

## 它是如何工作的...

我们看到的回溯信息有限，因为编译后的二进制文件不适合调试，它们省略了栈帧。为了保留栈帧信息，请在 `conf/local.conf` 配置文件中添加以下内容：

```
DEBUG_BUILD = "1"
```

这将把编译标志更改为调试优化，具体如下：

```
DEBUG_OPTIMIZATION = "-O -fno-omit-frame-pointer ${DEBUG_FLAGS} - pipe"
```

`-fno-omit-frame-pointer` 标志会告诉 `gcc` 保留栈帧。编译器还会减少优化级别，以提供更好的调试体验。

调试构建还可以让你追踪变量，设置断点和观察点，以及其他常见的调试功能。

在重新构建和安装目标镜像及工具链之后，你现在可以按照前述步骤中的相同步骤继续操作：

1.  使用以下代码连接到远程目标：

    ```
    (gdb) target remote <target_ip>:1234
    Remote debugging using 192.168.128.6:1234
    warning: Unable to find dynamic linker breakpoint function.
    GDB will be unable to debug shared library initializers
    and track explicitly loaded dynamic code.
    Cannot access memory at address 0x0
    0x76fdd800 in ?? ()
    ```

    如下设置 `sysroot`：

    ```
    (gdb) set sysroot /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi
    Reading symbols from /opt/poky/1.7.1/sysroots/cortexa9hf- vfp-neon-poky-linux-gnueabi/lib/ld-linux- armhf.so.3...done.
    Loaded symbols for /opt/poky/1.7.1/sysroots/cortexa9hf-vfp- neon-poky-linux-gnueabi/lib/ld-linux-armhf.so.3
    ```

1.  完成设置后，按照如下方式指示程序继续运行：

    ```
    (gdb) c
    Continuing.

    Program received signal SIGILL, Illegal instruction.

    Program received signal SIGABRT, Aborted.
    0x76b28bb4 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:55
    55      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
    (gdb) bt
    #0  0x76b28bb4 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:55
    #1  0x76b2cabc in __GI_abort () at abort.c:89
    #2  0x76decfa8 in __assert_fail (__assertion=0x76df4600 "magic_number == -0x123678",
        __file=0x1 <error: Cannot access memory at address 0x1>, __line=427,
        __function=0x76df4584 <WvTaskMan::_stackmaster()::__PRETTY_FUNCTION__> "static void WvTaskMan::_stackmaster()")
        at utils/wvcrashbase.cc:98
    #3  0x76dc58c8 in WvTaskMan::_stackmaster () at utils/wvtask.cc:427
    Cannot access memory at address 0x123678
    #4  0x00033690 in ?? ()
    Cannot access memory at address 0x123678
    Backtrace stopped: previous frame identical to this frame (corrupt stack?)
    ```

    你现在可以看到完整的回溯信息。

# 使用 strace 进行应用程序调试

调试并不总是与源代码打交道。有时候，是外部因素的变化引起了问题。

Strace 是一个有用的工具，适用于我们在寻找二进制文件本身以外的问题时；例如配置文件、输入数据和内核接口。本章节将解释如何使用它。

## 准备工作

要在你的系统中包含 strace，请将以下内容添加到你的 `conf/local.conf` 配置文件中：

```
IMAGE_INSTALL_append = " strace"
```

Strace 也包含在 `tools-debug` 镜像特性中，因此你也可以通过以下方式添加它：

```
EXTRA_IMAGE_FEATURES += "tools-debug"
```

Strace 也包含在 `-sdk` 镜像中。

在开始之前，我们还将包括 `pgrep`，这是一个进程工具，它通过名称查找进程 ID，从而让我们的调试更为轻松。为此，请将以下内容添加到你的 `conf/local.conf` 配置文件中：

```
IMAGE_INSTALL_append = " procps"
```

## 如何操作...

当打印系统调用时，strace 会打印传递给内核或从内核返回的值。详细模式选项会为某些系统调用打印更多的细节。

例如，过滤来自单个 ping 的 `sendto()` 系统调用，如下所示：

```
# strace -f -t -e sendto /bin/bash -c "ping -c 1 127.0.0.1"
5240  17:18:04 sendto(0, "\10\0;\220x\24\0\0\225m\256\355\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\ 0\0"..., 64, 0, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr("127.0.0.1")}, 28) = 64

```

## 它是如何工作的...

Strace 允许监视运行中的进程的系统调用并将其传递到 Linux 内核中。它使用 `ptrace()` 系统调用来实现这一功能。这意味着，其他使用 `ptrace()` 的程序，如 `gdb`，将无法同时运行。

Strace 是一种具有破坏性的监控工具，监控的进程将会变慢，并且会产生更多的上下文切换。对给定程序运行 strace 的通用方式如下：

```
strace -f -e <filter> -t -s<num> -o <log file>.strace <program>

```

下面解释了这些参数：

+   `f`：告诉 strace 跟踪所有子进程。

+   `e`：过滤输出，仅显示以逗号分隔的系统调用。

+   `t`：打印绝对时间戳。使用 `r` 以获取相对于上一个系统调用的时间戳，使用 `T` 添加系统调用的执行时间。

+   `s`：增加字符串的最大长度，默认值为 `32`。

+   `o`：将输出重定向到一个文件，供离线分析。

它还可以使用以下命令附加到正在运行的进程：

```
$ strace -p $( pgrep <program> )

```

或者使用以下命令来查看某个进程的多个实例：

```
$ strace $( pgrep <program> | sed 's/^/-p' )

```

要分离，只需按 *Ctrl* + *C*。

## 另见

+   相关的 man 页面可供参考，了解更多关于 strace 的信息：[`man7.org/linux/man-pages/man1/strace.1.html`](http://man7.org/linux/man-pages/man1/strace.1.html)

# 使用内核的性能计数器

硬件性能计数器非常适合代码优化，特别是在只有单一工作负载的嵌入式系统中。它们被广泛用于各种追踪和分析工具中。本章节将介绍 Linux 性能计数器子系统，并展示如何使用它。

## 准备工作

**Linux 内核性能计数子系统**（**LPC**），通常称为 `linux_perf`，是一个用于不同 CPU 特定性能测量的抽象接口。`perf_events` 子系统不仅暴露来自 CPU 的硬件性能计数器，还通过相同的 API 提供内核软件事件。它还允许将事件映射到进程，尽管这会带来性能开销。此外，它提供了跨架构通用的事件。

事件可以分为三大类：

+   **软件事件**：基于内核计数器，这些事件用于跟踪上下文切换、次要故障等。

+   **硬件事件**：这些来自处理器的 CPU **性能监控单元**（**PMU**），用于跟踪特定于架构的项目，如周期数、缓存未命中等。它们随每种处理器类型而变化。

+   **硬件缓存事件**：这些是常见的硬件事件，只有在它们实际上映射到 CPU 硬件事件时才会可用。

要了解你的平台是否支持 `perf_event`，你可以检查 `/proc/sys/kernel/perf_event_paranoid` 文件的存在。该文件还用于限制对性能计数器的访问，默认情况下允许内核和用户测量。它可以有以下值：

+   `2`: 仅允许用户空间测量

+   `1`: 允许内核和用户测量（默认）

+   `0`: 允许访问特定于 CPU 的数据，但不包括原始追踪点样本

+   `-1`: 无限制

i.MX6 SoC 配备了 Cortex-A9 CPU，其中包含一个 PMU，提供六个计数器，用于收集处理器和内存操作的统计数据，每个计数器都可以监控 58 个可用事件中的任何一个。

你可以在 *Cortex-A9 技术参考手册* 中找到可用事件的描述。

i.MX6 性能计数器不允许仅对用户或仅对内核测量进行独占访问。此外，不幸的是，i.MX6 SoC 设计师将所有 CPU 核心的 PMU 中断合并在一起，而理想情况下它们应该仅由触发它们的 CPU 处理。你可以使用 `maxcpus=1` 内核命令行参数启动 i.MX6，只使用一个核心，这样你仍然可以使用 `perf_events` 接口。

要配置 Linux 内核使用单核启动，请在 U-Boot 提示符下停止并按如下方式更改 `mmcargs` 环境变量：

```
> setenv mmcargs 'setenv bootargs console=${console},${baudrate} root=${mmcroot} ${extra_bootargs}; run videoargs'
> setenv extra_bootargs maxcpus=1

```

### 注意

`mmcargs` 环境变量仅在从 MMC 设备（如 microSD 卡）启动时使用。如果目标是从其他来源启动，如网络，则需要更改相应的环境变量。你可以使用 `printenv` U-Boot 命令转储整个 U-Boot 环境，并使用 `setenv` 更改所需的变量。

## 如何操作...

该接口引入了`sys_perf_event_open()`系统调用，计数器通过`ioctls`启动和停止，读取可以通过`read()`调用或`mmapping`样本写入循环缓冲区。`perf_event_open()`系统调用定义如下：

```
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>

int perf_event_open(struct perf_event_attr *attr,
                    pid_t pid, int cpu, int group_fd,
                    unsigned long flags);
```

由于没有`C`库包装器，因此需要使用`syscall()`调用它。

## 它是如何工作的...

以下是一个例子，`perf_example.c`，该程序修改自`perf_event_open`手册页面，用于测量`printf`调用的指令数：

```
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <linux/perf_event.h>
#include <asm/unistd.h>

static long
perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
                int cpu, int group_fd, unsigned long flags)
{
    int ret;

    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,
                   group_fd, flags);
    return ret;
}

int
main(int argc, char **argv)
{
    struct perf_event_attr pe;
    long long count;
    int fd;

    memset(&pe, 0, sizeof(struct perf_event_attr));
    pe.type = PERF_TYPE_HARDWARE;
    pe.size = sizeof(struct perf_event_attr);
    pe.config = PERF_COUNT_HW_INSTRUCTIONS;
    pe.disabled = 1;

    fd = perf_event_open(&pe, 0, -1, -1, 0);
    if (fd == -1) {
       fprintf(stderr, "Error opening leader %llx\n", pe.config);
       exit(EXIT_FAILURE);
    }

    ioctl(fd, PERF_EVENT_IOC_RESET, 0);
    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);

    printf("Measuring instruction count for this printf\n");

    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);
    read(fd, &count, sizeof(long long));

    printf("Used %lld instructions\n", count);

    close(fd);

    return 0;
}
```

要在外部编译此程序，我们可以使用以下命令：

```
$ source /opt/poky/1.7.1/environment-setup-cortexa9hf-vfp-neon-poky- linux-gnueabi
$ ${CC} perf_example.c -o perf_example

```

将二进制文件复制到目标设备后，您可以通过以下代码执行它：

```
# ./perf_example
Measuring instruction count for this printf
Used 0 instructions

```

显然，使用零指令来调用`printf()`是不正确的。经过检查，发现 i.MX6 处理器上有一个已记录的错误（ERR006259），该错误指出为了使用 PMU，SoC 在上电重置后需要至少接收 4 个 JTAG 时钟周期。

重新连接 JTAG 并重新运行该示例：

```
# ./perf_example
Measuring instruction count for this printf
Used 3977 instructions

```

## 还有更多...

即使你可以像前面例子中那样直接访问`perf_events`接口，推荐的使用方法是通过用户空间应用程序（如 perf），我们将在本章的*使用 perf 进行跟踪和分析*示例中看到。

## 另见

+   更多信息请参见技术参考手册：[`infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0388f/BEHGGDJC.html`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0388f/BEHGGDJC.html)，了解有关 Cortex-A9 PMU 的更多信息。

# 使用静态内核跟踪

Linux 内核不断通过静态探针点（称为**tracepoints**）进行插桩，这些探针在禁用时会带来非常小的开销。它们允许我们记录比我们在第二章中看到的函数跟踪器更多的信息，*BSP 层*。Tracepoints 被 Yocto 中的多个跟踪和分析工具使用。

本示例将解释如何独立于用户空间工具使用和定义静态跟踪点。

## 准备工作

静态探针可以通过自定义内核模块进行插桩，也可以通过事件跟踪基础设施插桩。启用内核中的任何跟踪功能将创建一个`/sys/kernel/debug/tracing/`目录；例如，前面在第二章中解释的函数跟踪功能，*BSP 层*。

因此，在继续本示例之前，您需要如前所述配置 Linux 内核中的函数跟踪功能。

## 如何操作...

静态跟踪功能通过`debugfs`文件系统暴露。该接口提供的功能包括：

+   **列出事件**：

    您可以查看通过`sysfs`暴露的可用跟踪点，并按子系统目录进行排序，方法是：

    ```
    # ls /sys/kernel/debug/tracing/events/
    asoc          ftrace        migrate       rcu           spi
    block         gpio          module        regmap        sunrpc
    cfg80211      header_event  napi          regulator     task
    compaction    header_page   net           rpm           timer
    drm           irq           oom           sched         udp
    enable        jbd           power         scsi          vmscan
    ext3          jbd2          printk        signal        workqueue
    ext4          kmem          random        skb           writeback
    filemap       mac80211      raw_syscalls  sock

    ```

    或者在`available_events`文件中使用`<subsystem>:<event>`格式，通过以下命令：

    ```
    #  grep 'net'  /sys/kernel/debug/tracing/available_events 
    net:netif_rx
    net:netif_receive_skb
    net:net_dev_queue
    net:net_dev_xmit

    ```

+   **描述事件**：

    每个事件都有一个特定的打印格式，描述了日志事件中包含的信息，如下所示：

    ```
    #cat /sys/kernel/debug/tracing/events/net/netif_receive_skb/format
    name: netif_receive_skb
    ID: 378
    format:
     field:unsigned short common_type;  offset:0;  size:2; signed:0;
     field:unsigned char common_flags;  offset:2;  size:1; signed:0;
     field:unsigned char common_preempt_count;  offset:3; size:1;  signed:0;
     field:int common_pid;  offset:4;  size:4;  signed:1;

     field:void * skbaddr;  offset:8;  size:4;  signed:0;
     field:unsigned int len;	offset:12;  size:4;  signed:0;
     field:__data_loc char[] name;	offset:16;  size:4;  signed:0;

    print fmt: "dev=%s skbaddr=%p len=%u", __get_str(name), REC- >skbaddr, REC->len

    ```

+   **启用和禁用事件**：

    您可以通过以下几种方式启用或禁用事件：

    +   通过向事件`enable`文件中回显 0 或 1：

        ```
        # echo 1 > /sys/kernel/debug/tracing/events/net/netif_receive_skb/enable

        ```

    +   按子系统目录，可以启用或禁用该目录/子系统中的所有跟踪点：

        ```
        # echo 1 > /sys/kernel/debug/tracing/events/net/enable

        ```

    +   通过将唯一的跟踪点名称回显到`set_event`文件中：

        ```
        # echo netif_receive_skb >> /sys/kernel/debug/tracing/set_event

        ```

    请注意，追加操作`>>`用于不清除事件。

    +   通过向事件名称追加感叹号，可以禁用事件：

        ```
        # echo '!netif_receive_skb' >> /sys/kernel/debug/tracing/set_event

        ```

    +   事件也可以通过子系统来启用/禁用：

        ```
        # echo 'net:*' > /sys/kernel/debug/tracing/set_event

        ```

    +   要禁用所有事件：

        ```
        # echo > /sys/kernel/debug/tracing/set_event

        ```

    您还可以通过传递`trace_event=<用逗号分隔的事件列表>`内核命令行参数，从启动时启用跟踪点。

+   **将事件添加到跟踪缓冲区**：

    要在跟踪缓冲区上看到跟踪点的出现，请打开跟踪功能：

    ```
    # echo 1 > /sys/kernel/debug/tracing/tracing_on

    ```

    跟踪点事件集成到`ftrace`子系统中，因此，如果启用跟踪点，在运行跟踪器时，它会出现在跟踪中。请看以下命令：

    ```
    # cd /sys/kernel/debug/tracing
    # echo 1 > events/net/netif_receive_skb/enable
    # echo netif_receive_skb > set_ftrace_filter
    # echo function > current_tracer
    # cat trace
     <idle>-0     [000] ..s2  1858.542206: netif_receive_skb <-napi_gro_receive
     <idle>-0     [000] ..s2  1858.542214: netif_receive_skb: dev=eth0 skbaddr=dcb5bd80 len=168

    ```

## 它的工作原理...

跟踪点是通过使用`TRACE_EVENT`宏插入的。它在内核源代码中插入一个回调，该回调使用跟踪点参数作为参数进行调用。使用`TRACE_EVENT`宏添加的跟踪点允许`ftrace`或任何其他跟踪器使用它们。回调将跟踪插入调用跟踪器的环形缓冲区。

要将新的跟踪点插入到 Linux 内核中，需要定义一个具有特殊格式的新头文件。默认情况下，跟踪点内核文件位于`include/trace/events`中，但内核具有功能，可以将头文件放置在不同的路径中。这在定义内核模块中的跟踪点时非常有用。

要使用跟踪点，必须在插入跟踪点的任何文件中包含头文件，并且单个 C 文件必须定义`CREATE_TRACE_POINT`。例如，要扩展我们在前一章中看到的`hello world`Linux 内核模块并添加跟踪点，可以将以下代码添加到`meta-bsp-custom/recipes-kernel/hello-world-tracepoint/files/hello_world.c`：

```
#include <linux/module.h>
#include "linux/timer.h"
#define CREATE_TRACE_POINTS
#include "trace.h"

static struct timer_list hello_timer;

void hello_timer_callback(unsigned long data)
{
        char a[] = "Hello";
        char b[] = "World";
        printk("%s %s\n",a,b);
      /* Insert the static tracepoint */
 trace_log_dbg(a, b);
      /* Trigger the timer again in 8 seconds */
        mod_timer(&hello_timer, jiffies + msecs_to_jiffies(8000));
}

static int hello_world_init(void)
{
      /* Setup a timer to fire in 2 seconds */
        setup_timer(&hello_timer, hello_timer_callback, 0);
        mod_timer(&hello_timer, jiffies + msecs_to_jiffies(2000));
        return 0;
}

static void hello_world_exit(void)
{
      /* Delete the timer */
        del_timer(&hello_timer);
}

module_init(hello_world_init);
module_exit(hello_world_exit);

MODULE_LICENSE("GPL v2");
```

`meta-bsp-custom/recipes-kernel/hello-world-tracepoint/files/trace.h`中的跟踪点头文件将是：

```
#undef TRACE_SYSTEM
#define TRACE_SYSTEM log_dbg

#if !defined(_HELLOWORLD_TRACE) || defined(TRACE_HEADER_MULTI_READ)
#define _HELLOWORLD_TRACE

#include <linux/tracepoint.h>

TRACE_EVENT(log_dbg,
            TP_PROTO(char *a, char *b),
            TP_ARGS(a, b),
            TP_STRUCT__entry(
                    __string(a, a)
                    __string(b, b)),
            TP_fast_assign(
                    __assign_str(a, a);
                    __assign_str(b, b);),
            TP_printk("log_dbg: a %s b %s",
                      __get_str(a), __get_str(b))
        );
#endif

/* This part must be outside protection */
#undef TRACE_INCLUDE_PATH
#undef TRACE_INCLUDE_FILE
#define TRACE_INCLUDE_PATH .
#define TRACE_INCLUDE_FILE trace
#include <trace/define_trace.h>
```

在`meta-bsp-custom/recipes-kernel/hello-world-tracepoint/files/Makefile`中的模块`Makefile`文件将如下所示：

```
obj-m   := hello_world.o
CFLAGS_hello_world.o    += -I$(src)

SRC := $(shell pwd)

all:
        $(MAKE) -C "$(KERNEL_SRC)" M="$(SRC)"

modules_install:
        $(MAKE) -C "$(KERNEL_SRC)" M="$(SRC)" modules_install

clean:
        rm -f *.o *~ core .depend .*.cmd *.ko *.mod.c
        rm -f Module.markers Module.symvers modules.order
        rm -rf .tmp_versions Modules.symvers
```

请注意，突出显示的行包括当前文件夹在`include`文件的搜索路径中。

我们现在可以像在第二章的*构建外部内核模块*食谱中看到的那样，外部构建模块，*BSP 层*。对应的 Yocto 食谱包含在随书附带的源码中。以下是相应的代码：

```
$ cd /opt/yocto/fsl-community-bsp/sources/meta-bsp-custom/recipes- kernel/hello-world-tracepoint/files/
$ source /opt/poky/1.7.1/environment-setup-cortexa9hf-vfp-neon-poky- linux-gnueabi
$ KERNEL_SRC=/opt/yocto/linux-wandboard make

```

将生成的`hello_world.ko`模块复制到 Wandboard 的根文件系统后，您可以使用以下命令加载它：

```
# insmod hello_world.ko
Hello World

```

您现在可以在`/sys/kernel/debug/tracing/events`目录下看到一个新的`log_dbg`目录，其中包含一个`log_dbg`事件跟踪点，格式如下：

```
# cat /sys/kernel/debug/tracing/events/log_dbg/log_dbg/format
name: log_dbg
ID: 622
format:
 field:unsigned short common_type;       offset:0;       size:2; signed:0;
 field:unsigned char common_flags;       offset:2;       size:1; signed:0;
 field:unsigned char common_preempt_count;       offset:3;    size:1; signed:0;
 field:int common_pid;   offset:4;       size:4; signed:1;

 field:__data_loc char[] a;      offset:8;       size:4; signed:0;
 field:__data_loc char[] b;      offset:12;      size:4; signed:0;

print fmt: "log_dbg: a %s b %s", __get_str(a), __get_str(b)

```

然后你可以在 `hello_timer_callback` 函数上启用函数追踪器：

```
# cd /sys/kernel/debug/tracing
# echo 1 > events/log_dbg/log_dbg/enable
# echo 1 > /sys/kernel/debug/tracing/tracing_on
# cat trace
 <idle>-0     [000] ..s2    57.425040: log_dbg: log_dbg: a Hello b World

```

## 还有更多内容...

静态追踪点也可以进行过滤。当事件与设置的过滤器匹配时，事件会被保留，否则会被丢弃。没有过滤器的事件总是被保留。

例如，要为前面代码中插入的 `log_dbg` 事件设置匹配过滤器，你可以匹配 `a` 或 `b` 变量：

```
# echo "a == \"Hello\"" > /sys/kernel/debug/tracing/events/log_dbg/log_dbg/filter

```

## 另见

+   更多信息请参见 Linux 内核文档：[`git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/trace/events.txt`](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/plain/Documentation/trace/events.txt)

+   Steven Rostedt 在 [`lwn.net/Articles/379903/`](http://lwn.net/Articles/379903/) 上的 *使用 TRACE_EVENT() 宏* 文章系列

# 使用动态内核追踪

`kprobes` 是一个内核调试工具，允许我们动态地插入几乎任何内核函数（除了 `kprobe` 本身）以非破坏性地收集调试和性能分析信息。一些架构会维护一个黑名单函数数组，这些函数无法通过 `kprobe` 进行探测，但在 ARM 架构中，该列表为空。

因为 `kprobes` 可以用来修改函数的数据和寄存器，所以它应该只在开发环境中使用。

有三种类型的探测器：

+   `kprobes`：这是内核探测器，可以插入到任何位置，若需要，可以在同一位置添加多个 `kprobe`。

+   `jprobe`：这是插入内核函数入口点的跳转探测器，用于访问其参数。每个位置只能添加一个 `jprobe`。

+   `kretprobe`：这是一个返回探测器，在函数返回时触发。此外，每个位置只能添加一个 `kretprobe`。

它们被打包成一个内核模块，`init` 函数负责注册探测器，`exit` 函数负责注销探测器。

本教程将解释如何使用所有类型的动态探测器。

## 准备工作

要为 Linux 内核配置 `kprobes` 支持，你需要：

+   定义 `CONFIG_KPROBES` 配置变量

+   定义 `CONFIG_MODULES` 和 `CONFIG_MODULE_UNLOAD` 以便可以使用模块来注册探测器。

+   定义 `CONFIG_KALLSYMS` 和 `CONFIG_KALLSYMS_ALL`（推荐）以便能够查找内核符号

+   可选地，定义 `CONFIG_DEBUG_INFO` 配置变量，这样探测器可以作为从入口点的偏移插入到函数中。要找到插入点，你可以使用 `objdump`，如下所示的 `do_sys_open` 函数片段：

    ```
    arm-poky-linux-gnueabi-objdump -d -l vmlinux | grep do_sys_open
    8010bfa8 <do_sys_open>:
    do_sys_open():
    8010c034:       0a000036        beq     8010c114 <do_sys_open+0x16c>
    8010c044:       1a000031        bne     8010c110 <do_sys_open+0x168>
    ```

    `kprobes` API 定义在 `kprobes.h` 文件中，包括三种类型探测器的注册/注销以及启用/禁用函数，具体如下：

    ```
    #include <linux/kprobes.h>
    int register_kprobe(struct kprobe *kp);
    int register_jprobe(struct jprobe *jp)
    int register_kretprobe(struct kretprobe *rp);

    void unregister_kprobe(struct kprobe *kp);
    void unregister_jprobe(struct jprobe *jp);
    void unregister_kretprobe(struct kretprobe *rp);
    ```

    默认情况下，`kprobe` 探测器在注册时会被启用，除非传入 `KPROBE_FLAG_DISABLED` 标志。以下函数定义用于启用或禁用探测器：

    ```
    int disable_kprobe(struct kprobe *kp);
    int disable_kretprobe(struct kretprobe *rp);
    int disable_jprobe(struct jprobe *jp);

    int enable_kprobe(struct kprobe *kp);
    int enable_kretprobe(struct kretprobe *rp);
    int enable_jprobe(struct jprobe *jp);
    ```

    注册的 `kprobe` 探针可以通过 `debugfs` 列出：

    ```
    $ cat /sys/kernel/debug/kprobes/list
    ```

    它们可以全局启用或禁用：

    ```
    $ echo 0/1 > /sys/kernel/debug/kprobes/enabled
    ```

## 如何操作...

在注册时，`kprobe` 探针会在被探测指令的起始位置放置一个断点（如果经过优化，则为跳转）指令。当断点被触发时，发生陷阱，寄存器被保存，控制权转交给 `kprobes`，并调用前处理程序。接着，它会单步执行断点，并调用后处理程序。如果发生故障，则会调用故障处理程序。如果需要，处理程序可以为 NULL。

`kprobe` 探针可以插入到函数符号或地址中，使用偏移字段，但不能同时插入两者。

### 注意

有时，`kprobe` 对于调试某些问题仍然过于干扰，因为它会减慢函数执行，可能影响调度，并且在中断上下文中调用时可能会引发问题。

例如，要在 `open` 系统调用中放置一个 `kprobe` 探针，我们可以使用 `meta-bsp-custom/recipes-kernel/open-kprobe/files/kprobe_open.c` 自定义模块：

```
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kprobes.h>

static struct kprobe kp = {
  .symbol_name  = "do_sys_open",
};

static int handler_pre(struct kprobe *p, struct pt_regs *regs)
{
  pr_info("pre_handler: p->addr = 0x%p, lr = 0x%lx,"
    " sp = 0x%lx\n",
  p->addr, regs->ARM_lr, regs->ARM_sp);

  /* A dump_stack() here will give a stack backtrace */
  return 0;
}

static void handler_post(struct kprobe *p, struct pt_regs *regs,
      unsigned long flags)
{
  pr_info("post_handler: p->addr = 0x%p, status = 0x%lx\n",
    p->addr, regs->ARM_cpsr);
}

static int handler_fault(struct kprobe *p, struct pt_regs *regs, int trapnr)
{
  pr_info("fault_handler: p->addr = 0x%p, trap #%dn",
    p->addr, trapnr);
  /* Return 0 because we don't handle the fault. */
  return 0;
}

static int kprobe_init(void)
{
  int ret;
  kp.pre_handler = handler_pre;
  kp.post_handler = handler_post;
  kp.fault_handler = handler_fault;

  ret = register_kprobe(&kp);
  if (ret < 0) {
    pr_err("register_kprobe failed, returned %d\n", ret);
    return ret;
  }
  pr_info("Planted kprobe at %p\n", kp.addr);
  return 0;
}

static void kprobe_exit(void)
{
  unregister_kprobe(&kp);
  pr_info("kprobe at %p unregistered\n", kp.addr);
}

module_init(kprobe_init)
module_exit(kprobe_exit)
MODULE_LICENSE("GPL");
```

我们通过 Yocto 配方编译它，正如 第二章 中 *构建外部内核模块* 配方所解释的那样，*BSP 层*。以下是 `meta-bsp-custom/recipes-kernel/open-kprobe/open-kprobe.bb` Yocto 配方文件的代码：

```
SUMMARY = "kprobe on do_sys_open kernel module."
LICENSE = "GPLv2"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/GPL- 2.0;md5=801f80980d171dd6425610833a22dbe6"

inherit module

PV = "0.1"

SRC_URI = " \
    file://kprobe_open.c \
    file://Makefile \
"

S = "${WORKDIR}"
```

`meta-bsp-custom/recipes-kernel/open-kprobe/files/Makefile` 文件内容如下：

```
obj-m  := kprobe_open.o

SRC := $(shell pwd)

all:
  $(MAKE) -C "$(KERNEL_SRC)" M="$(SRC)"

modules_install:
  $(MAKE) -C "$(KERNEL_SRC)" M="$(SRC)" modules_install

clean:
  rm -f *.o *~ core .depend .*.cmd *.ko *.mod.c
  rm -f Module.markers Module.symvers modules.order
  rm -rf .tmp_versions Modules.symvers
```

将其复制到运行相同内核的目标上，并使用以下命令加载：

```
$ insmod kprobe_open.ko
Planted kprobe at 8010da84

```

当打开文件时，我们现在可以看到处理程序在控制台中打印出来：

```
pre_handler: p->addr = 0x8010da84, lr = 0x8010dc34, sp = 0xdca75f98
post_handler: p->addr = 0x8010da84, status = 0x80070013

```

## 还有更多内容...

`jprobe` 探针是通过 `kprobe` 实现的。它会在给定的符号或地址处设置一个断点（但必须是函数的第一条指令），并复制一部分堆栈。当触发时，它会跳转到处理程序，使用与被探测函数相同的寄存器和堆栈。处理程序必须与被探测函数具有相同的参数列表和返回类型，并在返回之前调用 `jprobe_return()`，以将控制权传回 `kprobes`。然后恢复原始堆栈和 CPU 状态，并调用被探测的函数。

以下是 `meta-bsp-custom/recipes-kernel/open-jprobe/files/jprobe_open.c` 文件中 `open` 系统调用的 `jprobe` 示例：

```
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kprobes.h>
static long jdo_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
  pr_info("jprobe: dfd = 0x%x, filename = 0xs "
    "flags = 0x%x mode umode %x\n", dfd, filename, flags, mode);

  /* Always end with a call to jprobe_return(). */
  jprobe_return();
  return 0;
}

static struct jprobe my_jprobe = {
  .entry        = jdo_sys_open,
  .kp = {
    .symbol_name  = "do_sys_open",
  },
};

static int jprobe_init(void)
{
  int ret;

  ret = register_jprobe(&my_jprobe);
  if (ret < 0) {
    pr_err("register_jprobe failed, returned %d\n", ret);
    return -1;
  }
  pr_info("Planted jprobe at %p, handler addr %p\n",
        my_jprobe.kp.addr, my_jprobe.entry);
  return 0;
}

static void jprobe_exit(void)
{
  unregister_jprobe(&my_jprobe);
  pr_info("jprobe at %p unregistered\n", my_jprobe.kp.addr);
}

module_init(jprobe_init)
module_exit(jprobe_exit)
MODULE_LICENSE("GPL");
```

`kretprobe` 探针会在给定的符号或函数地址处设置一个 `kprobe`，当触发时，会用一个 trampoline（通常是一个 nop 指令）替换返回地址，`kprobe` 在此注册。当被探测函数返回时，trampoline 上的 `kprobe` 探针会被触发，调用返回处理程序，并在恢复执行之前设置回原始返回地址。

以下是 `meta-bsp-custom/recipes-kernel/open-kretprobe/files/kretprobe_open.c` 文件中 `open` 系统调用的 `kretprobe` 探针示例：

```
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kprobes.h>
#include <linux/ktime.h>
#include <linux/limits.h>
#include <linux/sched.h>

/* per-instance private data */
struct my_data {
  ktime_t entry_stamp;
};

static int entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
{
  struct my_data *data;

  if (!current->mm)
    return 1;  /* Skip kernel threads */

  data = (struct my_data *)ri->data;
  data->entry_stamp = ktime_get();
  return 0;
}

static int ret_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
{
  int retval = regs_return_value(regs);
  struct my_data *data = (struct my_data *)ri->data;
  s64 delta;
  ktime_t now;

  now = ktime_get();
  delta = ktime_to_ns(ktime_sub(now, data->entry_stamp));
  pr_info("returned %d and took %lld ns to execute\n",
        retval, (long long)delta);
  return 0;
}

static struct kretprobe my_kretprobe = {
  .handler    = ret_handler,
  .entry_handler    = entry_handler,
  .data_size    = sizeof(struct my_data),
  .maxactive    = 20,
};

static int kretprobe_init(void)
{
  int ret;

  my_kretprobe.kp.symbol_name = "do_sys_open";
  ret = register_kretprobe(&my_kretprobe);
  if (ret < 0) {
    pr_err("register_kretprobe failed, returned %d\n",
        ret);
    return -1;
}
  pr_info("Planted return probe at %s: %p\n",
  my_kretprobe.kp.symbol_name,            my_kretprobe.kp.addr);
  return 0;
}

static void kretprobe_exit(void)
{
  unregister_kretprobe(&my_kretprobe);
  pr_info("kretprobe at %p unregistered\n",
      my_kretprobe.kp.addr);

  /* nmissed > 0 suggests that maxactive was set too low. */
  pr_info("Missed probing %d instances of %s\n",
    my_kretprobe.nmissed, my_kretprobe.kp.symbol_name);
}

module_init(kretprobe_init)
module_exit(kretprobe_exit)
MODULE_LICENSE("GPL");
```

高亮显示的`maxactive`变量是`kretprobe`探针中用于返回地址的预留存储数量，默认情况下，它等于 CPU 的数量（或者在抢占系统中为 CPU 数量的两倍，最多为 10）。如果`maxactive`值过低，一些探针将会被漏掉。

完整的示例，包括 Yocto 食谱，可以在随书提供的源代码中找到。

## 另见

+   关于`kprobes`的文档可以在 Linux 内核的[`git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/kprobes.txt`](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/kprobes.txt)找到

# 使用动态内核事件

尽管动态追踪是一个非常有用的功能，但自定义内核模块并不是一个用户友好的接口。幸运的是，Linux 内核通过支持`kprobe`事件进行了扩展，允许我们使用`debugfs`接口设置`kprobes`探针。

## 准备就绪

要使用此功能，我们需要使用`CONFIG_KPROBE_EVENT`配置变量配置我们的内核。

## 如何操作...

`debugfs`接口通过`/sys/kernel/debug/tracing/kprobe_events`文件添加探针。例如，要将名为`example_probe`的`kprobe`添加到`do_sys_open`函数中，可以执行以下命令：

```
# echo 'p:example_probe do_sys_open dfd=%r0 filename=%r1 flags=%r2 mode=%r3' > /sys/kernel/debug/tracing/kprobe_events

```

探针将根据函数的声明参数列表，打印该函数的参数列表，如下所示：

```
long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode);

```

然后，您可以通过 sysfs 管理`kprobes`，具体如下：

+   查看所有已注册的探针：

    ```
    # cat /sys/kernel/debug/tracing/kprobe_events
    p:kprobes/example_probe do_sys_open dfd=%r0 filename=%r1 flags=%r2 mode=%r3

    ```

+   要打印探针格式：

    ```
    # cat /sys/kernel/debug/tracing/events/kprobes/example_probe/format
    name: example_probe
    ID: 1235
    format:
     field:unsigned short common_type;       offset:0;      size:2; signed:0;
     field:unsigned char common_flags;       offset:2;      size:1; signed:0;
     field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
     field:int common_pid;   offset:4;       size:4; signed:1;
     field:unsigned long __probe_ip; offset:8;       size:4; signed:0;
     field:u32 dfd;  offset:12;      size:4; signed:0;
     field:u32 filename;     offset:16;      size:4; signed:0;
     field:u32 flags;        offset:20;      size:4; signed:0;
     field:u32 mode; offset:24;      size:4; signed:0;
    print fmt: "(%lx) dfd=%lx filename=%lx flags=%lx mode=%lx", REC->__probe_ip, REC->dfd, REC->filename, REC->flags, REC- >mode

    ```

+   要启用探针，请使用以下命令：

    ```
    # echo 1 > /sys/kernel/debug/tracing/events/kprobes/example_probe/enable

    ```

+   要查看探针输出，请在`trace`或`trace_pipe`文件中查看：

    ```
    # cat /sys/kernel/debug/tracing/trace
    # tracer: nop
    #
    # entries-in-buffer/entries-written: 59/59   #P:4
    #
    #                              _-----=> irqs-off
    #                             / _----=> need-resched
    #                            | / _---=> hardirq/softirq
    #                            || / _--=> preempt-depth
    #                            ||| /     delay
    #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
    #              | |       |   ||||       |         |
     sh-737   [000] d...  1610.378856: example_probe: (do_sys_open+0x0/0x184) dfd=ffffff9c filename=f88488 flags=20241 mode=16
     sh-737   [000] d...  1660.888921: example_probe: (do_sys_open+0x0/0x184) dfd=ffffff9c filename=f88a88 flags=20241 mode=16

    ```

+   清除探针（在禁用后）：

    ```
    # echo '-:example_probe' >> /sys/kernel/debug/tracing/kprobe_events

    ```

+   清除所有探针：

    ```
    # echo > /sys/kernel/debug/tracing/kprobe_events

    ```

+   检查命中和漏掉事件的数量：

    ```
    # cat /sys/kernel/debug/tracing/kprobe_profile
    example_probe                             78               0

    ```

    格式如下：

    ```
    <event name> <hits> <miss-hits>

    ```

## 它是如何工作的...

要设置探针，我们使用以下语法：

```
<type>:<event name> <symbol> <fetch arguments>

```

让我们解释一下提到的每个参数：

+   `type`：这可以是`p`表示`kprobe`，或者`r`表示返回探针。

+   `event name`：这是可选的，格式为`<group/event>`。如果省略了组名，默认使用`kprobes`，如果省略了事件名，则根据符号自动生成事件名。给定事件名时，它将在`/sys/kernel/debug/tracing/events/kprobes/`下创建一个目录，内容如下：

    +   `id`：这是探针事件的 ID

    +   `filter`：这指定了用户的过滤规则

    +   `format`：这是探针事件的格式

    +   `enabled`：用于启用或禁用探针事件

+   `symbol`：这是符号名称，后跟一个可选的偏移量，或者是要插入探针的内存地址。

+   `fetch arguments`：这些是可选的，表示要提取的信息，最多可提取 128 个参数。它们具有以下格式：

    ```
    <name>=<offset>(<argument>):<type>

    ```

    让我们解释一下提到的每个参数：

    +   `name`：这设置了参数名称

    +   `offset`：这会向地址参数添加一个偏移量

    +   `argument`：这可以是以下格式：

        `%<register>`：这会获取指定的寄存器。对于 ARM 来说，这些是：

        `r0 to r10`

        `fp`

        `ip`

        `sp`

        `lr`

        `pc`

        `cpsr`

        `ORIG_r0`

    `@<address>`：这会获取指定内核地址的内存

    `@<symbol><offset>`：这会获取指定符号和可选偏移量的内存

    `$stack`：这会获取栈地址

    `$stack<N>`：这会获取栈中的第*n*个条目

    对于返回探针，我们有：

    `$retval`：这会获取返回值

    +   `type`：此选项设置`kprobe`用于访问内存的参数类型，以下是可用选项：

        u8, u16, u32, u64，适用于无符号类型

        s8, s16, s32, s64，适用于有符号类型

        string，适用于以空字符结尾的字符串

        位域，格式如下：

        ```
        b<bit-width>@<bit-offset>/<container-size>
        ```

## 还有更多...

当前版本的 Linux 内核（从 v3.14 开始）也支持用户空间探针事件（uprobes），其接口与`kprobes`事件相似。

# 探索 Yocto 的跟踪和性能分析工具

跟踪和性能分析工具用于提高应用程序和系统的性能、效率和质量。用户空间的跟踪和性能分析工具利用 Linux 内核提供的性能计数器以及静态和动态跟踪功能，正如我们在前面的示例中看到的那样。

## 正在准备

跟踪使我们能够记录应用程序的活动，以便分析、优化和修正其行为。

Yocto 提供了包括以下几种跟踪工具：

+   **trace-cmd**：这是`ftrace`内核子系统的命令行接口，以及**kernelshark**，一个图形化界面，用于与 trace-cmd 配合使用。

+   **perf**：这是一个起源于 Linux 内核的工具，它提供了命令行接口，用于性能计数器事件子系统。此后，它已扩展并添加了其他几种跟踪机制。

+   **blktrace**：这是一个提供块层输入/输出信息的工具。

+   **Linux Trace Toolkit Next Generation** (**LTTng**)：这是一个工具，用于对 Linux 内核、应用程序和库进行相关联的跟踪。Yocto 还包括**babeltrace**，一个将跟踪数据转换为人类可读日志的工具。

+   **SystemTap**：这是一个用于动态插桩 Linux 内核的工具。

性能分析是指一组技术，用于衡量应用程序消耗的资源和执行应用程序所需的时间。然后，这些数据被用来改善应用程序的性能并进行优化。一些前面提到的工具，如 perf 和 SystemTap，已经发展成为强大的跟踪和性能分析工具。

除了已列出的跟踪工具外，它们也可以用于性能分析，Yocto 还提供了其他几种性能分析工具：

+   **OProfile**：这是一个 Linux 的统计性能分析工具，它以低开销分析所有正在运行的代码。

+   **Powertop**：这是一个用于分析系统功耗和电源管理的工具。

+   **Latencytop**：这是一个用于分析系统延迟的工具。

+   **Sysprof**：该工具为 X11 图形镜像中的 Intel 架构提供，不能在 ARM 架构上使用。

## 如何操作...

这些工具可以单独添加到目标镜像中，或者通过`tools-profile`功能进行添加。为了使用这些工具，我们还需要在应用程序中包含调试信息。为此，我们应使用包的`-dbg`版本，或者更好地配置 Yocto，使得通过`dbg-pkgs`镜像功能生成调试信息。要将这两个功能添加到镜像中，请将以下内容添加到项目的`conf/local.conf`文件中：

```
EXTRA_IMAGE_FEATURES = "tools-profile dbg-pkgs"
```

目标镜像的`-sdk`版本已经添加了这些功能。

## 还有更多...

除了这些工具，Yocto 还提供了在 Linux 系统上可用的标准监控工具。一些示例如下：

+   **htop**：这个工具包含在`meta-oe`层中，提供进程监控功能。

+   **iotop**：这个工具也包含在`meta-oe`层中，它提供按进程分类的块设备 I/O 统计信息。

+   **procps**：这个工具包在 Poky 中可用，包含以下工具：

    +   **ps**：这个工具用于列出并提供进程状态信息。

    +   **vmstat**：用于虚拟内存统计。

    +   **uptime**：用于负载平均值监控。

    +   **free**：用于监视内存使用情况。记得考虑内核缓存。

    +   **slabtop**：该工具提供内核 slab 分配器的内存使用统计信息。

+   **sysstat**：这个工具包在 Poky 中可用，包含以下工具：

    +   **pidstat**：另一个用于进程统计信息的工具。

    +   **iostat**：提供块 I/O 统计信息。

    +   **mpstat**：该工具提供多处理器统计信息。

Yocto 还提供以下网络工具：

+   **tcpdump**：这个网络工具包含在`meta-networking`层的`meta-openembedded`中。它用于捕获和分析网络流量。

+   **netstat**：这是 Poky 中`net-tools`包的一部分。它提供网络协议统计信息。

+   **ss**：这个工具包含在 Poky 的`iproute2`包中。它提供套接字统计信息。

# 使用 perf 进行跟踪和分析

perf Linux 工具可以使用硬件和软件性能计数器事件，以及静态和动态内核跟踪点来对 Linux 内核进行仪器化。为此，它使用我们在前面的食谱中看到的内核功能，提供一个通用接口来管理它们。

该工具可用于调试、故障排除、优化和衡量应用程序、工作负载或整个系统，涵盖处理器、内核和应用程序。perf 可能是可用于 Linux 系统的最完整的跟踪和分析工具。

## 准备工作

perf 源代码是 Linux 内核的一部分。要在系统中包含 perf，请将以下内容添加到`conf/local.conf`文件中：

```
IMAGE_INSTALL_append = " perf"
```

perf 也是`tools-profile`镜像功能的一部分，因此你也可以通过以下方式添加它：

```
EXTRA_IMAGE_FEATURES += "tools-profile"
```

perf 也包含在`-sdk`镜像中。

为了最大化利用此工具，我们需要在用户空间应用程序、库以及 Linux 内核中都有符号。为此，我们需要避免剥离二进制文件，方法是在 `conf/local.conf` 配置文件中添加以下内容：

```
INHIBIT_PACKAGE_STRIP = "1"
```

另外，建议通过添加以下内容来增加应用程序的调试信息：

```
EXTRA_IMAGE_FEATURES += "dbg-pkgs"
```

默认情况下，调试信息会放在与其对应的二进制文件相同位置的 `.debug` 目录中。但是 perf 需要一个中央位置来查找所有调试信息。因此，为了使用 perf 理解的结构配置调试信息，我们还需要在 `conf/local.conf` 配置文件中添加以下内容：

```
PACKAGE_DEBUG_SPLIT_STYLE = 'debug-file-directory'
```

最后，使用 `CONFIG_DEBUG_INFO` 配置变量配置 Linux 内核以包含调试信息，使用 `CONFIG_KALLSYMS` 将调试符号添加到内核中，使用 `CONFIG_FRAME_POINTER` 以便能够看到完整的堆栈跟踪。

### 注意

正如我们在 *使用内核性能计数器* 章节中看到的，我们还需要将 `maxcpus=1`（或 `maxcpus=0` 禁用 SMP）传递给 Linux 内核，以便使用 i.MX6 PMU，因为 PMU 中断在所有核心之间共享。此外，为了在 i.MX6 处理器上使用 PMU，SoC 在上电复位后需要至少 4 个 JTAG 时钟周期。这在 *ERR006259* 错误报告中有文档说明。

在撰写本文时，Yocto 1.7 的 `meta-fsl-arm` 层禁用了部分 perf 功能。为了能够跟随接下来的示例，请从 `meta-fsl-arm` 层的 `/opt/yocto/fsl-community-bsp/sources/meta-fsl-arm/conf/machine/include/imx-base.inc` 文件中删除以下行：

```
-PERF_FEATURES_ENABLE = ""
```

更新的 Yocto 版本默认会包括此功能。

## 如何操作...

Perf 可以用于提供特定工作负载的默认事件统计信息：

```
# perf stat <command>

```

例如，单次 ping 会提供以下输出：

```
# perf stat ping -c 1 192.168.1.1
PING 192.168.1.1 (192.168.1.1): 56 data bytes
64 bytes from 192.168.1.1: seq=0 ttl=64 time=6.489 ms

--- 192.168.1.1 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 6.489/6.489/6.489 ms

 Performance counter stats for 'ping -c 1 192.168.1.1':

 8.984333 task-clock                #    0.360 CPUs utilized
 15 context-switches          #    0.002 M/sec
 0 cpu-migrations            #    0.000 K/sec
 140 page-faults               #    0.016 M/sec
 3433188 cycles                    #    0.382 GHz
 123948 stalled-cycles-frontend   #    3.61% frontend cycles idle 
 418329 stalled-cycles-backend    #   12.18% backend  cycles idle 
 234497 instructions              #    0.07  insns per cycle 
 #    1.78  stalled cycles per insn
 22649 branches                  #    2.521 M/sec
 8123 branch-misses             #   35.86% of all branches 

 0.024962333 seconds time elapsed

```

如果我们只对特定的一组事件感兴趣，可以使用 `-e` 选项指定我们想要输出信息的事件。

我们还可以采样数据并存储，以便后续分析：

```
# perf record <command>

```

更好的是，我们可以使用 `-g` 选项添加堆栈回溯：

```
# perf record -g -- ping -c 1 192.168.1.1

```

结果将存储在 `perf.data` 文件中，我们接着可以用以下命令分析：

```
# perf report

```

其输出可以在以下屏幕截图中看到：

![如何操作...](img/5186OS_05_01.jpg)

函数的顺序可以通过 `--sort` 选项自定义。

我们可以看到 perf 如何解析用户空间和内核符号。Perf 会从 `/boot` 目录下的 Linux 内核 ELF 文件读取内核符号。如果它存储在非标准位置，我们可以选择通过 `-k` 选项传递其位置。如果未找到，它将回退到使用 `/proc/kallsyms`，这是 Linux 内核在启用 `CONFIG_KALLSYMS` 配置变量时将内核符号导出到用户空间的地方。

### 注意

如果 perf 报告中没有显示内核符号，可能是因为 ELF 文件与正在运行的内核不匹配。你可以尝试重命名它，看看使用 `/proc/kallsyms` 是否有效。

此外，为了获取完整的回溯信息，应用程序需要通过使用`DEBUG_BUILD`配置变量进行调试优化编译，正如我们在本章之前所看到的那样。

默认情况下，Perf 使用 **newt** 界面（TUI），它需要 `expand` 工具，这是 coreutils 的一部分。如果你的根文件系统中没有包含 coreutils，你可以请求仅文本输出，如下所示：

```
# perf report –stdio

```

执行上述命令后，我们得到以下输出：

![如何操作...](img/5186OS_05_03.jpg)

我们可以通过以下列显示所有调用的函数：

+   **开销**：表示与该函数相关的采样数据的百分比。

+   **命令**：指传递给 perf record 的命令名称。

+   **共享对象**：表示 ELF 图像名称（内核会显示 `kernel.kallsyms`）。

+   **特权级别**：它有以下几种模式：

    +   表示用户模式

    +   `k` 表示内核模式

    +   `g` 表示虚拟化来宾内核

    +   `u` 表示虚拟化主机用户空间

    +   `H` 表示虚拟机监控器

+   **符号**：这是解析后的符号名称。

在 TUI 界面中，我们可以按下回车键选择一个函数名称进入子菜单，系统会给出如下输出：

![如何操作...](img/5186OS_05_04.jpg)

通过这点，我们可以，例如，如下截图所示注释代码：

![如何操作...](img/5186OS_05_05.jpg)

如果使用文本模式，我们还可以通过以下命令获得带注释的输出：

```
# perf annotate -d <command>

```

Perf 还可以进行系统范围的分析，而不仅仅关注特定的工作负载。例如，要监控系统五秒钟，我们可以执行以下命令：

```
# perf stat -a sleep 5
Performance counter stats for 'sleep 5':
 5006.660002 task-clock                #    1.000 CPUs utilized[100.00%]
 324 context-switches          #    0.065 K/sec [100.00%]
 0 cpu-migrations            #    0.000 K/sec [100.00%]
 126 page-faults               #    0.025 K/sec
 12200175 cycles                    #    0.002 GHz [100.00%]
 2844703 stalled-cycles-frontend   #   23.32% frontend cycles idle    [100.00%]
 9152564 stalled-cycles-backend    #   75.02% backend  cycles idle    [100.00%]
 4645466 instructions              #    0.38  insns per cycle 
 #    1.97  stalled cycles per insn [100.00%]
 479051 branches                  #    0.096 M/sec [100.00%]
 222903 branch-misses             #   46.53% of all branches 

 5.006115001 seconds time elapsed

```

或者，要采样系统五秒钟，我们可以执行以下命令：

```
# perf record -a -g -- sleep 5

```

使用系统范围测量时，命令仅作为测量时长。为此，`sleep` 命令不会消耗额外的周期。

## 它是如何工作的...

Perf 工具提供了系统中用户和内核事件的统计信息。它可以在两种模式下进行仪器化：

+   **事件计数**（`perf stat`）：在内核上下文中计数事件并在结束时打印统计信息。它的开销最小。

+   **事件采样**（`perf record`）：此命令将在给定的采样周期内将收集到的数据写入文件。然后可以将数据读取为分析数据（`perf report`）或跟踪数据（`perf script`）。将数据收集到文件可能会消耗较多资源，并且文件大小会迅速增长。

默认情况下，perf 会统计给定命令中所有线程的事件，包括子进程，直到命令执行完成或被中断。

运行 perf 的通用方式如下：

```
perf stat|record [-e <comma separated event list> --filter '<expr>'] [-o <filename>] [--] <command> [<arguments>]

```

让我们详细解释前面的代码：

+   `e`：指定要使用的事件列表，而不是默认的事件集合。也可以指定事件过滤器，其语法可在 Linux 内核源代码文档中的 `Documentation/trace/events.txt` 找到。

+   `o`：指定输出文件名，默认是`perf.data`。

+   `--`：当命令需要参数时，用作分隔符。

它还可以通过传递`-p <pid>`选项来启动或采样正在运行的进程。

我们可以通过执行以下命令来获取所有可用事件的列表：

```
# perf list

```

或使用以下命令在特定子系统上运行：

```
# perf list '<subsystem>:*'

```

你还可以通过使用`r<event>`事件直接访问原始 PMU 事件，例如，要读取 ARM 核心上的数据缓存未命中的情况：

```
# perf stat -e r3 sleep 5

```

除非另有指定，否则 perf record 会以平均 1000 Hz 的频率采样硬件事件，但可以通过`-F <freq>`参数修改采样频率。每次发生时，跟踪点都会被计数。

### 阅读跟踪数据

Perf 记录采样并将跟踪数据存储到文件中。原始时间戳跟踪数据可以通过以下命令查看：

```
# perf script

```

执行命令后，我们得到以下输出：

![阅读跟踪数据](img/5186OS_05_06.jpg)

正如我们所看到的，我们可以使用 perf 报告查看格式化的采样数据进行剖析分析，但我们也可以生成 python 脚本，然后修改它们以更改数据的展示方式，方法是运行以下代码行：

```
# perf script -g python

```

这将生成一个`perf-script.py`脚本，内容如下：

![阅读跟踪数据](img/5186OS_05_07.jpg)

要运行脚本，请使用以下命令：

```
# perf script -s perf-script.py

```

你需要在目标镜像中安装`perf-python`包。你可以通过以下命令将其添加到镜像中：

```
IMAGE_INSTALL_append = " perf-python"
```

现在你将得到类似于之前`perf`脚本的输出。但现在你可以修改 python 代码中的打印语句，以后处理采样数据，满足你的特定需求。

## 还有更多...

Perf 可以使用动态事件扩展事件列表，将其添加到任何可以放置`kprobe`的位置。为此，需要配置内核以支持`kprobe`和`uprobe`（如果可用），如前面*使用动态内核事件*一节所示。

要在特定函数中添加探测点，执行以下命令：

```
# perf probe --add "tcp_sendmsg"
Added new event:
 probe:tcp_sendmsg    (on tcp_sendmsg)

```

现在你可以在所有 perf 工具中使用它，比如剖析文件下载：

```
# perf record -e probe:tcp_sendmsg -a -g -- wget http://downloads.yoctoproject.org/releases/yocto/yocto- 1.7.1/RELEASENOTES
Connecting to downloads.yoctoproject.org (198.145.29.10:80)
RELEASENOTES         100% |**************************************************************************************| 11924   0:00:00 ETA
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.025 MB perf.data (~1074 samples) ]

```

然后，你可以执行以下命令查看剖析数据：

```
# perf report

```

然后你会得到以下输出：

![还有更多...](img/5186OS_05_08.jpg)

### 注意

你可能需要在目标系统中配置 DNS 服务器，以便`wget`命令正常工作，如前面的代码所示。要使用 Google 的公共 DNS 服务器，你可以将以下内容添加到`/etc/resolv.conf`文件中：

```
nameserver 8.8.8.8
nameserver 8.8.4.4

```

然后你可以通过以下命令删除探测：

```
# perf probe --del tcp_sendmsg
/sys/kernel/debug//tracing/uprobe_events file does not exist - please rebuild kernel with CONFIG_UPROBE_EVENT.
Removed event: probe:tcp_sendmsg

```

### 剖析图表

可以使用 perf 时间图可视化系统行为。要收集数据，请运行：

```
# perf timechart record -- <command> <arguments>

```

并使用以下命令将其转换为`svg`文件：

```
# perf timechart

```

### 使用 perf 作为 strace 替代品

Perf 可以作为 strace 的替代品，但具有更小的开销，使用以下语法：

```
# perf trace record <command>

```

然而，Yocto 中 perf 的食谱目前并没有构建此支持。我们可以在编译日志中看到缺失的库：

```
Makefile:681: No libaudit.h found, disables 'trace' tool, please install audit-libs-devel or libaudit-dev

```

## 另见

+   可用的 ARM i.MX6 PMU 事件列表，见[`infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0388f/BEHGGDJC.html`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0388f/BEHGGDJC.html)

+   在[`perf.wiki.kernel.org/index.php/Tutorial`](https://perf.wiki.kernel.org/index.php/Tutorial)上有一篇关于 perf 使用的扩展教程

+   Brendan Gregg 的 perf 站点上的一些高级示例[`www.brendangregg.com/perf.html`](http://www.brendangregg.com/perf.html)

# 使用 SystemTap

SystemTap 是一个 GPLv2 许可证的系统级工具，它允许您从正在运行的 Linux 系统收集跟踪和分析数据。用户编写`systemtap`脚本，然后将其编译为一个 Linux 内核模块，该模块与它将要运行的内核源代码链接。

脚本设置事件和处理程序，当指定的事件触发时，内核模块会调用这些处理程序。为此，它使用内核中的`kprobes`和`uprobes`（如果可用）接口，正如我们在*使用动态内核事件*配方中看到的那样。

## 准备就绪

要使用 SystemTap，我们需要通过特定添加它到目标镜像中，例如：

```
IMAGE_INSTALL_append = " systemtap"
```

我们还可以通过使用`tools-profile`镜像功能或`-sdk`镜像来添加它。

我们还需要在目标上运行一个 SSH 服务器。`-sdk`镜像中已经包含了这个功能；如果没有，我们可以通过以下方式将其添加到我们的镜像中：

```
EXTRA_IMAGE_FEATURES += "ssh-server-openssh"
```

我们还需要通过配置`CONFIG_DEBUG_INFO`变量来编译内核，以包含调试信息、性能事件计数器和`kprobes`，如前面配方中所述。

## 如何操作...

要在 Yocto 系统上使用 systemtap，我们需要在主机上运行 crosstap 工具，传递给它要运行的`systemtap`脚本。例如，要运行`sys_open.stp`示例脚本，我们可以运行以下代码：

```
probe begin
{
        print("Monitoring starts\n")
        printf("%6s %6s %16s\n", "UID", "PID", "NAME");
}

probe kernel.function("sys_open")
{
          printf("%6d %6d %16s\n", uid(), pid(), execname());
}

probe timer.s(60)
{
        print("Monitoring ends\n")
        exit()
}
```

我们将运行以下命令：

```
$ source setup-environment wandboard-quad
$ crosstap root@<target_ip> sys_open.stp

```

Yocto 不支持在目标上运行脚本，因为这需要在目标上构建模块，而这是未经测试的。

## 它是如何工作的...

SystemTap 脚本使用其自己的类似 C/awk 的语言编写。它们使我们能够通过在不同位置对内核代码进行插桩，来跟踪事件，例如：

+   系统 Tap 会话的开始和结束

+   内核和用户空间函数的入口、返回或特定偏移

+   定时器事件

+   性能硬件计数事件

它们还使我们能够提取数据，例如：

+   线程、进程或用户 ID

+   当前 CPU

+   进程名称

+   时间

+   局部变量

+   内核和用户空间回溯

此外，SystemTap 还提供了分析收集到的数据的能力，并且不同的探针可以协同工作。SystemTap 包括大量示例脚本，并提供一个框架来创建可以共享的脚本库。这些 tapsets 是默认安装的，并可以通过用户自己的脚本扩展。当脚本中未定义某个符号时，SystemTap 将搜索 tapset 库以查找该符号。

## 另见

+   Tapset 参考：[`sourceware.org/systemtap/tapsets/`](https://sourceware.org/systemtap/tapsets/)

+   所有示例都包含在[`sourceware.org/systemtap/examples/`](https://sourceware.org/systemtap/examples/)源代码中。

+   参考 SystemTap 脚本语言文档：[`sourceware.org/systemtap/langref/`](https://sourceware.org/systemtap/langref/)

# 使用 OProfile

OProfile 是一个统计分析工具，采用 GNU GPL 许可证发布。Yocto 1.7 版本中包含的版本是一个系统范围的分析器，它使用传统的分析模式，通过内核模块采样硬件性能计数器数据，并通过用户空间守护进程将其写入文件。更新的 Yocto 版本使用性能事件子系统，我们在*使用内核的性能计数器*食谱中介绍过，因此它们可以分析进程和工作负载。

Yocto 1.7 中包含的版本由一个内核模块、一个用于收集样本数据的用户空间守护进程和几个用于分析捕获数据的分析工具组成。

本食谱将重点介绍在 1.7 版本 Yocto 中包含的 OProfile 版本。

## 准备工作

要将 OProfile 包含到您的系统中，请将以下内容添加到`conf/local.conf`文件中：

```
 IMAGE_INSTALL_append += " oprofile"
```

OProfile 也是`tools-profile`镜像功能的一部分，因此您也可以通过以下方式添加它：

```
EXTRA_IMAGE_FEATURES += "tools-profile"
```

OProfile 也包含在`-sdk`镜像中。

除非需要注释结果，否则 OProfile 不需要应用程序中的调试符号。对于调用图分析，二进制文件必须包含堆栈帧信息，因此应该通过在`conf/local.conf`文件中设置`DEBUG_BUILD`变量来使用调试优化构建：

```
DEBUG_BUILD = "1"
```

要构建内核驱动程序，请配置 Linux 内核以支持分析，设置`CONFIG_PROFILING`，并将`CONFIG_OPROFILE`配置变量设置为构建 OProfile 模块。

OProfile 使用 SoC 中的硬件计数器支持，但它也可以在基于定时器的模式下工作。要使用定时器模式，您需要将`oprofile.timer=1`内核参数传递给 Linux 内核，或者使用以下命令加载 OProfile 模块：

```
# modprobe oprofile timer=1

```

### 注意

由于 OProfile 依赖于 i.MX6 性能计数器，我们仍然需要以`maxcpus=1`启动才能正常工作。这限制了 i.MX6 SoC 中的分析只能在一个核心上进行。

## 如何操作...

要分析单个 ping，请按以下步骤启动分析会话：

```
# opcontrol --start --vmlinux=/boot/vmlinux --callgraph 5
Using 2.6+ OProfile kernel interface.
Reading module info.
Using log file /var/lib/oprofile/samples/oprofiled.log
Daemon started.
Profiler running.

```

然后运行需要分析的工作负载，例如，一个简单的 ping：

```
# ping -c 1 192.168.1.1
PING 192.168.1.1 (192.168.1.1): 56 data bytes
64 bytes from 192.168.1.1: seq=0 ttl=64 time=5.421 ms

--- 192.168.1.1 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 5.421/5.421/5.421 ms

```

停止数据收集的命令如下：

```
 # opcontrol --stop

```

### 提示

如果内核镜像名称包含特殊字符，我们会遇到解析错误。为了避免这种情况，我们可以使用符号链接，如下所示：

```
# ln -s /boot/vmlinux-3.10.17-1.0.2- wandboard+gbe8d6872b5eb /boot/vmlinux

```

另外，如果您看到以下错误：

```
Count 100000 for event CPU_CYCLES is below the minimum 1500000

```

您需要将`CPU_CYCLES`事件的重置计数更改为该最小值，命令如下：

```
# opcontrol --setup --event=CPU_CYCLES:1500000

```

然后可以使用以下命令查看收集到的数据：

```
# opreport -f
Using /var/lib/oprofile/samples/ for samples directory.
CPU: ARM Cortex-A9, speed 996000 MHz (estimated)
Counted CPU_CYCLES events (CPU cycle) with a unit mask of 0x00 (No unit mask) count 1500000
CPU_CYCLES:150...|
 samples|      %|
------------------
 401 83.0228 /boot/vmlinux-3.10.17-1.0.2-wandboard+gbe8d6872b5eb
 31  6.4182 /bin/bash
 28  5.7971 /lib/libc-2.20.so
 18  3.7267 /lib/ld-2.20.so
 3  0.6211 /usr/bin/oprofiled
 1  0.2070 /usr/bin/ophelp
 1  0.2070 /usr/sbin/sshd

```

以下是带有调用图和符号的输出摘录：

```
# opreport -cl
Using /var/lib/oprofile/samples/ for samples directory.
warning: [heap] (tgid:790 range:0x3db000-0x4bc000) could not be found.
warning: [stack] (tgid:785 range:0x7ee11000-0x7ee32000) could not be found.
CPU: ARM Cortex-A9, speed 996000 MHz (estimated)
Counted CPU_CYCLES events (CPU cycle) with a unit mask of 0x00 (No unit mask) count 1500000
samples  %        app name                 symbol name
-------------------------------------------------------------------------------
 102      48.8038  vmlinux-3.10.17-1.0.2-wandboard+gbe8d6872b5eb __do_softirq
 107      51.1962  vmlinux-3.10.17-1.0.2-wandboard+gbe8d6872b5eb do_softirq
102      21.1180  vmlinux-3.10.17-1.0.2-wandboard+gbe8d6872b5eb __do_softirq
 102      47.4419  vmlinux-3.10.17-1.0.2-wandboard+gbe8d6872b5eb __do_softirq
 102      47.4419  vmlinux-3.10.17-1.0.2-wandboard+gbe8d6872b5eb __do_softirq [self]
 7         3.2558  vmlinux-3.10.17-1.0.2-wandboard+gbe8d6872b5eb net_rx_action
 4         1.8605  vmlinux-3.10.17-1.0.2-wandboard+gbe8d6872b5eb run_timer_softirq
--------------------------------------------------------------------- ----------
31        6.4182  bash                     /bin/bash

```

## 它是如何工作的...

OProfile 守护进程会持续记录数据，累积来自多个运行的数据。使用`--start`和`--stop`选项来开始和停止新数据的累积。如果您希望从零开始收集数据，请首先使用`--reset`选项。

在运行性能分析会话之前，您需要配置 OProfile 守护进程以启用或禁用内核分析。指定内核分析选项是唯一的强制配置变量。

为了配置 OProfile 守护进程，首先停止它（如果正在运行），使用`--shutdown`选项。`--stop`选项只会停止数据收集，但不会终止守护进程。

要配置没有内核分析的 OProfile，您可以执行以下命令：

```
opcontrol --no-vmlinux <options>
```

要配置内核分析，您可以运行以下命令：

```
opcontrol --vmlinux=/boot/path/to/vmlinux <options>
```

这两者都将配置守护进程并加载 OProfile 内核模块（如果需要）。一些常用选项包括：

+   `--separate=<type>`: 这控制如何将分析数据分隔成不同的文件，类型包括：

    +   **none**: 这不会分隔配置文件。

    +   **library**: 这将按应用程序分隔共享库配置文件。示例文件名将包括库的名称和可执行文件。

    +   **kernel**: 这会添加内核分析。

    +   **thread**: 这会添加每个线程的分析配置。

    +   **cpu**: 这会添加每个 CPU 的分析配置。

    +   **all**: 这将执行上述所有操作。

+   `--callgraph=<depth>`: 这将记录被调用函数和调用函数以及函数中的花费时间。

一旦守护进程配置完成，您可以开始性能分析会话。

要检查当前配置，您可以执行：

```
# opcontrol --status
Daemon not running
Session-dir: /var/lib/oprofile
Separate options: library kernel
vmlinux file: /boot/vmlinux
Image filter: none
Call-graph depth: 5

```

采样的数据存储在 `/var/lib/oprofile/samples/` 目录中。

然后，我们可以使用以下命令分析收集到的数据：

```
opreport <options>
```

一些有用的选项包括：

+   `-c`: 如果可用，这将显示调用图信息。

+   `-g`: 这将显示每个符号的源文件和行号。

+   `-f`: 这将显示完整的对象路径。

+   `-o`: 这将把输出提供到指定文件，而不是 `stdout`。

OProfile 在 `/dev/oprofile` 挂载一个伪文件系统，用于报告和接收来自用户空间的配置。它还包含一个字符设备节点，用于将内核模块中的采样数据传递给用户空间守护进程。

## 还有更多内容...

Yocto 包括一个可以在主机上运行的 OProfile 图形用户界面。然而，它不是 Poky 的一部分，需要单独下载和安装。

请参阅`oprofileui`库：[`git.yoctoproject.org/cgit/cgit.cgi/oprofileui/`](https://git.yoctoproject.org/cgit/cgit.cgi/oprofileui/) 以获取包含说明的 README，或者参阅*Yocto 项目的性能分析和跟踪手册*：[`www.yoctoproject.org/docs/1.7.1/profile-manual/profile-manual.html`](http://www.yoctoproject.org/docs/1.7.1/profile-manual/profile-manual.html)。

## 另请参见

+   该项目的主页，了解有关 OProfile 的更多信息：[`oprofile.sourceforge.net/news/`](http://oprofile.sourceforge.net/news/)

# 使用 LTTng

LTTng 是一组双许可（GPLv2 和 LGPL）的跟踪和性能分析工具，适用于应用程序和内核。它生成生产优化的**紧凑跟踪格式（CTF）**的二进制跟踪文件，可以通过诸如**babeltrace**等工具进行分析。

## 准备工作

要在系统中包含不同的 LTTng 工具，请将以下内容添加到您的 `conf/local.conf` 文件中：

```
IMAGE_INSTALL_append = " lttng-tools lttng-modules lttng-ust"
```

它们还包含在 `tools-profile` 图像功能中，因此您也可以使用以下方法添加它们：

```
EXTRA_IMAGE_FEATURES += "tools-profile"
```

这些也包含在 `-sdk` 镜像中。

### 提示

在撰写本文时，Yocto 1.7 将 `lttng-modules` 从 ARM 的 `tools-profile` 功能和 `sdk` 镜像中排除，因此必须手动添加。

LTTng 命令行工具是 LTTng 的主要用户界面。它可以用于跟踪 Linux 内核（使用我们在前面示例中看到的内核跟踪接口），以及带有仪表的用户空间应用程序。

## 如何执行...

内核性能分析会话工作流程如下：

1.  使用以下命令创建性能分析会话：

    ```
    # lttng create test-session
    Session test-session created.
    Traces will be written in /home/root/lttng-traces/test- session-20150117-174945

    ```

1.  使用以下命令启用您要跟踪的事件：

    ```
    # lttng enable-event --kernel sched_switch,sched_process_fork
    Warning: No tracing group detected
    Kernel event sched_switch created in channel channel0
    Kernel event sched_process_fork created in channel channel0

    ```

    您可以使用以下命令获取可用的内核事件列表：

    ```
    # lttng list --kernel

    ```

    这对应于 Linux 内核中可用的静态跟踪点事件。

1.  现在，您已准备好开始采样性能数据：

    ```
    # lttng start
    Tracing started for session test-session

    ```

1.  运行要进行性能分析的工作负载：

    ```
    # ping -c 1 192.168.1.1

    ```

1.  当命令执行完成或中断时，停止收集性能数据：

    ```
    # lttng stop
    Waiting for data availability.
    Tracing stopped for session test-session

    ```

1.  最后，使用以下命令销毁性能分析会话。请注意，这将保留跟踪数据，只销毁会话。

    ```
    # lttng destroy
    Session test-session destroyed

    ```

1.  要使跟踪数据可供人类阅读，请使用以下命令启动 `babeltrace`：

    ```
    # babeltrace /home/root/lttng-traces/test-session-20150117- 174945

    ```

也可以将性能分析数据复制到主机以进行分析。

用户空间应用程序和库需要被仪表化，以便进行性能分析。这是通过将它们与 `liblttng-ust` 库进行链接来完成的。

应用程序可以利用 `tracef` 函数调用来输出跟踪信息，其格式与 `printf()` 相同。例如，要为我们在前几章中看到的示例 `helloworld.c` 应用程序进行仪表化，修改 `meta-custom/recipes-example/helloworld/helloworld-1.0/helloworld.c` 源码如下：

```
#include <stdio.h>
#include <lttng/tracef.h>

main(void)
{
    printf("Hello World");
    tracef("I said: %s", "Hello World");
}
```

在 `meta-custom/recipes-example/helloworld/helloworld_1.0.bb` 中修改其 Yocto 配方如下：

```
DESCRIPTION = "Simple helloworld application"
SECTION = "examples"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4 f302"

SRC_URI = "file://helloworld.c"
DEPENDS = "lttng-ust"

S = "${WORKDIR}"

do_compile() {
             ${CC} helloworld.c -llttng-ust -o helloworld
}

do_install() {
             install -d ${D}${bindir}
             install -m 0755 helloworld ${D}${bindir}
}
```

然后构建软件包，将其复制到目标，然后按以下方式开始性能分析会话：

1.  通过执行以下命令创建性能分析会话：

    ```
    # lttng create test-user-session
    Session test-user-session created.
    Traces will be written in /home/root/lttng-traces/test-user- session-20150117-185731

    ```

1.  启用您要进行性能分析的事件——在本例中，所有用户空间事件：

    ```
    # lttng enable-event -u -a
    Warning: No tracing group detected
    All UST events are enabled in channel channel0

    ```

1.  开始收集性能数据：

    ```
    # lttng start
    Tracing started for session test-user-session

    ```

1.  运行工作负载——在本例中，是经过仪表化的 hello world 示例程序：

    ```
    # helloworld
    Hello World

    ```

1.  一旦完成，停止收集数据：

    ```
    # lttng stop
    Waiting for data availability.
    Tracing stopped for session test-user-session

    ```

1.  在不销毁会话的情况下，您可以执行以下命令启动 `babeltrace`：

    ```
    # lttng view
    [18:58:22.625557512] (+0.001278334) wandboard-quad lttng_ust_tracef:event: { cpu_id = 0 }, { _msg_length = 19, msg = "I said: Hello World" }

    ```

1.  最后，可以销毁性能分析会话：

    ```
    # lttng destroy test-user-session
    Session test-user-session destroyed

    ```

## 工作原理...

使用 Linux 内核中可用的跟踪功能进行内核跟踪，如我们在前面示例中所见。为了使以下示例生效，Linux 内核必须根据早期相应的示例进行适当配置。

LTTng 提供了一个通用用户界面，用于控制我们之前看到的一些内核追踪功能，例如以下内容：

+   **静态** **追踪事件**：

    你可以使用以下命令启用特定的静态追踪事件：

    ```
    # lttng enable-event <comma separated event list> -k

    ```

    你可以启用所有追踪点，方法如下：

    ```
    # lttng enable-event -a -k --tracepoint

    ```

    你也可以启用所有系统调用，方法如下：

    ```
    # lttng enable-event -a -k --syscall

    ```

    你可以启用所有追踪点和系统调用，方法如下：

    ```
    # lttng enable-event -a -k

    ```

+   **动态** **追踪事件**：

    你也可以添加动态追踪点，方法如下：

    ```
    # lttng enable-event <probe_name> -k --probe <symbol>+<offset>

    ```

    你也可以使用以下命令添加它们：

    ```
    # lttng enable-event <probe_name> -k --probe <address>

    ```

+   **函数** **追踪**：

    你也可以使用内核的函数追踪功能，方法如下：

    ```
    # lttng enable-event <probe_name> -k --function <symbol>

    ```

+   **性能** **计数器事件**：

    使用以下命令获取硬件性能计数器，例如 CPU 周期：

    ```
    # lttng add-context -t perf:cpu:cpu-cycles -k

    ```

    使用 `add-context --help` 选项列出更多上下文选项和性能计数器。

### 扩展应用程序性能分析

通过编写模板文件（`.tp`）并使用 `lttng-gen-tp` 脚本与源文件一起，可以进一步提升应用程序追踪的灵活性。这将生成一个对象文件，随后可以将其链接到你的应用程序中。

在撰写本文时，Yocto 没有标准的方式对用户空间应用程序进行跨平台仪器化，但可以通过本地使用 `-sdk` 映像，或者向 `conf/local.conf` 文件添加以下映像功能来实现：

```
EXTRA_IMAGE_FEATURES += "tools-sdk dev-pkgs"
```

例如，定义一个追踪点 `hw.tp` 文件，如下所示：

```
TRACEPOINT_EVENT(
    hello_world_trace_provider,
    hw_tracepoint,
    TP_ARGS(
        int, my_integer_arg,
        char*, my_string_arg
    ),
    TP_FIELDS(
        ctf_string(my_string_field, my_string_arg)
        ctf_integer(int, my_integer_field, my_integer_arg)
    )
)
```

通过 `lttng-gen-tp` 工具传递该文件，获取 `hw.c`、`hw.h` 和 `hw.o` 文件：

```
# lttng-gen-tp hw.tp

```

### 提示

请注意，`lttng-gen-tp` 工具并不包含在 `lttng-ust` 包中，而是包含在 `lttng-ust-bin` 包中。必须将其添加到目标映像中，例如，通过在 `conf/local.conf` 文件中添加以下内容：

```
IMAGE_INSTALL_append = " lttng-ust-bin"

```

现在，你可以将 `hw.h` 头文件添加到 `helloworld.c` 文件中的 hello world 应用程序中，并按如下方式使用 `tracepoint()` 调用：

```
#include <stdio.h>
#include "hw.h"

main(void)
{
    printf("Hello World");
    tracepoint(hello_world_trace_provider,  hw_tracepoint, 1, "I said: Hello World");
}
```

现在，按如下方式将应用程序与本地 `gcc` 链接：

```
# gcc -o hw helloworld.c hw.o -llttng-ust -ldl

```

### 提示

请注意，为了在目标上使用 `gcc`，我们需要构建一个 `-sdk` 映像，或者向我们的映像添加一些额外的功能，例如：

```
EXTRA_IMAGE_FEATURES = "tools-sdk dev-pkgs"

```

要对你的应用程序进行性能分析，请执行以下操作：

1.  创建一个性能分析会话：

    ```
    # lttng create test-session
    Spawning a session daemon
    Warning: No tracing group detected
    Session test-session created.
    Traces will be written in /home/root/lttng-traces/test- session-20150117-195930

    ```

1.  启用你想要分析的特定事件：

    ```
    # lttng enable-event --userspace hello_world_trace_provider:hw_tracepoint
    Warning: No tracing group detected
    UST event hello_world_trace_provider:hw_tracepoint created in channel channel0

    ```

1.  开始收集性能分析数据：

    ```
    # lttng start
    Tracing started for session test-session

    ```

1.  运行负载进行性能分析——在此案例中是 hello world 应用程序：

    ```
    #./hw
    Hello World

    ```

1.  停止收集数据：

    ```
    # lttng stop

    ```

1.  现在启动 `babeltrace`：

    ```
    # lttng view
    [20:00:43.537630037] (+?.?????????) wandboard-quad hello_world_trace_provider:hw_tracepoint: { cpu_id = 0 }, { my_string_field = "I said: Hello World", my_integer_field = 1 }

    ```

1.  最后，销毁分析会话：

    ```
    # lttng destroy test-session

    ```

## 还有更多...

你还可以使用 Trace Compass 应用程序或 Eclipse 插件通过访问 [`projects.eclipse.org/projects/tools.tracecompass/downloads`](http://projects.eclipse.org/projects/tools.tracecompass/downloads) 来分析主机中的追踪。在撰写本文时，稳定版本尚未发布。

## 另见

+   使用 LTTng 的详细信息请参考 [`lttng.org/docs/`](http://lttng.org/docs/)

+   有关 C 应用程序仪器化的详细信息，请参考 [`lttng.org/docs/#doc-c-application`](http://lttng.org/docs/#doc-c-application)

+   在 `lttng-ust` 源代码中的 `tracepoint()` 示例：[`git.lttng.org/?p=lttng-ust.git;a=tree;f=tests/hello;h=4ae310caf62a8321a253fa84a04982edab52829c;hb=HEAD`](http://git.lttng.org/?p=lttng-ust.git;a=tree;f=tests/hello;h=4ae310caf62a8321a253fa84a04982edab52829c;hb=HEAD)

# 使用 blktrace

有一些工具可以用来执行块设备的 I/O 监控和分析。

从我们在 *探索 Yocto 的追踪与分析工具* 配方中提到的 `iotop` 开始，它能大致了解系统和特定进程的吞吐量。或者使用 `iostat`，它提供更多关于 CPU 使用率和设备利用率的统计信息，但不提供每个进程的细节。最后是 `blktrace`，一个 GPLv2 许可的工具，它在低级别监控特定块设备的 I/O，并且还能计算 **每秒 I/O 操作** (**IOPS**)。

本配方将解释如何使用 `blktrace` 来追踪块设备，并使用 `blkparse` 将追踪数据转换为人类可读的格式。

## 准备工作

要使用 `blktrace` 和 `blkparse`，你可以通过明确添加它们到目标镜像中，像这样：

```
IMAGE_INSTALL_append = " blktrace"
```

另外，你也可以使用 `tools-profile` 镜像功能，或者一个 `-sdk` 镜像。

你还需要配置 Linux 内核，启用 `CONFIG_FTRACE` 和 `CONFIG_BLK_DEV_IO_TRACE`，才能追踪块 I/O 操作。

在分析块设备时，重要的是尽量减少追踪对结果的影响；例如，不在被分析的块设备上存储追踪数据。

有几种方法可以实现这一点：

+   从不同的块设备运行追踪。

+   从基于 RAM 的 `tmpfs` 设备（如 `/var/volatile`）运行追踪。从内存设备上运行将限制可存储的追踪数据量。

+   从网络挂载的文件系统运行追踪。

+   通过网络运行追踪。

此外，用于分析的块设备的文件系统也是一个重要因素，因为文件系统的特性（如日志记录）会扭曲 I/O 统计数据。即使是以块设备形式呈现给用户空间的闪存文件系统，也无法使用 `blktrace` 进行分析。

## 如何实现...

假设你想要分析 Wandboard 上 microSD 卡设备的 I/O。通过从网络启动系统，如在第一章《构建系统》中的 *为开发环境配置网络启动* 配方所示，你可以避免系统对设备的多余访问。

对于这个例子，我们将挂载为 ext2 分区，以避免日志记录，但可能还需要其他调整，以有效分析特定的工作负载：

```
# mount -t ext2 /dev/mmcblk0p2 /mnt
EXT2-fs (mmcblk0p2): warning: mounting ext3 filesystem as ext2
EXT2-fs (mmcblk0p2): warning: mounting unchecked fs, running e2fsck is recommended

```

分析特定工作负载的工作流程如下：

1.  启动 `blktrace`，收集 `/dev/mmcblk0` 设备的追踪数据：

    ```
    # blktrace /dev/mmcblk0

    ```

1.  启动需要分析的工作负载，例如创建一个 10 KB 的文件。打开 SSH 连接到目标并执行：

    ```
    # dd if=/dev/urandom of=/mnt/home/root/random-10k-file bs=1k count=10 conv=fsync
    10+0 records in
    10+0 records out
    10240 bytes (10 kB) copied, 0.00585167 s, 1.7 MB/s

    ```

1.  使用*Ctrl* + *C*停止控制台上的分析。这将在相同目录下创建一个名为`mmcblk0.blktrace.0`的文件。你将看到以下输出：

    ```
    ^C=== mmcblk0 ===
      CPU  0:                   30 events,        2 KiB data
     Total:                    30 events (dropped 0),        2 KiB data

    ```

    一些有用的`blktrace`选项包括：

    +   `-w`: 这用于只运行指定秒数

    +   `-a`: 这会将一个掩码添加到当前文件中，掩码可以是：

        +   `barrier`: 这是指障碍属性

        +   `complete`: 这是指由驱动程序完成的操作

        +   `fs`: 这些是文件系统请求

        +   `issue`: 这个选项指的是发出的操作

        +   `pc`: 这是指数据包命令事件

        +   `queue`: 这个选项代表队列操作

        +   `read`: 这是指读取跟踪

        +   `requeue`: 这是用于重新排队操作

        +   `sync`: 这表示同步属性

        +   `write`: 这是指写入跟踪

## 它是如何工作的...

一旦收集到跟踪数据，你可以使用`blkparse`进行处理，如下所示：

```
# blkparse mmcblk0

```

这将提供所有收集数据的`stdout`输出，以及最终的总结，如下所示：

```
Input file mmcblk0.blktrace.0 added
179,0    0        1     0.000000000   521  A   W 1138688 + 8 <- (179,2) 1114112
179,0    0        2     0.000003666   521  Q   W 1138688 + 8 [kworker/u8:0]
179,0    0        3     0.000025333   521  G   W 1138688 + 8 [kworker/u8:0]
179,0    0        4     0.000031000   521  P   N [kworker/u8:0]
179,0    0        5     0.000044666   521  I   W 1138688 + 8 [kworker/u8:0]
179,0    0        0     0.000056666     0  m   N cfq519A  insert_request
179,0    0        0     0.000063000     0  m   N cfq519A  add_to_rr
179,0    0        6     0.000081000   521  U   N [kworker/u8:0] 1
179,0    0        0     0.000121000     0  m   N cfq workload slice:6
179,0    0        0     0.000132666     0  m   N cfq519A  set_active wl_class:0 wl_type:0
179,0    0        0     0.000141333     0  m   N cfq519A  Not idling. st->count:1
179,0    0        0     0.000150000     0  m   N cfq519A  fifo=  (null)
179,0    0        0     0.000156000     0  m   N cfq519A  dispatch_insert
179,0    0        0     0.000167666     0  m   N cfq519A  dispatched a request
179,0    0        0     0.000175000     0  m   N cfq519A  activate rq, drv=1
179,0    0        7     0.000181333    83  D   W 1138688 + 8 [mmcqd/2]
179,0    0        8     0.735417000    83  C   W 1138688 + 8 [0]
179,0    0        0     0.739904333     0  m   N cfq519A  complete rqnoidle 0
179,0    0        0     0.739910000     0  m   N cfq519A  set_slice=4
179,0    0        0     0.739912000     0  m   N cfq schedule dispatch
CPU0 (mmcblk0):
 Reads Queued:           0,        0KiB  Writes Queued:1,4KiB
 Read Dispatches:        0,        0KiB  Write Dispatches:1,4KiB
 Reads Requeued:         0               Writes Requeued:0
 Reads Completed:        0,        0KiB  Writes Completed:1,4KiB
 Read Merges:            0,        0KiB  Write Merges:0,0KiB
 Read depth:             0               Write depth:1
 IO unplugs:             1               Timer unplugs:0

Throughput (R/W): 0KiB/s / 5KiB/s
Events (mmcblk0): 20 entries
Skips: 0 forward (0 -   0.0%)
```

`blkparse`的输出格式为：

```
179,0    0        7     0.000181333    83  D   W 1138688 + 8 [mmcqd/2]

```

这对应于：

```
<mayor,minor> <cpu> <seq_nr> <timestamp> <pid> <actions> <rwbs> <start block> + <nr of blocks> <command>

```

各列对应于：

+   `A`: I/O 被重定向到不同设备

+   `B`: I/O 被回跳

+   `C`: I/O 完成

+   `D`: I/O 发往驱动程序

+   `F`: I/O 前端与队列中的请求合并

+   `G`: 获取请求

+   `I`: I/O 插入到请求队列中

+   `M`: I/O 后端与队列中的请求合并

+   `P`: 插入请求

+   `Q`: I/O 由请求队列代码处理

+   `S`: 睡眠请求

+   `T`: 超时导致的拔出

+   `U`: 拔出请求

+   `X`: 分割

RWBS 字段对应于：

+   `R`: 读取

+   `W`: 写入

+   `B`: 障碍

+   `S`: 同步

另一种非破坏性跟踪方式是使用实时监控，即直接将`blktrace`的输出通过管道传递给`blkparse`，而不写入任何内容到磁盘，如下所示：

```
# blktrace /dev/mmcblk0 -o - | blkparse -i -

```

这也可以仅用一行命令完成：

```
# btrace /dev/mmcblk0

```

## 还有更多...

`blktrace`命令还可以通过网络发送跟踪数据，这样它就可以存储在不同的设备上。

为此，按照以下方式在目标系统上启动`blktrace`：

```
# blktrace -l /dev/mmcblk0

```

在另一台设备上，按照以下方式运行另一个实例：

```
$ blktrace -d /dev/mmcblk0 -h <target_ip>

```

回到目标，现在你可以执行你想要跟踪的特定工作负载：

```
# dd if=/dev/urandom of=/mnt/home/root/random-10k-file bs=1k count=10 conv=fsync
10+0 records in
10+0 records out
10240 bytes (10 kB) copied, 0.00585167 s, 1.7 MB/s

```

完成后，使用*Ctrl* + *C*中断远程`blktrace`。总结将同时在目标和主机上打印。

现在，你可以运行`blkparse`来处理收集到的数据。
