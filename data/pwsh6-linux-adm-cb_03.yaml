- en: Preparing for Administration using PowerShell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PowerShell 为管理做好准备
- en: 'In this chapter, we cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括以下主题：
- en: Installing Visual Studio Code
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Visual Studio Code
- en: Configuring automatic variables
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置自动变量
- en: Changing the shell behaviour using a variable
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用变量更改 Shell 行为
- en: Enabling automated execution of commands for each load
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用每次加载时自动执行命令
- en: Customising the terminal prompt
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义终端提示符
- en: Understanding standard redirection in PowerShell
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解 PowerShell 中的标准重定向
- en: Calling native Linux commands from PowerShell
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 PowerShell 调用原生 Linux 命令
- en: Understanding cmdlets and parameters
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解 cmdlet 和参数
- en: Running cmdlets with minimal keystrokes
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最少的按键运行 cmdlet
- en: Finding parameter aliases
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找参数别名
- en: Calling a PowerShell script
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 PowerShell 脚本
- en: Dot-sourcing a PowerShell script
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dot-sourcing PowerShell 脚本
- en: Calling a PowerShell cmdlet from outside of PowerShell
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 PowerShell 外部调用 PowerShell cmdlet
- en: Recording the cmdlets run on the PowerShell console
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录在 PowerShell 控制台上运行的 cmdlet
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: It is common notion that the more you use the terminal (as opposed to the GUI),
    the more efficient you are. Typing out commands is much easier and faster than
    clicking around the screen. However, to someone who has just begun using the terminal,
    it may not be so. Over time, as administrators grow more and more comfortable
    with the terminal, they learn to configure it for speed and efficiency, much like
    a trained horse. Further, most efficient administrators like automating several
    parts of their workflow—customising `.bashrc` and Vim scripts  are examples of
    it. In this chapter, we will familiarise ourselves with the different consoles
    and tools that work with PowerShell, and will also look at a few simple recipes
    which would help customise our workspace, so that we can be more efficient.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个普遍的观念，认为越多使用终端（而非 GUI），效率就越高。输入命令比点击屏幕更轻松、更快捷。然而，对于刚刚开始使用终端的人来说，情况可能并非如此。随着时间的推移，管理员会越来越熟悉终端，并学会像训练有素的马一样配置终端，以提高速度和效率。此外，大多数高效的管理员喜欢自动化他们工作流的多个部分——自定义
    `.bashrc` 和 Vim 脚本就是其中的例子。在本章中，我们将熟悉与 PowerShell 配合使用的不同控制台和工具，并探讨一些简单的技巧，帮助我们自定义工作空间，从而提高效率。
- en: Installing Visual Studio Code
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Visual Studio Code
- en: Scripting can happen on the console itself, with Vim. It is also possible to
    use other editors like Gedit or even Atom to write PowerShell scripts. It is,
    however, recommended to use Microsoft's open source code editor, called, Visual
    Studio Code (or `vscode`). In this recipe, we would look at installing Visual
    Studio Code, and configuring it to work with PowerShell.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以直接在控制台上使用 Vim 进行编写。也可以使用其他编辑器如 Gedit 或 Atom 来编写 PowerShell 脚本。然而，推荐使用微软的开源代码编辑器——Visual
    Studio Code（或 `vscode`）。在本教程中，我们将介绍如何安装 Visual Studio Code，并将其配置为与 PowerShell
    一起使用。
- en: Getting Ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would look at the steps to install `vscode` on Ubuntu. Today, most repositories
    contain Visual Studio Code. You may check in the software store of your distribution
    to install `vscode`. If not, the easiest way to install `vscode` is to download
    the `.deb` (or the `.rpm` package based on your distro), and run it to install
    the package on your computer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍在 Ubuntu 上安装 `vscode` 的步骤。如今，大多数软件库中都包含 Visual Studio Code。您可以在您的发行版的软件下载商店中查找并安装
    `vscode`。如果没有，安装 `vscode` 最简单的方法是下载 `.deb`（或根据您的发行版下载 `.rpm` 包），并运行它以在计算机上安装该软件包。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Installing Visual Studio Code is simple.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Visual Studio Code 非常简单。
- en: If your Linux distribution has a software store, search the store for Visual
    Studio Code.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的 Linux 发行版有软件商店，请在商店中搜索 Visual Studio Code。
- en: If you find Visual Studio Code, install the package from there. If not, proceed
    with the next step.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到 Visual Studio Code，请从那里安装该软件包。如果没有，请继续执行下一步。
- en: 'The package name for Visual Studio Code is `code`. Use your package manager
    to search for the package in the repository. On Ubuntu, the command would be:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio Code 的软件包名称是 `code`。使用您的包管理器在软件库中搜索该软件包。在 Ubuntu 上，命令是：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you're able to find the package in your repository, install vscode like you
    would any other package.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您能够在您的软件库中找到该软件包，请像安装任何其他软件包一样安装 vscode。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you were unable to find the package, go to [https://code.visualstudio.com/Download](https://code.visualstudio.com/Download)
    and download the right `code` package for your distro.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您无法找到该软件包，请访问[https://code.visualstudio.com/Download](https://code.visualstudio.com/Download)并下载适用于您发行版的正确`code`软件包。
- en: To install VS Code, call your package manager with the path to the downloaded
    package.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装 VS Code，调用你的包管理器并指定下载的包路径。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you would rather install VS Code in portable mode, download the VS Code tarball
    and extract its contents to a convenient location to run VS Code. Although, remember
    that updates to VS Code would be handled by VS Code itself, in this case.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你更愿意以便携模式安装 VS Code，可以下载 VS Code 的 tar 包，并将其内容提取到一个方便的位置来运行 VS Code。但请记住，在这种情况下，VS
    Code 的更新将由 VS Code 自身处理。
- en: Visual Studio Code is a powerful code editor in itself. However, it may not
    fully support PowerShell right out of the box. You would need to install the extension
    that packs capabilities which help run write and run PowerShell scripts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 本身是一个强大的代码编辑器。然而，它可能无法直接完美支持 PowerShell。你需要安装一个扩展，它可以提供运行和编写
    PowerShell 脚本的功能。
- en: Launch Visual Studio Code.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio Code。
- en: Click on the Extensions icon or press `Ctrl+Shift+X` to go to the Extensions
    pane.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击扩展图标或按 `Ctrl+Shift+X` 进入扩展面板。
- en: In the search bar, enter `powershell publisher:Microsoft` and hit Enter to search
    for the PowerShell package.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入 `powershell publisher:Microsoft`，然后按回车键搜索 PowerShell 包。
- en: Click on Install in the resulting package–the PowerShell package should be on
    top.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击安装，结果包中应该会显示 PowerShell 包，它会排在最上面。
- en: Once the installation completes, click on Reload to reload Visual Studio Code
    with PowerShell capabilities.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，点击重新加载，以使 Visual Studio Code 加载 PowerShell 功能。
- en: You are now ready to develop PowerShell scripts using a friendly editor that
    supports almost all of the capabilities that Windows PowerShell Integrated Scripting
    Environment has, and more!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好使用一个友好的编辑器来开发 PowerShell 脚本，它支持 Windows PowerShell 集成脚本环境的几乎所有功能，甚至更多！
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Windows PowerShell ISE was the de-facto environment to develop PowerShell scripts
    and even applications written in PowerShell. Then came Adam Driscoll's PowerShell
    extension to Microsoft Visual Studio which integrated PowerShell into the integrated
    development environment.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Windows PowerShell ISE 曾是开发 PowerShell 脚本甚至 PowerShell 编写的应用程序的事实标准环境。后来，Adam
    Driscoll 的 PowerShell 扩展将 PowerShell 集成到了 Microsoft Visual Studio 中，成为了集成开发环境的一部分。
- en: While PowerShell was being worked on, and the .NET Foundation was formed, Microsoft
    started working on a lightweight code editor called Visual Studio Code that packed
    many of the great features of Visual Studio, without all the load of the language
    libraries. This was enough to build PowerShell scripts; most PowerShell *script-writers*
    use mainly the IntelliSense features, and Visual Studio Code has them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 开发的同时，.NET 基金会成立，微软开始开发一个名为 Visual Studio Code 的轻量级代码编辑器，它包含了 Visual
    Studio 的许多强大功能，但没有语言库的负担。这足以构建 PowerShell 脚本；大多数 PowerShell *脚本编写者* 主要使用 IntelliSense
    功能，而 Visual Studio Code 提供了这些功能。
- en: Using a package manager to install VS Code ensures that all the dependencies
    are met. Also, this method of installation ensures that the signing key is added
    to the system. This way, updates to VS Code can be installed through the system,
    such as by running `sudo apt upgrade`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包管理器来安装 VS Code 可以确保满足所有依赖项。而且，这种安装方式确保了签名密钥被添加到系统中。这样，VS Code 的更新可以通过系统来安装，例如运行
    `sudo apt upgrade`。
- en: See also
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Installing Visual Studio Code on Linux](https://code.visualstudio.com/docs/setup/linux)
    (Microsoft documentation)'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[在 Linux 上安装 Visual Studio Code](https://code.visualstudio.com/docs/setup/linux)（Microsoft
    文档）'
- en: Configuring automatic variables
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置自动变量
- en: Perhaps nothing contributes to efficiency like configurability. Configuring
    a system is a way of moulding it to your taste. You are the only one who knows
    best what works for you. Therefore, the more configurable a system is, the better
    it can be moulded to your use. automatic variables in PowerShell are one of the
    first steps to customisation in PowerShell (profiles are the other; we shall look
    into them shortly). In this recipe, we will list out all the automatic variables,
    and configure some of them to our requirements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 也许没有什么比可配置性更能提高效率了。配置一个系统是将其塑造为符合你个人口味的一种方式。你是唯一知道什么对你最有效的人。因此，一个系统越可配置，它就越能根据你的需求进行调整。PowerShell
    中的自动变量是 PowerShell 自定义的第一步（配置文件是另一种方法；我们稍后会讲到它们）。在本教程中，我们将列出所有的自动变量，并将其中一些配置为满足我们的需求。
- en: Getting Ready
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Read the *Listing the various providers in PowerShell* section of *Installation,
    Reference and Help*, to learn how to use the various providers in PowerShell.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读 *PowerShell 中列出各种提供者* 部分，了解如何在 PowerShell 中使用各种提供者。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let us first list out the variables we have. This can be done in two ways:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们列出我们所拥有的变量。这可以通过两种方式完成：
- en: Using a cmdlet
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 cmdlet
- en: Using a provider
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提供程序
- en: Let us first look at using the cmdlet to list out the variables built into PowerShell.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看使用 cmdlet 列出内置于 PowerShell 的变量。
- en: Open a terminal window. If you have one open, restart PowerShell.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口。如果已经打开了一个，重启 PowerShell。
- en: Find the cmdlet that works with variables.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找与变量配合使用的 cmdlet。
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remember that the noun in a cmdlet is always singular. Therefore, it would be
    `Variable`, and not `Variables`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，cmdlet 中的名词总是单数形式。因此，应该是 `Variable`，而不是 `Variables`。
- en: There are five cmdlets that deal with variables. We want to fetch a list of
    all variables already existing in a new session of PowerShell. Let us pick `Get-Variable`,
    and fetch help information for it.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有五个 cmdlet 处理变量。我们希望获取一个新 PowerShell 会话中所有已存在变量的列表。让我们选择 `Get-Variable`，并获取它的帮助信息。
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the cmdlet that we need to list out all the variables predefined in
    the current scope.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们需要用来列出当前作用域中所有预定义变量的 cmdlet。
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That should list out all the variables predefined in the current scope.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该可以列出当前作用域中所有预定义的变量。
- en: Any variables you define would be listed here. Hence, it is important that you
    start a fresh session of PowerShell to see what variables have been predefined.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义的任何变量都会列在这里。因此，重要的是你要启动一个新的 PowerShell 会话，看看有哪些变量已经预定义。
- en: Let us now use a PowerShell provider to list out the variables defined in the
    current scope.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 PowerShell 提供程序列出当前作用域中定义的变量。
- en: List out the PowerShell providers. We looked at providers in the previous chapter.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出 PowerShell 提供程序。我们在前一章中已经看过提供程序。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Change location to the `Variable:` drive of the `Variable` provider. This is
    done using `Set-Location`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位置更改为 `Variable:` 驱动器，这属于 `Variable` 提供程序。可以使用 `Set-Location` 完成此操作。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let us list out all the available child items of the `Variable:` drive.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们列出 `Variable:` 驱动器下所有可用的子项。
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The output of this was identical to that of `Get-Variable`, called without an
    argument.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这的输出与没有参数调用的 `Get-Variable` 完全相同。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: PowerShell is built with some variables that control its behaviour, and administrators
    are allowed to modify some of them to suit the needs. Some variables, however,
    cannot be modified; they are contextual, and add some amount of flexibility (or
    modularity, as the case might be) to the shell.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 内建了一些控制其行为的变量，管理员可以修改其中一些以满足需求。然而，一些变量是不能修改的；它们是上下文相关的，提供了一定的灵活性（或者说模块化，根据具体情况而言）给
    shell。
- en: One such example would be `$PWD`, which contains the path of the present directory.
    This variable changes itself based on the execution of `Set-Location`. Values
    cannot be explicitly assigned to such variables; setting values explicitly would
    have no effect on the behaviour of the shell.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个这样的例子是 `$PWD`，它包含当前目录的路径。这个变量会根据 `Set-Location` 的执行自动变化。不能显式地为这样的变量分配值；显式设置值不会对
    shell 的行为产生任何影响。
- en: Some variables, on the other hand, accept values, and let us control the execution
    of commands and scripts. We shall look at an example in the next recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一些变量接受值，并让我们控制命令和脚本的执行。我们将在下一个食谱中看到一个示例。
- en: Changing the shell behaviour using a variable
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量改变 shell 行为
- en: In the previous recipe, we took a look at the existing variables. In this recipe,
    we will change the value of one of the variables to control the behaviour of PowerShell.
    Again, remember that the change in the value is ephemeral; the values would be
    reset once the PowerShell process is restarted.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个食谱中，我们查看了现有的变量。在这个食谱中，我们将更改其中一个变量的值，以控制 PowerShell 的行为。再次提醒，值的更改是暂时的；一旦
    PowerShell 进程重启，值会被重置。
- en: Getting Ready
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Read the previous recipe to understand what automatic variables that come predefined.
    Also, start Visual Studio Code. Follow the steps below to start VS Code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前一个食谱以了解哪些自动变量是预定义的。同时，启动 Visual Studio Code。按照下面的步骤启动 VS Code。
- en: Open Applications (I'm using the Gnome DE, which shows all applications with
    `Super + A`).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用程序（我使用的是 Gnome DE，使用 `Super + A` 可以显示所有应用程序）。
- en: Type in `code`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `code`。
- en: Press `` Ctrl + ` `` to launch the terminal.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 `` Ctrl + ` `` 启动终端。
- en: Click on New File at the welcome screen. (Or press `Ctrl + N`.)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在欢迎界面点击新建文件。（或者按 `Ctrl + N`。）
- en: At the bottom right of the VS Code window, you would see the file type set to
    Plain Text. Click on it; you would be taken to the command bar on top.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 窗口的右下角，你会看到文件类型设置为“纯文本”。点击它，你会被带到顶部的命令栏。
- en: Type in `powershell` at the command bar. The PowerShell Integrated Console will
    open at the bottom.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令栏中输入 `powershell`。PowerShell 集成控制台会在底部打开。
- en: '![](img/4695ded0-1291-4688-85fc-14410d9643aa.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4695ded0-1291-4688-85fc-14410d9643aa.png)'
- en: We are all set for the recipe now.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好进行配方操作了。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怎么做…
- en: 'Let us run a command that would result in an error. For now, let us not focus
    on the syntax of the command; our only goal for now is to generate an error. At
    the first line of the script window, type in:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行一个会导致错误的命令。暂时，我们不关注命令的语法；我们现在的唯一目标是生成一个错误。在脚本窗口的第一行，输入：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/b0b222fa-1b67-42e4-a78e-d22e94f2bc8a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0b222fa-1b67-42e4-a78e-d22e94f2bc8a.png)'
- en: Run the two-liner script using the `F5` key.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `F5` 键运行这段两行脚本。
- en: '![](img/104cf932-9a53-42b2-8bed-87e13ae01667.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/104cf932-9a53-42b2-8bed-87e13ae01667.png)'
- en: PowerShell is prompt to show an error. It also displays the `Hello world!` string.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 会提示显示错误。它还会显示 `Hello world!` 字符串。
- en: Now, let us set the error action preference, using the variable, `ErrorActionPreference`.
    We know there's such a variable from the previous recipe. First, though, restart
    PowerShell. The easiest way is to click on the little bin icon at the top of the
    Integrated Console window. When VS Code asks if you would like to restart the
    session, click on Yes.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `ErrorActionPreference` 变量设置错误操作偏好。我们从前面的配方中知道有这个变量。不过，首先，重新启动 PowerShell。最简单的方法是点击集成控制台窗口顶部的小垃圾桶图标。当
    VS Code 提示是否要重新启动会话时，点击“是”。
- en: '![](img/b9254d0b-3222-4b7d-879b-2d8b4063252b.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9254d0b-3222-4b7d-879b-2d8b4063252b.png)'
- en: 'Now, set the `ErrorActionPreference` variable. At the PowerShell Integrated
    Console, enter:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置 `ErrorActionPreference` 变量。在 PowerShell 集成控制台中，输入：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the two-liner script again.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行这段两行的脚本。
- en: There is no error this time. And we see `Hello world!` at the console.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有错误。我们在控制台看到 `Hello world!`。
- en: If you do not want the entire script appear at the prompt, make the first line
    of the script, `Clear-Host`; this would clear the screen before showing the output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望整个脚本出现在提示符中，可以让脚本的第一行是 `Clear-Host`；这样就会在显示输出之前清除屏幕。
- en: What if you were to check whether an error was generated at all? We check the
    value of the automatic variable, `Error`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想检查是否生成了错误怎么办？我们检查自动变量 `Error` 的值。
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/48e32e87-abde-4edd-9ca0-6cf1a296a5aa.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48e32e87-abde-4edd-9ca0-6cf1a296a5aa.png)'
- en: The `Value` column contains some text. Let's select and expand the contents
    of `Value`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Value` 列包含一些文本。让我们选择并展开 `Value` 的内容。'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/735a62cc-1e23-4373-8710-1f1c53943594.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/735a62cc-1e23-4373-8710-1f1c53943594.png)'
- en: The output text is the same as what we received before we set the error action
    preference.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文本与我们设置错误操作偏好之前收到的结果相同。
- en: You can also simply call the `Error` variable to read all the errors that occurred
    in the current session.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接调用 `Error` 变量来读取当前会话中发生的所有错误。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: By default, the error action preference is `Continue`, which means that PowerShell
    would display the error, and continue with the execution of the rest of the script
    (this effect is not noticeable when running individual commands, hence the creation
    of the two-liner, or three-liner in case you added `Clear-Host` at the top). By
    setting `ErrorActionPreference` to `SilentlyContinue`, we instruct PowerShell
    to record the error but not show it on the screen, and at the same time, go on
    with executing the rest of the script.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，错误操作偏好为 `Continue`，这意味着 PowerShell 会显示错误，并继续执行脚本的其余部分（在运行单个命令时，这种效果不明显，因此才创建了两行或三行的脚本，假如你在顶部加了
    `Clear-Host`）。通过将 `ErrorActionPreference` 设置为 `SilentlyContinue`，我们指示 PowerShell
    记录错误，但不在屏幕上显示，同时继续执行脚本的其余部分。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[about_Preference_Variables, $ErrorActionPreference](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables?view=powershell-6#erroractionpreference)
    (Microsoft documentation)'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[about_Preference_Variables, $ErrorActionPreference](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables?view=powershell-6#erroractionpreference)（Microsoft
    文档）'
- en: 'Recipe: Error handling in PowerShell'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方：PowerShell 中的错误处理
- en: Enabling automated execution of commands for each load
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用每次加载时自动执行命令
- en: Like we saw in the previous recipes, these changes are ephemeral; they remain
    as long as the session is active. There might be situations wherein administrators
    might require running a few commands, or loading modules to enable them to work
    faster. For instance, I tend to load a series of modules that help me manage Microsoft
    Exchange, Active Directory, VMware vSphere infrastructure, Citrix XenApp, Microsoft
    System Center, and other environments using PowerShell.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的示例中看到的，这些更改是暂时性的；它们只会在会话处于活动状态时有效。可能会出现管理员需要运行一些命令或加载模块以提高工作效率的情况。例如，我通常会加载一系列帮助我管理
    Microsoft Exchange、Active Directory、VMware vSphere 基础设施、Citrix XenApp、Microsoft
    System Center 以及其他环境的模块，所有这些操作都使用 PowerShell 完成。
- en: If you see, all of these products require different ways of loading the modules,
    snap-ins and scripts, and many of them require certain configuration every time
    you load the modules (such as connecting to VM servers with administrator credentials).
    These can be done using the PowerShell profile.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察，你会发现这些产品加载模块、snap-in 和脚本的方式不同，且许多产品每次加载模块时都需要特定的配置（比如以管理员身份连接到虚拟机服务器）。这些都可以通过
    PowerShell 配置文件来完成。
- en: Getting Ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: PowerShell by default does not create a profile during installation. It simply
    runs with its default configuration. Any override to this configuration would
    require creating and modifying the profile.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 在安装时默认不会创建配置文件。它只会使用默认配置运行。要覆盖此配置，你需要创建并修改配置文件。
- en: Open a PowerShell console. (You could either run pwsh at the terminal or use
    the VS Code console. This recipe uses the terminal.)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 PowerShell 控制台。（你可以在终端中运行 `pwsh` 或使用 VS Code 控制台。这个示例使用的是终端。）
- en: Reveal the path of your profile. To do this, simply call the automatic variable.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示你的配置文件路径。为此，只需调用自动变量。
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Check if your profile exists.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你的配置文件是否存在。
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you get True as the response, you can proceed with the recipe. If the response
    is False, which is most likely the case, run the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你得到的响应是 True，你可以继续执行该示例。如果响应是 False（这通常是默认情况），请运行以下命令：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You may receive an error, saying a part of the path was not found. This is because
    your `~/.config/` directory does not by default contain a `powershell` directory.
    Adding `-Force` to the command creates this directory and creates your profile
    file at the location.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会收到一个错误，提示未找到路径的一部分。这是因为你的 `~/.config/` 目录默认情况下不包含 `powershell` 目录。添加 `-Force`
    参数会创建这个目录，并在该位置创建你的配置文件。
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](img/c6790c84-4047-427b-933e-47b24beaf1d1.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6790c84-4047-427b-933e-47b24beaf1d1.png)'
- en: 'We will now edit the profile in VS Code. At the terminal, type:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在 VS Code 中编辑配置文件。在终端中输入：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You should have the profile open now. It would currently be empty. Let us now
    customise PowerShell's error action behaviour. Remember that we said that setting
    `ErrorActionPreference` to `SilentlyContinue` at the terminal was temporary. Let
    us now ensure that `ErrorActionPreference` is permanently set to `SilentlyContinue`
    every time we launch PowerShell.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的配置文件应该已经打开，当前为空。接下来，我们将自定义 PowerShell 的错误操作行为。记住，我们之前在终端中将 `ErrorActionPreference`
    设置为 `SilentlyContinue` 是临时的。现在，我们将确保每次启动 PowerShell 时，`ErrorActionPreference`
    都会永久设置为 `SilentlyContinue`。
- en: Switch to the terminal window. If you have the window open since the last recipe,
    restart PowerShell.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到终端窗口。如果你自上一个示例以来仍然保持窗口打开，请重启 PowerShell。
- en: Let us see what the error action preference is at the moment.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当前的错误操作首选项是什么。
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Switch to VS Code. The profile should already be open for edits.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 VS Code。配置文件应该已经打开，可以进行编辑。
- en: 'At the very first line, type in:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，输入：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Save the profile and close the file.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存配置文件并关闭该文件。
- en: At the terminal, type `exit` to exit from PowerShell. Start PowerShell again.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，输入 `exit` 退出 PowerShell。然后重新启动 PowerShell。
- en: 'Let us now check what the value is for `ErrorActionPreference`. At the prompt,
    type:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们检查一下 `ErrorActionPreference` 的值。在提示符下，输入：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To ensure the preference is indeed in place, type:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为确保设置已生效，请输入：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/bf5a2583-205d-4e2a-b756-4611f2977719.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf5a2583-205d-4e2a-b756-4611f2977719.png)'
- en: The cursor simply returned to the prompt at the next line without throwing an
    error.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 光标简单地返回到下一行的提示符，而没有抛出任何错误。
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原理...
- en: Long story short, the PowerShell profile executes every time a PowerShell session
    is loaded. This profile is a PowerShell script file that can contain a series
    of commands and functions, which would be executed just like another script.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，PowerShell 个人资料在每次加载 PowerShell 会话时都会执行。这个个人资料是一个 PowerShell 脚本文件，可以包含一系列命令和函数，这些命令和函数会像其他脚本一样执行。
- en: One important point to remember is that there is a different profile for each
    host. For instance, there is a separate profile for PowerShell loaded on the Terminal,
    and a different one for the Integrated Terminal on VS Code. This is because each
    of the terminals has a different nature.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要点是，每个主机都有不同的个人资料。例如，PowerShell 在终端上加载时有一个单独的个人资料，而 VS Code 中的集成终端则有一个不同的个人资料。这是因为每个终端的性质不同。
- en: Execution Policies have not been implemented in PowerShell on Linux. In case
    PowerShell on Linux gains the safety belt in the future, the execution policy
    should be set to allow execution of scripts in order for the profile to load.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 在 Linux 上尚未实现执行策略。如果 PowerShell 在未来在 Linux 上获得了安全性设置，则应设置执行策略为允许执行脚本，以便加载个人资料。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'It is bad practice to set a global action preference. Empty the profile to
    remove the error action preference. Since the profile has nothing else, you could
    even delete the profile using the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 设置全局操作首选项是不好的做法。清空个人资料以移除错误操作首选项。由于个人资料中没有其他内容，你甚至可以使用以下命令删除个人资料：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Read the best practices for more information.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读最佳实践以获取更多信息。
- en: Customising the terminal prompt
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义终端提示符
- en: In the previous recipe, we customised the error action preference using the
    profile. We used an already-demonstrated command to show that commands that can
    be run on the PowerShell console can be added to the profile as well, and this
    was a way to automate running a certain set of commands which could be used to
    increase productivity.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用个人资料自定义了错误操作首选项。我们使用了已经演示过的命令，展示了可以在 PowerShell 控制台中运行的命令同样也可以添加到个人资料中，这也是一种自动化执行一组命令的方式，从而提高生产力。
- en: Now, we will take the next step and customise our console prompt. The options
    are theoretically endless; this recipe is just another demonstration of how flexible
    PowerShell is.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进行下一步，定制我们的控制台提示符。理论上，选项是无穷无尽的；这个示例只是 PowerShell 灵活性如何的另一个演示。
- en: Getting Ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need VS Code for this recipe. If you did not follow along the last recipe,
    follow the steps in the *Getting Ready* section of the last recipe to create a
    PowerShell profile, only this time, run the commands at the PowerShell Integrated
    Console of VS Code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例需要 VS Code。如果你没有按照上一个示例进行，请按照上一个示例中 *准备工作* 部分的步骤创建 PowerShell 个人资料，这次在 VS
    Code 的 PowerShell 集成控制台中运行命令。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: Ensure that the profile is empty. If you just created the profile, you can simply
    proceed further. If not, clear all contents in the profile. If the error action
    preference is set in the profile, it would become hard to troubleshoot scripts
    that you create in the future.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 确保个人资料是空的。如果你刚刚创建了个人资料，可以直接继续。如果不是，请清空个人资料中的所有内容。如果个人资料中设置了错误操作首选项，将来你创建的脚本会很难进行故障排除。
- en: Enter the following in the main window.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主窗口中输入以下内容。
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Save the profile script file.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存个人资料脚本文件。
- en: Click on the little bin icon at the top of the Integrated Console to kill the
    current PowerShell session.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击集成控制台顶部的小垃圾桶图标以结束当前的 PowerShell 会话。
- en: When VS Code prompts you whether you would like to restart the session, click
    Yes.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 VS Code 提示你是否想要重新启动会话时，点击“是”。
- en: Your prompt should look as shown in the image below.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你的提示应该如下图所示。
- en: '![](img/f6f8c8ed-8df5-4d42-8415-d37b24ac6e27.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6f8c8ed-8df5-4d42-8415-d37b24ac6e27.png)'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The prompt is controlled by a function called `prompt`. To demonstrate this,
    we could use:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 提示由一个名为`prompt`的函数控制。为了演示这一点，我们可以使用：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output shows that there is indeed such a command, which is of the type
    `Function`. To know the contents of the `prompt` function, enter:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示确实有这样的命令，其类型为`Function`。要查看`prompt`函数的内容，请输入：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The output shows you the entire function you just wrote. This is, however, the
    function that overrode the default `prompt` function. If you clear your profile,
    restart the PowerShell session, and type in the command above, you would see a
    simple three-liner output, which is the default `prompt` function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了你刚刚编写的整个函数。但这其实是覆盖了默认 `prompt` 函数的那个函数。如果你清除配置文件，重新启动 PowerShell 会话，并输入上述命令，你将看到一个简单的三行输出，那就是默认的
    `prompt` 函数。
- en: 'Now to break down the function we wrote:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来解析我们编写的函数：
- en: First, you declare the function you are about to write. This is done using the
    keyword, `function`, followed by the name of the function. Since we want to work
    with the prompt, we use the existing function name so as to override the default
    functionality. The next thing that follows is the script block, which starts with
    a `{`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明你即将编写的函数。使用关键字 `function`，后跟函数的名称。由于我们想要处理提示符，所以使用现有的函数名称以覆盖默认的功能。接下来的内容是脚本块，它以
    `{` 开始。
- en: We want the location to appear at the prompt. This is a must-have information,
    for obvious reasons.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望位置能出现在提示符中。显而易见，这是必须包含的信息。
- en: If you notice, PowerShell shows the complete Home path at the prompt. While
    this works, we are used to the tilde for Home. Also, I know that Documents, Music
    and other folders reside within my Home folder, and I would rather have just the
    name of the folder appear at the prompt. This would mean some text manipulation.
    Therefore, I assign the current location to a variable, `$Location`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，PowerShell 在提示符处显示了完整的 Home 路径。虽然这样可以工作，但我们习惯于用波浪符（~）表示 Home。此外，我知道 Documents、Music
    和其他文件夹位于我的 Home 文件夹中，我更愿意在提示符处只显示文件夹的名称。这就需要一些文本操作。因此，我将当前路径赋值给一个变量，`$Location`。
- en: Next, we perform a switch-case operation and arrive at the value for what needs
    to be displayed at the prompt. Don't worry about the syntaxes for now; we will
    look into each of those in the chapters that follow.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行一个 switch-case 操作，并得到要在提示符中显示的值。现在先不担心语法问题，我们将在后续章节中详细讲解每一个。
- en: Later, we use a few `Write-Host` statements to construct the prompt text. The
    `-NoNewLine` parameter ensures that the contents of each statement do not go to
    the next line. When we need a line break, we explicitly add `` `n ``.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用几个 `Write-Host` 语句来构造提示符文本。`-NoNewLine` 参数确保每个语句的内容不会跳到下一行。当我们需要换行时，会显式添加
    `` `n ``。
- en: If you want to break a long-running line in a script, use the backtick (`` `
    ``) character at the point where you would like to break the line and press Enter
    to break the line after the backtick. PowerShell would treat the line with the
    backtick, as well as the line that follows, as the same line. Similarly, if you
    would like to write two statements in the same line, use the semicolon (`;`) at
    the end of the first statement, and continue with the second after a space. PowerShell
    will treat both the clauses as separate statements, just like plain English.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在脚本中断开一行较长的代码，请在希望换行的地方使用反引号（`` ` ``）字符，并按回车键进行换行。PowerShell 会将含有反引号的那一行与紧随其后的那一行视为同一行。同样，如果你希望在同一行编写两条语句，可以在第一条语句末尾使用分号（`;`），然后用空格继续写第二条语句。PowerShell
    会将这两条语句视为独立的语句，就像普通英语中的两个句子一样。
- en: Since `Write-Host` just sends text to the host, and does not return anything,
    we add a return statement to the function, with merely an empty space.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Write-Host` 只是将文本发送到主机，并不会返回任何内容，因此我们向函数中添加一个返回语句，仅返回一个空格。
- en: When we reload the PowerShell Integrated Console, the profile is loaded, and
    this time, the custom `prompt` function in the profile overrides the default `prompt`
    function, and presents us with a nice prompt, formatted just the way we defined.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新加载 PowerShell 集成控制台时，配置文件被加载，这时，配置文件中的自定义 `prompt` 函数会覆盖默认的 `prompt` 函数，并呈现我们定义的漂亮提示符。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: Play around with the sequences and the contents of the `Write-Host` statements
    for now to customise your prompt. Once we are comfortable with the syntaxes in
    PowerShell, we should be able to customise the profile further.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，先尝试修改 `Write-Host` 语句的序列和内容，以自定义你的提示符。等我们对 PowerShell 的语法熟悉后，应该能够进一步自定义配置文件。
- en: See also
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: '[about_Prompts](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_prompts?view=powershell-6)
    (Microsoft Documentation)'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[about_Prompts](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_prompts?view=powershell-6)（Microsoft
    文档）'
- en: Understanding standard redirection in PowerShell
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 PowerShell 中的标准重定向
- en: When I first started using the command line interface, I was daunted by `<`
    and `>` and `>>` at first. Then, I entirely stopped using the command line interface
    for a while and went back to the Windows administrator ways, albeit with an unusual-for-a-Windows-admin
    level of use of keyboard shortcuts (it's all about the speed and efficiency!).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次开始使用命令行界面时，`<`、`>` 和 `>>` 让我感到很困惑。然后，我完全停止使用命令行界面，转而回到了 Windows 管理员的方式，尽管在用键盘快捷键的频率上，达到了非同寻常的程度（这全是为了速度和效率！）。
- en: When PowerShell came along, I had forgotten about those operators; I simply
    went ahead and understood the concept of object and pipelines, and worked for
    years that way. Switching to Linux at home made me want to know the "Linux way"
    of using the terminal. The operators came back to haunt me. I simply installed
    PowerShell on Linux.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PowerShell 出现时，我已经忘记了那些操作符；我直接去理解对象和管道的概念，并且这样工作了多年。转到 Linux 后，我想了解在终端中使用“Linux方式”。这些操作符再次回到了我的面前。我干脆在
    Linux 上安装了 PowerShell。
- en: Redirection in PowerShell mainly relies on streams. And streams are covered
    in a different chapter. For now, we stick with the default stream, which is, `Success`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 中的重定向主要依赖于流。流的概念会在其他章节中讨论。现在，我们坚持使用默认流，即 `Success`。
- en: This recipe covers the different, simple redirections to help with basic administration.
    We shall come back to streams while understanding the concepts of error handling.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本操作涵盖了不同的、简单的重定向方法，帮助完成基本的管理任务。我们将在理解错误处理的概念时再回到流的部分。
- en: Before we begin, let us understand that PowerShell is very different from Bash
    in terms of redirection, although it packs some minor similarities; similarities
    enough to make you not go away, but rather appreciate the flexibility of the object
    model, and the uniformity of use.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，首先要理解，PowerShell 在重定向方面与 Bash 非常不同，尽管它有一些小的相似性；这些相似性足以让你不会离开，而是欣赏对象模型的灵活性和使用的一致性。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'We shall perform four activities in this recipe:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，我们将执行四个活动：
- en: Redirect output to a file
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出重定向到文件
- en: Append another output to the same file
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个输出追加到同一个文件中
- en: Send the output of a command to the console as well as a file
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令的输出发送到控制台和文件中
- en: Accept the input of one command into another
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个命令的输入接受到另一个命令中
- en: Apart from the operators that we use in the first two activities, we will also
    look at the cmdlet equivalents to those operators.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在前两个活动中使用的操作符外，我们还将查看这些操作符的 cmdlet 等价物。
- en: List out all the processes running on your computer at the moment.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前在你计算机上运行的所有进程。
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The output was shown on the console. Now, let us redirect the contents into
    a file.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出显示在控制台上。现在，让我们将内容重定向到文件中。
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: List out the contents of the file.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出文件的内容。
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let us now append the file with the date and time stamp.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将日期和时间戳追加到文件中。
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Read the contents of the file now.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在读取文件的内容。
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can see that the file now contains a list of all the processes running in
    the system, as well as the time stamp. The time stamp got *appended* to the file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到文件现在包含了系统中所有正在运行的进程的列表，以及时间戳。时间戳被*追加*到文件中了。
- en: When going the *PowerShell way*, the same results can be accomplished using
    the `Out-File` cmdlet. (`Out-File` has more features such as setting the encoding
    and new line control.) Let us accomplish the same tasks using the `Out-File` cmdlet.
    You may want to delete `processes.txt` before proceeding.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*PowerShell方式*时，可以通过 `Out-File` cmdlet 实现相同的结果。（`Out-File` 具有更多功能，如设置编码和换行控制。）让我们使用
    `Out-File` cmdlet 完成相同的任务。在继续之前，你可能需要删除 `processes.txt` 文件。
- en: Let us list out the currently-running processes again, and send the output to
    a file using `Out-File`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们再次列出当前运行的进程，并使用 `Out-File` 将输出发送到文件中。
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let us append the time stamp to the file.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将时间戳追加到文件中。
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you notice, the output of `Get-Process` and `Get-Date` went directly to the
    file; nothing got displayed on the host.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，`Get-Process` 和 `Get-Date` 的输出直接进入了文件；没有任何内容显示在主机上。
- en: If we want to display the output on the console as well as send the content
    to a file, we simply use `Tee-Object` instead of `Out-File`. If you would like,
    delete the file, `processes.txt` again.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想同时在控制台上显示输出并将内容发送到文件，我们只需使用 `Tee-Object` 替代 `Out-File`。如果你愿意，可以再次删除文件 `processes.txt`。
- en: Run the following command.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令。
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The list of running processes should be shown at the terminal.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的进程列表应该会显示在终端上。
- en: Check the contents of the file, `processes.txt`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件`processes.txt`的内容。
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the list of processes appears in the text file as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，进程列表也出现在了文本文件中。
- en: 'Let us now proceed with learning to make cmdlets accept input from files. Linux
    administrators are used to making commands accept input from a file, like so:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习如何让cmdlet接受来自文件的输入。Linux管理员习惯于让命令接受来自文件的输入，如下所示：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The command accepts input from `input_file.txt`, and performs operations on
    the input content.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令接受来自`input_file.txt`的输入，并对输入内容执行操作。
- en: 'In PowerShell, this is handled using `Get-Content` and the pipe (`|`). The
    PowerShell equivalent of a command accepting input from a file would be:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell中，这些操作通过`Get-Content`和管道符（`|`）来处理。PowerShell中接受来自文件输入的命令等价物是：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This might seem the other way around to most of those who are not used to PowerShell.
    Let us break down the process into pieces and try to understand it better. For
    instance, let us say you have a list of files in a text file called `input.txt`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉PowerShell的人来说，这可能看起来反过来了。让我们将过程分解成几部分，并试着更好地理解它。例如，假设你有一个名为`input.txt`的文本文件，其中列出了多个文件。
- en: Reveal the contents of the text file.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示文本文件的内容。
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](img/cfa87d64-fffb-4078-a37e-18d89fb00bae.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfa87d64-fffb-4078-a37e-18d89fb00bae.png)'
- en: List out the contents of the current directory.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前目录中的内容。
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have five test files in the current directory, four of which are in the list
    (the input file). Let us say that you would like to delete the files listed in
    the input file, from the directory.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在当前目录下有五个测试文件，其中四个在列表中（即输入文件）。假设你希望从目录中删除输入文件中列出的文件。
- en: Pass the output of `Get-Content` to the command, `Remove-Item`, through the
    pipe.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过管道将`Get-Content`的输出传递给命令`Remove-Item`。
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](img/f5ac1741-e892-4737-9bc2-842204050c21.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5ac1741-e892-4737-9bc2-842204050c21.png)'
- en: List out the files currently present in the directory.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前目录中存在的文件。
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Et voilà! If you compare the outputs of `ls` (before) and  `Get-ChildItem` (after);
    the files that were listed in the text file are no more.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 看！如果你比较`ls`（之前）和`Get-ChildItem`（之后）的输出，你会发现文本文件中列出的文件不再存在了。
- en: How it works...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we set out to understand the similarities between Bash and PowerShell.
    In spite of being fundamentally different from Bash, PowerShell does pack some
    similarities to Bash. Two of the similarities, as we saw, are passing content
    to files and appending content to the files.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们旨在理解Bash和PowerShell之间的相似之处。尽管PowerShell在本质上与Bash不同，但它确实有一些与Bash相似的地方。正如我们看到的那样，这些相似之处包括将内容传递到文件和向文件追加内容。
- en: We looked at three cmdlets in this recipe, one of which were used twice.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本教程中介绍了三个cmdlet，其中一个被使用了两次。
- en: Out-File
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Out-File
- en: Those comfortable with Bash use the `>` for sending the output to a file, and
    `>>` to append the output to an existing file. in PowerShell, we use the `Out-File`
    cmdlet. We run a command that sends output to the standard out, and through the
    pipe, redirect the output to `Out-File`, which handles writing the output to a
    file. Usually, `Out-File` is used to send content to a text file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉Bash的人通常使用`>`将输出发送到文件，使用`>>`将输出追加到已有文件。在PowerShell中，我们使用`Out-File` cmdlet。我们运行一个将输出发送到标准输出的命令，并通过管道将输出重定向到`Out-File`，由它负责将输出写入文件。通常，`Out-File`用于将内容发送到文本文件。
- en: When there is a need to append the content to a file, we use the `-Append` switch
    with `Out-File`. This way, if the file that is being written to already contains
    content, the content isn't overwritten (overwriting content is the default behaviour
    of `Out-File`).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将内容追加到文件时，我们使用`-Append`开关与`Out-File`配合使用。这样，如果正在写入的文件已经包含内容，新的内容就不会覆盖原有内容（覆盖内容是`Out-File`的默认行为）。
- en: Tee-Object
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tee-Object
- en: There are situations wherein you need to send content to a file, as well as
    display the content on the console. This is handled using a simple call of `Tee-Object`.
    `Tee-Object` works like the letter T; apart from sending content to a file or
    a variable, it also sends the content down the pipeline. In case `Tee-Object`
    is the last cmdlet in the statement, the pipeline output is sent out to standard
    out, which in most cases is the host (or in other words, the console by default).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要将内容发送到文件，并同时在控制台上显示该内容。这可以通过简单地调用`Tee-Object`来实现。`Tee-Object`像字母T一样，除了将内容发送到文件或变量，它还将内容传递到管道中。如果`Tee-Object`是语句中的最后一个cmdlet，那么管道的输出会发送到标准输出，这通常是主机（或者换句话说，默认是控制台）。
- en: In our recipe, we sent the first output to the file, `processes.txt`, and the
    second output was not sent down the pipeline. Therefore, `Tee-Object` picked the
    standard out.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们将第一部分输出发送到文件 `processes.txt`，第二部分输出没有通过管道传递。因此，`Tee-Object` 捕捉到了标准输出。
- en: Accepting input from file
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受来自文件的输入
- en: This process is significantly different in PowerShell, compared to Bash. In
    Bash, we call the command first, and then ask it to accept input from a file.
    In PowerShell, we make PowerShell read the contents of the input file first, and
    then send the output to the command that accepts input through the pipeline.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，这个过程与 Bash 有显著的不同。在 Bash 中，我们先调用命令，然后让它接受来自文件的输入。在 PowerShell
    中，我们先让 PowerShell 读取输入文件的内容，然后通过管道将输出发送到接受输入的命令。
- en: In our recipe, we read the contents of the file, `input.txt`, which contained
    a list of four file names. We used `Get-Content` to read the content from the
    file. `Get-Content` sent the output to the standard out at first, thereby showing
    us the contents of the file. We then added a pipe to tell PowerShell that we need
    further processing, and then, added `Remove-Item` to the command chain. (`Remove-Item`
    deletes items, which could be directories, files or links.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们读取了文件 `input.txt` 的内容，它包含了四个文件名的列表。我们使用 `Get-Content` 来读取文件内容。`Get-Content`
    最初将输出发送到标准输出，显示文件的内容。然后我们加了一个管道，告诉 PowerShell 需要进一步处理，然后在命令链中加入了 `Remove-Item`。(`Remove-Item`
    删除项，可以是目录、文件或链接。)
- en: As we would see later in this chapter, the first parameter (positional parameter,
    position 1) of `Remove-Item` is `Path`, which is also the parameter that accepts
    input through the pipeline. For more information, run the following command and
    read about the `Path` parameter of `Remove-Item`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章后面将看到的，`Remove-Item` 的第一个参数（位置参数，第 1 位）是 `Path`，它也是通过管道接受输入的参数。有关更多信息，请运行以下命令并阅读
    `Remove-Item` 的 `Path` 参数。
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](img/b1fcf9d5-5153-4ba2-a432-5bbcb8028f80.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1fcf9d5-5153-4ba2-a432-5bbcb8028f80.png)'
- en: There's more...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Clean up the contents that we created for this recipe if you are the type that
    likes directories clean! If we need more files or directories in later recipes,
    we will create them as needed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是喜欢保持目录整洁的人，请清理我们为此配方创建的内容！如果以后需要更多的文件或目录，我们会根据需要创建它们。
- en: See also
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: Recipe 3.8: Understanding cmdlets and parameters
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方 3.8：理解 cmdlet 和参数
- en: 'Recipe 1.6: Looking for help information specific to a parameter'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方 1.6：查找特定于参数的帮助信息
- en: Calling native Linux commands from PowerShell
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 PowerShell 调用本地 Linux 命令
- en: In the chapter, *Introducing the Core and its Capabilities*, we saw how native
    Linux commands were not convenience aliases in PowerShell on Linux, but the commands
    themselves. In this recipe, we would demonstrate using Linux commands at the PowerShell
    prompt. Remember how we used a Bash terminal to run the commands `ls -l` and `awk`
    to list the contents of a directory, and separate the columns in the output, in
    the recipe, *Comparing the outputs of Bash and PowerShell*. We will perform the
    same operation on the home directory, from with PowerShell, without using any
    of the PowerShell cmdlets.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，*介绍核心及其功能*，我们看到本地 Linux 命令在 Linux 上的 PowerShell 中并不是方便的别名，而是命令本身。在这个配方中，我们将演示如何在
    PowerShell 提示符下使用 Linux 命令。记得我们在配方 *比较 Bash 和 PowerShell 输出* 中，如何使用 Bash 终端运行命令
    `ls -l` 和 `awk` 来列出目录的内容，并将输出中的列分开吗？我们将不使用任何 PowerShell cmdlet，在 PowerShell 中执行同样的操作，操作对象是主目录。
- en: Getting started
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: It is recommended that you have a Windows PC with PowerShell installed on it
    (Windows PowerShell would also do) in order to compare the outputs and see if
    we encounter any errors.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你使用一台安装了 PowerShell 的 Windows PC（Windows PowerShell 也可以），以便比较输出并查看是否遇到任何错误。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: At the PowerShell prompt, type in the following command to list the contents
    of the directory.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 提示符下，键入以下命令以列出目录内容。
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You see the familiar output (albeit without any of the colours, if your terminal
    emulator uses colours for file names).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到熟悉的输出（如果你的终端模拟器为文件名使用颜色，输出将没有颜色）。
- en: Let us now look at the .NET Type Name of the output. For this, we would need
    to use the `Get-Member` cmdlet.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看输出的 .NET 类型名称。为此，我们需要使用 `Get-Member` cmdlet。
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'PowerShell displays, `TypeName: System.String`, which is consistent with what
    we saw in the aforementioned recipe.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'PowerShell 显示 `TypeName: System.String`，这与我们在前述配方中看到的结果一致。'
- en: If you have a Windows PC with PowerShell (or Windows PowerShell), run the same
    command on it.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一台带有 PowerShell（或 Windows PowerShell）的 Windows PC，运行相同的命令。
- en: '[PRE44]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice the .NET Type Name here; it is `System.IO.DirectoryInfo`, and if you
    scroll down the console a little, you would also see `System.IO.FileInfo`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的 .NET 类型名称；它是 `System.IO.DirectoryInfo`，如果你稍微滚动控制台，你还会看到 `System.IO.FileInfo`。
- en: 'Next, at the PowerShell on Windows (or Windows PowerShell) prompt, type:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 Windows 上的 PowerShell（或 Windows PowerShell）提示符下，键入：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You would receive an error, stating that there was no value given to the parameter,
    `LiteralPath`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你会收到一个错误，提示没有为参数 `LiteralPath` 提供值。
- en: '![](img/d565f397-477e-4b86-9518-f45d18ed8ab4.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d565f397-477e-4b86-9518-f45d18ed8ab4.png)'
- en: At the PowerShell prompt on the Windows PC, enter the following and press the
    Tab key on your keyboard, instead of Enter.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows PC 的 PowerShell 提示符下，键入以下内容并按下 Tab 键，而不是 Enter 键。
- en: '[PRE46]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You would see that the parameter name was completed to `LiteralPath`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到参数名称被补全为 `LiteralPath`。
- en: Press the Esc key to clear the command line.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 Esc 键清除命令行。
- en: 'Come back to Linux, and at the PowerShell prompt, type in the following and
    press the Tab key:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 Linux，在 PowerShell 提示符下，键入以下内容并按下 Tab 键：
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Nothing happens. Now, enter the following and press the Tab key:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么也没有发生。现在，输入以下内容并按下 Tab 键：
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The parameter name was completed to `-LiteralPath`. Let us take one more step
    and conclude this recipe.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称被补全为 `-LiteralPath`。让我们再进一步，完成这个过程。
- en: At the PowerShell prompt on Windows, run the following command.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 上的 PowerShell 提示符下，运行以下命令。
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![](img/91a6d14f-bbab-406c-8212-2285ff34399e.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91a6d14f-bbab-406c-8212-2285ff34399e.png)'
- en: Switch back to Linux and run the same command.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回 Linux 并运行相同的命令。
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You receive an error stating that there is no such alias.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你会收到一个错误，提示没有这样的别名。
- en: '![](img/75f2ffac-79de-4a70-af27-a3f0ade44b63.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75f2ffac-79de-4a70-af27-a3f0ade44b63.png)'
- en: How it works...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we run any of the Linux commands on PowerShell on Linux, PowerShell does
    not call the convenience aliases that were created for the benefit of Linux administrators,
    when Windows PowerShell was launched; these convenience aliases have not been
    included in PowerShell on Linux. PowerShell, instead, runs the actual Linux commands
    and shows the output on the console. Piping the output to other Linux commands
    work the same way as they do on Bash, when running them on PowerShell on Linux.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Linux 上的 PowerShell 上运行任何 Linux 命令时，PowerShell 不会调用为 Linux 管理员创建的便利别名，这些别名是在
    Windows PowerShell 启动时为 Linux 管理员的便利而创建的；这些便利别名没有包含在 Linux 上的 PowerShell 中。PowerShell
    会运行实际的 Linux 命令，并在控制台上显示输出。将输出管道传输到其他 Linux 命令的工作方式与在 Bash 上运行时相同。
- en: The first point to note is that `ls -l` is an actual command in Linux, and it
    returns the list of files and directories in the current directory, in a table
    format. When the same command is run on PowerShell on Windows, we receive an error,
    since PowerShell on Windows interprets `ls` as `Get-ChildItem`, and `-l` as the
    incomplete-but-definitive call to `-LiteralPath` and returns an error that the
    literal path was not specified.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点需要注意的是，`ls -l` 是 Linux 中的一个实际命令，它会以表格格式返回当前目录中的文件和目录列表。当在 Windows 的 PowerShell
    上运行相同的命令时，我们会收到一个错误，因为 PowerShell 在 Windows 上将 `ls` 解释为 `Get-ChildItem`，并将 `-l`
    解释为不完整但确定的 `-LiteralPath` 调用，返回一个错误，说明没有指定字面路径。
- en: When we run `Get-Alias` on `ls` on both the operating systems, PowerShell on
    Linux returns an error, while PowerShell on Windows shows the underlying PowerShell
    cmdlet.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在两个操作系统上对 `ls` 运行 `Get-Alias` 时，Linux 上的 PowerShell 会返回一个错误，而 Windows 上的
    PowerShell 会显示底层的 PowerShell cmdlet。
- en: The other point that pins down this fact is that the output of `ls` is string,
    as opposed to a system object, when the same `ls` is run on PowerShell on Windows.
    On Windows, PowerShell calls `Get-ChildItem` under the hood, and the output shown
    is that of `Get-ChildItem`. This is supported by the type name in the output of
    `Get-Member`, which is from the `System.IO` namespace. On the other hand, on Linux,
    running `Get-Member` on the output of `ls` simply returns `System.String`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个证实这一事实的点是，`ls` 的输出在 Windows 上的 PowerShell 中是字符串，而不是系统对象。当在 Windows 上的 PowerShell
    中运行相同的 `ls` 时，PowerShell 会在后台调用 `Get-ChildItem`，显示的输出就是 `Get-ChildItem` 的输出。这可以通过
    `Get-Member` 输出中的类型名称得到支持，该名称来自 `System.IO` 命名空间。另一方面，在 Linux 上，运行 `Get-Member`
    获取 `ls` 输出时，返回的仅是 `System.String`。
- en: See also
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: '[about_Aliases](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases?view=powershell-6)
    (Microsoft documentation)'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[关于别名](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases?view=powershell-6)（Microsoft
    文档）'
- en: Understanding cmdlets and parameters
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解cmdlet和参数
- en: Most of our scripting and administration is going to revolve around running
    cmdlets and chaining them. In some situations, we run a cmdlet expecting it to
    work a certain way, only to find out that the cmdlet threw an error, or worse,
    did something undesirable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分脚本编写和管理工作将围绕着运行cmdlet并将它们串联起来进行。在某些情况下，我们运行一个cmdlet时，期待它按某种方式工作，但却发现它抛出了错误，或者更糟的是，做了某些我们不希望它做的事情。
- en: The key to getting cmdlets to do what we want them to do is  to eliminate ambiguity.
    In this recipe, we will learn to construct commands contextually and effectively.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 获取cmdlet按预期工作的方法是消除歧义。在本教程中，我们将学习如何在特定上下文中有效构建命令。
- en: Getting Ready
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Read the Help section of the first chapter, *Installation, Reference and Help*.
    Let us understand the notifications used in the help information that `Get-Help`
    shows.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读第一章的帮助部分，*安装、参考和帮助*。让我们理解`Get-Help`显示的帮助信息中的通知内容。
- en: While this may not be an exhaustive guide to using help, it should cover most
    of your daily help document reading needs. The idea is to show you the notations.
    These notations may appear in several combinations (parameter values in curly
    braces, surrounded by square brackets, for example).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能不是一本全面的帮助使用指南，但它应该涵盖你日常阅读帮助文档的大部分需求。其目的是向你展示符号。这些符号可能会以多种组合形式出现（例如，参数值用大括号括起来，并用方括号包围）。
- en: '| **Notation** | **Meaning** |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **含义** |'
- en: '| `-Parameter <DataType>` | No square brackets: Mandatory parameter, named.
    The parameter must be called by name, and a value of DataType must be specified.
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `-Parameter <DataType>` | 无方括号：必需的命名参数。必须通过名称调用该参数，并指定一个DataType类型的值。 |'
- en: '| `[-Parameter <DataType>]` | Square brackets around the parameter-data-type-pair:
    Optional parameter, although, it must be called by name, and a value of DataType
    must be passed. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `[-Parameter <DataType>]` | 参数-数据类型对周围有方括号：可选参数，尽管必须通过名称调用该参数，并且必须传递一个DataType类型的值。
    |'
- en: '| `[-Parameter] <DataType>` | Square brackets around the parameter name: Positional
    parameter. You can simply pass a value of DataType to the cmdlet, as long as the
    value is at the position shown by the parameter in the help text. The parameter
    need not be called by name as long as the position is right. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `[-Parameter] <DataType>` | 参数名称周围有方括号：位置参数。你只需将一个DataType类型的值传递给cmdlet，只要该值位于帮助文本中所示的参数位置。只要位置正确，参数不必按名称调用。
    |'
- en: '| `[[-Parameter] <DataType>]` | Square brackets around the parameter name,
    and another pair of square brackets around the parameter-data-type-pair: Positional
    parameter, which is optional. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `[[-Parameter] <DataType>]` | 参数名称周围有方括号，参数-数据类型对周围有另一对方括号：位置参数，是可选的。 |'
- en: '| `-Parameter <DataType[]>` | Square brackets after DataType: Multi-valued
    parameter. This parameter accepts multiple values as input, each pair of values
    separated by a comma. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `-Parameter <DataType[]>` | DataType后面有方括号：多值参数。该参数接受多个值作为输入，每对值之间用逗号分隔。
    |'
- en: '| `-Parameter` | No data type: Switch parameter. Calling the parameter makes
    the switch $true, and not calling it uses the default value for the switch. To
    disable the switch, set it to false, like -Parameter:$false. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `-Parameter` | 无数据类型：开关参数。调用该参数时开关为$true，不调用时使用开关的默认值。要禁用该开关，将其设置为false，如-Parameter:$false。
    |'
- en: '| `-Parameter {Value1 &#124; Value2 &#124; Value3}` | Values surrounded by
    curly braces: Parameter that accepts predefined values as input. In this case,
    you would call the parameter like `-Parameter Value1`, or `-Parameter Value2`.
    In other words, this parameter does not accept arbitrary values. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `-Parameter {Value1 &#124; Value2 &#124; Value3}` | 值用大括号括起来：接受预定义值作为输入的参数。在这种情况下，你可以像`-Parameter
    Value1`或`-Parameter Value2`一样调用该参数。换句话说，该参数不接受任意值。 |'
- en: 'Bash champions take note: PowerShell needs a comma separating the values in
    a multi-valued parameter. Therefore, if you would like to call `Remove-Item` on
    three files, you would enter `Remove-Item file1, file2, file3`. If only a space
    separates the values (like Bash''s input), PowerShell will consider the three
    values as values to three positional parameters, and would either throw an error,
    or do something you did not want it to, based on the cmdlet you call.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Bash高手注意：PowerShell需要用逗号分隔多值参数中的值。因此，如果你想对三个文件使用`Remove-Item`，你应该输入`Remove-Item
    file1, file2, file3`。如果只有空格分隔这些值（如Bash的输入），PowerShell会将这三个值视为三个位置参数的值，并可能会抛出错误，或者根据你调用的cmdlet做出你不希望的操作。
- en: In general, anything surrounded by square brackets is optional. Anything surrounded
    by curly braces indicates predefined parameter values (the pipe separates each
    value). Data type followed by an empty pair of square brackets indicate array
    of that data type. And the position of the parameter is to be noted.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，方括号括起来的内容是可选的。大括号括起来的内容表示预定义的参数值（管道符分隔每个值）。数据类型后面跟着一对空的方括号表示该数据类型的数组。参数的位置也需要注意。
- en: 'Notice the combination: `Required` is false, there is a default value as shown
    in the text below the parameter name, and the position is `1`. This means that
    you can simply call the cmdlet, and it would run itself against the default value
    for its first parameter. The example used here is `Get-ChildItem`.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个组合：`Required`为假，下面参数名称的文本中显示了默认值，位置为`1`。这意味着你只需要调用 cmdlet，它就会根据第一个参数的默认值自动运行。此处使用的例子是`Get-ChildItem`。
- en: How to do it...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: That was a long getting ready section. Let us now put this knowledge to use.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个漫长的准备过程。现在，让我们将这些知识付诸实践。
- en: Run a command to get a list of files and directories in the current location.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令以获取当前路径下的文件和目录列表。
- en: '[PRE51]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Let us now add a `.` to indicate the current location.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个`.`来表示当前目录。
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Compare the outputs of the last two commands.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较最后两个命令的输出。
- en: 'Next, let us go with the following:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们继续执行以下操作：
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Is the output the same as that of the last two commands?
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是否与最后两个命令的输出相同？
- en: 'Run the following and note the values for each of the keys below:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，并记录每个键的值：
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Next, create a file in the current location, called `file1` by calling the parameter
    by name.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在当前路径下创建一个名为`file1`的文件，按名称调用该参数。
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We have two possibilities: `Path` and `Name`. Look for information on `Path`.'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有两个选择：`Path`和`Name`。查找有关`Path`的信息。
- en: '[PRE56]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If we use `Name`, we have to call it by name (no pun intended). If not, we can
    specify the name as part of `Path` (no alliteration intended either).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`Name`，必须按名称调用它（没有恶搞的意思）。如果不这样做，我们可以将名称作为`Path`的一部分来指定（也没有故意重复的意思）。
- en: Let us use `Path` first. “`-Path`” need not be written, since it is a positional
    parameter.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用`Path`。不需要写“`-Path`”，因为它是位置参数。
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Try the same operation with `Name`. This time, mention the parameter name.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用`Name`进行相同的操作。这次，指定参数名称。
- en: '[PRE58]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you would like, create a third file, by calling `Path` by name.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，可以创建一个第三个文件，通过指定`Path`的名称来创建。
- en: '[PRE59]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: List out the contents of the current location.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前路径的内容。
- en: '[PRE60]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The files are present.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 文件已存在。
- en: Let us now delete the files.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们删除文件。
- en: '[PRE61]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Mention the file names as paths.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件名作为路径提及。
- en: '[PRE62]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: List the contents of the directory.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出目录内容。
- en: '[PRE63]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, let us delete multiple files in one shot. And this time, let us call the
    parameter by name.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们一次删除多个文件。此次，我们按名称调用参数。
- en: '[PRE64]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Let us now create a directory. We need to use parameter called ItemType, which
    has predefined values, based on the provider (we are using `FileSystem`).
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个目录。我们需要使用一个名为 ItemType 的参数，该参数具有预定义的值，具体取决于提供者（我们使用的是`FileSystem`）。
- en: '[PRE65]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create three new files like so:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样创建三个新文件：
- en: '[PRE66]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, let us delete the contents. Wait for a confirmation prompt to appear after
    running the command.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们删除内容。在运行命令后，等待出现确认提示。
- en: '[PRE67]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Read the prompt. It talks something of the `Recurse` parameter.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读提示信息。它提到`Recurse`参数的一些内容。
- en: Choose `L` and press Enter to abort the process.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`L`并按回车键以中止该过程。
- en: 'Now, enter the following command:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入以下命令：
- en: '[PRE68]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: That was quiet! List out the contents of the current directory to ensure `test-dir`
    is gone.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安静了一会儿！列出当前目录的内容，确保`test-dir`已经删除。
- en: '[PRE69]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The directory is indeed gone.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 目录确实已删除。
- en: How it works...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Working with cmdlets is simple. There are two kinds of parameters: named and
    positional.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cmdlets 非常简单。参数有两种类型：命名参数和位置参数。
- en: Positional parameters work based on the position. They are programmed in such
    a way that PowerShell understands their logical sequence and performs its actions.
    For instance, when moving items, the general way of working is to call the command,
    pass the source first and then the destination.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数基于其位置工作。它们的编程方式使得 PowerShell 可以理解它们的逻辑顺序并执行相应操作。例如，在移动项目时，通常的操作流程是先调用命令，传入源路径，然后再传入目标路径。
- en: 'Therefore:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: '[PRE70]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: would mean that you want to move the directory, `GitHub` to `Code`. Many PowerShell
    cmdlets are programmed to understand this.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你想要将目录`GitHub`移动到`Code`。许多 PowerShell cmdlet 都是按照这种方式编程的，能够理解这一操作。
- en: Named parameters, on the other hand, are to be called by name. Help text shows
    them without any brackets surrounding them. Calling the positional parameters
    by name is optional—you are allowed to simply pass the values. However, be careful
    with what position or sequence you mention them in.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数则需要通过名称来调用。帮助文本显示时不会有任何括号包围它们。通过名称调用位置参数是可选的——你可以直接传递值。不过，请小心你在调用时提到的位置或顺序。
- en: The best practice is to always pass parameter values, calling them by name when
    writing scripts. When running quick commands, on the other hand, you may omit
    calling positional parameters by name in the interest of speed.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是在编写脚本时始终传递参数值，通过名称调用它们。另一方面，当运行快速命令时，可以为了速度而省略通过名称调用位置参数。
- en: Some parameters have predefined value validation added to them. These parameters
    accept only those values that have been defined in them. For instance, `ItemType`
    only accepts `File`, `Directory`, `SymbolicLink`, `Junction` and `HardLink` as
    values as of writing this section.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数已添加预定义的值验证。这些参数只接受已经定义的值。例如，`ItemType` 只接受 `File`、`Directory`、`SymbolicLink`、`Junction`
    和 `HardLink` 作为值（截至本节撰写时）。
- en: And then, there are switch parameters. `Recurse` is an example. When you call
    these parameters with no value, the parameters assume `True` in most cases. When
    you have to set them to `False`, you mention, `-Parameter:$false` (for example,
    `-Confirm:$false`). If you do not call the switch parameter, the parameter goes
    with the default value specified in the cmdlet.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有开关参数。`Recurse` 就是一个例子。当你调用这些参数且没有传值时，在大多数情况下，参数默认为 `True`。当你需要将它们设置为 `False`
    时，可以这样写：`-Parameter:$false`（例如，`-Confirm:$false`）。如果你没有调用开关参数，则参数会使用 cmdlet 中指定的默认值。
- en: There's more
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: If you would like to create the files and directories again, don't run four
    commands. Run the following two.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想重新创建文件和目录，不需要运行四个命令。运行以下两个命令即可。
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The parameter, Force, creates `test-dir` when creating `child-dir`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 Force 在创建 `child-dir` 时会创建 `test-dir`。
- en: Go ahead and delete the entire directory if you want to, without the `Recurse`
    parameter. At the confirmation prompt, press Enter (`Y` is the default response).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想的话，继续删除整个目录，不需要 `Recurse` 参数。在确认提示时，按 Enter（`Y` 是默认的响应）。
- en: Running cmdlets with minimal keystrokes
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最少按键运行 cmdlet
- en: Commands have been made to be short, historically. However, the situation turned
    into a dilemma over time, since shorter commands meant that they had to be remembered,
    and longer commands meant more keystrokes.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 命令历史上被设计得很简短。然而，随着时间的推移，情况变成了一个两难的境地，因为简短的命令意味着它们需要记住，而更长的命令则意味着更多的按键操作。
- en: 'PowerShell has long commands, however, it deals with them in two ways:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 有很长的命令，但它通过两种方式来处理它们：
- en: Aliases, which tend to be shorter.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 别名，通常比较短。
- en: Tab completion, which require more keystrokes than aliases, but don't require
    remembering much.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制表符自动完成，虽然比别名需要更多按键，但不需要记住太多内容。
- en: The first way necessitates using our memory to recall command names as required.
    The second, on the other hand, solves the keystroke issue efficiently.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方式需要我们利用记忆来回忆命令名称。而第二种方式则有效地解决了按键次数问题。
- en: Bash users are used to getting a list of matches laid out in a nice tabular
    format when the tab key matches more than one strings in the context. On the other
    hand, the matches cycle at the cursor in Windows (which most Bash users find "weird").
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 用户习惯于在制表符匹配到多个字符串时，看到以整齐的表格形式列出的匹配项。而在 Windows 中，匹配项则会在光标处循环显示（大多数 Bash
    用户认为这是“奇怪”的）。
- en: Be that as it may, tab completion is a boon, and this recipe makes complete
    use of tab completion and simple string matching to significantly reduce keystrokes
    when using PowerShell cmdlets.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，制表符自动完成仍然是一个福音，这个技巧充分利用了制表符自动完成和简单的字符串匹配，大大减少了使用 PowerShell cmdlet 时的按键次数。
- en: Getting Ready
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We use the Gnome Terminal terminal emulator for this recipe, and tab completion
    on PowerShell on Linux on Gnome Terminal behaves exactly the same way that it
    works on Bash on Gnome Terminal:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本教程中使用 Gnome Terminal 终端仿真器，PowerShell 在 Gnome Terminal 上的制表符自动完成功能表现与 Bash
    在 Gnome Terminal 上的完全相同：
- en: If only one word matches the string before the tab, the word is completed.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只有一个单词与制表符前的字符串匹配，则该单词会被完成。
- en: If multiple words match the string before the tab, all possible options are
    listed.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个单词与制表符前的字符串匹配，所有可能的选项都会列出。
- en: If you are using VS Code for this recipe, or a different terminal emulator,
    its behaviour may be different.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 VS Code 或其他终端模拟器，它的行为可能会有所不同。
- en: How to do it...
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: Let us get right to it!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始吧！
- en: Say, we would like to get the list of files and directories within the current
    directory.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，我们希望获取当前目录中的文件和目录列表。
- en: 'The right way of doing this, as per best practices would be:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照最佳实践，正确的做法应该是：
- en: '[PRE72]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'However, as we''ve seen before, the easy way of doing this would be:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，正如我们之前所看到的，做这件事的简便方法是：
- en: '[PRE73]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We would use the former way when including the cmdlet in a script. This avoids
    ambiguity, in most contexts that the script would run in. This usually means minimal
    bugs. The latter, on the other hand, is the short way of running the same cmdlet,
    by leveraging the user-friendly features of it, combined with the awareness of
    the environment as an intelligent human. This approach significantly reduces key
    strokes–three characters, as opposed to twenty-one.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 cmdlet 包含到脚本中时，我们会使用前一种方式。这可以避免在大多数脚本运行的环境中产生歧义，通常意味着最小的 bug。后一种方式，则是通过利用其用户友好的功能，并结合作为智能人的环境意识，运行相同
    cmdlet 的快捷方式。这种方式显著减少了击键次数——仅三个字符，而不是二十一个。
- en: Although, if you are writing a script and would like to reduce keystrokes, you
    could still do it, without having to remember things such as `gpv` means `Get-ItemPropertyValue`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，如果你正在编写脚本并希望减少击键次数，你仍然可以这么做，而不需要记住诸如 `gpv` 代表 `Get-ItemPropertyValue` 之类的内容。
- en: 'Enter: Tab completion.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：Tab 补全。
- en: 'Follow the keystrokes mentioned below:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请按照以下击键操作：
- en: '[PRE74]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Those were ten keystrokes including <Enter>.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 那是十次击键，包括 <Enter>。
- en: There may be situations wherein you would need to call a named parameter. And
    the named parameter might be long.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一些情况，你需要调用命名参数。而命名参数可能会很长。
- en: Find a command that has `ComputerName` as a parameter.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个命令，其参数包含 `ComputerName`。
- en: '[PRE75]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This completes to:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完成为：
- en: '[PRE76]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![](img/c624b608-e1c3-4cae-91db-beeec2cef223.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c624b608-e1c3-4cae-91db-beeec2cef223.png)'
- en: 'But it throws an error. The error says, `Possible matches include: -ParameterName
    -ParameterType`. This is the caveat in PowerShell on Linux. Let us try again:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '但是它抛出了一个错误。错误信息显示：`Possible matches include: -ParameterName -ParameterType`。这是
    Linux 上 PowerShell 的一个特殊问题。让我们再试一次：'
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![](img/e5f9420d-d558-4df5-957a-64e2e050e962.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5f9420d-d558-4df5-957a-64e2e050e962.png)'
- en: Read the list of possibilities and select `ParameterName`.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读可能的选项并选择 `ParameterName`。
- en: '[PRE78]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The complete resolution of that would be:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的解析结果是：
- en: '[PRE79]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: And it worked.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它成功了。
- en: Next, let us suspend the activity in our session for, say, five seconds. The
    cmdlet for this would be `Start-Sleep`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们暂停会话中的活动，例如暂停五秒钟。实现这一点的 cmdlet 是 `Start-Sleep`。
- en: Let us first get help on the cmdlet.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先查看 cmdlet 的帮助。
- en: '[PRE80]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The help text says that the parameter at position one, which need not be named
    is `Seconds` (square brackets around Seconds in the second parameter set), and
    it accepts integer values.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助文本显示，位置为一的参数（不必命名）是 `Seconds`（第二组参数中的 `Seconds` 周围有方括号），并且它接受整数值。
- en: 'Therefore, to suspend the session for five seconds, we would use:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，要暂停会话五秒钟，我们将使用：
- en: '[PRE81]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If we wanted the session (or script) suspended for 100 milliseconds, we would
    need to use the named `Milliseconds` parameter. With tab completion, it would
    be:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们希望会话（或脚本）暂停 100 毫秒，我们需要使用命名的 `Milliseconds` 参数。通过 Tab 补全，代码将会是：
- en: '[PRE82]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Which would resolve to:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解析为：
- en: '[PRE83]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You can, in fact, reduce the number of tabs when using parameter names. Just
    type enough for PowerShell to uniquely identify the parameter name:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事实上，在使用参数名称时，你可以减少 Tab 键的次数。只需要输入足够的字符，PowerShell 就能唯一识别该参数名称：
- en: '[PRE84]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Which would resolve to:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解析为：
- en: '[PRE85]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If the delay was not noticeable, feel free to increase the number a little (say,
    3000).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果延迟不明显，可以适当增加数字（例如，3000）。
- en: How it works...
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理是……
- en: We have already seen how to use aliases. Aliases work just like normal cmdlets,
    including the syntax of their parameters. The only catch is that we have to remember
    the aliases. Custom aliases, as shall see in the best practices section, are a
    bad idea given that the aliases have to be imported everywhere we want to run
    scripts that have custom aliases.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用别名。别名的工作方式与正常的 cmdlet 相同，包括它们的参数语法。唯一需要注意的是，我们必须记住这些别名。自定义别名，如我们将在最佳实践部分中看到的，由于别名必须在我们运行包含自定义别名的脚本的地方导入，因此它们并不推荐使用。
- en: Tab completion on the other hand, reduces the number of keystrokes, but requires
    muscle memory. It requires some level of practice, given which, significantly
    improves productivity.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 而另一方面，tab 完成减少了按键次数，但需要肌肉记忆。只要有一定的练习，这会显著提高生产力。
- en: 'Tab completion works when writing cmdlets, writing parameter names, as well
    as when passing pre-defined values to parameters, such as:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Tab 完成在编写 cmdlet、编写参数名称以及向参数传递预定义值时有效，例如：
- en: '[PRE86]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Which completes to:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这会完成为：
- en: '[PRE87]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In many situations, it is not necessary to use tab completion at all, for instance,
    in the case of `Start-Sleep`. There is no parameter that starts with `m` in case
    of the cmdlet. Therefore, using `-m` was sufficient for PowerShell to uniquely
    identify `-Milliseconds`. That saved us the `<Tab>` keystroke as well.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，根本不需要使用 tab 完成，例如在 `Start-Sleep` 的情况下。此 cmdlet 没有任何以 `m` 开头的参数。因此，使用
    `-m` 已足够让 PowerShell 唯一识别 `-Milliseconds`。这样也省去了 `<Tab>` 的按键。
- en: Productivity with respect to writing scripts in PowerShell is a skill that comes
    with practice. While aliases sure are a shortcut to speed, they have their perils.
    On the other hand, using the keyboard to write scripts helps with muscle memory,
    which not only helps us think in PowerShell, it also helps speeding up tab completion,
    which works equally well when running commands at the console, or writing scripts.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中编写脚本的生产力是一项随着练习而提高的技能。虽然别名确实是加速的捷径，但也有其危险性。另一方面，使用键盘编写脚本有助于肌肉记忆，这不仅能帮助我们以
    PowerShell 的方式思考，还能加速 tab 完成，无论是在控制台运行命令还是编写脚本时，它都同样有效。
- en: Using short parameter names is generally not a good practice while scripting;
    use these with a similar caution as aliases. Short parameter names affect readability,
    and also, might break scripts at some point in future. For instance, if you call
    a certain cmdlet in a script, with a short parameter name `-comp`, which at the
    time of the creation of the script, stood only for `ComputerName`. Later, imagine
    the cmdlet received an update with an added parameter, `-CompatibilityMode`; this
    would break the script that you wrote.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写脚本时，一般不建议使用短参数名；使用时应像别名一样谨慎。短参数名影响可读性，而且在未来某个时刻可能会导致脚本出错。例如，如果你在脚本中调用某个 cmdlet，使用了一个短参数名
    `-comp`，而该参数名在脚本创建时仅代表 `ComputerName`。后来，假设该 cmdlet 更新并添加了一个新的参数 `-CompatibilityMode`，这就会导致你写的脚本无法运行。
- en: There's more...
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Try to type most commonly used cmdlets along with the parameters to practice
    tab completion.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入最常用的 cmdlet 和参数，来练习 tab 完成。
- en: Get familiar with VS Code by typing the cmdlets in the script pane. Notice how
    cmdlet, parameter and parameter value completion work in VS Code. If you prefer
    completion to work the same way as at the console, refer my custom settings JSON
    in the book’s GitHub repository.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在脚本窗格中输入 cmdlet 来熟悉 VS Code。注意，VS Code 中 cmdlet、参数和参数值的完成是如何工作的。如果你希望完成方式与控制台一样，请参考我在本书
    GitHub 仓库中的自定义设置 JSON。
- en: Finding parameter aliases
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找参数别名
- en: We worked with aliases for cmdlets, we saw how to uniquely identify parameter
    names without having to type the entire parameter name, and we also looked at
    leveraging the power of tab completion.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理了 cmdlet 的别名，看到如何唯一识别参数名，而不必输入完整的参数名，我们还探讨了如何利用 tab 完成的强大功能。
- en: To complete the cycle, let us also look at parameter aliases.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们也来看看参数别名。
- en: As you may have guessed, parameter aliases work very similar to cmdlet aliases.
    The primary goal of these aliases is to reduce keystrokes.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，参数别名的工作方式与 cmdlet 别名非常相似。这些别名的主要目标是减少键盘输入。
- en: Parameter aliases are not documented in a friendly way, however, can be easily
    found thanks to the object-oriented model of PowerShell. In this recipe, we shall
    look at how to fetch parameter aliases.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 参数别名没有以友好的方式记录，但得益于 PowerShell 的面向对象模型，仍然可以轻松找到。在本食谱中，我们将看看如何获取参数别名。
- en: Getting Ready
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Find all the commands that take in `ComputerName` as a parameter, with minimal
    keystrokes.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 查找所有使用 `ComputerName` 作为参数的命令，最少的按键输入。
- en: '[PRE88]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This resolves to:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这会解析为：
- en: '[PRE89]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '![](img/7de20ecf-5174-4e9e-a5ae-9e024c717114.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7de20ecf-5174-4e9e-a5ae-9e024c717114.png)'
- en: 'The output was the same as what we ran a while ago:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与我们之前运行的相同：
- en: '[PRE90]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How did PowerShell know that `Cn` stands for `ComputerName`?
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是如何知道 `Cn` 代表 `ComputerName` 的？
- en: How to do it...
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Parameters are part of cmdlets, and `Get-Command` is the cmdlet that fetches
    information about cmdlets.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: Parameters 是 cmdlet 的一部分，而 `Get-Command` 是获取关于 cmdlet 信息的 cmdlet。
- en: For this example, let us pick the cmdlet, `Invoke-Command`.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们选择 cmdlet `Invoke-Command`。
- en: '[PRE91]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Examine the object that this command outputs.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查该命令输出的对象。
- en: '[PRE92]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The output shows a member called Parameters. Use the member access operator
    to pick the member.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出中显示了一个名为 Parameters 的成员。使用成员访问操作符来选择这个成员。
- en: '[PRE93]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: See what members this member contains.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看这个成员包含哪些成员。
- en: '[PRE94]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Would Values show us the information we need?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Values` 会展示我们所需的信息吗？'
- en: '[PRE95]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Yes, that does give us something, but there is too much output. We need only
    the parameter names and their aliases.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，这确实给了我们一些东西，但输出太多了。我们只需要参数名称及其别名。
- en: '[PRE96]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: There you go.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。
- en: How it works...
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We saw while reading about the Core and its capabilities, that PowerShell, most
    of the time, returns objects. And every object can have objects within itself.
    Going by the same path as that of .NET, a member access operator can be used to
    select the members (which could be properties or methods). Properties are addressed
    by simply using the property names, while methods need arguments passed to them
    (an empty pair of parentheses is still needed if no argument is being passed).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在阅读 Core 及其功能时看到，PowerShell 大多数时候会返回对象。而每个对象内部都可以有其他对象。沿着 .NET 的路径，成员访问操作符可以用来选择成员（这些成员可以是属性或方法）。属性通过直接使用属性名称来访问，而方法则需要传递参数（如果不传递参数，依然需要使用一对空括号）。
- en: The parameters of a cmdlet are objects of the output that the `Get-Command`
    cmdlet returns. Therefore, calling `Get-Command` with the cmdlet, `Invoke-Command`
    returns data about `Invoke-Command` as the output object. This can be further
    broken down to several other objects (members), among which, there is `Parameters`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: cmdlet 的参数是 `Get-Command` cmdlet 返回的输出对象。因此，调用 `Get-Command` 并指定 cmdlet `Invoke-Command`，它会返回关于
    `Invoke-Command` 的数据作为输出对象。这可以进一步分解成几个其他对象（成员），其中就包括 `Parameters`。
- en: '`Parameters` itself can be further broken down into other members, `Values`
    being one of them—`Values` contains the names of the parameters, as revealed by
    running `Get-Member`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parameters` 本身可以进一步分解为其他成员，其中 `Values` 就是其中之一——`Values` 包含了参数的名称，运行 `Get-Member`
    时可以看到这一点。'
- en: We select two objects from within `Values`, called `Name` and `Aliases`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `Values` 中选择了两个对象，分别是 `Name` 和 `Aliases`。
- en: These parameter aliases can be used in place of parameters themselves.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数别名可以替代参数本身使用。
- en: 'There are two caveats with parameter aliases:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 参数别名有两个需要注意的地方：
- en: They are case-sensitive, which means reaching for the Shift key.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是区分大小写的，这意味着需要按下 Shift 键。
- en: They have to be remembered, even though they have a pattern to them, just like
    how cmdlet aliases do (`ip` for `Import` and `g` for `Get`, for instance).
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们需要记住，尽管它们有一定的模式，就像 cmdlet 的别名一样（例如，`ip` 代表 `Import`，`g` 代表 `Get`）。
- en: Calling a PowerShell script
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 PowerShell 脚本
- en: PowerShell scripts are nothing but a series of PowerShell cmdlets, each in a
    line of a `ps1` file. These instructions are executed one after the other, similar
    to the good old shell script. Using VS Code makes running PowerShell scripts simpler,
    in that you simply have to run the script to make the script work its magic.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 脚本不过是一系列 PowerShell cmdlet，每个 cmdlet 都位于 `ps1` 文件的一行。这些指令一个接一个地执行，类似于传统的
    shell 脚本。使用 VS Code 使得运行 PowerShell 脚本变得更简单，你只需要运行脚本，脚本就会发挥它的作用。
- en: However, running PowerShell scripts on VS Code is not the usual way of automation
    for obvious reasons. Also, there are many ways to run a PowerShell script. We
    shall look at a very simple way of running the script in this recipe; as we progress
    in the book, we will also add more features to our scripts, and further, will
    package them into modules for future use.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 VS Code 中运行 PowerShell 脚本并不是一种常见的自动化方式，原因显而易见。此外，运行 PowerShell 脚本的方法有很多种。我们将在这个教程中介绍一种非常简单的脚本运行方式；随着书中的进展，我们也会为我们的脚本添加更多功能，进一步将它们打包成模块以供将来使用。
- en: Getting Ready
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses VS Code to write the script. While any text or code editor
    would work for the script, we use VS Code because in my experience, VS Code is
    the friendliest editor for  PowerShell scripting.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程使用 VS Code 编写脚本。虽然任何文本编辑器或代码编辑器都可以用来编写脚本，但我们选择 VS Code，因为根据我的经验，VS Code 是
    PowerShell 脚本编写中最友好的编辑器。
- en: Open VS Code, create a new file.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VS Code，创建一个新文件。
- en: Create a new directory at a convenient location (`~/Code`, perhaps?).
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个方便的位置创建一个新目录（例如 `~/Code`？）。
- en: Save the empty file as `hello-world.ps1` within the directory you just created.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将空文件保存为`hello-world.ps1`，保存在你刚刚创建的目录中。
- en: Observe the bottom right of VS Code; it should now say, `PowerShell`.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看VS Code的右下角，应该现在显示为`PowerShell`。
- en: Press `` Ctrl + ` `` to close the console at the bottom to reduce distraction.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`` Ctrl + ` ``关闭底部的控制台，以减少干扰。
- en: If everything is as shown in the screenshot below, you are good to go. (Ignore
    the colour of the status bar at the bottom, as well as the git status at the bottom-left
    for now.)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切如截图所示，你就准备好开始了。（暂时忽略底部状态栏的颜色以及左下角的Git状态。）
- en: '![](img/23eb3582-a3de-490a-804e-16c977434c72.png)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23eb3582-a3de-490a-804e-16c977434c72.png)'
- en: How to do it...
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'At the script pane, type in:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本面板中输入：
- en: '[PRE97]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Save (**File** > **Save** or `Ctrl + S`) the script.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存（**文件** > **保存**或`Ctrl + S`）脚本。
- en: Click on **Debug** in the left. Alternatively, press `Ctrl + Shift + D`. This
    opens the Debug pane.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的**调试**。或者，按下`Ctrl + Shift + D`。这将打开调试面板。
- en: Press the green play-button-like **Start debugging** button.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下绿色的类似播放按钮的**开始调试**按钮。
- en: The console should pop out and display `Hello, World!`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应该会弹出并显示`Hello, World!`。
- en: Let us run the script one more time. This time, we will not open the Debug pane
    or press buttons on the screen. Simply, press `F5`.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再运行一次脚本。这次，我们不打开调试面板，也不按屏幕上的按钮。简单地，按下`F5`。
- en: '`Hello, World!` should again be displayed in the console.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello, World!`应该再次出现在控制台中。'
- en: '![](img/0ab2165b-fadb-4c0e-b8e4-b87e283c3067.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ab2165b-fadb-4c0e-b8e4-b87e283c3067.png)'
- en: Let us now call the script without using the debug controls.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们不使用调试控件来调用脚本。
- en: Close the file (Ctrl + W).
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件（Ctrl + W）。
- en: 'At the prompt on the console, type in:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台的提示符下，输入：
- en: '[PRE98]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: You should see `Hello, World!` appear.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到`Hello, World!`出现在控制台中。
- en: Now, navigate to home.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到主目录。
- en: Next, type `&`, add a space, `./` and start typing the path to where you stored
    the script. Use tab completion just like how you would on Bash.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入`&`，加上空格，再输入`./`，然后开始输入存储脚本的路径。像在Bash中一样使用Tab补全功能。
- en: When you reach the location of the script file, press Enter to call the file.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你到达脚本文件的位置时，按回车键来调用该文件。
- en: '![](img/7d6b31d4-f323-4db3-81a8-b7aaa3faf1b9.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d6b31d4-f323-4db3-81a8-b7aaa3faf1b9.png)'
- en: How it works...
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The simplest way to run a PowerShell script is to debug it at the Integrated
    Scripting Environment. We use VS Code as our ISE of choice in this case. The other
    two ways of calling the script described in this recipe are from the PowerShell
    console. You may use the integrated console in VS Code, or a PowerShell console
    called at the Terminal for this purpose.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 运行PowerShell脚本的最简单方法是在集成脚本环境中调试它。在这种情况下，我们选择使用VS Code作为我们的ISE。本文中描述的调用脚本的另外两种方式是通过PowerShell控制台。你可以使用VS
    Code中的集成控制台，或者在终端中调用PowerShell控制台来实现。
- en: 'When the script is located at the present working directory, PowerShell just
    calls the `ps1` file and executes it. Another way of calling PowerShell scripts
    is to use `&` (or the **call operator**): type `&` followed by a space, followed
    by the path to the script file. This way of calling handles spaces in the path
    well.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本位于当前工作目录时，PowerShell会直接调用`ps1`文件并执行它。调用PowerShell脚本的另一种方式是使用`&`（或**调用操作符**）：输入`&`，然后空格，接着是脚本文件的路径。通过这种方式调用可以很好地处理路径中的空格。
- en: If the path to the script contains spaces, the path would need to be surrounded
    by quotes. This would make PowerShell think that you are simply giving it a string
    value. PowerShell would, then, simply display the path as text the moment you
    press Enter.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本的路径包含空格，则该路径需要用引号括起来。这样，PowerShell会认为你只是给它一个字符串值。然后，PowerShell会在你按下回车键时，将路径作为文本显示。
- en: When you use the `&` call operator, you tell PowerShell that you want to run
    a script (or a command).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`&`调用操作符时，你是在告诉PowerShell你想要运行一个脚本（或一个命令）。
- en: Another way of calling scripts is to use `.` (or the **dot operator**), which
    we shall look at in the next recipe.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 调用脚本的另一种方式是使用`.`（或**点操作符**），我们将在下一个食谱中讨论这一点。
- en: Dot-sourcing a PowerShell script
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点源 PowerShell 脚本
- en: In the previous recipe, we saw how to call PowerShell scripts from outside of
    the ISE. We gave PowerShell the path, and explicitly mentioned that we would like
    it to run the script, by using a call operator.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇中，我们展示了如何在ISE外部调用PowerShell脚本。我们给PowerShell提供了路径，并明确表示希望它通过调用操作符运行脚本。
- en: This way is ideal if you would just like the script to perform its task and
    not leave anything behind, like variable values and such. However, there are situations
    wherein we would like to run a script and, say, retain values of the variables
    we declared and assigned in them, or use the functions we declared in them.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只希望脚本执行任务而不留下任何东西，例如变量值等，这种方式是理想的。然而，也有一些情况，我们希望运行脚本，并且保留我们在脚本中声明和赋值的变量，或者使用我们在脚本中声明的函数。
- en: In such situations where we would like the functions, variables and even aliases
    retained in the current session, we use dot-sourcing.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们希望函数、变量甚至别名保留在当前会话中的情况下，我们使用点源。
- en: How to do it...
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: If you deleted the file after the previous recipe, restore it or recreate it
    using the steps in the previous recipe. Then,
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在上一实例之后删除了文件，按照上一实例中的步骤恢复它或重新创建它。然后，
- en: Open the script file that you created in the previous recipe. At the second
    line, type the following.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你在上一实例中创建的脚本文件。在第二行，输入以下内容。
- en: '[PRE99]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Save the script. Do not run it yet.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。不要运行它。
- en: Place your cursor at the integrated console, and call the script using the call
    operator.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标放置在集成控制台，并使用调用操作符调用脚本。
- en: '[PRE100]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We declared $Message and assigned a string value to it. Call the variable to
    see what value it contains.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了 `$Message` 并给它赋了一个字符串值。调用该变量查看它包含的值。
- en: '[PRE101]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Nothing.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何反应。
- en: Now, dot-source the script. (There are two dots; one is the operator, and the
    other after the space is reference to the current directory.)
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用点源（dot-source）脚本。（这里有两个点；一个是操作符，另一个是空格后指向当前目录。）
- en: '[PRE102]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Call the $Message variable again.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用 `$Message` 变量。
- en: '[PRE103]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '![](img/a0c0e9b2-1b76-46b1-97de-239dcda9adea.png)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0c0e9b2-1b76-46b1-97de-239dcda9adea.png)'
- en: How it works...
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a script or a command is called using the call operator, the script or
    command is simply run without the current session (or technically, scope) being
    modified. The command or script runs and exits without changing anything pertaining
    to the session, including changes to built-in/automatic variables.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用调用操作符调用脚本或命令时，脚本或命令会简单地运行，而不会修改当前会话（或者从技术上讲，是作用域）。命令或脚本运行并退出，而不会更改与会话相关的任何内容，包括对内建/自动变量的更改。
- en: When changes to the scope are desired, the script or command must be dot-sourced.
    This way, whatever variables, functions or aliases are defined in it, are retained
    in the current scope.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要更改作用域时，脚本或命令必须通过点源来调用。这样，脚本中定义的任何变量、函数或别名都会保留在当前作用域中。
- en: There's more...
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Create a new alias using `New-Alias` within the `hello-world.ps1` script. Try
    to get the value of the alias after first calling the script (using the debug
    control, as well as using the call operator), and then, by dot-sourcing the script.
    Observe the outcomes.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `hello-world.ps1` 脚本中使用 `New-Alias` 创建一个新的别名。尝试在第一次调用脚本后（使用调试控制以及使用调用操作符）获取别名的值，然后，通过点源脚本来获取别名的值。观察结果。
- en: Calling a PowerShell cmdlet from outside of PowerShell
  id: totrans-553
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 PowerShell 外部调用 PowerShell cmdlet
- en: So far we have learnt to call cmdlets from the console, run scripts at the ISE,
    and call scripts in two modes. In this very short recipe, we shall learn how to
    call a PowerShell cmdlet from outside of PowerShell.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了从控制台调用 cmdlet、在 ISE 中运行脚本，并以两种模式调用脚本。在这个非常简短的实例中，我们将学习如何从 PowerShell
    外部调用 PowerShell cmdlet。
- en: How to do it...
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open a Terminal window.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口。
- en: 'At the prompt, type:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入：
- en: '[PRE104]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Read the syntax for the command.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读命令的语法。
- en: 'At the prompt, type:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入：
- en: '[PRE105]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '![](img/23321ef5-fc49-4e61-a77e-e957c0051db9.png)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23321ef5-fc49-4e61-a77e-e957c0051db9.png)'
- en: Let us now run the `hello-world.ps1` script.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来运行`hello-world.ps1`脚本。
- en: '[PRE106]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '![](img/705055a1-23b9-4322-bb0b-ee77122284eb.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](img/705055a1-23b9-4322-bb0b-ee77122284eb.png)'
- en: How it works...
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: PowerShell is not an application that runs on top of Bash. PowerShell is a shell
    itself. However, it can be called from with Bash just like another application.
    Like applications, the `pwsh` command takes in arguments, which are then processed
    by PowerShell.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 不是一个运行在 Bash 之上的应用程序。PowerShell 本身就是一个 Shell。然而，它可以像其他应用程序一样从 Bash
    中调用。像应用程序一样，`pwsh` 命令接受参数，然后由 PowerShell 处理。
- en: The two main ways we may want to use PowerShell from within Bash is to run a
    single command, or call a script file. You can even call a script block, however,
    this must be done from within PowerShell. In most cases, running single cmdlets
    or calling a script should suffice.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要在 Bash 中使用 PowerShell 的两种主要方式是运行单个命令，或者调用一个脚本文件。你甚至可以调用一个脚本块，然而，这必须在 PowerShell
    内部执行。在大多数情况下，运行单个 cmdlet 或调用脚本就足够了。
- en: In general, when calling `pwsh` with cmdlets, make `-Command` (or `-c`) the
    last parameter, since anything that comes after the cmdlet itself is considered
    cmdlet arguments. Same goes for `-File` as well.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在调用 `pwsh` 并使用 cmdlets 时，应将 `-Command`（或 `-c`）作为最后一个参数，因为在 cmdlet 本身之后的任何内容都被视为
    cmdlet 参数。`-File` 也是一样。
- en: When a script is designed to accept arguments, the script arguments can be passed
    after the script name, just like with cmdlets.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个脚本被设计为接受参数时，脚本参数可以在脚本名称后面传递，就像使用 cmdlet 一样。
- en: Recording the cmdlets run on the PowerShell console
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录在 PowerShell 控制台上运行的 cmdlet。
- en: Often, there are situations in which you perform a series of tasks on your PowerShell
    console, and after quite some trial-and-error, come across a solution. And then,
    you wish you had recorded everything you did on the console. You could still copy
    content from the console, so you try to scroll up. But you can only go so far.
    Your command history (a little like Bash history) can help you, but sometimes,
    that feels limited as well.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 PowerShell 控制台上，你会执行一系列任务，在经过一番反复试探后，找到了解决方案。然后，你希望你能记录下所有在控制台上的操作。你仍然可以从控制台复制内容，所以你尝试向上滚动。但你只能滚动这么远。你的命令历史（有点像
    Bash 历史）可以帮到你，但有时候，这也感觉有限。
- en: A few months ago, we were troubleshooting a sync issue between two of their
    software update distribution systems which were supposed to work in sync. After
    some of us were done beating around the GUI, (of course) we decided to pick PowerShell
    to fix the issue. We ran a series of commands, and after a few hours of fighting
    with the systems, the systems yielded, and we were back up and running.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月前，我们正在排查两套本应同步工作的软件更新分发系统之间的同步问题。在我们中的一些人已经厌倦了图形界面（GUI）之后，（当然）我们决定使用 PowerShell
    来解决问题。我们运行了一系列命令，经过几个小时与系统的斗争，系统终于屈服，我们重新开始工作。
- en: 'Our managers asked for all the steps that we took to achieve this, so that
    they could be documented for future use. Of course I cannot tell you all the steps
    that we took—because: a) scope of the book, and b) agreements with our clients—but
    I can tell you what can help in such situations.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的经理要求我们记录所有的步骤，以便将来可以参考。当然，我不能告诉你我们所采取的所有步骤——因为：a) 本书的范围，b) 我们与客户的协议——但我可以告诉你，在这种情况下，有哪些方法可能会有所帮助。
- en: How to do it...
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Start PowerShell at the terminal, or use the PowerShell Integrated Console on
    VS Code.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端启动 PowerShell，或使用 VS Code 上的 PowerShell 集成控制台。
- en: 'Run the following command:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE107]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: You can also simply run the cmdlet without any arguments; it would automatically
    create a text file with an auto-generated file name. Get the current system date
    and time
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以直接运行没有任何参数的 cmdlet；它会自动创建一个带有自动生成文件名的文本文件。获取当前系统的日期和时间。
- en: '[PRE108]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: List out all the files and directories in the current location.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前目录中的所有文件和目录。
- en: '[PRE109]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Create a new directory.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新目录。
- en: '[PRE110]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Create a new file within the directory.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目录中创建一个新文件。
- en: '[PRE111]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Add content to the file.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向文件添加内容。
- en: '[PRE112]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Delete the directory.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除目录。
- en: '[PRE113]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Stop recording what you did.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止记录你所做的事情。
- en: '[PRE114]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: You should have now received the location of the transcript file. Read the contents
    of the file.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该已经收到了转录文件的位置。读取文件内容。
- en: '[PRE115]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '![](img/3b8eda4d-a326-4155-b8ea-67f3d63f7aa3.png)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b8eda4d-a326-4155-b8ea-67f3d63f7aa3.png)'
- en: How it works...
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A transcript created by running `Start-Transcript` stores all of your actions
    and the console output of all of the commands you ran, in a text file. The transcript
    also contains some of other useful information pertaining to the context the commands
    were run in.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`Start-Transcript`创建的转录文件会将你所有的操作和所有命令的控制台输出存储在一个文本文件中。转录文件还包含一些与命令执行时的上下文相关的其他有用信息。
- en: A transcript file is a little more than a history file, in that the former contains
    the output of the commands, apart from the commands themselves.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 转录文件比历史文件稍微多一点，因为前者包含了命令的输出，而不仅仅是命令本身。
- en: The `Start-Transcript` cmdlet does not require any argument at all; it can create
    a text file at the user's home, with a unique name to ensure that no other transcript
    is rewritten. In other words, `Path` is an optional parameter.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start-Transcript` cmdlet 完全不需要任何参数；它可以在用户的主目录下创建一个文本文件，并赋予唯一名称，以确保不会覆盖其他转录文件。换句话说，`Path`
    是一个可选参数。'
- en: This concludes this chapter about preparing for administration using PowerShell.
    It's time to crack your knuckles and refill your coffee mug. Did I tell you coffee
    speeds up thinking in PowerShell? Placebo, you say? Let's not get into an argument
    right now.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容已经讲完，关于如何使用 PowerShell 为管理做准备。现在是时候活动一下手指，重新倒杯咖啡了。我要告诉你，咖啡能加速 PowerShell
    中的思维吗？你说这是安慰剂效应？我们现在可别争论这个。
