- en: Time for Safety
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性时刻
- en: 'Safety is important, wherever we are. For example, in a construction site as
    in a newly built operating system, safety is a key factor to have things done
    the right way. Our shell is nothing different when it comes to safety: we spend
    most of our time inside our environment, trying to have things done, tasks running,
    and keep everything in order. This last chapter will give us some quick solutions and
    hints on how to strengthen it and preserve it from the most common issues using
    the shell. We will not use more advanced tools such as security or other kernel-level
    enhancement: such tools would require an entire book on their own, and they come
    after we clean up our shell. We will perform *housekeeping*, nothing really invasive,
    just a *finishing touch*, trying to find a balance between security, safety, and
    usability; and this is actually a hard goal: strengthen too much and even the
    easiest task will be almost impossible to be carried on. It will be be usable
    and probably our system will be too exposed or unsafe. We will try to hit the
    sweet spot, having a usable system, fairly safe and secure; but then it is up
    to the administrator of each system to decide what the balance should be: we can
    only advice a few tips and show what could be done.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性无论我们身处何地都很重要。例如，在建筑工地上，像在新构建的操作系统中一样，安全性是确保事情以正确方式完成的关键因素。我们的 shell 在安全性方面也不例外：我们大多数时间都待在环境中，努力完成任务，保持一切井然有序。本章将为我们提供一些快速的解决方案和提示，帮助我们加强安全性并避免最常见的问题。我们不会使用像安全性或其他内核级别增强这样的更高级工具：这些工具本身就需要一本书的篇幅，并且它们是在清理我们的
    shell 后才会使用的。我们将进行*家务管理*，没有什么真正侵入性的操作，只是做一些*修饰性工作*，力求在安全性、可靠性和可用性之间找到一个平衡；这其实是一个很难实现的目标：加强过多的话，即使是最简单的任务也几乎无法完成。如果我们过于注重安全性，可能会导致我们的系统过于暴露或不安全。因此，我们将尝试找到一个最佳平衡点，确保系统既可用，又相对安全；但最终还是由每个系统的管理员决定这个平衡点应该是什么：我们只能提供一些建议和展示可能的操作。
- en: The restricted shell
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受限 shell
- en: 'There are different ways to restrict what a user can do on a system and there
    are a lot of reasons why we would restrict a user''s ability to interact with
    a system: maybe we want a user just to be able to copy a file to and from the
    system or to have a simple home where they can work on their tasks without peeking
    around the system. Anyway, whatever is our goal we can start working with a restrict
    shell.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以限制用户在系统上的操作，并且有很多原因导致我们会限制用户与系统的交互：可能我们只希望用户能够将文件复制进出系统，或者为他们提供一个简单的主目录，让他们可以在里面工作而不去窥探系统中的其他内容。无论我们的目标是什么，我们都可以从使用受限
    shell 开始。
- en: 'Bash itself offers an additional layer of security using the following options:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 本身提供了额外的安全层，使用以下选项：
- en: '`rbash`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rbash`'
- en: '`--restricted`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--restricted`'
- en: '`-r`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`'
- en: 'Invoking `rbash` or simply `bash` with the `--restricted` or `-r` options spins
    a Bash instance that trims down what the users will be able to do on such an environment:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--restricted` 或 `-r` 选项调用 `rbash` 或直接调用 `bash`，将启动一个受限的 Bash 实例，从而限制用户在该环境中可以执行的操作：
- en: 'The user cannot change the directory using the `cd` builtin. The user will
    be prevented to set or unset the values for the following environment variables:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户不能使用 `cd` 内建命令更改目录。用户将被阻止设置或取消设置以下环境变量的值：
- en: '`BASH_ENV`'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BASH_ENV`'
- en: '`ENV`'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`'
- en: '`SHELL`'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHELL`'
- en: '`PATH`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH`'
- en: The user will not be able to specify command names with slashes and this means
    no command names with absolute paths. No filenames containing a slash can be passed
    as an argument to the built-in command called `.`. So, the user will not be able
    to source (the `read and execute` command from) a file from outside his home directory.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户无法指定带有斜杠的命令名称，这意味着无法使用绝对路径的命令名称。不能将包含斜杠的文件名作为内建命令 `.` 的参数传递。因此，用户将无法从主目录外部加载（读取并执行）文件。
- en: No filename containing a slash can be passed as an argument to the builtin command
    called `hash` using the `-p` option. Hash determines the full filename of a command
    specified as an argument by searching into the directories specified by the environmental
    variable: `$PATH`. If `-p filename` is given as an option, hash would use the
    filename as the full path to the command searched. So, no commands invoked outside
    the home directory.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能传递包含斜杠的文件名作为内建命令 `hash` 的参数，使用 `-p` 选项时尤为如此。`hash` 会通过在由环境变量 `$PATH` 指定的目录中查找，确定作为参数给定的命令的完整文件名。如果给定了
    `-p filename` 选项，`hash` 会将文件名视为查找命令时的完整路径。因此，不能调用位于主目录以外的命令。
- en: No functions definitions are imported at the start from the shell environment.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Shell 环境启动时，函数定义不会被导入。
- en: No value is taken into account from the environment SHELLOPTS variable at startup
    and so no shell options are set for the shell.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时，环境变量 SHELLOPTS 的值不会被考虑，因此不会为 Shell 设置任何选项。
- en: No redirections are allowed using the standard operators `>`, `>|`, `<>`, `>&`,
    `&>`, `>>`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准操作符 `>`, `>|`, `<>`, `>&`, `&>`, `>>` 不允许进行重定向。
- en: No exec built-in is available to replace the shell with a different command.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法使用内建的 exec 命令来替换 Shell 为其他命令。
- en: It is not possible to add or delete builtin commands using the `enable` builtin
    with `-d` or `-f` options.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法使用 `enable` 内建命令通过 `-d` 或 `-f` 选项添加或删除内建命令。
- en: It is not possible to use the `enable` built-in to enable or disable the Bash
    built-ins.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法使用 `enable` 内建命令来启用或禁用 Bash 内建命令。
- en: The option `-p` is not allowed for the built-in command, so no `$PATH` manipulation
    is possible.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于内建命令，不允许使用 `-p` 选项，因此无法操作 `$PATH`。
- en: It is impossible to turn off a restricted mode using `set +r` or `set +o restricted`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法使用 `set +r` 或 `set +o restricted` 关闭受限模式。
- en: 'So, with all these limits, the user is caged in its home directory. But how
    do you set up an `rbash login` shell? The easiest method is to find the Bash link
    and redirect it to `rbash`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，尽管有这些限制，用户还是被限制在他的主目录中。但如何设置一个 `rbash 登录` Shell 呢？最简单的方法是找到 Bash 链接并将其重定向到
    `rbash`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this case, a link already exists between `rbash` and `bash`, but in this
    case there were not anyone of them, so we must create it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`rbash` 和 `bash` 之间已经存在链接，但在这种情况下它们没有任何链接，所以我们必须创建一个：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we have to check that `rbash` is listed in `/etc/shells` , which sports
    the full pathnames to valid login shells:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须检查 `rbash` 是否列在 `/etc/shells` 中，该文件列出了有效登录 Shell 的完整路径：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s create a user with a restricted shell:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个具有限制 Shell 的用户：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once done, let''s `su` to the user and test the `cd` command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，让我们 `su` 到该用户并测试 `cd` 命令：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we are. The `cd` command is restricted as we expected it to be. Let''s
    check some other restrictions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里了。`cd` 命令被如我们预期的那样限制。让我们检查一下其他的限制：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nice, no redirections, though the cage is not really isolated:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，没有重定向，不过这个“笼子”并没有完全隔离：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The restricted user can still do something outside its directory. Let''s override
    this using a local profile:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个受限用户仍然可以在其目录外做一些事情。让我们通过使用本地配置文件来覆盖这个限制：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s delete `.bash_profile` or `.profile` we find in the home directory
    and create it, if it does not exist, the file `.bashrc` whose only line should
    be:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们删除在主目录中找到的 `.bash_profile` 或 `.profile` 文件，如果它们不存在，就创建一个 `.bashrc` 文件，其中的唯一一行应该是：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s prevent the user from modifying it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们阻止用户修改它：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now let''s `su`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们 `su`：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And let''s check what we can do:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们能做些什么：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We are not allowed to do that, which we already know. Let''s try to list some
    files:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不被允许这么做，这一点我们已经知道了。让我们试着列出一些文件：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Great, no commands are available outside our `$HOME/bin`. Let''s try again:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，除了我们的 `$HOME/bin` 目录外没有其他命令可用。让我们再试一次：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As expected, there is another failure. Now let''s try the `df` that command
    we linked inside our user''s `$HOME/bin` directory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，出现了另一个失败。现在让我们尝试一下我们在用户的 `$HOME/bin` 目录中链接的 `df` 命令：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This works, we successfully limited the commands the user has access to and
    restricted it to his home directory. Great, looks like it has been contained,
    but there are some limitations:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有效，我们成功限制了用户可以访问的命令，并将其限制在他的主目录内。很棒，看起来已经被隔离了，但还是有一些限制：
- en: 'The restricted user can escape this *cage* running a program, which has a shell
    function. A classical example is the `vi` editor:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 受限用户可以通过运行具有 Shell 函数的程序逃离这个*笼子*。一个经典的例子是 `vi` 编辑器：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another method to escape a restricted shell is to invoke an unrestricted shell:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 逃离受限 Shell 的另一种方法是启动一个没有限制的 Shell：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This also means that any script with a valid sha-bang will invoke a full-blown
    shell and escape any restrictions. All of these methods imply that the user has
    access either to Bash or to any programs featuring a shell function, otherwise
    jumping out from the cage would not be so easy. But we have to bear something
    important in mind: this is a method to cage some users in their working space,
    so it will separate them from each other, give them their own isolated home, and
    prevent them from inadvertently messing with other parts of the system. It is
    not a full-blown security layer hacker; for this kind of stuff, we should rely
    on something more at a kernel level, and it is outside the scope of this book,
    since it would require quite a long explanation about security, kernel compiling,
    third-party products, hardening, and so forth. Again, it is a book on its own.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着任何具有有效sha-bang的脚本都会调用完整的shell，从而逃脱任何限制。这些方法意味着用户可以访问Bash或任何具有shell功能的程序，否则逃出限制区就不容易。但我们需要牢记一点：这是将某些用户限制在其工作空间中的方法，它将把他们彼此隔离，给予他们独立的家目录，并防止他们无意中破坏系统的其他部分。它并不是一个完备的安全层；对于这类问题，我们应该依赖更为底层的解决方案，如内核级别的安全措施，这超出了本书的讨论范围，因为这需要大量的关于安全、内核编译、第三方产品、加固等方面的解释。再说一次，这将是一本独立的书。
- en: So, we want to keep things clean, and what can we do to host remote connections
    in an orderly manner?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望保持整洁，如何有序地承载远程连接呢？
- en: Restricted shells for OpenSSH
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenSSH的限制性shell
- en: Even though the restricted shell for OpenSSH ([http://www.pizzashack.org/rssh/](http://www.pizzashack.org/rssh/))
    is not strictly a shell tool; its simplicity makes it a good candidate for helping
    to keep the house clean when some visitor knocks on wood. Rssh is available for
    a variety of distributions and platforms and offers a restricted shell allowing
    not only `scp` and `ftp`, but also `csv`, `rdist` , and `rsync`. So, we can create
    accounts available for file copy or synchronization without allowing a full shell
    access; and this can be handy to keep things on a low profile and lower the server
    exposure to attacks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OpenSSH的限制性shell（[http://www.pizzashack.org/rssh/](http://www.pizzashack.org/rssh/)）严格来说并不是一个shell工具，但它的简洁性使其成为帮助保持系统整洁的好工具，尤其是在某个访客敲门时。Rssh支持多种发行版和平台，提供了一个限制性shell，不仅支持`scp`和`ftp`，还支持`csv`、`rdist`和`rsync`。因此，我们可以创建仅允许文件复制或同步的账户，而不提供完全的shell访问；这对于保持低调并降低服务器遭受攻击的风险非常有用。
- en: 'The first step consists in installing rssh from a package or from a source.
    In our example, we will rely on a package since the distribution used, Debian,
    has one; and also,  using packages will ensure that the utility will be upgraded
    and patched by the maintainers whenever needed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段是从包或源代码安装rssh。在我们的示例中，我们将依赖于一个包，因为所使用的发行版Debian中已有此包；此外，使用包管理可以确保在需要时，维护者会对该工具进行升级和修补：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once installed, we will have a new shell binary available:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们将获得一个新的shell二进制文件：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, now let''s use this new binary as the restricted user''s shell:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个新的二进制文件作为限制性用户的shell：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And let''s verify directly on `/etc/passwd` that the shell has been assigned:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们直接在`/etc/passwd`中验证是否已分配shell：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It seems all OK, so let''s connect from remote to the system where the restricted
    user resides:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来正常，接下来让我们从远程连接到限制性用户所在的系统：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The account is locked out and this is the default behavior of `rssh` since
    we did not configure it yet. So, let''s see the main configuration directives
    that we can use inside the `/etc/rssh.conf` file to enable some protocols and
    per user configurations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该账户已被锁定，这是`rssh`的默认行为，因为我们尚未进行配置。因此，接下来我们来看一下在`/etc/rssh.conf`文件中可以使用的一些主要配置指令，以启用某些协议和每个用户的配置：
- en: '`allowsftp`: Allows sftp connections.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowsftp`：允许sftp连接。'
- en: '`allowcvs`: Allows cvs connections.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowcvs`：允许cvs连接。'
- en: '`allowrdist`: Allows rdist connections.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowrdist`：允许rdist连接。'
- en: '`allowrsync`: Allows rsync connections.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowrsync`：允许rsync连接。'
- en: '`allowsvnserve`: Allows svnserve connections.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowsvnserve`：允许svnserve连接。'
- en: '`umask`: Sets the umask for the files and directories created during a scp
    or sftp session. The umask is usually set by the shell upon user login, so to
    avoid this, rssh must set the umask itself.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`umask`：设置在scp或sftp会话期间创建的文件和目录的umask。umask通常由shell在用户登录时设置，因此为了避免这种情况，rssh必须自己设置umask。'
- en: '`logfacility`: Specifies which syslog facility or C macros to use for logging.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logfacility`：指定用于日志记录的syslog设施或C宏。'
- en: '`chrootpath`: A helper application for `rssh` (`rssh_chroot_helper`) calls
    the `chroot()` system call changing the root of the filesystem for the session.
    So, for example:  `chrootpath=/opt/jails` will change the root of the virtual
    filesystem to `/opt/jails` for the users whose shell is `rssh`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chrootpath`：`rssh` 的一个辅助应用程序（`rssh_chroot_helper`）调用 `chroot()` 系统调用，改变会话的文件系统根目录。例如：`chrootpath=/opt/jails`
    将会把虚拟文件系统的根目录更改为 `/opt/jails`，适用于其 shell 为 `rssh` 的用户。'
- en: After the login, the `/var/caged/users` directory will appear to the user as
    the root directory of the filesystem, and it will not be able to get outside of
    it. If this directive is used, a `chroot` jail must be in place to provide the
    users a minimal environment. We will see later how to do it. If the user's home
    directory defined in `/etc/passwd` is inside the path specified by `chrootpath`,
    then the user will be `chdired` to his home directory, otherwise it will be `chdired`
    to the root of the `chroot` jail.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，`/var/caged/users` 目录将显示为用户的文件系统根目录，且无法超出该目录。如果使用了此指令，则必须设置 `chroot` 监狱，为用户提供最小化的环境。稍后我们将看到如何操作。如果在
    `/etc/passwd` 中定义的用户主目录位于 `chrootpath` 指定的路径中，那么用户将被 `chdired` 到其主目录，否则将被 `chdired`
    到 `chroot` 监狱的根目录。
- en: '`user`: With this directive, we can set a per user configuration that will
    override all others directives. The `user` keyword appears in a string separated
    in fields by colons (`:`) with the following structure:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`: 使用这个指令，我们可以为每个用户设置配置，覆盖所有其他指令。`user` 关键字出现在用冒号（`:`）分隔的字符串中，具有以下结构：'
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, let''s see what each fields represents:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来让我们看看每个字段代表什么：
- en: '**username**: This is the account name we want to set the configuration for.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**username**：这是我们希望为其设置配置的帐户名。'
- en: '**umask**: Is the umask expressed in octal for the user. It follows the same
    specification as if we were setting it for the Bash shell.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**umask**：表示用户的 umask，以八进制形式表示。它遵循与为 Bash shell 设置 umask 时相同的规范。'
- en: '**access_digits**: These are six binary digits that specify if the user is
    allowed to use `rsync`, `rdist`, `cvs`, `sftp`, `scp` , and `svnserve` in the
    order listed.  `0` means the user is not allowed, a `1` means the user is allowed
    to use it.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**access_digits**：这六个二进制数字指定用户是否被允许使用 `rsync`、`rdist`、`cvs`、`sftp`、`scp` 和
    `svnserve`，按顺序列出。`0` 表示不允许用户使用，`1` 表示允许用户使用。'
- en: '**path**: It specifies the path to the directory the user will be chrooted
    in.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**path**：指定用户将被限制到的目录路径。'
- en: 'Quotes are not mandatory except when there are spaces in the path field. In
    this case, we can user either single or double quotes. Spaces around `=` are fine.
    So, something like `user=restricted:022:100000:` means that the user restricted
    has a umask of `022` and has the `rsync` connections available. No `chroot` is
    specified:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 引号不是强制性的，除非路径字段中有空格。在这种情况下，我们可以使用单引号或双引号。`=` 两边的空格是可以的。所以，像 `user=restricted:022:100000:`
    这样的表达式意味着用户 restricted 的 umask 是 `022`，并且该用户可以使用 `rsync` 连接。没有指定 `chroot`：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The previous statement means that the user restricted has an umask of `011`,
    `sftp` , and `scp` connections available, and it will be chrooted in `/usr/local/chroot
    jails`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的语句意味着用户 restricted 拥有 `011` 的 umask，`sftp` 和 `scp` 连接可用，并且它将被限制在 `/usr/local/chroot
    jails` 中。
- en: Knowing a bit more about configurations, let's enable just the `scp` connections
    for our restricted user by adding  `user = restricted:277:000010` to `/etc/rssh.conf`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多配置后，让我们通过在 `/etc/rssh.conf` 中添加 `user = restricted:277:000010` 来仅启用受限用户的
    `scp` 连接。
- en: 'Time to check whether we finally can access the remote system:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是检查我们是否终于可以访问远程系统的时候了：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is interesting. The message is slightly different from the previous attempt:
    we are still prevented to log into the remote server using ssh, but it states
    that although the account is restricted by rssh, we can use `scp`. So, let''s
    try it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣。消息与上次尝试略有不同：我们仍然无法通过 ssh 登录到远程服务器，但它说明尽管帐户受到 rssh 的限制，我们仍然可以使用 `scp`。所以，让我们试试看：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Well, it seems it worked. Let''s have a look on the remote server:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它好像成功了。让我们看一下远程服务器：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here we go. In the home directory of the restricted user, we have our file
    with the access rights set to `400`, as expected. Nice and easy. But there is
    a small issue and we can see what it is about here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 来了。在受限用户的主目录中，我们的文件访问权限已设置为 `400`，如预期的那样。简单明了。但这里有一个小问题，我们可以在这里看到问题所在：
- en: '![](img/00047.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: Using FileZilla we are able to browse the entire filesystem of the remote host
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FileZilla，我们能够浏览远程主机的整个文件系统。
- en: Even though the user is limited to a protocol, he can browse the remote filesystem
    without any restrictions other than the Unix/POSIX file permissions. In the example
    shown, we enabled the SFTP protocol and actually connected to the system as the
    restricted user browsing, having a look at the `/etc` directory. Can we prevent
    this? Yes, we can `chroot` the user into, ideally, a filesystem on its own, mounted
    with `nosuid` and possibly with a `noxec` options if supported. This way, even
    if a user uploads an executable, he will not be able to run it and/or exploit
    any `suid` rights. Is it easy to do? No, creating a `chroot` jail can be really
    hard since it requires copying the relevant binaries and libraries into the jail
    itself; versions and paths can change depending on the distribution used and also
    the release itself. Actually, the source tarball of rssh offers a script, which
    with some modifications can actually help copying all the necessary files to the
    jail. There are also some other scripts that we can easily find on the internet
    and that will help us in this sensible job. Anyway, there is a much easier way
    to provide a restricted sftp access to a server, and we do not have to look so
    far away from our environment since we can accomplish this task simply using the
    OpenSSH server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户被限制在一个协议中，他仍然可以浏览远程文件系统，除了 Unix/POSIX 文件权限之外没有任何限制。在示例中，我们启用了 SFTP 协议，并实际以受限用户身份连接到系统，浏览
    `/etc` 目录。我们能防止这种情况吗？可以，我们可以将用户 `chroot` 到一个理想的文件系统中，最好是挂载为 `nosuid`，如果支持的话，还可以选择
    `noxec` 选项。这样，即使用户上传了可执行文件，他也无法运行它或利用任何 `suid` 权限。这个操作容易做吗？不，创建 `chroot` 监狱可能非常困难，因为这需要将相关的二进制文件和库文件复制到监狱中；版本和路径可能会根据所使用的发行版以及版本本身发生变化。实际上，rssh
    的源 tarball 提供了一个脚本，通过一些修改，实际上可以帮助将所有必要的文件复制到监狱中。我们还可以在互联网上找到一些其他的脚本，这些脚本将帮助我们完成这项敏感的工作。无论如何，提供受限
    SFTP 访问到服务器有一个更简单的方法，我们无需远离我们的环境，因为我们可以仅仅使用 OpenSSH 服务器来完成这项任务。
- en: Restricted sftp sessions with OpenSSH
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenSSH 限制 SFTP 会话
- en: Using OpenSSH, everything can be easily done with five configuration lines and
    a few commands; let's see how. We are on the remote server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenSSH，一切可以通过五行配置和一些命令轻松完成；让我们看看如何操作。我们在远程服务器上。
- en: 'First, let''s open the OpenSSH file, which is usually found in `/etc/ssh/sshd_config` and
    add these few lines:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开 OpenSSH 配置文件，通常位于 `/etc/ssh/sshd_config`，并添加以下几行：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We should already know what these directives are, but let''s recall what we
    wrote in [Chapter 12](part0194.html#5P0D40-8ae483f626fa439a8b6ee1bf9fb955ec),*Remote
    Connections over SSH*, about remote connections over ssh:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该已经知道这些指令是什么，但让我们回顾一下我们在[第12章](part0194.html#5P0D40-8ae483f626fa439a8b6ee1bf9fb955ec)中关于
    SSH 远程连接的内容，*远程 SSH 连接*：
- en: '`Match`: With this directive, we can use conditional statements so that if
    they are satisfied the following configuration lines, we will override the ones
    in the main configuration block. If a keyword/configuration block appears in more
    than one match clause, only the first instance is taken in to account. As matching
    criteria, we can use the following directives: user, group, host, local address,
    l local port, address, or all for all of them. We can match a list, patterns an
    negation. In our example, we are going to match against a group that we are going
    to create in a moment: whatever account belongs to the group sftp-only will be
    subjected to the following configuration lines.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Match`：使用这个指令，我们可以使用条件语句，这样如果满足条件，以下的配置行将覆盖主配置块中的内容。如果一个关键字/配置块在多个 `Match`
    子句中出现，只有第一个实例会被考虑。作为匹配条件，我们可以使用以下指令：用户、组、主机、本地地址、本地端口、地址，或者所有条件。我们可以匹配一个列表、模式或否定。在我们的示例中，我们将匹配一个我们稍后会创建的组：属于
    `sftp-only` 组的所有账户将受以下配置行的限制。'
- en: '`ChrootDirectory`: By specifying the full path to a directory, we can `chroot`
    a user into it after successful authentication. It is not an easy task since the
    directory must be owned by root and cannot be writable by anyone else. In addition,
    we must provide some files required for a session, like the shell, `/dev/null`,
    `/dev/zero`, `/dev/arandom`, `/dev/stdin`, `/dev/stdout`, `/dev/stderr`, and `/dev/ttyx`.
    We can also find some tokens such as `%h` standing for the home directory of the
    account authenticating, or we can also see `%%` , which stands for a simple `%`.  `%u`
    is replaced by the username. In our case, we do not have to provide any binaries,
    because we will allow sftp connections only, since there is no shell, there is
    no chance of executing anything.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChrootDirectory`：通过指定目录的完整路径，我们可以在成功认证后将用户 `chroot` 到该目录中。这不是一项简单的任务，因为该目录必须由
    `root` 拥有，并且不能对其他人可写。此外，我们还必须提供会话所需的一些文件，例如 shell、`/dev/null`、`/dev/zero`、`/dev/arandom`、`/dev/stdin`、`/dev/stdout`、`/dev/stderr`
    和 `/dev/ttyx`。我们还可以使用一些令牌，例如 `%h` 代表认证账户的主目录，`%%` 代表简单的 `%`，`%u` 则会被替换为用户名。在我们的案例中，我们不需要提供任何二进制文件，因为我们只允许
    `sftp` 连接，由于没有 shell，无法执行任何操作。'
- en: '`X11Forwarding`: This allows/denies the `X11` forwarding. If set to `yes` ,
    it can expose `X11` to attacks; so this option must be taken with care. Defaults
    to `no`. We prevent the forwarding to `X11`: there is no need for it and it can
    expose the system.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X11Forwarding`：此选项允许/拒绝 `X11` 转发。如果设置为 `yes`，可能会使 `X11` 暴露于攻击之中；因此，这个选项需要谨慎使用。默认值为
    `no`。我们禁止转发 `X11`：既然不需要此功能，它可能会暴露系统。'
- en: '`AllowTcpForwarding`: This allow/denies TCP forwarding and can take as argument
    `yes`, `all`, `no`, or `local` and `remote`. The first two options allow the forwarding,
    the third denies it, and the `local` allows local forwarding only; `remote` enables
    remote forwarding only. There is no shell or TCP forwarding for our example.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllowTcpForwarding`：此选项允许/拒绝 TCP 转发，参数可以为 `yes`、`all`、`no` 或 `local` 和 `remote`。前两个选项允许转发，第三个选项拒绝转发，而
    `local` 仅允许本地转发；`remote` 仅允许远程转发。对于我们的示例来说，不涉及任何 shell 或 TCP 转发。'
- en: '`ForceCommand`: Overrides any commands sent by the client or listed in the
    `~/.ssh/rc` of the authenticating account and forces the execution of the command
    listed in this directive. The command is executed through the account shell with
    the `-c` option. Defaults to `no`. In our case, we force the execution of the
    OpenSSH internal `sftp` subsystem.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForceCommand`：覆盖客户端发送的任何命令或在认证账户的 `~/.ssh/rc` 文件中列出的命令，并强制执行此指令中列出的命令。该命令通过账户的
    shell 执行，并附带 `-c` 选项。默认值为 `no`。在我们的案例中，我们强制执行 OpenSSH 内部的 `sftp` 子系统。'
- en: 'Talking about the subsystem, let''s verify that in the same config file OpenSSH
    is configured to use the `internal-sftp` subsystem:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 说到子系统，让我们验证在同一个配置文件中，OpenSSH 是否配置为使用 `internal-sftp` 子系统：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We may also want to add some more restrictions at the end of the configuration
    file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也许还想在配置文件末尾添加一些额外的限制：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`AllowAgentForwarding`: Defines whether ssh-agent forwarding is allowed or
    not. Defaults to `yes` to increase the security, and since it is not really needed
    for an `sftp` account, so we are going to disable it.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllowAgentForwarding`：定义是否允许 ssh-agent 转发。默认值为 `yes`，以增加安全性，由于 `sftp` 账户实际上不需要此功能，因此我们将禁用它。'
- en: '`PermitTunnel`: This allows/denies the tunnel device forwarding. It takes yes,
    point-to-point , Ethernet, or no as arguments. Yes enables both point-to-point
    and Ethernet forwarding. Defaults to no, and we want to be sure it is disabled
    since we do not need a tunnel for an sftp account.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PermitTunnel`：此选项允许/拒绝隧道设备转发。参数可以为 `yes`、点对点、以太网或 `no`。`yes` 启用点对点和以太网转发，默认值为
    `no`，我们希望确保它被禁用，因为我们不需要为 `sftp` 账户启用隧道。'
- en: 'Now that we have all the service bits in place, let''s restart the OpenSSH
    server, in our case, this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了所有服务部分，接下来重启 OpenSSH 服务器，在我们的例子中就是这个：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Time to add our new group and move our restricted user there:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该是时候添加我们的新组并将受限用户移到其中了：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So, now we have our restricted user added to the `sftp-only` group without
    a valid shell to log in to the system:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经将受限用户添加到 `sftp-only` 组中，并且没有有效的 shell 用于登录系统：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s make the user home directory owned by root so that the user would
    not be able to write into it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将用户的主目录设置为由 `root` 拥有，这样用户就无法向其写入：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And let''s create a new home owned by `root`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个由 `root` 拥有的新主目录：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also let a subdir owned by the restricted user who can write to it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以让一个受限用户拥有一个子目录，允许其写入：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'All fine now, let''s try to log in:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常，现在让我们尝试登录：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That is fine: we do not want a full shell for the restricted user, so let''s
    try sftp:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这没问题：我们不希望受限用户有完整的 shell，所以让我们尝试 sftp：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Great, we are in, but let''s check what we can actually do:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们进来了，但是让我们检查一下我们实际能做什么：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: OK, we are in our remote root directory, but what is inside it?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们在我们的远程根目录中，但里面有什么？
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This sounds familiar. It is the cage, so let''s escape it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很熟悉。这是一个围栏，所以让我们逃出去：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'No, we actually cannot do so. At least, let''s try to upload something:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不行，实际上我们不能这样做。至少让我们试着上传一些东西：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'No way, the user''s root directory is unwritable, so let''s `cd` to the exchange
    directory and try the upload again:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不行，用户 root 的目录是不可写的，所以让我们 `cd` 到交换目录再试一次上传：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It definitely works. Let''s get the file back:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它绝对有效。让我们把文件拿回来：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here we are, the account is ready for the customer to connect and share data.
    But what if we want to connect using a key for authentication?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里了，账户已经准备好供客户连接和共享数据。但如果我们想要使用密钥进行认证连接呢？
- en: 'Let''s first modify `/etc/ssh/ssd_config` by adding the following line at the
    very end of the file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先修改 `/etc/ssh/ssd_config`，在文件的最末尾添加以下行：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will be under the match condition and will be triggered for all the users
    of the `sftp-only` group; but for this to be taken in to account, we have to reload
    the configuration:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在匹配条件下，并且将被所有 `sftp-only` 组的用户触发；但为了使其生效，我们必须重新加载配置：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So, since the new directive instructs OpenSSH to look for `authorized_keys`
    inside `/opt/sftp-jails/authorized_keys/{username}/authorized_keys` for all the
    users belonging to the `sftp-only` group, let''s start creating the correct directories:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于新指令指示 OpenSSH 在 `/opt/sftp-jails/authorized_keys/{username}/authorized_keys`
    中为所有属于 `sftp-only` 组的用户查找 `authorized_keys`，让我们开始创建正确的目录：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is the full path to the user directory holding the authentication key
    for the user that is restricted. We will have to create one of each user; and
    the name of the final directory must be the same as the username. Now, we have
    to trim ownership and access rights:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含用户认证密钥的用户目录的完整路径，该目录是受限用户的用户名。我们将需要为每个用户创建一个目录，并且最终目录的名称必须与用户名相同。现在，我们必须修剪所有权和访问权限：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `authorized_keys` directory belongs to user root and the group: `sftp-only` ,
    while the subdirectory restricted belongs to user restricted and group root:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorized_keys` 目录属于用户 root 和组：`sftp-only`，而子目录 restricted 属于用户 restricted
    和组 root：'
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'All the users from the `sftp-only` group can traverse the `authorized_keys`
    directory, but only the restricted user can traverse the directory restricted.
    Now, let''s copy our key example to the final destination:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属于 `sftp-only` 组的用户都可以遍历 `authorized_keys` 目录，但只有受限用户可以遍历 restricted 目录。现在，让我们将我们的示例密钥复制到最终目标：
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And now let''s give it a correct ownership and access rights:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们给它正确的所有权和访问权限：
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'So, we should end with such a configuration:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们应该以这样的配置结束：
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Everything looks fine, so we just have to test what we have done so far. Let''s
    go to the local server and try a connection on the remote server:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很好，所以我们只需测试一下我们到目前为止做了什么。让我们转到本地服务器，尝试连接远程服务器：
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s try a `ssh` connection:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个 `ssh` 连接：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is correct, we should not be allowed to connect over `ssh` with shell or
    access a home directory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的，我们不应该被允许通过 `ssh` 连接带有 shell 的用户或访问主目录。
- en: 'Let''s try an `sftp` connection:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个 `sftp` 连接：
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Great, we are connected using our identity key and with no user or file or
    IP address specified. So, let''s make some test:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们使用我们的身份密钥连接了，并且没有指定用户、文件或 IP 地址。所以，让我们进行一些测试：
- en: '[PRE56]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We are in our user root directory; let''s try to climb up to the system root
    directory:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的用户根目录中；让我们尝试爬到系统根目录：
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'No way, we are caged into our root directory and cannot go to any upper levels.
    Let''s look for a file to upload:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不行，我们被困在我们的根目录中，无法进入任何上层目录。让我们寻找要上传的文件：
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s try to upload it to the home directory:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将其上传到主目录：
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We have no permission, as expected. We need to use the exchange subdirectory
    for our purposes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有权限，不出所料。我们需要使用交换子目录来实现我们的目的：
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Successfully uploaded! Now, let''s see what is inside the exchange directory:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上传成功！现在，让我们看看交换目录里面有什么：
- en: '[PRE61]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Done! Everything looks fine. Or something like that since we are blind on what
    happens during the connection. Since everything is in an isolated cage, there
    is no way to use a system facility such as `rsyslog` to actually record what the
    user is doing during an `sftp` session. Or, at least, the normal `rsyslog` configuration
    is not able to do this, but there are a few methods to work around this limitation.
    One that we are going to see  involves the use of a pipe; it will make things
    really easy. First, let's modify a couple of directives in `/etc/ssh/sshd_config`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！一切看起来都很好。或者说，差不多，因为我们对连接期间发生的事情视而不见。由于一切都在一个隔离的环境中，因此没有办法使用像`rsyslog`这样的系统设施来实际记录用户在`sftp`会话期间的操作。或者，至少，正常的`rsyslog`配置无法做到这一点，但有一些方法可以绕过这个限制。我们将要看到的一种方法涉及使用管道；它会让事情变得非常简单。首先，让我们修改`/etc/ssh/sshd_config`中的一些指令。
- en: 'The old `Subsystem` and `ForceCommand` now must be rewritten as:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的`Subsystem`和`ForceCommand`现在必须重新编写为：
- en: '[PRE62]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now the `internal-sftp` will log with a level of `INFO`, so we have to export
    this information to the main log using a socket. So, let''s create a file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`internal-sftp`将以`INFO`级别记录日志，因此我们需要通过套接字将这些信息导出到主日志中。让我们创建一个文件：
- en: '[PRE63]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'So, what we have done is instruct `rsyslog` to create a Unix socket in in the
    `/dev` directory of the restricted user; and the `sftp` subsystem will be able
    to send the log messages to `rsyslog` using that socket. Yes, but how are these
    messages written? They are written by simply accessing one of the properties of
    the message itself. In this case, if the name of the program that generated the
    messages is `internal-sftp`, then the message is written on `/var/log/openssh-sftp.log`.
    Once done, let''s restart both `sshd` and `rsyslog`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们所做的是指示`rsyslog`在受限用户的`/dev`目录中创建一个Unix套接字；`sftp`子系统将能够通过这个套接字将日志消息发送给`rsyslog`。是的，但是这些消息是如何写入的呢？它们是通过简单地访问消息本身的某个属性来写入的。在这种情况下，如果生成消息的程序名称是`internal-sftp`，那么消息将被写入`/var/log/openssh-sftp.log`。完成后，让我们重启`sshd`和`rsyslog`：
- en: '[PRE64]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you receive a message from `rsyslog` complaining about the `imuxsock` module
    already being loaded, just comment out the first line with `#`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到来自`rsyslog`的消息，抱怨`imuxsock`模块已被加载，只需将第一行注释掉`#`。
- en: 'Now, we just have to make another connection and issue some commands in order
    to populate the log file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需再建立一次连接并执行一些命令，以便填充日志文件：
- en: '[PRE65]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'That''s it. Now we have a nice log showing us what the user has done during
    his `sftp` session; and the log itself is out of reach of any `sftp` users. In
    our example, we redirected the messages based on the name of the program, which
    created them; but we have other tags we can use to filter. So, let''s see the
    more useful ones:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在我们有了一个很好的日志，显示了用户在其`sftp`会话期间所做的事情；而且该日志本身对任何`sftp`用户都是不可访问的。在我们的示例中，我们基于生成消息的程序名称来重定向消息；但是我们还有其他标签可以用来过滤。接下来，让我们看看其他更有用的标签：
- en: '`HOSTNAME`: The hostname as it appears in the message.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HOSTNAME`：消息中显示的主机名。'
- en: '`FROMHOST`: The hostname of the system the message was received from. In a
    chained configuration, this is the system next to the receiver, not necessarily
    the first sender.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROMHOST`：消息接收到的系统主机名。在链式配置中，这是接收方旁边的系统，而不一定是第一个发送方。'
- en: '`syslogfacility`: The facility reported by the message in numerical form.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syslogfacility`：消息报告的设施，以数字形式显示。'
- en: '`syslogfacility-text`: The facility reported by the message in text form.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syslogfacility-text`：消息报告的设施，以文本形式显示。'
- en: '`syslogseverity`: The severity reported by the message in numerical form.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syslogseverity`：消息以数字形式报告的严重性。'
- en: '`syslogseverity-text`: The severity reported by the message in text form.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syslogseverity-text`：消息报告的严重性，以文本形式显示。'
- en: 'By using these properties, we can do something interesting. Let''s start creating
    another user with the same group and shell as restricted:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些属性，我们可以做一些有趣的事情。让我们开始创建另一个与受限用户具有相同组和shell的用户：
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, let''s change the home directory owner for the user''s home directory:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改用户主目录的所有者：
- en: '[PRE67]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s create the new jail copying the one we already have:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新监狱，复制我们已有的：
- en: '[PRE68]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We just have to fix the ownership now:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只需要修复所有权：
- en: '[PRE69]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Time for copying the keys:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是复制密钥的时候了：
- en: '[PRE70]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In our example, for brevity, we are using the same key as the restricted user,
    but we can always create a new key and copy over the `authorized_keys` file to
    give each user their own key. Once done, let''s try a connection:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，为了简便起见，我们使用的是与受限用户相同的密钥，但我们始终可以创建一个新密钥并将`authorized_keys`文件复制过去，以便为每个用户分配他们自己的密钥。完成后，让我们尝试连接：
- en: '[PRE71]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'OK, the user can access and has the right permissions, but what about logging?
    Nothing, we did not set up anything for logging, so let''s modify `/etc/rsyslog.d/openssh-sftp.conf`
    by adding the following line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，用户可以访问并且拥有正确的权限，但日志呢？什么也没有，我们没有为日志设置任何内容，因此让我们通过添加以下行来修改`/etc/rsyslog.d/openssh-sftp.conf`：
- en: '[PRE72]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, to get the new instructions taken in account, let''s restart `rsyslog`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使新的指令生效，让我们重启`rsyslog`：
- en: '[PRE73]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And let''s connect again to generate some logging lines:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们再次连接，生成一些日志行：
- en: '[PRE74]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s check the log file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查日志文件：
- en: '[PRE75]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is what is expected. We created a Unix socket in the new user''s jail;
    and we are receiving the messages sent by the `internal-sftp` subsystem for the
    account session. Nice, but confusing. All the log messages from all the users
    will be contained in a single file, and since the command messages such as `May
    12 04:02:11 spoton internal-sftp[18573]: closedir "/exchange"` are not identified
    by a user account name, but from a session ID [18631], it is feasible to follow
    all the actions performed during a session and trace them back to the user who
    made them. But overall, it is not so easy to read. What can we do? Well, as always
    we have to use a bit of imagination and creativity and bend the rules to take
    some advantages. Let''s tinker with the `rsyslog` config file for `openssh-sftp`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '这是预期的结果。我们在新用户的监狱中创建了一个Unix套接字；并且我们正在接收由`internal-sftp`子系统为账户会话发送的消息。很好，但有些混淆。所有用户的日志消息都会包含在一个文件中，而像`May
    12 04:02:11 spoton internal-sftp[18573]: closedir "/exchange"`这样的命令消息并没有被用户账户名标识，而是通过会话ID[18631]来区分，因此可以追踪到会话期间执行的所有操作，并追溯到执行操作的用户。但总体来说，这并不容易阅读。我们能做什么呢？嗯，像往常一样，我们需要使用一些想象力和创造力，弯曲规则以获得一些优势。让我们动手修改`openssh-sftp`的`rsyslog`配置文件：'
- en: '[PRE76]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s open it and replace its content with the following lines:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开它并将内容替换为以下几行：
- en: '[PRE77]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'What did we do? We used a property manipulation string, which allowed us to
    associate a hostname property to the messages coming from a specific socket. Then,
    we added two rules to redirect the messages to a per user log file, based on the
    hostname property found in the messages themselves. We intentionally wrote the
    hostname property with different cases to show that the property name is case
    insensitive. Time to restart `rsyslogd`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了什么？我们使用了一个属性操作字符串，使我们能够将主机名属性与来自特定套接字的消息关联。然后，我们添加了两条规则，将消息重定向到每个用户的日志文件，基于消息本身中找到的主机名属性。我们故意使用了不同大小写的主机名属性，目的是显示该属性名是大小写不敏感的。现在是时候重启`rsyslogd`了：
- en: '[PRE78]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The logging facility is ready, let''s connect again and make some *noise*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 日志设施已经准备好了，让我们再连接一次，制造一些*噪音*：
- en: '[PRE79]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now is the time to check:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是检查的时候了：
- en: '[PRE80]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We connected as casualuser, and indeed we see a file named `casualuser-sftp.log`
    exactly where we expected to find it. Let''s have a look at what is inside:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以普通用户身份连接，的确我们看到一个名为`casualuser-sftp.log`的文件，正如我们预期的那样出现在那里。让我们看一下里面的内容：
- en: '[PRE81]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'That''s it. Our `sftp` session has been fully logged and now if we want to
    know what the casual user did, we just have to open the log file and read it through.
    One interesting note, each line of message has now the name of the user it belongs
    to. Well, it would actually be the hostname, but we streched the rules to get
    what we wanted from the system. Is it really so? Let''s make a final check connecting
    a restricted user to see if a new log file is being generated:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们的` sftp`会话已经完全记录，现在如果我们想知道普通用户做了什么，我们只需要打开日志文件并阅读它。一个有趣的点是，每行消息现在都包含了属于该用户的名字。嗯，实际上它会是主机名，但我们通过扩展规则从系统中获取了我们想要的信息。真的是这样吗？让我们通过连接一个受限用户做最后检查，看是否生成了新的日志文件：
- en: '[PRE82]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now that we have issued some commands as a restricted user, let''s see if the
    file we want is really in place:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经作为受限用户执行了一些命令，让我们看看我们需要的文件是否真的在预期的位置：
- en: '[PRE83]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The file is correctly in place, so let''s have a look inside:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 文件正确地存在，所以让我们看看里面的内容：
- en: '[PRE84]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The content is there; all the actions performed by the restricted user have
    been logged and are out of his reach. One last check here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 内容已经在那里；所有受限用户执行的操作都已被记录，并且超出了他们的访问权限。最后再做一次检查：
- en: '[PRE85]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This confirms that no lines tagged as restricted are listed into the `casualuser-sftp.log` ,
    so each user has his own log.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了没有任何标记为受限的行出现在`casualuser-sftp.log`中，因此每个用户都有自己的日志文件。
- en: 'So, we now have a fully functional `sftp` server, along with individual jails
    and per user logging. There is just one nice touch left to give to our server,
    and this will bring us back to the old times: we are talking of a banner to display
    to our users. It can look like that is something not so useful or something that
    belongs to the past times but it is not that. When someone connects to our server
    must be notified that this is a private facility and no illegal action will be
    allowed. This is useful at least for two reasons:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在拥有一个完全功能的`sftp`服务器，以及单独的监狱环境和每个用户的日志记录。现在只剩下一个小细节要给我们的服务器，这将带我们回到过去：我们正在谈论一个显示给用户的横幅。它看起来可能不像是那么有用，或者属于过去的时代，但事实并非如此。当有人连接到我们的服务器时，必须通知他这是一个私人设施，不允许进行任何非法操作。至少有两个原因说明这样做是有用的：
- en: If an unauthorized user connects by mistake to our server, he has to know that
    he is not where he thinks he is; so we give him a chance to disconnect and no
    further actions will be taken.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个未经授权的用户错误地连接到我们的服务器，他必须知道自己并不在他所认为的地方；因此，我们给他一个断开连接的机会，并且不会采取进一步的行动。
- en: If an unknown user connects willfully to our server, he must be notified that
    he is not allowed to do so. In case he proceeds further, we will then be allowed
    in the future to show this as an evidence of his will to carry some illegal actions
    against our facility.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个不明身份的用户故意连接到我们的服务器，必须通知他不被允许这样做。如果他继续操作，那么我们以后可以将其作为他试图对我们的设施进行非法操作的证据。
- en: It can look quite simplistic, but with a banner in place, no one will be able
    to say *I did not know*. No, the user was notified and that matters. Since we
    do not want to scare our visitors, let's make a banner with a jazz using `figlet`,
    a utility that will apply some nice fonts to our messages ready to be displayed
    over a terminal. In our example, we are using Debian, so a simple `root:# apt-get
    install figlet` will install the utility. The default set of font is not so rich,
    but more can be downloaded from the site of this project at [http://www.figlet.org/fontdb.cgi](http://www.figlet.org/fontdb.cgi).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来可能很简单，但有了横幅，没人能再说“我不知道”。不，用户已被通知，这一点很重要。由于我们不想吓到访客，让我们用`figlet`制作一个带有爵士风格的横幅，`figlet`是一个可以为我们的消息应用漂亮字体的工具，准备在终端上显示。在我们的例子中，我们使用的是Debian，因此输入`root:#
    apt-get install figlet`就能安装这个工具。默认的字体集并不丰富，但可以从该项目的官方网站下载更多：[http://www.figlet.org/fontdb.cgi](http://www.figlet.org/fontdb.cgi)。
- en: 'Let''s first test what we have already installed on our system. For a Debian
    environment, the font files reside in `/usr/share/figlet/` , but this can differ
    based on the distribution used. So, to test all the fonts and see what we do like
    the most, a one line for loop is what we need:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先测试一下系统上已经安装的字体。在Debian环境中，字体文件位于`/usr/share/figlet/`，但这可能会根据所使用的发行版有所不同。因此，为了测试所有字体并查看我们最喜欢的字体，我们需要一个一行的for循环：
- en: '[PRE86]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '![](img/00048.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.jpeg)'
- en: 'A simple `for` loop will show us our message in all the fonts available. So,
    let''s create a test file with our welcome banner:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`for`循环将展示我们所有可用的字体中的消息。所以，让我们创建一个包含欢迎横幅的测试文件：
- en: '[PRE87]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Let''s save it to a file named `header.txt` and pass it to `figlet stdin`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其保存为一个名为`header.txt`的文件，并传递给`figlet stdin`：
- en: '[PRE88]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We will get something like what is shown in the following screenshot, which
    is nicely centered:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到类似下图所示的效果，字体会很漂亮地居中显示：
- en: '![](img/00049.jpeg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.jpeg)'
- en: 'A simple `for` loop will show us our message in all the fonts available. Now,
    let''s add some meaningful warning to a `footer.txt` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`for`循环将展示我们所有可用的字体中的消息。现在，让我们为`footer.txt`文件添加一些有意义的警告：
- en: '[PRE89]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let''s pass this message through `figlet`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`figlet`传递这条消息：
- en: '[PRE90]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Since we have our banner, let''s clean it up a bit:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了横幅，让我们稍微整理一下它：
- en: '[PRE91]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'That''s all. So we try a new connection to the server, and we will get a nice
    welcome message like the one shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。所以我们尝试重新连接服务器，并且我们会收到像这里显示的那样的欢迎消息：
- en: '![](img/00050.gif)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.gif)'
- en: A nice welcome message will remind the visitors about the restriction of this
    sftp site.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一条漂亮的欢迎消息将提醒访问者此sftp站点的限制。
- en: 'Great, but let''s say we saw a font that we like, but it is not installed.
    For the sake of this example, let''s say we want to use the alligator font:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但假设我们看到了一种喜欢的字体，但它没有安装。为了这个示例，我们假设我们想使用鳄鱼字体：
- en: '[PRE92]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'It is not installed so we cannot use it, but it is just a matter of downloading it
    and copying over the font directory:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有安装，因此我们无法使用它，但这只是下载并复制字体目录的问题：
- en: '[PRE93]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now let''s just give the previous command again:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需再次输入之前的命令：
- en: '[PRE94]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The font is available to figlet, and so the result is what we can see in the
    following screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 字体可供figlet使用，因此结果就是我们在以下截图中看到的内容：
- en: '![](img/00051.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: Installing a font is simply a matter of copying it in the fonts directory
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 安装字体其实只是将其复制到字体目录中
- en: 'So, let''s have fun. Try to change and create your message in the style we
    prefer: a banner shall not be necessarily boring.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们来点乐趣吧。尝试改变并创建你喜欢的样式：一个横幅不一定非得枯燥乏味。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This is the last summary of this book and the last topic was figlet; and it
    was not just a coincidence. What we tried to make clear through all the chapters
    is that Bash is fun. Did we touch every possible topic and example? No, not at
    all, and this is the greatest thing of all: we have so many things to see, so
    many ways to bend Bash to do unthinkable tasks. Just think about something and
    then try the shell: in most cases a bit of imagination will find a creative way
    to overcome obstacles and to chuckle about what has been done. This book is named
    *Mastering Bash*, but no book can exhaust the massive amount of things that we
    can discover about this shell. So, this is not a landing point, this is just a
    step further, maybe higher than usual, but just a step in an ongoing journey in
    our favorite environment, in our beloved GNU/Linux operating system.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后总结，上一章的主题是figlet；这并非偶然。我们在所有章节中试图阐明的是，Bash是有趣的。我们是否涵盖了所有可能的话题和示例？不，根本没有，而这正是最伟大的地方：我们有太多东西可以探索，太多方法可以让Bash完成难以想象的任务。只要想想某件事，然后尝试使用shell：在大多数情况下，稍微动点脑筋就能找到创造性的方式克服障碍，并且为完成的结果会心一笑。本书名为*《精通Bash》*，但没有一本书能涵盖我们可以发现的关于这个shell的所有内容。所以，这不是终点，这只是一个更进一步的步骤，也许比平时更高，但依然是我们最喜爱的环境、我们钟爱的GNU/Linux操作系统中不断探索旅程的一小步。
