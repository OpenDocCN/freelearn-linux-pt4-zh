- en: Conditions Attached
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加条件
- en: Now you can make your scripts more interactive using the `read` command, and
    you know how to read parameters and options to lighten your inputs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用`read`命令让脚本更加互动，并且你已经知道如何读取参数和选项来简化输入。
- en: We can say that we are now into the fine print of the script. These are the
    details that are written into our scripts using conditions to test if a statement
    should run or not. We are now ready to add some intelligence into our scripts,
    so our scripts become more robust, easier to use, and more reliable. Conditional
    statements can be written with simple command-line lists of `AND` or `OR` commands
    together, or, more often, within traditional `if` statements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，我们现在进入了脚本的细节部分。这些是通过条件语句在脚本中编写的细节，用于测试某个语句是否应该执行。现在我们准备为脚本添加一些智能，这样脚本会变得更健壮、更易用、更可靠。条件语句可以通过简单的命令行列表（`AND`或`OR`命令）来编写，或者更常见的是在传统的`if`语句中编写。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Simple decision paths using command-line lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行列表的简单决策路径
- en: Verifying user input with lists
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表验证用户输入
- en: Using the test shell built-in
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试Shell内建命令
- en: Creating conditional statements using `if`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`创建条件语句
- en: Extending `if` with `else`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`else`扩展`if`
- en: Using the `test` command with the `if` command
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`test`命令与`if`命令
- en: More conditions with `elif`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`elif`添加更多条件
- en: Using case statements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用case语句
- en: Recipe-frontend with `grep`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`grep`的配方前端
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter can be downloaded from here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以从此处下载：
- en: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter03)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Mastering-Linux-Shell-Scripting-Second-Edition/tree/master/Chapter03)'
- en: Simple decision paths using command-line lists
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行列表的简单决策路径
- en: We have used command-line lists (`||` and `&&`), both in [Chapter 1](f439f212-0f5f-4c9d-abdb-9f9b8c199a78.xhtml),
    *The What and Why of Scripting with Bash*, and in some of the scripts found in
    [Chapter 2](10a24eea-2218-44cc-a019-e01ee63ad77c.xhtml), *Creating Interactive
    Scripts*. Lists are one of the simplest conditional statements that we can create,
    and so we thought that it was appropriate to use them in the earlier examples
    before fully explaining them here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](f439f212-0f5f-4c9d-abdb-9f9b8c199a78.xhtml)《Bash脚本的是什么以及为什么要使用它》和[第2章](10a24eea-2218-44cc-a019-e01ee63ad77c.xhtml)《创建交互式脚本》中都使用了命令行列表（`||`和`&&`）。列表是我们可以创建的最简单的条件语句之一，因此我们认为在这里彻底解释之前，在前面的示例中使用它们是合适的。
- en: 'Command-line lists are two or more statements that are joined using either
    the `AND` or `OR` notations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行列表是两个或更多通过`AND`或`OR`符号连接的语句：
- en: '`&&`: `AND`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`：`AND`'
- en: '`||`: `OR`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||`：`OR`'
- en: Where the two statements are joined using the `AND` notation, the second command
    only runs if the first command succeeds. Whereas, with the `OR` notation, the
    second command will run only if the first command fails.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个语句通过`AND`符号连接时，第二个命令只有在第一个命令成功时才会执行。而使用`OR`符号时，第二个命令只有在第一个命令失败时才会执行。
- en: 'The decision on the success or failure of a command is taken by reading the
    exit code from the application. A zero represents a successful application completion
    and anything other than a zero represents a failure. We can test the success or
    failure of an application by reading the exit status by means of the system variables
    `$?`. This is shown in the following example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是否成功执行的决定是通过读取应用程序的退出代码来判断的。零表示应用程序成功完成，非零表示失败。我们可以通过读取系统变量`$?`来测试应用程序的成功或失败。以下是示例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we need to ensure that a script is run from a user''s home directory, we
    can build this into the script''s logic. This can be tested from the command line,
    and it does not have to be in a script. Consider the following command-line example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要确保脚本从用户的主目录运行，我们可以将其构建到脚本的逻辑中。这可以通过命令行进行测试，并且不一定非得在脚本中。考虑以下命令行示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The double vertical bars denote an `OR` Boolean. This ensures that the second
    statement is only executed when the first statement is not true. In simple terms,
    if we are not currently in the home directory, we will be by the end of the command-line
    list. We will see more on the `test` command soon.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 双竖线（`||`）表示`OR`布尔逻辑。这确保第二个语句只有在第一个语句不为真时才会执行。简单来说，如果我们当前不在主目录中，命令执行完毕后我们将会回到主目录。稍后我们会详细讲解`test`命令。
- en: 'We can build this into almost any command that we want and not just test. For
    example, we can query to see if a user is logged into the system, and if they
    are, then we can use the `write` command to directly message their console. Similar
    to before, we can test this in the command line prior to adding it to the script.
    This is shown in the following command-line example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这段代码添加到几乎任何命令中，而不仅仅是`test`命令。例如，我们可以查询是否有用户已登录到系统，如果有，我们可以使用`write`命令直接向他们的终端发送消息。与之前类似，我们可以在命令行中测试这个功能，然后再将其添加到脚本中。以下是命令行示例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that you should change the user `pi` to your username.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你应该将`pi`用户替换为你的用户名。
- en: If we use this in a script, it is almost certain that we will replace the username
    with a variable. In general, if we need to refer to the same value more than once,
    then using a variable is a good idea. In this case, we are searching for the `pi`
    user.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在脚本中使用它，几乎可以确定我们会将用户名替换为变量。一般来说，如果我们需要多次引用同一个值，那么使用变量是个好主意。在这种情况下，我们正在寻找`pi`用户。
- en: 'When we break the command-line list down, we first use the `who` command to
    list the users who are logged on. We pipe the list to `grep` to search for the
    desired username. We are not interested in the output from the search, just its
    success or failure. Bearing this in mind, we redirect all our output to `/dev/null`.
    The double ampersand indicates that the second statement in the list runs only
    if the first returns true. If the `pi` user is logged on, we use `write` to message
    the user. The following screenshot illustrates this command and the output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将命令行列表拆解时，首先使用`who`命令列出已登录的用户。我们将列表通过管道传递给`grep`，以便搜索所需的用户名。我们对搜索结果不感兴趣，只关注其是否成功。考虑到这一点，我们将所有输出重定向到`/dev/null`。双重与号（`&&`）表示只有在第一个语句返回`true`时，第二个语句才会执行。如果`pi`用户已登录，我们会使用`write`命令向该用户发送消息。以下截图展示了该命令及其输出：
- en: '![](img/0889d658-e55d-450c-8eb6-d2a47ddcaa43.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0889d658-e55d-450c-8eb6-d2a47ddcaa43.png)'
- en: Verifying user input with lists
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表验证用户输入
- en: In this script, we will ensure that a value has been supplied to the first positional
    parameter. We can modify the `hello2.sh` script that we created in [Chapter 1](f439f212-0f5f-4c9d-abdb-9f9b8c199a78.xhtml),
    *The What and Why of Scripting with Bash*, to check for user input before displaying
    the `hello` text.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们将确保第一个位置参数已经被赋值。我们可以修改在[第1章](f439f212-0f5f-4c9d-abdb-9f9b8c199a78.xhtml)中创建的`hello2.sh`脚本，*使用Bash脚本的目的与原理*，在显示`hello`文本之前检查用户输入。
- en: 'You can copy the `hello2.sh` script to `hello4.sh`, or simply create a new
    script from scratch. There will not be a lot of typing and the script will be
    created as `$HOME/bin/hello4.sh`, as shown:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`hello2.sh`脚本复制到`hello4.sh`，或者从头创建一个新脚本。输入的内容不会很多，脚本将被创建为`$HOME/bin/hello4.sh`，如下所示：
- en: '![](img/77473c24-d9fd-4e35-a31c-6cf514493b5e.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77473c24-d9fd-4e35-a31c-6cf514493b5e.png)'
- en: 'We can ensure that the script is executable by using the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令确保脚本是可执行的：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can then run the script with or without arguments. The `test` statement is
    looking for the `$1` variable to be zero bytes. If it is, then we will not see
    the `hello` statement; otherwise, it will print the `hello` message. In simple
    terms, we will see the `hello` message if we supply a name.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以带参数或不带参数地运行这个脚本。`test`语句会检查`$1`变量是否为空字节。如果是，那么我们不会看到`hello`语句；否则，它会打印`hello`消息。简单来说，如果我们提供了名字，就会看到`hello`消息。
- en: 'The following screenshot shows the output that you will see when you do not
    supply a parameter to the script, followed by the supplied parameter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了当你没有向脚本提供参数时的输出，后面跟着提供的参数：
- en: '![](img/e94c738c-682b-47ca-8375-ac40a123dd45.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e94c738c-682b-47ca-8375-ac40a123dd45.png)'
- en: Using the test shell built-in
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`test`内建命令
- en: It is probably time for us to pull over to the side of the scripting highway
    and look a little more at the command `test`. This is both a shell built-in and
    a file executable in its own right. Of course, we will have to hit the built-in
    command first, unless we specify the full path to the file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是时候我们在脚本的高速公路旁稍作停留，仔细看看`test`命令了。它既是一个Shell内建命令，也是一个独立的文件可执行命令。当然，除非我们指定文件的完整路径，否则必须先调用内建命令。
- en: 'When the `test` command is run without any expressions to evaluate, then the
    test will return false. So, if we run the `test` as shown in the following command,
    the exit status will be `1`, even though no error output is shown:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当`test`命令没有表达式进行评估时，测试将返回假值。因此，如果我们按照以下命令运行`test`，即使没有错误输出，退出状态仍然是`1`：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `test` command will always return either `True` or `False`, or `0` or `1`,
    respectively. The basic syntax of `test` is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`命令将始终返回`True`或`False`，或`0`或`1`，分别对应真假值。`test`命令的基本语法如下：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or, we can invert the `test` command with this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过以下命令反转`test`命令：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we need to include multiple expressions, this can be done using `AND` or
    `OR` together, using the `-a` and `-o` options, respectively:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要包含多个表达式，可以使用`AND`或`OR`组合这两个表达式，分别使用`-a`和`-o`选项：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also write this as a shorthand version, replacing the `test` with square
    brackets to surround the expression, as shown in the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以写成简写形式，使用方括号将表达式括起来，替代`test`命令，示例如下：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Testing strings
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试字符串
- en: 'We can test for the equality or inequality of two strings. For example, one
    of the ways to test the root user is using the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试两个字符串的相等性或不等性。例如，测试root用户的一种方法是使用以下命令：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We could also write this using the square bracket notation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用方括号表示法来写这个命令：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that you must put a space between each bracket and the inner testing condition
    as previously shown.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个括号和内部测试条件之间必须留有空格，正如前面所示。
- en: 'Equally, we could test for a non-root account with the following two methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以通过以下两种方法来测试非root账户：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can also test for the zero values or non-zero values of strings. We saw this
    in an earlier example in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试字符串的零值或非零值。在本章的早期示例中，我们已经看到过这个方法。
- en: 'To test if a string has a value, we can use the `-n` option. We can check to
    see if the current connection is made through SSH by checking for the existence
    of a variable in the user''s environment. We do this by using `test` and square
    brackets in the following two examples:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个字符串是否有值，我们可以使用`-n`选项。我们可以通过检查用户环境中是否存在某个变量，来判断当前的连接是否通过SSH建立。我们通过使用`test`命令和方括号来完成这一检查，以下是两个示例：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If this is true, then the connection is made with SSH; if it is false, then
    the connection is not through SSH.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为真，则表示连接是通过SSH建立的；如果为假，则表示连接不是通过SSH建立的。
- en: 'As we saw earlier, testing for a zero string value is useful when deciding
    if a variable is set:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，测试零字符串值对于判断变量是否已设置非常有用：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or, more simply, we could use the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更简单的方法是使用以下命令：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A true result for this query means that no input parameters have been supplied
    to the script.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询的结果为真意味着没有向脚本提供输入参数。
- en: Testing integers
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试整数
- en: 'As well as testing string values of bash scripts, we can test for integer values
    and whole numbers. Another way of testing the input of a script is to count the
    numbers of positional parameters and also test if the number is above `0`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试bash脚本的字符串值外，我们还可以测试整数值和整数。测试脚本输入的另一种方式是计算位置参数的数量，并测试该数量是否大于`0`：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or using the brackets, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用方括号，如下所示：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When in a relationship, the top positional parameters of the `$#` variable represent
    the number of parameters passed to the script.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，`$#`变量表示传递给脚本的参数数量。
- en: 'There are many tests that can be done for numbers:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多可以用于数字的测试：
- en: '`number1 -eq number2`: This checks if `number1` is equal to `number2`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1 -eq number2`：检查`number1`是否等于`number2`。'
- en: '`number1 -ge number2`: This checks if `number1` is greater than or equal to
    `number2`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1 -ge number2`：检查`number1`是否大于或等于`number2`。'
- en: '`number1 -gt number2`: This checks if `number1` is greater than `number2`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1 -gt number2`：检查`number1`是否大于`number2`。'
- en: '`number1 -le number2`: This checks if `number1` is smaller than or equal to
    `number2`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1 -le number2`：检查`number1`是否小于或等于`number2`。'
- en: '`number1 -lt number2`: This checks if `number1` is smaller than `number2`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1 -lt number2`：此命令检查`number1`是否小于`number2`'
- en: '`number1 -ne number2`: This checks if `number1` is not equal to `number2`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1 -ne number2`：此命令检查`number1`是否不等于`number2`'
- en: Testing file types
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试文件类型
- en: 'While testing for values, we can test for the existence of a file or file type.
    For example, we may only want to delete a file if it is a symbolic link. We use
    this while compiling a kernel. The `/usr/src/linux` directory should be a symbolic
    link to the latest kernel source code. If we download a newer version before compiling
    the new kernel, we need to delete the existing link and create a new link. Just
    in case someone has created the `/usr/src/linux` directory, we can test if it
    has a link before removing it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试值时，我们可以测试文件或文件类型的存在。例如，我们可能只想在文件是符号链接时才删除它。在编译内核时，我们会使用这种方法。`/usr/src/linux`目录应该是指向最新内核源代码的符号链接。如果我们在编译新内核之前下载了更新版本，我们需要删除现有的链接并创建一个新链接。为了防止有人创建了`/usr/src/linux`目录，我们可以在删除之前测试它是否存在链接：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `-h` option tests that the file has a link. Other options include the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`-h`选项用于测试文件是否有链接。其他选项包括以下内容：'
- en: '`-d`: This shows that it''s a directory'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：此命令显示该文件是否为目录'
- en: '`-e`: This shows that the file exists in any form'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`：此命令显示文件是否以任何形式存在'
- en: '`-x`: This shows that the file is executable'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`：此命令显示文件是否可执行'
- en: '`-f`: This shows that the file is a regular file'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：此命令显示文件是否为常规文件'
- en: '`-r`: This shows that the file is readable'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`：此命令显示文件是否可读'
- en: '`-p`: This shows that the file is a named pipe'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`：此命令显示文件是否为命名管道'
- en: '`-b`: This shows that the file is a block device'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`：此命令显示文件是否为块设备'
- en: '`file1 -nt file2`: This checks if `file1` is newer than `file2`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file1 -nt file2`：此命令检查`file1`是否比`file2`更新'
- en: '`file1 -ot file2`: This checks if `file1` is older than `file2`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file1 -ot file2`：此命令检查`file1`是否比`file2`更旧'
- en: '`-O file`: This checks if the logged-in user is the owner of the file'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O file`：此命令检查当前登录用户是否为该文件的所有者'
- en: '`-c`: This shows that the file is a character device'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`：此命令显示文件是否为字符设备'
- en: More options do exist, so delve into the main pages as you need to. We will
    use different options throughout the book, and thus giving you practical and useful
    examples.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在更多选项，因此根据需要深入阅读主要页面。我们将在整本书中使用不同的选项，从而为您提供实用且有用的示例。
- en: Creating conditional statements using if
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`if`语句创建条件语句
- en: As we have seen so far, it is possible to build simple conditions using command-line
    lists. These conditional statements can be written both with and without a test.
    As the complexity of the tasks increases, it becomes easier to create statements
    using `if`. This will certainly ease both the readability of the script and the
    logic layout. To a degree, it also matches the way in which we think and speak;
    `if` is a semantic in our spoken language in the same way it is within the bash
    script.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过使用命令行列表，构建简单的条件是可能的。这些条件语句可以有或没有测试。随着任务复杂性的增加，使用`if`语句创建语句变得更加简单。这肯定会提高脚本的可读性和逻辑布局。从某种程度上说，它也符合我们思考和表达的方式；`if`在我们的口语中就像在bash脚本中一样，都是一种语义。
- en: 'Even though it will take up more than a single line in the script, with an
    `if` statement we can achieve more and make the script more legible. That being
    said, let''s look at creating `if` conditions. The following is an example of
    a script using an `if` statement:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在脚本中会占用多于一行，但通过使用`if`语句，我们可以实现更多功能，并使脚本更具可读性。话虽如此，让我们来看看如何创建`if`条件。以下是一个使用`if`语句的脚本示例：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code within the `if` statement will run only when the condition evaluates
    to true, and the end of the `if` block is denoted with `fi` - `if` backward. The
    color coding in `vim` can be useful to aid readability, which you will see in
    the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句中的代码仅在条件为真时运行，`if`语句块的结束由`fi`表示——`if`的倒写。在`vim`中的颜色编码有助于提高可读性，您将在下面的截图中看到：'
- en: '![](img/e3c54fe4-dc6f-47c5-b4cf-70fd7e8ec78b.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3c54fe4-dc6f-47c5-b4cf-70fd7e8ec78b.png)'
- en: Within the script, we can easily add in multiple statements to run when the
    condition is `true`. In our case, this includes exiting the script with an error
    indicated, as well as including the `usage` statement to assist the user. This
    ensures that we only display the `hello` message if we have supplied a name of
    the person to be welcomed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们可以轻松添加多个语句，当条件为`true`时运行。在我们的案例中，这包括退出脚本并显示错误提示，以及包含`usage`语句以帮助用户。这样可以确保我们只有在提供了被欢迎人的名字时才显示`hello`消息。
- en: 'We can view the script execution both with and without the argument in the
    following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下截图查看脚本执行的情况，分别是在有和没有参数的情况下：
- en: '![](img/7f8039a1-0737-44e3-afff-0e749ba74e1d.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f8039a1-0737-44e3-afff-0e749ba74e1d.png)'
- en: 'The following pseudocode shows the syntax of the `if` conditional statement:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码展示了`if`条件语句的语法：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Indenting the code is not required, but it helps readability and is highly recommended.
    Adding the `then` statement to the same line as the `if` statement, again assists
    with the readability of the code, and the semicolon is required to separate the
    `if` from the `then`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进代码不是必须的，但它有助于提高可读性，并且强烈推荐。将`then`语句与`if`语句写在同一行也有助于提高代码的可读性，并且需要使用分号将`if`与`then`分隔开。
- en: Extending if with else
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`else`扩展`if`
- en: 'When a script is required to continue regardless of the result of the `if`
    condition, it is often necessary to deal with both conditions of the evaluation,
    what to do when it is `true` as well as `false`. This is where we can make use
    of the `else` keyword. This allows the execution of one block of code when the
    condition is true and another when the condition is evaluated as false. The pseudocode
    for this is shown as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本需要继续执行，无论`if`条件结果如何时，通常需要处理评估的两个条件，即`true`和`false`时的操作。这时可以使用`else`关键字。这样可以在条件为真时执行一个代码块，在条件为假时执行另一个代码块。以下是该伪代码：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we consider extending the `hello5.sh` script that we created earlier, it
    is easily possible to allow for the correct execution, regardless of the parameter
    being present or not. We can recreate this as `hello6.sh`, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑扩展之前创建的`hello5.sh`脚本，完全可以确保无论参数是否存在，都能正确执行。我们可以将其重新创建为`hello6.sh`，如下所示：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The script now sets a named variable, which helps readability, and we can assign
    the correct value to `$name` from the input parameter or from the `read` prompt;
    either way the script is working well and starting to take shape.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本设置了一个命名变量，这有助于提高可读性，我们可以将正确的值从输入参数或`read`提示中赋给`$name`；无论哪种方式，脚本都能很好地工作并开始成型。
- en: Test command with the if command
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`if`命令测试
- en: You have seen how to use the `test` command or the short version `[ ]`. This
    test returns zero (true) or non-zero (false).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何使用`test`命令或简写的`[ ]`。这个测试返回零（true）或非零（false）。
- en: You will see how to check the returned result using the `if` command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如何使用`if`命令检查返回结果。
- en: Checking strings
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查字符串
- en: 'You can use the `if` command with the `test` command to check if the string
    matches a specific criterion:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`if`命令与`test`命令结合使用，检查字符串是否符合特定条件：
- en: '`if [$string1 = $string2]`: This checks if `string1` is identical to `string2`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if [$string1 = $string2]`：检查`string1`是否与`string2`相同'
- en: '`if [$string1 != $string2]`: This checks if `string1` is not identical to `string2`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if [$string1 != $string2]`：检查`string1`是否与`string2`不同'
- en: '`if [$string1 \< $string2]`: This checks if `string1` is less than `string2`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if [$string1 \< $string2]`：检查`string1`是否小于`string2`'
- en: '`if [$string1 \> $string2]`: This checks if `string1` is greater than `string2`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if [$string1 \> $string2]`：检查`string1`是否大于`string2`'
- en: The less than and greater than should be escaped with a backslash as if it shows
    a warning.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 小于号和大于号应该用反斜杠转义，以防显示警告。
- en: '`if [-n $string1]`: This checks if `string1` is longer than zero'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if [-n $string1]`：检查`string1`是否长度大于零'
- en: '`if [-z $string1]`: This checks if `string1` has zero length'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if [-z $string1]`：检查`string1`的长度是否为零'
- en: 'Let''s see some examples to explain how `if` statements work:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子来解释`if`语句是如何工作的：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/74dbf900-d13c-41cf-a80c-4e18abd68a4a.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74dbf900-d13c-41cf-a80c-4e18abd68a4a.png)'
- en: This `if` statement checks if strings are identical or not; since the strings
    are not identical, because one of them has a capital letter, they are identified
    as not identical.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if`语句检查字符串是否相同；由于字符串不相同，因为其中一个包含了大写字母，它们被判定为不相同。
- en: Note the space between the square brackets and the variables; without this space
    it will show a warning in some cases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方括号与变量之间的空格；如果没有这个空格，某些情况下会显示警告。
- en: 'The not-equal operator (`!=`) works the same way. Also, you can negate the
    `if` statement and it will work the same way, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于运算符（`!=`）的作用相同。此外，你可以对`if`语句取反，它也会按照相同的方式工作，如下所示：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The less-than and greater-than operators check if the first string is greater
    than or less than the second string from the ASCII-order perspective:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 小于号和大于号运算符检查第一个字符串是否从ASCII顺序上大于或小于第二个字符串：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](img/ff88ad5f-cd5f-4136-be1d-75c2fd803432.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff88ad5f-cd5f-4136-be1d-75c2fd803432.png)'
- en: In the ASCII order, the lower-case characters are higher than the upper case.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASCII顺序中，小写字母的值高于大写字母。
- en: Don't get confused if you use the `sort` command to sort a file or similar,
    and find that the sorting order works the opposite way to the `test` command.
    This is because the `sort` command uses the numbering order from the system settings,
    which is the opposite to the ASCII order.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`sort`命令对文件进行排序或者类似的操作，发现排序顺序与`test`命令的排序方向相反，别搞混淆。这是因为`sort`命令使用了系统设置的数字顺序，而这个顺序与ASCII顺序正好相反。
- en: 'To check the string length, you can use the `-n` test:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查字符串长度，你可以使用`-n`测试：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](img/11a536ac-c91c-40a0-999a-b510d4ae52fe.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11a536ac-c91c-40a0-999a-b510d4ae52fe.png)'
- en: 'To check for a length of zero, you can use the `-z` test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查长度是否为零，你可以使用`-z`测试：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/3883875a-03ce-4aa8-886f-86a9e8bf9e4c.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3883875a-03ce-4aa8-886f-86a9e8bf9e4c.png)'
- en: We have used quotes around the tested strings, even though our string has no
    spaces.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试字符串时使用了引号，即使我们的字符串中没有空格。
- en: In case you have a string with spaces, you **MUST** use quotes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含空格的字符串，你**必须**使用引号。
- en: Checking files and directories
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件和目录
- en: Similarly, you can check files and directories using the `if` statement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用`if`语句检查文件和目录。
- en: 'Let''s look at an example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个例子：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We used the `-d` test to check if the path is a directory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`-d`测试来检查路径是否为目录。
- en: The rest of the tests work the same way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的测试方法都一样。
- en: Checking numbers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查数字
- en: Also, in the same way, we can check numbers using the `test` and the `if` commands.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以使用`test`和`if`命令检查数字。
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/1067d6cb-c22a-4133-94a4-7bccbe1c20a2.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1067d6cb-c22a-4133-94a4-7bccbe1c20a2.png)'
- en: As expected, `12` is greater than `10`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的，`12`大于`10`。
- en: All other numeric tests work the same way.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他的数字测试方式相同。
- en: Combining tests
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合测试
- en: You can combine multiple tests and check them using one `if` statement.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个测试结合起来，使用一个`if`语句进行检查。
- en: 'This is done using the `AND` (`&&`) and `OR` (`||`) commands:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用`AND`（`&&`）和`OR`（`||`）命令来完成：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/f63859d4-b6fb-4942-b9fc-06966967efab.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f63859d4-b6fb-4942-b9fc-06966967efab.png)'
- en: The `if` statement performs two checks, it checks if the directory exists and
    that the name is not of zero length.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句执行了两个检查，它检查目录是否存在，并且名称的长度是否为零。'
- en: The two tests must return success (zero) to evaluate the next `echo` command.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试必须成功（返回零），才能执行下一个`echo`命令。
- en: If one of them fails, the `if` statement goes to the `else` clause.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个测试失败，`if`语句会进入`else`子句。
- en: Unlike the `OR` (`||`) command, if any of the tests returns success (zero),
    the `if` statement succeeds.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与`OR`（`||`）命令不同，如果任何一个测试返回成功（零），`if`语句就会成功。
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/0d829e61-aeed-48c1-8224-2a5902974186.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d829e61-aeed-48c1-8224-2a5902974186.png)'
- en: It is clear enough that if one of the tests returns true, the `if` statement
    returns true for the combined tests.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，如果其中一个测试返回真，`if`语句会对所有组合的测试返回真。
- en: More conditions with elif
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用elif的更多条件
- en: 'Moving on to where we require a greater degree of control, we can use the `elif`
    keyword. Unlike `else`, `elif` requires an additional condition to be tested for
    each `elif`. In this way, we can provide for different circumstances. We can add
    in as many `elif` conditions as required. The following shows some pseudocode:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要更高控制度时，可以使用`elif`关键字。与`else`不同，`elif`每次都需要一个附加的条件进行测试。通过这种方式，我们可以根据不同的情况做出不同的处理。我们可以根据需要添加任意多个`elif`条件。以下是一些伪代码示例：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A script may make life easier for the operator by providing a simplified selection
    for a more complex piece of code. Even though the script becomes gradually more
    complex to meet the requirements, to the operator the execution is greatly simplified.
    It is our job to enable users to run more complex operations easily from the command
    line when creating scripts. Often, this will necessitate the addition of more
    complexity to our scripts; however, we will be rewarded with the reliability of
    the scripted application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以通过提供简化的选择来帮助操作员完成更复杂的代码部分。尽管脚本逐渐变得更加复杂以满足需求，但对于操作员来说，执行变得大大简化。我们的工作是让用户能够通过命令行轻松运行更复杂的操作，在创建脚本时，通常这需要向脚本中添加更多的复杂性；然而，我们将收获脚本化应用的可靠性。
- en: Creating the backup2.sh using elif
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用elif创建backup2.sh
- en: We can revisit the script that we created to run the earlier backup. This script,
    `$HOME/bin/backup.sh`, prompts the user for the file type and the directory in
    which to store the backup. The tools used for the backup are `find` and `cp`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新审视之前创建的脚本，用于运行先前的备份。这个脚本`$HOME/bin/backup.sh`会提示用户选择文件类型和存储备份的目录。备份使用的工具是`find`和`cp`。
- en: With this new-found knowledge, we can now allow the script to run the backup
    using the command `tar` and the level of compression selected by the operator.
    There is no requirement to select the file type, as the complete home directory
    will be backed up, with the exclusion of the backup directory itself.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新学到的知识，我们现在可以允许脚本使用`tar`命令进行备份，并根据操作员选择的压缩级别进行压缩。无需选择文件类型，因为整个主目录会被备份，但会排除备份目录本身。
- en: 'The operator can select the compression based on three letters: `H`, `M`, and
    `L`. The selection will affect the options passed to the `tar` command and the
    backup file created. The selection of high uses `bzip2` compression, medium uses
    `gzip` compression, and low creates an uncompressed `tar` archive. The logic exists
    in the extended `if` statement that follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员可以根据三个字母`H`、`M`和`L`选择压缩级别。选择将影响传递给`tar`命令的选项以及创建的备份文件。高压缩使用`bzip2`，中等压缩使用`gzip`，低压缩则创建未压缩的`tar`归档。该逻辑存在于后续的扩展`if`语句中：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Based on the user selection, we can configure the correct options for the `tar`
    command. As we have three conditions to evaluate, the `if`, `elif`, and `else`
    statements are appropriate. To see how the variables are configured we can look
    at the following extract from the script:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的选择，我们可以为`tar`命令配置正确的选项。由于我们有三个条件需要评估，`if`、`elif`和`else`语句是合适的。要查看变量如何配置，我们可以参考以下脚本片段：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The complete script can be created as `$HOME/bin/backup2.sh` and should comprise
    the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以创建为`$HOME/bin/backup2.sh`，并应包含以下代码：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we execute the script, we need to select `H`, `M`, or `L` in upper case,
    as this is how the selection is made within the script. The following screenshot
    shows the initial script execution, where the selection for `M` has been made:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行脚本时，需要选择大写的`H`、`M`或`L`，因为在脚本中就是这样进行选择的。以下截图显示了初始脚本执行的情况，其中已经选择了`M`：
- en: '![](img/5db19093-f5be-42e5-9e7f-8d31490c4835.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5db19093-f5be-42e5-9e7f-8d31490c4835.png)'
- en: Using case statements
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用case语句
- en: Rather than using multiple `elif` statements, a `case` statement may provide
    a simpler mechanism when evaluations are made on a single expression.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用多个`elif`语句，`case`语句在对单一表达式进行评估时，可能提供一种更简便的机制。
- en: 'The basic layout of a `case` statement is listed as follows, using pseudocode:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`语句的基本布局如下所示，使用伪代码：'
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The statement layout that we see is not dissimilar to the `switch` statements
    that exist in other languages. In bash, we can use the `case` statement to test
    for simple values, such as strings or integers. Case statements can cater for
    a wide range of letters, such as `[a-f]` or `a` through to `f`, but they cannot
    easily deal with integer ranges such as `[1-20]`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的语句布局与其他语言中的`switch`语句相似。在bash中，我们可以使用`case`语句来测试简单的值，例如字符串或整数。`case`语句可以处理广泛的字母范围，例如`[a-f]`或从`a`到`f`，但它不能轻松处理如`[1-20]`这样的整数范围。
- en: The `case` statement will first expand the expression and then it will try to
    match it with each item in turn. When a match is found, all the statements are
    executed until the `;;`. This indicates the end of the code for that match. If
    there is no match, the case `else` statement indicated by the `*` will be matched.
    This needs to be the last item in the list.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`语句首先会扩展表达式，然后尝试逐个与每个项目进行匹配。当找到匹配项时，所有语句都会执行，直到遇到`;;`，这表示该匹配的代码结束。如果没有匹配项，将匹配`case`语句中的`else`部分，即由`*`表示的项。这必须是列表中的最后一项。'
- en: 'Consider the following script `grade.sh`, which is used to evaluate grades:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下脚本`grade.sh`，它用于评估成绩：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The script first uses an `if` statement to check that exactly two arguments
    have been supplied to the script. If they are not supplied, the script will exit
    with an error state:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先使用`if`语句检查是否确实向脚本提供了两个参数。如果没有提供，脚本将以错误状态退出：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then we use parameter expansion for the value of the `$2` variable to capitalize
    the input using `^^`. This represents the grade that we supply. Since we are capitalizing
    the input, we first try to match against the letters `A` through to `C`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用参数扩展 `$2` 变量的值，通过 `^^` 来将输入转换为大写。这代表我们提供的等级。由于我们在将输入转换为大写，因此我们首先尝试与字母
    `A` 到 `C` 进行匹配。
- en: We make similar tests for the other supplied grades, `E` through to `F`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对其他提供的等级 `E` 到 `F` 进行了类似的测试。
- en: 'The following screenshot shows the script execution with different grades:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了不同等级下脚本执行的情况：
- en: '![](img/a8e5aec7-d0e4-4654-930d-65d27d51e8fb.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8e5aec7-d0e4-4654-930d-65d27d51e8fb.png)'
- en: Recipe – building a frontend with grep
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配方 – 使用 grep 构建前端
- en: 'As a finale to this chapter, we will group a few features that we have learned
    together and build a script that prompts the operator for a filename, a search
    string, and an operation to carry out with the `grep` command. We will create
    the script as `$HOME/bin/search.sh`, and don''t forget to make it executable:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的结尾，我们将把一些我们学到的功能组合在一起，编写一个脚本，提示操作员输入文件名、搜索字符串和要使用 `grep` 命令执行的操作。我们将创建脚本文件
    `$HOME/bin/search.sh`，并且不要忘记将其设为可执行：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We start by checking for exactly three input arguments using the following
    code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下代码开始检查是否正好有三个输入参数：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The next check uses a command-line list to exit the script if the file argument
    is not a regular file, using `test -f`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个检查使用命令行列表，如果文件参数不是常规文件，则退出脚本，使用 `test -f`：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `case` statement allows for three operations:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 语句允许进行三种操作：'
- en: Counting the matching lines
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计匹配的行
- en: Printing the matching lines
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印匹配的行
- en: Printing all but the matching lines
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印除匹配行之外的所有行
- en: 'The following screenshot shows the search of the `/etc/ntp.conf` file for lines
    beginning with the string server. We choose the count option in this example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 `/etc/ntp.conf` 文件中搜索以字符串 server 开头的行。在这个例子中，我们选择了 count 选项：
- en: '![](img/0138fe56-7b1e-4b12-b8fc-3740b01bfca0.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0138fe56-7b1e-4b12-b8fc-3740b01bfca0.png)'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: One of the most important and time-consuming tasks in scripting is building
    all of the conditional statements that we need to make the script usable and robust.
    There is an 80/20 rule that is often spoken of. This is where 20 percent of your
    time is spent in writing the main script and 80 percent of the time is spent in
    ensuring that all of the possible eventualities are correctly handled in the script.
    This is what we refer to as the procedural integrity of the script, where we try
    to cover each scenario carefully and accurately.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本时，最重要且耗时的任务之一就是构建所有的条件语句，使脚本既可用又稳健。通常会提到一个 80/20 法则：20%的时间用于编写主要脚本，而80%的时间用于确保脚本中所有可能的情况都得到正确处理。这就是我们所说的脚本的过程完整性，我们尝试仔细而准确地涵盖每一种场景。
- en: We started by looking at a simple test with command-line lists. If the actions
    needed are simple, then these provide great functionality and are easily added.
    Where more complexity is required, we add `if` statements.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看了一个简单的命令行列表测试。如果需要的操作比较简单，那么这些命令提供了很好的功能，并且容易添加。在需要更多复杂性时，我们会加入 `if` 语句。
- en: Using the `if` statements, we can extend them as required using the `else` and
    `elif` keywords. Don't forget that `elif` keywords need their own conditions to
    evaluate.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if` 语句时，我们可以根据需要通过 `else` 和 `elif` 关键字扩展它们。别忘了 `elif` 关键字需要有自己的条件来进行评估。
- en: We saw how to use `if` statements with the `test` command, and check strings,
    files, and numbers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用 `if` 语句与 `test` 命令一起检查字符串、文件和数字。
- en: Finally, we saw how we can use `case` where a single expression needs to be
    evaluated.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何使用 `case` 语句来评估一个需要单一表达式的情况。
- en: In the next chapter, we will seek to understand the importance of reading in
    already prepared code snippets. We will create a sample `if` statement that can
    be saved as a code snippet to be read into the script at the time of editing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨阅读已经准备好的代码片段的重要性。我们将创建一个示例 `if` 语句，可以将其保存为代码片段，在编辑时加载到脚本中。
- en: Questions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'What is the result of the following code: `True` or `False`?'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的结果是什么：`True` 还是 `False`？
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Which one of the following scripts is correct?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个脚本是正确的？
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Or
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How many commands can be used as an operator to return `True` in the following
    example?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下示例中，可以使用多少个命令作为操作符来返回 `True`？
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What is the result of the following code?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的结果是什么？
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Further reading
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Please see the following for further reading relating to this chapter:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下内容，以获取更多与本章相关的阅读材料：
- en: '[http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-6.html](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-6.html)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-6.html](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-6.html)'
- en: '[http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html)'
- en: '[http://wiki.bash-hackers.org/commands/classictest](http://wiki.bash-hackers.org/commands/classictest)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://wiki.bash-hackers.org/commands/classictest](http://wiki.bash-hackers.org/commands/classictest)'
