- en: Passing Data through the Pipeline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过管道传递数据
- en: 'In this chapter, we cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括以下主题：
- en: Selecting columns from the output
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中选择列
- en: Limiting the number of items returned by a cmdlet
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制 cmdlet 返回的项目数量
- en: Expanding selections
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展选择
- en: Filtering objects
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤对象
- en: Grouping the output
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对输出进行分组
- en: Sorting the output
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对输出进行排序
- en: Taking actions on the returned objects
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对返回的对象采取行动
- en: Understanding pipeline-enabled parameters
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解启用管道的参数
- en: Importing content into PowerShell
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容导入 PowerShell
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: It is time for some information feasting now. In the previous chapter, *First
    Steps in Administration using PowerShell*, we looked at a few simple concepts
    such as working with dates and processes. In doing so, we learnt a thing or two
    about using PowerShell as well, for example, measuring the output objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是信息大餐的时刻了。在上一章，*PowerShell 管理的第一步*中，我们探讨了一些简单的概念，例如操作日期和进程。在此过程中，我们也学到了如何使用
    PowerShell 的一些技巧，比如衡量输出对象。
- en: 'In this chapter, we will learn to use one of those things that make PowerShell
    highly efficient and friendly: The Pipeline.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习使用 PowerShell 高效且友好的工具之一：管道。
- en: Most Linux administrators would have used the pipeline in their shell commands
    or shell scripts. And most administrators who use any form of shell scripting
    would be aware that the pipe sends the output of one command as input to the next.
    It is also true in case of Bash (and its derivatives) that the pipe sends *text*
    from the preceding command to the succeeding one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 管理员在其 shell 命令或 shell 脚本中使用过管道。并且使用任何形式的 shell 脚本的管理员都知道，管道将一个命令的输出作为输入传递给下一个命令。在
    Bash（及其衍生版本）的情况中，管道会将*文本*从前一个命令传递到下一个命令。
- en: Most PowerShell cmdlets output objects. And the pipeline in PowerShell sends
    the output *object* to the next command. When we run a PowerShell command (and
    not a Linux command) in PowerShell, we get a table-like output in most cases.
    We may think that it is all of the output.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 PowerShell cmdlet 输出对象。PowerShell 中的管道将输出的*对象*传递给下一个命令。当我们在 PowerShell 中运行
    PowerShell 命令（而不是 Linux 命令）时，通常会得到类似表格的输出。我们可能认为这就是所有的输出。
- en: 'When we ask PowerShell to get any information, it pulls out entire the object
    in the background. This object (or a package that contains a lot of objects) is
    then processed using PowerShell''s built-in formatting rules in order for it to
    be displayed on the host. To quote Microsoft:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要求 PowerShell 获取任何信息时，它会在后台提取整个对象。然后，这个对象（或包含大量对象的包）会使用 PowerShell 内置的格式化规则进行处理，以便在主机上显示。引用微软的话：
- en: What you see onscreen is a summary of information, and not a complete representation
    of the output object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示的是信息的摘要，而不是输出对象的完整表示。
- en: Therefore, more often than not, what you see on the screen as the output of
    a certain command, is just a tip of the iceberg! Just that the *submerged* part
    was chosen not to be displayed based on the formatting rules. In this chapter,
    we will use the pipeline to get more from the objects, than is displayed on the
    screen by default, and leverage the capability of the pipeline to get more out
    of PowerShell than meets the eye.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常情况下，您在屏幕上看到的某个命令的输出，只是冰山一角！只是因为*潜藏*部分根据格式化规则被选择不显示。在本章中，我们将使用管道获取比默认屏幕显示更多的对象内容，并利用管道的功能，从
    PowerShell 中挖掘更多的信息。
- en: Selecting columns from the output
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从输出中选择列
- en: When my brother saw me exploring `awk`, he said, 'Boy, have we overused this
    command!' Of course, not everything displayed on the screen is important—or even
    necessary. In this recipe, we learn to separate the columns in PowerShell, without
    using the Linux command, `awk`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我哥哥看到我在探索 `awk` 时，他说：“伙计，我们过度使用这个命令了！”当然，并不是所有在屏幕上显示的内容都是重要的——甚至并非必要。在本节中，我们将学习如何在
    PowerShell 中分隔列，而无需使用 Linux 命令 `awk`。
- en: Getting Ready
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Go to a directory that has some files that we can play with. If you do not have
    such a directory, create one and create some files in there. Let the files be
    of different extensions, so that we can use them in the future recipes as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 转到一个包含一些可以操作的文件的目录。如果你没有这样的目录，可以创建一个并在其中创建一些文件。让文件具有不同的扩展名，以便我们在未来的教程中也可以使用它们。
- en: If you have not already, clone the git repository, [https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook](https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook).
    There is a quick-and-dirty script, `Initialize-PacktPs6CoreLinuxLab.ps1` under
    the directory, `chapter-05`. Run the script to get the necessary files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有克隆 Git 仓库，[https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook](https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook)。在目录`chapter-05`下有一个快速而简便的脚本，`Initialize-PacktPs6CoreLinuxLab.ps1`。运行该脚本以获取必要的文件。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: The `awk` command works with text, and based on the delimiters in the output
    text, separates the output into columns. This separated output is displayed as
    columns again, using a the `print` function, like in C. PowerShell works a little
    differently.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令处理文本，并根据输出文本中的分隔符，将输出分成多个列。这个分隔的输出再次以列的形式显示，使用类似C语言中的`print`函数。PowerShell
    的工作方式稍有不同。'
- en: Let us get started.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: If you did not create files, please do so. Here are some commands you could
    use to create the files.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有创建文件，请创建。以下是一些你可以用来创建文件的命令。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may also want to download some real multimedia content, just so we get the
    `length` (file size) property for future use. Just download any random images
    or media files.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也许想下载一些真实的多媒体内容，以便我们获取`length`（文件大小）属性，供以后使用。随便下载一些随机的图片或媒体文件。
- en: Navigate to the location where you saved the files. I have them in a directory
    called `random` in my home directory. You would, too, if you used the script.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你保存文件的位置。我将它们保存在我的主目录下一个名为`random`的目录中。如果你使用了脚本，应该也会这样。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use tab-completion to complete the cmdlet as well as the path.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Tab 补全来完成 cmdlet 和路径。
- en: List out the contents in the current location.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前目录下的内容。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/fc1b8222-bc35-4723-bc80-b3c548ec789f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc1b8222-bc35-4723-bc80-b3c548ec789f.png)'
- en: Let us say, you do not require the `Mode` column.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你不需要`Mode`列。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/66a9b353-b59f-4822-9b84-ea92bae58933.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66a9b353-b59f-4822-9b84-ea92bae58933.png)'
- en: If you notice, select does not seem to follow the naming or capitalisation convention
    that PowerShell uses. How is that? Run `Get-Command select` to find out.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，`select`似乎没有遵循 PowerShell 使用的命名或大小写约定。是怎么回事呢？运行`Get-Command select`来找出原因。
- en: This sequence does not really make sense to you in the current context. Shuffle
    the columns.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前的上下文中，这个顺序对你来说并没有太大意义。重新排列列的顺序。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/3f839c8d-22b8-45c0-bbf9-913af8c94295.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f839c8d-22b8-45c0-bbf9-913af8c94295.png)'
- en: That looks much better.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来好多了。
- en: Now, change the column name of `LastWriteTime` to `Modified`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`LastWriteTime`列的名称改为`Modified`。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the name of the last column now, and compare it with the previous output.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一列的名称，并与之前的输出进行对比。
- en: Now, pick just the year; not the entire date.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只选择年份，不要整个日期。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See how many days have passed since the last change.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看自上次更改以来已过去多少天。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: If you ran `Get-Command select`, you would have understood by now, that `select`
    is in fact an alias for `Select-Object`. As already established, PowerShell outputs
    objects. These objects are then formatted using built-in formatting rules to show
    on the screen a certain way.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了`Get-Command select`，你现在应该已经明白，`select`实际上是`Select-Object`的别名。如前所述，PowerShell
    输出对象。这些对象随后使用内置的格式化规则进行格式化，并以特定方式显示在屏幕上。
- en: When we use the `Select-Object`, we override the formatting rules by specifying
    which objects need to be shown to us. While the primary objective of `Select-Object`
    is to pick the columns we need, the cmdlet also allows us to sequence the output
    columns.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Select-Object`时，我们通过指定需要显示哪些对象来覆盖格式化规则。虽然`Select-Object`的主要目的是选择我们需要的列，但该
    cmdlet 还允许我们对输出列进行排序。
- en: PowerShell also gives us the freedom to modify the name of the columns returned.
    In such a case, we use a *hashtable* to specify the name that we want, and what
    data we want shown under the column. You can even perform calculations on the
    data returned, and make this a calculated property. At the last step, we subtract
    the date of last modification from the current date, pick the total number of
    days that have passed since, and then, use the `Round` method of the `[math]`
    accelerator to get a rounded figure of the number of days since the last modification.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 同样为我们提供了修改返回列名的自由。在这种情况下，我们使用*哈希表*来指定我们想要的名称，以及在该列下显示的数据。你甚至可以对返回的数据进行计算，并将其设置为计算属性。在最后一步，我们从当前日期中减去最后修改日期，选取自那时起经过的天数，然后，使用`Round`方法和`[math]`加速器来获得最后修改以来天数的四舍五入值。
- en: The concept of `$_` or `$PSItem`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_` 或 `$PSItem` 的概念。'
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Try `Select-Object` with other cmdlets such as `Get-Command`, to select only
    those columns that you need.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将`Select-Object`与其他 cmdlet（如 `Get-Command`）一起使用，来仅选择你需要的那些列。
- en: See also
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Recipe : Creating and initialising a simple hash table.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：创建并初始化一个简单的哈希表。
- en: Limiting the number of output objects
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制输出对象的数量
- en: In the previous recipe, *Selecting columns from the output*, we saw how the
    `Select-Object` cmdlet can be used to select only the columns we want. In this
    recipe, we will learn to limit the output of a cmdlet to a subset of the total
    items returned.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，*从输出中选择列*，我们学习了如何使用 `Select-Object` cmdlet 来仅选择我们需要的列。在本示例中，我们将学习如何将
    cmdlet 的输出限制为返回的所有项目的子集。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: Ensure that you are at a location that has a few files. List out the contents
    of the current directory and count the number of items returned. If the number
    is less than five, you may want to consider adding more items to the directory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在一个包含一些文件的位置。列出当前目录的内容，并计算返回的项目数量。如果数量少于五个，你可能需要考虑向目录中添加更多项目。
- en: Enter the following command to count the number of files and directories at
    the current path.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以计算当前路径下文件和目录的数量。
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you would like to reduce keystrokes, given that we are only running commands
    at the terminal, you could use the alias and the defaults of the cmdlet.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想减少输入的字符数，考虑到我们仅在终端运行命令，你可以使用 cmdlet 的别名和默认设置。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Those parentheses are required; the parentheses work almost similar to how
    they work in mathematics: the instruction within the parentheses is processed
    first. In this case, we want `gci` executed first, and then, the `Count` property
    from within the returned object picked.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些括号是必须的；括号的工作方式与数学中的相似：括号内的指令会先被处理。在这种情况下，我们希望首先执行 `gci`，然后选择从返回对象中获取的 `Count`
    属性。
- en: Get the list of parameters `Select-Object` has.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 `Select-Object` 的参数列表。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We see parameters like, `First` and `Last`, and they accept integer values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到诸如 `First` 和 `Last` 的参数，它们接受整数值。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Navigate to the directory where you have the files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到包含文件的目录。
- en: Select only the first five files and directories from the returned list, using
    the `First` parameter.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `First` 参数，仅从返回的列表中选择前五个文件和目录。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let us say you would like to pick the last five elements.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你想要选取最后五个元素。
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To skip the first three objects:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过前三个对象：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you would like to skip the last two objects:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想跳过最后两个对象：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To pick the fourth element from the output:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中选取第四个元素：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, combine it with what we learnt in the previous recipe. Pick only the file
    names and the last modified time of the first four elements.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将其与我们在前一个示例中学到的结合起来。仅选取前四个元素的文件名和最后修改时间。
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is a simple recipe that helps you work with the number of items returned
    in the output. With `Select-Object` in PowerShell, we need not loop through output,
    while simultaneously counting, to only get the number of elements that we want.
    The `Select-Object` cmdlet has that functionality built in.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，帮助你处理输出中返回项目的数量。在 PowerShell 中使用 `Select-Object`，我们不需要通过输出循环并计数，只为了获取我们想要的元素数量。`Select-Object`
    cmdlet 已内置该功能。
- en: 'The parameter names are self-explanatory. Except perhaps the `Index` parameter,
    which works exactly how numbering of array elements works with most programming
    languages: it starts with zero. Therefore, the fourth element in the array would
    have an index of `3`, and not `4`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称不言自明。也许除了 `Index` 参数，它的工作方式与大多数编程语言中的数组元素编号方式相同：从零开始。因此，数组中的第四个元素的索引是 `3`，而不是
    `4`。
- en: The parameters, `Property` and `First` can be combined together since they both
    feature in the same parameter set in the help documentation for `Select-Object`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Property` 和 `First` 这两个参数可以结合使用，因为它们都出现在 `Select-Object` 的帮助文档中的同一个参数集里。'
- en: Expanding the properties within properties
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开属性中的属性
- en: 'So far from what we have seen, two things are clear to us:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，从我们所看到的两件事已经很明确：
- en: An object output feels richer and makes using it easier.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象输出显得更加丰富，使用起来也更方便。
- en: An object can have more objects within it.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个对象可以包含更多的对象。
- en: We have handled the first point using the `Select-Object` cmdlet, wherein we
    picked only the objects properties that we needed, and omitted the rest. This
    recipe is designed to break down the second point for better understanding.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过使用 `Select-Object` cmdlet 处理了第一个点，其中我们只选择了需要的对象属性，忽略了其他的。这一部分教程旨在分解第二个点，帮助更好地理解。
- en: 'Let us step into this recipe with one thing in our mind: objects can contain
    objects within them, which in turn can contain more objects within them. To demonstrate
    this, we shall use the `Get-Process` cmdlet.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们带着一个想法进入这个教程：对象可以包含对象，而这些对象又可以包含更多对象。为了演示这一点，我们将使用 `Get-Process` cmdlet。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let us begin with listing out the processes; we shall look at all the properties
    the `Get-Process` cmdlet gives us and look for complex ones.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从列出所有进程开始；我们将查看 `Get-Process` cmdlet 提供的所有属性，并寻找复杂的对象。
- en: Select all the properties that are part of the output of the `Get-Process` cmdlet.
    Pick only the first object, so your console is not filled with content.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Get-Process` cmdlet 输出中的所有属性。只选择第一个对象，以免你的控制台输出过多内容。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Observe the property, `Threads`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 `Threads` 属性。
- en: Select the name of the process, the ID and the threads.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择进程的名称、ID 和线程。
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: List out all the threads for the `pwsh` process.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出 `pwsh` 进程的所有线程。
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A lot of content is output. Say, we want just the ID, the priority, and the
    start time of the resulting output.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出内容很丰富。假设我们只需要结果输出中的 ID、优先级和启动时间。
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This gave us the ID, the priority level and the start time of all the threads
    that are running under `pwsh`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了所有在 `pwsh` 下运行的线程的 ID、优先级和启动时间。
- en: What if we use `ExpandProperty` on the ID?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们对 ID 使用 `ExpandProperty` 呢？
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/9a082625-cdef-4a3d-ab7a-dc865b01364f.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a082625-cdef-4a3d-ab7a-dc865b01364f.png)'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The default parameter for `Select-Object`, as we have seen, is `Property`. It
    accepts property names and shows their values in the output. The parameter can
    be used to fetch values of multiple properties (`Name`, `Id`, `Threads`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，`Select-Object` 的默认参数是 `Property`。它接受属性名称并在输出中显示其值。该参数可以用于提取多个属性的值（如
    `Name`、`Id`、`Threads`）。
- en: However, some properties have more complex objects within them, like how we
    saw in case of the `Threads` property of the object returned by `Get-Process`.
    A simple way to identify complex objects is to see if they are enclosed in curly
    braces.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些属性内部包含更复杂的对象，比如我们在 `Get-Process` 返回的对象的 `Threads` 属性中看到的那样。识别复杂对象的简单方法是看看它们是否被大括号包围。
- en: The `ExpandProperty` parameter accepts only a single property name as input
    and expands the property to show its objects. This can again be piped to `Select-Object`
    (or any other relevant cmdlet) for further processing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExpandProperty` 参数仅接受单个属性名称作为输入，并展开该属性以显示其内部对象。这个展开后的结果还可以通过管道传递给 `Select-Object`（或任何其他相关的
    cmdlet）进行进一步处理。'
- en: In cases where the object is not complex, `ExpandProperty` simply shows the
    output without its header. If you notice the output of `ExpandProperty`, it does
    not contain the name of the expanded object itself (`Threads` in our case); it
    contains only the value. The value, in turn has multiple properties within it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象不复杂的情况下，`ExpandProperty` 只会显示输出而没有头部。如果你注意到 `ExpandProperty` 的输出，它不包含展开的对象名称（在我们案例中是
    `Threads`）；它只包含值。这个值又包含了多个属性。
- en: In case of simple properties, using `ExpandProperty` simply strips off the property
    name from the output.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单属性的情况下，使用 `ExpandProperty` 会简单地从输出中去除属性名称。
- en: Filtering objects
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤对象
- en: In the recipe, *Limit the number of items returned by a cmdlet*, we saw how
    to restrict the output content based on a number. In this recipe, we would look
    at filtering the output based on a certain criterion, and not a number.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱《*限制cmdlet返回的项数*》中，我们看到如何根据数量限制输出内容。在本食谱中，我们将学习如何根据某个特定标准而非数量来过滤输出。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Go back to read the recipe, *Working with date properties*, if you have not
    read it already. This recipe uses one of the properties from the date object to
    filter content. While it is not critical to understand filtration of objects,
    it still demonstrates the simplicity of filtration based on object properties.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有阅读，返回阅读食谱《*与日期属性一起工作*》。本食谱使用日期对象的一个属性来过滤内容。虽然理解对象的过滤并非关键，但它仍然展示了基于对象属性的过滤是多么简单。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Navigate to the location where you created files for use with this book.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到你为本书创建文件的位置。
- en: List out the contents of this directory to see what content you have. (If you
    are like me, you would have even forgotten where you created this directory, and
    what content you put in.)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出该目录的内容，查看你有哪些内容。（如果你像我一样，可能甚至忘记了你在哪里创建了这个目录，以及你放了什么内容。）
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice the names of the properties you got.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你得到的属性名称。
- en: Now, pick only those files that are larger than `0` bytes.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只挑选那些大于`0`字节的文件。
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Pick out all the JPG files from the lot. To do this, add another condition to
    the existing condition. Although, this time, use the `FilterScript` parameter
    instead of `Property`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中挑选所有JPG文件。为此，在现有条件上再加一个条件。尽管这次使用的是`FilterScript`参数，而不是`Property`。
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Add a condition to get only those files whose names start with 'c'.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个条件，获取文件名以“c”开头的文件。
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, choose those files which were created before the 30th minute of any hour.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择那些在任何小时的第30分钟之前创建的文件。
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/b3ae5d4b-631d-4e62-9ee6-c0c105aebfb5.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3ae5d4b-631d-4e62-9ee6-c0c105aebfb5.png)'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Filtration of the output is very simple in PowerShell. Given that the content
    output is an object, we could simply use the properties from within the object
    for the filtration.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell中，输出的过滤非常简单。由于内容输出是一个对象，我们可以直接使用对象内部的属性进行过滤。
- en: 'This recipe shows two modes of filtration:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了两种过滤模式：
- en: Using one property and comparing its value to the input,
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个属性，并将其值与输入进行比较，
- en: Using a filter script, that uses multiple values, and multiple conditions.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个包含多个值和多个条件的过滤脚本。
- en: The `Property` parameter accepts only one property. A conditional operator and
    a value for comparison are added to the statement to filter the output.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Property`参数只接受一个属性。为过滤输出，条件操作符和比较值被添加到语句中。'
- en: The `FilterScript` parameter, on the other hand, can handle more complex filtration,
    for example, when we need the output to meet several conditions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`FilterScript`参数可以处理更复杂的过滤操作，例如，当我们需要输出满足多个条件时。
- en: A significant difference between using `Property` and `FilterScript` is the
    use of the automatic variable, `$_`. This variable contains the *current object*
    in the pipeline. For example, in this recipe, we pass the object from `Get-ChildItem`
    to `Where-Object` through the pipeline. The automatic variable, `$_`, contains
    the object returned by `Get-ChildItem`, so that `Where-Object` can process it.
    `$_.LastWriteTime`, in this case, picks the `LastWriteTime` property from the
    object returned by `Get-ChildItem`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Property`和`FilterScript`的一个显著区别是自动变量`$_`的使用。该变量包含管道中的*当前对象*。例如，在本食谱中，我们通过管道将`Get-ChildItem`返回的对象传递给`Where-Object`。自动变量`$_`包含`Get-ChildItem`返回的对象，`Where-Object`可以对其进行处理。在本例中，`$_.LastWriteTime`获取由`Get-ChildItem`返回的对象的`LastWriteTime`属性。
- en: Also, the `LastWriteTime` object is of type `System.DateTime` or `DateTime`.
    (Run `(Get-ChildItem .).LastWriteTime | Get-Member` to know more.) Therefore,
    it is possible to break it down further into days, hours, minutes, and so on,
    which is the reason, `$_.LastWriteTime.Minute` could be used for filtration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`LastWriteTime`对象属于`System.DateTime`或`DateTime`类型。（运行`(Get-ChildItem .).LastWriteTime
    | Get-Member`了解更多信息。）因此，它可以进一步拆解为天、小时、分钟等，这也是为什么可以使用`$_.LastWriteTime.Minute`进行过滤的原因。
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Try out the `Where-Object` cmdlet on other outputs, such as that of `Get-Process`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在其他输出上使用`Where-Object` cmdlet，例如`Get-Process`的输出。
- en: Grouping the output
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对输出进行分组
- en: There are situations where we could group the objects that were output, so that
    we could handle each group better, or simply for a more organised output. In this
    recipe, we will look at passing the output of one cmdlet through the pipeline
    to Group-Object and group the output based on a property.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，我们可以对输出的对象进行分组，以便更好地处理每个组，或者仅仅为了更有组织的输出。在本示例中，我们将通过管道将一个cmdlet的输出传递给`Group-Object`，并根据某个属性对输出进行分组。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To group objects based on a property, we use the `Get-ChildItem` cmdlet on the
    files that we created for use in this book.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据属性对对象进行分组，我们使用`Get-ChildItem` cmdlet对本书中使用的文件进行操作。
- en: Navigate to the location where you created or downloaded the files.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到你创建或下载文件的位置。
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: List out only the files (exclude the directories).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅列出文件（排除目录）。
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Or use the *shorthand* version.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用*简写*版本。
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Group the objects based on the extension.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据扩展名对对象进行分组。
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The shorthand version of this would be:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个简写版本是：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![](img/126cd1df-e553-47c3-becf-a56acb92fb78.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/126cd1df-e553-47c3-becf-a56acb92fb78.png)'
- en: Use the `Select-Object` cmdlet to only show the extension and the number of
    files in each extension.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Select-Object` cmdlet只显示扩展名和每个扩展名下的文件数。
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Is there a simpler way to do this?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有更简单的方法来做到这一点？
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now that we know how to handle grouping and expanded property selection, let
    us pick only the JPG files from the lot.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何处理分组和展开的属性选择，让我们从中挑选出所有JPG文件。
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![](img/f0b16425-bada-4fba-ad2d-f7c9a62124a9.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0b16425-bada-4fba-ad2d-f7c9a62124a9.png)'
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we did in this recipe was certainly non-intuitive, considering we could
    use just `Where-Object` along with the `Get-ChildItem`. However, the intention
    of this recipe was to demonstrate the use of `Group-Object`. The `Group-Object`
    cmdlet creates groups based on the criteria we specify, and names the groups on
    the criteria. In our case, the criteria for grouping was the extension, and hence,
    the names of the groups were the extensions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们所做的操作无疑是不直观的，因为我们本可以仅使用`Where-Object`和`Get-ChildItem`。然而，本示例的目的是展示如何使用`Group-Object`。`Group-Object`
    cmdlet会根据我们指定的标准创建组，并根据该标准命名这些组。在我们的例子中，分组的标准是扩展名，因此，组的名称就是扩展名。
- en: Each of these groups contains its elements, which are objects in themselves.
    If we simply want the count and the names of the groups, we use the `NoElement`
    parameter. If we want only the elements, we use the `ExpandProperty` parameter
    of the `Select-Object` cmdlet and expand all the elements. The elements thus expanded
    are the objects of the cmdlet preceding the `Group-Object` cmdlet (`Get-ChildItem`
    in our case).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组包含其元素，这些元素本身也是对象。如果我们只想要组的数量和名称，我们可以使用`NoElement`参数。如果我们只想要元素，则使用`Select-Object`
    cmdlet的`ExpandProperty`参数并展开所有元素。被展开的元素是`Group-Object`前一个cmdlet的对象（在我们的例子中是`Get-ChildItem`）。
- en: If `Where-Object` and other cmdlets could do what `Group-Object` could in a
    complicated way, why have it in the first place? Read on until *Taking actions
    on the returned objects* to know more.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Where-Object`和其他cmdlet可以以复杂的方式做`Group-Object`能做的事，那为什么还要有`Group-Object`呢？继续阅读*对返回对象采取行动*，了解更多信息。
- en: There's more...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you have gotten a hang of tab completion, you need not even select the properties
    that are not shown by default. All you have to do is type `Group-Object` after
    the pipe, add a space and press Tab; PowerShell will show you what objects are
    available to use for grouping. Try it with:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经掌握了Tab补全功能，你甚至无需选择那些默认未显示的属性。你只需要在管道后输入`Group-Object`，加一个空格并按Tab键；PowerShell会显示可用于分组的对象。试试看：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: See also
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Recipe 05.07: Taking actions on the returned objects
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 05.07：对返回的对象采取行动
- en: Sorting the output
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序输出
- en: It is time for another simple cmdlet, which would build towards the recipe,
    *Taking actions on the returned objects*. In this recipe, we will sort the output
    objects to meet our requirements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到了另一个简单的cmdlet，它将为“*对返回的对象采取行动*”这一示例奠定基础。在本示例中，我们将对输出对象进行排序，以满足我们的要求。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will continue to use the directory and the files we created for the book.
    If all of your files are of zero bytes, download a few files with content. The
    file type does not matter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用为本书创建的目录和文件。如果你的所有文件都是零字节，下载几个有内容的文件。文件类型无关紧要。
- en: List out the files in the directory.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出目录中的文件。
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Filter the output to have only files.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤输出，只有文件。
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Pipe the object to the `Sort-Object` cmdlet to sort the output based on the
    file size.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象传递给`Sort-Object` cmdlet，以根据文件大小对输出进行排序。
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The shorthand for the expression would be:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该表达式的简写为：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Sort the files, the largest file to the smallest file.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排序文件，从最大文件到最小文件。
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Pick the largest three files in the lot.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从中选择三个最大的文件。
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create two files, and, using a text editor, add some content into both of them.
    (Or use the following script block to create some random text.)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个文件，并使用文本编辑器向它们添加一些内容。（或者使用以下脚本块创建一些随机文本。）
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, sort the files in the directory, first, by size, and then, the name.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照文件大小排序目录中的文件，然后按文件名排序。
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Observe the output that you get.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 观察你得到的输出。
- en: Sort the list in the descending order.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按降序排序列表。
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![](img/98feda49-fc08-4af2-8a63-c814f055239c.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98feda49-fc08-4af2-8a63-c814f055239c.png)'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is another demonstration of passing objects through the pipeline.
    In the help documentation for `Sort-Object`, we see a parameter called `InputObject`.
    This parameter is a generic term used in PowerShell for a parameter whose input
    comes through the pipeline.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是通过管道传递对象的另一个演示。在`Sort-Object`的帮助文档中，我们看到一个名为`InputObject`的参数。这个参数是PowerShell中的一个通用术语，用来描述通过管道传递的输入参数。
- en: '`Sort-Object` accepts input from the pipeline, and sorts the content based
    on the property specified. If a property is not specified, the default property
    for the object output from the preceding command is used for sorting. If there
    are multiple properties are input, the sorting happens based on the order in which
    the properties are specified.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort-Object`接受来自管道的输入，并根据指定的属性进行排序。如果没有指定属性，则使用前一个命令输出对象的默认属性进行排序。如果输入多个属性，则根据指定属性的顺序进行排序。'
- en: Sorting can happen in the ascending order (default), or the descending order.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 排序可以按升序（默认）或降序进行。
- en: Taking actions on the returned objects
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对返回的对象执行操作
- en: We have been using the pipeline throughout this chapter to perform various activities
    on the objects. We have been passing objects from one cmdlet to another, and in
    fact, taking actions on the objects being returned. This recipe, in the technical
    sense therefore, is nothing new. However, in order to get ourselves more comfortable
    using the pipeline, and to show that the pipeline is not just used for selection,
    filtration and sorting, we will use the pipeline to also perform some deletions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在使用管道对对象执行各种操作。我们已经将对象从一个cmdlet传递到另一个cmdlet，实际上对返回的对象进行了操作。因此，从技术角度来看，这个示例并不新颖。然而，为了让我们更熟悉管道的使用，并且展示管道不仅仅用于选择、过滤和排序，我们还将使用管道执行一些删除操作。
- en: Getting Ready
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you do not have files within the demo directory that we created, please go
    ahead and create some files. Make sure some of the files have some content in
    them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在我们创建的演示目录中没有文件，请继续创建一些文件。确保其中一些文件有内容。
- en: Let us say that you have been given a requirement. There is a certain team which
    would like the top two largest files of each type, deleted from a directory. If
    there is only one file of a certain type, that file has to be left alone.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你收到一个需求。有一个团队希望删除每种类型中最大的两个文件。如果某种类型的文件只有一个，那就不删除该文件。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here is an outline of the steps you would want to take:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可能需要执行的步骤概述：
- en: Get all the files at the path specified.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取指定路径下的所有文件。
- en: Group the files by file type (extension).
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按文件类型（扩展名）分组文件。
- en: Filter out those groups that contain more than one item.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤掉包含多个项目的组。
- en: Expand each group, sort the files by size (length).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开每个组，按大小（长度）排序文件。
- en: Pick the two largest files in each group.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每个组中选择两个最大的文件。
- en: Delete the files.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除文件。
- en: While we are working on a sandbox directory, and that we are taking precautions
    not to delete anything important, it is still better to only prototype the action
    using ShouldPerform (the WhatIf parameter). This way, the files would not be actually
    deleted, but PowerShell would only tell you what it would do if the command is
    run.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们正在使用一个沙箱目录，并且采取了不删除重要文件的预防措施，但最好仅使用ShouldPerform（WhatIf参数）来原型化操作。这样，文件不会被实际删除，而是PowerShell只会告诉你如果运行该命令会执行什么操作。
- en: Let us get cracking.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: List the contents of the current directory and group the output based on the
    extension.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前目录的内容，并根据扩展名分组输出。
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Filter to discard lone files of each extension.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤以丢弃每个扩展名的单个文件。
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now comes a loop construct. We will look at how that works in a future chapter.
    For now, just know that it works. The goal here is to only leverage the pipeline.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来看一个循环结构。我们将在后续章节中详细了解它是如何工作的。目前，只需知道它能正常运行。这里的目标是充分利用管道。
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![](img/c1ae6403-f6e6-48bf-a8cb-188092d3f16e.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1ae6403-f6e6-48bf-a8cb-188092d3f16e.png)'
- en: Delete these files using the `Remove-Item` cmdlet. Use the `WhatIf` switch if
    you do not want the files actually deleted.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Remove-Item` cmdlet 删除这些文件。如果您不想实际删除文件，请使用 `WhatIf` 开关。
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: When any cmdlet reads an object through the pipeline, it reads the entire contents
    of the object. And any cmdlet that is designed to accept input through the pipeline
    picks the right property from the object, and then takes actions on the objects.
    In the case of this recipe, it was the `Path` property that was picked in order
    to identify the files to delete.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何 cmdlet 通过管道读取对象时，它读取对象的全部内容。而任何设计为通过管道接受输入的 cmdlet，则从对象中选择正确的属性，然后对这些对象执行操作。在这个例子中，选择的是
    `Path` 属性，以便识别要删除的文件。
- en: To know if a certain cmdlet accepts input from the pipeline, run `Get-Help`
    on the cmdlet with the `Full` parameter, and see if the value for `Accept pipeline
    input?` is true. The `InputObject` parameter of `Where-Object`, or the `Path`
    parameter of `Move-Item` are a couple of examples.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道某个 cmdlet 是否接受来自管道的输入，请使用 `Full` 参数运行 `Get-Help` 命令，并查看 `Accept pipeline
    input?` 的值是否为 true。`Where-Object` 的 `InputObject` 参数或 `Move-Item` 的 `Path` 参数就是其中的一些示例。
- en: Understanding pipeline-enabled parameters
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解启用管道的参数
- en: Understanding pipelines is not so much of a requirement if you plan to use PowerShell
    for only running commands on the console; it is well encapsulated, and the cmdlets
    are well designed to be able to handle passing objects between cmdlets. However,
    if you plan to create custom functions and modules, the concept of the pipeline
    is something you would want to understand well.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划仅在控制台上运行 PowerShell 命令，则了解管道不是必须的；它被很好地封装，并且 cmdlet 被设计得很好，能够处理在 cmdlet
    之间传递对象的情况。然而，如果您计划创建自定义函数和模块，则理解管道的概念是您希望深入了解的内容。
- en: In this recipe, we will look into the two ways cmdlets accept input. At the
    point where we create functions, we will look at how to enable pipeline input
    for parameters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将研究 cmdlet 接受输入的两种方式。在创建函数的时候，我们将看看如何为参数启用管道输入。
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We will mostly use the help documentation to demonstrate the two different kinds
    of pipeline input.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要使用帮助文档来演示两种不同类型的管道输入。
- en: 'At the prompt, type the following command:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符处，键入以下命令：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![](img/ece35564-34f0-4beb-a575-83b29dc0208e.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ece35564-34f0-4beb-a575-83b29dc0208e.png)'
- en: It says the parameter accepts string input, and accepts input by property name
    as well as by value.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它说该参数接受字符串输入，并且也接受通过属性名称和值输入。
- en: Type the following to see if a valid string is accepted.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容以查看是否接受有效字符串。
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![](img/2f9fadc6-7b06-4d05-a0f3-3232e4d88ab8.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f9fadc6-7b06-4d05-a0f3-3232e4d88ab8.png)'
- en: Let us try something similar with `Get-Date`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试类似的操作，使用 `Get-Date`。
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The Date parameter accepts values through the pipeline. However, the type is
    DateTime, and not string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Date 参数通过管道接受值。但类型是 DateTime，而不是字符串。
- en: Try sending a valid string through the pipeline to see if it gets converted
    into date.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过管道发送有效字符串，看看它是否被转换为日期。
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It did convert the string into date and time.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实将字符串转换为日期和时间。
- en: '![](img/9bf14887-e102-4518-aba5-ef0f00939e1d.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bf14887-e102-4518-aba5-ef0f00939e1d.png)'
- en: Now, let us go back to getting details of the current directory. This time,
    however, we would pick only the FullName property of the object.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到获取当前目录详细信息的步骤。不过，这次我们只会选择对象的 FullName 属性。
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Pass this through the pipeline to the `Get-ChildItem` cmdlet.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过管道将此传递给 `Get-ChildItem` cmdlet。
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There is an error.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了一个错误。
- en: '![](img/4b9eb33e-158a-47c3-91fa-81c8373590b4.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b9eb33e-158a-47c3-91fa-81c8373590b4.png)'
- en: Change the property name to `LiteralPath`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性名称更改为 `LiteralPath`。
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Pass the object to `Get-ChildItem` through the pipeline.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过管道将对象传递给 `Get-ChildItem`。
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That worked.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 那成功了。
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'There are two kinds of input through the pipeline:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过管道有两种类型的输入：
- en: '`ByPropertyName`'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ByPropertyName`'
- en: '`ByValue`'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ByValue`'
- en: The `ByValue` type is perhaps the most common. If a parameter accepts input
    through the pipeline by value, it would look for the data type that matches the
    defined data type in the output, and pick the output as input for itself. In case
    the data type is not the same as that defined, but can be converted to the required
    type, the parameter would convert the value into the data type it takes in, and
    processes it. This happened in the case of `Get-Date`, where we sent the date
    as a string, and passed it through the pipeline to `Get-Date`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByValue` 类型也许是最常见的。如果一个参数通过管道按值接受输入，它会查找与输出中定义的数据类型匹配的数据类型，并将输出作为其输入。在数据类型与定义的类型不相同，但可以转换为所需类型的情况下，参数会将值转换为它所接受的数据类型并进行处理。这在
    `Get-Date` 中发生过，我们将日期作为字符串发送，并通过管道传递给 `Get-Date`。'
- en: In case of `Get-Item`, the `Path` parameter accepted string input and processed
    the command. In case of `Get-Date`, the `Date` parameter converted the string
    into a `DateTime` object and processed the request.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Get-Item` 中，`Path` 参数接受字符串输入并处理命令。在 `Get-Date` 中，`Date` 参数将字符串转换为 `DateTime`
    对象并处理请求。
- en: '`ByPropertyName`, as compared to `ByValue`, looks for a property of the *exact
    same name* as the parameter. In our case, `LiteralPath` of `Get-ChildItem` threw
    an error when we passed the `FullName` property, even though it was essentially
    the literal path of the object, and a string value. The reason for the error was
    that the property was not called `LiteralPath`. When we changed the name of the
    property to `LiteralPath`, `Get-ChildItem` accepted the input through the pipeline,
    and gave us the desired output.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ByValue` 相比，`ByPropertyName` 会查找与参数*完全相同名称*的属性。在我们的例子中，`Get-ChildItem` 的
    `LiteralPath` 在我们传递 `FullName` 属性时抛出了错误，尽管它本质上是对象的字面路径，并且是一个字符串值。错误的原因是属性并没有被命名为
    `LiteralPath`。当我们将属性名称更改为 `LiteralPath` 时，`Get-ChildItem` 通过管道接受了输入，并给出了期望的输出。
- en: Importing content into PowerShell
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入内容到 PowerShell
- en: 'Administrators managing multiple computers need to have some sort of input
    fed into cmdlets so they can automate tasks. While most Linux administrators are
    familiar with sending input to files, the important point with PowerShell is that
    apart from taking file-based input (read: `Get-Content`),  PowerShell is also
    capable of *importing* input. This imported input is a PowerShell object.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 管理多个计算机的管理员需要将某些输入传递给 cmdlet，以便自动化任务。虽然大多数 Linux 管理员熟悉将输入发送到文件，但在 PowerShell
    中，重要的一点是，除了接受基于文件的输入（例如：`Get-Content`），PowerShell 还能够*导入*输入。这种导入的输入是一个 PowerShell
    对象。
- en: In this recipe, we will look at two kinds of import cmdlets and learn to work
    with them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将研究两种导入 cmdlet，并学习如何使用它们。
- en: How to do it...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the recipe, *Parsing input from text to object*, we used `Import-Csv` to
    import a comma-separated values file to convert the data contained within to a
    PowerShell object. Let us recapitulate what we learnt, however this time, now
    that we know how to work with objects, we will use the imported content in some
    way.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱 *从文本到对象的解析输入* 中，我们使用 `Import-Csv` 导入了一个以逗号分隔的值文件，将其中的数据转换为 PowerShell 对象。让我们回顾一下我们学到的内容，不过这次，由于我们已经知道如何处理对象，我们将以某种方式使用导入的内容。
- en: Before we import content, let us first export some content into a CSV file.
    This way, we would have some relevant content to manipulate.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入内容之前，让我们首先将一些内容导出到 CSV 文件。这样，我们就有了一些相关的内容可以进行操作。
- en: Navigate to the location where you created files for this chapter. List the
    contents of the directory. While the book uses (and recommends) complete cmdlets
    even at the console (using tab-completion of course), feel free to use aliases
    if you want.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你为本章创建文件的位置。列出目录的内容。尽管本书在控制台中使用（并推荐）完整的 cmdlet（当然使用 Tab 补全），但如果你愿意，也可以使用别名。
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Export the contents to a CSV file.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容导出到 CSV 文件。
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Open the file in a spreadsheet processor like LibreOffice Calc or even a text
    editor to view its contents.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 LibreOffice Calc 或文本编辑器等电子表格处理器打开该文件，以查看其内容。
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That was a plain text representation of the object returned by `Get-ChildItem.`
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Get-ChildItem` 返回的对象的纯文本表示。
- en: Import the contents of the CSV file to convert this text into an object.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 CSV 文件的内容，将文本转换为对象。
- en: '[PRE60]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Find the type of the object returned by this command.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找此命令返回的对象类型。
- en: '[PRE61]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The object type is `System.Management.Automation.PSCustomObject`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型是 `System.Management.Automation.PSCustomObject`。
- en: Check if this is the same as that returned by `Get-ChildItem`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查这是否与 `Get-ChildItem` 返回的相同。
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The object returned by `Import-Csv` is different. Is it possible to treat it
    just like we do other objects? Get the `CreationTime` using the member access
    operator.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Import-Csv`返回的对象不同。是否可以像对待其他对象一样对待它？使用成员访问运算符获取`CreationTime`。'
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Get just the year.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只选择年份。
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Find the type of object returned by the last command.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找上一个命令返回的对象类型。
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Attempt to convert the `LastWriteTime` into a `DateTime` object. Pick just the
    first record, though.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将`LastWriteTime`转换为`DateTime`对象。只选择第一个记录。
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: What if we had to retain all the objects within the object returned by `Get-ChildItem`,
    including their object types?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们必须保留`Get-ChildItem`返回的对象中的所有对象，包括它们的对象类型，该怎么办？
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, import the contents of the XML to the session.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将XML的内容导入到会话中。
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Find out the type name of the object returned by the import command.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找导入命令返回的对象类型名称。
- en: '[PRE69]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Pick the `CreationTime` property and find its type.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`CreationTime`属性并查找它的类型。
- en: '[PRE70]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Pick just the year.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只选择年份。
- en: '[PRE71]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Importing content from a CSV is a straightforward process. The columns in a
    CSV are separated by commas. PowerShell creates an object from the input content,
    with each column making a property of a PowerShell custom object. Operations that
    we perform on objects can be performed on the `PSCustomObject`, however, the only
    limitation with `Import-Csv` is that the properties cannot be multi-valued, nor
    can they have other sub-properties within them. There could be ways to achieve
    multi-valued properties with CSV, but they would involve some manipulation after
    the object is imported within PowerShell. One such way is to separate the values
    of the property with a delimiter, and then, after the import, split the delimited
    value.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从CSV导入内容是一个直接的过程。CSV中的列是由逗号分隔的。PowerShell会根据输入的内容创建一个对象，每一列都会成为PowerShell自定义对象的一个属性。我们对对象执行的操作也可以作用于`PSCustomObject`，然而`Import-Csv`的唯一限制是属性不能是多值的，也不能包含其他子属性。虽然使用CSV有可能实现多值属性，但这需要在对象导入PowerShell后进行一些处理。一个方法是通过分隔符分隔属性的值，然后在导入后分割这些分隔值。
- en: On the other hand, a CLIXML (or a Common Language Infrastructure XML) is a complete
    .NET object. When a PowerShell object is exported to CLIXML, the object is retained
    as it is. That is, the CLIXML retains all the properties (of theoretically any
    depth), and the methods that were part of the output object. In other words, it
    can be said that a CLIXML export is almost lossless in terms of the members of
    the object.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，CLIXML（或称公共语言基础结构XML）是一个完整的.NET对象。当PowerShell对象导出为CLIXML时，该对象会原封不动地保留下来。也就是说，CLIXML保留了所有属性（理论上可以达到任意深度），以及输出对象的所有方法。换句话说，可以说CLIXML导出在对象成员方面几乎是无损的。
- en: See also
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Recipe: Generate random text using ASCII characters'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 方案：使用ASCII字符生成随机文本
