- en: Using libvirt to Manage KVM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 libvirt 管理 KVM
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing and configuring libvirt
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置 libvirt
- en: Defining KVM instances
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 KVM 实例
- en: Starting, stopping, and removing KVM instances
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动、停止和删除 KVM 实例
- en: Inspecting and editing KVM configs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和编辑 KVM 配置
- en: Building new KVM instances with virt-install and using the console
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 virt-install 构建新的 KVM 实例并使用控制台
- en: Managing CPU and memory resources in KVM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 KVM 中管理 CPU 和内存资源
- en: Attaching block devices to virtual machines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将块设备附加到虚拟机
- en: Sharing directories between a running VM and the host OS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行中的虚拟机与宿主操作系统之间共享目录
- en: Autostarting KVM instances
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动启动 KVM 实例
- en: Working with storage pools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存储池
- en: Managing volumes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理存储卷
- en: Managing secrets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理机密信息
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we saw examples of provisioning virtual machines using
    the QEMU toolset and the KVM kernel modules. The QEMU commands are convenient
    for quickly starting virtual instances; however, they don't provide an easy way
    of configuring and administering the life cycle of the virtual machines.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们展示了使用 QEMU 工具集和 KVM 内核模块来配置虚拟机的示例。QEMU 命令适合快速启动虚拟实例；然而，它们没有提供配置和管理虚拟机生命周期的简便方法。
- en: In this chapter, we are going to work with the libvirt toolset. Libivrt provides
    various userspace commands and language bindings in order to build, configure,
    start, stop, migrate, terminate, and do other functions to manage your virtual
    machines. It provides support for different virtualization technologies, such
    as QEMU/KVM, XEN, and containers with LXC.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将使用 libvirt 工具集。Libvirt 提供了各种用户空间命令和语言绑定，用于构建、配置、启动、停止、迁移、终止虚拟机，并执行其他管理功能。它支持不同的虚拟化技术，如
    QEMU/KVM、XEN 和 LXC 容器。
- en: We will start by installing and configuring the libvirt tools, then move on
    to creating virtual machines using the XML configuration files that libvirt supports
    and explore many of the functionalities that the toolkit provides in order to
    manage the life cycle of KVM instances. All the recipes in this chapter are going
    to be in the context of building highly available, multitenant environments.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从安装和配置 libvirt 工具开始，然后继续创建使用 libvirt 支持的 XML 配置文件的虚拟机，并探索该工具包提供的许多功能，以便管理
    KVM 实例的生命周期。本章中的所有示例都将以构建高可用、多租户环境为背景。
- en: Installing and configuring libvirt
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 libvirt
- en: In this recipe, we are going to install libvirt from packages provided by the
    Linux distribution of choice and see what configuration files and options are
    available for configuring it. As with any other production-ready tools, we recommend
    using packages for your production environment for ease and consistency of deployment;
    however, compiling the latest version from the source is also an option if the
    packages from your Linux vendor are older.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将从你选择的 Linux 发行版提供的软件包中安装 libvirt，并查看可用于配置的配置文件和选项。和其他生产环境工具一样，我们推荐在生产环境中使用软件包，以便于部署和保持一致性；然而，如果你所在
    Linux 发行商的包版本较旧，也可以选择从源码编译最新版本。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Depending on your Linux distribution, the package name and installation commands
    will differ. You can use your system's package manager, such as `apt`, `dnf`,
    or `yum` to search for any packages containing the `libvirt` string and get familiar
    with what is available for your particular Linux variant. The source code can
    be downloaded from the official libvirt project website at [http://www.qemu-project.org/download/#source](https://libvirt.org/downloads.html).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的 Linux 发行版，软件包名称和安装命令会有所不同。你可以使用系统的包管理器，如 `apt`、`dnf` 或 `yum` 来搜索包含 `libvirt`
    字符串的包，并了解适用于你特定 Linux 版本的可用软件包。源代码可以从官方的 libvirt 项目网站下载：[http://www.qemu-project.org/download/#source](https://libvirt.org/downloads.html)。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To install libvirt from packages and source follow the following steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件包和源代码安装 libvirt，请按照以下步骤操作：
- en: 'On Ubuntu, install the package by running:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上，通过运行以下命令安装软件包：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ensure that the `libvirt` daemon is running by executing:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令确保 `libvirt` 守护进程正在运行：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Examine the default configuration:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查默认配置：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Disable the security driver in QEMU by editing the `qemu` configuration file
    as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编辑 `qemu` 配置文件禁用 QEMU 中的安全驱动：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Restart the `libvirt` daemon:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启 `libvirt` 守护进程：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Depending on your Linux distribution, the name of the `libvirt` service may
    be different. On RHEL/CentOS, the name of the service is `libvirtd`; to restart
    it, run `service libvirtd restart`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的 Linux 发行版，`libvirt` 服务的名称可能会有所不同。在 RHEL/CentOS 上，服务名称是 `libvirtd`；要重启它，可以运行
    `service libvirtd restart`。
- en: 'Examine all configuration files in the `libvirt` directory:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `libvirt` 目录中的所有配置文件：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we installed the package on Ubuntu. The postinstall script started
    the `libvirt` daemon after the package was successfully installed. We verified
    that in step 2.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们在 Ubuntu 上安装了该软件包。安装后，后安装脚本启动了 `libvirt` 守护进程。我们在第 2 步中验证了这一点。
- en: In step 3, we examined the main configuration file for the service-side daemon
    - `libvirtd`. The process runs on the host OS and manages tasks for the virtual
    machines, such as configuration, life cycle management, migration, storage, and
    networking, as we are going to see later in this chapter. The userspace tools
    provided by the package we installed communicate with the daemon by sending requests
    on a local Unix domain socket. The default options we saw in step 3 are sufficient
    for the recipes in this chapter, but the configuration file is rather large. We
    encourage you to go through it and get familiar with the rest of the available
    configuration options. The file is very well documented.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 步中，我们检查了服务端守护进程 `libvirtd` 的主要配置文件。该进程在主机操作系统上运行，管理虚拟机的任务，如配置、生命周期管理、迁移、存储和网络等，我们将在本章稍后看到。我们安装的软件包提供的用户空间工具通过发送请求到本地
    Unix 域套接字与守护进程进行通信。第 3 步中看到的默认选项足以满足本章中的食谱需求，但配置文件相当庞大。我们建议你仔细阅读它，并熟悉其中的其他配置选项。该文件的文档非常完善。
- en: In step 4, we disabled the security driver for QEMU. By default on RHEL/CentOS
    systems, QEMU is configured to use SELinux. Ubuntu distributions use **AppArmor**.
    For simplicity, we disable that functionality in this step; however, in production,
    you should take advantage of the extra security that a mandatory access control
    system such as SELinux provides.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 步中，我们禁用了 QEMU 的安全驱动程序。默认情况下，在 RHEL/CentOS 系统上，QEMU 被配置为使用 SELinux。Ubuntu
    发行版使用 **AppArmor**。为了简化，我们在此步骤中禁用了该功能；然而，在生产环境中，你应该利用强制访问控制系统（如 SELinux）提供的额外安全性。
- en: Any change to the `libvirt` configuration file requires a restart. We restart
    the `libvirt` service in step 5.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `libvirt` 配置文件的任何更改都需要重启。我们在第 5 步中重启了 `libvirt` 服务。
- en: 'There are few important configuration files that we need to be familiar, which
    are listed in step 6:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要熟悉一些重要的配置文件，这些文件在第 6 步中列出了：
- en: '`libvirt.conf` is the client-side configuration file for the `virsh` command
    that we are going to use in this recipe. We can specify URI aliases in it. The
    defaults should be sufficient.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libvirt.conf` 是我们将在本食谱中使用的 `virsh` 命令的客户端配置文件。我们可以在其中指定 URI 别名。默认设置应该已经足够。'
- en: '`libvirtd.conf` is the server-side configuration file, as we saw in step 3. It
    provides various security options, request limits, and logging controls. For the
    purpose of this book, the defaults are sufficient.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libvirtd.conf` 是服务端配置文件，正如我们在第 3 步中看到的。它提供了各种安全选项、请求限制和日志控制。对于本书的目的，默认设置已经足够。'
- en: '`qemu.conf` is the main configuration file for the QEMU driver that `libvirt`
    uses. We can configure options such as the VNC server address, the security driver
    that we saw in step 4 and the user and group for the QEMU process.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qemu.conf` 是 QEMU 驱动程序的主要配置文件，它是 `libvirt` 使用的。我们可以配置诸如 VNC 服务器地址、在第 4 步中看到的安全驱动程序，以及
    QEMU 进程的用户和组等选项。'
- en: Once we create a QEMU/KVM virtual machine, the `/etc/libvirt/qemu/` directory will
    contain the XML configuration definition for that instance, as we are going to
    see in the following recipes.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们创建了 QEMU/KVM 虚拟机，`/etc/libvirt/qemu/` 目录将包含该实例的 XML 配置定义，正如我们在接下来的食谱中将看到的那样。
- en: Finally, the `/etc/libvirt/qemu/networks/` directory contains configuration
    files for the networking. We are going to explore those in more detail later in
    this chapter.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`/etc/libvirt/qemu/networks/` 目录包含了用于网络配置的文件。我们将在本章稍后更详细地探讨这些文件。
- en: Defining KVM instances
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 KVM 实例
- en: In this recipe, we are going to define a virtual instance by creating a simple
    XML configuration file that `libvirt` can use to build the virtual machine. We
    are going to describe some of the XML schema blocks and look at examples of how
    to generate the XML definition file using the `virt-install` command rather than
    writing it manually.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过创建一个简单的XML配置文件来定义虚拟实例，该文件可以被`libvirt`用于构建虚拟机。我们将描述一些XML架构块，并展示如何使用`virt-install`命令生成XML定义文件，而不是手动编写。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要以下内容：
- en: The QEMU binaries, provided after following the *Installing and configuring
    QEMU* recipe from [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM*.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照[第1章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*“安装和配置QEMU”*配方中所述提供的QEMU二进制文件。
- en: The custom raw Debian image we built in the *Installing a custom OS on the image
    with debootstrap* recipe from the previous chapter.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在上一章的*使用debootstrap安装自定义操作系统*配方中构建的自定义原始Debian镜像。
- en: You can use your own virtual machine image or download one from the Internet,
    as we showed in the *Using pre-existing images* recipe in [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM.*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用自己的虚拟机镜像或从互联网上下载一个，正如我们在[第1章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*“使用现有镜像”*配方中展示的那样，开始使用QEMU和KVM。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To define a new KVM virtual machine, run the commands outlined here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个新的KVM虚拟机，请运行这里概述的命令：
- en: 'List all virtual machines on the host OS:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出主机操作系统上的所有虚拟机：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the following XML definition file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下XML定义文件：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the virtual machine:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义虚拟机：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'List all instances in all states:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有状态下的实例：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we used the `virsh` command and supplied all argument to list all
    active and inactive instances. As expected, we started with no instances defined.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们使用了`virsh`命令并提供了所有参数，以列出所有活动和非活动的实例。正如预期的那样，我们一开始没有定义任何实例。
- en: 'In step 2, we created a definition file for a new KVM instance. We used a small
    subsection of the available XML schema attributes to set the following options:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们为新的KVM实例创建了一个定义文件。我们使用了可用XML架构属性的小部分来设置以下选项：
- en: The root element of the XML file is required for all virtual machine definitions
    and is named **domain**. It has two attributes--`type` and `id`. We specified
    `kvm` as the `type` and an `id` as `1` because this is our first KVM virtual machine.
    All other attributes are defined under the domain root element.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML文件的根元素是所有虚拟机定义所必需的，命名为**domain**。它有两个属性——`type`和`id`。我们将`kvm`指定为`type`，并将`id`设置为`1`，因为这是我们的第一台KVM虚拟机。所有其他属性都在domain根元素下定义。
- en: We specified a name for the instance with the name attribute.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过`name`属性指定了实例的名称。
- en: The memory attribute defines the available memory to the VM, in our case, 1
    GB.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: memory属性定义了分配给虚拟机的可用内存，在我们的案例中是1GB。
- en: The `vcpu` element defines the maximum number of virtual CPUs allocated for
    the guest OS. We specified `1`, and we used the optional attribute placement that
    indicates the CPU placement mode; in this example, static. Static placement indicates
    that the virtual instance will be pinned to all the available physical CPUs.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vcpu`元素定义了为客户操作系统分配的虚拟CPU的最大数量。我们将其指定为`1`，并使用了可选属性placement，指示CPU的放置模式；在本例中，使用的是静态模式。静态放置表示虚拟实例将被固定在所有可用的物理CPU上。'
- en: The OS element defines the architecture of the VM with the use of the type element.
    The `hvm` option indicates that we are going to use full virtualization, which
    is going to be KVM, as specified in the domain type attribute we saw earlier.
    We specify the boot device the VM will start from with the `<boot dev>` element.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS元素通过使用type元素定义虚拟机的架构。`hvm`选项表示我们将使用完全虚拟化，这将是KVM，正如我们之前看到的domain类型属性所指定的那样。我们通过`<boot
    dev>`元素指定虚拟机启动的设备。
- en: The next three elements specify the action to be taken when the guest requests
    a power off, reboot or it crashes. In our example, the VM will be destroyed when
    the guest OS is powered off and restarted when the guest reboots or crashes.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的三个元素指定了当客户请求关闭电源、重启或发生崩溃时需要采取的操作。在我们的示例中，当客户操作系统关闭电源时，虚拟机将被销毁，当客户重启或崩溃时，虚拟机将重新启动。
- en: The largest section of the XML definition is the devices section, where we use
    various XML elements to describe devices provided to the guest OS. The emulator
    element specifies the path to the emulator binary. We are going to use the same
    QEMU emulator binary `qemu-system-x86_64` we used in [Chapter 1,](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce) *Getting
    Started with QEMU and KVM*. In the last few sections of the devices attribute,
    we define the type of virtual disk we are using, in this example, the raw image
    we built in the previous chapter. In a similar fashion, we describe the VNC server
    that the guest should start and the network interface inside the guest OS.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 定义文件中最大的部分是设备部分，我们使用各种 XML 元素来描述提供给来宾操作系统的设备。emulator 元素指定了模拟器二进制文件的路径。我们将使用在
    [第 1 章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce) *开始使用 QEMU 和 KVM*
    中使用的相同的 QEMU 模拟器二进制文件 `qemu-system-x86_64`。在设备属性的最后几个部分，我们定义了我们使用的虚拟磁盘类型，在本例中是我们在前一章构建的原始镜像。以类似的方式，我们描述了来宾操作系统中应该启动的
    VNC 服务器和网络接口。
- en: With the `config` file in place, we defined the instance in step 3, using the
    image we created earlier in `/tmp`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 `config` 文件后，我们在第 3 步中定义了实例，使用的是我们之前在 `/tmp` 创建的镜像。
- en: Once a new instance has been defined, it does not automatically start by default.
    We can see that the status of the new instance is `shut off` in step 4.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新实例被定义，它默认不会自动启动。我们可以看到在第 4 步中，新的实例状态是 `shut off`。
- en: For information on all of the available XML elements and their attributes, please
    refer to the official documentation at [http://libvirt.org/formatdomain.html](http://libvirt.org/formatdomain.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有可用 XML 元素及其属性的信息，请参阅官方文档：[http://libvirt.org/formatdomain.html](http://libvirt.org/formatdomain.html)。
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Configuring a virtual machine by writing the XML file, can be quite tedious
    and error-prone. An easier way of creating the VM from an existing image, or from
    an installation media (which can be physical, virtual, or a network location),
    is using the `virt-install` tool. Lets see an example of creating the same KVM
    instance using that tool.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写 XML 文件来配置虚拟机可能会非常繁琐且容易出错。创建虚拟机的一个更简单的方法是使用 `virt-install` 工具，这可以从现有镜像或安装介质（可以是物理的、虚拟的或网络位置）创建虚拟机。让我们看一个使用该工具创建相同
    KVM 实例的例子。
- en: 'We start by installing the package:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从安装包开始：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we define and start the new instance by invoking the `virt-install` command
    (if an instance with the same name already exist, you''ll need to destroy and
    undefine it first):'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用 `virt-install` 命令来定义并启动新的实例（如果已经存在相同名称的实例，你需要先销毁并取消定义它）：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The new VM has now been defined and started. To confirm, execute:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的虚拟机现在已经定义并启动。为了确认，执行以下命令：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see the virtual machine definition file that was automatically generated
    by running the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到通过运行以下代码自动生成的虚拟机定义文件：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Starting, stopping, and removing KVM instances
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动、停止和移除 KVM 实例
- en: In the previous recipe, we saw how to define new KVM virtual machine by either
    manually writing the XML definition file or using the `virt-install` tool to define
    the instance for us.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的教程中，我们看到如何通过手动编写 XML 定义文件或使用 `virt-install` 工具来定义新的 KVM 虚拟机实例。
- en: If you define a new instance from an XML file, by default the instance will
    not start automatically. In this recipe, we will see how to start an instance
    that was previously configured.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从 XML 文件定义新的实例，默认情况下实例不会自动启动。在本教程中，我们将看到如何启动之前配置的实例。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们需要以下内容：
- en: The QEMU binaries, provided after following the *Installing and configuring
    QEMU* recipe from [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM*.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在遵循 *安装和配置 QEMU* 教程后提供的 QEMU 二进制文件，通过 [第 1 章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)
    *开始使用 QEMU 和 KVM* 获得。
- en: The custom raw Debian image we built in the *Installing a custom OS on the image
    with debootstrap* recipe from the previous chapter.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 *使用 debootstrap 安装自定义操作系统* 教程中构建的自定义原始 Debian 镜像。
- en: The virsh tool provided by completing the *Installing and configuring libvirt*
    recipe.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成 *安装和配置 libvirt* 教程后提供的 virsh 工具。
- en: The defined instance from the *Defining KVM instances* recipe in a `shut off`
    state.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *定义 KVM 实例* 教程中定义的实例处于 `shut off` 状态。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps outline the process of listing, starting, and stopping
    KVM instances using the `virsh` command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了使用`virsh`命令列出、启动和停止KVM实例的过程：
- en: 'List all instances in all states:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有状态下的实例：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Start the newly defined instance and verify its status:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动新定义的实例并验证其状态：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Examine the running process for the virtual machine:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查虚拟机的运行进程：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Terminate the VM and ensure its status changed from running to `shut off`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止虚拟机并确保其状态从运行中变为`关闭`：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Remove the instance definition:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除实例定义：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we list all defined instances, regardless of their state. From the
    output, we can see that we currently have one instance that we defined in the
    earlier recipe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们列出了所有定义的实例，无论其状态如何。从输出中，我们可以看到我们当前有一个在早前的教程中定义的实例。
- en: In step 2, we started the virtual machine and ensured its status had changed
    to running.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们启动了虚拟机并确保其状态已变为运行。
- en: If you completed the *Running Virtual Machines with qemu-system-** recipe from
    [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*, Getting Started
    with QEMU and KVM*, you might note that the XML definition for this VM is very
    similar to all the command-line options we used to start the QEMU instance. We
    can see the similarities of how the new instance was started  in step 3\. The
    main difference is the larger number of parameters that `libvirt` passed to the
    QEMU executable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了[第1章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)中的*使用qemu-system-运行虚拟机*教程，你可能会注意到该虚拟机的XML定义与我们用于启动QEMU实例的所有命令行选项非常相似。我们可以看到在步骤3中启动新实例的相似性。主要区别在于`libvirt`传递给QEMU可执行文件的参数更多。
- en: Finally, in steps 4 and 5, we stopped the VM and removed its definition file.
    The raw image we used for the VM is still available however and can be used again.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在步骤4和5中，我们停止了虚拟机并移除了其定义文件。然而，我们用来做虚拟机的原始镜像仍然可用，并且可以再次使用。
- en: Inspecting and editing KVM configs
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查和编辑KVM配置
- en: In this recipe, we are going to use the `virsh` tool to inspect and edit the
    configuration for an existing virtual machine. As we saw earlier, once we define
    and start a KVM instance, `libvirt` creates the XML definition file in the `/etc/libvirt/qemu/`
    directory. We can dump the guest configuration to disk, for inspection, or to
    back it up. With the `virsh` command we can also perform updates to the configuration
    in place, as we will see later in this recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用`virsh`工具来检查和编辑现有虚拟机的配置。如前所述，一旦定义并启动了KVM实例，`libvirt`会在`/etc/libvirt/qemu/`目录中创建XML定义文件。我们可以将来宾配置转储到磁盘，以便检查或备份。使用`virsh`命令，我们还可以在原地执行配置更新，正如本教程稍后所示。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程中，我们需要以下内容：
- en: The QEMU binaries, provided after following the *Installing and configuring
    QEMU* recipe from [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM*
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照[第1章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)中的*安装与配置QEMU*教程提供的QEMU二进制文件，开始使用QEMU和KVM
- en: The custom raw Debian image we built in the *Installing custom OS on the image
    with debootstrap* recipe from the previous chapter, or any other virtual machine
    image, in either `raw` or `qcow2` format
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在上一章的*使用debootstrap安装自定义操作系统*中构建的自定义Debian镜像，或任何其他虚拟机镜像，格式可以是`raw`或`qcow2`
- en: The `virsh` tool provided by completing the *Installing and configuring libvirt *recipe
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成*安装与配置libvirt*教程后提供的`virsh`工具
- en: A running `libvirt` KVM instance
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行的`libvirt` KVM实例
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps outline the process of inspecting and editing the XML definition
    of a KVM instance:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了检查和编辑KVM实例的XML定义的过程：
- en: 'Ensure that you have a running KVM instance with libvirt, if not, follow the
    steps in the previous recipe:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你有一个运行中的KVM实例和libvirt，如果没有，请按照之前教程中的步骤进行操作：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Dump the instance configuration file to **standard output** (**stdout**). For
    more information on stdout refer to folllowing link:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例配置文件输出到**标准输出**（**stdout**）。有关stdout的更多信息，请参考以下链接：
- en: '[https://en.wikipedia.org/wiki/Standard_streams](https://en.wikipedia.org/wiki/Standard_streams)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Standard_streams](https://en.wikipedia.org/wiki/Standard_streams)'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Save the configuration to a new file, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将配置保存到新文件中，如下所示：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Edit the configuration in place and change the available memory for the VM:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原地编辑配置并更改虚拟机的可用内存：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Libvirt provides two main ways to manipulate the configuration definitions of
    the virtual instances. We can either dump the config from an existing instance,
    as we did in steps 2 and 3, or edit the XML definition in place, as we did in
    step 4.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt提供了两种主要方式来操作虚拟实例的配置定义。我们可以像第2步和第3步那样从现有实例中导出配置，或者像第4步那样在原地编辑XML定义。
- en: Saving the current configuration to a file is a convenient way to back up the
    VM definition. It also provides a way of defining a new instance by editing the
    saved file and just changing the name and ID of the virtual machine. We can then
    use that file to start a new VM on the same, or a different host, assuming that
    the filesystem or image is also available. We are going to see examples of migrating
    and backing up virtual machines with `libvirt` in later recipes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前配置保存到文件是一种方便的备份VM定义的方式。它还提供了一种通过编辑保存的文件并仅更改虚拟机的名称和ID来定义新实例的方法。然后，我们可以使用该文件在同一主机或不同主机上启动一个新的虚拟机，前提是文件系统或镜像也可用。在以后的食谱中，我们将看到使用`libvirt`迁移和备份虚拟机的示例。
- en: 'When making changes in place, as shown in step 4, the default system `$EDITOR`
    will be used. Once in the editing mode, note that the XML file contains information
    about the current state of the virtual instance. The `<uuid>` and `<currentMemory>`
    attributes are such examples. If you would like to change the available memory
    for the VM, after updating the `<memory>` attribute, you might need to delete
    the `<currentMemory>` stanza. If there are any issues with the edit, libvirt will
    complain with an error message and present the following options:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在原地进行更改时，如第4步所示，将使用默认系统`$EDITOR`。进入编辑模式后，请注意XML文件包含有关虚拟实例当前状态的信息。`<uuid>`和`<currentMemory>`属性就是这样的例子。如果你想更改虚拟机的可用内存，在更新`<memory>`属性后，可能需要删除`<currentMemory>`段。如果编辑时出现任何问题，libvirt将显示错误消息并提供以下选项：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Also keep in mind that, if you would like to create a new instance from the
    dump of an existing one, you will need to change the `<name>` and delete the `<uuid>`
    attributes, as the latter will be autogenerated once the new instance has been
    defined.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还请记住，如果你想从现有实例的转储中创建一个新实例，你需要更改`<name>`并删除`<uuid>`属性，因为后者会在定义新实例时自动生成。
- en: Building new KVM instances with virt-install and using the console
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用virt-install构建新的KVM实例并使用控制台
- en: In the *Connecting to the running instance with VNC* recipe from [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM,* you learned how to connect to a QEMU/KVM virtual
    machine that was running a VNC server. This is a great way to connect to an instance
    that is being installed or in the process of booting in order to interact with
    it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*《QEMU与KVM入门》*中的*连接到运行中的实例（使用VNC）*一节，你学习了如何连接到运行VNC服务器的QEMU/KVM虚拟机。这是连接到正在安装或启动过程中的实例的一种非常好的方式，以便与其进行交互。
- en: So far, we've used the custom raw image that we created earlier, which contains
    an installation of Debian. Recall from [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM,* that we used the `debootstrap` command to
    install the OS inside the image file. In this recipe, we are going to use the
    `virt-install` tool to install a new Linux distribution, using the provided upstream
    Internet repository, as the source of the installation and then use the `virsh`
    command to attach to the running instance, using the console.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用之前创建的自定义原始镜像，其中包含Debian操作系统的安装。回顾[第1章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*，《QEMU与KVM入门》*，我们使用了`debootstrap`命令在镜像文件内安装操作系统。在这个食谱中，我们将使用`virt-install`工具安装一个新的Linux发行版，使用提供的上游互联网存储库作为安装源，然后使用`virsh`命令连接到运行中的实例，使用控制台。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we are going to need the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要以下内容：
- en: The `virsh` command
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virsh` 命令'
- en: The `virt-install` command
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt-install` 命令'
- en: Internet connectivity in order to download the installation files
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要互联网连接以下载安装文件
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To build a new KVM instance and connect to it using the console, perform the
    following steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个新的KVM实例并通过控制台连接到它，执行以下步骤：
- en: 'Install a new KVM virtual machine using the official Debian repository:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用官方Debian存储库安装新的KVM虚拟机：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Attach to the console to complete the installation by running the following
    code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码连接到控制台以完成安装：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once connected to the console, you should be presented with a screen similar
    to the one here:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦连接到控制台，你应该看到类似于此处的屏幕：
- en: '![](img/00007.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpeg)'
- en: The console output once connected with the virsh console command
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，通过 virsh 控制台命令看到的控制台输出
- en: Complete the installation by following the text menu prompts.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照文本菜单提示完成安装。
- en: 'Start the newly provisioned VM:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动新配置的虚拟机：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using your favorite VNC client, connect to the instance, log in with the username
    and password you created during the installation process in step 3 and enable
    the serial console access by running the following command:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的 VNC 客户端连接到实例，使用你在安装过程中第 3 步创建的用户名和密码登录，并通过运行以下命令启用串行控制台访问：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Close the VNC session and connect to the virtual instance from the host OS,
    using `virsh`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 VNC 会话，并通过主机操作系统使用 `virsh` 连接到虚拟实例：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Disconnect from the console using the *Ctrl* + *]* key combination.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *]* 键组合断开与控制台的连接。
- en: 'Examine the `image` file created after the installation:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查安装后创建的 `image` 文件：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you are not using systemd-based `init` system on the distribution for the
    KVM machine, in order to allow access to the serial console of the instance, you
    will need to edit the `/etc/securetty` or the `/etc/inittab` files.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在 KVM 机器的发行版上使用基于 systemd 的 `init` 系统，则为了允许访问实例的串行控制台，你需要编辑 `/etc/securetty`
    或 `/etc/inittab` 文件。
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A lot happened in this recipe, so lets go through all the steps in more detail.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中发生了很多事情，所以让我们更详细地回顾一下所有步骤。
- en: In step 1, we started the installation process for a new KVM instance using
    the `virt-install` utility. We specified the serial console to be enabled during
    the installation process with the `--extra-args` parameter. We also used the `--location`
    flag to tell `libvirt` the location of the installation files for the latest Debian
    distribution. We then specified the location and size of the image file that will
    contain the guest OS filesystem. Since this file did not exist, `virt-install`
    created it as a raw image, as shown in step 9.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们使用 `virt-install` 工具启动了一个新的 KVM 实例的安装过程。我们通过 `--extra-args` 参数指定在安装过程中启用串行控制台。我们还使用
    `--location` 标志告诉 `libvirt` 安装文件的位置，以便安装最新的 Debian 发行版。然后我们指定了将包含来宾操作系统文件系统的映像文件的位置和大小。由于该文件尚不存在，`virt-install`
    创建了一个原始映像，如第 9 步所示。
- en: With console access enabled for the installation, we were able to connect to
    the console in step 2 and complete the installation process in steps 3 and 4.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 启用了控制台访问后，我们能够在第 2 步连接到控制台，并在第 3 和第 4 步完成安装过程。
- en: After the installation completed, the console session was terminated and the
    new KVM instance ready to be started. We started the instance in step 5.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，控制台会话终止，新 KVM 实例准备启动。我们在第 5 步启动了实例。
- en: In order to enable console access on the serial port, we first connected to
    the running VM using a VNC client and instruct systemd to started the console
    service in step 6.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用串行端口上的控制台访问，我们首先使用 VNC 客户端连接到正在运行的虚拟机，并在第 6 步指示 systemd 启动控制台服务。
- en: With console access enabled, we were able to connect to the serial console using
    the virsh tool in step 7.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 启用控制台访问后，我们能够在第 7 步使用 virsh 工具连接到串行控制台。
- en: With all this completed, we now have two ways of connecting to a running KVM
    instance using either VNC or the console.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们现在有两种方法可以连接到正在运行的 KVM 实例，分别是通过 VNC 或控制台。
- en: In the later recipe, we will enable networking in the guest OS and provide a
    third way to connect using SSH.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的配方中，我们将启用来宾操作系统的网络功能，并提供第三种使用 SSH 连接的方法。
- en: Managing CPU and memory resources in KVM
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 KVM 中的 CPU 和内存资源
- en: Changing the amount of allocated memory or the number of CPUs can be done either
    by editing the XML definition for the VM or using the `libvirt` toolset. In this
    recipe, we are going to look at examples of changing both the memory and the CPU
    count for a KVM instance.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过编辑虚拟机的 XML 定义或使用 `libvirt` 工具集来更改分配的内存量或 CPU 数量。在这个配方中，我们将查看如何更改 KVM 实例的内存和
    CPU 数量的示例。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将需要以下内容：
- en: A running KVM instance with 1 GB of memory, 1 CPU allocated, and console access
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行的 KVM 实例，分配了 1 GB 内存和 1 个 CPU，并启用了控制台访问
- en: The `libvirt` package
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libvirt` 包'
- en: A guest OS with at least 4 GB of available memory and minimum of 4 CPUs
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个至少有 4 GB 可用内存和最低 4 个 CPU 的来宾操作系统
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To inspect and update the memory and CPU resources assigned to a virtual machine
    follow the process outlined here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查并更新分配给虚拟机的内存和CPU资源，请按照这里概述的过程进行：
- en: 'Get memory statistics for the running instance:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取正在运行的实例的内存统计信息：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Update the available memory for the VM to 2 GB:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将虚拟机的可用内存更新为2 GB：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Stop the running instance:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止正在运行的实例：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Set the maximum usable memory to 2 GB:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最大可用内存设置为2 GB：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Start the instance:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动实例：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Check the current allocated memory:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前分配的内存：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Connect to the KVM instance and check the memory in the guest OS:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到KVM实例并检查来宾操作系统中的内存：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check the memory settings in the instance XML definition:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查实例XML定义中的内存设置：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Get information about the guest CPUs:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取来宾CPU的信息：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'List the number of virtual CPUs used by the guest OS:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出来宾操作系统使用的虚拟CPU数量：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Change the number of allocated CPUs to 4 for the VM:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将虚拟机分配的CPU数量更改为4：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Ensure that the CPU count update took effect:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保CPU数量更新生效：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In step 1, we gathered some memory statistics for the running KVM instance.
    From the output, we can see that the VM is configured with 1 GB of memory indicated
    by the actual parameter, and it's currently using 333644 KB of memory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们收集了正在运行的KVM实例的内存统计信息。从输出中，我们可以看到虚拟机配置了1GB的内存（由实际参数指示），并且当前使用了333644
    KB的内存。
- en: In step 2, we updated the available memory to 2 GB and then proceeded to update
    the maximum memory that can be allocated to the instance in step 4\. In order
    to perform that operation, the instance had to be stopped first, as shown in step
    3.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们将可用内存更新为2 GB，并在第4步中继续更新可以分配给实例的最大内存。为了执行此操作，必须先停止实例，如第3步所示。
- en: In steps 6, 7, and 8, we made sure that the updates took place by first invoking
    the `dommemstat` subcommand, then connected to the VMs console and finally checked
    the current configuration by dumping the instance definition.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6、7和8步中，我们通过首先调用`dommemstat`子命令、然后连接到虚拟机的控制台，最后通过转储实例定义检查当前配置，确保了更新的生效。
- en: The `virsh` command provides few subcommands to inspect the CPU state for a
    running VM. In steps 9 and 10, we listed the allocated virtual CPUs for the `kvm1`
    instance, in this case, just one and the current state, load, and affinity.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`virsh`命令提供了几个子命令来检查正在运行的虚拟机的CPU状态。在第9步和第10步中，我们列出了`kvm1`实例的虚拟CPU数量，在本例中为一个，并显示了当前的状态、负载和亲和性。'
- en: Finally, in steps 11 and 12, we update the XML definition of the instance, allocating
    four CPUs and listed the new count.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第11步和第12步中，我们更新了实例的XML定义，分配了四个CPU并列出了新的数量。
- en: There's more...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this recipe, we used the `virsh` command with various subcommands in one
    liners. This is particularly useful if we need to run the commands from a script.
    The `virsh` command also provides an interactive terminal, which saves some typing,
    and provides contextual help. To start the virtualization-interactive terminal,
    run the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们使用了`virsh`命令的多个子命令，通过一行命令来执行。这在我们需要通过脚本运行命令时特别有用。`virsh`命令还提供了一个交互式终端，这样可以减少一些输入，并提供上下文帮助。要启动虚拟化交互式终端，请运行以下代码：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Typing `help` will list all available subcommands with a short description.
    To obtain more information for a particular subcommand type:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`help`将列出所有可用的子命令及其简短描述。要获取某个特定子命令的更多信息，请输入：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All the steps we performed in this recipe can be done in the interactive terminal.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程中我们执行的所有步骤都可以在交互式终端中完成。
- en: Attaching block devices to virtual machines
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将块设备附加到虚拟机
- en: In this recipe, we are going to examine a few different ways of adding new block
    devices to a KVM instance. The new block device can then be partitioned, formatted,
    and used as a regular block device inside the guest OS. We can add disks to live
    running instances, or we can attach them persistently by creating XML definitions
    for the individual block devices offline. From the host OS, we can present any
    type of block device file to the guest, including iSCSI targets, LVM logical volumes,
    or image files.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将探讨几种向KVM实例添加新块设备的方法。新的块设备可以进行分区、格式化，并作为常规块设备在来宾操作系统内使用。我们可以将磁盘附加到正在运行的实例，也可以通过离线创建单独块设备的XML定义将其持久化添加。从主机操作系统，可以将任何类型的块设备文件呈现给来宾，包括iSCSI目标、LVM逻辑卷或镜像文件。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程需要以下内容：
- en: A running KVM instance with console access
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有控制台访问权限的正在运行的KVM实例
- en: The `dd` utility
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dd`实用工具'
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To attach a new block device to a KVM guest, run the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新的块设备附加到KVM来宾中，运行以下命令：
- en: 'Create a new 1 GB image file:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的1GB镜像文件：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Attach the file as a new disk to the KVM instance:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件作为新磁盘附加到KVM实例：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Connect to the KVM instance via the console:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过控制台连接到KVM实例：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Print the kernel ring buffer and check for the new block device:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印内核环形缓冲区并检查新的块设备：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Examine the new block device:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新块设备：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Dump the instance configuration from the host OS:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主机操作系统中导出实例配置：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Get information about the new disk:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取新磁盘的信息：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Detach the disk:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卸载磁盘：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Copy or create a new raw image:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个新的原始镜像：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Write the following `config` file:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入以下`config`文件：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Attach the new device:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加新设备：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Detach the block device:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卸载块设备：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Attaching more disks to running KVM instances can be quite useful, especially
    when using LVM inside the guest OS, as this allows for extending the logical volumes,
    thus adding more disk space on the go. Libvirt provides two different methods
    for this as we saw in the steps outlined earlier. We can use the `virsh attach-disk`
    command by passing the location of the image file and the name of the new block
    device for the guest VM as we saw in step 2.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 向运行中的KVM实例附加更多磁盘非常有用，尤其是在来宾操作系统中使用LVM时，因为这可以扩展逻辑卷，从而在运行时添加更多磁盘空间。Libvirt提供了两种不同的方法，正如我们在前面的步骤中所看到的。我们可以使用`virsh
    attach-disk`命令，传递镜像文件的位置和新块设备的名称，正如我们在第2步中看到的那样。
- en: In step 1, we created a new raw image using the `dd` command; however, we could
    have used the qemu-img tool as we saw in the *Managing Disk images with qemu-img*
    and dd recipe from [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*,
    Getting Started with QEMU and KVM*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们使用`dd`命令创建了一个新的原始镜像；然而，我们也可以使用qemu-img工具，正如我们在[第1章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*《QEMU和KVM入门》*中的*管理磁盘镜像与qemu-img*一节所看到的那样。
- en: After attaching the new disk in step 2, in steps 3, 4, and 5, we connected to
    VM and verified that a new block device is indeed present. This is also reflected
    in the XML definition of the instance in step 6.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中附加新磁盘后，在第3、4和5步中，我们连接到虚拟机并验证了新块设备确实存在。这一点在第6步的实例XML定义中也有所体现。
- en: To make the new device available after a VM restart and persist the XML definition
    changes, pass the `--persist` option to the `virsh attach-disk` command.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在虚拟机重启后使新设备可用并保持XML定义的更改，请将`--persist`选项传递给`virsh attach-disk`命令。
- en: In step 7, we display some information about the new disk. This data is quite
    useful in order to monitor the read/write requests for the block device, without
    having to attach to the virtual instance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，我们显示了有关新磁盘的一些信息。这些数据非常有用，可以用来监控块设备的读写请求，而无需连接到虚拟实例。
- en: In step 8, we detached the disk from the running KVM instance. If you dump the
    instance definition at this point, you will note the absence of the extra disk.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们从运行中的KVM实例中卸载了磁盘。如果此时导出实例定义，你会发现额外的磁盘已不再存在。
- en: An alternative way of attaching a block device is shown in step 10\. We first
    create a new XML file with the definition of the block device we are attaching.
    Note how similar the definition is to the output in step 6.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 附加块设备的另一种方式在第10步中展示。我们首先创建一个新的XML文件，其中包含要附加的块设备定义。请注意，这个定义与第6步中的输出非常相似。
- en: In step 11, we detach the new device yet again. Note that we have to specify
    the same device XML definition file in order to do that.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11步中，我们再次卸载了新设备。请注意，我们必须指定相同的设备XML定义文件才能进行此操作。
- en: Once the disk is visible inside the guest OS, we can use it as a regular block
    device, we can partition it, create a filesystem, and mount it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦磁盘在来宾操作系统中可见，我们可以将其作为常规块设备使用，可以对其进行分区、创建文件系统并挂载。
- en: Sharing directories between a running VM and the host OS
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行中的虚拟机与主机操作系统之间共享目录
- en: In the previous recipe, we saw two examples on how to attach disks to a running
    KVM instance. In this recipe, we are going to share a directory from the host
    OS and make it available in the virtual machine. We can only perform this action
    on a stopped instance however. If you've been following along, you should already
    have a libvirt KVM instance that you can use.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个步骤中，我们展示了如何将磁盘附加到运行中的KVM实例的两个示例。在本步骤中，我们将从主机操作系统共享一个目录，并使其在虚拟机中可用。然而，我们只能在实例停止后执行此操作。如果你一直跟随本教程，你应该已经有一个可以使用的libvirt
    KVM实例。
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The prerequisites for this recipe are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的前提条件如下：
- en: Stopped libvirt KVM instance with console access
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止的 libvirt KVM 实例并可通过控制台访问
- en: A guest OS with the `9p` and `virtio` kernel modules (available on most Linux
    distributions by default)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备 `9p` 和 `virtio` 内核模块的来宾操作系统（大多数 Linux 发行版默认包含）
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To share a directory from the host OS to the KVM guest, execute the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要将宿主操作系统的目录共享给 KVM 来宾系统，请执行以下命令：
- en: 'Create a new directory on the host OS and add a file to it:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在宿主操作系统上创建一个新目录并添加文件：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the following definition to the stopped KVM instance:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下定义添加到已停止的 KVM 实例中：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Start the VM:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动虚拟机：
- en: '[PRE58]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Connect to the console as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式连接到控制台：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Ensure that the `9p` and the `virtio` kernel modules are loaded:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保加载 `9p` 和 `virtio` 内核模块：
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Mount the shared directory to `/mnt`:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将共享目录挂载到 `/mnt`：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'List the new mount:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出新的挂载：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Ensure that the shared file is visible in the host OS:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在宿主操作系统中可以看到共享文件：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's get through the steps and see what was accomplished in more details in
    the previous section.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步走过这些步骤，看看在前面章节中完成了哪些操作的详细内容。
- en: 'In step 1, we create a directory and a file that we want to share with the
    guest OS. Then, on the stopped KVM instance, we added the new `<filesystem>` definition
    in step 2\. We used the mount type because we are mounting a directory and specified
    the `accessmode`, which specifies the security mode for accessing the shared resource.
    There are three access modes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们创建了一个目录和一个文件，希望与来宾操作系统共享。然后，在已停止的 KVM 实例上，我们在步骤 2 中添加了新的 `<filesystem>`
    定义。我们使用了挂载类型，因为我们要挂载一个目录，并指定了 `accessmode`，它指定了访问共享资源的安全模式。有三种访问模式：
- en: '`passthrough`: This is the default mode, which accesses the shared directory
    using the permissions of the user inside the guest OS'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`passthrough`：这是默认模式，使用来宾操作系统内用户的权限访问共享目录'
- en: '`mapped`: In this mode, the shared directory and its files are accessed using
    the permissions of the QEMU user, inherited from the host'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapped`：在此模式下，共享目录及其文件将使用来自宿主操作系统的 QEMU 用户权限进行访问'
- en: '`squash`: This mode is similar to the passthrough mode; however, the failures
    of privileged operations such as `chmod` are ignored'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`squash`：此模式类似于透传模式；然而，像 `chmod` 等特权操作的失败会被忽略'
- en: With the new definition in place, we start the VM in step 3 and connect to it
    in step 4.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在新定义生效后，我们在步骤 3 中启动虚拟机，并在步骤 4 中连接到它。
- en: 'On the Debian virtual machine we have been using, the required kernel module
    has been loaded when the VM started. If this is not the case for your VM, load
    the modules by running:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用的 Debian 虚拟机上，所需的内核模块在虚拟机启动时已被加载。如果你的虚拟机没有自动加载，请通过以下命令加载这些模块：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The main action happens in step 6, where we mount the shared directory and ensure
    that it has been successfully mounted and the file present in the subsequent steps.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 主要操作发生在步骤 6，在这里我们挂载共享目录，并确保它已经成功挂载，后续步骤中的文件也已经到位。
- en: There's more...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this chapter, we have been starting KVM virtual machines using the `virsh`
    command, provided by the `libvirt` toolset and libraries. If you check the process
    tree after starting a guest, you can see that `virsh` command actually calls the `/usr/bin/qemu-system-x86_64`
    binary. If you recall from the *Running virtual machines with qemu-system-** recipe
    in [Chapter 1](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*, Getting
    Started with QEMU and KVM;* this is exactly what we used to start QEMU/KVM virtual
    machines.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在使用 `libvirt` 工具集和库提供的 `virsh` 命令启动 KVM 虚拟机。如果你在启动来宾虚拟机后查看进程树，你会发现
    `virsh` 命令实际上会调用 `/usr/bin/qemu-system-x86_64` 二进制文件。如果你还记得 [第 1 章](part0026.html#OPEK0-c1e587dcccb14690b55c247c1809e6ce)*
    中的 *使用 qemu-system- 启动虚拟机* 的食谱，*开始使用 QEMU 和 KVM*；这正是我们用来启动 QEMU/KVM 虚拟机的工具。
- en: 'Note the process that the `libvirt` daemon started when we ran started the
    KVM instance in this recipe:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意当我们在本教程中启动 KVM 实例时，`libvirt` 守护进程启动的过程：
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Instead of using libvirt, we can start a new guest OS with the same shared
    directory we use in this recipe, by just running the following, just make sure
    to stop the `libvirt` instance we started earlier first:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不使用 libvirt，而是通过以下命令直接启动一个新的来宾操作系统，并使用与本教程中相同的共享目录，只需确保先停止我们之前启动的 `libvirt`
    实例：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You should be able to use your VNC client to connect to the guest and perform
    the same steps to mount the shared directory, as we did earlier.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够使用你的 VNC 客户端连接到来宾系统并执行相同的步骤来挂载共享目录，正如我们之前所做的那样。
- en: Autostarting KVM instances
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动启动 KVM 实例
- en: Once a KVM instance has been defined and started, it will run until the host
    OS is up. Once the host OS restarts, instances build with libvirt will not automatically
    start once the host is up and the `libvirt` daemon is running. In this recipe,
    we are going to change this behavior and ensure virtual instance start when the
    `libvirt` daemon starts.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦KVM实例被定义并启动，它将一直运行，直到宿主操作系统启动。一旦宿主操作系统重启，通过libvirt构建的实例将在宿主操作系统启动并且`libvirt`守护进程运行时不会自动启动。在这个食谱中，我们将改变这种行为，并确保在`libvirt`守护进程启动时虚拟实例也能启动。
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we are going to need a single KVM instance build with libvirt.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此食谱，我们将需要一个通过libvirt构建的单个KVM实例。
- en: How to do it...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To configure a KVM guest to automatically start after a server, or `libvirtd` restart,
    run the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置KVM客户机以便在服务器或`libvirtd`重启后自动启动，请运行以下命令：
- en: 'Enable the VM `autostart`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用虚拟机`autostart`：
- en: '[PRE67]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Obtain information for the instance:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取实例的信息：
- en: '[PRE68]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Stop the running instance and ensure that it is in the `shut off` state:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止运行中的实例并确保它处于`关闭`状态：
- en: '[PRE69]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Stop the `libvirt` daemon and ensure that it is not running:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止`libvirt`守护进程并确保它没有运行：
- en: '[PRE70]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Start back the `libvirt` daemon:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动`libvirt`守护进程：
- en: '[PRE71]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'List all running instances:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有正在运行的实例：
- en: '[PRE72]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Disable the `autostart` option:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用`autostart`选项：
- en: '[PRE73]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Verify the change:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证更改：
- en: '[PRE74]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this simple recipe, we enabled the `autostart` feature of a libvirt controlled
    KVM instance.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的食谱中，我们启用了libvirt控制的KVM实例的`autostart`功能。
- en: In step 1, we enabled `autostart` and verified that it has been enabled in step
    2.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们启用了`autostart`并在第2步中验证了它已经启用。
- en: Next, to simulate a server restart, we first stop the running instance in step
    3 and the `libvirt` daemon in step 4.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了模拟服务器重启，我们首先在第3步中停止运行中的实例，并在第4步中停止`libvirt`守护进程。
- en: In step 5, we started the `libvirt` daemon back and observe that it started
    the virtual machine as well, as seen in step 6.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，我们重新启动了`libvirt`守护进程，并观察到它也启动了虚拟机，如第6步所示。
- en: Finally, in steps 7 and 8, we disable the `autostart` feature and ensure that
    it indeed has been disabled.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第7步和第8步中，我们禁用了`autostart`功能，并确保它确实已被禁用。
- en: Working with storage pools
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与存储池的工作
- en: Libvirt provides a centralized way of managing instance volumes (being image
    files or directories) by defining storage pools. A storage pool is a collection
    of volumes that then can be assigned to virtual machines and used to host their
    filesystems or added as additional block devices. The main benefits of using storage
    pools is the ability for libvirt to present and manage the given storage type to
    VMs in a centralized way.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt提供了一种集中式的方式来管理实例卷（无论是镜像文件还是目录），通过定义存储池。存储池是卷的集合，然后可以将这些卷分配给虚拟机，用来托管它们的文件系统或作为额外的块设备。使用存储池的主要好处是，libvirt能够以集中方式向虚拟机呈现并管理指定的存储类型。
- en: 'As of this writing, the following storage pool backends are available:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，以下存储池后端是可用的：
- en: Directory backend
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录后端
- en: Local filesystem backend
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地文件系统后端
- en: Network filesystem backend
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络文件系统后端
- en: Logical backend
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑后端
- en: Disk backend
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘后端
- en: iSCSI backend
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iSCSI后端
- en: SCSI backend
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCSI后端
- en: Multipath backend
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多路径后端
- en: RADOS block device backend
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RADOS块设备后端
- en: Sheepdog backend
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sheepdog后端
- en: Gluster backend
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gluster后端
- en: ZFS backend
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZFS后端
- en: Virtuozzo storage backend
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Virtuozzo存储后端
- en: In this recipe, we are going to create a directory-backed storage pool, move
    an existing image to it, and then provision a new KVM instance using the storage
    pool and volume.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个目录支持的存储池，将现有镜像移动到该池中，然后使用该存储池和卷来配置一个新的KVM实例。
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将需要以下内容：
- en: The Debian raw image we created in the *Building new KVM instances with virt-install
    and using the console* recipe
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在*使用virt-install和控制台构建新的KVM实例*食谱中创建的Debian原始镜像
- en: The `libvirt` package
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libvirt`软件包'
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps demonstrate how to create a new storage pool, inspect it,
    and assign it to a virtual machine:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何创建一个新的存储池，检查它，并将其分配给虚拟机：
- en: 'Copy the raw Debian image file we created in the *Building new KVM instances
    with virt-install and using the console* recipe earlier in this chapter:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制我们在本章*使用virt-install和控制台构建新的KVM实例*食谱中创建的Debian原始镜像文件：
- en: '[PRE75]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create the following storage pool definition:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下存储池定义：
- en: '[PRE76]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Define the new storage pool:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义新的存储池：
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'List all storage pools:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有存储池：
- en: '[PRE78]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Start the new storage pool and ensure that it''s active:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动新的存储池并确保它处于活动状态：
- en: '[PRE79]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Enable the `autostart` feature on the storage pool:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用存储池的`autostart`功能：
- en: '[PRE80]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Obtain more information about the storage pool:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取有关存储池的更多信息：
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'List all volumes that are a part of the storage pool:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有属于存储池的卷：
- en: '[PRE82]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Obtain information on the volume:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取卷的相关信息：
- en: '[PRE83]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Start new KVM instance using the storage pool and volume, then ensure that
    it''s running:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用存储池和卷启动新的KVM实例，并确保其正在运行：
- en: '[PRE84]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start this recipe with an image of a Debian OS that we installed earlier
    in the book; however, you can use an `empty`, `raw`, or `qcow2` image, add it
    to the storage pool, and install the virtual machine OS on it with almost no changes
    to the recipe steps if you don't have that image already.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本书前面安装的Debian操作系统镜像开始这份食谱；不过，如果你没有该镜像，完全可以使用一个`empty`、`raw`或`qcow2`镜像，添加到存储池中，并在其上安装虚拟机操作系统，几乎不需要更改食谱步骤。
- en: In step 1, we copy the VM image to the default libvirt storage pool location
    in `/var/lib/libvirt/images/`, but you can create your own directory, the location
    does not matter as long as it's defined in the storage pool configuration file.
    We do that in step 2.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们将VM镜像复制到默认的libvirt存储池位置`/var/lib/libvirt/images/`，但你也可以创建自己的目录，位置并不重要，只要在存储池配置文件中定义即可。我们在第2步完成这项工作。
- en: In step 3, we define the new storage pool, by specifying a name, target directory,
    and the type of the pool, in this case, a directory backend pool. We then proceed
    to list the new pool in step 4\. Note that, once defined, we still need to start
    it, just like defining a new KVM instance from an XML file. By default, the `autostart`
    option is not enabled on a new storage pool.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们定义新的存储池，通过指定名称、目标目录和池的类型，这里是一个目录后端池。然后在第4步继续列出新的池。请注意，一旦定义了存储池，我们仍然需要启动它，就像从XML文件定义新的KVM实例一样。默认情况下，`autostart`选项在新存储池上是禁用的。
- en: In step 5, we start the storage pool and ensure that it's active. We then proceed
    to enable the `autostart` feature so that the volumes can be used in case the
    host server restarts in step 6.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，我们启动存储池并确保它处于活动状态。然后在第6步中，我们继续启用`autostart`功能，以便在主机服务器重启时，卷能够被使用。
- en: Although not mandatory, we check the metadata provided for the storage pool
    and its volumes in step 7\. Note that the allocation field shows how much space
    is used by the volumes in the pool. We currently have a single raw image with
    that exact size.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不是强制性的，但我们在第7步检查存储池及其卷提供的元数据。请注意，分配字段显示了存储池中卷所占用的空间。目前我们有一个具有该精确大小的原始镜像。
- en: In step 8, we list all volumes that are a part of the new storage pool and obtain
    further information about the single volume in step 9.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们列出所有属于新存储池的卷，并在第9步获取该单个卷的更多信息。
- en: Finally in step 10, we start a new KVM instance using the storage pool and volume
    by passing the storage pool and volume names to the vol disk type.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 最后在第10步，我们通过将存储池和卷的名称传递给卷磁盘类型，启动一个新的KVM实例。
- en: There's more...
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Let's look at a slightly more complicated example of using storage pools by
    defining an iSCSI-backed pool.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个稍微复杂一点的示例，通过定义一个iSCSI支持的池来使用存储池。
- en: 'Creating an iSCSI target and logging it on the initiator  server is beyond
    the scope of this recipe, so we assume that you have an iSCSI target ready to
    be used from a remote server. The new storage pool definition is as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 创建iSCSI目标并在发起服务器上登录超出了本食谱的范围，因此我们假设你已经准备好一个可以从远程服务器使用的iSCSI目标。新的存储池定义如下：
- en: '[PRE85]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The file is very similar to the directory-backed storage pool, the main difference
    are the following attributes:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件与目录支持的存储池非常相似，主要区别在于以下属性：
- en: The `<host>` attribute specifies the hostname of the iSCSI target server that
    is exporting the iSCSI LUN
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<host>`属性指定正在导出iSCSI LUN的iSCSI目标服务器的主机名。'
- en: The `<device>` specifies the name of the iSCSI LUN we are going to log in
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<device>`指定我们将登录的iSCSI LUN的名称。'
- en: Once a new iSCSI block device has been logged in, it will appear in the location
    specified in `<path>`, on most Linux distributions in the `/dev/disk/by-path`
    directory
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦新的iSCSI块设备登录，它将出现在`<path>`指定的位置，在大多数Linux发行版中，位于`/dev/disk/by-path`目录下。
- en: 'We define and start the new storage pool the same way we did in steps 3 and
    5 earlier in the recipe. Once the storage pool is active, libvirt will log the
    remote iSCSI target LUNs. We can list the available iSCSI volumes as usual:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像在食谱中的步骤 3 和步骤 5 一样定义并启动新的存储池。一旦存储池激活，libvirt 会记录远程 iSCSI 目标 LUN。我们可以像往常一样列出可用的
    iSCSI 卷：
- en: '[PRE86]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To start a new installation process using the iSCSI volume as the target for
    the guest OS filesystem, run the following code:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 iSCSI 卷作为来宾操作系统文件系统的目标来启动新的安装过程，运行以下代码：
- en: '[PRE87]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: For more information about the XML definition of the other backend types, please
    refer to [https://libvirt.org/storage.html](https://libvirt.org/storage.html).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有关其他后端类型的 XML 定义的更多信息，请参见 [https://libvirt.org/storage.html](https://libvirt.org/storage.html)。
- en: Managing volumes
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理卷
- en: In the previous recipe, we saw how to create new storage pools, add a volume
    to it, and create a new KVM instance using that volume. In this recipe, we are
    going to focus on manipulating volumes that are a part of an existing storage
    pool. Strictly speaking, we are not required to use storage pools and volumes
    in order to build VMs. We can use other tools to manage and manipulate the virtual
    instance images, such as the `qemu-img` utility. Using volumes is just a convenience
    for having a centralized storage repository of various backend types.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个食谱中，我们看到了如何创建新的存储池，向其中添加卷，并使用该卷创建新的 KVM 实例。在这个食谱中，我们将专注于操作已存在存储池中的卷。严格来说，我们不需要使用存储池和卷来构建虚拟机。我们可以使用其他工具来管理和操作虚拟实例镜像，例如
    `qemu-img` 工具。使用卷只是为了方便集中存储各种后端类型的存储库。
- en: Getting ready
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The main requirement of this recipe is to have an existing storage pool with
    the directory backend. If you skipped the previous recipe, now is that time to
    create a new one, as we'll be using it to manipulate volumes.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的主要要求是需要有一个已存在的、目录后端的存储池。如果你跳过了前一个食谱，现在是时候创建一个新的了，因为我们将使用它来操作卷。
- en: How to do it...
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create, inspect and assign volumes to an instance, run the following:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建、检查并分配卷到实例，运行以下命令：
- en: 'List the available storage pools:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出可用的存储池：
- en: '[PRE88]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'List the available volumes, that are a part of the storage pool:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出存储池中可用的卷：
- en: '[PRE89]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create a new volume with the specified size:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个指定大小的新卷：
- en: '[PRE90]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'List the volumes on the filesystem:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出文件系统中的卷：
- en: '[PRE91]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Obtain information about the new volume:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取有关新卷的信息：
- en: '[PRE92]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Use the `virsh` command to get even more information:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `virsh` 命令获取更多信息：
- en: '[PRE93]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Dump the volume configuration:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转储卷配置：
- en: '[PRE94]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Resize the volume and display the new size:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整卷的大小并显示新的大小：
- en: '[PRE95]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Delete the volume and list all available volumes in the storage pool:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除卷并列出存储池中所有可用卷：
- en: '[PRE96]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Clone the existing volume:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆现有卷：
- en: '[PRE97]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works...
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We start this recipe with the `file_virtimages` storage pool we created in the
    previous recipe. We list all storage pools in step 1 to confirm that. In step
    2, we see that our storage pool contains a single volume. No surprises here as
    we created that in the last recipe in this chapter.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从在上一食谱中创建的 `file_virtimages` 存储池开始这个食谱。在步骤 1 中，我们列出了所有存储池以确认这一点。在步骤 2 中，我们看到我们的存储池包含一个卷。这里没有惊讶，因为我们在本章的上一个食谱中创建了它。
- en: In step 3, we create a new volume, by specifying its name, size, and the storage
    pool we want it to be a part of. Since this is a directory-backed storage pool,
    we can see the volume as a raw image file in step 4.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中，我们通过指定卷的名称、大小以及我们希望它属于的存储池来创建一个新卷。由于这是一个目录支持的存储池，我们可以在步骤 4 中看到该卷作为一个原始镜像文件。
- en: In steps 5 and 6, we collect more information about the new volume. We can see
    that it is a raw, therefore by default a sparse image. Sparse images don't allocate
    all of the disk space and grow as more data is being written to it.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 5 和步骤 6 中，我们收集了更多关于新卷的信息。我们可以看到它是原始格式的，因此默认是一个稀疏镜像。稀疏镜像不会分配所有磁盘空间，并随着数据写入的增多而增长。
- en: In step 7, we dump the definition of the volume. We can use that to define a
    new volume later on with the `virsh vol-create` command.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 7 中，我们转储了卷的定义。我们可以稍后使用 `virsh vol-create` 命令用它来定义一个新卷。
- en: Libvirt provides a convenient way to resize existing images. This is what we
    do in step 8--we resize the image to 10 GB. We can now see that the allocation
    size is smaller than the capacity; this is because the image is raw.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt 提供了一种方便的方式来调整现有镜像的大小。这就是我们在步骤 8 中所做的——我们将镜像大小调整为 10 GB。现在我们可以看到分配的大小小于容量；这是因为该镜像是原始格式的。
- en: Finally, in step 9, we delete the image, though we could have used it to install
    a new virtual machine, as shown in the *Working with storage pools* recipe.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第 9 步中，我们删除了镜像，尽管我们本可以使用它来安装一个新的虚拟机，正如 *使用存储池* 这一食谱所示。
- en: In the last step, we use the existing Debian image and created a clone volume
    from it. Starting a virtual machine using the cloned volume will result in an
    identical KVM instance, as the one we cloned the volume from. This combined with
    a dump of the instance definition is a great way to backup your KVM instances,
    as long as you store the volume image file and the XML definition file to a remote
    location. We are going to explore backing up KVM instances in later recipes.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们使用现有的 Debian 镜像并从中创建了一个克隆卷。使用克隆的卷启动虚拟机将导致生成与我们克隆的卷相同的 KVM 实例。结合实例定义的转储，这是备份
    KVM 实例的绝佳方式，只要你将卷镜像文件和 XML 定义文件存储到远程位置。我们将在后续的食谱中探讨如何备份 KVM 实例。
- en: Managing secrets
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理密钥
- en: Libvirt provides an API to create, store, and use secrets. Secrets are objects
    that contain sensitive information such as passwords, that can be associated with
    different volume backend types. Recall from the *Working with storage pools* recipe,
    which we created an iSCSI pool and volume from a remote iSCSI target and used
    it as the image for a KVM guest. In production environments, more often than not
    iSCSI targets are presented with CHAP authentication. In this recipe, we are going
    to create a secret to be used with an iSCSI volume.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Libvirt 提供了一个 API 来创建、存储和使用密钥。密钥是包含敏感信息（如密码）的对象，可以与不同的卷后端类型关联。回想一下 *使用存储池* 这一食谱，我们从远程
    iSCSI 目标创建了一个 iSCSI 存储池和卷，并将其用作 KVM 客户机的镜像。在生产环境中，iSCSI 目标通常会使用 CHAP 认证。在本食谱中，我们将创建一个密钥，用于与
    iSCSI 卷一起使用。
- en: Getting ready
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to need the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们需要以下内容：
- en: A storage pool with an iSCSI-backed volume
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 iSCSI 支持卷的存储池
- en: The `libvirt` package
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libvirt` 包'
- en: How to do it...
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To define and list secrets with libvirt, perform the steps outlined here:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 libvirt 定义和列出密钥，请按照以下步骤操作：
- en: 'List all available secrets:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有可用的密钥：
- en: '[PRE98]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Create the following secrets definition:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下密钥定义：
- en: '[PRE99]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Create the secret and ensure that it has been successfully created:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建密钥并确保它已成功创建：
- en: '[PRE100]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Set a value for the secret:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为密钥设置一个值：
- en: '[PRE101]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Create a new iSCSI pool definition file:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 iSCSI 存储池定义文件：
- en: '[PRE102]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: How it works...
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运作...
- en: In step 1, we list all available secrets that libvirt knows about. Since we
    haven't created any, the list is empty.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们列出了 libvirt 所知道的所有可用密钥。由于我们尚未创建任何密钥，因此列表为空。
- en: 'In step 2, we create the XML definition of the secret. The XML elements that
    we use to define the secret are:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 步中，我们创建了密钥的 XML 定义。我们用于定义密钥的 XML 元素包括：
- en: The `<secret>` root element, with an optional `ephemeral` attribute, telling
    `libvirt` that the password should only be stored in memory, if set to yes.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<secret>` 根元素，带有一个可选的 `ephemeral` 属性，告诉 `libvirt` 密码应仅存储在内存中（如果设置为 yes）。'
- en: The `<description>` attribute containing an arbitrary description.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<description>` 属性，包含一个任意描述。'
- en: The `<usage>` element specifies what the secrets is going to be used for and
    its type. In this example, the `type` attribute is set to iSCSI. The other available
    types are `volume`, `ceph`, and `tls`. The `type` attribute is mandatory.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<usage>` 元素指定密钥的用途及其类型。在本示例中，`type` 属性设置为 iSCSI。其他可用的类型包括 `volume`、`ceph`
    和 `tls`。`type` 属性是必填项。'
- en: The `<target>` element that specifies an arbitrary name is to be used in the
    iSCSI pool definition.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<target>` 元素指定了一个任意名称，用于 iSCSI 存储池定义中。'
- en: With the configuration file in place, we create the secret in step 3\. If the
    operation is successful, libvirt returns an UUID that identifies the secret.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件就绪后，我们在第 3 步中创建密钥。如果操作成功，libvirt 会返回一个 UUID，用于标识该密钥。
- en: In step 4, we set a value for the secret, by base64 encoding the `some_password`
    string, which is the password for the iSCSI target we would like to use, as a
    storage pool volume.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 步中，我们为密钥设置了一个值，通过 base64 编码 `some_password` 字符串，这是我们希望用于存储池卷的 iSCSI 目标密码。
- en: And finally in step 5, we add the `<auth>` attribute under the `<source>` section
    of the iSCSI pool definition. Note that the secret we would like the iSCSI volume
    to use is specified in the `<secret usage='iscsi_secret'/>` attribute. Libvirt
    can now use the `iscsi_secret` name to locate the actual password that it has
    stored.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第5步中，我们在iSCSI池定义的`<source>`部分下添加`<auth>`属性。请注意，我们希望iSCSI卷使用的密钥在`<secret
    usage='iscsi_secret'/>`属性中进行了指定。Libvirt现在可以使用`iscsi_secret`名称来定位它存储的实际密码。
