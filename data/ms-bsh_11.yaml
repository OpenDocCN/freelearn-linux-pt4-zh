- en: Living as a Daemon
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为守护进程运行
- en: 'In the journey that we had through the pages of this book, we saw lots of fun
    stuff, played with processes, sent signals, put things in the background, and
    wrote complex scripts. Everything done so far has one goal: to make us get the
    best from our Bash, have it working for us in repetitive tasks, and use built-ins,
    loops, and external commands to ease our everyday life as a power user. There
    are some times, though, when we need our scripts getting to work on a long run,
    maybe staying active indefinitely, so just running it as a normal program would
    not fit our need. We have to sweep through the obscure path of life as a daemon.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们翻阅本书的过程中，我们看到了很多有趣的东西，玩弄了进程，发送了信号，将任务放到后台，并编写了复杂的脚本。到目前为止所做的一切都有一个目标：让我们从
    Bash 中获得最佳的使用效果，让它为我们处理重复任务，并使用内建命令、循环和外部命令来简化我们作为高级用户的日常生活。然而，有时我们需要让我们的脚本长期运行，可能是无限期地活跃，所以下面就需要使用守护进程，而不仅仅是作为普通程序运行。我们必须踏上成为守护进程的那条模糊之路。
- en: What is a daemon?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是守护进程？
- en: 'Well, what makes a daemon different from a normal program? We usually want
    to use a daemon to get some of the following features:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，守护进程与普通程序有什么不同呢？我们通常想用守护进程来获得以下一些功能：
- en: Runs indefinitely
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永久运行
- en: Offers a service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供服务
- en: Survives even if the calling session ends
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使调用会话结束，仍然可以存活
- en: Does not lock a terminal
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会锁定终端
- en: Does not lock the any subdirectory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会锁定任何子目录
- en: 'That is, more or less, what a daemon as we know it does. Imagine the SSHD daemon,
    FTPD, or Apache:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所知的守护进程的基本功能。想象一下 SSHD 守护进程、FTPD 或 Apache：
- en: Runs in the background
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台运行
- en: Offers a service you interact with a socket
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供你与之交互的服务，通过一个套接字
- en: Can be started or stopped but no further direct interaction from the command
    line
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以启动或停止，但无法从命令行进行进一步的直接交互
- en: Available when you log in and still there when you log off
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你登录时可用，并且在你注销时依然存在
- en: They run in background
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在后台运行
- en: You actually have no idea on how they can do all of this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上根本不知道它们是如何做到这一切的。
- en: DEMO
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'So, how could we turn one of our scripts into a daemon? One first attempt could
    be using `&`. The trailing ampersand is a Bash built-in which instructs the shell
    to run the command in the background inside a subshell. Once the command is executed, the
    shell does not wait for it to finish but returns a code `0`, which means successful,
    and proceeds further in any other commands that are to be executed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何将一个脚本转变为守护进程呢？一个初步尝试可能是使用 `&`。尾随的 `&` 是 Bash 内建命令，它指示 shell 在子shell中后台运行命令。一旦命令执行，shell
    不会等待它完成，而是返回代码 `0`（表示成功），并继续执行其他命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What we saw in the example is that the shell executed the first `ls` command
    and gave us back this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中看到的是，shell 执行了第一个 `ls` 命令并返回了这个：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But then, it did not wait for the `ls` process to complete its job; it just
    forked it in a subshell and proceeded to execute the `ps` command. For our experiments,
    let''s create an empty shell and a script with an infinite loop, which actually
    does nothing:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它并没有等待 `ls` 进程完成工作；它只是将其分叉到一个子shell中，然后继续执行 `ps` 命令。为了进行我们的实验，让我们创建一个空的 shell
    和一个具有无限循环的脚本，这个脚本实际上什么也不做：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Nothing special, the only thing interesting here is that once launched, the
    script will execute until we stop it. Now, let''s run it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么特别的，唯一有趣的是，一旦启动，脚本将一直执行，直到我们停止它。现在，让我们运行它：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Well, we said it does nothing, but it actually does something: it gets hold
    of your terminal and will not give it back to you until it is terminated or sent
    into the background. So, here we have two options:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们说它什么都不做，但实际上它在做一些事情：它占据了你的终端，直到终止或被送入后台，它才会把终端交还给你。所以，我们有两个选择：
- en: '*Ctrl *+ *C* sends a `SIGKILL` signal to the process and terminates it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ctrl* + *C* 发送 `SIGKILL` 信号到进程并终止它：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Ctrl*+*Z *sends `SIGTSTP`, which suspends its execution:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ctrl* + *Z* 发送 `SIGTSTP`，它会暂停执行：'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once suspended, we can put the job in the background using its job ID, in our
    case `[1]`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦被暂停，我们可以使用其作业 ID 将任务放入后台，在我们的例子中是 `[1]`：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If now we check the status of the job, it will be this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在检查作业的状态，它将是这样的：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can see that the script is no longer stopped, but it is actually running
    in the background. At this point, you may have forgotten what was the PID of the
    subshell running the script, or you just do not know that there is a quick way
    to recall it, since it is stored in the `$!` variable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，脚本不再停止，而是实际上在后台运行。此时，你可能已经忘记了运行脚本的子壳的PID，或者你根本不知道有一种快速的方法可以召回它，因为它保存在`$!`变量中：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s bring the process into the foreground:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个过程带到前台：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Kill it since it got hold of the terminal once again:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 杀死它，因为它再次占用了终端：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s see what happens if we run multiple instances of the script directly
    in the background using the ampersand:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接在后台使用`&`运行多个脚本实例，会发生什么情况呢？
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, all of them are in the background with their own job ID:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，它们都在后台运行，并且拥有各自的作业ID：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There is something new in the output of jobs and those are  `–` and `+` characters,
    which are close to the job ID:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jobs`的输出中有一些新内容，那些是靠近作业ID的`–`和`+`字符：
- en: '`+`: This identifies the job that `fg` or `bg` will work on by default'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：这标识了`fg`或`bg`默认会操作的作业'
- en: '`-`: This identifies the job that would be the default if the current default
    job exited.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`：这标识了如果当前默认作业退出，将成为默认作业的作业'
- en: 'Let''s make a test. First, check the status of the jobs:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个测试。首先，检查作业的状态：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All of them are running in the background. Let''s recall in the foreground
    the default one:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都在后台运行。让我们将默认作业召回前台：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's suspend it with *Ctrl*+*Z:*
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用*Ctrl*+*Z*暂停它：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we just gave the `fg` command without an argument; and as expected, the
    job with ID `3` and the `+` trailing character was pulled into the foreground.
    Now, let''s check the status of the jobs:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们只是给出了没有参数的`fg`命令；如预期的那样，ID为`3`且带有`+`字符的作业被拉回了前台。现在，让我们检查作业的状态：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The third job is stopped, but we can see the `+` character. Let''s recall the
    default job to the foreground again, and then stop it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个作业被停止，但我们可以看到`+`字符。让我们再次将默认作业召回前台，然后停止它：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again, the third job is the default one because it never died, it just got
    suspended. So, time to gracefully kill it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，第三个作业是默认的，因为它从未终止，它只是被挂起了。所以，现在是时候优雅地终止它了：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s have a look at the status of the job now that we killed the default
    one:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在杀死默认作业之后，作业的状态：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's it, the job ID number `2` is now the default one, and the number `1`
    is the second in the line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，作业ID为`2`的作业现在是默认的，而编号为`1`的作业排在第二位。
- en: nohup
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`nohup`'
- en: 'nohup is a **Portable Operating System Interface** (**POSIX**) command that
    prevents the process given as an argument from receiving the **Hangup (HUP)**
    signal. If we run a script preceding it with nohup, it will be shielded by the
    HUP signal sent to all the processes when the interactive session closes. If the
    standard output is a terminal, nohup appends it to the `nohup.out` file in the
    local directory and if it is not possible in the user''s home directory while
    the standard error is redirected to the `stdout`. So something as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`nohup`是一个**可移植操作系统接口**（**POSIX**）命令，防止作为参数传递的进程接收到**挂起（HUP）**信号。如果我们在脚本前加上`nohup`运行，它将被保护，不受交互式会话关闭时发送给所有进程的HUP信号影响。如果标准输出是终端，`nohup`会将其附加到本地目录中的`nohup.out`文件中，如果无法在用户的主目录中写入，它会将标准错误重定向到`stdout`。所以下面是这样的情况：'
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The script is running in the background as `jobs` correctly reports:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本在后台运行，正如`jobs`命令正确报告的那样：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, the script is detached and `stdout` is redirected to the `nohup.out` file
    while`stdin` is ignored:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，脚本已经被分离，`stdout`被重定向到`nohup.out`文件，而`stdin`被忽略：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s exit our interactive session using `exit `and recreate a new session.
    We just have to open a new terminal and give the `jobs` command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`exit`退出我们的交互式会话，并重新创建一个新的会话。我们只需打开一个新终端并使用`jobs`命令：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Nothing, no jobs were listed. Why? Is the process still there? Let''s have
    a look:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何内容，没有作业被列出。为什么？进程还在吗？我们来看看：
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The script is still running and `PID` is the same, so why don''t we see it
    in the job list? Because we closed the old shell and opened a new one; and so
    the old job list, related to the old shell, got destroyed. This is desirable since
    without having a job ID, the shell cannot control the process and interfere with
    it directly. Then, have a look at the second field of the process listing:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本仍在运行，`PID`没有变化，那么为什么我们在作业列表中看不到它？因为我们关闭了旧的shell并打开了新的shell；因此，旧的作业列表与旧的shell相关联，已经被销毁。这是可取的，因为没有作业ID，shell就无法直接控制进程或与之干扰。然后，看看进程列表中的第二个字段：
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While `grep` has a terminal associated `pts/0`, the `while` script runs without
    any terminal associated, so we see `?` and that is what we wanted from the beginning.
    Before proceeding, let''s clean up, killing the script:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `grep` 关联了一个终端 `pts/0`，但是 `while` 脚本没有任何关联的终端，因此我们看到了 `?`，这正是我们一开始想要的。在继续之前，让我们清理一下，杀掉脚本：
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Nice, everything is clear, simple, and easy, isn''t it? No. Sometimes we just
    fire an application on a remote server through SSH. We use `nohup` and `&` to
    detach completely from the terminal, and shield it from the HUP signal on session
    closure; and then when we try to log off, our connection just hangs indefinitely.
    What happened? Why does everything seem to hang? This behavior is due to the OpenSSH
    server that handles the SSH connections: before closing the connection, OpenSSH
    waits to read the **end-of-file (eof)** on the pipes connected to `stdout` and
    `stderr` of the process ran by the user. The issue here is related to how a file
    returns an eof in Unix, and it does so when all the references to it have been
    closed. But when you run a process in the background of the shell you are working
    on over an SSH connection, the process gets the standard references to `stdout`
    and `stderr` of the shell it runs in. When you then close the shell, the OpenSSH
    server loses these references, because the shell has now died and so it will never
    see any eof coming from those. So, it will hang the connection indefinitely. So,
    how to prevent this? Actually either manually closing the process once it has
    been launched and before logging out or redirecting the references to the standard
    streams (`stdin`, `stdout`, `stderr`) when launching it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，一切都清晰、简单、易懂，是吧？不对。有时我们只是通过 SSH 在远程服务器上启动一个应用程序。我们使用 `nohup` 和 `&` 完全从终端中分离，并将它从会话关闭时的
    HUP 信号中保护起来；然后当我们尝试注销时，我们的连接就会无限期地挂起。发生了什么？为什么一切看起来都挂起了？这个行为是由于处理 SSH 连接的 OpenSSH
    服务器所致：在关闭连接之前，OpenSSH 会等待读取连接到用户运行的进程的 `stdout` 和 `stderr` 管道的 **文件结束符 (eof)**。这里的问题与
    Unix 中文件如何返回 eof 有关，只有在所有引用都被关闭时它才会返回 eof。但当你在通过 SSH 连接的 shell 后台运行一个进程时，该进程会得到与其运行的
    shell 的 `stdout` 和 `stderr` 的标准引用。当你关闭 shell 时，OpenSSH 服务器会失去这些引用，因为 shell 已经死掉，因此它永远看不到来自这些引用的
    eof 信号。所以，它会使连接无限期挂起。那么，如何防止这种情况呢？其实，解决方法是手动在退出前关闭该进程，或者在启动进程时重定向标准流（`stdin`、`stdout`、`stderr`）的引用。
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unfortunately, not even redirecting sometimes works since OpenSSH is quite sensitive
    to a bunch of causes and circumstances and will not send any HUP to the processes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使重定向有时也不起作用，因为 OpenSSH 对一堆原因和情况非常敏感，不会向进程发送任何 HUP 信号。
- en: disown
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: disown
- en: 'What if we run a process and then want to keep it alive even after the interactive
    shell has been closed? Let''s recall what happens when a shell exits: before exiting,
    it sends `SIGHUP` to all the jobs running. If a job is in stop state, the shell
    will send it a `SIGCONT` signal to resume it so that it can receive the `SIGHUP`
    signal and gracefully die. To accomplish this task, the shell browses through
    a table where it keeps all the jobs, and here is the trick. Let''s start a script
    in the background a few times:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动一个进程，然后想要在交互式 shell 关闭后仍然保持它的运行状态，该怎么办？让我们回顾一下 shell 退出时会发生什么：在退出之前，它会向所有正在运行的作业发送
    `SIGHUP` 信号。如果一个作业处于暂停状态，shell 会向它发送 `SIGCONT` 信号以恢复执行，这样它就可以接收到 `SIGHUP` 信号并优雅地退出。为了完成这个任务，shell
    会浏览一个包含所有作业的表格，接下来就是诀窍。让我们在后台启动一个脚本几次：
- en: '[PRE28]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s have a look at the shell job table:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 shell 的作业表：
- en: '[PRE29]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can see all three processes running as we expected. Now do the fun stuff:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到预期中的所有三个进程都在运行。现在，开始做有趣的部分：
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What just happened to the job with ID `2`?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ID 为 `2` 的作业发生了什么？
- en: '[PRE31]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Well, it disappeared from the job table but it''s still there:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它已经从作业表中消失，但它仍然在那里：
- en: '[PRE32]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `ps` command followed by `-p` and `pid` just shows us a process selecting
    it on `PID`. It just showed that our disowned job is still up and running. So,
    with `disown` , we just removed a job from the shell job list; and thus, when
    the shell exits, it will not send to this job the `SIGHUP` signal it would send if
    no `disown` was given. We can actually go even further:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 命令后面加上 `-p` 和 `pid` 只是用来显示我们选定的进程 `PID`。它刚刚显示了我们的“脱离”的作业仍然在运行。所以，使用 `disown`，我们只是把一个作业从
    shell 的作业列表中移除了；因此，当 shell 退出时，它不会向该作业发送 `SIGHUP` 信号，正如如果没有使用 `disown` 时会发送的那样。实际上，我们甚至可以进一步操作：'
- en: '[PRE33]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The job is still there but has been marked not to receive a `SIGHUP` signal
    from the shell when the latter exits. Optionally, you can run `disown` with no
    `ID` and `-a` so that it removes or marks all the IDs in the job table. No ID
    and `-r` will restrict the operations to only the running jobs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 任务仍然存在，但已经标记为在 shell 退出时不会收到 `SIGHUP` 信号。你可以选择使用没有 `ID` 和 `-a` 的 `disown` 来移除或标记任务表中的所有
    ID。如果没有 `ID` 和 `-r`，则操作将仅限于运行中的任务。
- en: 'Are the background processes not being killed after your interactive shell
    is closed? Let''s check this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的交互式 shell 关闭后，背景进程没有被终止吗？我们来检查一下：
- en: '[PRE34]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`huponexit` is set to off. This can be the reason why the background processes
    are not being killed on shell exit. We can temporarily set it on with this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`huponexit` 设置为关闭。这可能是背景进程在 shell 退出时未被终止的原因。我们可以通过以下方式暂时将其开启：'
- en: '[PRE35]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To make it permanent, set it in `~/.bashrc` or `/etc/bashrc` with `shopt -s
    huponexit.`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其永久生效，可以将其设置在 `~/.bashrc` 或 `/etc/bashrc` 文件中，使用 `shopt -s huponexit`。
- en: Double fork and setsid
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双重派生和 setsid
- en: There are a couple of methods to daemonize a process, maybe less popular but
    really interesting ones; and these are the **double fork** and **setsid**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将进程转为守护进程，虽然可能不太常见，但非常有趣；这些方法包括**双重派生**和**setsid**。
- en: Double fork is the way a process is usually daemonized and implies a fork, a
    duplication of the parent process to create a child one. In the case of double
    forking applied to daemonization, the parent process forks off a child process,
    then terminates it. Then, the child process forks its own child process and terminates.
    So, at the end of the chain, the two parent processes die and only the grandchild
    is alive and running but as a daemon. The reason for this resides in how a controlling
    terminal for a session is allocated since the child processes that are forked
    inherit the controlling terminal from their parent process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 双重派生是将进程转为守护进程的常用方法，意味着派生一个子进程，即通过复制父进程来创建一个子进程。在应用于守护进程化的双重派生中，父进程先派生一个子进程，然后终止它。接着，子进程再次派生自己的子进程并终止。这样，链条末端的两个父进程会死亡，只有孙进程存活并作为守护进程运行。这样做的原因与会话的控制终端分配方式有关，因为被派生的子进程会继承其父进程的控制终端。
- en: 'In an interactive session, the shell is the first processed to be executed,
    so it is the controlling process for the terminal and the session leader from
    which all forked processes in the session inherit their controlling terminal.
    Forking and killing the parent processes gives us an orphan process, which is
    automatically reparented to `init`, so it becomes the child of the main process
    of the system. All of this is to prevent the child process from being a session
    leader and acquiring a controlling terminal; and this is the reason why we double
    fork and kill the parent twice: we want to make the child process an orphan so
    that the system, to prevent it from becoming a zombie process, will reparent it
    to `init`. Since it is is not the first process in its pipeline, it cannot become
    a session leader and acquire the controlling terminal. So, the child process is
    then moved to a different session and has no hold on the controlling terminal,
    going effectively daemon.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式会话中，shell 是第一个被执行的进程，因此它是终端的控制进程，也是会话的会话领导进程，所有在该会话中派生的进程都会继承它的控制终端。通过派生并终止父进程，我们得到了一个孤儿进程，它会自动被重新父化为
    `init`，成为系统主进程的子进程。所有这一切的目的是为了防止子进程成为会话领导进程并获取控制终端；这就是为什么我们需要双重派生并两次终止父进程的原因：我们希望让子进程成为孤儿进程，以便系统将其重新父化为
    `init`，从而防止它变成僵尸进程。因为它不是管道中的第一个进程，所以不能成为会话领导进程，也不能获得控制终端。这样，子进程就被移动到一个不同的会话中，不再控制控制终端，实际上变成了守护进程。
- en: 'Let''s have a look and start our script in the background:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看，并将脚本放到后台运行：
- en: '[PRE36]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And have a look at the IDs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看进程的 ID：
- en: '[PRE37]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The session ID is the same as the shell from which it forked, but it has its
    own process group ID and the **Parent Process ID** (**PPID**)equal to its parent
    process ID. Let''s see where the script places itself in the process tree:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 会话 ID 与它派生自的 shell 相同，但它有自己的进程组 ID 和**父进程 ID**（**PPID**）等于它的父进程 ID。让我们看看脚本在进程树中所处的位置：
- en: '[PRE38]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As expected, it is nested inside the login session, so it is part of this session.
    Now, let''s double fork:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，它嵌套在登录会话中，因此它是该会话的一部分。现在，让我们进行双重派生：
- en: '[PRE39]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Have a look at the process:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个过程：
- en: '[PRE40]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The PPID of the shell executing `while` is now really interesting; it took
    the value of `1`. This means that his parent process is no longer the shell spawned
    at the login session but the `init` process. But notice, it still shares the same
    session ID and the same terminal. We can double-check with `pstree`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`while`的 shell 的 PPID 现在变得非常有趣；它的值变成了`1`。这意味着它的父进程不再是登录会话中启动的 shell，而是`init`进程。但请注意，它仍然共享相同的会话
    ID 和相同的终端。我们可以通过`pstree`再次确认：
- en: '[PRE41]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We do not have any nesting since we are directly reparented at the first level
    to `init`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们直接被重新归属于第一层`init`，所以没有任何嵌套。
- en: 'With `setsid`, we get a slightly different outcome. Whenever a process which
    is not the process group leader calls `setsid` , this creates a new session and
    makes the calling process the session leader, the process group leader of a newly
    created process group, and deprives it of a controlling terminal. So, we essentially
    come up with a new session that holds a new process group and only one process,
    the calling process. Both the session and process group ID are set to the calling
    process ID. We want to daemonize a process but there is a drawback, we do not
    have any output unless we redirect to a file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setsid`，我们得到一个稍微不同的结果。每当一个不是进程组领导的进程调用`setsid`时，它会创建一个新的会话，并使调用进程成为该会话的会话领导，成为新创建进程组的进程组领导，并且没有控制终端。因此，我们本质上创建了一个新会话，持有一个新进程组，并且只有一个进程，即调用进程。会话和进程组
    ID 都设置为调用进程的进程 ID。我们希望将进程转为守护进程，但有一个缺点，那就是除非我们重定向到文件，否则没有任何输出：
- en: '[PRE42]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s demonize our script:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将脚本转为守护进程：
- en: '[PRE43]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This time, we had to use the `-e` option of `ps` to show all the processes
    and the `grep` to while, because `ps`, by default, shows only the processes with
    the same effect user ID as the current user and with the same terminal. In this
    case, we changed the terminal, so it would not show up. Finally, let''s have a
    look at `pstree`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们需要使用`ps`的`-e`选项来显示所有进程，并且使用`grep`，因为`ps`默认情况下只显示与当前用户具有相同效应用户ID并且与当前终端相同的进程。在这种情况下，我们更改了终端，所以它不会显示。最后，让我们看一下`pstree`：
- en: '[PRE44]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we would expect, since the `PPID` is `1`, we see a nesting on the first level.
    The process, in our case the shell, executing the script is reparented to `init`
    without any controlling terminal.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，由于`PPID`为`1`，我们在第一层看到了嵌套。该进程，在我们的例子中是执行脚本的 shell，被重新归属于`init`，没有任何控制终端。
- en: 'Now that we have examined a few methods on how to effectively put a process
    in the background and shield it from a session closure, we can proceed further,
    having a look at how we can actually write scripts that demonize themselves, going
    in the background and working without user interaction. Well, there would be some
    workaround such as using utilities: a screen and a terminal multiplexer, which
    allow you to detach a session from a terminal so that the process can keep running
    even if user logs out. Anyway, this is not our goal, we are not reviewing external
    tools but trying to sort out the best from our Bash, so the next paragraph will
    dwell a bit on the different methods to have Bash to demonize our scripts.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了几种将进程有效地放到后台并使其避免会话关闭的方法，我们可以继续进一步，看看如何编写可以自动转为守护进程的脚本，使其进入后台并且无需用户交互地工作。当然，也有一些变通方法，比如使用工具：屏幕和终端复用器，这些工具允许你将会话从终端中分离，以便即使用户注销，进程仍然可以继续运行。无论如何，这不是我们的目标，我们不是在回顾外部工具，而是在尝试从
    Bash 中找出最佳方法，所以接下来的段落将会探讨一些不同的方法，如何让 Bash 将我们的脚本转为守护进程。
- en: Becoming a daemon
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为守护进程
- en: A life as a daemon is not an easy life and requires a lot of gruesome deaths
    of parent processes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程的生活并不轻松，需要经历父进程的无数“残酷死亡”。
- en: The first thing needed for a process to become a daemon is to fork as a new
    process so the parent can exit, and the the prompt is returned to the invoking
    shell. This ensures that the new process is not a process group leader, since
    a process group leader cannot create a new session calling `setsid`. So, the new
    child process can now be promoted to process group leader and session leader by
    calling `setsid`. So far, the new session has no controlling terminal, and so
    does the new child. So, we fork again to be sure that the session and group leader
    can exit. Now, the grandchild is not a session, so the terminal it is going to
    open cannot be its controlling terminal. This is how things work in the hard life
    of a Linux process; if it is not a session leader, the terminal it is going to
    open is not the controlling terminal for the calling process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使进程成为守护进程所需的第一步是通过`fork`创建一个新进程，以便父进程可以退出，命令行提示符返回给调用的shell。这确保新进程不是进程组领导者，因为进程组领导者不能通过调用`setsid`创建新会话。因此，新的子进程现在可以通过调用`setsid`提升为进程组领导者和会话领导者。到目前为止，新会话没有控制终端，新的子进程也没有。因此，我们再次调用`fork`以确保会话和组领导者能够退出。现在，孙子进程不是一个会话，因此它将要打开的终端不能是其控制终端。这就是Linux进程生活的艰难之处；如果它不是会话领导者，它将要打开的终端就不是调用进程的控制终端。
- en: 'Now, the process is detached from a controlling terminal but we still have
    an issue: it is locking the directory it has been called from, so if we tried
    to unmount it, we''d fail. The next step is to have the process change its working
    directory to `/` , the root directory of the filesystem (`chdir` `/`), or to any
    directory holding the files the process requires to be able to run. We are almost
    there. A good practice is to set `umask 0` for the process, so we reset `umask`.
    The process could have inherited and will create files with the permissions granted
    by the `open()` call. We are almost there; the next step for the process is to
    close the standard file descriptors (`stdin`, `stdout`, `stderr`) inherited from
    the parent process and open a new set.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进程已经与控制终端分离，但我们仍然有一个问题：它正在锁定它被调用的目录，所以如果我们尝试卸载它，我们会失败。下一步是让进程将工作目录更改为`/`，即文件系统的根目录（`chdir`
    `/`），或者更改为任何包含进程运行所需文件的目录。我们快完成了。一个好的做法是为进程设置`umask 0`，以便重置`umask`。进程可能已经继承了`umask`并会根据`open()`调用创建具有相应权限的文件。我们已经接近完成；下一步是让进程关闭从父进程继承的标准文件描述符（`stdin`，`stdout`，`stderr`），并打开一组新的文件描述符。
- en: Trapping a daemon
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获守护进程
- en: 'Before giving yourselves to the black magic of creating a daemon, you should
    learn how to shield it from any signals that can doom it to death. As we saw in
    the previous chapters, if a process dies, it could leave a mess behind since it
    had no time to clean *the house*. Scary, but we can do something to prevent all
    this: using traps that will help us deal with the signal and create more robust
    and well functioning scripts. In our case, the `trap` built-in will be handy to
    keep an eye on how our script behaves, since it is a signal handler that modifies
    how a process reacts to a signal. The general syntax of trap is here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在投入创建守护进程的黑魔法之前，你应该学会如何防止它受到任何可能导致其死亡的信号。如我们在前几章中所见，如果进程死亡，它可能会留下混乱，因为它没有时间清理*房子*。这很可怕，但我们可以做些事情来防止这一切发生：使用陷阱帮助我们处理信号并创建更强大、功能更完善的脚本。在我们的案例中，内建的`trap`将非常有用，用来监控我们的脚本行为，因为它是一个信号处理程序，可以修改进程如何响应信号。`trap`的通用语法如下：
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With commands being a list that can be executed, functions included, upon receiving
    a signal. We already saw some of the signals and their numeric values, but trap
    can use some keywords for the most common ones, as listed in the following table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 命令作为可以执行的列表，其中包括接收到信号时要执行的函数。我们已经看过一些信号及其数值，但`trap`可以使用一些关键字来处理最常见的信号，如下表所示：
- en: '| **Signal** | **Numeric value** |  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **信号** | **数字值** |  |'
- en: '| `HUP` | `1` | Hang up. Means that the controlling terminal exited. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `HUP` | `1` | 挂断。意味着控制终端已退出。 |'
- en: '| `INT` | `2` | Interrupt, it happens when *Ctrl* + *C* is pressed. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `INT` | `2` | 中断，当按下*Ctrl* + *C*时会发生。 |'
- en: '| `QUIT` | `3` | Quit. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `QUIT` | `3` | 退出。 |'
- en: '| `KILL` | `9` | This is an untrappable signal. Upon receiving, the process
    has to exit. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `KILL` | `9` | 这是一个无法捕获的信号。接收到该信号时，进程必须退出。 |'
- en: '| `TERM` | `15` | Terminate, is the default kill signal, can be handled, otherwise
    the process exits gracefully. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `TERM` | `15` | 终止，是默认的杀死信号，可以处理，否则进程会优雅地退出。 |'
- en: '| `EXIT` | `0` | An exit trap is raised on exit. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `EXIT` | `0` | 退出陷阱在退出时触发。 |'
- en: You can specify one or more signals per single trap, and you can also reset
    a trap to its default behavior using the trap called `– signal`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个陷阱中指定一个或多个信号，也可以通过调用 `– signal` 来重置陷阱的默认行为。
- en: 'Signals, how many of them? Who can remember all of them? No one but the `kill`
    command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 信号，多少种？谁能记得所有的信号？除了 `kill` 命令，没人能记得：
- en: '[PRE46]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, let''s see how to use a trap for a clean exit with this little example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用陷阱进行干净的退出，通过这个小例子：
- en: '[PRE47]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This script features an infinite `while` loop, which hosts a nested `for` loop,
    running through a range between `1` and `1000`. When the value of `x` reaches
    `500` , it prints a message on the `write.log` file. Upon exit, the inner loop
    is relaunched, but the outer structure is an infinite loop and will keep running
    indefinitely. Let''s run it and after a few seconds, let''s issue a *Ctrl *+ *C*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本有一个无限的 `while` 循环，其中嵌套着一个 `for` 循环，遍历 `1` 到 `1000` 的范围。当 `x` 的值达到 `500`
    时，它会在 `write.log` 文件中打印一条消息。退出时，内部循环会重新启动，但外部结构是一个无限循环，将会一直运行下去。让我们运行它，几秒钟后按 *Ctrl*+*C*：
- en: '[PRE48]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'So, we had the terminal locked by our script that was running in the foreground,
    and to regain control, we had to issue a `kill -15` , a *TERM* signal, by pressing
    *Ctrl*+*C*. Let''s have a look at the directory:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的脚本把终端锁定在前台运行，为了重新获得控制权，我们必须通过按 *Ctrl*+*C* 发出 `kill -15`，即 *TERM* 信号。让我们来看看目录：
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It seems that the log was left behind:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来日志被留下了：
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Yes, it is actually our log filled with the message we set up. Being a log,
    it is not so bad if it is left behind, but what if this were a temporary file?
    Would we want to litter the filesystem with temp files each time the script exits
    because of a term or another signal? Let''s improve it creating a cleanup function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，实际上是我们的日志，里面充满了我们设置的消息。作为日志，它被留下来也无妨，但如果这只是一个临时文件呢？每次脚本因终止或其他信号退出时，是否愿意在文件系统中留下临时文件？让我们通过创建一个清理函数来改进它：
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once invoked, this function will echo a meaningful message on `stdout`, delete
    the `write.log` file, and exit with a successful status. The last bit is the actual
    signal handler:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用，这个函数将在 `stdout` 上回显一条有意义的信息，删除 `write.log` 文件，并以成功状态退出。最后一部分是实际的信号处理程序：
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'That is all, let''s run the script and give a *Ctrl*+*C* after a while:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些，运行脚本后稍等片刻，然后按 *Ctrl*+*C*：
- en: '[PRE53]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It seems it worked; let''s have a look at the filesystem:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有效；让我们来看看文件系统：
- en: '[PRE54]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Clean, `write.log` has been cleaned upon exit. This is the expected and desired
    behavior. We can also go further, shielding the process from a signal so that
    is essentially ignored. Let''s add the following line to our script:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 干净，`write.log` 在退出时已被清理。这是预期并期望的行为。我们还可以更进一步，屏蔽进程不受信号影响，让它被忽略。让我们在脚本中添加以下行：
- en: '[PRE55]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let''s execute the script in the background:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在后台执行脚本：
- en: '[PRE56]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Well, since we are going to deal with daemons, we do not have to fear killing innocent
    processes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，既然我们要处理守护进程，我们就不必担心杀死无辜的进程：
- en: '[PRE57]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Haha! We killed you!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！我们杀死了你！
- en: '[PRE58]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Ahem, we have to reconsider our statement. It seems that our trap worked very
    well. In fact, a trap with a signal but with just `‘''` as argument simply lets
    the signal be ignored. Well, we have other means of destruction, as we can invoke
    `INT`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们得重新考虑一下我们的说法。看起来我们的陷阱工作得非常好。事实上，带有信号但仅用 `‘'` 作为参数的陷阱，实际上会让信号被忽略。好吧，我们还有其他的破坏方式，因为我们可以调用
    `INT`：
- en: '[PRE59]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we exited the script in an orderly manner, no logs left behind:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以有序的方式退出了脚本，未留下任何日志：
- en: '[PRE60]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The filesystem is clean, no `write.log` left on it. Now, let''s see a tricky
    use of a trap adding a few bits to our script. Let''s start with `y=0` placed
    at the very opening of the script, followed by a slightly revised loop:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是干净的，`write.log` 文件没有留下。现在，让我们看一下通过给脚本添加一些内容来使用陷阱的一个巧妙方法。我们先在脚本开头放入 `y=0`，然后是稍作修改的循环：
- en: '[PRE61]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s run the script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行脚本：
- en: '[PRE62]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If a signal is received while Bash is waiting for a command to complete, the
    trap will be executed only after the command is over with its execution. If the
    built-in `wait` is used, it will return immediately upon receiving a signal for
    which a `trap` is set and the `trap` itself gets executed. Notice that a `trap`
    usually exits with a status of 0, but, in this case, the value of the exit status
    will be higher than 128.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Bash 等待命令完成时接收到信号，陷阱将在命令执行完成后才会执行。如果使用内建的 `wait`，它将在收到设置了 `trap` 的信号时立即返回，随后
    `trap` 本身会被执行。请注意，`trap` 通常会以 0 的状态退出，但在这种情况下，退出状态的值将大于 128。
- en: 'Each time a command is executed, the value of the variable is printed as we
    can see, debugging the script with the `-x` option added to the Bash:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行命令时，变量的值都会打印出来，正如我们所见，使用`-x`选项调试Bash脚本时：
- en: '[PRE63]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Move around the `trap` line and see how much info you can gather by modifying
    it to suit your needs. So, play for a while and have fun preparing for the the
    final touch of magic.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到`trap`行，看看你能通过修改它来收集多少信息，以满足你的需求。所以，玩一会儿，享受为最终魔法触摸做准备的乐趣吧。
- en: Going dark with the daemon
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与守护进程一起走向黑暗
- en: 'Do you think doing daemons is a complex task? Yes it is, unless you use a nice
    utility called *daemon*. The task of this program is to daemonize other commands
    or script in a simple and neat way. Does this utility take any shortcuts? No,
    it just goes through all the steps we have already seen to detach a process from
    the controlling terminal, putting it in background, starting a new session, clearing
    the umask, and closing the old file descriptors. Well, doing it by ourselves in
    Bash coding will be quite a difficult task. This program makes everything straightforward,
    nothing to take care of manually. But there is a drawback: this is not a standard
    utility and must be installed by the user. Not a big issue indeed since many distributions
    such as Debian or Red Hat have a package for this utility.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为做守护进程是一项复杂的任务吗？是的，除非你使用一个叫做*daemon*的好用工具。这个程序的任务是以简单整洁的方式将其他命令或脚本转变为守护进程。这个工具有没有采取任何捷径？没有，它只是通过我们已经看到的所有步骤，将进程从控制终端中分离出来，放到后台，启动一个新会话，清除umask，并关闭旧的文件描述符。嗯，如果我们自己在Bash脚本中做这个，确实会是一项相当困难的任务。这个程序让一切变得简单明了，无需手动处理任何事情。但也有一个缺点：这不是一个标准工具，必须由用户手动安装。其实这不算大问题，因为许多发行版如Debian或Red
    Hat都有这个工具的安装包。
- en: 'Time to try this utility out, so let''s take our `write.sh` script and daemonize
    it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该是尝试这个工具的时候了，所以让我们把`write.sh`脚本转变为守护进程：
- en: '[PRE64]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We just called the daemon program, passing the full path to our script and
    the `-r` option that will respawn it in case it gets stopped. Let''s see what
    happens on our system:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚调用了daemon程序，传递了脚本的完整路径以及`-r`选项，这样如果脚本被停止，它会重新启动。让我们看看在我们的系统上会发生什么：
- en: '[PRE65]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Great, our script has no controlling terminal; it is running in background
    and writing its log file into the root directory of our filesystem. Now, let''s
    kill it with the `-9` option, as no process can ignore it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们的脚本没有控制终端；它正在后台运行，并将日志文件写入我们文件系统的根目录。现在，让我们使用`-9`选项终止它，因为没有进程可以忽略它：
- en: '[PRE66]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'So we killed the process; let''s verify it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们杀死了这个进程；让我们验证一下：
- en: '[PRE67]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The script is there. We actually killed its process but the `-r` option for
    daemon forced it to respawn the script; and here we are, our daemon is up and
    running even though we killed it. If we really want to read it, we must first
    kill the daemon program then the script process:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本就在这里。我们实际上终止了它的进程，但由于守护进程的`-r`选项，它强制重新启动了脚本；于是我们看到了，我们的守护进程正在运行，即使我们终止了它。如果我们真的想读取它，我们必须先终止守护进程程序，然后终止脚本进程：
- en: '[PRE68]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This is the easiest way to run daemon, which has quite a bunch of options.
    For instance, let''s say we want to run the script as user `zarrelli` and have
    it change the directory to a subdir:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行守护进程的最简单方式，实际上它有很多选项。例如，假设我们希望以用户`zarrelli`身份运行脚本，并让它更改目录到一个子目录：
- en: '[PRE69]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'With `-D`, we gave a new target for `chdir` while `-u` gives the process a
    new running user as we can see from `ps`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-D`，我们为`chdir`指定了一个新的目标，而`-u`为进程指定了一个新的运行用户，正如我们从`ps`命令中看到的：
- en: '[PRE70]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As expected, the newly created log files belong to the user called `zarrelli`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，新的日志文件属于名为`zarrelli`的用户：
- en: '[PRE71]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Simple, but probably we want a service that runs at the startup of the system
    and stops when it shuts down. So, why not use `systemd` for our purposes?  First
    step, we create the `/etc/systemd/system/writing.service` file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，但我们可能希望有一个在系统启动时运行并在关机时停止的服务。那么，为什么不使用`systemd`来满足我们的需求呢？第一步，我们创建`/etc/systemd/system/writing.service`文件。
- en: 'We are going to create a basic unit for a `systemd` managed service, so let''s
    write the following unit configuration lines inside the file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`systemd`管理的服务创建一个基本单元，所以让我们在文件中写入以下单元配置行：
- en: '[PRE72]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Nothing special here; depending on what kind of script we are going to demonize,
    we can choose our after target. A network script needs to be run after the network
    is up, so `network.target` is more appropriate here. We could just want to add
    some logging function, so we gave `syslog.target`. We could also give multiple
    target, so it really depends on what we are going to demonize. Under `[Service]` ,
    we just point out the script executable and, more importantly, the type of execution:
    since our script will run indefinitely, it will never exit. So we need to specify
    the *simple* startup style so that `systemd` will execute the script and move
    on without waiting for it to exit like in the *fork* style. The rest is quite
    straightforward, so let''s save the file and give the appropriate permission to
    it:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的；根据我们要守护的脚本类型，可以选择合适的目标。如果是网络脚本，需要在网络启动后运行，因此`network.target`在这里更为合适。如果我们只想添加一些日志功能，可以使用`syslog.target`。我们也可以设置多个目标，这完全取决于我们要守护的是什么。在`[Service]`下，我们只需要指定脚本可执行文件，并且更重要的是指定执行类型：由于我们的脚本将会无限期运行，永远不会退出。因此，我们需要指定*简单*的启动方式，这样`systemd`就会执行该脚本并继续处理，而不是像*fork*模式那样等待脚本退出。其余的部分非常直接，因此我们保存文件并赋予它适当的权限：
- en: '[PRE73]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, time to enable the service:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了启用服务的时刻：
- en: '[PRE74]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Create a symlink from `/etc/systemd/system/default.target.wants/writing.service`
    to `/etc/systemd/system/writing.service`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从`/etc/systemd/system/default.target.wants/writing.service`创建一个符号链接到`/etc/systemd/system/writing.service`。
- en: 'Reloading the `systemd` daemon will help to have the new service recognized:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载`systemd`守护进程将有助于使新服务被识别：
- en: '[PRE75]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Well, we are ready for the first execution of our service:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们准备好首次执行我们的服务了：
- en: '[PRE76]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'No output here, but since this service is managed by `systemd` , we can ask
    the latter what is going on:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有输出，但由于这个服务是由`systemd`管理的，我们可以询问它当前的状态：
- en: '[PRE77]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The script is running; let''s make some other checks:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本正在运行；让我们做些其他检查：
- en: '[PRE78]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `log` file is there, filling up; now let''s check the terminal:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`文件在那里，正在填充；现在让我们检查终端：'
- en: '[PRE79]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here it is, without an associated controlling terminal. Last bit, we have to
    stop the daemon when we do not want it to run:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里它来了，没有关联的控制终端。最后一步，当我们不想让守护进程继续运行时，我们需要停止它：
- en: '[PRE80]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, if we do not want our daemon to be managed by `systemd` anymore, we
    can just unlink it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们不希望`systemd`再管理我们的守护进程，可以直接取消链接它：
- en: '[PRE81]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, restart `systemd` daemon:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动`systemd`守护进程：
- en: '[PRE82]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结：
- en: In this chapter, we had a look at how to set a process in the background and
    have it survive to our logouts and to most of the signal we could send to it.
    Next step was how to daemonize a process and how to make a system managed service
    out of it thanks to systemd. Is that all? Well, no. With a bit of creativity,
    we can assemble the bits and bricks we were given and create our own daemonized
    scripts and services, so this could be a nice homework during some rainy days.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们查看了如何将一个进程放到后台并使其在我们注销后继续运行，以及如何让它抵抗我们可能发送给它的大部分信号。接下来的步骤是如何将进程守护化，并利用`systemd`将其转变为一个系统管理的服务。就这样了吗？当然不是。通过一点创造力，我们可以将现有的碎片和构件拼接在一起，创建我们自己的守护进程脚本和服务，所以这可以成为一个不错的作业，尤其是在雨天的时候。
- en: We are now leaving daemons and moving onto something more related to system
    administration tasks, and we will see how to use some easy, powerful utilities
    and services to customize the environment we are working in and how to make it
    reasonably safe with little efforts.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将离开守护进程部分，转向一些更相关的系统管理任务，我们将看看如何使用一些简单而强大的工具和服务来定制我们工作的环境，并且如何以最小的努力使其保持合理的安全性。
