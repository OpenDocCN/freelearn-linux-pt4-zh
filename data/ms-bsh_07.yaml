- en: Plug into the Real World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到现实世界
- en: 'We are moving into the real world now, creating something that can turn out
    handy for your daily routine; during this process, we will have a look at the
    common pitfalls in coding and how to make our script reliable. Be it a short or
    long script, we must always ask ourselves the same questions:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入了现实世界，正在创造一些对日常工作有用的工具；在这个过程中，我们将关注编程中常见的陷阱，并学习如何使我们的脚本更可靠。不管脚本长短，我们必须始终问自己相同的问题：
- en: What do we really want to accomplish?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们到底想要达成什么目标？
- en: How much time do we have?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有多少时间？
- en: Do we have all the resources needed?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否具备所需的所有资源？
- en: Do we have the knowledge required for the task?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否具备完成任务所需的知识？
- en: We will start coding with a Nagios plugin, which will give us a broad understanding
    of how this monitoring system is and how to make a script dynamically interact
    with other programs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写一个 Nagios 插件开始，这将帮助我们广泛理解这个监控系统是如何运作的，以及如何使脚本与其他程序动态交互。
- en: What is Nagios?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Nagios？
- en: '**Nagios** is one of the most widely adopted open source IT infrastructure
    monitoring tools, whose main interesting feature is the fact that it does not
    know how to monitor anything. Well, it sounds like a joke, but actually Nagios
    can be defined as an evaluating core, which takes some information as input and
    reacts accordingly. How is this information gathered? It is not the main concern
    of this tool and this leads us to an interesting point: Nagios leaves the task
    of getting the monitored data to an external plugin, which knows the following
    details:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**Nagios** 是最广泛采用的开源 IT 基础设施监控工具之一，其主要有趣之处在于它本身并不知道如何监控任何东西。听起来像是开玩笑，但实际上，Nagios
    可以被定义为一个评估核心，它接受一些信息作为输入，并根据这些信息做出反应。那么，这些信息是如何收集的呢？这并不是这个工具的主要关切，这也引出了一个有趣的观点：Nagios
    将收集监控数据的任务交给一个外部插件，插件需要知道以下细节：'
- en: How to connect to the monitored services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何连接到被监控的服务
- en: How to collect the data from the monitored services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何收集来自被监控服务的数据
- en: How to evaluate the data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何评估数据
- en: Inform Nagios if the values gathered are beyond or in the boundaries to raise
    an alarm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收集到的值超出了或在警报阈值范围内，通知 Nagios 触发警报。
- en: 'So, a plugin does a lot of things and one would ask oneself what does Nagios
    do then? Imagine it as an exchange pod where information is flowing in and out
    and decisions are taken based on the configurations set; the core triggers the
    plugin to monitor a service; the plugin itself returns some information and Nagios
    takes a decision about:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个插件做了很多事情，可能有人会问，Nagios 到底在做什么？可以把它想象成一个信息交换舱，信息不断地流进流出，决策是基于设置的配置做出的；核心触发插件去监控某个服务；插件本身返回一些信息，然后
    Nagios 根据这些信息做出决策：
- en: Whether to raise an alarm
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否触发警报
- en: Send a notification
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送通知
- en: Whom to notify
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知谁
- en: For how long
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续多长时间
- en: What, if any action is taken in order to get back to normality
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果采取任何措施以恢复正常状态
- en: The core Nagios program does everything except actually knock at the door of
    a service, ask for information, and decide whether this information shows some
    issues or not.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 核心的 Nagios 程序除了真正敲开服务的大门，索取信息并决定这些信息是否显示出问题外，其他一切都做了。
- en: Active and passive checks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主动和被动检查
- en: To understand how to code a plugin, we have first to grasp how, on a broad scale,
    a Nagios check works. There are two different kinds of checks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何编写一个插件，我们首先需要广泛理解 Nagios 检查的工作原理。Nagios 检查有两种不同类型。
- en: Active checks
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主动检查
- en: 'Based on a time range, or manually triggered, an active check sees a plugin
    actively connecting to a service and collecting information. A typical example
    could be for a plugin to check the disk space: once invoked, it interfaces with
    (usually) the operating system, executes a `df` command, works on the output,
    extracts the value related to the disk space, evaluates it against some thresholds,
    and reports back a status, such as OK, WARNING, CRITICAL, or UNKNOWN.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于时间范围，或者手动触发的情况下，主动检查会看到插件主动连接到服务并收集信息。一个典型的例子是插件检查磁盘空间：一旦被调用，它通常会与操作系统进行交互，执行
    `df` 命令，处理输出，提取与磁盘空间相关的值，评估是否超过某些阈值，并返回状态，例如 OK、WARNING、CRITICAL 或 UNKNOWN。
- en: Passive checks
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被动检查
- en: 'In this case, Nagios does not trigger anything but waits to be contacted by
    some means by the service, which must be monitored. It seems quite confusing,
    but let''s make a real-life example. How would you monitor if a disk backup has
    been completed successfully? One quick answer would be: knowing when the backup
    task starts and how long it lasts, we can define a time and invoke a script to
    check the task at that given hour.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Nagios 并不会触发任何操作，而是等待服务通过某种方式主动联系，服务必须被监控。看起来有些困惑，但我们可以通过一个实际的例子来说明。你怎么监控一个磁盘备份是否成功完成？一个简单的回答是：了解备份任务的开始时间和持续时间后，我们可以定义一个时间并调用脚本，在那个指定时间检查任务。
- en: Nice, but when we plan something, we must have a full understanding of how real
    life goes, and a backup is not our little pet in the living room, it's rather
    a beast, which does what it wants. A backup can last a variable amount of time
    depending on an unpredictable factor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但当我们进行规划时，我们必须充分理解现实生活的运行方式，备份并不是我们客厅里的一只小宠物，它更像是一头野兽，做它想做的事。备份的持续时间可能因不可预测的因素而有所不同。
- en: For instance, your typical backup task would copy 1 TB of data in 2 hours, starting
    at 03:00, out of a 6 TB disk. So, the next backup task would start at 03:00+02:00=05:00
    AM, give or take some minutes. And you set up an active check for it at 05:30,
    and it works well for a couple of months. Then, one early morning, you receive
    a notification on your smartphone that the backup is in CRITICAL. You wake up,
    connect to the backup console and see that at 06:00 in the morning, you are asleep
    and the backup task has not even been started by the console. Then, you have to
    wait until 08:00 AM until some of your colleagues show up at the office to find
    out that the day before the disk, your backup has been filled with 2 extra TB
    of data due to an unscheduled data transfer. So, the backup task preceding the
    one you are monitoring lasted not for a couple of hours but 6 hours, and the task
    you are monitoring then started at 09:30 AM.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，你的典型备份任务会在 2 小时内复制 1 TB 的数据，开始时间为 03:00，从一个 6 TB 的磁盘中进行备份。那么，下一个备份任务将从 03:00+02:00=05:00
    AM 开始，可能有几分钟的误差。你设置了一个 05:30 的主动检查，它运行了几个月都很顺利。然后，在某个清晨，你收到手机上的通知，备份任务处于 CRITICAL
    状态。你醒来，连接到备份控制台，发现早上 06:00，你还在睡觉，备份任务甚至没有被控制台启动。然后，你必须等到 08:00 AM，直到一些同事到达办公室，才发现前一天备份磁盘由于一次非计划的数据传输，增加了
    2 TB 的数据。所以，前一个备份任务并没有持续几小时，而是持续了 6 小时，而你监控的备份任务在 09:30 AM 开始。
- en: Long story short, your active check has been fired up too early; that is why
    it failed. Maybe your are tempted to move your schedule some hours ahead, but
    simply do not do it, as these time slots are not sliding frames. If you move your
    check ahead, you should then move all the checks for the subsequent tasks ahead.
    You do it in one week, the project manager will ask someone to delete the 2 TB
    excess (useless for the project now), and your schedules will be 2 hours ahead,
    making your monitoring useless. So, as we insisted before, planning and analyzing
    the context is the key factor in making a good script and, in this case, a good
    plugin. We have a service that does not run 24/7 like a web service or a mail
    service; what is specific to the backup is that it is run periodically, but we
    do not know exactly when.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，你的主动检查启动得太早了，这就是它失败的原因。也许你会想把时间安排提前几个小时，但千万不要这么做，因为这些时间段不是滑动框架。如果你把检查提前，你就应该将所有后续任务的检查时间也提前。你这样做了一周后，项目经理会要求某人删除那
    2 TB 的多余数据（现在对项目没有用），而你的时间安排将提前 2 小时，导致监控变得没用。所以，正如我们之前所说，规划和分析上下文是编写一个好脚本、一个好插件的关键因素。我们有一个不像
    web 服务或邮件服务那样 24/7 运行的服务，备份的特殊之处在于它是定期执行的，但我们并不确切知道它什么时候运行。
- en: 'The best approach to this kind of monitoring is letting the service itself
    notify us when it finished its task and what was its outcome. This is usually
    accomplished using the ability of most backup programs to send a **Simple Network
    Monitoring Protocol** (**SNMP**) trap to a destination to inform it of the outcome;
    and in our case it would be the Nagios server, which would have been configured
    to receive the trap and analyze. Add to this an event horizon so that if you do
    not receive the specific trap in, let''s say, 24 hours, we raise an alarm anyway
    and you are covered: whenever the backup task gets completed or when it times
    out, we receive a notification.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种监控的最佳方法是让服务在完成任务并报告结果时主动通知我们。通常，这通过大多数备份程序能够发送**简单网络管理协议**（**SNMP**）陷阱来实现，告知目的地结果是什么；在我们的案例中，它将是
    Nagios 服务器，Nagios 被配置为接收这个陷阱并进行分析。再加上一个事件时间范围，这样如果我们在，比如说，24 小时内没有收到特定的陷阱，我们就会触发警报，这样你就有保障了：无论是备份任务完成，还是超时，我们都会收到通知。
- en: '![](img/00012.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: Nagios notifications flowchart
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Nagios 通知流程图
- en: Returning code and thresholds
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回代码和阈值
- en: 'Before coding a plugin, we must face some concepts that will be the stepping
    stone of our Nagios code base, one of these being the return codes of the plugin
    itself. As we already discussed, once the plugin collects the data about how the
    service is going, it evaluates these data and determines if the situation falls
    under one of the following status:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写插件代码之前，我们必须面对一些概念，这些概念将成为我们 Nagios 代码库的基石，其中之一就是插件本身的返回代码。正如我们之前讨论的，一旦插件收集了关于服务运行情况的数据，它就会评估这些数据并判断情况是否属于以下状态之一：
- en: '| **Return code** | **Status** | **Description** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **返回代码** | **状态** | **描述** |'
- en: '| `0` | OK | The plugin checked the service and the results that are inside
    the acceptable range. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 正常 | 插件检查了服务，并且结果在可接受范围内。 |'
- en: '| `1` | WARNING | The plugin checked the service and the results that are above
    a WARNING threshold. We must keep an eye on the service. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 警告 | 插件检查了服务，并且结果超过了警告阈值。我们必须关注这个服务。 |'
- en: '| `2` | CRITICAL | The plugin checked the service and the results that are
    above a CRITICAL threshold or the service not responding. We must react now. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 危急 | 插件检查了服务，并且结果超出了危急阈值，或者服务没有响应。我们现在必须采取行动。 |'
- en: '| `3` | UNKNOWN | Either we passed the wrong arguments to the plugin or there
    is some internal error in it. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `3` | 未知 | 要么是我们向插件传递了错误的参数，要么插件内部出现了某些错误。 |'
- en: 'So, our plugin will check a service, evaluate the results, and based on a threshold,
    will return to Nagios one of the values listed in the tables and a meaningful
    message, like we can see in the description column in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的插件将检查服务，评估结果，并根据阈值，将表格中列出的一个值和有意义的消息返回给 Nagios，正如我们在下方截图中的描述列所看到的那样：
- en: '![](img/00013.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: Notice the service check in red and the message in the preceding screenshot.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面截图中的红色服务检查和消息。
- en: In the screenshot, we can see that some checks are green, meaning okay, and
    they have an explicative message in the description section. What we see in this
    section is the output of the plugin written in the `stdout`; and it is what we
    will craft as a response to Nagios.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中，我们可以看到一些检查是绿色的，表示正常，它们在描述部分有详细的解释信息。我们在此部分看到的是插件写入 `stdout` 的输出；这也是我们将作为对
    Nagios 的响应来构建的内容。
- en: 'Pay attention to the SSH check: it is red and is failing because it is checking
    the service at the default port, which is `22`, but on this server the `ssh` daemon
    is listening on a different port. This leads us to a consideration: our plugin
    will need a command line parser able to receive some configuration options and
    some threshold limits as well, because we need to know what to check, where to
    check, and what are the acceptable working limits for a service:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 SSH 检查：它是红色的，并且失败了，因为它在默认端口 `22` 检查服务，但在这台服务器上，`ssh` 守护进程监听的是一个不同的端口。这引出一个问题：我们的插件需要一个命令行解析器，能够接收一些配置选项和阈值限制，因为我们需要知道检查什么、在哪里检查以及服务的可接受工作范围是什么：
- en: '**Where**: In Nagios, there can be a host without service checks (except for
    the implicit host alive carried on by a ping), but no services without a host
    to be performed onto. So, any plugin must receive on the command line the indication
    of the host to be run against, be it a dummy host but there must be one.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：在 Nagios 中，可以有没有服务检查的主机（除了通过 ping 进行的隐式主机存活检查），但不能有没有主机的服务。因此，任何插件都必须在命令行中接收要执行的主机指示，可以是虚拟主机，但必须指定。'
- en: '**How**: This is where our coding comes in; we will have to write the lines
    of code that instruct the plugin how to connect to the server, query, collect,
    and parse the answer.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何**：这是我们编写代码的地方；我们必须编写代码行，指示插件如何连接到服务器、查询、收集和解析响应。'
- en: '**What**: We must instruct the plugin, usually with some meaningful options
    on the command line, on what are the acceptable working limits so that it can
    evaluate them and decide to notify us with an OK, WARNING, or CRITICAL message.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义**：我们必须指示插件，通常通过命令行中带有一些有意义的选项，告诉它哪些是可接受的工作限制，以便它可以评估这些限制并决定是否向我们发送 OK、WARNING
    或 CRITICAL 消息。'
- en: 'That is all for our script: who to notify, when, how, how many times, and so
    forth. These are tasks carried on by the core; a Nagios plugin is unaware of all
    of this. What it really must know for effective monitoring is what are the correct
    values that identify a working service. We can pass to our script two different
    kinds of value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们脚本的全部内容：谁在何时、如何、多少次通知我们，等等。这些任务由核心处理；Nagios 插件对此并不知情。插件真正需要了解的有效监控内容是识别工作服务的正确值是什么。我们可以向脚本传递两种不同类型的值：
- en: '**Range**: This is a series of numeric values with a starting and ending point,
    like from 3 to 7 or from one number to infinite'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：这是一个带有起始点和结束点的数值系列，例如从 3 到 7 或从一个数字到无限大'
- en: '**Threshold**: It is a range with an associated alert level'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阈值**：这是一个带有相关警报级别的范围'
- en: 'So, when our plugins perform checks, they collect a numeric value that is within
    or outside a range, based on the threshold we impose; then, based on the evaluation,
    it replies to Nagios with a return code and a message. How do we specify some
    ranges on the command line? Essentially in the following way:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们的插件执行检查时，它们会收集一个在范围内或范围外的数值，这取决于我们设置的阈值；然后，根据评估结果，它将通过返回代码和消息回复 Nagios。那么，我们如何在命令行中指定某些范围呢？基本上是以下方式：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the range starts from `0`, the part from `:` to the left can be omitted.
    The `start_value` must always be a lower number than `end_value`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果范围从 `0` 开始，则可以省略从 `:` 到左边的部分。`start_value` 必须始终小于 `end_value`。
- en: If the range starts with `start_value`, it means from that number to infinity.
    Negative infinity can be specified using `~`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果范围从 `start_value` 开始，表示从该数字到无限大。可以使用 `~` 指定负无穷大。
- en: An alert is generated when the collected value resides outside the range specified,
    comprised of the endpoints.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当收集的值超出指定范围（包括端点）时，会生成警报。
- en: If `@` is specified, the alert is generated if the value resides inside the
    range.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了 `@`，当值位于范围内时会生成警报。
- en: 'Let''s see some practical examples of how we would call our script, imposing
    some thresholds:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些如何在命令行中调用脚本并设置阈值的实际示例：
- en: '| **Plugin call** | **Meaning** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **插件调用** | **含义** |'
- en: '| `./my_plugin -c 10` | CRITICAL if less than `0` or higher than `10` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `./my_plugin -c 10` | 如果小于 `0` 或大于 `10` 则为 CRITICAL |'
- en: '| `./my_plugin -w 10:20` | WARNING if less than `10` or higher than `20` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `./my_plugin -w 10:20` | 如果小于 `10` 或大于 `20` 则为 WARNING |'
- en: '| `/my_plugin -w ~:15 -c 16` | WARNING if between -infinite and `15`, critical
    from `16` and higher |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `/my_plugin -w ~:15 -c 16` | 如果在负无限大和 `15` 之间则为 WARNING，`16` 及更高则为 CRITICAL
    |'
- en: '| `./my_plugin -c 35:` | CRITICAL if the value collected is below `35` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `./my_plugin -c 35:` | 如果收集的值低于 `35` 则为 CRITICAL |'
- en: '| `./my_plugin -w @100:200` | CRITICAL if the value is from `100` to `200`,
    OK otherwise |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `./my_plugin -w @100:200` | 如果值在 `100` 到 `200` 之间则为 CRITICAL，其他情况为 OK |'
- en: 'We covered the basic requirements for our plugin that in its simplest form
    should be called with the following syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了插件的基本要求，在最简单的形式下，它应该使用以下语法调用：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We already talked about the need to relate a check to a host; we can do this
    either by using a hostname or hostaddress. It is up to us what to use, but we
    will not fill in this piece of information, because it will be drawn by the service
    configuration as a standard macro. We just introduced a new concept, service configuration,
    which is essential in making our script work in Nagios, so let''s briefly see
    what we are talking about. A caveat before starting our journey on Nagios configurations:
    this is not a book on Nagios, so we will not cover all the complex bits and parts.
    We will touch all the topics needed to make our script do its job and with a working
    Nagios installation; we will be able to activate our new plugin quickly. Let''s
    see now how to configure a plugin to make it work under Nagios, so then we will
    be able to focus on our script without any distractions.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过需要将检查与主机关联起来的必要性；我们可以使用主机名或主机地址来实现这一点。我们可以自行决定使用哪种方式，但我们不会填写这一信息片段，因为它将被服务配置作为标准宏引用。我们刚刚介绍了一个新概念，服务配置，在Nagios中使我们的脚本工作变得至关重要，因此让我们简要地看看我们正在讨论什么。在开始讨论Nagios配置之前，我们需要注意一点：这不是一本关于Nagios的书籍，因此我们不会覆盖所有复杂的细节和部分。我们将涉及所有使我们的脚本正常工作所需的主题，并通过一个工作正常的Nagios安装能够快速激活我们的新插件。现在让我们看看如何配置一个插件以使其在Nagios下工作，然后我们将能够专注于我们的脚本而没有任何分散注意力的干扰。
- en: Command and service definitions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令和服务定义
- en: At the base of everything in Nagios is a plugin, the minion who carries out the
    job of retrieving the information, evaluating it, raising the alarm, and providing
    a meaningful message. Left alone, Nagios does not know how to call a plugin, what
    options to pass to it or how to handle it, so we need a command definition, which
    defines how the script will be called.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nagios的一切基础之上是一个插件，这是一个执行检索信息、评估信息、引发警报并提供有意义消息的代理人。单独看，Nagios不知道如何调用插件，传递哪些选项或如何处理它，因此我们需要一个命令定义，定义脚本将如何被调用。
- en: 'Let''s take as an example the command definition for the `ssh` service check,
    which is failing because the port used for the check is not the one the daemon
    is listening on:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`ssh`服务检查的命令定义为例，它失败是因为用于检查的端口与守护进程正在侦听的端口不同：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see here a command definition named `command_name check_ssh`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里有一个名为`command_name check_ssh`的命令定义。
- en: 'Let''s keep `check_ssh` in mind, because it will be the handle we will use
    to refer to this command definition later on. As we can see, this definition is
    really short; it defines a handle, and, most importantly, the command line to
    call the plugin. In this case, it is really easy: the plugin accepts the host
    address and that is enough for a basic check. Look at  `$HOSTADDRESS$`. This is
    one of the so-called **Nagios standard macros:** essentially a place holder, which
    will be instantiated by Nagios with the host address of the host you will associate
    the service making use of this command. Nothing complicated so far, let''s move
    onto the service definition, making use of this command definition:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住`check_ssh`，因为这将是我们稍后引用此命令定义时使用的句柄。正如我们所看到的，这个定义非常简短；它定义了一个句柄，最重要的是调用插件的命令行。在这种情况下，非常简单：插件接受主机地址就足够进行基本检查。看看`$HOSTADDRESS$`。这是所谓的**Nagios标准宏**之一：基本上是一个占位符，Nagios将会用主机地址实例化它，你将把这个服务关联到这个命令。
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `ssh` service definition introduces something new, and this is the inheritance
    of properties by the Nagios objects. As we discussed previously, the script carries
    out the checking, evaluation, and alarm raising; the core does all the rest, and
    lots of stuff. Looking at this service definition, it does not seem a lot, but
    focus on the first line named `use generic-service`. This rings a bell. Looking
    at the definition, it seems that `generic-service` is actually a template, doesn't
    it?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssh`服务定义引入了一些新的东西，这是通过Nagios对象继承属性的一个例子。正如我们之前讨论的，脚本执行检查、评估和引发警报；核心部分则完成其余所有工作，还有很多其他事情。看看这个服务定义，它似乎并不复杂，但是集中在第一行`use
    generic-service`上。这让人觉得耳熟能详。看看定义，似乎`generic-service`实际上是一个模板，是吗？'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Well, as we can see, there is a lot we can define service-wise, just so much
    to clutter a service definition so we hide the complexity in a template and recall
    it, like sourcing a library. Once the template is imported, all its definition
    will apply to the service that called it and if we want to modify some values
    from the template, we just write them in the service definition with the new values,
    because if we have multiple definitions with the same name and different values,
    the closest to the final object wins. So, a definition at the service level wins
    over a definition in the template. We will not explain all the definitions in
    the template, as they are not useful for our goal, since our script will rely
    on the generic service definition without any alterations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如我们所见，我们可以在服务方面定义很多内容，这些内容可能会让服务定义显得杂乱无章，所以我们将复杂性隐藏在模板中并调用它，就像引用一个库一样。一旦模板被导入，所有的定义都将应用到调用它的服务上。如果我们想修改模板中的某些值，我们只需在服务定义中写入新的值，因为如果我们有多个具有相同名称和不同值的定义，最终对象会选择最接近的那个。所以，服务层的定义会覆盖模板中的定义。我们不会解释模板中的所有定义，因为它们对我们的目标并没有帮助，毕竟我们的脚本将依赖于没有任何修改的通用服务定义。
- en: Let's go back to the service definition and have a look at the second line `host_name`
    localhost. We already mentioned the fact that each service check must refer to
    one (or more) host, so here is where we see what host this service applies to.
    We could also have used `hostgroup_name name_of_the_hostgroup`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到服务定义，看看第二行`host_name` localhost。我们已经提到过，每个服务检查必须引用一个（或多个）主机，所以在这里我们看到这个服务适用于哪个主机。我们也可以使用`hostgroup_name
    name_of_the_hostgroup`。
- en: 'To apply a single check to multiple hosts enclosed in a host group definition.
    Let''s move onto the `service_description` ssh. As for the command definition,
    this is the handle used to refer to this service definition throughout Nagios:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将单个检查应用于多个被包含在主机组定义中的主机。接下来看一下`service_description` ssh。至于命令定义，这是用来在Nagios中引用这个服务定义的标识符：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is where we call the command definition passing optional arguments. In
    our predefined configuration, there are no parameters to give to the command,
    so nothing special. With this line, the service definition recalls the syntax
    defined in the command definition called by the handled, and optionally passes
    some arguments to it. All the configurations for services, commands, hosts, and
    templates follow the same structure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们调用命令定义并传递可选参数的地方。在我们预定义的配置中，没有要传递给命令的参数，因此没有什么特别的。通过这行代码，服务定义调用了由处理器调用的命令定义中的语法，并可选地将一些参数传递给它。服务、命令、主机和模板的所有配置都遵循相同的结构：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can then have the different definitions on one files closed in their snippets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将不同的定义保存在一个文件中，并将它们封装在各自的代码块中。
- en: 'We just saw how the ssh check works in Nagios, but it actually does not work,
    since it throws us an error. What we would need is a way to change the port that
    the service is being checked on. How do we accomplish this task? By simply bearing
    in mind that the actual plugin is the star here, it will drive all our efforts,
    so let''s invoke it and see what it has to say. Let''s have a look at the command
    line definition:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的是Nagios中的ssh检查，但实际上它并不起作用，因为它抛出了一个错误。我们需要的是一种方法来更改正在检查的端口。我们该如何完成这项任务？只需记住，实际的插件才是这里的主角，它将推动我们的所有努力，所以让我们调用它，看看它有什么要说的。让我们看看命令行定义：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From here, we know where the script is, so let''s call it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们知道脚本的位置了，所以让我们调用它：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What we see here is that the script accepts some arguments and options on the
    command line, but each script is usually coded with a full help message invoked
    by a `-h` option:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是，脚本接受命令行上的一些参数和选项，但每个脚本通常都会编写一个完整的帮助信息，通过`-h`选项调用：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's keep in mind this help, because it is something we will have to implement
    in our plugin. Anyway, what we see, among other options is that we can actually
    change the port the service is being checked on using the option: `-p`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住这个帮助信息，因为它是我们需要在插件中实现的内容。无论如何，我们可以看到，除了其他选项外，我们实际上可以使用选项`-p`来更改服务正在检查的端口。
- en: 'Let''s check where our `ssh` server is listening for connections:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们的`ssh`服务器正在哪个地方监听连接：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we know that our `ssh` daemon is listening on port `1472`. So we have to
    make a manual check to be sure on how to invoke the plugin with the new parameters
    and values:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的`ssh`守护进程正在`1472`端口监听。所以我们需要手动检查，确保如何使用新的参数和值来调用插件：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It worked we processed `-H localhost` to identify which host we are executing
    our check against and `-p 1472` to query the correct port for this `ssh` daemon
    configuration. Now, let''s pay attention to the reply from the plugin:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它起作用了，我们处理了`-H localhost`来识别我们正在执行检查的主机，`-p 1472`用来查询该`ssh`守护进程配置的正确端口。现在，让我们关注插件的回复：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the standard structure of the message provided by a Nagios plugin:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Nagios插件提供的消息的标准结构：
- en: The name of the service (SSH).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务的名称（SSH）。
- en: Service status (OK).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务状态（OK）。
- en: Message given by the service being checked (or a message we crafted ourselves).
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被检查服务给出的消息（或者是我们自己构造的消息）。
- en: 'Then there is something we never saw before:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有一些我们之前没有见过的内容：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a pipe, followed by one or more labels, time in our example, and some
    values usually related to how the service is working. Whatever is written, it
    is not a Nagios concern, since it will not process this part of the output line.
    These values are there for third-party applications such as `pnp4nagios` or Nagios
    graph to process them and eventually draw out some performance graphics.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一条管道，后面跟着一个或多个标签，时间就是我们示例中的标签，还有一些通常与服务工作状态相关的值。无论写的是什么，这不是Nagios关心的，因为它不会处理输出行的这一部分。这些值是供第三方应用程序，如`pnp4nagios`或Nagios图形，来处理它们并最终绘制出一些性能图形。
- en: '![](img/00014.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: Nagios shows the performance data but does not really make use of it
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Nagios显示了性能数据，但并没有真正利用它
- en: 'We will see later how a graph for a service looks like, now let''s remember
    one thing: the output of a plugin is usually one line long and even though you
    have a multiline output, it is always better to stick to a simple message.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到服务的图形是什么样子的，现在让我们记住一件事：插件的输出通常是单行的，即使你有多行输出，最好也保持简洁的信息。
- en: 'Now, let''s go back to the definition of the SSH service check, and let''s
    see how to modify it to enable a different port check. This is the `check_ssh` command
    that we have already seen:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到SSH服务检查的定义，看看如何修改它以启用不同端口的检查。这就是我们之前见过的`check_ssh`命令：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To enable the definition of an arbitrary port check, we have to modify the
    `command_line` row so that it will accept the new `-p` parameter with an argument:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用任意端口检查的定义，我们必须修改`command_line`行，使其接受带有参数的新`-p`：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What we did is simple: we just added a `-p` followed by `$ARG1$`. What is this
    new bit? In Nagios, you can pass whatever arguments you want to a script, and
    you refer to them using a positional variable. Think of `$ARG1$` as  `$1` for
    a standard bash script; it identifies the first argument passed to the command
    line. Bear in mind that options like `-p` are not counted as arguments. So `$ARG2$`
    will be the second positional argument, `$ARG3$` the third, and so on. Do not
    forget the leading and trailing dollar signs. So, we modified the way Nagios can
    call the plugin, and now we can pass it an extra argument. What is left is to
    actually provide the extra argument to the script; this is done by modifying the
    service definition for `ssh`. We previously had this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的很简单：我们只是添加了一个`-p`后跟`$ARG1$`。这个新部分是什么？在Nagios中，你可以将任何你想要的参数传递给脚本，且通过位置变量来引用它们。把`$ARG1$`看作标准bash脚本中的`$1`；它表示传递给命令行的第一个参数。记住，像`-p`这样的选项不算作参数。所以`$ARG2$`是第二个位置参数，`$ARG3$`是第三个，以此类推。不要忘记前后的美元符号。所以，我们修改了Nagios调用插件的方式，现在我们可以给它传递一个额外的参数。剩下的就是实际将额外的参数提供给脚本；这是通过修改`ssh`的服务定义来完成的。我们之前有如下内容：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This definition must be modified so that we can store and pass the port number
    to the command, so this is how we do it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义必须修改，以便我们可以存储并传递端口号到命令中，下面是我们如何操作的：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The exclamation mark (`!`) after the command name is a standard field separator
    and identifies the different positional arguments passed to the plugin. Let''s
    make an example modifying the `command_line` of `ssh` to accept it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 命令名称后的感叹号（`!`）是标准字段分隔符，用于标识传递给插件的不同位置参数。让我们举个例子，修改`ssh`的`command_line`来接受它：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We must modify the command line to accept five parameters instead of one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须修改命令行，以接受五个参数而不是一个：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The modification is quite straightforward, we just wrote down all the switches
    and their arguments using the positional `$ARGn$` variables. Now that the command
    line is ready to accept the new values, we must fill in the placeholders:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 修改非常简单，我们只是用位置变量`$ARGn$`写下了所有开关及其参数。现在命令行已经准备好接受新值，我们必须填写占位符：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Not so complicated; each argument must be written in the order expected by
    the command line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 没那么复杂；每个参数必须按命令行预期的顺序书写：
- en: '| `-p` | `-` | `-P` | `-t` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `-p` | `-` | `-P` | `-t` |'
- en: '| `1472` | `4` | `2.0` | `30` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `1472` | `4` | `2.0` | `30` |'
- en: One thing to bear in mind is that the standard macros do not play a positional
    parameters so they do not have to be taken in to account when counting the slot
    indexes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，标准宏不使用位置参数，因此在计算插槽索引时不必考虑它们。
- en: 'Now that we have all the bits in order, with the right switches and values,
    we have to write our new configuration down. Okay, but where? The location of
    the configuration files differs from distribution to distribution and the way
    the files are fragmented too: some distributions have commands and service definitions
    inside a host file along with the host definition, some others have fragmented
    in single files. How do we deal with it? Let the Nagios process tell you how it
    reads the information:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经把所有部分都整理好了，具备了正确的开关和参数值，我们需要写下新的配置。好吧，但在哪里写？配置文件的位置因发行版而异，文件的碎片化方式也不同：有些发行版将命令和服务定义放在一个主机文件中连同主机定义一起，而其他发行版则将它们分散在单独的文件中。我们该如何处理呢？让Nagios进程告诉你它如何读取信息：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A `ps` command shows us that Nagios is reading its main configuration directives
    from`/etc/nagios3/nagios.cfg`. So, it is worth having a look at it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令显示Nagios从`/etc/nagios3/nagios.cfg`读取其主配置指令。因此，值得查看它：'
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a standard section in the Nagios main configuration file, and you will
    find it in each and every installation, so pay attention to the lines that are
    not commented out by a `#` character:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Nagios主配置文件中的标准部分，您会在每个安装中都找到它，因此请注意那些没有被`#`字符注释掉的行：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, from the main configuration file, we can see that the configurations are
    stored in one file and two directories. Since we are dealing with a command plugin
    modification, we start from `cfg_dir=/etc/nagios-plugins/config`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，从主配置文件中，我们可以看到配置存储在一个文件和两个目录中。由于我们处理的是命令插件修改，我们从`cfg_dir=/etc/nagios-plugins/config`开始。
- en: 'Looking for a file that cold bear an `ssh` configuration, let''s move to `root:~$
    cd /etc/nagios-plugins/config` and `grep` for `ssh` in each file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 查找可能包含`ssh`配置的文件，让我们进入`root:~$ cd /etc/nagios-plugins/config`并在每个文件中使用`grep`查找`ssh`：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just `egrep -l` will print only the names of the files where a match has been
    found; if you are not sure and want to see the actual matched line, use `-ir`
    instead of `-lr` , and you will see a lot more information. Anyway, between the
    two files, it seems pretty clear that the one we will have to modify is `ssh.cfg`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用`egrep -l`将仅打印出匹配项所在文件的名称；如果你不确定并希望查看实际的匹配行，请使用`-ir`而不是`-lr`，这样你将看到更多信息。无论如何，在这两个文件之间，似乎很清楚我们需要修改的是`ssh.cfg`。
- en: 'Let''s open it and go to the end of the file, adding our new command definition:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开文件并跳到文件末尾，添加我们的新命令定义：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As appears evident, we changed `command_name`; since there cannot be two command
    definitions with the same handle, we just chose something unique for our purposes.
    It will not be displayed to users, so it does not need to be fancy, just useful
    and meaningful. Let's save the file and proceed to define a new service configuration;
    from the main configuration file, it seems quite clear we have to look into `cfg_dir=/etc/nagios3/conf.d`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，我们更改了`command_name`；由于不能有两个相同句柄的命令定义，我们为我们的目的选择了一个独特的名称。它不会显示给用户，所以不需要华丽，只需要实用和有意义。我们保存文件并继续定义一个新的服务配置；从主配置文件中来看，似乎很清楚我们需要查看`cfg_dir=/etc/nagios3/conf.d`。
- en: 'So, let''s move to this directory: `root:~$ cd /etc/nagios3/conf.d`, and `grep`
    for `ssh` again:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们进入这个目录：`root:~$ cd /etc/nagios3/conf.d`，再次使用`grep`查找`ssh`：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, it is not clear what is bearing what, so an extended `grep` will
    be handy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，不清楚是什么包含了什么，所以使用扩展的`grep`命令会很有帮助：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, it is clear that `hostgroups_nagios.cfg` bears the configurations related
    to the host groups, and among those, the configuration of the group of hosts that
    are being checked for the `ssh` service. The second file, `services_nagios2.cfg`,
    holds the configuration for the ssh service check, so let''s open it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很明显`hostgroups_nagios.cfg`包含了与主机组相关的配置，其中包括检查`ssh`服务的主机组配置。第二个文件`services_nagios2.cfg`包含了`ssh`服务检查的配置，所以让我们打开它：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here is the `ssh` service check configuration we were looking for. In a production
    environment, we would have to estimate the impact of our configuration, since
    if we now modify this definition, it will apply to all the servers we are checking
    against. Notice `hostgroup_name ssh-servers`, we are checking a group of servers
    being this group populated by one or one thousand servers is not important.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们所寻找的`ssh`服务检查配置。在生产环境中，我们需要估算配置的影响，因为如果我们现在修改这个定义，它将应用于所有正在检查的服务器。请注意`hostgroup_name
    ssh-servers`，我们正在检查一个服务器组，无论这个组包含一个服务器还是一千个服务器，都不重要。
- en: 'In a production or a staging scenario, we would have to see which servers we
    are checking for the ssh service, understand if our modifications will have some
    odd effects on some of them, and if so, tear these servers out of the new check
    and create a special group for them using the old definition for them. In our
    case, since this is a demo installation and has `localhost` as the only group
    member, we can just modify the existing configuration and go with it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产或预演环境中，我们需要查看我们正在检查哪些服务器的ssh服务，了解我们的修改是否会对其中一些服务器产生异常影响，如果是的话，就将这些服务器从新的检查中移除，并为它们创建一个特殊的组，使用旧定义进行检查。在我们的例子中，由于这是一个演示安装，并且只有`localhost`作为唯一组成员，我们可以直接修改现有配置并继续使用：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This definition is quite similar to the one we crafted before; just here we
    are in a real scenario. Nagios is configured to apply this check on a hostgroup
    instead of a single server, but since the hostgroup is made by one server only,
    the localhost, the two definitions have the same scope. What we are left with
    is to force Nagios to reload the definitions so that our new configurations will
    be read by the core. A reload or restart will suffice:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义与我们之前制定的非常相似；只不过这里我们处于一个实际场景中。Nagios配置为在主机组上应用此检查，而不是单个服务器，但由于主机组只有一台服务器——本地主机，两个定义的作用范围相同。接下来我们需要做的是强制Nagios重新加载定义，以便我们的新配置能够被核心读取。重新加载或重启都足够：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now edit the `/etc/nagios3/nagios.cfg` file and enable the following configuration
    bit:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编辑`/etc/nagios3/nagios.cfg`文件并启用以下配置：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With `0` meaning disabled and `1` enabled, we just told Nagios to accept external
    command, so we can reload the configuration `service nagios3 reload`, go to the
    service name, and enter the server details page. Here we just have to click on Re-schedule
    the next check of this service.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`表示禁用，`1`表示启用，我们刚刚告诉Nagios接受外部命令，因此我们可以重新加载配置`service nagios3 reload`，进入服务名称，进入服务器详情页面。在这里，我们只需点击“重新安排该服务的下一个检查”。'
- en: Let's select Force check and commit; a new check will be forced whatever schedule
    is at play.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择强制检查并提交；无论当前调度如何，都会强制进行新检查。
- en: 'In the Debian and Ubuntu standard Nagios installation, you could face `Error:
    Could not stat() command file ''/var/lib/nagios3/rw/nagios.cmd''! `'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '在Debian和Ubuntu标准的Nagios安装中，你可能会遇到`Error: Could not stat() command file ''/var/lib/nagios3/rw/nagios.cmd''!`'
- en: 'When you try to force a check. You can solve it with the following procedure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试强制进行检查时，可以通过以下过程解决：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you face any issues with your plugin, enable `debug` mode in `/etc/nagios3/nagios.cfg` 
    by setting the following configuration bit:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的插件遇到任何问题，请在`/etc/nagios3/nagios.cfg`中启用`debug`模式，通过设置以下配置：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will generate a lot of information written in the `debug` file, which in
    our installation is in `/var/log/nagios3/nagios.debug` file, which is important
    to understand what is going on, but they will slow down the system a bit, so we
    must keep the debug on only for the time it is needed, then we must revert to
    the normal logging.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成大量信息写入`debug`文件，在我们的安装中，文件位于`/var/log/nagios3/nagios.debug`，这些信息对于理解发生了什么非常重要，但它们会稍微降低系统性能，因此我们必须仅在需要时启用调试，之后要恢复为正常日志记录。
- en: 'A Nagios reload will enforce the activation of the new configuration. But let''s
    have a look at what the debug log has to say about our new modified command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Nagios重新加载将强制激活新的配置。但让我们看看调试日志对我们修改后的命令有什么反馈：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is clear how Nagios builds up the command line piece by piece, so we can
    understand how it parses all our definitions and how it allocates the value we
    passed through the service definition itself. If we take the last row, copy and
    paste the command line of the final output, and execute it on the server, we are
    monitoring the service onto this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，Nagios是如何逐步构建命令行的，因此我们可以理解它如何解析我们的所有定义，以及如何分配我们通过服务定义传递的值。如果我们复制并粘贴最后一行的命令行输出，并在服务器上执行它，我们就可以开始监控这个服务：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We get the service checked, a status (OK), and performance data as well:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了服务检查，获得了一个状态（OK），以及性能数据：
- en: '![](img/00015.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: Our SSH service check now works and we have performance data too.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 SSH 服务检查已经正常工作，并且我们也有性能数据。
- en: 'Performance data is a useful bit of information that can give you some ready-made
    projections on service running pattern, once you plot it on a chart. With such
    data and charts we can do this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 性能数据是一些有用的信息，可以在图表上绘制后，为您提供一些现成的服务运行模式预测。有了这样的数据和图表，我们可以做到这一点：
- en: '**Adopt a service capacity management strategy**: Since we can easily forecast
    the consumption curve for a service, we can predict when it will be time to upgrade
    the hardware needed to provision it.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采用服务容量管理策略**：由于我们可以轻松预测服务的消耗曲线，因此我们可以预测何时需要升级所需的硬件。'
- en: '**Find out usage patterns**: A service can be used in a uneven pattern. For
    example, a company mail server is most used during office hours and less during
    the night or weekends; disk space for a data warehouse server is used more during
    the data consolidation batches than during other moments. So, a service that appears
    adequate while you are checking it can be under-equipped in other moments: a graph
    will show you how the usage curve moves over time.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**了解使用模式**：服务可能会以不均匀的模式使用。例如，公司的邮件服务器在办公时间使用最多，在夜间或周末使用较少；数据仓库服务器的磁盘空间在数据整合批处理期间使用更多。因此，当您检查服务时看起来合适，但在其他时刻可能是不足的：图表将显示您如何查看使用曲线随时间变化。'
- en: '**Find failures at a glance**: Watching at the gaps into the graph, you can
    easily spot service interruptions, and selecting the piece of graph you want to
    inspect can be exploded in detail.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一目了然地找到故障**：观察图表中的间隙，您可以轻松地发现服务中断，并且选择要检查的图表片段可以详细展开。'
- en: '**Create fancy reports for management**: Seems a joke but busy management prefers
    to have a comprehensive glance at services than pages and pages of numeric data.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为管理人员创建精美的报告**：看起来像是一个玩笑，但繁忙的管理人员更喜欢综合了解服务，而不是数页页的数值数据。'
- en: So, let's quickly see how to install one of this graphing tools. Since this
    is not a book on Nagios, we will not go into much detail, but we are going to
    see only what is needed to enable this third-party service and have our plugin
    performance data graphed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们快速看看如何安装其中一个图形工具。由于这不是关于 Nagios 的书籍，我们不会深入讲解，但我们将仅了解启用此第三方服务和使我们的插件性能数据图表化所需的内容。
- en: Let's start editing the `/etc/nagios3/nagios.cfg` file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编辑 `/etc/nagios3/nagios.cfg` 文件。
- en: 'Look for the following snippets of configuration and modify them so the final
    result will be this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 查找以下配置片段，并修改它们，以便最终结果将是这样：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We enabled the performance processing data and defined the name of the commands,
    which will deal with them; the next logical step is to define the commands we
    just pointed out. Edit the `/etc/nagios3/commands.cfg` file and add the following
    snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用了性能处理数据，并定义了处理它们的命令的名称；接下来的逻辑步骤是定义我们刚刚指出的命令。编辑 `/etc/nagios3/commands.cfg`
    文件，并添加以下片段：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We are working on a Debian installation, so the paths and file names may differ
    when using some other distribution or installing from sources.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在进行 Debian 安装，因此在使用其他发行版或从源安装时，路径和文件名可能会有所不同。
- en: Comment out any pre-existing snippets sporting `command_name process-host-perfdata`
    and `command_name process-service-perfdata`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何预先存在的片段标记为 `command_name process-host-perfdata` 和 `command_name process-service-perfdata`。
- en: 'We will use the new ones, as the old ones are useless for our purposes, so
    again comment them out. Now that we have the command in place and the data will
    be processed as intended, we have to tell Nagios how to trigger the chart visualization.
    So, time to edit `/etc/nagios3/conf.d/services_nagios2.cfg` and modify the previously
    edited ssh service check configuration so that now it appears as this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用新的内容，因为旧的对我们的目的无用，因此再次将它们注释掉。现在我们已经有了命令，并且数据将按预期处理，我们必须告诉 Nagios 如何触发图表可视化。因此，是时候编辑
    `/etc/nagios3/conf.d/services_nagios2.cfg` 并修改先前编辑的 SSH 服务检查配置，使其现在显示为：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We added an action URL configuration line so that Nagios will draw a small
    clickable icon close to the service name. So, let''s restart Nagios and go to
    the service page just to find out something new:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个操作 URL 配置行，以便 Nagios 在服务名称附近绘制一个小的可点击图标。因此，让我们重新启动 Nagios 并转到服务页面，看看有什么新发现：
- en: '![](img/00016.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: Adding the action_url string to any service configurations will make this new
    icon appear
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 向任何服务配置中添加`action_url`字符串将使这个新图标出现。
- en: 'The icon is clickable, so we just click it and the result is similar to the
    one in the next screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图标是可以点击的，我们只需点击它，结果类似于下一个截图所示：
- en: '![](img/00017.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: SSH service check performance data are now graphed
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: SSH服务检查的性能数据现在已经被绘制成图表。
- en: From now on, our performance data will be graphed, so our Nagios environment
    is ready to host our first Nagios plugin.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们的性能数据将被绘制成图表，因此我们的Nagios环境已经准备好承载我们的第一个Nagios插件。
- en: Our first Nagios plugin
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个Nagios插件
- en: It's time now to start working to our first Nagios plugin, and it does not really
    matter what we are going check here, since what we are interested in is how to
    deal with the exchange between Nagios and the plugin, more than how and what we
    are going to monitor. Once we are done with the script, we will be able to reuse
    its framework to create whatever script we want, so let's start.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始创建我们的第一个Nagios插件了，实际上我们要检查的内容并不重要，因为我们关心的是如何处理Nagios和插件之间的交换，而不是我们要监控什么或怎么监控。一旦我们完成了脚本，就可以重用它的框架来创建任何我们想要的脚本，所以让我们开始吧。
- en: Our project involves checking the status of the local disk using the **Self-Monitoring,
    Analysis, and Reporting Technology **(**S.M.A.R.T.**), which we can think of as
    a system embedded in most hard disks and solid state disks, whose task is to anticipate
    and prevent issues and failures. So, a plugin able to query the S.M.A.R.T. system
    can be used to trap some forthcoming failures, notify the user, and even take
    advantage of the response mechanism in Nagios to trigger some scripts or programs,
    for example copying all the data from the soon to fail disk to somewhere else
    before it get lost.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目涉及使用**自监控、分析和报告技术**（**S.M.A.R.T.**）检查本地磁盘的状态，我们可以把它看作是嵌入在大多数硬盘和固态硬盘中的系统，其任务是预测和防止问题和故障。因此，能够查询S.M.A.R.T.系统的插件可以用于捕捉即将发生的故障，通知用户，甚至可以利用Nagios中的响应机制触发一些脚本或程序，例如在磁盘即将故障之前将所有数据复制到其他地方，避免数据丢失。
- en: Our first step in this project will be installing the `smartmontools` package
    in our distribution. In Debian and Ubuntu, the package is called `smartmontools`;
    it can be different in other distribution. What we are looking for is a package
    holding the `smartctl` utility.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的第一步是安装`smartmontools`软件包。在Debian和Ubuntu中，软件包叫做`smartmontools`；在其他发行版中可能会不同。我们要找的是一个包含`smartctl`工具的软件包。
- en: 'This is the program our plugin will rely on, and it is the actual utility querying
    the for the disk information, so our first step will be to find which disks are
    attached to our system:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的插件将依赖的程序，它是实际查询磁盘信息的工具，因此我们第一步是找出哪些磁盘连接到了系统：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here we are; our system has one disk and its name is `sda`. If we want to find
    out something more about our disk, we can install `hwinfo` and run it as root:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的系统，它有一个磁盘，名称是`sda`。如果我们想了解更多关于磁盘的信息，可以安装`hwinfo`并以root身份运行它：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have been introduced to our disk, we have to see if it is polite
    enough to answer our S.M.A.R.T requests:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了我们的磁盘，现在我们需要看看它是否足够“有礼貌”来响应我们的S.M.A.R.T.请求：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That is a lot of information taken from you hard disk and, bottom line, most
    of it is useless to you. For the sake of our little project, we will take just
    a little information into account and this is here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这从硬盘中提取了大量信息，归根结底，大多数信息对你来说是**无用的**。为了我们的这个小项目，我们只会考虑一些信息，具体如下：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, our plugin will take just these three pieces of information into account
    with three different thresholds:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的插件将仅考虑这三项信息，并根据三个不同的阈值进行处理：
- en: '| **Control** | **OK** | **WARNING** | **CRITICAL** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **控制** | **正常** | **警告** | **危急** |'
- en: '| SMART overall-health self-assessment test result | PASSED |  | !CRITICAL
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| SMART整体健康自检测试结果 | 通过 |  | !危急 |'
- en: '| Temperature | 40: | @41:49 | :50 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 温度 | 40: | @41:49 | :50 |'
- en: '| Self-test execution status | 0 |  | !0 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 自检执行状态 | 0 |  | !0 |'
- en: We start planning our script. For the `overall-health`, we have an OK value,
    but no WARNING since whatever value we have different from `PASSED` means to us
    a critical situation. For the temperature, we can adjust the threshold to our
    working environment. Usually a value up to 40 degrees Celsius is considered optimal.
    From 41 to 50 is deemed acceptable, meaning it can cause some damage to the disk
    in the long run, so we are in a WARNING condition--not yet lethal, but we must
    keep an eye on it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始规划脚本。对于`overall-health`，我们有一个OK值，但没有WARNING，因为任何不同于`PASSED`的值对我们来说都意味着一个关键情况。对于温度，我们可以根据工作环境调整阈值。通常，温度高达40摄氏度被认为是最佳的。41到50摄氏度被认为是可接受的，这意味着从长远来看，可能会对磁盘造成一定损害，因此我们处于WARNING状态——还不致命，但我们必须保持关注。
- en: Everything from 50 Celsius and above is considered extremely dangerous to the
    health of your disk, so we shall trigger a CRITICAL condition and have someone
    to react as soon as possible. `Self-test execution status` tells us if the last
    self test on the drive was successful or completed with errors, and so anything
    other than 0 (successful) will trigger a critical condition.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从50摄氏度及以上被认为是极其危险的，会对磁盘健康造成威胁，因此我们应该触发CRITICAL状态，并且尽快让某人做出反应。`Self-test execution
    status`会告诉我们驱动器上的最后一次自检是否成功或有错误，因此任何不是0（成功）的状态都会触发一个关键状态。
- en: 'We identified the information that will trigger the status in Nagios; we planned
    our threshold, now before actually writing the plugin we need to find a way to
    reliably collect the data that will be evaluated against the threshold. Here some
    regular expressions will come in handy, so let''s start with the overall health,
    calling the  `smartcl` utility with a filter:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经识别出将触发Nagios状态的信息；我们规划了阈值，现在在实际编写插件之前，我们需要找到一种可靠的方式来收集将与阈值进行比较的数据。这里一些正则表达式会很有用，所以让我们从整体健康状态开始，调用`smartcl`工具并添加过滤器：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This simple one liner gets the full output from `smartctl`, then pipes it to
    the input of `grep`, which selects and outputs only the line containing the words
    `overall-health`. The output is finally passed to `awk`, which takes the input
    and divides it into columns, each field separated by blanks, and then prints out
    the sixth field, which shows `PASSED`. Then something like this would trap the
    result of the overall check:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的一行命令从`smartctl`获取完整的输出，然后将其传递给`grep`，后者选择并输出只包含`overall-health`字样的行。输出最终被传递给`awk`，它将输入拆分成列，每个字段由空格分隔，然后打印出第六个字段，即显示`PASSED`。类似如下的代码会捕捉到整体检查的结果：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In fact, we can double-check this with the following line:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以通过以下命令来再次验证：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That is, the command substitution got the output of the whole command line into
    the `H_CHECK` variable, and we could print it too.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，命令替换将整条命令行的输出放入了`H_CHECK`变量中，我们也可以打印出来。
- en: 'One recommendation here. When it comes to variables, you can use whatever notation
    you want, it is up to you, but bear in mind some rules of thumb:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个建议。当涉及到变量时，你可以使用任何你想要的表示方式，这取决于你，但请记住一些经验法则：
- en: '**Keep the variable name short and meaningful**:A variable name like `THIS_IS_THE.OVER-ALL.RESULT`
    will clutter your code, so `H_HEALTH` is compact and meaningful'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持变量名简短且有意义**：像`THIS_IS_THE.OVER-ALL.RESULT`这样的变量名会使代码变得混乱，所以`H_HEALTH`是简洁且有意义的。'
- en: '**Use lower, capital, or camelcase like `OverAllHealth`, but be consistent
    with your choice**:Stick to whatever you chose throughout your script, so it will
    be easier to identify variables in your code'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用小写、大写或驼峰式命名，如`OverAllHealth`，但要保持一致性**：在脚本中保持你选择的命名风格，这样更容易识别变量。'
- en: '**Do not use keywords, utility of built-in names, or anything reserved for
    your variable names**:It will make your script unreliable'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用关键字、工具函数或保留的名称作为变量名**：这会使你的脚本变得不可靠。'
- en: 'Now it is time to get the value of the temperature in our disk:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是获取我们磁盘温度值的时候了：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'So, let''s get this into a variable:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们将这个值存入一个变量：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we have to check for `Self-test execution status`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须检查`Self-test execution status`：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And trap the resulting value in a variable:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将结果值存入变量：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that we have a way to gather the information we want, it is time to put
    some boundaries on our investigations. What if the disk does not exist? What if
    it does not support S.M.A.R.T.? And our script will need to call `smartctl` as
    root, so we will get advantage of `sudo` to ease the process. So, let''s start
    with the first lines of the script, which holds the sha-bang, license, author,
    and first variables. Remember to change the code to whatever suits you:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了收集所需信息的方法，是时候为我们的调查设定一些边界了。如果磁盘不存在怎么办？如果它不支持 S.M.A.R.T. 呢？我们的脚本还需要以
    root 用户身份调用 `smartctl`，所以我们将利用 `sudo` 来简化这个过程。那么，让我们从脚本的前几行开始，这些行包含 sha-bang、许可证、作者和第一个变量。记得根据需要修改代码：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is the sha-bang and a licence with author, nothing special, so let''s
    move on:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 sha-bang 和一个包含作者的许可证，没什么特别的，所以我们继续：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Since the path for each utility we use the command substitution with which:
    this latter will give us back the path to the utility. The only drawback is that
    it will give no path if the utility is not in the `$PATH` environment of the user,
    but this is not a big deal except for `smartctl`, which is not in`$PATH` ; we
    just give the full path manually. We do not check `echo` command, since it is
    a built-in:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为每个工具的路径使用了命令替换 `which`，它会返回工具的路径。唯一的缺点是，如果工具不在用户的 `$PATH` 环境变量中，它不会返回路径，但这不是大问题，除了
    `smartctl`，它不在 `$PATH` 中；我们只需手动提供完整路径即可。我们不检查 `echo` 命令，因为它是内建的：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Who remembers the correct status codes returned by a Nagios plugin? Better
    have them stored in some handy variables:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 谁记得 Nagios 插件返回的正确状态码？最好将它们存储在一些方便的变量中：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, a bit of a caution. If the script does not receive a value for the WARNING
    and CRITICAL thresholds, it will be assigned automatically from a predefined value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一点需要注意。如果脚本没有接收到 WARNING 和 CRITICAL 阈值的值，它将从预定义的值中自动分配：
- en: 'Now that we have some headings in place, let''s check if our utilities are
    correctly pointed to by the variables:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些标题，让我们检查一下变量是否正确地指向了我们的工具：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is the first function of our script, and its job is quite straightforward:
    it checks if the path pointed by `#SMARTCTL` leads to a file; if not, it prints
    a WARNING message and exits with an error. In our prototype, we print a message
    even if the path is valid, but in the final stage, we will put a debug condition
    to activate or deactivate this kind of extra message, since Nagios does not accept
    such a message. We will also have a debug option that will make visible the inner
    computation of our script, if needed. Let''s test what''s done so far, making
    the script executable and running:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们脚本的第一个函数，它的任务相当简单：它检查 `#SMARTCTL` 指向的路径是否指向一个文件；如果没有，它会打印一个 WARNING 消息并以错误代码退出。在我们的原型中，即使路径有效，我们也会打印消息，但在最终阶段，我们会设置一个调试条件来启用或禁用这种额外的消息，因为
    Nagios 不接受此类消息。我们还将有一个调试选项，如果需要，它将显示我们脚本的内部计算过程。让我们测试一下到目前为止完成的部分，使脚本可执行并运行：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now let''s check adding two fake variables to the script:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在脚本中添加两个假变量进行检查：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now let''s check again:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再检查一次：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And then run the script again:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次运行脚本：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The script exits at the first variable that does not hold a correct path to
    a file, so let''s delete it, remove it from the function, and run the script again:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本会在遇到第一个没有正确指向文件路径的变量时退出，所以让我们删除它，移除它在函数中的引用，并再次运行脚本：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Again, the script exits at the first variable met that does not hold a path
    to a file with an error code; and we printed it on the standard out. This behavior
    suits us since we want the script to stop its execution if something prevents
    it from running correctly, and we want meaningful advice, so we can amend it using
    the hints it provides. We do not need fake variables anymore, so let's clear them
    out.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，脚本会在遇到第一个没有指向文件路径的变量时退出，并返回错误代码；我们将错误信息打印到标准输出。这种行为适合我们，因为我们希望脚本在遇到任何妨碍其正常运行的问题时停止执行，并提供有意义的建议，以便我们根据提示进行修正。我们不再需要假变量了，清除它们：
- en: 'Next, check whether the disk we are inspecting really exists, so let''s add
    some more stuff to our script. First, a variable to hold the path to the disk
    we want to monitor:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查我们正在检查的磁盘是否真实存在，所以让我们在脚本中再添加一些内容。首先，添加一个变量来保存我们想要监视的磁盘路径：
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, let''s check if the path we just specified leads to a real block device:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查一下我们刚刚指定的路径是否指向一个真实的块设备：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A simple file test on the path tells us whether this is a block device or not.
    Is it enough just to know if a path leads to a block device? No, because a disk
    is a block device, but a block device is not necessarily a disk, it can be a tape
    drive for instance. Anyway, we do not need a specific test looking for a disk,
    since the next function will check S.M.A.R.T. capabilities for the device. Only
    a S.M.A.R.T.-enabled hard disk will pass this test, and no other kinds of block
    device have this capability, so here we will sort out which is which. Before proceeding,
    let''s write a verbosity switch for our functions so that we will be able to print
    informative messages on `stdout`. Let''s start creating a variable, which will
    hold the status value for the verbosity switch:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对路径进行简单的文件测试可以告诉我们它是否是块设备。知道路径是否指向块设备就足够了吗？不，因为磁盘是块设备，但块设备不一定是磁盘，它可以是磁带驱动器，例如。无论如何，我们不需要专门查找磁盘的测试，因为下一个函数将检查设备的S.M.A.R.T.能力。只有启用了S.M.A.R.T.的硬盘才能通过此测试，其他类型的块设备没有此能力，因此在这里我们将区分出哪个是哪个。在继续之前，让我们为我们的函数编写一个详细模式开关，以便我们能够在`stdout`上打印信息性消息。让我们开始创建一个变量，它将保存详细模式开关的状态值：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And now, let''s rewrite the `path_exists` function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新编写`path_exists`函数：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Well, time to test the script:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，是时候测试脚本了：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: All the messages are printed out, but what happens if we change the value of
    verbosity to `0` like `VERB=${VERB:=0}`?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有消息都被打印出来了，但如果我们将详细模式的值更改为`0`，例如`VERB=${VERB:=0}`，会发生什么？
- en: 'Let''s call the script again:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次调用脚本：
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'All the messages from the `path_exists` function are now silenced. How did
    we do it? Simply using the the arithmetic `(( ))` operator, which returns true
    as exit status if it evaluates to a non-zero value. We used two different ways
    to manage the verbosity:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`path_exists`函数的消息现在都被静音了。我们是如何做到的？简单地使用算术`(( ))`运算符，如果它评估为非零值，则返回真作为退出状态。我们使用了两种不同的方式来管理详细模式：
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This compact notation has a smaller impact on the flow of our script and is
    prefered when we have to execute a short list of commands. In this case, if `$VERB`
    evaluates to not zero, a simple echo is executed, so this notation fits the case.
    When we have to execute a longer list of commands, we can choose a more readable
    notation:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种紧凑的表示法对我们脚本流程的影响较小，在必须执行短命令列表时更可取。在这种情况下，如果`$VERB`评估为非零，就会执行简单的echo，因此这种表示法适合这种情况。当我们必须执行更长命令列表时，我们可以选择更易读的表示法：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In this case, we can append more commands under the echo, and they all will
    be executed if `$VERB` evaluates to a non-zero value: cascading more commands
    on a list will make the code more readable and easy to maintain. But, well, the
    second verbose switch is not really useful because that part of the code traps
    an issue and comes into play when the path does not point to a file, and we always
    want to see an error message when we have an issue, regardless of the verbosity.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以在echo下附加更多命令，如果`$VERB`评估为非零值，则所有这些命令都将被执行：在列表上级联更多命令将使代码更易读和易于维护。但是，嗯，第二个详细模式开关并不是真正有用，因为代码的这部分会捕获一个问题，并在路径指向非文件时发挥作用，我们始终希望在出现问题时看到错误消息，无论详细程度如何。
- en: 'So, clear it out, as it was just an example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，清除它，因为它只是一个例子：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, let''s add the verbosity switch to the `disk_exists` function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`disk_exists`函数中添加详细模式开关：
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Notice (`:`) in the code. It is a placeholder for us to fill in with a S.M.A.R.T.
    capability checking code. As of now, if the path leads to a block device, the
    script does nothing (`:`). How do we check if a device is S.M.A.R.T. enabled?
    We can rely on the `smartctl` output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码中的（`:`）。这是一个占位符，我们将用S.M.A.R.T.能力检查代码填充进去。到目前为止，如果路径指向块设备，则脚本什么也不做（`:`）。如何检查设备是否启用S.M.A.R.T.？我们可以依赖于`smartctl`的输出：
- en: '[PRE70]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Great, the output of `smartctl` sports two lines, on one we have the info about
    whether the device has S.M.A.R.T. capability or not and the second informs us
    whether it is enabled or not.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，`smartctl`的输出包含两行，其中一行显示设备是否具有S.M.A.R.T.功能，第二行告诉我们它是否启用。
- en: 'Be wary while working with the output of a command: it can change upon different
    versions, so always check first the full output of the command itself before trying
    to trap some information.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理命令输出时要小心：它可能会根据不同版本而变化，因此在尝试捕获某些信息之前，始终先检查命令本身的完整输出。
- en: 'Once we know where to look, it is just a simple matter to trap the bits of
    information we want:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道在哪里查找，只需简单地捕获我们想要的信息：
- en: '[PRE71]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Cutting the output of `smartctl` and grabbing the content of the fourth field
    only gave us the two keywords we were looking for:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 截取 `smartctl` 的输出并仅抓取第四个字段的内容，成功得到了我们寻找的两个关键字：
- en: '[PRE72]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Both of them must be in the output for our check to pass, so let''s rewrite
    the first part of our script:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 它们必须都出现在输出中，才能让我们的检查通过，所以我们重新编写脚本的第一部分：
- en: '[PRE73]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We will make use of `awk` and `grep`, so we added them to a couple of handy
    variables. Notice that we are parsing the output of the utility (`smartctl`) and
    this can change in the future releases of the program, so we store in variables
    the fields we are working on. This way, if the output-related keywords change,
    we will modify them just once in our script. Now, just before the `disk_exists`
    function, we create a new code snippet:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `awk` 和 `grep`，所以我们将它们添加到一些方便的变量中。请注意，我们正在解析工具（`smartctl`）的输出，未来版本中这个输出可能会发生变化，因此我们将正在使用的字段存储在变量中。这样，如果输出相关的关键字发生变化，我们只需在脚本中修改一次。现在，就在
    `disk_exists` 函数之前，我们创建一个新的代码片段：
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We are just putting in a function that we did on the command line, but now,
    we store the output into an array. We start with simple constructs and check whether
    they work correctly. Once we are confident, we move to more complex solutions.
    Now, we must call the function with an argument; let''s do it at the end of the
    script:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在命令行中做的一个函数，现在，我们将输出存储到一个数组中。我们从简单的构造开始，检查它们是否正确工作。一旦我们有信心，就转向更复杂的解决方案。现在，我们必须带着一个参数调用这个函数；让我们把它放在脚本的最后：
- en: '[PRE75]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'So far, so good. Our script is grabbing the two keywords we were looking for.
    Now, we can go further and work on the keyword so that if they are not in the
    output of `smartctl`, our script will exit with an error; and we start adding
    something at the beginning of our script:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们的脚本正在获取我们寻找的两个关键字。现在，我们可以进一步处理这些关键字，以便如果它们不在 `smartctl` 的输出中，我们的脚本将退出并报错；然后我们在脚本的开头添加一些内容：
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `SMART_IND` array contains the keyword we need to trap to be sure we have
    a drive with S.M.A.R.T. capabilities, so now we have to craft our function to
    take an advantage of this new array:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`SMART_IND` 数组包含我们需要捕获的关键字，以确保我们有支持 S.M.A.R.T. 的硬盘，所以现在我们必须构建一个函数来利用这个新数组：'
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'So, basically we grep the output of `smartctl` on the `IS_SMART` value, then
    hold the results in the `IS_SMART` array. We have two nested loops: the outer
    cycles through the values of `IS_SMART` and the inner through the values of `SMART_IND`.
    Every time two indicators match, a counter is incremented. At the end of the loop,
    if the counter is not equal to the length of `SMART_IND`, we know that we could
    not match the exact number of indicators. In some cases, you will not have that
    nice smart support string, so we can use an alternative indicator to match, in
    case the first string is not shown:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们在 `smartctl` 的输出中使用 `grep` 查找 `IS_SMART` 值，然后将结果保存在 `IS_SMART` 数组中。我们有两个嵌套的循环：外循环遍历
    `IS_SMART` 的值，内循环遍历 `SMART_IND` 的值。每次两个指示符匹配时，计数器就会增加。在循环结束时，如果计数器不等于 `SMART_IND`
    的长度，我们就知道无法匹配到正确数量的指示符。在某些情况下，你可能没有那种漂亮的 SMART 支持字符串，所以我们可以使用一个替代指示符来匹配，以防第一个字符串未显示：
- en: '[PRE78]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Maybe less, maybe more, better to exit with an error and check.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更少，也可能更多，最好在检查时退出并报错。
- en: 'Now, let''s see what happens if we run this script on a system with a disk,
    which does not support SMART:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们在一个不支持 SMART 的系统上运行这个脚本会发生什么：
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Fair enough, when the script detects no SMART capabilities, it exits cleanly
    giving us a meaningful message. Now, since the smart check can be carried on only
    if there is a valid disk, we will call the `smart_enabled` function from inside
    the `disk_exists` function. So, let''s move the `smart_enabled` function call
    from the bottom of our script to the `disk_exists` function:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，当脚本检测到没有 SMART 能力时，它会干净地退出并给出有意义的消息。现在，由于只有在有有效硬盘的情况下才能进行 SMART 检查，我们将从 `disk_exists`
    函数内部调用 `smart_enabled` 函数。因此，我们将 `smart_enabled` 函数的调用从脚本的底部移到 `disk_exists` 函数中：
- en: '[PRE80]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: To be available inside the `disk_exists` function, the `smart_enable` function
    must be defined beforehand.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `disk_exists` 函数中可用，`smart_enable` 函数必须事先定义。
- en: 'We made a good amount of checks, now it is time to create our check function,
    which will deal with three different times of measurements:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了大量的检查，现在是时候创建我们的检查函数，它将处理三种不同的测量类型：
- en: Overall health
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体健康状况
- en: Temperature
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度
- en: Self-test
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自检
- en: 'So, our function must accept at least three parameters:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的函数必须接受至少三个参数：
- en: The type of check
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查的类型
- en: Warning threshold
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告阈值
- en: Critical threshold
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临界阈值
- en: 'Let''s start with something easy, implementing just the overall-check monitoring,
    starting with some new variables:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始，实现一个整体检查监控，从一些新的变量开始：
- en: '[PRE81]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Nothing really difficult, we just grep the output, put it into a variable,
    and see whether it matches our anchor (`PASSED`). If it does, the script exits
    with a `STATE_OK` value, and if not, it throws `STATE_CRITICAL`. Let''s have a
    look, but change the verbosity to `0` beforehand:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么难的，我们只需grep输出，将其放入变量中，并查看它是否匹配我们的锚点（`PASSED`）。如果匹配，脚本将以`STATE_OK`值退出，如果不匹配，它将抛出`STATE_CRITICAL`。让我们来看看，但事先将详细信息级别设置为`0`：
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is an acceptable plugin response, and if we passed this to Nagios, it
    would show a green OK field on the web UI, so we reached a milestone: we have
    our first good plugin reply. Now, since all the errors must be trapped by Nagios,
    let''s allocats `exit 1` with this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可接受的插件响应，如果我们将其传递给Nagios，它将在Web界面上显示一个绿色的“OK”字段，所以我们达到了一个里程碑：我们得到了第一个正确的插件回复。现在，由于所有错误必须由Nagios捕捉，我们来为这个分配`exit
    1`：
- en: '[PRE83]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'So, all the previous error message must now become optional like in the `path_exists()` function:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，所有之前的错误信息现在必须变为可选，就像在`path_exists()`函数中一样：
- en: '[PRE84]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We can see a slight change in the function; since we called `disk_exists` from
    inside `path_exists()`, we chained the functions so that when we have a successful
    outcome, we call the next function in a row.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到函数有了些许变化；由于我们在`path_exists()`内调用了`disk_exists`，我们将函数连接起来，以便在成功的结果后，调用下一个函数。
- en: 'Great, we have a function to check the `overall-health` parameter, and it also
    gives us a correct Nagios message and exit code; but this is one out of three
    possible checks, so we have to make this one element in our series. So, what should
    we do if we want to make this a part of a wider range of tests? Since these are
    three checks only, we can easily group them in a `if/then/elif/fi` construct,
    but let''s start with a new variable:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们有一个检查`overall-health`参数的函数，它还会给我们正确的Nagios消息和退出代码；但这只是三项检查中的一项，所以我们必须将其作为系列中的一个元素。那么，如果我们想将其纳入更广泛的测试范围，我们该怎么做呢？由于这只是三项检查，我们可以轻松地将它们分组在一个`if/then/elif/fi`结构中，但让我们从一个新的变量开始：
- en: '[PRE85]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This is a branch selector; if we do not specify anything, it will take the
    value of `HEALTH` and trigger one of the three checks; now let''s see the new
    code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个分支选择器；如果我们没有指定任何内容，它将默认选择`HEALTH`并触发三项检查中的一项；现在让我们看看新代码：
- en: '[PRE86]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The new code checks for how many arguments have been passed as input, if they
    are not exactly two, it throws an error and exit with  `STATE_UNKNOWN`. If we
    have two arguments, then it goes on checking if the first argument is a function
    selector and what its value. We filled in just the first function, created some
    placeholders for the other two, and got a catchall in case none of the acceptable
    values for a function selector have been entered.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码检查传递了多少个参数，如果不是恰好两个，它将抛出错误并以`STATE_UNKNOWN`退出。如果有两个参数，它接着检查第一个参数是否是一个函数选择器以及它的值。我们只填充了第一个函数，创建了其他两个的占位符，并在没有输入接受的函数选择器值时做了一个捕捉处理。
- en: 'We can now proceed with the self-check function, which is quite similar to
    the `overall-health`, but first some variables:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续实现自检功能，这与`overall-health`非常相似，但首先需要一些变量：
- en: '[PRE87]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You can already figure out what these are used for; we just to have to keep
    in mind we are using a lot of variable to customize the commands as much as we
    can, since we are working with a utility output, and this output can change from
    version to version. It usually stays quite the same over minor releases, but by
    using plenty of variable, we will be able to modify our script quickly if needed:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以弄清楚这些是用来做什么的；我们只需要记住，我们在尽可能多地自定义命令时，使用了很多变量，因为我们正在处理一个工具输出，而这个输出可能会在不同版本之间有所变化。它通常在小版本更新中保持相对一致，但通过使用大量变量，如果需要，我们可以快速修改脚本：
- en: '[PRE88]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We filled in our placeholder. This function is similar to the first one, the
    only real difference is the arithmetic evaluation performed and a check on the
    value to match and that must be a number. Calling the function with the `SELFCHECK`
    keyword will show us this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们填充了占位符。这个函数与第一个函数类似，唯一的实际区别是执行了算术评估，并检查值是否匹配且必须是数字。使用`SELFCHECK`关键字调用该函数时，显示如下：
- en: '[PRE89]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Great, now it is time for the last check, which is quite different from the
    other two, since it requires a check against some thresholds. We start with some
    variables as usual:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，现在是进行最后一次检查的时候了，这与其他两个检查有些不同，因为它需要与一些阈值进行比较。我们像往常一样从一些变量开始：
- en: '[PRE90]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And now we use the code itself:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用代码本身：
- en: '[PRE91]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This is a bit more complex than the other two checks. First, we check that
    the value of `WARNING_THRESHOLD` is lower than `CRITICAL_THRESHOLD`; and we do
    it using a small command line calculator and an arithmetic evaluation. Then, we
    check that `T_CHECK` holds a numeric value since we are talking about degrees Celsius (the
    hard disk temperature is commonly reported in Celsius). Once we are free from
    such hindrances, we can proceed to check the value of `T_CHECK` against the threshold in
    the following way:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这比另外两个检查要复杂一些。首先，我们检查`WARNING_THRESHOLD`的值是否低于`CRITICAL_THRESHOLD`；我们使用一个小的命令行计算器和算术运算来完成这个检查。接着，我们检查`T_CHECK`是否是一个数值，因为我们讨论的是摄氏度（硬盘温度通常以摄氏度报告）。一旦我们消除了这些障碍，就可以按以下方式检查`T_CHECK`的值是否符合阈值：
- en: '[PRE92]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let''s test the script with different values for the WARNING and CRITICAL thresholds:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下这个脚本，使用不同的WARNING和CRITICAL阈值：
- en: '[PRE93]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'As we can see, our thresholds are set pretty well and the same is for the precedence
    of values, so we are quite fine. Notice the performance data; since this is a
    temperature indicator, we can later have it plotted on Nagios if we wish. The
    last step here is to create a command line parser to get all the required values:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的阈值设置得相当合理，值的优先级也是一样的，所以我们很好。注意性能数据；由于这是一个温度指示器，如果我们愿意，之后可以在Nagios中将其绘制出来。这里的最后一步是创建一个命令行解析器来获取所有需要的值：
- en: '[PRE94]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We started with the print usage. In case the user does input some wrong options,
    we give them a hint of what to do:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从打印用法开始。如果用户输入了一些错误的选项，我们给出提示该怎么做：
- en: '[PRE95]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Nice, isn''t it? But how do we call that function and manage the input? Let''s
    see:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，是不是？但是我们怎么调用那个函数并管理输入呢？让我们看看：
- en: '[PRE96]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: What do we do in this block? While the number of arguments on the command line
    is higher than zero, we parse the command line itself, and check the options using
    the case construct. Every time we match a value, we instantiate a variable and
    shift the command line, so we are ready to process the next option; this is our
    command line parser.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个代码块中做了什么？当命令行上的参数数量大于零时，我们解析命令行本身，并使用case结构检查选项。每次匹配到一个值时，我们实例化一个变量并移动命令行，这样就准备好处理下一个选项了；这就是我们的命令行解析器。
- en: 'Now that our plugin is ready to serve our purposes, we have to copy it to the
    plugins directory `root:~$ cp check_my_smart.sh /usr/lib/nagios/plugins/`; now
    let''s check the ownership and access right to it. The one shown here should suffice:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的插件准备好为我们的目的服务了，我们必须将它复制到插件目录`root:~$ cp check_my_smart.sh /usr/lib/nagios/plugins/`；现在让我们检查它的所有权和访问权限。这里显示的应该就足够了：
- en: '[PRE97]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Once the script is in place, we have to tell Nagios how to call it, so a command
    definition is needed. Let''s move to the command configurations directory `cd
    /etc/nagios-plugins/config/` and create the `check_my_smart.cfg` file with the
    following content:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本到位，我们必须告诉Nagios如何调用它，因此需要一个命令定义。让我们进入命令配置目录`cd /etc/nagios-plugins/config/`并创建`check_my_smart.cfg`文件，内容如下：
- en: '[PRE98]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We won't repeat it, but always check for the user access rights on files. If
    you are not confident about which rights to use, look at the similar files in
    the directory you are working on. But be aware of what you concede.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重复这一点，但始终要检查文件的用户访问权限。如果你不确定应该使用什么权限，可以查看你正在工作的目录中的类似文件。但要注意你所赋予的权限。
- en: 'We are going to use `sudo` since the `smartctl` utility needs the root privileges
    to access disk information. The disk and module options must be given on the service
    configuration, but the WARNING and CRITICAL values are optional. Time to modify `/etc/sudoers`
    and add the following line:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`sudo`，因为`smartctl`工具需要root权限才能访问磁盘信息。磁盘和模块选项必须在服务配置中给出，但WARNING和CRITICAL值是可选的。现在是时候修改`/etc/sudoers`并添加以下行：
- en: '[PRE99]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'So, the Nagios user now is able to call the `smartctl` utility as root without
    being asked for any passwords. This, though, requires a little change in our script:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在Nagios用户可以作为root用户调用`smartctl`工具，而不需要输入任何密码。不过，这需要我们在脚本中做一点修改：
- en: '[PRE100]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This will enable our script to call `smartctl` as the root user. A little homework:
    try to trap and deal with the chance we did not enable `sudo` for the Nagios user.
    How would your manage this problem? Let''s move on and write our services definitions
    in `/etc/nagios3/conf.d/localhost_nagios2.cfg`, and add the following lines:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的脚本能够以root用户身份调用`smartctl`。稍微做点功课：尝试捕获并处理没有为Nagios用户启用`sudo`的情况。你会如何解决这个问题？我们继续前进，写出我们的服务定义到`/etc/nagios3/conf.d/localhost_nagios2.cfg`，并添加以下行：
- en: '[PRE101]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We configured three new service checks, but only one needs an `action_url` ,
    as only the temperature check gives us some values that change over time and can
    be usefully graphed. Now, all that is left is to restart Nagios using `service
    nagios3 restart` and check whether everything is fine, as we can see in the following
    screenshot:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了三个新的服务检查，但只有一个需要 `action_url`，因为只有温度检查会提供随时间变化的值，并且可以有效地绘制成图表。现在，剩下的就是使用
    `service nagios3 restart` 重启 Nagios 并检查一切是否正常，正如我们在下面的截图中看到的那样：
- en: '![](img/00018.jpeg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: Our new three checks are online and the disk seems a bit overheated.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的三个检查功能已上线，磁盘似乎有些过热。
- en: 'Let''s just check whether our temperature check is producing some performance
    data and it is being graphed:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下温度检测是否生成了一些性能数据，并且是否已经被绘制成图表：
- en: '![](img/00019.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: We are keeping an eye on the temperature, thanks to our new graph.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们的新图表，我们正密切关注温度。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We just saw how to handle a problem in a real scenario by analyzing our goal,
    planning the methods and tools we needed to accomplish it, and taking care of
    the issues on the path to our solution. We worked on our outcome in small steps,
    consecutive and joined all the bits once ready, so we did not face a cumbersome
    whole big problem, but solved what we encountered at each step by learning how
    to proceed and avoid overthinking. Now, we are ready to proceed and work on something
    quite useful nowadays: our personal Slack poster utility.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到如何通过分析目标、规划所需的方法和工具，并解决实现过程中遇到的问题，来处理现实场景中的一个问题。我们通过小步骤、连续进行的方式处理了我们的结果，并在准备好时将所有部分结合在一起，因此我们没有面对一个庞大的复杂问题，而是在每个步骤中解决了遇到的具体问题，通过学习如何继续前进并避免过度思考。现在，我们准备继续并开展一些现代社会中非常有用的工作：我们的个人
    Slack 海报工具。
