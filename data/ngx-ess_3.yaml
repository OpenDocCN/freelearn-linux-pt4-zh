- en: Chapter 3. Proxying and Caching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：代理与缓存
- en: Designed as a web accelerator and a frontend server, Nginx has powerful tools
    to delegate complex tasks to upstream servers while focusing on heavy lifting.
    Reverse proxy is one such tool that turns Nginx into an essential component of
    any high-performance web service.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 作为 Web 加速器和前端服务器设计，拥有强大的工具，可以将复杂的任务委托给上游服务器，同时专注于繁重的工作。反向代理就是其中一个工具，它使
    Nginx 成为任何高性能 Web 服务的重要组成部分。
- en: By abstracting away complexities of HTTP and handling them in a scalable and
    efficient manner, Nginx allows web applications to focus on solving the problem
    they are designed to solve without stumbling upon low-level details.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过抽象化 HTTP 的复杂性并以可扩展和高效的方式处理，Nginx 使 Web 应用能够专注于解决它们被设计来解决的问题，而不会陷入底层细节。
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: How to set up Nginx as a reverse proxy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将 Nginx 设置为反向代理
- en: How to make proxying transparent for the upstream server and the end user
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让代理对上游服务器和最终用户透明
- en: How to handle upstream errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理上游错误
- en: How to use Nginx cache
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Nginx 缓存
- en: You will find out how to use all features of Nginx reverse proxy and turn it
    into a powerful tool for accelerating and scaling your web service.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解到如何使用 Nginx 反向代理的所有功能，并将其转变为一个强大的加速和扩展 Web 服务的工具。
- en: Nginx as a reverse proxy
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nginx 作为反向代理
- en: HTTP is a complex protocol that deals with data of different modality and has
    numerous optimizations that—if implemented properly—can lead to a significant
    increase in web service performance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是一个复杂的协议，处理不同模态的数据，并具有许多优化，如果实施得当，可以显著提高 Web 服务的性能。
- en: At the same time, web application developers have less time to deal with low-level
    issues and optimizations. The mere idea of decoupling a web application server
    from a frontend server shifts the focus on managing incoming traffic to the frontend,
    while shifting the focus on functionality, application logic, and features to
    the web application server. This is where Nginx comes into play as a decoupling
    point.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Web 应用开发人员可以减少处理底层问题和优化的时间。将 Web 应用服务器与前端服务器解耦的这一概念，将重点从管理前端的传入流量转移到 Web
    应用服务器上的功能、应用逻辑和特性。这正是 Nginx 作为解耦点发挥作用的地方。
- en: 'An example of a decoupling point is SSL termination: Nginx receives and processes
    inbound SSL connections, it forwards the request over plain HTTP to an application
    server, and wraps the received response back into SSL. The application server
    no longer needs to take care of storing certificates, SSL sessions, handling encrypted
    and unencrypted transmission, and so on.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦的一个例子是 SSL 终止：Nginx 接收并处理传入的 SSL 连接，将请求通过普通的 HTTP 转发到应用服务器，并将接收到的响应重新封装为 SSL。应用服务器不再需要处理证书存储、SSL
    会话、加密和未加密传输等问题。
- en: 'Other examples of decoupling are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其他解耦的例子如下：
- en: Efficient handling of static files and delegating the dynamic part to the upstream
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效处理静态文件并将动态部分委托给上游
- en: Rate, request, and connection limiting
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制速率、请求和连接
- en: Compressing responses from the upstream
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩来自上游的响应
- en: Caching responses from the upstream
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存来自上游的响应
- en: Accelerating uploads and downloads
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速上传和下载
- en: By shifting these functions to a Nginx-powered frontend, you are essentially
    investing in the reliability of your website.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些功能转移到由 Nginx 提供支持的前端，您实际上是在投资于您网站的可靠性。
- en: Setting up Nginx as a reverse proxy
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Nginx 作为反向代理
- en: 'Nginx can be easily configured to work as a reverse proxy:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 可以轻松配置为反向代理：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, `upstream_server_name` is the host name of the upstream
    server. When a request for location is received, it will be passed to the upstream
    server with a specified host name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`upstream_server_name` 是上游服务器的主机名。当收到某个位置的请求时，它会被传递到具有指定主机名的上游服务器。
- en: 'If the upstream server does not have a host name, an IP address can be used
    instead:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上游服务器没有主机名，可以使用 IP 地址代替：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the upstream server is listening on a nonstandard port, the port can be
    added to the destination URL:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上游服务器监听非标准端口，可以将端口添加到目标 URL 中：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The destination URL in the preceding examples does not have a path. This makes
    Nginx pass the request as is, without rewriting the path in the original request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的目标 URL 没有路径。这使得 Nginx 按原样转发请求，而不重新写入原始请求中的路径。
- en: 'If a path is specified in the destination URL, it will replace a part of the
    path from the original request that corresponds to the matching part of the location.
    For example, consider the following configuration:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标 URL 中指定了路径，它将替换掉原始请求中与位置匹配部分对应的路径。例如，考虑以下配置：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If a request for `/download/BigFile.zip` is received, the path in the destination
    URL is `/media` and it corresponds to the matching `/download` part of the original
    request URI. This part will be replaced with `/media` before passing to the upstream
    server, so the passed request path will look like `/media/BigFile.zip`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到对 `/download/BigFile.zip` 的请求，目标 URL 中的路径是 `/media`，它对应原始请求 URI 中的 `/download`
    部分。这个部分会在传递到上游服务器之前被替换成 `/media`，因此传递的请求路径看起来像 `/media/BigFile.zip`。
- en: 'If `proxy_pass` directive is used inside a regex location, the matching part
    cannot be computed. In this case, a destination URI without a path must be used:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `proxy_pass` 指令被用在正则表达式位置内，匹配的部分将无法计算。在这种情况下，必须使用没有路径的目标 URI：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The same applies to cases where the request path was changed with the rewrite
    directive and is used by a `proxy_pass` directive.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则适用于请求路径通过 rewrite 指令改变并被 `proxy_pass` 指令使用的情况。
- en: 'Variables can be a part of the destination URL as well:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以是目标 URL 的一部分：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In fact, any part or even the whole destination URL can be specified by a variable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，任何部分，甚至整个目标 URL 都可以通过变量来指定：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This gives enough flexibility in specifying the destination URL for the upstream
    server. In [Chapter 5](ch05.html "Chapter 5. Managing Inbound and Outbound Traffic"),
    *Managing Inbound and Outbound Traffic*, we will find out how to specify multiple
    servers as an upstream and distribute connections among them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这为指定上游服务器的目标 URL 提供了足够的灵活性。在[第 5 章](ch05.html "第 5 章：管理入站和出站流量")，*管理入站和出站流量*中，我们将了解如何指定多个服务器作为上游并在它们之间分配连接。
- en: Setting the backend the right way
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确设置后端
- en: The right way to configure a backend is to avoid passing everything to it. Nginx
    has powerful configuration directives that help you ensure that only specific
    requests are delegated to the backend.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正确配置后端的方法是避免将所有内容都传递给它。Nginx 提供了强大的配置指令，帮助确保只有特定的请求被委托给后端。
- en: 'Consider the following configuration:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下配置：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This passes every request with a URI that ends with `.php` to the PHP interpreter.
    This is not only inefficient due to the intensive use of regular expressions,
    but also a serious security issue on most PHP setups because it may allow arbitrary
    code execution by an attacker.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将每个以 `.php` 结尾的 URI 请求传递给 PHP 解释器。这不仅由于正则表达式的广泛使用而效率低下，而且在大多数 PHP 设置中还是一个严重的安全问题，因为它可能允许攻击者执行任意代码。
- en: 'Nginx has an elegant solution for this problem in the form of the `try_files`
    directive. The `try_files` directive takes a list of files and a location as the
    last argument. Nginx tries specified files in consecutive order and if none of
    them exists, it makes an internal redirect to the specified location. Consider
    the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 对此问题提供了一个优雅的解决方案，即 `try_files` 指令。`try_files` 指令接受一个文件列表和一个作为最后参数的路径位置。Nginx
    按顺序尝试指定的文件，如果都不存在，则进行内部重定向到指定的位置。请看下面的示例：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding configuration first looks up a file corresponding to the request
    URI, looks for a directory corresponding to the request URI in the hope of returning
    an index of that directory, and finally makes an internal redirect to the named
    location `@proxy` if none of these files or directories exist.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置首先查找与请求 URI 对应的文件，接着查找与请求 URI 对应的目录，希望返回该目录的索引；如果这些文件或目录都不存在，最后会进行内部重定向到指定的名为
    `@proxy` 的位置。
- en: This configuration makes sure that whenever a request URI points to an object
    in the filesystem it is handled by Nginx itself using efficient file operations,
    and only if there is no match in the filesystem for the given request URI is it
    delegated to the backend.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置确保了每当请求 URI 指向文件系统中的对象时，它将由 Nginx 自行处理，使用高效的文件操作；只有当文件系统中没有匹配的请求 URI 时，才会委托给后端。
- en: Adding transparency
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加透明度
- en: Once forwarded to an upstream server, a request loses certain properties of
    the original request. For example, the virtual host in a forwarded request is
    replaced by the host/port combination of the destination URL. The forwarded request
    is received from an IP address of the Nginx proxy, and the upstream server's functionality
    based on the client's IP address might not function properly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求被转发到上游服务器，原始请求的某些属性会丢失。例如，转发请求中的虚拟主机将被目标 URL 的主机/端口组合替代。转发请求是从 Nginx 代理的
    IP 地址接收的，而上游服务器基于客户端的 IP 地址的功能可能无法正常工作。
- en: 'The forwarded request needs to be adjusted so that the upstream server can
    obtain the missing information of the original request. This can be easily done
    with the `proxy_set_header` directive:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 转发请求需要进行调整，以便上游服务器能够获取原始请求缺失的信息。这可以通过 `proxy_set_header` 指令轻松实现：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `proxy_set_header` directive takes two arguments, the first of which is
    the name of the header that you want to set in the proxied request, and the second
    is the value for this header. Again, both arguments can contain variables.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy_set_header` 指令接受两个参数，第一个是你希望在代理请求中设置的头部名称，第二个是该头部的值。同样，这两个参数都可以包含变量。'
- en: 'Here is how you can pass the virtual host name from the original request:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何从原始请求中传递虚拟主机名的方法：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The variable `$host` has a smart functionality. It does not simply pass the
    virtual host name from the original request, but uses the name of the server the
    request is processed by if the host header of the original request is empty or
    missing. If you insist on using the bare virtual host name from the original request,
    you can use the `$http_host` variable instead of `$host`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `$host` 具有智能功能。它不仅仅传递原始请求中的虚拟主机名，还会在原始请求的主机头为空或缺失时，使用处理请求的服务器的名称。如果你坚持要使用原始请求中的虚拟主机名，可以使用
    `$http_host` 变量，而不是 `$host`。
- en: 'Now that you know how to manipulate the proxied request, we can let the upstream
    server know the IP address of the original client. This can be done by setting
    `X-Real-IP` and/or the `X-Forwarded-For` headers:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何操作代理请求，我们可以让上游服务器了解原始客户端的 IP 地址。这可以通过设置 `X-Real-IP` 和/或 `X-Forwarded-For`
    头部来实现：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will make the upstream server aware of the original client's IP address
    via `X-Real-IP` or the `X-Forwarded-For` header. Most application servers support
    this header and take appropriate actions to properly reflect the original IP address
    in their API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，上游服务器就能通过 `X-Real-IP` 或 `X-Forwarded-For` 头部了解到原始客户端的 IP 地址。大多数应用服务器支持该头部，并采取适当的措施以正确反映原始
    IP 地址。
- en: Handling redirects
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理重定向
- en: The next challenge is rewriting redirects. When the upstream server issues a
    temporary or permanent redirect (HTTP status codes `301` or `302`), the absolute
    URI in the location or refresh headers needs to be rewritten so that it contains
    a proper host name (the host name of the server the original request came to).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个挑战是重写重定向。当上游服务器发出临时或永久重定向（HTTP 状态码 `301` 或 `302`）时，位置或刷新头部中的绝对 URI 需要被重写，以便它包含正确的主机名（即原始请求所到达的服务器的主机名）。
- en: 'This can be done using the `proxy_redirect` directive:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 `proxy_redirect` 指令来实现：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Consider a web application that is running at `http://localhost:8080/app`, while
    the original server has the address `http://www.example.com`. Assume the web application
    issues a temporary redirect (HTTP 302) to `http://localhost:8080/app/login`. With
    the preceding configuration, Nginx will rewrite the URI in the location header
    to `http://www.example.com/login`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个运行在 `http://localhost:8080/app` 的 Web 应用程序，而原始服务器的地址是 `http://www.example.com`。假设
    Web 应用程序发出了一个临时重定向（HTTP 302）到 `http://localhost:8080/app/login`。使用前述配置，Nginx 将会将位置头部中的
    URI 重写为 `http://www.example.com/login`。
- en: If the redirect URI was not rewritten, the client would be redirected to `http://localhost:8080/app/login`,
    which is valid only within a local domain, so the web application would not be
    able to work properly. With the `proxy_redirect` directive, the redirect URI will
    be properly rewritten by Nginx, and the web application will be able to perform
    the redirect properly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重定向 URI 没有被重写，客户端将被重定向到 `http://localhost:8080/app/login`，这个地址只在本地域名下有效，因此
    Web 应用程序无法正常工作。使用 `proxy_redirect` 指令后，重定向 URI 将被 Nginx 正确重写，Web 应用程序将能够正确地进行重定向。
- en: 'The host name in the second argument of the `proxy_redirect` directive can
    be omitted:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy_redirect` 指令的第二个参数中的主机名可以省略：'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code can be further reduced to the following configuration using
    variables:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量，前面的代码可以进一步简化为以下配置：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The same transparency option can be applied to cookies. In the preceding example,
    consider cookies are set to the domain `localhost:8080`, since the application
    server replies at `http://localhost:8080`. The cookies will not be returned by
    the browser, because the cookie domain does not match the request domain.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的透明度选项也可以应用于 cookies。在前面的示例中，假设 cookies 被设置为 `localhost:8080` 域名，因为应用服务器在
    `http://localhost:8080` 上响应。由于 cookie 域名与请求域名不匹配，浏览器将不会返回这些 cookies。
- en: Handling cookies
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 cookies
- en: 'To make cookies work properly, the domain name in cookies needs to be rewritten
    by the Nginx proxy. To do this, you can use the `proxy_cookie_domain` directive
    as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 cookies 正常工作，cookie 中的域名需要通过 Nginx 代理进行重写。为此，您可以使用如下所示的 `proxy_cookie_domain`
    指令：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, Nginx replaces the cookie domain `localhost:8080`
    in the upstream response with `www.example.com`. The cookies set by the upstream
    server will refer to the domain `www.example.com` and the browser will return
    cookies in subsequent requests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，Nginx 将上游响应中的 cookie 域名 `localhost:8080` 替换为 `www.example.com`。上游服务器设置的
    cookies 将指向 `www.example.com` 域名，浏览器将在后续请求中返回这些 cookies。
- en: 'If cookie path needs to be rewritten as well due to application server being
    rooted at a different path, you can use the `proxy_cookie_path` directive as shown
    in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于应用服务器位于不同路径，需要重写 cookie 路径，可以使用 `proxy_cookie_path` 指令，如以下代码所示：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, whenever Nginx detects a cookie with a prefix specified in
    the first argument of the `proxy_cookie_path` directive (`/my_webapp/`), it replaces
    this prefix with the value in the second argument of the `proxy_cookie_path` directive
    (`/`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，每当 Nginx 检测到一个具有在 `proxy_cookie_path` 指令第一个参数中指定的前缀 (`/my_webapp/`) 的
    cookie 时，它会将这个前缀替换为 `proxy_cookie_path` 指令第二个参数中的值 (`/`)。
- en: 'Putting everything together for the `www.example.com` domain and the web application
    running at `localhost:8080`, we get the following configuration:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起，对于 `www.example.com` 域名和运行在 `localhost:8080` 的 Web 应用，我们可以得到以下配置：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding configuration ensures transparency for a web application server
    so that it doesn't even need to know which virtual host it is running on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置确保了 Web 应用服务器的透明性，使其无需知道自己运行在哪个虚拟主机上。
- en: Using SSL
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SSL
- en: 'If the upstream server supports SSL, connections to the upstream server can
    be secured by simply changing the destination URL scheme to `https`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上游服务器支持 SSL，只需将目标 URL 的协议更改为 `https`，即可安全连接到上游服务器：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the authenticity of the upstream server needs to be verified, this can be
    enabled using the `proxy_ssl_verify` directive:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要验证上游服务器的真实性，可以通过 `proxy_ssl_verify` 指令启用此功能：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The certificate of the upstream server will be verified against certificates
    of well-known certification authorities. In Unix-like operating systems, they
    are usually stored in `/etc/ssl/certs`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上游服务器的证书将与知名认证机构的证书进行验证。在类 Unix 操作系统中，它们通常存储在 `/etc/ssl/certs` 中。
- en: 'If an upstream uses a trusted certificate that cannot be verified by well-known
    certification authorities or a self-signed certificate, it can be specified and
    declared as trusted using the `proxy_ssl_trusted_certificate` directive. This
    directive specifies the path to the certificate of the upstream server or a certificate
    chain required to authenticate the upstream server in PEM format. Consider the
    following example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上游使用的证书无法通过知名认证机构验证，或是自签名证书，可以使用 `proxy_ssl_trusted_certificate` 指令指定并声明其为受信任的证书。此指令指定上游服务器证书的路径，或
    PEM 格式认证上游服务器所需的证书链。参考以下示例：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If Nginx needs to authenticate itself to the upstream server, the client certificate
    and the key can be specified using the `proxy_ssl_certificate` and `proxy_ssl_certificate_key`
    directives. The directive `proxy_ssl_certificate` specifies the path to the client
    certificate in PEM format, while `proxy_ssl_certificate_key` specifies the path
    to the private key from the client certificate in PEM format. Consider the following
    example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Nginx 需要对上游服务器进行身份验证，可以使用 `proxy_ssl_certificate` 和 `proxy_ssl_certificate_key`
    指令来指定客户端证书和密钥。`proxy_ssl_certificate` 指令指定 PEM 格式的客户端证书路径，而 `proxy_ssl_certificate_key`
    指令指定 PEM 格式的客户端证书私钥路径。参考以下示例：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The specified certificate will be presented while setting up the secure connection
    to the upstream server, and its authenticity will be verified by specified private
    key.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立与上游服务器的安全连接时，将使用指定的证书，并通过指定的私钥验证其真实性。
- en: Handling errors
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: If Nginx experiences a problem contacting the upstream server or the upstream
    server returns an error, there is an option to take certain actions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Nginx 在与上游服务器通信时遇到问题，或上游服务器返回错误，则可以选择采取某些操作。
- en: 'The upstream server connectivity errors can be handled using the `error_page`
    directive:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上游服务器连接错误可以通过`error_page`指令进行处理：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will make Nginx return the document from the file `50x.html` once an upstream
    connectivity error has occurred.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 Nginx 在发生上游连接错误时，从文件`50x.html`返回文档。
- en: 'This will not change the HTTP status code in the response. To change the HTTP
    status code to successful, you can use the following syntax:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会改变响应中的 HTTP 状态码。如果要将 HTTP 状态码更改为成功状态，可以使用以下语法：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A more sophisticated action can be taken upon failure of an upstream server
    using an `error_page` directive that points to a named location:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上游服务器出现故障时，可以使用`error_page`指令，指向一个命名位置，采取更复杂的操作：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding configuration, Nginx first tries to fulfill the request by
    forwarding it to the `upstreamA` server. If this results in an error, Nginx switches
    to a named location `@retry` in an attempt to try with the `upstreamB` server.
    Request an URI while switching so that the `upstreamB` server will receive an
    identical request. If this doesn't help either, Nginx returns a static file `50x.html`
    pretending no error occurred.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，Nginx 首先尝试通过将请求转发到`upstreamA`服务器来处理该请求。如果发生错误，Nginx 将切换到名为`@retry`的位置，尝试与`upstreamB`服务器进行连接。请求
    URI 在切换时保持不变，这样`upstreamB`服务器将接收到相同的请求。如果这仍然没有解决问题，Nginx 将返回一个静态文件`50x.html`，假装没有发生错误。
- en: 'If an upstream has replied but returned an error, it can be intercepted rather
    than passed to the client using the `proxy_intercept_errors` directive:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上游已回复但返回错误，可以使用`proxy_intercept_errors`指令进行拦截，而不是将其传递给客户端：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding configuration, the `upstreamB` server will be called even when
    the `upstreamA` server replies but returns erroneous HTTP status code, such as
    `403` or `404`. This gives `upstreamB` an opportunity to fix the soft errors of
    `upstreamA`, if necessary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，即使`upstreamA`服务器回复但返回错误的 HTTP 状态码，如`403`或`404`，`upstreamB`服务器也会被调用。这给了`upstreamB`修复`upstreamA`的软错误的机会，如果需要的话。
- en: However, this configuration pattern must not proliferate too much. In [Chapter
    5](ch05.html "Chapter 5. Managing Inbound and Outbound Traffic"), *Managing Inbound
    and Outbound Traffic*, we will find out how to handle such situations in a more
    elegant way, without sophisticated configuration structures.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种配置模式不应过度扩展。在[第5章](ch05.html "第5章：管理进出流量")，*管理进出流量*中，我们将了解如何以更优雅的方式处理此类情况，而不需要复杂的配置结构。
- en: Choosing an outbound IP address
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择外部 IP 地址
- en: Sometimes, when your proxy server has multiple network interfaces, it becomes
    necessary to choose which IP address should be used as outbound address for upstream
    connections. By default, the system will choose the address of the interface that
    adjoins the network containing the host used as destination in the default route.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你的代理服务器有多个网络接口时，必须选择使用哪个 IP 地址作为上游连接的外部地址。默认情况下，系统会选择与默认路由中目标主机所在网络相邻的接口地址。
- en: 'To choose a particular IP address for outbound connections, you can use the
    `proxy_bind` directive:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择特定的 IP 地址用于外部连接，可以使用`proxy_bind`指令：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will make Nginx bind outbound sockets to the IP address `192.168.0.2` before
    making a connection. The upstream server will then see connections coming from
    IP address `192.168.0.2`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 Nginx 在建立连接之前，将外部套接字绑定到 IP 地址`192.168.0.2`。然后，上游服务器将看到来自 IP 地址`192.168.0.2`的连接。
- en: Accelerating downloads
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速下载
- en: Nginx is very efficient at heavy operations, such as handling large uploads
    and downloads. These operations can be delegated to Nginx using built-in functionality
    and third-party modules.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 在处理大型上传和下载等重负载操作时非常高效。这些操作可以通过内置功能和第三方模块委托给 Nginx 处理。
- en: 'To accelerate download, the upstream server must be able to issue the `X-Accel-Redirect`
    header that points to the location of a resource which needs to be returned, instead
    of the response obtained from the upstream. Consider the following configuration:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加速下载，上游服务器必须能够发出指向需要返回的资源位置的 `X-Accel-Redirect` 头，而不是返回来自上游的响应。考虑以下配置：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With the preceding configuration, once Nginx detects the `X-Accel-Redirect`
    header in the upstream response, it performs an internal redirect to the location
    specified in this header. Assume the upstream server instructs Nginx to perform
    an internal redirect to `/internal-media/BigFile.zip`. This path will be matched
    against the location `/internal-media`. This location specifies the document root
    at `/var/www/media`. So if a file `/var/www/media/BigFile.zip` exists, it will
    be returned to the client using efficient file operations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述配置，一旦 Nginx 在上游响应中检测到 `X-Accel-Redirect` 头，它将执行指向该头中指定位置的内部重定向。假设上游服务器指示
    Nginx 执行内部重定向到 `/internal-media/BigFile.zip`。这个路径将与 `/internal-media` 位置匹配。该位置指定了文档根目录为
    `/var/www/media`。因此，如果文件 `/var/www/media/BigFile.zip` 存在，它将通过高效的文件操作返回给客户端。
- en: For many web application servers, this feature provides an enormous speed up—both
    because they might not handle large downloads efficiently and because proxying
    reduces efficiency of large downloads.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多 Web 应用服务器来说，这一功能大大提高了速度——既因为它们可能无法高效处理大文件下载，也因为代理会降低大文件下载的效率。
- en: Caching
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Once Nginx is set up as a reverse proxy, it's logical to turn it into a caching
    proxy. Fortunately, this can be achieved very easily with Nginx.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将 Nginx 设置为反向代理，合理的做法是将其转变为缓存代理。幸运的是，使用 Nginx 可以非常容易地实现这一点。
- en: Configuring caches
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置缓存
- en: Before you can enable caching for a certain location, you need to configure
    a cache. A cache is a filesystem directory containing files with cached items
    and a shared memory segment where information about cached items is stored.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用某个位置的缓存之前，您需要先配置缓存。缓存是一个包含缓存项文件的文件系统目录，并且有一个存储缓存项信息的共享内存段。
- en: 'A cache can be declared using the `proxy_cache_path` directive:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `proxy_cache_path` 指令声明一个缓存：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding command declares a cache rooted at the path `<path>` with a shared
    memory segment named `<name>` of the size `<size>`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令声明了一个位于路径 `<path>` 的缓存，并有一个名为 `<name>` 的共享内存段，其大小为 `<size>`。
- en: 'This directive has to be specified in the `http` section of the configuration.
    Each instance of the directive declares a new cache and must specify a unique
    name for a shared memory segment. Consider the following example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令必须在配置的`http`部分中指定。每个指令实例声明一个新的缓存，并且必须为共享内存段指定一个唯一的名称。考虑以下示例：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding configuration declares a cache rooted at `/var/www/cache` with
    a shared memory segment named `my_cache`, which is 8 MB in size. Each cache item
    takes around 128 bytes in memory, thus the preceding configuration allocates space
    for around 64,000 items.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置声明了一个位于 `/var/www/cache` 的缓存，并有一个名为 `my_cache` 的共享内存段，其大小为 8MB。每个缓存项在内存中大约占用
    128 字节，因此上述配置为大约 64,000 个项分配了空间。
- en: 'The following table lists other parameters of `proxy_cache_path` and their
    meaning:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了 `proxy_cache_path` 的其他参数及其含义：
- en: '| Parameter | Description |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `levels` | Specifies hierarchy levels of the cache directory |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `levels` | 指定缓存目录的层级结构 |'
- en: '| `inactive` | Specifies the time after which a cache item will be removed
    from the cache if it was not used, regardless of freshness |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `inactive` | 指定缓存项在未被使用时将从缓存中移除的时间，无论其是否新鲜 |'
- en: '| `max_size` | Specifies maximum size (total size) of all cache items |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `max_size` | 指定所有缓存项的最大大小（总大小） |'
- en: '| `loader_files` | Specifies the number of files a **cache loader** process
    loads in each iteration |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `loader_files` | 指定 **缓存加载器** 进程在每次迭代中加载的文件数 |'
- en: '| `loader_sleep` | Specifies the time interval a cache loader process sleeps
    between each iteration |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `loader_sleep` | 指定缓存加载器进程在每次迭代之间休眠的时间间隔 |'
- en: '| `loader_threshold` | Specifies the time limit for each iteration of a cache
    loader process |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `loader_threshold` | 指定缓存加载器进程每次迭代的时间限制 |'
- en: Once Nginx starts, it processes all configured caches and allocates shared memory
    segments for each of the caches.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Nginx 启动，它会处理所有配置的缓存并为每个缓存分配共享内存段。
- en: After that, a special process called cache loader takes care of loading cached
    items into memory. Cache loader loads items in iterations. The parameters `loader_files`,
    `loader_sleep`, and `loader_threshold` define the behavior of the cache loader
    process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，一个名为缓存加载器的特殊进程负责将缓存项加载到内存中。缓存加载器以迭代的方式加载项目。`loader_files`、`loader_sleep`和`loader_threshold`参数定义了缓存加载器进程的行为。
- en: When running, a special process called **cache manager** monitors the total
    disk space taken by all cache items and evicts less requested items if the total
    consumed space is larger than specified in the `max_size` parameter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，一个名为**缓存管理器**的特殊进程监控所有缓存项所占用的总磁盘空间，并在总空间超过`max_size`参数指定的大小时，驱逐请求较少的缓存项。
- en: Enabling caching
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用缓存
- en: 'To enable caching for a location, you need to specify the cache using the `proxy_cache`
    directive:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要为某个位置启用缓存，您需要使用`proxy_cache`指令指定缓存：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The argument of the `proxy_cache` directive is the name of a shared memory
    segment that points to one of the caches configured using the `proxy_cache_path`
    directive. The same cache can be used in multiple locations. The upstream response
    will be cached if it is possible to determine the expiration interval for it.
    The primary source for the expiration interval for Nginx is the upstream itself.
    The following table explains which upstream response header influences caching
    and how:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy_cache`指令的参数是指向通过`proxy_cache_path`指令配置的缓存的共享内存段的名称。相同的缓存可以在多个位置使用。如果能够确定上游响应的过期时间间隔，则该响应将被缓存。Nginx的过期时间间隔的主要来源是上游响应。以下表格解释了哪些上游响应头会影响缓存以及如何影响：'
- en: '| Upstream response header | How it influences caching |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 上游响应头 | 它如何影响缓存 |'
- en: '| --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `X-Accel-Expires` | This specifies the cache item expiration interval in
    seconds. If the value starts from `@`, then the number following it is UNIX timestamp
    when the item is due to expire. This header has the higher priority. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `X-Accel-Expires` | 此项指定缓存项的过期时间间隔（以秒为单位）。如果值以`@`开头，则后面的数字是该项到期的UNIX时间戳。此头部的优先级更高。
    |'
- en: '| `Expires` | This specifies the cache item expiration time stamp. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `Expires` | 此项指定缓存项的过期时间戳。 |'
- en: '| `Cache-Control` | This enables or disables caching |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `Cache-Control` | 启用或禁用缓存 |'
- en: '| `Set-Cookie` | This disables caching |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `Set-Cookie` | 这会禁用缓存 |'
- en: '| `Vary` | The special value `*` disables caching. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `Vary` | 特殊值`*`禁用缓存。 |'
- en: 'It is also possible to explicitly specify an expiration interval for various
    response codes using the `proxy_cache_valid` directive:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过`proxy_cache_valid`指令明确指定各种响应代码的过期时间间隔：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This sets the expiration interval for responses with codes `200`, `301`, `302`
    to `1h` (1 hour). Note that the default status code list for the `proxy_cache_valid`
    directive is `200`, `301`, and `302`, so the preceding configuration can be simplified
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把状态码`200`、`301`、`302`的响应过期时间间隔设置为`1h`（1小时）。请注意，`proxy_cache_valid`指令的默认状态码列表是`200`、`301`和`302`，因此上述配置可以简化为如下：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To enable caching for negative responses, such as `404`, you can extend the
    status code list in the `proxy_cache_valid` directive:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要为负面响应（如`404`）启用缓存，可以在`proxy_cache_valid`指令中扩展状态码列表：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding configuration will cache `404` responses for `1m` (1 minute).
    The expiration interval for negative responses is deliberately set to much lower
    values than that of the positive responses. Such an optimistic approach ensures
    higher availability by expecting negative responses to improve, considering them
    as transient and assuming a shorter expected lifetime.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将缓存`404`响应`1m`（1分钟）。负面响应的过期时间间隔故意设置为比正面响应要低得多。这样的一种乐观方法确保了更高的可用性，因为负面响应预计会改善，认为它们是暂时性的，并假设其预期寿命较短。
- en: Choosing a cache key
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择缓存键
- en: Choosing the right cache key is important for the best operation of the cache.
    The cache key must be selected such that it maximizes the expected efficiency
    of the cache, provided that each cached item has valid content for all subsequent
    requests that evaluate to the same key. This requires some explanation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的缓存键对缓存的最佳操作至关重要。缓存键必须选择得当，以最大化缓存的预期效率，前提是每个缓存项对于所有后续请求都有有效的内容，这些请求评估为相同的键。这需要一些解释。
- en: First, let's consider efficiency. When Nginx refers to the upstream server in
    order to revalidate a cache item, it obviously stresses the upstream server. With
    each subsequent cache hit, Nginx reduces the stress on the upstream server in
    comparison to the situation when requests were forwarded to the upstream without
    caching. Thus, the efficiency of the cache can be represented as *Efficiency =
    (Number hits + Number misses) / Number misses*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑效率。当Nginx向上游服务器请求以重新验证缓存项时，显然会加重上游服务器的负担。每次缓存命中后，Nginx会减少对上游服务器的压力，相比于没有缓存时将请求转发到上游服务器的情况。因此，缓存的效率可以表示为*效率
    = (命中次数 + 未命中次数) / 未命中次数*。
- en: Thus, when nothing can be cached, each request leads to a cache miss and the
    efficiency is 1\. But when we get 99 subsequent cache hits for each cache miss,
    the efficiency evaluates to *(99 + 1) / 1 = 100*, which is 100 times larger!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当无法缓存时，每个请求都会导致缓存未命中，效率为1。但当我们每次缓存未命中后，接下来有99次缓存命中时，效率计算为*(99 + 1) / 1 =
    100*，也就是提高了100倍！
- en: Second, if a document is cached but it is not valid for all requests that evaluate
    to the same key, clients might see content that is not valid for their requests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果一个文档已经缓存，但并不适用于所有评估为相同键的请求，客户端可能会看到不适用于其请求的内容。
- en: For example, the upstream analyses the `Accept-Language` header and returns
    the version of the document in the most suitable language. If the cache key does
    not include the language, the first user to request the document will obtain it
    in their language and trigger the caching in that language. All users that subsequently
    request this document will see the cached version of the document, and thus they
    might see it in the wrong language.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上游服务器会分析`Accept-Language`头，并返回以最适合语言显示的文档版本。如果缓存键不包含语言，第一个请求文档的用户将获得他们语言的版本，并会触发该语言的缓存。所有后续请求该文档的用户都会看到缓存中的版本，因此他们可能会看到错误的语言版本。
- en: If the cache key includes the language of the document, the cache will contain
    multiple separate items for the same document in each requested language, and
    all users will see it in the proper language.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓存键包含文档的语言，缓存将为每种请求的语言存储同一文档的多个独立项，所有用户都会看到正确语言版本的文档。
- en: The default cache key is `$scheme$proxy_host$request_uri`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的缓存键是`$scheme$proxy_host$request_uri`。
- en: 'This might not be optimal because of the following reasons:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下原因，这可能并不是最优的：
- en: The web application server at `$proxy_host` can be responsible for multiple
    domains
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于`$proxy_host`的Web应用服务器可以负责多个域名
- en: The HTTP and HTTPS versions of the website can be identical (`$scheme` variable
    is redundant, thus duplicating items in the cache)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站的HTTP和HTTPS版本可以是相同的（`$scheme`变量是多余的，从而在缓存中会重复项）
- en: Content can vary depending on query arguments
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容可能会根据查询参数有所不同
- en: 'Thus, considering everything described previously and given that HTTP and HTTPS
    versions of the website are identical and content varies depending on query arguments,
    we can set the cache key to a more optimal value `$host$request_uri$is_args$args`.
    To change the default cache item key, you can use the `proxy_cache_key` directive:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到之前描述的所有情况，并且鉴于网站的HTTP和HTTPS版本是相同的，且内容会根据查询参数有所不同，我们可以将缓存键设置为一个更优的值`$host$request_uri$is_args$args`。要更改默认的缓存项键，可以使用`proxy_cache_key`指令：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This directive takes a script as its argument which is evaluated into a value
    of a cache key at runtime.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令以脚本作为参数，该脚本在运行时被评估为缓存键的值。
- en: Improving cache efficiency and availability
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高缓存效率和可用性
- en: 'The efficiency and availability of the cache can be improved. You can prevent
    an item from being cached until it gets a certain minimum number of requests.
    This could be achieved using the `proxy_cache_min_uses` directive:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可以提高缓存的效率和可用性。你可以防止项目在未达到一定请求次数之前被缓存。这可以通过使用`proxy_cache_min_uses`指令来实现：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, the response will be cached once the item gets no
    less than five requests. This prevents the cache from being populated by infrequently
    used items, thus reducing the disk space used for caching.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，响应会在项被请求不低于五次时缓存。这可以防止缓存中被不常用的项填满，从而减少用于缓存的磁盘空间。
- en: 'Once the item has expired, it can be revalidated without being evicted. To
    enable revalidation, use the `proxy_cache_revalidate` directive:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目过期，可以在不被驱逐的情况下重新验证它。要启用重新验证，可以使用`proxy_cache_revalidate`指令：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, once a cache item expires, Nginx will revalidate it
    by making a conditional request to the upstream server. This request will include
    the `If-Modified-Since` and/or `If-None-Match` headers as a reference to the cached
    version. If the upstream server responds with a `304 Not Modified` response, the
    cache item remains in the cache and the expiration time stamp is reset.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，一旦缓存项过期，Nginx 将通过向上游服务器发出条件请求来重新验证该缓存项。此请求将包括 `If-Modified-Since` 和/或
    `If-None-Match` 头部，作为参考缓存版本。如果上游服务器响应 `304 Not Modified`，则缓存项保持在缓存中，并且过期时间戳会被重置。
- en: 'Multiple simultaneous requests can be prohibited from filling the cache at
    the same time. Depending on the upstream reaction time, this might speed up cache
    population while reducing the load on the upstream server at the same time. To
    enable this behavior, you can use the `proxy_cache_lock` directive:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以禁止多个同时请求同时填充缓存。根据上游服务器的反应时间，这可能加速缓存的填充，同时减少上游服务器的负载。要启用此行为，可以使用 `proxy_cache_lock`
    指令：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once the behavior is enabled, only one request will be allowed to populate a
    cache item it is related to. The other requests related to this cache item will
    wait until either the cache item is populated or the lock timeout expires. The
    lock timeout can be specified using the `proxy_cache_lock_directive` directive.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用此行为，仅允许一个请求填充与之相关的缓存项。其他与此缓存项相关的请求将等待，直到缓存项被填充或锁定超时过期。锁定超时时间可以通过 `proxy_cache_lock_directive`
    指令指定。
- en: 'If higher availability of the cache is required, you can configure Nginx to
    reply with stale data when a request refers to a cached item. This is very useful
    when Nginx acts as an edge server in a distribution network. The users and search
    engine crawlers will see your web site available, even though the main site experiences
    connectivity problems. To enable replying with stale data, use the `proxy_cache_use_stale`
    directive:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更高的缓存可用性，可以配置 Nginx，在请求引用缓存项时，回复陈旧的数据。当 Nginx 作为分发网络中的边缘服务器时，这非常有用。即使主站点遇到连接问题，用户和搜索引擎爬虫也能看到你的网站是可用的。要启用陈旧数据的回复，可以使用
    `proxy_cache_use_stale` 指令：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding configuration enables replying with stale data in case of connectivity
    error, upstream error (`502`, `503`, or `504`), and connection timeout. The following
    table lists all possible values for arguments of the `proxy_cache_use_stale` directive:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置启用了在连接错误、上游错误（`502`、`503` 或 `504`）以及连接超时的情况下，使用陈旧数据进行回复。下表列出了 `proxy_cache_use_stale`
    指令参数的所有可能值：
- en: '| Value | Meaning |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `error` | A connection error has occurred or an error during sending a request
    or receiving a reply has occurred |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `error` | 发生了连接错误，或在发送请求或接收回复过程中发生了错误 |'
- en: '| `timeout` | A connection timed out during setup, sending a request or receiving
    a reply |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `timeout` | 连接在设置、发送请求或接收回复过程中超时 |'
- en: '| `invalid_header` | The upstream server has returned an empty or invalid reply
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `invalid_header` | 上游服务器返回了空的或无效的回复 |'
- en: '| `updating` | Enables stale replies while the cache item is being updated
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `updating` | 在缓存项更新时启用陈旧的回复 |'
- en: '| `http_500` | The upstream server returned a reply with HTTP status code `500`
    (Internal Server Error) |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `http_500` | 上游服务器返回了 HTTP 状态码 `500`（内部服务器错误） |'
- en: '| `http_502` | The upstream server returned a reply with HTTP status code `502`
    (Bad Gateway) |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `http_502` | 上游服务器返回了 HTTP 状态码 `502`（错误网关） |'
- en: '| `http_503` | The upstream server returned a reply with HTTP status code `503`
    (Service Unavailable) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `http_503` | 上游服务器返回了 HTTP 状态码 `503`（服务不可用） |'
- en: '| `http_504` | The upstream server returned a reply with HTTP status code `504`
    (Gateway Timeout) |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `http_504` | 上游服务器返回了 HTTP 状态码 `504`（网关超时） |'
- en: '| `http_403` | The upstream server returned a reply with HTTP status code `403`
    (Forbidden) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `http_403` | 上游服务器返回了 HTTP 状态码 `403`（禁止） |'
- en: '| `http_404` | The upstream server returned a reply with HTTP status code `404`
    (Not Found) |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `http_404` | 上游服务器返回了 HTTP 状态码 `404`（未找到） |'
- en: '| `off` | Disables use of stale replies |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `off` | 禁用使用陈旧的回复 |'
- en: Handling exceptions and borderline cases
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常和边界情况
- en: 'When caching is not desirable or not efficient, it can be bypassed or disabled.
    This can happen in the following instances:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当缓存不需要或不高效时，可以绕过或禁用缓存。这种情况可能出现在以下实例中：
- en: A resource is dynamic and varies depending on external factors
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源是动态的，取决于外部因素而变化
- en: A resource is user-specific and varies depending on cookies
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源是用户特定的，并且根据 cookies 的不同而有所变化
- en: Caching does not add much value
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存的价值不大
- en: A resource is not static, for example a video stream
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源不是静态的，例如视频流
- en: 'When bypass is forced, Nginx forwards the request to the backend without looking
    up an item in the cache. The bypass can be configured using the `proxy_cache_bypass`
    directive:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当强制绕过时，Nginx 会将请求转发到后台服务器，而不会查找缓存中的项。可以使用 `proxy_cache_bypass` 指令来配置绕过：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This directive can take one or more arguments. When any of them evaluate to
    true (nonempty value and not 0), Nginx does not look up an item in the cache for
    a given request. Instead, it directly forwards the request to the upstream server.
    The item can still be stored in the cache.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令可以接受一个或多个参数。当其中任何一个评估为真（非空值且不为 0）时，Nginx 不会查找缓存中的项，而是直接将请求转发到上游服务器。该项仍然可以存储在缓存中。
- en: 'To prevent an item from being stored in the cache, you can use the `proxy_no_cache`
    directive:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要防止将项存储在缓存中，可以使用 `proxy_no_cache` 指令：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This directive works exactly like the `proxy_cache_bypass` directive, but prevents
    items from being stored in the cache. When only the `proxy_no_cache` directive
    is specified, the items can still be returned from the cache. The combination
    of both `proxy_cache_bypass` and `proxy_no_cache` disables caching completely.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令的作用与 `proxy_cache_bypass` 指令完全相同，但它防止将项目存储在缓存中。当仅指定 `proxy_no_cache` 指令时，项目仍然可以从缓存中返回。结合使用
    `proxy_cache_bypass` 和 `proxy_no_cache` 可以完全禁用缓存。
- en: 'Now, let''s consider a real-world example when caching needs to be disabled
    for all user-specific pages. Assume that you have a website powered by WordPress
    and you want to enable caching for all pages but disable caching for all customized
    or user-specific pages. To implement this, you can use a configuration similar
    to the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个实际的例子，即当需要为所有用户特定页面禁用缓存时。假设你有一个由 WordPress 驱动的网站，想要为所有页面启用缓存，但为所有定制的或用户特定的页面禁用缓存。要实现这一点，你可以使用类似下面的配置：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding configuration, we first delegate all requests pertaining to
    the WordPress administrative area to the upstream server. We then use the `if`
    directive to look up WordPress login cookies and set the `$do_not_cache` variable
    to `1` if they are present. Then, we enable caching for all other locations but
    disable caching whenever the `$do_not_cache` variable is set to `1` using the
    `proxy_cache_bypass` and `proxy_no_cache` directives. This disables caching for
    all requests with WordPress login cookies.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们首先将所有与 WordPress 管理区域相关的请求委托给上游服务器。然后，我们使用 `if` 指令检查 WordPress 登录
    cookies，如果存在，则将 `$do_not_cache` 变量设置为 `1`。接着，我们为所有其他位置启用缓存，但使用 `proxy_cache_bypass`
    和 `proxy_no_cache` 指令禁用当 `$do_not_cache` 变量设置为 `1` 时的缓存。这将禁用所有带有 WordPress 登录
    cookies 的请求的缓存。
- en: The preceding configuration can be extended to extract no-cache flags from arguments
    or HTTP headers, to further tune your caching.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置可以扩展以从参数或 HTTP 头中提取无缓存标志，从而进一步调整缓存。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to work with proxying and caching—some of the
    most important Nginx features. These features practically define Nginx as a web
    accelerator and being proficient in them is essential to get the most out of Nginx.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何使用代理和缓存——这是 Nginx 最重要的特性之一。这些特性实际上定义了 Nginx 作为 Web 加速器的角色，掌握这些特性对于充分发挥
    Nginx 的功能至关重要。
- en: In the next chapter, we'll look into how to rewrite engine works in Nginx and
    the basics of access control.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨如何在 Nginx 中重写引擎的工作原理以及访问控制的基础知识。
