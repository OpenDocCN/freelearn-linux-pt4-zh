- en: Chapter 2. The BSP Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。BSP层
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Creating a custom BSP layer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建定制的BSP层
- en: Introducing system development workflows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍系统开发工作流
- en: Adding a custom kernel and bootloader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义内核和引导加载程序
- en: Building the U-Boot bootloader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建U-Boot引导加载程序
- en: Explaining Yocto's Linux kernel support
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Yocto对Linux内核的支持
- en: Describing Linux's build system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Linux的构建系统
- en: Configuring the Linux kernel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Linux内核
- en: Building the Linux source
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Linux源代码
- en: Building external kernel modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建外部内核模块
- en: Debugging the Linux kernel and modules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Linux内核和模块
- en: Debugging the Linux kernel booting process
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Linux内核引导过程
- en: Using the kernel tracing system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核追踪系统
- en: Managing the device tree
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理设备树
- en: Debugging device tree issues
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试设备树问题
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Once we have our build environment ready with the Yocto project, it's time to
    think about beginning development work on our embedded Linux project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的构建环境准备好并且Yocto项目已经就绪，就可以开始考虑开始开发我们的嵌入式Linux项目。
- en: Most of the embedded Linux projects require both custom hardware and software.
    An early task in the development process is to test different hardware reference
    boards and the selection of one to base our design on. We have chosen the Wandboard,
    a Freescale i.MX6-based platform, as it is an affordable and open board, which
    makes it perfect for our needs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式Linux项目都需要定制硬件和软件。开发过程中的一项早期任务是测试不同的硬件参考板，并选择一个作为我们设计的基础。我们选择了Wandboard，这是一个基于Freescale
    i.MX6的开发平台，它价格实惠且开源，非常适合我们的需求。
- en: On an embedded project, it is usually a good idea to start working on the software
    as soon as possible, probably before the hardware prototypes are ready, so that
    it is possible to start working directly with the reference design.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式项目中，通常最好尽早开始软件开发，可能在硬件原型准备好之前，这样就可以直接开始与参考设计一起工作。
- en: But at some point, the hardware prototypes will be ready and changes will need
    to be introduced into Yocto to support the new hardware.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在某个阶段，硬件原型将准备就绪，需要在Yocto中引入更改以支持新硬件。
- en: This chapter will explain how to create a BSP layer to contain those hardware-specific
    changes, as well as show how to work with the U-Boot bootloader and the Linux
    kernel, components which are likely to take most of the customization work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何创建一个BSP层来包含这些硬件特定的更改，并展示如何与U-Boot引导加载程序和Linux内核进行工作，这些组件可能需要进行最多的定制工作。
- en: Creating a custom BSP layer
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建定制的BSP层
- en: These custom changes are kept on a separate Yocto layer, called a **Board Support
    Package** (**BSP**) layer. This separation is best for future updates and patches
    to the system. A BSP layer can support any number of new machines and any new
    software feature that is linked to the hardware itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定制更改保存在一个单独的Yocto层中，称为**板支持包**（**BSP**）层。这种分离方式对系统的未来更新和补丁是最有利的。一个BSP层可以支持任意数量的新机器和任何与硬件相关的新软件功能。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: By convention, Yocto layer names start with `meta`, short for metadata. A BSP
    layer may then add a `bsp` keyword, and finally a unique name. We will call our
    layer `meta-bsp-custom`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，Yocto层的名称以`meta`开头，表示元数据。BSP层可以添加`bsp`关键字，最后加上一个唯一的名称。我们将把我们的层命名为`meta-bsp-custom`。
- en: 'There are several ways to create a new layer:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以创建一个新层：
- en: Manually, once you know what is required
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动操作，一旦你知道需要做什么
- en: By copying the `meta-skeleton` layer included in Poky
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过复制Poky中包含的`meta-skeleton`层
- en: By using the `yocto-layer` command-line tool
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`yocto-layer`命令行工具
- en: 'You can have a look at the `meta-skeleton` layer in Poky and see that it includes
    the following elements:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看Poky中的`meta-skeleton`层，看到它包含以下元素：
- en: A `layer.conf` file, where the layer configuration variables are set
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`layer.conf`文件，用于设置层的配置变量
- en: A `COPYING.MIT` license file
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`COPYING.MIT`许可证文件
- en: Several directories named with the `recipes` prefix with example recipes for
    BusyBox, the Linux kernel and an example module, an example service recipe, an
    example user management recipe, and a multilib example.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多名为`recipes`前缀的目录，其中包含BusyBox、Linux内核和示例模块的配方，示例服务配方，示例用户管理配方以及多库示例。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will cover some of the use cases that appear in the available examples in
    the next few recipes, so for our needs, we will use the `yocto-layer` tool, which
    allows us to create a minimal layer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几个食谱中介绍一些可用示例中的用例，因此对于我们的需求，我们将使用 `yocto-layer` 工具，它允许我们创建一个最小化的层。
- en: 'Open a new terminal and change to the `fsl-community-bsp` directory. Then set
    up the environment as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端并切换到 `fsl-community-bsp` 目录。然后按如下方式设置环境：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that once the `build` directory has been created, the `MACHINE` variable
    has already been configured in the `conf/local.conf` file and can be omitted from
    the command line.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦创建了 `build` 目录，`MACHINE` 变量已经在 `conf/local.conf` 文件中配置好了，可以从命令行中省略。
- en: 'Change to the `sources` directory and run:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `sources` 目录并运行：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the `yocto-layer` tool will add the `meta` prefix to your layer,
    so you don''t need to. It will prompt a few questions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`yocto-layer` 工具会为你的层添加 `meta` 前缀，因此你不需要手动添加。它会提示几个问题：
- en: The layer priority which is used to decide the layer precedence in cases where
    the same recipe (with the same name) exists in several layers simultaneously.
    It is also used to decide in what order `bbappends` are applied if several layers
    append the same recipe. Leave the default value of 6\. This will be stored in
    the layer's `conf/layer.conf` file as `BBFILE_PRIORITY`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层优先级用于决定当同一个食谱（同名）同时存在于多个层中时，哪个层的优先级更高。它还用于决定如果多个层同时追加同一个食谱，`bbappends` 应该按照什么顺序应用。请保留默认值
    6。这个值将存储在该层的 `conf/layer.conf` 文件中，作为 `BBFILE_PRIORITY`。
- en: Whether to create example recipes and append files. Let's leave the default
    *no* for the time being.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否创建示例食谱并追加文件。暂时我们保持默认值 *no*。
- en: 'Our new layer has the following structure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新层具有以下结构：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The first thing to do is to add this new layer to your project''s `conf/bblayer.conf`
    file. It is a good idea to add it to your template conf directory''s `bblayers.conf.sample`
    file too, so that it is correctly appended when creating new projects. The highlighted
    line in the following code shows the addition of the layer to the `conf/bblayers.conf`
    file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将这个新层添加到你项目的 `conf/bblayer.conf` 文件中。最好也将其添加到模板配置目录的 `bblayers.conf.sample`
    文件中，以便在创建新项目时正确地附加它。以下代码中的高亮行展示了将该层添加到 `conf/bblayers.conf` 文件中的方式：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, BitBake will parse the `bblayers.conf` file and find the `conf/layers.conf`
    file from your layer. In it, we find the following line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，BitBake 将解析 `bblayers.conf` 文件，并从你的层中找到 `conf/layers.conf` 文件。在其中，我们可以找到以下行：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It tells BitBake which directories to parse for recipes and append files. You
    need to make sure your directory and file hierarchy in this new layer matches
    the given pattern, or you will need to modify it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉 BitBake 需要解析哪些目录以获取食谱和追加文件。你需要确保这个新层中的目录和文件层级符合给定的模式，否则你需要进行修改。
- en: 'BitBake will also find the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake 还会找到以下内容：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `BBPATH` variable is used to locate the `bbclass` files and the configuration
    and files included with the `include` and `require` directives. The search finishes
    with the first match, so it is best to keep filenames unique.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`BBPATH` 变量用于定位 `bbclass` 文件以及通过 `include` 和 `require` 指令包含的配置文件和文件。搜索会在找到第一个匹配项时结束，因此最好保持文件名唯一。'
- en: 'Some other variables we might consider defining in our `conf/layer.conf` file
    are:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会考虑在 `conf/layer.conf` 文件中定义的其他一些变量包括：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `LAYERDEPENDS` literal is a space-separated list of other layers your layer
    depends on, and the `LAYERVERSION` literal specifies the version of your layer
    in case other layers want to add a dependency to a specific version.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`LAYERDEPENDS` 字面量是一个以空格分隔的其他层的列表，表示你的层依赖的其他层，而 `LAYERVERSION` 字面量指定你的层的版本，以防其他层希望添加对特定版本的依赖。'
- en: The `COPYING.MIT` file specifies the license for the metadata contained in the
    layer. The Yocto project is licensed under the *MIT* license, which is also compatible
    with the **General Public License** (**GPL**). This license applies only to the
    metadata, as every package included in your build will have its own license.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPYING.MIT` 文件指定了该层中元数据的许可证。Yocto 项目采用 *MIT* 许可证，该许可证与 **通用公共许可证**（**GPL**）兼容。此许可证仅适用于元数据，因为构建中包含的每个软件包都有自己的许可证。'
- en: The `README` file will need to be modified for your specific layer. It is usual
    to describe the layer and provide any other layer dependencies and usage instructions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`README` 文件需要根据你的特定层进行修改。通常在文件中描述该层并提供任何其他层的依赖关系和使用说明。'
- en: Adding a new machine
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新机器
- en: 'When customizing your BSP, it is usually a good idea to introduce a new machine
    for your hardware. These are kept under the `conf/machine` directory in your BSP
    layer. The usual thing to do is to base it on the reference design. For example,
    `wandboard-quad` has the following machine configuration file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当自定义你的 BSP 时，通常是为你的硬件引入一个新的机器配置。这些配置文件保存在你的 BSP 层中的`conf/machine`目录下。通常做法是基于参考设计。例如，`wandboard-quad`有如下的机器配置文件：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A machine based on the Wandboard design could define its own machine configuration
    file, `wandboard-quad-custom.conf`, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Wandboard 设计的机器可以定义自己的机器配置文件，`wandboard-quad-custom.conf`，内容如下：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `wandboard.inc` file now resides on a different layer, so in order for BitBake
    to find it, we need to specify the full path from the `BBPATH` variable in the
    corresponding layer. This machine defines its own U-Boot configuration file and
    Linux kernel device tree in addition to defining its own set of machine features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`wandboard.inc`文件位于一个不同的层中，因此为了让 BitBake 找到它，我们需要在相应层中从`BBPATH`变量指定完整路径。此机器除定义自己的
    U-Boot 配置文件和 Linux 内核设备树外，还定义了自己的一组机器特性。
- en: Adding a custom device tree to the Linux kernel
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向 Linux 内核添加自定义设备树
- en: 'To add this device tree file to the Linux kernel, we need to add the device
    tree file to the `arch/arm/boot/dts` directory under the Linux kernel source and
    also modify the Linux build system''s `arch/arm/boot/dts/Makefile` file to build
    it as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个设备树文件添加到 Linux 内核中，我们需要将设备树文件添加到 Linux 内核源代码下的`arch/arm/boot/dts`目录，并且还需要修改
    Linux 构建系统中的`arch/arm/boot/dts/Makefile`文件，以便像下面这样构建它：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code uses diff formatting, where the lines with a minus prefix are removed,
    the ones with a plus sign are added, and the ones without a prefix are left as
    reference.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了 diff 格式，其中带有减号前缀的行是删除的，带有加号前缀的行是新增的，而没有前缀的行作为参考保留。
- en: 'Once the patch is prepared, it can be added to the `meta-bsp-custom/recipes-kernel/linux/linux-wandboard-3.10.17/`
    directory and the Linux kernel recipe appended adding a `meta-bsp-custom/recipes-kernel/linux/linux-wandboard_3.10.17.bbappend`
    file with the following content:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦补丁准备好，它可以被添加到`meta-bsp-custom/recipes-kernel/linux/linux-wandboard-3.10.17/`目录，并且
    Linux 内核配方会附加一个`meta-bsp-custom/recipes-kernel/linux/linux-wandboard_3.10.17.bbappend`文件，内容如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An example patch that adds a custom device tree to the Linux kernel can be found
    in the source code that accompanies the book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义设备树到 Linux 内核的示例补丁可以在随书籍附带的源代码中找到。
- en: Adding a custom U-Boot machine
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义的 U-Boot 机器
- en: 'In the same way, the U-Boot source may be patched to add a new custom machine.
    Bootloader modifications are not as likely to be needed as kernel modifications
    though, and most custom platforms will leave the bootloader unchanged. The patch
    would be added to the `meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/`
    directory and the U-Boot recipe appended with a `meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend`
    file with the following content:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，可以对 U-Boot 源代码进行补丁，以添加一个新的自定义机器。然而，启动加载程序的修改不像内核修改那样常见，大多数自定义平台将保持启动加载程序不变。补丁将被添加到`meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/`目录，并且
    U-Boot 配方会附加一个`meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend`文件，内容如下：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An example patch that adds a custom machine to U-Boot can be found in the source
    code that accompanies the book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将自定义机器添加到 U-Boot 的示例补丁可以在随书籍附带的源代码中找到。
- en: Adding a custom formfactor file
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义的 formfactor 文件
- en: 'Custom platforms can also define their own `formfactor` file with information
    that the build system cannot obtain from other sources, such as defining whether
    a touchscreen is available or defining the screen orientation. These are defined
    in the `recipes-bsp/formfactor/` directory in our `meta-bsp-custom` layer. For
    our new machine, we could define a `meta-bsp-custom/recipes-bsp/formfactor/formfactor_0.0.bbappend`
    file to include a `formfactor` file as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义平台还可以定义自己的`formfactor`文件，包含构建系统无法从其他来源获取的信息，例如定义是否有触摸屏或定义屏幕方向。这些文件在我们的`meta-bsp-custom`层中的`recipes-bsp/formfactor/`目录下定义。对于我们的新机器，我们可以定义一个`meta-bsp-custom/recipes-bsp/formfactor/formfactor_0.0.bbappend`文件，内容如下：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the machine-specific `meta-bsp-custom/recipes-bsp/formfactor/formfactor/wandboard-quadcustom/machconfig`
    file would be as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 而与机器相关的`meta-bsp-custom/recipes-bsp/formfactor/formfactor/wandboard-quadcustom/machconfig`文件将如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Introducing system development workflows
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入系统开发工作流
- en: When customizing the software, there are some system development workflows that
    are commonly used, and we will introduce them in this recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义软件时，有一些常用的系统开发工作流，我们将在这个配方中介绍它们。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will see an overview of the following development workflows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将概述以下开发工作流：
- en: External development
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部开发
- en: Working directory development
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: External source development
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部源代码开发
- en: They are all used under different scenarios.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在不同的场景下使用。
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's understand what the use of each of these development workflows is individually.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别理解这些开发工作流的用途。
- en: External development
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部开发
- en: In this workflow, we don't use the Yocto build system to build our packages,
    just a Yocto toolchain and the package's own build system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作流中，我们不使用 Yocto 构建系统来构建我们的包，只使用 Yocto 工具链和包的自有构建系统。
- en: 'The resulting source can be integrated into Yocto in the following ways:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的源代码可以通过以下方式集成到 Yocto 中：
- en: With a recipe that fetches a released tarball.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个从发布的 tarball 获取的配方。
- en: With a recipe that fetches directly from a source-controlled repository.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个直接从源代码控制仓库获取的配方。
- en: External development is usually the preferred method for U-Boot and Linux kernel
    development, as they can be easily cross-compiled. Third-party packages in Yocto
    are also developed in this way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 外部开发通常是 U-Boot 和 Linux 内核开发的首选方法，因为它们可以轻松交叉编译。Yocto 中的第三方包也是以这种方式开发的。
- en: However, third-party packages can be tricky to cross-compile, and that is just
    what the Yocto build system makes easy. So, if we are not the main developers
    of the package and we only want to introduce some fixes or modifications, we can
    use Yocto to help us. The two workflows explained in the following sections use
    the Yocto build system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第三方包可能很难交叉编译，而 Yocto 构建系统正是让这变得容易。所以，如果我们不是包的主要开发者，只是想引入一些修复或修改，我们可以使用 Yocto
    来帮助我们。接下来将解释的两个工作流都使用了 Yocto 构建系统。
- en: Working directory development
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: In this workflow, we use the working directory inside the `build` directory,
    `tmp/work`. As we know, when Yocto builds a package, it uses the working directory
    to extract, patch, configure, build, and package the source. We can directly modify
    the source in this directory and use the Yocto system to build it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作流中，我们使用 `build` 目录中的工作目录，`tmp/work`。正如我们所知，当 Yocto 构建一个包时，它使用工作目录来提取、修补、配置、构建和打包源代码。我们可以直接在这个目录中修改源代码，并使用
    Yocto 系统来构建它。
- en: This methodology is commonly used when sporadically debugging third-party packages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常用于偶尔调试第三方包时。
- en: 'The workflow is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流如下：
- en: 'Remove the package''s `build` directory to start from scratch:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除包的 `build` 目录以从头开始：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Tell BitBake to fetch, unpack, and patch the package, but stop there:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 BitBake 获取、解压并修补包，但在此停止：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Enter the package's source directory and modify the source. Usually, we would
    create a temporary local Git directory to help us with our development and to
    extract the patches easily.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入包的源代码目录并修改源代码。通常，我们会创建一个临时的本地 Git 目录来帮助我们开发，并轻松提取补丁。
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Build it without losing our changes:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不丢失我们修改的情况下构建它：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note the capital `C`. This instructs BitBake to run the compile task and all
    the tasks that follow it. This is the same as running:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意大写的`C`。这指示 BitBake 执行编译任务以及后续的所有任务。这与运行以下命令是一样的：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Test it by copying the package to a running system and installing it with the
    target''s package management system. When you run your system from an NFS root
    filesystem, it''s as easy as to copy it there and run the following command (assuming
    the default RPM package format):'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将包复制到运行中的系统并使用目标的包管理系统安装来测试它。当你从 NFS 根文件系统运行系统时，只需将它复制到那里并运行以下命令（假设使用默认的 RPM
    包格式）：
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Optionally, you can also use a package feed as we saw in the *Setting up a
    package feed* recipe in [Chapter 1](ch01.html "Chapter 1. The Build System"),
    *The Build System*, in which case you would rebuild the index with the following:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选地，你也可以像在 [第 1 章](ch01.html "第 1 章 构建系统") *构建系统* 中的 *设置包源* 配方中看到的那样使用包源，在这种情况下，你将重新构建索引，命令如下：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And then use the smart package management utility on the target to install the
    package as previously shown.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后使用目标上的智能包管理工具安装包，如之前所示。
- en: Extract the patches and add them to the recipe's `bbappend` file.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取补丁并将其添加到配方的 `bbappend` 文件中。
- en: External source development
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部源代码开发
- en: In this workflow, we will use the Yocto build system to build an external directory
    containing the source. This external directory is usually source controlled to
    help us in our development.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种工作流程中，我们将使用Yocto构建系统来构建包含源码的外部目录。这个外部目录通常是受版本控制的，以帮助我们进行开发。
- en: This is the usual methodology to follow for extensive package development once
    the source has already been integrated with the Yocto build system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在源码已经与Yocto构建系统集成后进行广泛包开发的常用方法。
- en: 'The workflow is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程如下：
- en: We perform our development on this external-version-controlled directory and
    commit our changes locally.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个外部版本控制的目录上进行开发，并在本地提交我们的更改。
- en: We configure the Yocto build system to use a directory in our host system to
    fetch the source from, and optionally also to build in. This guarantees that our
    changes cannot be lost by any action of the Yocto build system. We will see some
    examples of this later on.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们配置Yocto构建系统，以使用主机系统中的一个目录来获取源码，并可选择在其中构建。这保证了我们的任何操作都不会使Yocto构建系统中的更改丢失。稍后我们将看到一些例子。
- en: 'Build it using Yocto:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Yocto构建它：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Test it by copying the package to a running system and installing it with the
    target's package management system.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将包复制到运行中的系统并使用目标的软件包管理系统进行安装来进行测试。
- en: Extract the patches and add them to the recipe's `bbappend` file.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取补丁并添加到配方的`bbappend`文件中。
- en: Adding a custom kernel and bootloader
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义内核和引导程序
- en: Development in U-Boot and the Linux kernel is usually done externally to Yocto,
    as they are easy to build using a toolchain, like the one provided by Yocto.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在U-Boot和Linux内核中的开发通常是在Yocto之外进行的，因为它们很容易使用工具链进行构建，比如Yocto提供的工具链。
- en: 'The development work is then integrated into Yocto in one of two ways:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将开发工作集成到Yocto中的一种方法：
- en: With patches added to the kernel and U-Boot `bbappend` files. This method will
    build the same source as the reference design board we are using as base, and
    apply our changes over it.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用添加到内核和U-Boot `bbappend`文件的补丁。这种方法将构建与我们正在使用的基础参考设计板相同的源，并对其应用我们的更改。
- en: Using a different Git repository, forked from the Linux kernel and U-Boot Git
    repositories being used by the reference design, and using a `bbappend` file to
    point the recipe to it. This way, we can directly commit the changes to the repository
    and the Yocto build system will build them.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的Git存储库，从Linux内核和U-Boot Git存储库分叉，并使用`bbappend`文件将配方指向它。这样，我们可以直接提交更改到存储库，而Yocto构建系统将会构建它们。
- en: Usually a forked Git repository is only needed when the hardware changes are
    substantial and the work in the Linux kernel and bootloader is going to be extensive.
    The recommendation is to start with patches, and only use a forked repository
    when they become difficult to manage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只有在硬件更改非常重大并且Linux内核和引导加载程序的工作将非常广泛时，才需要分叉Git存储库。建议的做法是从补丁开始，只有当它们难以管理时才使用分叉存储库。
- en: Getting Ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The first question when starting work on the Linux kernel and U-Boot modifications
    is how do you find which of the several available recipes are being used for your
    build.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始对Linux内核和U-Boot进行修改的工作时，第一个问题是如何找出哪些可用的配方正在为您的构建使用。
- en: Finding the Linux kernel source
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 找到Linux内核源码
- en: 'To find the Linux kernel source, we might use several methods. As we are aware
    we are building for a `wandboard-quad` machine, the first thing to do is find
    a machine configuration file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到Linux内核源码，我们可以使用几种方法。因为我们知道正在为`wandboard-quad`机器进行构建，所以要做的第一件事是找到机器配置文件：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The machine configuration file above in turn includes a `wandboard.inc` file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述机器配置文件反过来包括一个`wandboard.inc`文件：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we find a Linux kernel recipe being specified as the preferred provider
    for virtual/kernel. Virtual packages like this are used when a feature or element
    is provided by more than one recipe. It allows us to choose which of all those
    recipes will finally be used. Virtual packages will be further explained in the
    *Selecting a specific package versions and providers* recipe in [Chapter 3](ch03.html
    "Chapter 3. The Software Layer"), *The Software Layer*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发现一个Linux内核配方被指定为虚拟/kernel的首选提供者。像这样的虚拟包在一个功能或元素由多个配方提供时使用。这允许我们选择最终使用的所有配方中的哪一个。关于*选择特定软件版本和提供者*配方的详细解释将在[第3章](ch03.html
    "第3章。软件层")的*软件层*中进一步说明。
- en: 'We could check the actual output from our previous `core-image-minimal` build:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查之前`core-image-minimal`构建的实际输出：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As the `linux-wanboard` directory exists in our `work` folder, we can be sure
    the recipe has been used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `linux-wandboard` 目录存在于我们的 `work` 文件夹中，我们可以确定该配方已经被使用。
- en: 'We can check what the available Linux recipes are with:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令检查可用的 Linux 配方：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have lots of options, but we can use some of our acquired knowledge to filter
    them out. Let''s exclude the `poky` and `meta-openembedded` directories, as we
    know the BSP support is included in the Freescale community BSP layers:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多选项，但我们可以利用一些已获得的知识来过滤它们。让我们排除 `poky` 和 `meta-openembedded` 目录，因为我们知道 BSP
    支持已经包含在 Freescale 社区 BSP 层中：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we can also use the `bitbake-layers` script included in Poky:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以使用 Poky 中包含的 `bitbake-layers` 脚本：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Not all those kernels support the Wandboard machine completely, but they all
    support Freescale ARM machines, so they are useful for comparisons.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有这些内核都完全支持 Wandboard 机器，但它们都支持 Freescale ARM 机器，因此它们对进行比较很有用。
- en: Finding the U-Boot source
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找 U-Boot 源代码
- en: 'If we continue to pull the include chain, we have `imx-base.inc`, which itself
    includes `fsl-default-providers.inc`, where we find:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续拉取包含链，我们会看到 `imx-base.inc`，它本身包括 `fsl-default-providers.inc`，在其中我们可以找到：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So `u-boot-fslc` is the U-Boot recipe we are looking for.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 `u-boot-fslc` 就是我们正在寻找的 U-Boot 配方。
- en: Developing using a Git repository fork
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Git 仓库分支进行开发
- en: We will show how to append a recipe to use a forked repository to work from
    it. We will use the Linux kernel as an example, but the concept works just as
    well for U-Boot or any other package, although the specifics will change.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何追加一个配方，使用一个分叉的仓库进行开发。我们将以 Linux 内核为例，但这一概念同样适用于 U-Boot 或任何其他软件包，尽管具体细节会有所不同。
- en: We will fork or branch the repository used in the reference design and use it
    to specify `SRC_URI` for the recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分叉或创建参考设计中使用的仓库，并用它来指定配方的 `SRC_URI`。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For this example, I have forked the repository to [https://github.com/yoctocookbook/linux](https://github.com/yoctocookbook/linux),
    so my `recipes-kernel/linux/linux-wandboard_3.10.17.bbappend` file would have
    the following changes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我已经将仓库分叉到 [https://github.com/yoctocookbook/linux](https://github.com/yoctocookbook/linux)，所以我的
    `recipes-kernel/linux/linux-wandboard_3.10.17.bbappend` 文件将包含以下更改：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note how the URL needs to start with `git://`. This is so that BitBake can recognize
    it as a Git source. Now we can clean and build the Linux kernel and the source
    will be fetched from the forked repository.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 URL 需要以 `git://` 开头。这是为了让 BitBake 能够识别它为 Git 源。现在我们可以清理并构建 Linux 内核，源代码将从分叉的仓库中获取。
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s have a look at the `linux-wandboard_3.10.17.bb` recipe:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `linux-wandboard_3.10.17.bb` 配方：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first interesting thing is the inclusion of both `linux-wandboard.inc` and
    `linux-dtb.inc`. We will look at the first later on, and the other is a class
    that allows us to compile Linux kernel device trees. We will discuss device trees
    in the *Managing the device tree* recipe later in this chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有趣的地方是同时包含了 `linux-wandboard.inc` 和 `linux-dtb.inc`。我们稍后会查看第一个，而另一个是一个类，它允许我们编译
    Linux 内核设备树。我们将在本章稍后的 *管理设备树* 配方中讨论设备树。
- en: Then it declares two package dependencies, `lzop-native` and `bc-native`. The
    `native` part tells us that these are used in the host system, so they are used
    during the Linux kernel build process. The `lzop` tool is used to create the `cpio`
    compressed files needed in the `initramfs` system, which is a system that boots
    from a memory-based root filesystem, and `bc` was introduced to avoid a Perl kernel
    dependency when generating certain kernel files.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它声明了两个软件包依赖关系，`lzop-native` 和 `bc-native`。`native` 部分告诉我们这些是在主机系统中使用的，因此它们在
    Linux 内核构建过程中被使用。`lzop` 工具用于创建 `cpio` 压缩文件，这些文件在 `initramfs` 系统中使用，该系统从基于内存的根文件系统启动，`bc`
    被引入是为了避免在生成某些内核文件时产生 Perl 核心依赖。
- en: Then it sets the branch and revision, and finally it sets `COMPATIBLE_MACHINE`
    to `wandboard`. We will speak about machine compatibility in the *Adding new packages*
    recipe of [Chapter 3](ch03.html "Chapter 3. The Software Layer"), *The Software
    Layer*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它设置了分支和修订版本，最后将 `COMPATIBLE_MACHINE` 设置为 `wandboard`。我们将在[第 3 章](ch03.html
    "第 3 章。软件层")的 *添加新软件包* 配方中讲解机器兼容性，*软件层*。
- en: 'Let''s now have a look at the `linux-wandboard.inc` include file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 `linux-wandboard.inc` 包含文件：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is actually the file we were looking for. Initially, it specifies the license
    for the kernel source and points to it, sets a default branch and local version
    kernel string, and sets up the `SCR_URI` variable, which is the place where the
    source code is fetched from.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上就是我们要找的文件。最初，它指定了内核源代码的许可证，并指向它，设置了默认分支和本地版本的内核字符串，并设置了 `SCR_URI` 变量，这是源代码获取的地方。
- en: It then offers the `WANDBOARD_GITHUB_MIRROR` variable, which we can modify in
    our `bbappend` file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了`WANDBOARD_GITHUB_MIRROR`变量，我们可以在 `bbappend` 文件中修改它。
- en: So the logical setup would be to create a GitHub account and fork the provided
    `wandboard-org` Linux repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，逻辑上应该是创建一个 GitHub 账户并从提供的 `wandboard-org` Linux 仓库进行分叉。
- en: Once the fork is in place, we need to modify the `WANDBOARD_GITHUB_MIRROR` variable.
    But as we saw before, the recipe configures a specific revision and branch. We
    want to develop here, so we want to change this to a new development branch we
    have created. Let's call it `wandboard_imx_3.10.17_1.0.2_ga-dev` and set the revision
    to automatically fetch the newest point in the branch.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分支创建完毕，我们需要修改 `WANDBOARD_GITHUB_MIRROR` 变量。正如我们之前看到的，配方配置了特定的修订版和分支。我们希望在这里进行开发，因此我们需要将其更改为我们创建的新开发分支。我们可以将其命名为
    `wandboard_imx_3.10.17_1.0.2_ga-dev`，并将修订版设置为自动获取该分支中的最新版本。
- en: Building the U-Boot bootloader
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 U-Boot 引导加载程序
- en: In this recipe, we will go through the several development workflows described
    previously using the U-Boot bootloader as an example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过之前描述的几种开发工作流，使用 U-Boot 引导加载程序作为示例。
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will see how the following development workflows are applied to U-Boot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下开发工作流如何应用于 U-Boot：
- en: External development
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部开发
- en: External source development
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部源代码开发
- en: Working directory development
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's explain the three workflows, previously mentioned, in detail.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好详细解释之前提到的三种工作流。
- en: External development
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部开发
- en: We will use a Yocto toolchain to build the U-Boot source externally from the
    Yocto build system.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Yocto 工具链，在 Yocto 构建系统外部构建 U-Boot 源代码。
- en: 'Download and install a Yocto project cross-compilation toolchain for your host
    by going to the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装 Yocto 项目的交叉编译工具链，方法是访问以下链接：
- en: '[http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/)'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/](http://downloads.yoctoproject.org/releases/yocto/yocto-1.7.1/toolchain/)'
- en: Tip
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Choose either the 32- or 64-bit version and execute the installation script,
    accepting the default installation location. It is recommended not to change the
    default location to avoid relocation issues.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择 32 位或 64 位版本，并执行安装脚本，接受默认安装位置。建议不要更改默认位置，以避免位置迁移问题。
- en: 'Find the upstream Git repository:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到上游 Git 仓库：
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Clone the U-Boot''s source from its upstream repository:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上游仓库克隆 U-Boot 的源代码：
- en: '[PRE33]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The default branch should be `patches-2014.10`, but if it''s not, you can change
    it with the following:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认分支应该是 `patches-2014.10`，但如果不是，你可以使用以下命令进行更改：
- en: '[PRE34]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set up the environment using the script provided with the toolchain:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用工具链附带的脚本设置环境：
- en: '[PRE35]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Configure U-Boot for `wandboard-quad`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `wandboard-quad` 配置 U-Boot：
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you try to build U-Boot, it will fail. This is because the default Yocto
    environment setup does not cater to U-Boot''s needs. A quick look at the U-Boot
    recipe shows that it clears some flags before building, so let''s do that:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试构建 U-Boot，它会失败。这是因为默认的 Yocto 环境设置并不满足 U-Boot 的需求。快速查看 U-Boot 配方可以发现，它在构建之前清除了一些标志，因此我们需要做如下操作：
- en: '[PRE37]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we are ready to build. The U-Boot recipe also passes `CC` to the `make`
    utility in the `EXTRA_OEMAKE` flags as U-Boot does not read it from the environment,
    so we also need to run:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备构建。U-Boot 配方还将 `CC` 传递给 `make` 工具，作为 `EXTRA_OEMAKE` 标志，因为 U-Boot 不会从环境中读取它，因此我们还需要运行：
- en: '[PRE38]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can optionally pass a `-jN` argument for multithreaded compilation. Here,
    `N` is the number of CPU cores.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以选择传递 `-jN` 参数来进行多线程编译。这里，`N` 是 CPU 核心数。
- en: How it works…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The U-Boot `Makefile` looks for `libgcc` using the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot 的 `Makefile` 使用以下命令查找 `libgcc`：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If we don't define `CC`, the expression does not correctly expand to the location
    of the `libgcc` library in the toolchain, as the `sysroot` option is not passed
    to the compiler.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有定义 `CC`，该表达式不会正确展开为工具链中 `libgcc` 库的位置，因为没有将 `sysroot` 选项传递给编译器。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Newer versions of U-Boot have already fixed this issue, but we decided to leave
    the instruction as the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 更新版本的U-Boot已经修复了这个问题，但我们决定将指令保留如下：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That works for older versions of U-Boot too.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于旧版本的U-Boot同样有效。
- en: Another way to avoid the problem would be to define the `USE_PRIVATE_LIBGCC`
    U-Boot configuration variable, but that would use an internal `libgcc` library
    to U-Boot, which may not be what we want.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个避免问题的方法是定义`USE_PRIVATE_LIBGCC` U-Boot配置变量，但这将使用内部的`libgcc`库到U-Boot，这可能不是我们想要的。
- en: We would then need to copy the image to the target to test our changes, as we
    will see soon.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将镜像复制到目标设备以测试我们的更改，这很快就会看到。
- en: External source development
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部源开发
- en: We will use the Yocto build system from a local directory by cloning a local
    copy of the source used in the reference design and configuring our project to
    use it as an external source. We will then develop from it, extract the patches,
    and add them to a `bbappend` file on our BSP layer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个本地目录中使用Yocto构建系统，通过克隆参考设计中使用的源代码的本地副本，并配置我们的项目以使用它作为外部源。然后，我们将从中开发，提取补丁，并将其添加到我们的BSP层中的`bbappend`文件中。
- en: We will use the U-Boot source cloned in the example beforehand.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前克隆的U-Boot源码。
- en: 'To configure our `conf/local.conf` file to work from the cloned source, modify
    it as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的`conf/local.conf`文件以从克隆源码工作，按以下方式修改它：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `EXTERNALSRC` variable defines the source location (`S`), while the `EXTERNALSRC_BUILD`
    variable defines the build location (`B`). This code will also build on the external
    source location as the `u-boot-fslc` recipe does not currently support the separation
    of the source and `build` directories.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXTERNALSRC`变量定义了源代码位置(`S`)，而`EXTERNALSRC_BUILD`变量定义了构建位置(`B`)。这段代码也将在外部源位置上构建，因为`u-boot-fslc`配方目前不支持源代码和构建目录的分离。'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to remove the aforementioned configuration when trying the working
    directory development methodology explained next in this recipe.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在尝试下一个方法时删除前述的配置，该方法在接下来的这个配方中解释了工作目录开发方法。
- en: 'Now we can build on a new shell with:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在新的shell上进行构建：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When building from an external source, the expansion of `SRCPV` fails with
    an error. Recipes need to be temporarily modified to use static versioning while
    the external source compilation is enabled. In the case of U-Boot, we would make
    the following change in the `meta-fsl-arm/recipes-bsp/u-boot/u-boot-fslc_2014.10.bb`
    file:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在从外部源构建时，`SRCPV`的扩展会失败并显示错误。在启用外部源编译时，需要暂时修改配方以使用静态版本控制。对于U-Boot，我们会在`meta-fsl-arm/recipes-bsp/u-boot/u-boot-fslc_2014.10.bb`文件中进行以下更改：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This uses diff formatting, where the lines with a minus prefix are removed and
    the ones with a plus sign are added.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用差异格式，带有减号前缀的行将被删除，带有加号前缀的行将被添加。
- en: An example patch to U-Boot that allows us to perform external source development
    can be found in the source code that accompanies the book.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在附带书籍的源代码中找到一个允许我们执行外部源开发的U-Boot示例补丁。
- en: 'Development work can now be committed in the local Git repository, and patches
    can be generated with `git format-patch`. For example, we could change the board
    information for the Wandboard with the `0001-wandboard-Change-board-info.patch`
    file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 开发工作现在可以提交到本地Git存储库，并可以使用`git format-patch`生成补丁。例如，我们可以为Wandboard更改板信息并创建`0001-wandboard-Change-board-info.patch`文件：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To add this patch to Yocto''s U-Boot recipe, we create a `meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend`
    file with the following content:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此补丁添加到Yocto的U-Boot配方中，我们创建一个`meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc_2014.10.bbappend`文件，内容如下：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The patch needs to be placed under `meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/`,
    as specified in the `FILESEXTRAPATHS` variable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁需放置在`meta-bsp-custom/recipes-bsp/u-boot/u-boot-fslc-v2014.10/`下，正如`FILESEXTRAPATHS`变量中指定的。
- en: Files added to the `SRC_URI` variable that end in the `patch` or `diff` prefixes
    will be applied in the order they are found. You can also force a file to be treated
    as `patch` by specifying an `apply=yes` property to it in `SRC_URI`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 被添加到`SRC_URI`变量的以`patch`或`diff`前缀结尾的文件将按照它们被发现的顺序应用。您也可以通过在`SRC_URI`中指定`apply=yes`属性来强制将文件视为`patch`。
- en: Working directory development
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: 'A typical workflow when working on a small modification would be:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行小修改时的典型工作流程将会是：
- en: 'Start the U-Boot package compilation from scratch:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从头开始编译U-Boot包：
- en: '[PRE46]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will erase the `build` folder, shared state cache, and downloaded package
    source.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将清除 `build` 文件夹、共享状态缓存和下载的包源。
- en: 'Start a development shell:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动开发 shell：
- en: '[PRE47]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will fetch, unpack, and patch the U-Boot sources and spawn a new shell
    with the environment ready for U-Boot compilation. The new shell will change to
    the U-Boot `build` directory, which contains a local Git repository.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将获取、解压和打补丁 U-Boot 源码，并启动一个新的 shell，环境已准备好进行 U-Boot 编译。新 shell 会切换到包含本地 Git
    仓库的 U-Boot `build` 目录。
- en: Perform your modifications on the local Git repository.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地 Git 仓库中执行修改。
- en: 'Leave the devshell open and use a different terminal to compile the source
    without erasing our modifications:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持 devshell 打开，并使用另一个终端编译源代码，而不擦除我们的修改：
- en: '[PRE48]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the capital `C`. This invokes the compile task but also all the tasks that
    follow it.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意大写的 `C`。这会触发编译任务，但也会触发随后的所有任务。
- en: The newly compiled U-Boot image is available under `tmp/deploy/images/wandboard-quad`.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新编译的 U-Boot 镜像可在 `tmp/deploy/images/wandboard-quad` 下找到。
- en: Test your changes. Typically, this means that we need to reprogram the bootloader
    into the microSD card (as is the case with the Wandboard) or the internal `emmc`
    (if available) at the correct offset. We can do it both from the target or from
    your host computer.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试您的更改。通常，这意味着我们需要将引导加载程序重新编程到 microSD 卡（如 Wandboard 所示）或内置的 `emmc`（如果可用），并在正确的偏移量处进行编程。我们可以从目标设备或主机计算机上进行此操作。
- en: From the host computer, we would use `dd` to copy the new U-Boot image to an
    offset of 0x400, which is where the i.MX6 bootrom expects to find it.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从主机计算机，我们将使用 `dd` 命令将新的 U-Boot 镜像复制到偏移量为 0x400 的位置，这是 i.MX6 bootrom 期望找到它的地方。
- en: '[PRE49]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This writes with an offset of 2 blocks, which, given a 512-byte block size,
    is 0x400 (1024) bytes.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会以 2 个块的偏移量进行写入，考虑到每块大小为 512 字节，偏移量为 0x400（1024）字节。
- en: Tip
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be careful when running the `dd` command, as it could harm your machine. You
    need to be absolutely sure that the sdN device corresponds to your microSD card
    and not a drive on your development machine.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行 `dd` 命令时要小心，因为它可能会损坏您的机器。您需要确保 sdN 设备对应的是您的 microSD 卡，而不是开发机器上的某个驱动器。
- en: 'From the device itself, we can use U-Boot''s `mmc` command as follows:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从设备本身，我们可以使用 U-Boot 的 `mmc` 命令，如下所示：
- en: 'Load the U-Boot image to memory:'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 U-Boot 镜像加载到内存中：
- en: '[PRE50]'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The hexadecimal file size of the TFTP transfer is kept in the filesize environment
    variable, which we will use later on.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TFTP 传输的十六进制文件大小保存在 `filesize` 环境变量中，我们稍后会使用它。
- en: Select the MMC device to operate on. You can use the `mmc` part to discover
    which is the correct device.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择要操作的 MMC 设备。您可以使用 `mmc` 部分来发现哪个是正确的设备。
- en: '[PRE51]'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can see that partition `1` starts at sector `8192`, leaving enough space
    to program U-Boot.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到分区 `1` 从扇区 `8192` 开始，留下足够的空间来编程 U-Boot。
- en: 'With a 512-byte block size, we calculate the number of blocks as follows:'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 512 字节的块大小，我们按如下方式计算块数：
- en: '[PRE52]'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We then write to an offset of two blocks with the numbers of blocks occupied
    by our image.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们将写入两个块的偏移量，使用我们镜像占用的块数。
- en: '[PRE53]'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Go back to the devshell and commit your change to the local Git repository.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 devshell 并将您的更改提交到本地 Git 仓库。
- en: '[PRE54]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Generate a patch into the U-Boot recipe patch directory as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个补丁到 U-Boot 配方的补丁目录，如下所示：
- en: '[PRE55]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finally, add the patch to the U-Boot recipe as explained before.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将补丁添加到之前解释过的 U-Boot 配方中。
- en: Explaining Yocto's Linux kernel support
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 Yocto 的 Linux 内核支持
- en: 'The Yocto project offers a kernel framework that allows us to work with the
    Linux kernel in different ways:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 项目提供了一个内核框架，允许我们以不同的方式与 Linux 内核进行工作：
- en: Fetching the source from a Git repository and applying patches to it. This is
    the path taken by the Freescale community BSP-supported kernels, as we saw previously.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Git 仓库获取源代码并应用补丁。这是 Freescale 社区 BSP 支持的内核所走的路径，正如我们之前所看到的。
- en: The `linux-yocto` style kernels that generate the kernel source from a set of
    Git branches and leafs. Specific features are developed in branches, and a leaf
    is followed for a complete set of features.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-yocto` 样式的内核从一组 Git 分支和叶子生成内核源代码。特定的功能在分支中开发，叶子则跟随一个完整的功能集。'
- en: In this recipe, we will show how to work with a `linux-yocto` style kernel.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示如何使用 `linux-yocto` 样式的内核。
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To use a `linux-yocto` style kernel, the kernel recipe inherits the `linux-yocto.inc`
    file. A Git repository for a `linux-yocto` style kernel contains metadata either
    in the recipe or inside the kernel Git tree, in branches named with the `meta`
    prefix.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`linux-yocto`风格的内核，内核配方会继承`linux-yocto.inc`文件。`linux-yocto`风格内核的Git仓库包含元数据，通常在配方中或内核Git树中，分支以`meta`前缀命名。
- en: The `linux-yocto` style kernel recipes are all named `linux-yocto` and follow
    the upstream kernel development, rooted in the `kernel.org` repository. Once a
    new Yocto release cycle starts, a recent upstream kernel version is chosen, and
    the kernel version from the previous Yocto release is maintained. Older versions
    are updated inline with the **Long Term Support Initiative** (**LTSI**) releases.
    There is also a `linux-yocto-dev` package, which always follows the latest upstream
    kernel development.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`linux-yocto`风格的内核配方全部命名为`linux-yocto`，并遵循上游内核开发，基于`kernel.org`仓库。一旦新的Yocto发布周期开始，就会选择一个最新的上游内核版本，并保持前一个Yocto发布周期的内核版本。较旧的版本则根据**长期支持计划**（**LTSI**）发布进行更新。还有一个`linux-yocto-dev`包，它始终跟随最新的上游内核开发。'
- en: Yocto kernels are maintained separately from the upstream kernel sources, and
    add features and BSPs to cater to embedded system developers.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto内核与上游内核源代码分开维护，并为嵌入式系统开发人员添加功能和BSP。
- en: Although the Freescale community BSP does not include `linux-yocto` style kernels,
    some other BSP layers do.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Freescale社区的BSP不包含`linux-yocto`风格的内核，但其他一些BSP层包含此类内核。
- en: 'Metadata variables that are used to define the build include:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义构建的元数据变量包括：
- en: '`KMACHINE`: This is usually the same as the `MACHINE` variable, but not always.
    It defines the kernel''s machine type.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KMACHINE`：这个通常与`MACHINE`变量相同，但并非总是如此。它定义了内核的机器类型。'
- en: '`KBRANCH`: This explicitly sets the kernel branch to build. It is optional.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KBRANCH`：这显式设置要构建的内核分支。它是可选的。'
- en: '`KBRANCH_DEFAULT`: This is the default value for KBRANCH, initially `master`.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KBRANCH_DEFAULT`：这是KBRANCH的默认值，初始值为`master`。'
- en: '`KERNEL_FEATURES`: This adds additional metadata that is used to specify configuration
    and patches. It appears above the defined `KMACHINE` and `KBRANCH`. It is defined
    in **Series Configuration Control** (**SCC**) files as described soon.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERNEL_FEATURES`：这添加了额外的元数据，用于指定配置和补丁。它出现在定义的`KMACHINE`和`KBRANCH`上方。它在**系列配置控制**（**SCC**）文件中定义，稍后会详细说明。'
- en: '`LINUX_KERNEL_TYPE`: This defaults to standard, but may also be `tiny` or `preempt-rt`.
    It is defined in its own SCC description files, or explicitly defined using the
    `KTYPE` variable in the SCC files.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINUX_KERNEL_TYPE`：默认为标准类型，但也可以是`tiny`或`preempt-rt`。它在其自己的SCC描述文件中定义，或者在SCC文件中使用`KTYPE`变量明确指定。'
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The metadata included in the Linux kernel manages the configuration and source
    selection to support multiple BSPs and kernel types. The tools that manage this
    metadata are built in the `kern-tools` package.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核中的元数据管理配置和源选择，以支持多个BSP和内核类型。管理这些元数据的工具构建在`kern-tools`包中。
- en: 'The metadata can be set either in recipes, for small changes or if you are
    using a kernel repository you do not have access to, or most usually inside the
    kernel Git repository in `meta` branches. The `meta` branch that is to be used
    defaults to a `meta` directory in the same repository branch as the sources, but
    can be specified using the `KMETA` variable in your kernel recipe. If it does
    not reside in the same branch as the kernel source, it is kept in an orphan branch;
    that is, a branch with its own history. To create an orphan branch, use the following
    commands:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据可以在配方中设置，用于小的修改，或者如果你没有访问某个内核仓库的权限，通常是在内核Git仓库中的`meta`分支中设置。要使用的`meta`分支默认位于与源代码相同仓库分支中的`meta`目录中，但也可以在内核配方中使用`KMETA`变量指定。如果它不在与内核源代码相同的分支中，它会被保存在孤立分支中；也就是说，这是一个具有自己历史的分支。要创建孤立分支，请使用以下命令：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Your recipe must then include `SRCREV_meta` to point to the revision of the
    `meta` branch to use.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你的配方必须包括`SRCREV_meta`，以指向要使用的`meta`分支的修订版本。
- en: 'The metadata is described in SCC files, which can include a series of commands:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据在SCC文件中描述，其中可以包含一系列命令：
- en: '`kconf`: This command applies a configuration fragment to the kernel configuration.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kconf`：该命令将一个配置片段应用到内核配置中。'
- en: '`patch`: This command applies the specified patch.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch`：该命令应用指定的补丁。'
- en: '`define`: This introduces the variable definitions.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`define`：这引入变量定义。'
- en: '`include`: This includes another SCC file.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：这包含另一个SCC文件。'
- en: '`git merge`: This merges the specified branch into the current branch.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git merge`：将指定的分支合并到当前分支。'
- en: '`branch`: This creates a new branch relative to the current branch, usually
    `KTYPE` or as specified.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`branch`：根据当前分支创建一个新的分支，通常是`KTYPE`或按指定内容。'
- en: 'SCC files are broadly divided into the following logical groupings:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: SCC文件大致分为以下逻辑分组：
- en: '**configuration (**`cfg`**)**: This contains one or more kernel configuration
    fragments and an SCC file to describe them. For example:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**configuration (**`cfg`**)**：包含一个或多个内核配置片段以及描述它们的SCC文件。例如：'
- en: '[PRE57]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**patches**: This contains one or more kernel patches and an SCC file to describe
    them. For example:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补丁**：包含一个或多个内核补丁以及描述它们的SCC文件。例如：'
- en: '[PRE58]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**features**: This contains mix configurations and patches to define complex
    features. It can also include other description files. For example:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**features**：包含混合配置和补丁以定义复杂的特性。它还可以包括其他描述文件。例如：'
- en: '[PRE59]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**kernel types**: This contains features that define a high-level kernel policy.
    By default, three kernel types are defined in SCC files:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核类型**：包含定义高级内核策略的特性。默认情况下，SCC文件中定义了三种内核类型：'
- en: '**standard**: This is a generic kernel definition policy'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**standard**：这是一个通用的内核定义策略。'
- en: '**tiny**: This is a bare minimum kernel definition policy and is independent
    of the standard type'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tiny**：这是一个最小的内核定义策略，独立于标准类型。'
- en: '**preempt-rt**: This inherits from the standard type to define a real-time
    kernel where the `PREEMTP-RT` patches are applied'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**preempt-rt**：继承自标准类型，用于定义应用了`PREEMPT-RT`补丁的实时内核。'
- en: Other kernel types can be defined by using the `KTYPE` variable on an SCC file.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他内核类型可以通过在SCC文件中使用`KTYPE`变量来定义。
- en: '**Board Support Packages** (**BSP**): A combination of kernel types and hardware
    features. BSP types should include KMACHINE for the kernel machine and KARCH for
    the kernel architecture.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Board Support Packages**（**BSP**）：内核类型和硬件特性的组合。BSP类型应包括KMACHINE（内核机器）和KARCH（内核架构）。'
- en: See also
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Detailed information regarding `linux-yocto` style kernels can be found in the
    *Yocto Project Linux Kernel Development Manual* at [http://www.yoctoproject.org/docs/1.7.1/kernel-dev/kernel-dev.html](http://www.yoctoproject.org/docs/1.7.1/kernel-dev/kernel-dev.html)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`linux-yocto`风格内核的详细信息，请参阅*Yocto项目Linux内核开发手册*，网址：[http://www.yoctoproject.org/docs/1.7.1/kernel-dev/kernel-dev.html](http://www.yoctoproject.org/docs/1.7.1/kernel-dev/kernel-dev.html)
- en: Describing Linux's build system
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述Linux的构建系统
- en: The Linux kernel is a monolithic kernel and as such shares the same address
    space. Although it has the ability to load modules at runtime, the kernel must
    contain all the symbols the module uses at compilation time. Once the module is
    loaded, it will share the kernel's address space.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核是单内核，因而共享同一地址空间。尽管它能够在运行时加载模块，但内核必须在编译时包含模块所需的所有符号。一旦模块被加载，它将共享内核的地址空间。
- en: The kernel build system, or **kbuild**, uses conditional compilation to decide
    which parts of the kernel are compiled. The kernel build system is independent
    of the Yocto build system.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 内核构建系统或**kbuild**使用条件编译来决定内核的哪些部分需要编译。内核构建系统独立于Yocto构建系统。
- en: In this recipe, we will explain how the kernel's build system works.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指南中，我们将解释内核构建系统是如何工作的。
- en: How to do it...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The kernel configuration is stored in a `.config` text file in the kernel root
    directory. The kbuild system reads this configuration to build the kernel. The
    `.config` file is referred to as the kernel configuration file. There are multiple
    ways to define a kernel configuration file:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 内核配置存储在内核根目录下的`.config`文本文件中。kbuild系统读取该配置文件来构建内核。`.config`文件被称为内核配置文件。定义内核配置文件有多种方式：
- en: Manually editing the `.config` file, although this is not recommended.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动编辑`.config`文件，尽管不推荐这样做。
- en: 'Using one of the user interfaces the kernel offers (type the make help command
    for other options):'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核提供的用户接口之一（键入make help命令以查看其他选项）：
- en: '`menuconfig`: An ncurses menu-based interface (`make menuconfig`)'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`menuconfig`：基于ncurses的菜单界面（`make menuconfig`）'
- en: '`xconfig`: A Qt-based interface (`make xconfig`)'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xconfig`：基于Qt的界面（`make xconfig`）'
- en: '`gconfig`: A GTK-based interface (`make gconfig`)'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gconfig`：基于GTK的界面（`make gconfig`）'
- en: Note
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that to build and use these interfaces, your Linux host needs to have the
    appropriate dependencies.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，为了构建和使用这些接口，您的Linux主机需要具有适当的依赖项。
- en: Automatically via a build system such as Yocto.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过像Yocto这样的构建系统自动化执行。
- en: 'Each machine also defines a default configuration in the kernel tree. For ARM
    platforms, these are stored in the `arch/arm/configs` directory. To configure
    an ARM kernel, that is, to produce a `.config` file from a default configuration,
    you run:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 每台机器还在内核树中定义了一个默认配置。对于 ARM 平台，这些存储在 `arch/arm/configs` 目录中。要配置 ARM 内核，即从默认配置生成一个
    `.config` 文件，您运行：
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For example we can build a default configuration for Freescale i.MX6 processors
    by running:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过运行以下命令为 Freescale i.MX6 处理器构建一个默认配置：
- en: '[PRE61]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理如下…
- en: Kbuild uses `Makefile` and `Kconfig` files to build the kernel source. Kconfig
    files define configuration symbols and attributes, and `Makefile` file match configuration
    symbols to source files.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Kbuild 使用 `Makefile` 和 `Kconfig` 文件来构建内核源代码。Kconfig 文件定义配置符号和属性，而 `Makefile`
    文件将配置符号与源文件匹配。
- en: 'The kbuild system options and targets can be seen by running:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令可以查看 kbuild 系统的选项和目标：
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There's more...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In recent kernels, a default configuration contains all the information needed
    to expand to a full configuration file. It is a minimal kernel configuration file
    where all dependencies are removed. To create a default configuration file from
    a current `.config` file, you run:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的内核中，默认配置包含了扩展为完整配置文件所需的所有信息。它是一个最小内核配置文件，其中删除了所有依赖项。要从当前的 `.config` 文件创建一个默认配置文件，您运行：
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This creates a `defconfig` file in the current kernel directory. This `make`
    target can be seen as the opposite of the `<platform>_defconfig` target explained
    before. The former creates a configuration file from a minimal configuration,
    and the other expands the minimal configuration into a full configuration file.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前内核目录中创建一个 `defconfig` 文件。这个 `make` 目标可以看作是之前介绍的 `<platform>_defconfig`
    目标的反义。前者从最小配置创建一个配置文件，后者将最小配置扩展为完整配置文件。
- en: Configuring the Linux kernel
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Linux 内核
- en: In this recipe, we will explain how to configure a Linux kernel using the Yocto
    build system.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将解释如何使用 Yocto 构建系统配置 Linux 内核。
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before configuring the kernel, we need to provide a default configuration for
    our machine, which is the one the Yocto project uses to configure a kernel. When
    defining a new machine in your BSP layer, you need to provide a `defconfig` file.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置内核之前，我们需要为我们的机器提供一个默认配置，这是 Yocto 项目用来配置内核的方式。在你的 BSP 层中定义新的机器时，需要提供一个 `defconfig`
    文件。
- en: The Wandboard's `defconfig` file is stored under `sources/meta-fsl-arm-extra/recipes-kernel/linux/linux-wandboard-3.10.17/defconfig`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Wandboard 的 `defconfig` 文件存储在 `sources/meta-fsl-arm-extra/recipes-kernel/linux/linux-wandboard-3.10.17/defconfig`
    下。
- en: 'This would be the base `defconfig` file for our custom hardware, so we copy
    it to our BSP layer:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们自定义硬件的基本 `defconfig` 文件，因此我们将其复制到我们的 BSP 层中：
- en: '[PRE64]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We then add it to our kernel using `meta-bsp-custom/recipes-kernel/linux/linux-wandboard_3.10.17.bbappend`
    as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将其添加到我们的内核中，使用 `meta-bsp-custom/recipes-kernel/linux/linux-wandboard_3.10.17.bbappend`
    如下：
- en: '[PRE65]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Kernel configuration changes to your platform can be made directly in this `defconfig`
    file.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 内核配置更改可以直接在这个 `defconfig` 文件中进行。
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To create a `.config` file from the machine `defconfig` file, execute the following
    command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要从机器 `defconfig` 文件创建一个 `.config` 文件，请执行以下命令：
- en: '[PRE66]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This will also run the oldconfig kernel `make` target to validate the configuration
    against the Linux source.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将运行 oldconfig 内核 `make` 目标，以验证与 Linux 源的配置。
- en: 'We can then configure the Linux kernel from the BitBake command line using
    the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下 BitBake 命令行配置 Linux 内核：
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The menuconfig user interface, as well as other kernel configuration user interfaces,
    has a search functionality that allows you to locate configuration variables by
    name. Have a look at the following screenshot:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`menuconfig` 用户界面以及其他内核配置用户界面具有搜索功能，允许您通过名称定位配置变量。看下面的屏幕截图：'
- en: '![How to do it...](img/5186OS_02_01.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/5186OS_02_01.jpg)'
- en: Note
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the following chapters, we will mention specific kernel configuration variables,
    like `CONFIG_PRINTK`, without specifying the whole path to the configuration variable.
    The search interface of the different UIs can be used to locate the configuration
    variable path.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们会提到特定的内核配置变量，比如 `CONFIG_PRINTK`，而不会详细说明配置变量的完整路径。可以使用不同 UI 的搜索接口来定位配置变量路径。
- en: 'When you save your changes, a new `.config` file is created on the kernel''s
    `build` directory, which you can find using the following command:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存更改时，一个新的`.config`文件会在内核的`build`目录中创建，你可以使用以下命令找到它：
- en: '[PRE68]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You can also modify the configuration using a graphical UI, but not from the
    BitBake command line. This is because graphical UIs need host dependencies, which
    are not natively built by Yocto.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用图形界面修改配置，但不能从BitBake命令行修改。这是因为图形界面需要主机依赖项，而Yocto没有原生构建这些依赖项。
- en: 'To make sure your Ubuntu system has the needed dependencies, execute the following
    command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的Ubuntu系统具备所需的依赖项，请执行以下命令：
- en: '[PRE69]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then change to the kernel `build` directory, which you found before, with:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 然后切换到之前找到的内核`build`目录，使用以下命令：
- en: '[PRE70]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, run the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令：
- en: '[PRE71]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you encounter compilation errors, attempt to run from a new terminal that
    has not had the environment configured with the `setup-environment` script.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到编译错误，请尝试从一个未使用`setup-environment`脚本配置过环境的新终端运行。
- en: 'A new window will open with the graphical configuration user interface shown
    in the next screenshot:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 将会打开一个新窗口，显示下一个截图中的图形配置用户界面：
- en: '![How to do it...](img/5186OS_02_02.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/5186OS_02_02.jpg)'
- en: When you save your changes, the `.config` file will be updated.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存更改时，`.config`文件将被更新。
- en: To use an updated configuration, you need to take care that BitBake does not
    revert your changes when building. Refer to the *Building the Linux kernel* recipe
    in this chapter for additional details.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用更新的配置，你需要确保BitBake在构建时不会还原你的更改。有关更多细节，请参考本章中的*构建Linux内核*配方。
- en: There's more...
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can make your kernel changes permanent with the following steps:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下步骤使内核更改永久生效：
- en: 'Create a default configuration from your `.config` file from the kernel source
    directory and a clean environment (not configured with the `setup-environment`
    script) by running:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内核源目录的`.config`文件和一个干净的环境（未使用`setup-environment`脚本进行配置）创建默认配置，方法是运行：
- en: '[PRE72]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Copy the `defconfig` file from your kernel `build` folder to your kernel recipe''s
    `defconfig` file as follows:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`defconfig`文件从你的内核`build`文件夹复制到内核配方的`defconfig`文件，如下所示：
- en: '[PRE73]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Alternatively, you may use BitBake from the `build` directory as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以按如下方式从`build`目录使用BitBake：
- en: '[PRE74]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This also creates a `defconfig` file in the Linux kernel's source directory,
    which needs to be copied to your recipe.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会在Linux内核的源代码目录中创建一个`defconfig`文件，必须将其复制到你的配方中。
- en: Using configuration fragments
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用配置片段
- en: 'The `linux-yocto` style kernels can also apply isolated kernel configuration
    changes defined in the kernel configuration fragments; for example:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`linux-yocto`风格的内核还可以应用在内核配置片段中定义的隔离内核配置更改；例如：'
- en: '[PRE75]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Kernel configuration fragments are appended to `SRC_URI` in the same way, and
    are applied over the `defconfig` file.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 内核配置片段以相同的方式附加到`SRC_URI`，并覆盖`defconfig`文件。
- en: 'The `linux-yocto` style kernels (not the one for the Wandboard though) also
    provide a set of tools to manage kernel configuration:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`linux-yocto`风格的内核（不过不包括Wandboard的那个）还提供了一套管理内核配置的工具：'
- en: 'To configure the kernel from the `defconfig` file and the supplied configuration
    fragments, execute:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从`defconfig`文件和提供的配置片段配置内核，请执行：
- en: '[PRE76]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To create a configuration fragment with your changes, execute:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建一个包含你更改的配置片段，请执行：
- en: '[PRE77]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To validate the kernel configuration, you may run:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要验证内核配置，你可以运行：
- en: '[PRE78]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Building the Linux kernel
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Linux内核
- en: In this recipe, we will go through the development workflows described earlier
    using the Linux kernel as an example.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过使用Linux内核作为示例，展示前面描述的开发工作流程。
- en: How to do it...
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will see how the following development workflows are applied to the Linux
    kernel:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下开发工作流程是如何应用于Linux内核的：
- en: External development
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部开发
- en: Working directory development
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: External source development
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部源开发
- en: How it works...
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's explain the three methodologies listed previously in detail.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释之前列出的三种方法。
- en: External development
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部开发
- en: 'When compiling outside of the Yocto build environment, we can still use the
    Yocto-provided toolchain to build. The process is as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Yocto构建环境外编译时，我们仍然可以使用Yocto提供的工具链进行构建。过程如下：
- en: We will use the Yocto project cross-compilation toolchain already installed
    in your host.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用已经安装在主机上的Yocto项目交叉编译工具链。
- en: 'Clone the `wandboard-org linux-wandboard` repository locally:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地克隆 `wandboard-org linux-wandboard` 仓库：
- en: '[PRE79]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Go to the branch specified in the `linux-wandboard_3.10.17.bb` recipe:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `linux-wandboard_3.10.17.bb` 配方中指定的分支：
- en: '[PRE80]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Compile the kernel source as follows:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤编译内核源代码：
- en: 'Prepare the environment as follows:'
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下步骤准备环境：
- en: '[PRE81]'
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Configure the kernel with the default machine configuration:'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认机器配置配置内核：
- en: '[PRE82]'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Compile the kernel image, modules, and the device tree file with:'
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令编译内核镜像、模块和设备树文件：
- en: '[PRE83]'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You can optionally pass a `-jN` argument to make to build multithreaded.
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以选择传递 `-jN` 参数给 make 以进行多线程构建。
- en: This will build the kernel's zImage, modules, and device tree files.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将构建内核的 zImage、模块和设备树文件。
- en: Note
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Older Yocto environment setup scripts set the `LD` variable to use `gcc`, but
    the Linux kernel uses `ld` instead. If your compilation is failing, try the following
    before running `make`:'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 较旧的 Yocto 环境设置脚本将 `LD` 变量设置为使用 `gcc`，但 Linux 内核使用的是 `ld`。如果你的编译失败，请在运行 `make`
    之前尝试以下操作：
- en: '[PRE84]'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To build only modules, you may run:'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若要仅构建模块，你可以运行：
- en: '[PRE85]'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And to build only device tree files, you may run:'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果只需要构建设备树文件，你可以运行：
- en: '[PRE86]'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Copy the kernel image and device tree file to the TFTP root to test using network
    booting:'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将内核镜像和设备树文件复制到 TFTP 根目录，以便使用网络启动进行测试：
- en: '[PRE87]'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Some other embedded Linux targets might need to compile a uImage if the U-Boot
    bootloader is not compiled with zImage booting support:'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些其他嵌入式 Linux 目标可能需要编译 uImage，特别是当 U-Boot 引导加载程序没有编译支持 zImage 启动时：
- en: '[PRE88]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `mkimage` tool is part of the Yocto toolchain when built with the FSL community
    BSP. We will see how to build and install an SDK in the *Preparing and using an
    SDK* recipe in [Chapter 4](ch04.html "Chapter 4. Application Development"), *Application
    Development*.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mkimage` 工具是 Yocto 工具链的一部分，当使用 FSL 社区 BSP 构建时。我们将在[第 4 章](ch04.html "第 4 章：应用开发")的
    *准备和使用 SDK* 配方中看到如何构建和安装 SDK，*应用开发*。'
- en: 'If it is not included in your toolchain, you can install the tool in your host
    using the following command:'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果它不包含在你的工具链中，你可以使用以下命令在主机上安装该工具：
- en: '[PRE89]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`LOADADDR` is the U-Boot entry point; that is, the address where U-Boot will
    place the kernel in memory. It is defined in the `meta-fsl-arm imx-base.inc` file:'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LOADADDR` 是 U-Boot 的入口点；也就是 U-Boot 将内核放置到内存中的地址。它在 `meta-fsl-arm imx-base.inc`
    文件中定义：'
- en: '[PRE90]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: External source development
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部源代码开发
- en: As we did with U-Boot before, we will use the Yocto build system, pointing it
    to a local directory with a clone of the Linux source repository. We will use
    the local Git repository cloned in the earlier section.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在 U-Boot 中所做的，我们将使用 Yocto 构建系统，指向包含 Linux 源代码仓库克隆的本地目录。我们将使用之前部分克隆的本地
    Git 仓库。
- en: 'We configure for external development in our `conf/local.conf` file using the
    following code:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `conf/local.conf` 文件中使用以下代码来配置外部开发：
- en: '[PRE91]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Tip
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to remove this configuration when using the working directory development
    methodology explained next in this recipe.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在使用下文解释的工作目录开发方法时，删除此配置。
- en: But, just as before, the compilation fails with U-Boot. In this case, the linux-wandboard
    recipe, not being a `linux-yocto` style recipe, is not prepared for external source
    compilation and it fails in the configuration task.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如之前一样，编译在 U-Boot 上失败。在这种情况下，linux-wandboard 配方由于不是 `linux-yocto` 样式的配方，因此没有准备好进行外部源代码编译，并且在配置任务时失败。
- en: Kernel developers prefer to compile the kernel externally as we saw earlier,
    so this scenario is not likely to be fixed soon.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 内核开发者通常更倾向于外部编译内核，正如我们之前看到的，因此这种情况可能不会很快得到修复。
- en: Working directory development
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作目录开发
- en: Typically we work with patches and use this development workflow when we have
    a small amount of changes or we don't own the source repository.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在我们有少量更改或不拥有源代码仓库时，我们会使用补丁并采用这种开发工作流。
- en: 'A typical workflow when working on a modification would be:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理修改时，典型的工作流会是：
- en: 'Start the kernel package compilation from scratch:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从头开始启动内核包的编译：
- en: '[PRE92]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This will erase the `build` folder, shared state cache, and downloaded package
    source.
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将清除 `build` 文件夹、共享状态缓存以及下载的包源。
- en: 'Configure the kernel as follows:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤配置内核：
- en: '[PRE93]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This will convert the machine `defconfig` file into a `.config` file and call
    `oldconfig` to validate the configuration with the kernel source.
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把机器 `defconfig` 文件转换为 `.config` 文件，并调用 `oldconfig` 来验证与内核源代码的配置。
- en: 'You can optionally add your own configuration changes with:'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以选择性地通过以下方式添加自定义配置更改：
- en: '[PRE94]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Start a development shell on the kernel:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内核上启动开发 shell：
- en: '[PRE95]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This will fetch, unpack, and patch the kernel sources and spawn a new shell
    with the environment ready for kernel compilation. The new shell will change to
    the kernel `build` directory which contains a local Git repository.
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将获取、解压并修补内核源代码，并启动一个新的shell，环境已准备好进行内核编译。新的shell将切换到包含本地Git仓库的内核`build`目录。
- en: Perform our modifications, including kernel configuration changes.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行我们的修改，包括内核配置更改。
- en: 'Leave the devshell open and go back to the terminal with the sourced Yocto
    environment to compile the source without erasing our modifications as follows:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持devshell打开，然后返回到已加载Yocto环境的终端，以便在不删除我们修改的情况下编译源代码，如下所示：
- en: '[PRE96]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note the capital `C`. This invokes the compile task but also all the tasks that
    follow it.
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意大写字母`C`。这将调用编译任务以及其后所有任务。
- en: The newly compiled kernel image is available under `tmp/deploy/images/wandboard-quad`.
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新编译的内核镜像可在`tmp/deploy/images/wandboard-quad`下找到。
- en: 'Test your changes. Typically, we would work from a network-booted system, so
    we would copy the kernel image and the device tree file to the TFTP server root
    and boot the target with them using the following command:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试您的更改。通常，我们会在一个网络引导的系统上工作，因此我们会将内核镜像和设备树文件复制到TFTP服务器根目录，并使用以下命令引导目标：
- en: '[PRE97]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Refer to the *Configuring network booting for a development setup* recipe in
    [Chapter 1](ch01.html "Chapter 1. The Build System"), *The Build System* for details.
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考[第1章](ch01.html "第1章。构建系统")中的*配置网络引导开发环境*食谱，了解详细信息，*构建系统*。
- en: 'Alternatively, the U-Boot bootloader can boot a Linux zImage kernel from memory
    with its corresponding device tree using the following syntax:'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，U-Boot引导加载程序可以使用以下语法，从内存中引导带有相应设备树的Linux zImage内核：
- en: '[PRE98]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'For example, we can fetch images from TFTP and boot the Wandboard images as
    follows:'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我们可以从TFTP获取镜像并按如下方式引导Wandboard镜像：
- en: '[PRE99]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: If we were using an initramdisk, we would pass it as the second argument. Since
    we aren't, we use a dash instead.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们使用的是initramdisk，我们将其作为第二个参数传递。由于我们没有使用，我们改用破折号。
- en: 'The command to boot a uImage Linux kernel image from memory would use `bootm`
    instead, as in:'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从内存中引导uImage Linux内核镜像的命令应使用`bootm`，例如：
- en: '[PRE100]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Go back to the devshell and commit your change to the local Git repository:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到devshell并将您的更改提交到本地Git仓库：
- en: '[PRE101]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Generate a patch into the kernel recipe patch directory:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将补丁生成到内核食谱的补丁目录中：
- en: '[PRE102]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Finally, add the patch to the kernel recipe as previously described.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将补丁添加到内核食谱中，如前所述。
- en: Building external kernel modules
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建外部内核模块
- en: The Linux kernel has the ability to load modules at runtime that extend the
    kernel functionality. Kernel modules share the kernel's address space and have
    to be linked against the kernel they are going to be loaded onto. Most device
    drivers in the Linux kernel can either be compiled into the kernel itself (built-in)
    or as loadable kernel modules that need to be placed in the root filesystem under
    the `/lib/modules` directory.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核具有在运行时加载扩展内核功能的模块的能力。内核模块共享内核的地址空间，并且必须与其将要加载的内核进行链接。Linux内核中的大多数设备驱动程序可以被编译成内核本身（内建）或作为需要放置在根文件系统下`/lib/modules`目录中的可加载内核模块。
- en: The recommended approach to develop and distribute a kernel module is to do
    it with the kernel source. A module in the kernel tree uses the kernel's kbuild
    system to build itself, so as long as it is selected as module in the kernel configuration
    and the kernel has module support enabled, Yocto will build it.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和分发内核模块的推荐方法是与内核源代码一起进行。内核树中的模块使用内核的kbuild系统来构建自己，因此，只要它在内核配置中被选为模块，并且内核启用了模块支持，Yocto就会构建它。
- en: However, it is not always possible to develop a module in the kernel. Common
    examples are hardware manufacturers who provide Linux drivers for a wide variety
    of kernel versions and have an internal development process separated from the
    kernel community. The internal development work is usually released first as an
    external out-of-tree module, although it is common for some or all of these internal
    developments to finish up in the mainstream kernel eventually. However, upstreaming
    is a slow process and hardware companies will therefore prefer to develop internally
    first.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非总是可以在内核中开发模块。常见的例子是硬件制造商为多种内核版本提供Linux驱动程序，并且它们的内部开发过程与内核社区分离。内部开发工作通常首先作为外部树外模块发布，尽管一些或所有这些内部开发最终会进入主流内核。然而，上游提交是一个缓慢的过程，因此硬件公司通常会优先在内部开发。
- en: It's worth remembering that the Linux kernel is covered under a GPLv2 license,
    so Linux kernel modules should be released with a compatible license. We will
    cover licenses in more detail in the following chapters.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，Linux内核受GPLv2许可证保护，因此Linux内核模块应当以兼容的许可证发布。我们将在后续章节中详细介绍许可证问题。
- en: Getting ready
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To compile an external kernel module with Yocto, we first need to know how
    we would link the module source with the kernel itself. An external kernel module
    is also built using the kbuild system of the Linux kernel it is going to be linked
    against, so the first thing we need is a `Makefile`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Yocto编译外部内核模块，首先需要了解如何将模块源代码与内核本身链接。外部内核模块也是使用它将要链接的Linux内核的kbuild系统构建的，因此我们首先需要一个`Makefile`：
- en: '[PRE103]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The `Makefile` file just wraps the `make` command used to compile a module
    on a Linux system:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`Makefile`文件仅包装了用于在Linux系统上编译模块的`make`命令：'
- en: '[PRE104]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Here, `make` is instructed to build in the location of the kernel source, and
    the `M` argument tells kbuild it is building a module at the specified location.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`make`指令会在内核源代码所在的位置进行构建，而`M`参数告诉kbuild它正在指定位置构建一个模块。
- en: 'And then we code the source of the module itself (`hello_world.c`):'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们编写模块源代码本身（`hello_world.c`）：
- en: '[PRE105]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'It''s worth remembering that we need to compile against a kernel source that
    has already been built. Use the following steps for compilation:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，我们需要使用已经构建的内核源代码进行编译。使用以下步骤进行编译：
- en: 'We prepare the environment using the Yocto toolchain environment setup script:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Yocto工具链环境设置脚本来准备环境：
- en: '[PRE106]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Next we build the module. We execute the following from the module source directory:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们构建模块。从模块源目录执行以下命令：
- en: '[PRE107]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: How to do it...
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Once we know how to compile the module externally, we are ready to prepare a
    Linux kernel module Yocto recipe for it.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道如何外部编译模块，我们就准备好为其准备一个Linux内核模块Yocto配方。
- en: 'We place the module source file and `Makefile` in `recipes-kernel/hello-world/files/`
    inside our `meta-bsp-custom` layer. We then create a `recipes-kernel/hello-world/hello-world.bb`
    file with the following content:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模块源文件和`Makefile`放置在`meta-bsp-custom`层中的`recipes-kernel/hello-world/files/`目录下。然后，我们创建一个`recipes-kernel/hello-world/hello-world.bb`文件，内容如下：
- en: '[PRE108]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The recipe defines the source directory and the two module files after inheriting
    the `module` class, which takes care of everything. The `KERNEL_SRC` argument
    in our `Makefile` is set by the module class to `STAGING_KERNEL_DIR`, the location
    where the kernel class places the Linux kernel headers needed for external module
    compilation.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方在继承`module`类后定义了源目录和两个模块文件，该类负责所有事务。`Makefile`中的`KERNEL_SRC`参数由模块类设置为`STAGING_KERNEL_DIR`，即内核类放置用于外部模块编译所需的Linux内核头文件的位置。
- en: 'We build it with the following command:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令进行构建：
- en: '[PRE109]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The resulting module is called `hello_world.ko`, with the `kernel-module` prefix
    being added to the package name by the module `bbclass` automatically.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模块名为`hello_world.ko`，`bbclass`会自动在包名中添加`kernel-module`前缀。
- en: There's more...
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The previous instructions will build the module but will not install it in the
    root filesystem. For that, we need to add a dependency to the root filesystem.
    This is usually done in machine configuration files using `MACHINE_ESSENTIAL`
    (for modules that are needed to boot) or `MACHINE_EXTRA` (if they are not essential
    for boot but needed otherwise), variables.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指令将构建模块，但不会将其安装到根文件系统中。为此，我们需要将根文件系统添加为依赖项。通常在机器配置文件中使用`MACHINE_ESSENTIAL`（用于启动时所需的模块）或`MACHINE_EXTRA`（如果它们对启动不是必需的，但其他情况下需要）变量来完成此操作。
- en: 'The dependencies that are essential to boot are:'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些对启动是必需的依赖项有：
- en: '`MACHINE_ESSENTIAL_EXTRA_RDEPENDS`: The build will fail if they can''t be found'
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MACHINE_ESSENTIAL_EXTRA_RDEPENDS`：如果找不到它们，构建将失败'
- en: '`MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS`: The build will not fail if they can''t
    be found'
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS`：如果找不到它们，构建不会失败'
- en: 'The dependencies that are not essential to boot are:'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些对启动不是必需的依赖项有：
- en: '`MACHINE_EXTRA_RDEPENDS`: The build will fail if they can''t be found'
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MACHINE_EXTRA_RDEPENDS`：如果找不到它们，构建将失败'
- en: '`MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS`: The build will not fail if they can''t
    be found'
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS`：如果找不到它们，构建不会失败'
- en: Debugging the Linux kernel and modules
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Linux内核和模块
- en: We will highlight some of the most common methods employed by kernel developers
    to debug kernel issues.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点介绍内核开发人员常用的一些调试内核问题的方法。
- en: How to do it...
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Above all, debugging the Linux kernel remains a manual process, and the most
    important developer tool is the ability to print debug messages.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，调试Linux内核仍然是一个手动过程，最重要的开发者工具是能够打印调试信息。
- en: The kernel uses the `printk` function, which is very similar syntactically to
    the `printf` function call from standard C libraries, with the addition of an
    optional log level. The allowed formats are documented in the kernel source under
    `Documentation/printk-formats.txt`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 内核使用`printk`函数，它在语法上与标准C库中的`printf`函数调用非常相似，唯一不同的是它增加了一个可选的日志级别。允许的格式在内核源代码的`Documentation/printk-formats.txt`中有详细记录。
- en: The `printk` functionality needs to be compiled into the kernel with the `CONFIG_PRINTK`
    configuration variable. You can also configure the Linux kernel to prepend a precise
    timestamp to every message with the `CONFIG_PRINTK_TIME` configuration variable,
    or even better, with the `printk.time` kernel command-line argument or through
    sysfs under `/sys/module/printk/parameters`. Usually all kernels contain `printk`
    support, and the Wandboard kernel does too, although it is commonly removed on
    production kernels for small embedded systems.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`printk`功能需要在内核中通过`CONFIG_PRINTK`配置变量进行编译。你还可以通过`CONFIG_PRINTK_TIME`配置变量配置Linux内核为每条消息前面加上精确的时间戳，或者更好地，通过`printk.time`内核命令行参数或通过`/sys/module/printk/parameters`下的sysfs来实现。通常所有内核都包含`printk`支持，Wandboard内核也包括，尽管它通常会在生产内核中为小型嵌入式系统去除。'
- en: The `printk` function can be used in any context, interrupt, **non-maskable
    interrupt** (**NMI**), or scheduler. Note that using it inside interrupt context
    is not recommended.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`printk`函数可以在任何上下文中使用，包括中断、**不可屏蔽中断**（**NMI**）或调度器。请注意，在中断上下文中使用它并不推荐。'
- en: 'A useful debug statement to be used during development could be:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在开发过程中有用的调试语句可能是：
- en: '[PRE110]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The first thing to note is that there is no comma between the log level macro
    and the print format. We then print the function and line where the debug statement
    is placed and then the parent function. Finally, we print the variables we are
    actually interested in.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，日志级别宏和打印格式之间没有逗号。然后，我们打印调试语句所在的函数和行号，以及父函数。最后，打印我们实际关注的变量。
- en: How it works...
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The available log levels in `printk` are presented in the following table:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`printk`中可用的日志级别：
- en: '| Type | Symbol | Description |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 符号 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Emergency | `KERN_EMERG` | System is unstable and about to crash |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| 紧急 | `KERN_EMERG` | 系统不稳定且即将崩溃 |'
- en: '| Alert | `KERN_ALERT` | Immediate action is needed |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| 警告 | `KERN_ALERT` | 需要立即采取行动 |'
- en: '| Critical | `KERN_CRIT` | Critical software or hardware failure |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| 严重 | `KERN_CRIT` | 严重的软件或硬件故障 |'
- en: '| Error | `KERN_ERR` | Error condition |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | `KERN_ERR` | 错误条件 |'
- en: '| Warning | `KERN_WARNING` | Nothing serious, but might indicate a problem
    |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| 警告 | `KERN_WARNING` | 没有严重问题，但可能暗示有问题 |'
- en: '| Notice | `KERN_NOTICE` | Nothing serious, but user should take note |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| 通知 | `KERN_NOTICE` | 没有什么严重问题，但用户应注意 |'
- en: '| Information | `KERN_INFO` | System information |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| 信息 | `KERN_INFO` | 系统信息 |'
- en: '| Debug | `KERN_DEBUG` | Debug messages |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | `KERN_DEBUG` | 调试信息 |'
- en: If no log level is specified, the default log message as configured in the kernel
    configuration is used. By default, this is `KERN_WARNING`.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定日志级别，将使用内核配置中配置的默认日志消息。默认情况下，这是`KERN_WARNING`。
- en: All `printk` statements go to the kernel log buffer, which may wrap around,
    except debug statements, which only appear if the `DEBUG` symbol is defined. We
    will see how to enable kernel debug messages soon. The `printk` log buffer must
    be a power of two, and its size should be set in the `CONFIG_LOG_BUF_SHIFT` kernel
    configuration variable. You may modify it with the `log_buf_len` kernel command-line
    parameter.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`printk`语句都会写入内核日志缓冲区，该缓冲区可能会覆盖，调试语句除外，只有在定义了`DEBUG`符号时才会出现。稍后我们将看到如何启用内核调试消息。`printk`日志缓冲区的大小必须是2的幂，并且其大小应该在`CONFIG_LOG_BUF_SHIFT`内核配置变量中设置。你可以使用`log_buf_len`内核命令行参数进行修改。
- en: We print the kernel log buffer with the `dmesg` command. Also, a Yocto user
    space will have a kernel log daemon running that will log kernel messages to disk
    under `/var/log/messages`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`dmesg`命令打印内核日志缓冲区。此外，Yocto用户空间将运行一个内核日志守护进程，该进程会将内核消息记录到`/var/log/messages`中的磁盘。
- en: Messages above the current console log level will also appear on the console
    immediately. The `ignore_loglevel` kernel command-line argument, also available
    under `/sys/module/printk/parameters`, may be used to print all kernel messages
    to the console independently of the log level.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 超过当前控制台日志级别的消息也会立即出现在控制台上。`ignore_loglevel` 内核命令行参数（也可以在 `/sys/module/printk/parameters`
    下找到）可用于打印所有内核消息到控制台，无论日志级别如何。
- en: 'You can also change the log level at runtime via the `proc` filesystem. The
    `/proc/sys/kernel/printk` file contains the current, default, minimum, and boot
    time default log levels. To change the current log level to the maximum, execute:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 `proc` 文件系统在运行时更改日志级别。`/proc/sys/kernel/printk` 文件包含当前日志级别、默认日志级别、最小日志级别以及启动时的默认日志级别。要将当前日志级别更改为最大值，请执行：
- en: '[PRE111]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'You can also set the console log level with the `dmesg` tool as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 `dmesg` 工具如下设置控制台日志级别：
- en: '[PRE112]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: To make the change persistent, you can pass a log level command-line parameter
    to the kernel, or on some Yocto root filesystem images, you could also use a `/etc/sysctl.conf`
    file (those that install the `procps` package).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 要使更改持久化，你可以将日志级别命令行参数传递给内核，或者在某些 Yocto 根文件系统镜像中，你也可以使用 `/etc/sysctl.conf` 文件（这些镜像安装了
    `procps` 包）。
- en: There's more...
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Linux drivers do not use the `printk` function directly. They use, in order
    of preference, subsystem-specific messages (such as `netdev` or `v4l)` or the
    `dev_*` and `pr_*` family of functions. The latter are described in the following
    table:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 驱动程序不会直接使用 `printk` 函数。它们按优先顺序使用特定子系统的消息（如 `netdev` 或 `v4l`）或 `dev_*`
    和 `pr_*` 函数族。后者在下表中描述：
- en: '| Device message | Generic message | Printk symbol |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| 设备消息 | 一般消息 | Printk 符号 |'
- en: '| --- | --- | --- |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `dev_emerg` | `pr_emerg` | `KERN_EMERG` |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| `dev_emerg` | `pr_emerg` | `KERN_EMERG` |'
- en: '| `dev_alert` | `pr_alert` | `KERN_ALERT` |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| `dev_alert` | `pr_alert` | `KERN_ALERT` |'
- en: '| `dev_crit` | `pr_crit` | `KERN_CRIT` |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| `dev_crit` | `pr_crit` | `KERN_CRIT` |'
- en: '| `dev_err` | `pr_err` | `KERN_ERR` |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| `dev_err` | `pr_err` | `KERN_ERR` |'
- en: '| `dev_warn` | `pr_warn` | `KERN_WARNING` |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `dev_warn` | `pr_warn` | `KERN_WARNING` |'
- en: '| `dev_notice` | `pr_notice` | `KERN_NOTICE` |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| `dev_notice` | `pr_notice` | `KERN_NOTICE` |'
- en: '| `dev_info` | `pr_info` | `KERN_INFO` |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| `dev_info` | `pr_info` | `KERN_INFO` |'
- en: '| `dev_dbg` | `pr_debug` | `KERN_DEBUG` |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| `dev_dbg` | `pr_debug` | `KERN_DEBUG` |'
- en: 'To enable the debug messages within a driver, you may do either of these:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用驱动程序中的调试消息，你可以执行以下任意操作：
- en: 'Define `DEBUG` in a macro before any other header file in your driver source,
    as follows:'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在驱动源代码中，在任何其他头文件之前定义 `DEBUG` 宏，如下所示：
- en: '[PRE113]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Use the dynamic debug kernel feature. You can then enable/disable all `dev_dbg`
    and `pr_debug` debug messages with granularity through `debugfs`.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态调试内核功能。然后，你可以通过 `debugfs` 按粒度启用/禁用所有 `dev_dbg` 和 `pr_debug` 调试消息。
- en: Using dynamic debug
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用动态调试
- en: 'To use the dynamic debug functionality in the Linux kernel, follow these steps:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 内核中使用动态调试功能，请按以下步骤操作：
- en: Make sure your kernel is compiled with dynamic debugging (`CONFIG_DYNAMIC_DEBUG`).
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的内核已启用动态调试功能（`CONFIG_DYNAMIC_DEBUG`）。
- en: 'Mount the debug filesystem if it hasn''t already been mounted:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未挂载调试文件系统，请先挂载：
- en: '[PRE114]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Configure the debug though the `dynamic_debug/control` folder. It accepts a
    whitespace-separated sequence of words:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `dynamic_debug/control` 文件夹配置调试。它接受由空格分隔的单词序列：
- en: '`func <function name>`'
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func <function name>`'
- en: '`file <filename>`'
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file <filename>`'
- en: '`module <module name>`'
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module <module name>`'
- en: '`format <pattern>`'
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format <pattern>`'
- en: '`line <line or line range>`'
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line <line or line range>`'
- en: '`+ <flag>`: This adds the specified flag'
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+ <flag>`：添加指定的标志'
- en: '`- <flag>`: This one removes the specified flag'
  id: totrans-575
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- <flag>`：移除指定的标志'
- en: '`= <flag>`: This sets the specified flag'
  id: totrans-576
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`= <flag>`：设置指定的标志'
- en: 'The flags are defined as follows:'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 各种标志定义如下：
- en: '`f`: This flag includes the function name in the message'
  id: totrans-578
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`：此标志在消息中包含函数名'
- en: '`l`: This flag includes the line number in the message'
  id: totrans-579
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l`：此标志在消息中包含行号'
- en: '`m`: This flag includes the module name in the message'
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`：此标志在消息中包含模块名'
- en: '`p`: This flag enables the debug message'
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`：此标志启用调试消息'
- en: '`t`: This flag includes the thread ID in non-interrupt context messages'
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`：此标志在非中断上下文消息中包含线程 ID'
- en: By default all debug messages are disabled. The control file contains all the
    available debug points, and by default they have no flags enabled (marked as `=`_).
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，所有调试消息都是禁用的。控制文件包含所有可用的调试点，默认情况下它们没有启用任何标志（标记为 `=`_）。
- en: 'Now we will enable the debug as follows:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将按如下方式启用调试：
- en: 'Enable all debug statements in a file:'
  id: totrans-585
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用文件中的所有调试语句：
- en: '[PRE115]'
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Optionally, you could run a specific debug statement:'
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，您可以运行特定的调试语句：
- en: '[PRE116]'
  id: totrans-588
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To list all enabled debug statements, we use the following command:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出所有启用的调试语句，我们使用以下命令：
- en: '[PRE117]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: To make the debug changes persistent, we can pass `dyndbg="<query>"` or `module.dyndbg="<query>"`
    to the kernel in the command-line arguments.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 要使调试更持久，我们可以将 `dyndbg="<query>"` 或 `module.dyndbg="<query>"` 传递给内核在命令行参数中。
- en: Note that the query string needs to be passed surrounded by quotes so that it
    is correctly parsed. You can concatenate more than one query in the command-line
    argument by using a semicolon to separate them; for example, `dyndbg="file mxc_v4l2_capture.c
    +pfl; file ipu_bg_overlay_sdc.c +pfl"`
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，查询字符串需要用引号括起来传递，以便正确解析。 您可以使用分号将多个查询连接在命令行参数中； 例如，`dyndbg="file mxc_v4l2_capture.c
    +pfl; file ipu_bg_overlay_sdc.c +pfl"`
- en: Rate-limiting debug messages
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限速调试消息
- en: 'There are rate-limiting and one-shot extensions to the `dev_*`, `pr_*`, and
    `printk` family of functions:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `dev_*`、`pr_*` 和 `printk` 函数族，有限速和单次扩展：
- en: '`printk_ratelimited()`, `pr_*_ratelimited()`, and `dev_*_ratelimited()` print
    no more than 10 times in a 5 * HZ interval'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printk_ratelimited()`、`pr_*_ratelimited()` 和 `dev_*_ratelimited()` 在 5 * HZ
    的间隔内最多打印 10 次'
- en: '`printk_once()`, `pr_*_once()`, and `dev_*_once()` will print only once.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printk_once()`、`pr_*_once()` 和 `dev_*_once()` 只会打印一次。'
- en: And you also have utility functions to dump a buffer in hexadecimal; for example,
    `print_hex_dump_bytes()`.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用十六进制转储缓冲区的实用函数； 例如，`print_hex_dump_bytes()`.
- en: See also
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The dynamic debug is documented in the Linux kernel source under `Documentation/dynamic-debug-howto.txt`
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态调试在 Linux 内核源码中有详细记录，位于 `Documentation/dynamic-debug-howto.txt`
- en: Debugging the Linux kernel booting process
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Linux 内核引导过程
- en: We have seen the most general techniques for debugging the Linux kernel. However,
    some special scenarios require the use of different methods. One of the most common
    scenarios in embedded Linux development is the debugging of the booting process.
    This recipe will explain some of the techniques used to debug the kernel's booting
    process.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了调试 Linux 内核的最常见技术。 然而，在一些特殊场景中，需要使用不同的方法。 在嵌入式 Linux 开发中最常见的场景之一是调试引导过程。
    本文将解释用于调试内核引导过程的一些技术。
- en: How to do it...
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: A kernel crashing on boot usually provides no output whatsoever on the console.
    As daunting as that may seem, there are techniques we can use to extract debug
    information. Early crashes usually happen before the serial console has been initialized,
    so even if there were log messages, we would not see them. The first thing we
    will show is how to enable early log messages that do not need the serial driver.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 引导时内核崩溃通常不会在控制台上提供任何输出。 尽管这看起来很令人生畏，但我们可以使用技术提取调试信息。 早期崩溃通常发生在串行控制台初始化之前，因此即使有日志消息，我们也看不到它们。
    我们将首先展示如何启用不需要串行驱动程序的早期日志消息。
- en: In case that is not enough, we will also show techniques to access the log buffer
    in memory.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，我们还将展示访问内存中日志缓冲区的技术。
- en: How it works...
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运作...
- en: Debugging booting problems have two distinctive phases, before and after the
    serial console is initialized. After the serial is initialized and we can see
    serial output from the kernel, debugging can use the techniques described earlier.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 调试引导问题有两个明显的阶段，在串行控制台初始化之前和之后。 在串行控制台初始化之后，我们可以看到内核的串行输出，可以使用早期描述的技术进行调试。
- en: Before the serial is initialized, however, there is a basic **UART** support
    in ARM kernels that allows you to use the serial from early boot. This support
    is compiled in with the `CONFIG_DEBUG_LL` configuration variable.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在串行初始化之前，ARM 内核中有基本的 **UART** 支持，允许您从早期引导开始使用串行。 此支持与 `CONFIG_DEBUG_LL` 配置变量一起编译进去。
- en: This adds supports for a debug-only series of assembly functions that allow
    you to output data to a UART. The low-level support is platform specific, and
    for the i.MX6, it can be found under `arch/arm/include/debug/imx.S`. The code
    allows for this low-level UART to be configured through the `CONFIG_DEBUG_IMX_UART_PORT`
    configuration variable.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了对调试专用系列的汇编函数的支持，允许您向 UART 输出数据。 低级支持是平台特定的，对于 i.MX6，可以在 `arch/arm/include/debug/imx.S`
    中找到。 该代码允许通过 `CONFIG_DEBUG_IMX_UART_PORT` 配置变量配置此低级 UART。
- en: 'We can use this support directly by using the `printascii` function as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式直接使用 `printascii` 函数：
- en: '[PRE118]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'However, much more preferred would be to use the `early_print` function, which
    makes use of the function explained previously and accepts formatted input in
    `printf` style; for example:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更推荐的做法是使用 `early_print` 函数，该函数利用前面解释的函数，并接受 `printf` 风格的格式化输入；例如：
- en: '[PRE119]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Dumping the kernel's printk buffer from the bootloader
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从引导加载程序中转储内核的 printk 缓冲区
- en: Another useful technique to debug Linux kernel crashes at boot is to analyze
    the kernel log after the crash. This is only possible if the RAM memory is persistent
    across reboots and does not get initialized by the bootloader.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 Linux 内核启动时崩溃的另一种有用方法是分析崩溃后的内核日志。这只有在 RAM 内存在重启后保持持久性并且不被引导加载程序初始化的情况下才可能实现。
- en: As U-Boot keeps the memory intact, we can use this method to peek at the kernel
    login memory in search of clues.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 U-Boot 保持内存不变，我们可以使用此方法查看内核登录内存，以寻找线索。
- en: Looking at the kernel source, we can see how the log ring buffer is set up in
    `kernel/printk/printk.c` and also note that it is stored in `__log_buf`.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 查看内核源代码，我们可以看到日志环形缓冲区是如何在`kernel/printk/printk.c`中设置的，并且注意到它存储在`__log_buf`中。
- en: 'To find the location of the kernel buffer, we will use the `System.map` file
    created by the Linux build process, which maps symbols with virtual addresses
    using the following command:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到内核缓冲区的位置，我们将使用 Linux 构建过程创建的 `System.map` 文件，它通过以下命令映射符号与虚拟地址：
- en: '[PRE120]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To convert the virtual address to physical address, we look at how `__virt_to_phys()`
    is defined for ARM:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 要将虚拟地址转换为物理地址，我们查看 ARM 中 `__virt_to_phys()` 是如何定义的：
- en: '[PRE121]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `PAGE_OFFSET` variable is defined in the kernel configuration as:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`PAGE_OFFSET` 变量在内核配置中定义如下：'
- en: '[PRE122]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Some of the ARM platforms, like the i.MX6, will dynamically patch the `__virt_to_phys()`
    translation at runtime, so `PHYS_OFFSET` will depend on where the kernel is loaded
    into memory. As this can vary, the calculation we just saw is platform specific.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 ARM 平台，如 i.MX6，会在运行时动态修补 `__virt_to_phys()` 转换，因此 `PHYS_OFFSET` 将取决于内核加载到内存中的位置。由于这一点可能有所不同，刚才看到的计算是平台特定的。
- en: For the Wandboard, the physical address for 0x80f450c0 is 0x10f450c0.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Wandboard，0x80f450c0 的物理地址是 0x10f450c0。
- en: 'We can then force a reboot using a magic *SysRq* key, which needs to be enabled
    in the kernel configuration with `CONFIG_MAGIC_SYSRQ`, but is enabled in the Wandboard
    by default:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过强制重启使用一个神奇的 *SysRq* 键，这个键需要在内核配置中启用 `CONFIG_MAGIC_SYSRQ`，但是在 Wandboard
    上默认启用：
- en: '[PRE123]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We then dump that memory address from U-Boot as follows:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过以下方式从 U-Boot 转储该内存地址：
- en: '[PRE124]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: There's more...
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Another method is to store the kernel log messages and kernel panics or oops
    into persistent storage. The Linux kernel's persistent store support (`CONFIG_PSTORE`)
    allows you to log in to the persistent memory kept across reboots.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将内核日志消息和内核 panic 或 oops 信息存储到持久存储中。Linux 内核的持久存储支持（`CONFIG_PSTORE`）允许你将数据记录到跨重启保持的持久内存中。
- en: To log panic and oops messages into persistent memory, we need to configure
    the kernel with the `CONFIG_PSTORE_RAM` configuration variable, and to log kernel
    messages, we need to configure the kernel with `CONFIG_PSTORE_CONSOLE`.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 panic 和 oops 消息记录到持久内存中，我们需要配置内核并启用 `CONFIG_PSTORE_RAM` 配置变量，而要记录内核消息，我们则需要配置内核启用
    `CONFIG_PSTORE_CONSOLE`。
- en: 'We then need to configure the location of the persistent storage on an unused
    memory location, but keep the last 1 MB of memory free. For example, we could
    pass the following kernel command-line arguments to reserve a 128 KB region starting
    at 0x30000000:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要配置持久存储的位置，选择一个未使用的内存位置，但保持最后 1 MB 内存为空。例如，我们可以传递以下内核命令行参数，预留一个从 0x30000000
    开始的 128 KB 区域：
- en: '[PRE125]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We would then mount the persistent storage by adding it to `/etc/fstab` so
    that it is available on the next boot as well:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们会通过将其添加到 `/etc/fstab` 中来挂载持久存储，以便在下次启动时也可以使用：
- en: '[PRE126]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We then mount it as follows:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按如下方式挂载它：
- en: '[PRE127]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Next, we force a reboot with the magic *SysRq* key:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过神奇的 *SysRq* 键强制重启：
- en: '[PRE128]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'On reboot, we will see a file inside `/pstore`:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在重启时，我们会在 `/pstore` 中看到一个文件：
- en: '[PRE129]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'This will have contents such as the following:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含如下内容：
- en: '[PRE130]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We should move it out of `/pstore` or remove it completely so that it doesn't
    occupy memory.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将其移出 `/pstore` 或完全删除，以避免占用内存。
- en: Using the kernel function tracing system
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内核函数跟踪系统
- en: 'Recent versions of the Linux kernel contain a set of tracers that, by instrumenting
    the kernel, allow you to analyze different areas like:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的 Linux 内核包含一组跟踪器，通过对内核进行插桩，允许你分析不同的领域，比如：
- en: Interrupt latency
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断延迟
- en: Preemption latency
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抢占延迟
- en: Scheduling latency
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度延迟
- en: Process context switches
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程上下文切换
- en: Event tracing
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件追踪
- en: Syscalls
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用
- en: Maximum stack
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大堆栈
- en: Block layer
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块层
- en: Functions
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: The tracers have no performance overhead when not enabled.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 当追踪器未启用时，追踪器不会带来性能开销。
- en: Getting ready...
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: The tracing system can be used in a wide variety of debugging scenarios, but
    one of the most common tracers used is the function tracer. It instruments every
    kernel function with a NOP call that is replaced and used to trace the kernel
    functions when a trace point is enabled.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪系统可以用于多种调试场景，但最常用的追踪器之一是函数追踪器。它通过NOP调用对每个内核函数进行插桩，NOP调用在启用追踪点时被替换并用于追踪内核函数。
- en: To enable the function tracer in the kernel, use the `CONFIG_FUNCTION_TRACER`
    and `CONFIG_FUNCTION_GRAPH_TRACER` configuration variables.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 要在内核中启用函数追踪器，请使用`CONFIG_FUNCTION_TRACER`和`CONFIG_FUNCTION_GRAPH_TRACER`配置变量。
- en: 'The kernel tracing system is controlled via a `tracing` file in the `debug`
    filesystem, which is mounted by default on Yocto''s default images. If not, you
    can mount it with:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 内核追踪系统通过`debug`文件系统中的`tracing`文件进行控制，默认情况下Yocto的默认镜像会挂载该文件系统。如果没有，你可以通过以下命令挂载：
- en: '[PRE131]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We can list the available tracers in our kernel by executing:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下命令列出内核中可用的追踪器：
- en: '[PRE132]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: How to do it...
  id: totrans-664
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can enable a tracer by echoing its name to the `current_tracer` file. No
    tracers are enabled by default:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将追踪器的名称回显到`current_tracer`文件中来启用追踪器。默认情况下没有启用任何追踪器：
- en: '[PRE133]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'You can disable all tracers by executing the following command:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令来禁用所有追踪器：
- en: '[PRE134]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We use `echo -n` to avoid the trailing newline when echoing to files in `sysfs`.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`echo -n`来避免在通过`echo`命令向`sysfs`文件写入时产生换行符。
- en: 'To enable the function tracer, you would execute:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用函数追踪器，你需要执行：
- en: '[PRE135]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'A prettier graph can be obtained by using the function graph tracer as follows:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数图形追踪器可以获得更美观的图形，方法如下：
- en: '[PRE136]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: How it works...
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can look at the captured trace in human-readable format via the `trace`
    and `trace_pipe` files, with the latter blocking on `read` and consuming the data.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`trace`和`trace_pipe`文件查看捕获的可读格式追踪数据，后者在`read`时会阻塞并消耗数据。
- en: 'The function tracer provides the following output:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 函数追踪器提供如下输出：
- en: '[PRE137]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The format for the function tracer output is:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 函数追踪器输出的格式是：
- en: '[PRE138]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The graphical function tracer output is as follows:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 图形化函数追踪器的输出如下：
- en: '[PRE139]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The format for the grapical function tracer output is:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 图形化函数追踪器输出的格式是：
- en: '[PRE140]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: There's more...
  id: totrans-684
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The kernel tracing system allows us to insert traces in the code by using the
    `trace_printk` function call. It has the same syntax as `printk` and can be used
    in the same scenarios, interrupts, NMI, or scheduler contexts.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 内核追踪系统允许我们通过使用`trace_printk`函数调用在代码中插入追踪。它与`printk`的语法相同，可以在相同的场景中使用，如中断、NMI或调度器上下文。
- en: Its advantage is that as it prints to the tracing buffer in memory and not to
    the console, it has much lower delays than `printk`, so it is useful to debug
    scenarios where `printk` is affecting the system's behavior; for example, when
    masking a timing bug.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 它的优点是，由于它将数据输出到内存中的追踪缓冲区，而不是输出到控制台，因此比`printk`具有更低的延迟，因此它对于调试`printk`影响系统行为的场景非常有用；例如，调试时序错误。
- en: 'Tracing is enabled once a tracer is configured, but whether the trace writes
    to the ring buffer or not can be controlled. To disable the writing to the buffer,
    use the following command:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了追踪器，追踪就会被启用，但是否将追踪数据写入环形缓冲区是可以控制的。要禁用写入缓冲区，请使用以下命令：
- en: '[PRE141]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'And to re-enable it, use the following command:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新启用它，请使用以下命令：
- en: '[PRE142]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: You can also enable and disable the tracing from kernel space by using the `tracing_on`
    and `tracing_off` functions.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用`tracing_on`和`tracing_off`函数从内核空间启用和禁用追踪。
- en: Inserted traces will appear in any tracer, including the `function` tracer,
    in which case it will appear as a comment.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的追踪信息会出现在任何追踪器中，包括`function`追踪器，在这种情况下，它将作为注释出现。
- en: Filtering function traces
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤函数追踪
- en: You can get finer granularity in the functions being traced by using the dynamic
    tracer, which can be enabled with the `CONFIG_DYNAMIC_FTRACE` configuration variable.
    This is enabled with the tracing functionality by default. This adds two more
    files, `set_ftrace_filter` and `set_ftrace_notrace`. Adding functions to `set_ftrace_filter`
    will trace only those functions, and adding them to `set_ftrace_notrace` will
    not trace them, even if they are also added to `set_ftrace_filter`.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用动态跟踪器来获得更细粒度的跟踪功能，动态跟踪器可以通过配置变量`CONFIG_DYNAMIC_FTRACE`启用。默认情况下，跟踪功能启用时会自动启用此功能。它会增加两个文件，`set_ftrace_filter`和`set_ftrace_notrace`。将函数添加到`set_ftrace_filter`中将仅跟踪这些函数，而将它们添加到`set_ftrace_notrace`中则不会跟踪它们，即使它们也添加到`set_ftrace_filter`中。
- en: 'The set of available function names that can be filtered may be obtained by
    executing the following command:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 可供筛选的函数名集合可以通过执行以下命令获得：
- en: '[PRE143]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Functions can be added with:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过以下方式添加：
- en: '[PRE144]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Note that we use the concatenation operator (`>>`) so that the new function
    is appended to the existing ones.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用连接操作符（`>>`）将新函数追加到现有函数中。
- en: 'And functions can also be removed with:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以通过以下方式移除：
- en: '[PRE145]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'To remove all functions, just echo a blank line into the file:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除所有函数，只需将空行写入文件：
- en: '[PRE146]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'There is a special syntax that adds extra flexibility to the filtering: `<function>:<command>:[<parameter>]`'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的语法可以为筛选提供额外的灵活性：`<function>:<command>:[<parameter>]`
- en: 'Let''s explain each of the components individually:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别解释每个组件：
- en: '`function`: This specifies the function name. Wildcards are allowed.'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`：这指定了函数名，支持通配符。'
- en: '`command`: This has the following attributes:'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：具有以下属性：'
- en: '`mod`: This enables the given function name only in the module specified in
    the parameter'
  id: totrans-708
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod`：这只会在参数指定的模块中启用给定的函数名。'
- en: '`traceon/traceoff`: This enables or disables tracing when the specified function
    is hit the numbers of times given in the parameter, or always if no parameter
    is given.'
  id: totrans-709
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traceon/traceoff`：当指定的函数被触发给定次数时，这将启用或禁用跟踪，如果没有提供参数，则始终启用或禁用。'
- en: '`dump`: Dump the contents of the tracing buffer when the given function is
    hit.'
  id: totrans-710
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dump`：当触发指定函数时，转储跟踪缓冲区的内容。'
- en: 'Here are some examples:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例：
- en: '[PRE147]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Enabling trace options
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用跟踪选项
- en: 'Traces have a set of options that can be individually enabled in the `/sys/kernel/debug/tracing/options`
    directory. Some of the most useful options include:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪器有一组可以单独启用的选项，这些选项位于`/sys/kernel/debug/tracing/options`目录中。一些最有用的选项包括：
- en: '`print-parent`: This option displays the caller function too'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print-parent`：此选项也会显示调用者函数。'
- en: '`trace_printk`: This option disables `trace_printk` writing'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace_printk`：此选项禁用`trace_printk`的写入。'
- en: Using the function tracer on oops
  id: totrans-717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在oops上使用函数跟踪器
- en: 'Another alternative to log the kernel messages on oops or panic is to configure
    the function tracer to dump its buffer contents to the console so that the events
    leading up to the crash can be analyzed. Use the following command:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在oops或panic时记录内核消息的替代方法是配置函数跟踪器，将其缓冲区内容转储到控制台，以便分析导致崩溃的事件。使用以下命令：
- en: '[PRE148]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The `sysrq-z` combination will also dump the contents of the tracing buffer
    to the console, as does calling `ftrace_dump()` from the kernel code.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysrq-z`组合键也会将跟踪缓冲区的内容转储到控制台，调用内核代码中的`ftrace_dump()`也是如此。'
- en: Getting a stack trace for a given function
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取给定函数的堆栈跟踪
- en: 'The tracing code can create a backtrace for every function called. However,
    this is a dangerous feature and should only be used with a filtered selection
    of functions. Have a look at the following commands:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪代码可以为每个调用的函数创建回溯。然而，这是一个危险的特性，应该只在筛选后的函数选择中使用。请查看以下命令：
- en: '[PRE149]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Configuring the function tracer at boot
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在启动时配置函数跟踪器
- en: 'The function tracer can be configured in the kernel command-line arguments
    and started as early as possible in the boot process. For example, to configure
    the graphic function tracer and filter some functions, we would pass the following
    arguments from the U-Boot bootloader to the kernel:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 函数跟踪器可以在内核命令行参数中进行配置，并尽早在启动过程中启动。例如，配置图形函数跟踪器并筛选一些函数，我们可以通过以下参数从U-Boot引导加载程序传递给内核：
- en: '[PRE150]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: See also
  id: totrans-727
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: More details can be found in the kernel source documentation folder at `Documentation/trace/ftrace.txt`
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多细节可以在内核源代码的文档文件夹`Documentation/trace/ftrace.txt`中找到。
- en: Managing the device tree
  id: totrans-729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理设备树
- en: The device tree is a data structure that is passed to the Linux kernel to describe
    the physical devices in a system.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树是一种数据结构，传递给 Linux 内核，用于描述系统中的物理设备。
- en: In this recipe, we will explain how to work with device trees.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将解释如何使用设备树。
- en: Getting ready
  id: totrans-732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Devices that cannot be discovered by the CPU are handled by the platform devices
    API on the Linux kernel. The device tree replaces the legacy platform data where
    hardware characteristics were hardcoded in the kernel source so that platform
    devices can be instantiated. Before device trees came into use, the bootloader
    (for example, U-Boot) had to tell the kernel what machine type it was booting.
    Moreover, it had to pass other information such as memory size and location, kernel
    command line, and more.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 无法发现的设备由 Linux 内核中的平台设备 API 处理。设备树取代了旧有的平台数据，其中硬件特性被硬编码在内核源代码中，允许实例化平台设备。在设备树使用之前，启动加载程序（例如
    U-Boot）必须告诉内核正在启动的是哪种机器类型。此外，它还必须传递其他信息，如内存大小和位置、内核命令行等。
- en: The device tree should not be confused with the Linux kernel configuration.
    The device tree specifies what devices are available and how they are accessed,
    not whether the hardware is used.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树不应与 Linux 内核配置混淆。设备树指定了哪些设备可用以及如何访问这些设备，而不是硬件是否被使用。
- en: The device tree was first used by the PowerPC architecture and was adopted later
    on by ARM and all others, except x86\. It was defined by the Open Firmware specification,
    which defined the flattened device tree format in **Power.org Standard for Embedded
    Power Architecture Platform Requirements** (**ePAPR**), which describes an interface
    between a boot program and a client.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树最早由 PowerPC 架构使用，后来被 ARM 和其他架构（除了 x86）采用。它由 Open Firmware 规范定义，该规范在 **Power.org
    嵌入式电源架构平台需求标准** (**ePAPR**) 中定义了扁平化的设备树格式，该标准描述了引导程序与客户端之间的接口。
- en: Platform customization changes will usually happen in the device tree without
    the need to modify the kernel source.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 平台自定义更改通常会在设备树中进行，而无需修改内核源代码。
- en: How to do it...
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: A device tree is defined in a human-readable device tree syntax (`.dts`) text
    file. Every board has one or several DTS files that correspond to different hardware
    configurations.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树在一个人类可读的设备树语法（`.dts`）文本文件中定义。每个开发板都有一个或多个 DTS 文件，分别对应不同的硬件配置。
- en: 'These DTS files are compiled into **Device Tree Binary** (**DTB**) blobs, which
    have the following properties:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 DTS 文件会被编译成 **设备树二进制文件** (**DTB**) 二进制块，具有以下特点：
- en: They are relocatable, so pointers are never used internally
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是可重定位的，因此内部不会使用指针。
- en: They allow for dynamic node insertion and removal
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许动态插入和移除节点。
- en: They are small in size
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们体积小巧。
- en: Device tree blobs can either be attached to the kernel binary (for legacy compatibility)
    or, as is more commonly done, passed to the kernel by a bootloader like U-Boot.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树二进制文件可以附加到内核二进制文件中（以保持向后兼容性），或者像通常做的那样，通过 U-Boot 等引导加载程序传递给内核。
- en: To compile them, we use a **Device Tree Compiler** (**DTC**), which is included
    in the kernel source inside `scripts/dtc` and is compiled along with the kernel
    itself, or we could alternatively install it as part of your distribution. It
    is recommended to use the DTC compiler included in the kernel tree.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译它们，我们使用 **设备树编译器** (**DTC**)，它包含在内核源代码中的 `scripts/dtc` 目录，并与内核一起编译，或者我们也可以将其作为发行版的一部分安装。建议使用内核树中包含的
    DTC 编译器。
- en: The device trees can be compiled independently or with the Linux kernel kbuild
    system, as we saw previously. However, when compiling independently, modern device
    trees will need to be preprocessed by the C preprocessor first.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树可以独立编译，也可以与 Linux 内核的 kbuild 系统一起编译，正如我们之前所看到的。然而，当独立编译时，现代设备树需要先由 C 预处理器进行预处理。
- en: It's important to note that the DTC currently performs syntax checking but no
    binding checking, so invalid DTS files may be compiled, and the resulting DTB
    file may result in a non-booting kernel. Invalid DTB files usually hang the Linux
    kernel very early on so there will be no serial output.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，DTC 目前只执行语法检查，而不执行绑定检查，因此无效的 DTS 文件可能会被编译，而生成的 DTB 文件可能导致内核无法启动。无效的 DTB
    文件通常会让 Linux 内核在启动早期挂起，因此不会有串口输出。
- en: The bootloader might also modify the device tree before passing it to the kernel.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 启动加载程序也可能在将设备树传递给内核之前对其进行修改。
- en: How it works...
  id: totrans-748
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理……
- en: 'The DTS file for the `wandboard-quad` variant is under `arch/arm/boot/dts/imx6q-wandboard.dts`
    and looks as follows:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '`wandboard-quad`变种的 DTS 文件位于`arch/arm/boot/dts/imx6q-wandboard.dts`，其内容如下：'
- en: '[PRE151]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'What we see here is the device tree root node that has no parents. The rest
    of the nodes will have a parent. The structure of a node can be represented as
    follows:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是设备树的根节点，它没有父节点。其余节点都会有父节点。节点的结构可以表示如下：
- en: '[PRE152]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The node properties can be:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 节点属性可以是：
- en: Empty
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空
- en: Contain one or more strings
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个或多个字符串。
- en: Contain one or more unsigned 32-bit numbers, called **cells**
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个或多个无符号 32 位数字，称为**单元**。
- en: Contain a binary byte stream
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含二进制字节流。
- en: Be a reference to another node, called a **phandle**
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用另一个节点，称为**phandle**。
- en: The device tree is initially parsed by the C preprocessor and it can include
    other DTS files. These `include` files have the same syntax and are usually appended
    with the `dtsi` suffix. File inclusion can also be performed with the device tree
    `/include/` operator, although `#include` is recommended, and they should not
    be mixed. In this case, both `imx6q.dtsi` and `imx6qdl-wandboard.dtsi` are overlaid
    with the contents of `imx6q-wandboard.dts`.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树最初由 C 预处理器解析，并且可以包含其他 DTS 文件。这些`include`文件具有相同的语法，通常以`dtsi`后缀结尾。文件包含也可以通过设备树的`/include/`操作符来执行，尽管推荐使用`#include`，并且它们不应该混合使用。在这种情况下，`imx6q.dtsi`和`imx6qdl-wandboard.dtsi`的内容会覆盖`imx6q-wandboard.dts`。
- en: Device tree nodes are documented in bindings contained in the `Documentation/devicetree/bindings/`
    directory of the kernel source. New nodes must include the corresponding bindings,
    and these must be reviewed and accepted by the device tree maintainers. Theoretically,
    all bindings need to be maintained, although it is likely this will be relaxed
    in the future.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树节点在内核源代码的`Documentation/devicetree/bindings/`目录中的绑定文档中有详细说明。新节点必须包含相应的绑定，并且这些绑定必须经过设备树维护者的审查和接受。从理论上讲，所有绑定都需要维护，尽管未来可能会放宽这一要求。
- en: The compatible property
  id: totrans-761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 兼容性属性。
- en: The most important property in a device tree node is the `compatible` property.
    In the root node, it defines the machine types the device tree is compatible with.
    The DTS file we just saw is compatible in order of precedence with the `wand,imx6q-wandboard`
    and `fsl,imx6q` machine types.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树节点中最重要的属性是`compatible`属性。在根节点中，它定义了设备树兼容的机器类型。我们刚才看到的 DTS 文件按优先顺序与`wand,imx6q-wandboard`和`fsl,imx6q`机器类型兼容。
- en: 'On a non-root node, it will define the driver match for the device tree node,
    binding a device with the driver. For example, a platform driver that binds with
    a node that defines a property that is compatible with `fsl,imx6q-tempmon` would
    contain the following excerpt:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 在非根节点上，它将定义设备树节点的驱动匹配，将设备与驱动程序绑定。例如，一个平台驱动程序，如果与一个定义了兼容`fsl,imx6q-tempmon`属性的节点绑定，则会包含如下摘录：
- en: '[PRE153]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The Wandboard device tree file
  id: totrans-765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Wandboard 设备树文件。
- en: Usually, the first DTSI file to be included is `skeleton.dtsi`, which is the
    minimum device tree needed to boot, once a compatible property is added.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，首先要包含的 DTSI 文件是`skeleton.dtsi`，这是启动所需的最小设备树，一旦添加了兼容性属性。
- en: '[PRE154]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Here are the other common top nodes:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是其他常见的顶级节点：
- en: '**chosen**: This node defines fixed parameters set at boot, such as the Linux
    kernel command line or the `initramfs` memory location. It replaces the information
    traditionally passed in ARM tags (`ATAGS`).'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**chosen**：该节点定义了启动时设置的固定参数，如 Linux 内核命令行或`initramfs`内存位置。它取代了传统上通过 ARM 标签（`ATAGS`）传递的信息。'
- en: '**memory**: This node is used to define the location and size of RAM. This
    is usually filled in by the bootloader.'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**memory**：该节点用于定义 RAM 的位置和大小，通常由引导加载程序填充。'
- en: '**aliases**: This defines shortcuts to other nodes.'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**别名**：这定义了指向其他节点的快捷方式。'
- en: '**address-cells** and **size-cells**: These are used for memory addressability
    and will be discussed later on.'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**address-cells**和**size-cells**：这两个属性用于内存可寻址性，稍后将讨论。'
- en: 'A summary representation of the `imx6q-wandboard.dts` file showing only the
    selected buses and devices follows:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`imx6q-wandboard.dts`文件的摘要表示，仅显示选定的总线和设备：
- en: '[PRE155]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: On this DTS, we can find several nodes defining **system on chip** (**SoC**)
    buses and several other nodes defining on-board devices.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 DTS 中，我们可以找到几个节点定义了**片上系统**（**SoC**）总线和其他几个节点定义了板载设备。
- en: Defining buses and memory-addressable devices
  id: totrans-776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义总线和内存可寻址设备。
- en: Buses are typically defined by the `compatible` property or the `simple-bus`
    property (to define a memory-mapped bus with no specific driver binding) or both.
    The `simple-bus` property is needed so that children nodes to the bus are registered
    as platform devices.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 总线通常通过`compatible`属性或`simple-bus`属性（用于定义一个没有特定驱动程序绑定的内存映射总线）或两者定义。`simple-bus`属性是必需的，这样总线的子节点才能注册为平台设备。
- en: 'For example, the `soc` node is defined as follows:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`soc`节点定义如下：
- en: '[PRE156]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The properties on the `soc` node are used to specify the memory addressability
    of the children nodes.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '`soc`节点上的属性用于指定子节点的内存寻址方式。'
- en: '`address-cells`: This property indicates how many base address cells are needed
    in the `reg` property.'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address-cells`：此属性指示在`reg`属性中需要多少个基地址单元。'
- en: '`size-cells`: This property indicates how many size cells are needed in the
    `reg` property.'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size-cells`：此属性指示在`reg`属性中需要多少个大小单元。'
- en: '`ranges`: This one describes an address translation between parent and child
    buses. In here, there is no translation and parent and child addressing is identical.'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges`：这个属性描述了父子总线之间的地址转换。在这里，没有转换，父子地址是相同的。'
- en: 'In this case, any child of `soc` needs to define its memory addressing with
    a `reg` property that contains one cell for the address and one cell for the size.
    The `aips-bus` node does that with the following property:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`soc`的任何子节点都需要通过`reg`属性定义其内存地址，该属性包含一个单元表示地址，一个单元表示大小。`aips-bus`节点通过以下属性实现：
- en: '[PRE157]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: There's more...
  id: totrans-786
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: When the device tree binary blob is loaded in memory by the Linux kernel, it
    is expanded into a flattened device tree that is accessed by offset. The `fdt_*`
    kernel functions are used to access the flattened device tree. This `fdt` is then
    parsed and transformed into a tree memory structure that can be efficiently accessed
    with the `of_*` family of functions (the prefix comes from Open Firmware).
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 当Linux内核将设备树二进制数据加载到内存中时，它会展开成一个扁平化的设备树，通过偏移量访问。`fdt_*`内核函数用于访问扁平化的设备树。这个`fdt`随后被解析并转化为一个可以通过`of_*`系列函数（前缀来源于Open
    Firmware）高效访问的树形内存结构。
- en: Modifying and compiling the device tree in Yocto
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Yocto中修改和编译设备树
- en: 'To modify the device tree in the Yocto build system, we execute the following
    set of commands:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Yocto构建系统中修改设备树，我们执行以下一组命令：
- en: '[PRE158]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We then edit `arch/arm/boot/dts/imx6q-wandboard.dts` and compile the changes
    with:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着编辑`arch/arm/boot/dts/imx6q-wandboard.dts`并使用以下命令编译更改：
- en: '[PRE159]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'If we want to create a device tree with extra space, let''s say 1024 bytes
    (for example, to add nodes dynamically as explained in the next recipe), we need
    to specify it with a DTC flag as follows:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个具有额外空间的设备树，比如1024字节（例如，添加节点如下一食谱所示），我们需要通过DTC标志来指定它，如下所示：
- en: '[PRE160]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'To deploy it, we exit the devshell and build the kernel from the project''s
    `build` directory:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署它，我们退出devshell并从项目的`build`目录中构建内核：
- en: '[PRE161]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: See also
  id: totrans-797
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: More information regarding device trees can be found at [http://www.devicetree.org](http://www.devicetree.org)
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于设备树的信息可以在[http://www.devicetree.org](http://www.devicetree.org)找到
- en: Debugging device tree issues
  id: totrans-799
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试设备树问题
- en: This recipe will show some techniques to debug common problems with the device
    tree.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将展示一些调试设备树常见问题的技巧。
- en: How to do it...
  id: totrans-801
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行...
- en: As mentioned before, problems with the syntax of device tree files usually result
    in the kernel crashing early in the boot process. Other type of problems are more
    subtle and usually appear once a driver is making use of the information provided
    by the device tree. For both types of problems, it is helpful to be able to look
    not only at the device tree syntax file, but also at the device tree blob, as
    it is read by both U-Boot and the Linux kernel. It may also be helpful to modify
    the device tree on the fly using the tools that U-Boot offers.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，设备树文件的语法问题通常会导致内核在启动过程中崩溃。其他类型的问题更为隐蔽，通常在驱动程序使用设备树提供的信息时出现。对于这两类问题，能够查看不仅是设备树语法文件，还能查看设备树二进制数据（U-Boot和Linux内核读取的内容）是非常有帮助的。使用U-Boot提供的工具动态修改设备树也可能会很有用。
- en: How it works...
  id: totrans-803
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Looking at the device tree from U-Boot
  id: totrans-804
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从U-Boot查看设备树
- en: 'The U-Boot bootloader offers the `fdt` command to interact with a device tree
    blob. On the Wandboard''s default environment, there are two variables related
    to the device tree:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot引导加载程序提供了`fdt`命令来与设备树二进制数据交互。在Wandboard的默认环境中，有两个与设备树相关的变量：
- en: '`fdt_file`: This variable contains the name of the device tree file used'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fdt_file`：此变量包含使用的设备树文件的名称'
- en: '`fdt_addr`: This variable contains the location in memory to load the device
    tree'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fdt_addr`：此变量包含加载设备树的内存位置'
- en: 'To fetch the Wandboard''s device tree from the TFTP server location and place
    it in memory, we use the following command:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 TFTP 服务器位置获取 Wandboard 的设备树并将其放入内存，我们使用以下命令：
- en: '[PRE162]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Once we have the device tree blob in memory, we tell U-Boot where it is located:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设备树二进制文件加载到内存中，我们告诉 U-Boot 它的位置：
- en: '[PRE163]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'And then we can inspect nodes from the device tree using the full path to them
    from the root node. To inspect the selected levels, we use the `list` command,
    and to print complete subtrees, we use the `print` command:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过设备树的完整路径从根节点开始检查节点。要检查选定的级别，我们使用 `list` 命令，要打印完整的子树，我们使用 `print` 命令：
- en: '[PRE164]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'U-Boot can also attach new nodes to the tree assuming there is extra space
    in the device tree:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot 也可以将新的节点附加到设备树中，前提是设备树中有额外的空间：
- en: '[PRE165]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'It can also create or remove properties:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以创建或删除属性：
- en: '[PRE166]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: For example, it can be useful to modify the kernel command line through the
    chosen node.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过选定的节点修改内核命令行是很有用的。
- en: Looking at the device tree from the Linux kernel
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Linux 内核查看设备树
- en: 'Once the Linux kernel is booted, it can be useful to expose the device tree
    to user space so that it can be explored. You can do this by configuring the Linux
    kernel with the `CONFIG_PROC_DEVICETREE` configuration variable. The Wandboard
    Linux kernel comes preconfigured to expose the device tree in `/proc/device-tree`
    as follows:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Linux 内核启动后，将设备树暴露给用户空间以便进行探索是很有用的。可以通过配置 Linux 内核的 `CONFIG_PROC_DEVICETREE`
    配置变量来实现。Wandboard Linux 内核已经预配置为在 `/proc/device-tree` 中暴露设备树，如下所示：
- en: '[PRE167]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
