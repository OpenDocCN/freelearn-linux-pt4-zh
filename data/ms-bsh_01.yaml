- en: Let's Start Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编程吧
- en: Mastering Bash is the art of taking advantage of your environment to make the
    best out of it. It is not just a matter of dealing with boring routine tasks that
    can be automated. It is crafting your working space so that it becomes more efficient
    for your goals. Thus, even though Bash scripting is not as expressive as other
    more complex languages, such as Python or JavaScript, it is simple enough to be
    grabbed in a short time, and so flexible that it will suffice for most of your
    everyday tasks, even the trickiest ones.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 精通 Bash 就是掌握如何利用你的环境，最大化其潜力。这不仅仅是处理可以自动化的枯燥日常任务。它是将你的工作空间打造得更加高效，以实现你的目标。因此，尽管
    Bash 脚本的表达能力不如 Python 或 JavaScript 等其他复杂语言，但它足够简单，可以在短时间内掌握，而且灵活到足以满足你大多数日常任务的需求，甚至是最棘手的任务。
- en: 'But is Bash so plain and easy? Let''s have a look at our first lines in Bash.
    Let''s begin with something easy:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Bash 就这么简单易用吗？让我们看看在 Bash 中的第一行代码。我们从简单的开始：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let us do it again in a slightly different way:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以稍微不同的方式再做一次：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What is interesting here is that the value of `real` is slightly different
    between the two commands. OK, but why? Let''s dig a bit further with the following
    commands:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，`real` 的值在两个命令之间稍有不同。好的，但为什么呢？让我们通过以下命令深入探讨：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Interestingly enough, the first seems to be a `shell builtin`, the second simply
    a system program, an external utility, and it is here that lies the difference.
    `builtin` is a command that is built into the shell, the opposite of a system
    program, which is invoked by the shell. An internal command, the opposite to an
    external command.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，第一个似乎是一个 `shell builtin`，第二个只是一个系统程序，一个外部工具，差异就出在这里。`builtin` 是内置于 shell
    中的命令，而系统程序则由 shell 调用。内置命令与外部命令正好相反。
- en: To understand the difference between internal and external shell commands that
    lead to such different timing, we have to understand how an external program is
    invoked by the shell. When an external program is to be executed, Bash creates
    a copy of itself with the same environment of the parent shell, giving birth to
    a new process with a different process ID number. So to speak, we just saw how
    forking is carried out. Inside the new address space, a system exec is called
    to load the new process data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解导致如此不同的执行时机的内外部 shell 命令之间的区别，我们必须了解外部程序是如何被 shell 调用的。当外部程序要执行时，Bash 会创建一个它自己的副本，使用父
    shell 相同的环境，并产生一个具有不同进程 ID 的新进程。可以说，我们刚刚看到了如何进行分叉。在新的地址空间中，调用系统的 exec 来加载新进程数据。
- en: 'For the `builtin` commands, it is a different story, Bash executes them without
    any forks, and this leads to a couple of the following interesting outcomes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `builtin` 命令，情况有所不同，Bash 在不进行任何分叉的情况下执行它们，这会带来以下几个有趣的结果：
- en: 'The `builtin` execution is faster because there are no copies and no executables
    invoked. One side note is that this advantage is more evident with short-running
    programs because the overhead is before any executable is called: once the external
    program is invoked, the difference in the pure execution time between the `builtin`
    command and the program is negligible.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builtin` 执行更快，因为没有副本，也没有执行文件被调用。值得注意的是，这一优势在短时间运行的程序中更为明显，因为开销是在任何可执行文件被调用之前：一旦外部程序被调用，`builtin`
    命令和程序之间的纯执行时间差异可以忽略不计。'
- en: 'Being internal to Bash, the `builtin` commands can affect its internal state,
    and this is not possible with the external program. Let''s take into account a
    classic example using `builtincd`. If `cd` were an external program, once invoked
    from shell as:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Bash 的内置命令，`builtin` 命令可以影响其内部状态，而外部程序无法做到这一点。让我们考虑一个经典的例子，使用 `builtincd`。如果
    `cd` 是一个外部程序，一旦从 shell 中调用，如下所示：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first operation would be our shell forking a process for `cd`, and this
    latter would change the current directory for its own process, not for the one
    we are inside and that was forked to give birth to the `cd` process. The parent
    shell would remain unaffected. So, we would not go anywhere.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个操作是我们的 shell 为 `cd` 分叉一个进程，后者会改变它自己的进程中的当前目录，而不是我们所在的那个进程，该进程是为了启动 `cd` 进程而被分叉的。父
    shell 不会受到影响。因此，我们将无法前往任何地方。
- en: 'Curious about which `bulitins` are available? You have some options, to either
    execute the following `builtin`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道有哪些 `builtin` 可用吗？你有几个选项，可以执行以下 `builtin`：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or this other `builtin`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这个其他的 `builtin` 命令：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To better understand why there is a difference between the execution of a `builtin`
    and an external program, we must see what happens when we invoke a command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解为何`builtin`和外部程序的执行有差异，我们需要看看当我们调用命令时发生了什么。
- en: First, remember that the shell works from left to right and takes all the variable
    assignments and redirections and saves them in order to process later.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，记住Shell是从左到右工作的，它会处理所有的变量赋值和重定向，并将它们保存起来以供后续处理。
- en: If nothing else is left, the shell takes the first word from the command line
    as the name of the command itself, while all the rest is considered as its arguments.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有其他内容，Shell将把命令行中的第一个单词作为命令名称，而其余部分将被视为参数。
- en: The next step is dealing with the required input and output redirection.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一步是处理所需的输入和输出重定向。
- en: Finally, before being assigned to a variable, all the text following the sign
    `=` is subject to tilde expansion, parameter expansion, command substitution,
    arithmetic expansion, and quote removal.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在赋值给变量之前，所有在`=`符号后的文本都将进行波浪线扩展、参数扩展、命令替换、算术扩展和引号移除。
- en: If no command name comes out as a result of the last operation, the variable
    can then affect the environment. If an assignment fails, an error is raised and
    the command invoked exits with a non-zero status.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最后的操作没有产生命令名称，变量就可以影响环境。如果赋值失败，则会引发错误，并且调用的命令会以非零状态退出。
- en: If no command name is the outcome of the operation seen before, all the redirections
    are applied, but differently from variables, they do not affect the current environment.
    Again, if any error occurs, there is a non-zero status exit.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作结果中没有命令名称，所有重定向将被应用，但与变量不同，它们不会影响当前环境。同样，如果发生任何错误，返回的退出状态为非零。
- en: Once the preceding operations are performed, the command is then executed and
    exited with a status, depending on whether one or more expansions contain command
    substitutions. The overall exit status will be the one from the last command substitution,
    and if no command substitution were performed, the exit status will be zero.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的操作完成，命令就会被执行，并根据是否有一个或多个扩展包含命令替换来决定退出状态。总体退出状态将是最后一个命令替换的状态，如果没有执行命令替换，退出状态将为零。
- en: At this point, we are finally left with a command name and some optional arguments.
    It is at this point the roads of `builtins` and external programs divert.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们最终只剩下一个命令名称和一些可选的参数。此时，`builtins`和外部程序的路径开始分歧。
- en: At first, the shell looks at the command name, and if there are no slashes,
    it searches for its location
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一开始，Shell查看命令名称，如果没有斜杠，它会搜索命令的路径。
- en: If there are no slashes, the shell tries to see if there is a function with
    that name and executes it
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有斜杠，Shell会尝试查找是否存在一个与该名称相同的函数并执行它。
- en: If no functions are found, the shell tries to hit `builtin`, and if there is
    anyone with that name, it is executed
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有找到函数，Shell会尝试执行`builtin`，如果有该名称的`builtin`，它会被执行。
- en: OK, now if there is any `builtin`, it already got invoked. What about an external
    program?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在如果有任何`builtin`，它已经被调用。那么外部程序呢？
- en: 'Our Bash goes on, and if it finds no `builtins` by that name on the command
    line, there are three chances:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在命令行上找不到名为`builtins`的内容，我们的Bash将继续执行，并且有三次机会：
- en: The full path of the command to execute is already contained into its internal
    hash table, which is a structure used to speed up the search
  id: totrans-33
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行命令的完整路径已经包含在其内部哈希表中，哈希表是用来加速查找的结构。
- en: If the full path is not in the hash, the shell looks for it into the content
    of the environmental `PATH` variable, and if it finds it, it is added to the hash
    table
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果完整路径不在哈希表中，Shell会在环境变量`PATH`的内容中查找，如果找到，它会被添加到哈希表中。
- en: The full path is not available in the `PATH` variable, so the shell returns
    with an exit status of 127
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`PATH`变量中没有完整路径，Shell会返回退出状态127。
- en: 'Hash can even be invoked as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希甚至可以像这样被调用：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The second column will then tell you not only which commands have been hashed,
    but also how many times each of them has been executed during the current session
    (hits).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二列将告诉你，不仅哪些命令已经被哈希，还会告诉你每个命令在当前会话中执行的次数（命中次数）。
- en: Let's say that the search found the full path to the command we want to execute;
    now we have a full path, and we are in the same situation as if the Bash found
    one or more slashes into the command name. In either case, the shell thinks that
    it has a good path to invoke a command and executes the latter in a forked environment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设搜索找到了我们想要执行的命令的完整路径；现在我们有了完整路径，情况就像 Bash 在命令名称中发现一个或多个斜杠一样。在这两种情况下，shell 都认为它有一个有效的路径来调用命令，并在一个分叉的环境中执行该命令。
- en: This is when we are lucky, but it can happen that the file invoked is not an
    executable, and in this case, given that our path does not point to a directory
    instead of a file, the Bash makes an educated guess and thinks to run a shell
    script. In this case, the script is executed in a subshell that is at all a new
    environment, which inherits the content of the hash table of the parent shell.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运气好的时候，但也可能发生调用的文件不是可执行文件的情况，这时，由于我们的路径指向的是一个目录而非文件，Bash 会做出一个合理的猜测，认为需要运行一个
    shell 脚本。在这种情况下，脚本会在一个子 shell 中执行，而这个子 shell 是一个全新的环境，它继承了父 shell 的哈希表内容。
- en: Before doing anything else, the shell looks at the first line of the script
    for an optional `sha-bang` (we will see later what this is) - after the `sha-bang`,
    there is the path to the interpreter used to manage the script and some optional
    arguments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何其他事情之前，shell 会查看脚本的第一行，寻找一个可选的 `sha-bang`（我们稍后会看到这是什么）- 在 `sha-bang` 后面是用于管理脚本的解释器路径和一些可选参数。
- en: At this point, and only at this point, your external command, if it is a script,
    is executed. If it is an executable, it is invoked a bit before, but way after
    any `builtin`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，只有在这个时刻，如果你的外部命令是脚本，它才会被执行。如果它是可执行文件，它会在稍早一些时候被调用，但仍然在任何`builtin`命令之后执行。
- en: During these first paragraphs, we saw some commands and concepts that should
    sound familiar to you. The next paragraphs of this chapter will quickly deal with
    some basic elements of Bash, such as variables, expansions, and redirections.
    If you already know them, you will be able to use the next pages as a reference
    while working on your scripts. If, on the contrary, you are not so familiar with
    them, have a look at what comes next because all you will read will be fundamental
    in understanding what you can do in and with the shell.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段落中，我们已经看到了一些应该对你来说熟悉的命令和概念。本章的接下来的段落将快速讲解一些 Bash 的基本元素，如变量、扩展和重定向。如果你已经熟悉它们，那么在工作脚本时，你可以将接下来的页面作为参考。如果相反，你对这些概念不太熟悉，那么请继续阅读接下来的内容，因为你所阅读的所有内容将对理解你可以在
    shell 中做什么以及如何操作非常重要。
- en: I/O redirection
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入输出重定向
- en: 'As we saw in the previous pages, redirection is one of the last operations
    undertaken by Bash to parse and prepare the command line that will lead to the
    execution of a command. But what is a redirection? You can easily guess from your
    everyday experience. It means taking a stream that goes from one point to another
    and making it go somewhere else, like changing the flow of a river and making
    it go somewhere else. In Linux and Unix, it is quite the same, just keep in mind
    the following two principles:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的页面所看到的，重定向是 Bash 在解析并准备执行命令的命令行时所执行的最后操作之一。那么什么是重定向呢？你可以从日常经验中轻松猜到。它意味着将一个流从一个点引导到另一个点，然后让它去别的地方，就像改变一条河流的流向让它流向别的地方一样。在
    Linux 和 Unix 中，情况也差不多，只需要记住以下两个原则：
- en: In Unix, each process, except for daemons, is supposed to be connected to a
    standard input, standard output, and standard error device
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unix 中，除了守护进程外，每个进程都应该连接到标准输入、标准输出和标准错误设备
- en: Every device in Unix is represented by a file
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix 中的每个设备都通过一个文件来表示
- en: 'You can also think of these devices as streams:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这些设备视为流：
- en: Standard input, named `stdin`, is the intaking stream from which the process
    receives input data
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输入，名为 `stdin`，是进程接收输入数据的流
- en: Standard output, named `stdout`, is the outbound stream where the process writes
    its output data
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输出，名为 `stdout`，是进程写入其输出数据的外发流
- en: Standard error, named `stderr`, is the stream where the process writes its error
    messages
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准错误，名为 `stderr`，是进程写入其错误信息的流
- en: 'These streams are also identified by a standard POSIX file descriptor, which
    is an integer used by the kernel as a handler to refer to them, as you can see
    in the following table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些流也由标准 POSIX 文件描述符来标识，文件描述符是一个整数，内核用它作为处理程序来引用这些流，如下表所示：
- en: '| **Device** | **Mode** | **File descriptor** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **模式** | **文件描述符** |'
- en: '| `stdin` | read | 0 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `stdin` | 读 | 0 |'
- en: '| `stdout` | write | 1 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `stdout` | 写 | 1 |'
- en: '| `stderr` | write | 2 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `stderr` | 写入 | 2 |'
- en: So, tinkering with the file descriptors for the three main streams means that
    we can redirect the flows between `stdin` and `stdout`, but also `stderr`, from
    one process to the other. So, we can make different processes communicate with
    each other, and this is actually a form of IPC, inter-process communication, which
    we will look at it in more detail later in this book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，操作文件描述符来处理三种主要流意味着我们可以在`stdin`和`stdout`之间重定向流，也可以在`stderr`之间重定向流，甚至可以让一个进程与另一个进程进行通信，这实际上是一种进程间通信（IPC）的形式，我们将在本书后续章节更详细地讨论这一点。
- en: 'How do we redirect the **Input/Output** (**I/O**), from one process to another?
    We can get to this goal making use of some special characters:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将**输入/输出**（**I/O**）从一个进程重定向到另一个进程？我们可以利用一些特殊字符来实现这一目标：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's start stating that the default output of a process, usually, is the `stdout`.
    Whatever it returns is returned on the `stdout` which, again usually, is the monitor
    or the terminal. Using the `>` character, we can divert this flow and make it
    go to a file. If the file does not exist, it is created, and if it exists, it
    is flattened and its content is overwritten with the output stream of the process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先声明，进程的默认输出通常是`stdout`。无论它返回什么，都会返回到`stdout`，而`stdout`通常是显示器或终端。通过使用`>`字符，我们可以将这个流重定向到文件。如果文件不存在，它将被创建，如果文件已存在，它将被覆盖并用进程的输出流替换原有内容。
- en: 'A simple example will clarify how the redirection to a file works:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子可以澄清如何将输出重定向到文件：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We used the command `echo` to print a message on the `stdout`, and so we see
    the message written, in our case, to the text terminal that is usually connected
    to the shell:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了命令`echo`来打印信息到`stdout`，因此我们可以看到信息被写入到通常与Shell连接的文本终端中：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There is nothing on the filesystem, so the output went straight to the terminal,
    but the underlying directory was not affected. Now, time for a redirection:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统中没有任何内容，所以输出直接显示在终端上，但底层目录没有受到影响。现在，是时候进行重定向了：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Well, nothing to the screen; no output at all:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，屏幕上没有显示任何内容；没有任何输出：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Actually, as you can see, the output did not vanish; it was simply redirected
    to a file on the current directory which got created and filled in:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，正如你所看到的，输出没有消失；它只是被重定向到当前目录下的一个新文件中，并被创建和填充：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we have something interesting. The `cat` command takes the content of the
    `output_file.txt` and sends it on the `stdout.` What we can see is that the output
    from the former command was redirected from the terminal and written to a file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有些有趣的内容。`cat`命令获取`output_file.txt`的内容并将其发送到`stdout`。我们可以看到的是，前一个命令的输出被重定向到终端并写入到文件中。
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This double mark answers a requirement we often face: *How can we add more
    content coming from a process to a file without overwriting anything?* Using this
    double character, which means no file is already in place, create a new one; if
    it already exists, just append the new data. Let''s take the previous file and
    add some content to it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个双重标记解决了我们经常面临的一个问题：*我们如何在不覆盖任何内容的情况下，将更多来自进程的内容添加到文件中？* 使用这个双重字符，表示文件尚不存在时会创建一个新文件；如果文件已经存在，则直接将新数据追加到文件末尾。我们来看一下之前的文件并向其添加一些内容：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Bingo, the file was not overwritten and the new content from the `echo` command
    was added to the old. Now, we know how to write to a file, but what about reading
    from somewhere else other than the `stdin`?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，文件没有被覆盖，`echo`命令的新内容被添加到了旧内容中。现在，我们知道如何写入文件，那么从`stdin`以外的其他地方读取数据呢？
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the text terminal is the `stdin`, the keyboard is the standard input for
    a process, where it expects some data from. Again, we can divert the flow or data
    reading and get the process read from a file. For our example, we start creating
    a file containing a set of unordered numbers:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本终端是`stdin`，键盘则是进程的标准输入，进程从中获取数据。我们同样可以重定向数据流或读取流，并让进程从文件中读取数据。以我们的例子为例，我们首先创建一个包含一组无序数字的文件：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And let us verify its content, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们验证它的内容，方法如下：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can have the `sort` command read this file into its `stdin`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让`sort`命令将这个文件读取到它的`stdin`中，方法如下：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Nice, our numbers are now in sequence, but we can do something more interesting:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，我们的数字现在已经按顺序排列，但我们可以做些更有趣的事情：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What did we do? We simply gave the file `to_sort` to the command `sort` into
    its standard input, and at the same time, we concatenated a second redirection
    so that the output of `sort` is written into the file `sorted`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了什么？我们只是将文件`to_sort`传递给`sort`命令的标准输入，同时连接了第二个重定向，使得`sort`的输出被写入文件`sorted`：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, we can concatenate multiple redirections and have some interesting results,
    but we can do something even trickier, that is, chaining together inputs and outputs,
    not on files but on processes, as we will see now.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以连接多个重定向并获得一些有趣的结果，但我们还可以做一些更复杂的事情，即将输入和输出链式连接，操作的对象不再是文件，而是进程，正如我们接下来所看到的。
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The pipe character does exactly what its name suggests, *pipes* the stream;
    could be the `stdout` or `stderr`, from one process to another, creating a simple
    interprocess communication facility:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 管道字符正如其名称所示，*管道*将一个进程的流（可能是`stdout`或`stderr`）传递给另一个进程，创建一个简单的进程间通信机制：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we had a bit of fun, first getting a list of processes, then
    piping the output to the `awk` utility, which printed only the first, eleventh,
    and twelfth fields of the output of the first command, giving us the process ID,
    CPU percentage, and memory percentage columns. Then, we got rid of the heading
    `PID %CPU %MEM`, piping the `awk` output to the input of `grep`, which performed
    a reverse pattern matching on any strings containing a character, not a number.
    In the next stage, we piped the output to the `sort` command, which reverse-ordered
    the data based on the values in the second column. Finally, we wanted only the
    three lines, and so we got the `PID` of the first three heaviest processes relying
    on CPU occupation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们玩得很开心，首先获取了一个进程列表，然后将输出通过管道传给`awk`工具，`awk`只打印了第一个、第十一和第十二列，分别是进程ID、CPU百分比和内存百分比。然后，我们去掉了标题`PID
    %CPU %MEM`，将`awk`的输出通过管道传给`grep`，`grep`对所有包含字符而非数字的字符串进行了反向模式匹配。接下来，我们将输出传给了`sort`命令，按第二列的值对数据进行了倒序排序。最后，我们只想要前三行，于是我们得到了依赖于CPU占用的前三个最重进程的`PID`。
- en: 'Redirection can also be used for some kind of fun or useful stuff, as you can
    see in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向也可以用来做一些有趣或有用的事情，正如你在下面的截图中所看到的：
- en: '![](img/00005.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: As you can see, there are two users on the same machine on different terminals,
    and remember that each user has to be connected to a terminal. To be able to write
    to any user's terminal, you must be root or, as in this example, the same user
    on two different terminals. With the `who` command we can identify which terminal
    (`ttys`) the user is connected to, also known as *reads from*, and we simply redirect
    the output from an `echo` command to his terminal. Because its session is connected
    to the terminal, he will read what we send to the `stdin` of his terminal device
    (hence, `/dev/ttysxxx`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，机器上有两个用户在不同的终端上，记住每个用户都必须连接到一个终端。要能够向任何用户的终端写入内容，你必须是root用户，或者像本例中一样，是同一用户在两个不同的终端上。通过`who`命令，我们可以识别出用户连接到的终端（`ttys`），也就是*从中读取*，然后我们只需将`echo`命令的输出重定向到他的终端。因为他的会话已连接到该终端，所以他会读取我们发送到其终端设备`stdin`的数据（因此是`/dev/ttysxxx`）。
- en: 'Everything in Unix is represented by a file, be it a device, a terminal, or
    anything we need access to. We also have some special files, such as `/dev/null`,
    which is a sinkhole - whatever you send to it gets lost:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Unix中的一切都通过文件表示，无论是设备、终端，还是我们需要访问的任何内容。我们还有一些特殊的文件，比如`/dev/null`，它是一个“黑洞”——你发送到它的任何东西都会丢失：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And have a look at the following example too:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，看看以下示例：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Great, there is enough to have fun, but it is just the beginning. There is a
    whole lot more to do with the file descriptors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，有足够的内容来玩耍，但这只是个开始。还有很多工作要做，涉及文件描述符。
- en: Messing around with stdin, stdout, and stderr
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩弄stdin、stdout和stderr
- en: Well, if we tinker a little bit with the file descriptors and special characters
    we can have some nice, really nice, outcomes; let's see what we can do.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果我们稍微调整一下文件描述符和特殊字符，我们可以得到一些不错的、真的很不错的结果；让我们看看能做些什么。
- en: '`x < filename`: This opens a file in read mode and assigns the descriptor named
    `a`, whose value falls between `3` and `9`. We can choose any name by the means
    of which we can easily access the file content through the `stdin`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x < filename`：这会以读取模式打开一个文件，并为名为`a`的描述符分配一个值，该值在`3`和`9`之间。我们可以选择任何名字，通过这个名字，我们可以轻松地通过`stdin`访问文件内容。'
- en: '`1 > filename`: This redirects the standard output to filename. If it does
    not exist, it gets created; if it exists, the pre-existing data is overwritten.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1 > 文件名`：这会将标准输出重定向到文件名。如果文件不存在，它会被创建；如果文件已存在，原有数据将被覆盖。'
- en: '`1 >> filename`: This redirects the standard output to filename. If it does
    not exist, it is created; otherwise, the contents get appended to the pre-existing
    data.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1 >> 文件名`：这会将标准输出重定向到文件名。如果文件不存在，它会被创建；如果文件已存在，内容将被追加到原有数据之后。'
- en: '`2 > filename`: This redirects the standard error to filename. If it does not
    exist, it gets created; if it exists, the pre-existing data is overwritten.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2 > 文件名`：这会将标准错误重定向到文件名。如果文件不存在，它会被创建；如果文件已存在，原有数据将被覆盖。'
- en: '`2 >> filename`: This redirects the standard error to filename. If it does
    not exist, it is created; otherwise, the contents get appended to the pre-existing
    data.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2 >> 文件名`：这会将标准错误重定向到文件名。如果文件不存在，它会被创建；如果文件已存在，内容将被追加到原有数据之后。'
- en: '`&> filename`: This redirects both the `stdout` and the `stderr` to filename.
    This redirects the standard error to filename. If it does not exist, it gets created;
    if it exists, the pre-existing data is overwritten.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&> 文件名`：这会将 `stdout` 和 `stderr` 都重定向到文件名。如果文件不存在，它会被创建；如果文件已存在，则会覆盖原有数据。'
- en: '`2>&1`: This redirects the `stderr` to the `stdout`. If you use this with a
    program, its error messages will be redirected to the `stdout`, that is, usually,
    the monitor.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2>&1`：这会将 `stderr` 重定向到 `stdout`。如果你在程序中使用此命令，它的错误信息将被重定向到 `stdout`，即通常的显示器上。'
- en: '`y>&x`: This redirects the file descriptor for `y` to `x` so that the output
    from the file pointed by descriptor `y` will be redirected to the file pointed
    by descriptor `x`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y>&x`：这会将描述符 `y` 的文件重定向到描述符 `x`，这样描述符 `y` 指向的文件的输出就会重定向到描述符 `x` 指向的文件。'
- en: '`>&x`: This redirects the file descriptor `1` that is associated with the `stdout`
    to the file pointed by the descriptor `x`, so whatever hits the standard output
    will be written in the file pointed by `x`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>&x`：这会将与 `stdout` 关联的文件描述符 `1` 重定向到描述符 `x` 指向的文件中，这样任何输出到标准输出的内容都将写入描述符 `x`
    指向的文件。'
- en: '`x<> filename`: This opens a file in read/write mode and assigns the descriptor
    `x` to it. If the file does not exist, it is created, and if the descriptor is
    omitted, it defaults to `0`, the `stdin`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x<> 文件名`：这会以读写模式打开文件，并将描述符 `x` 分配给它。如果文件不存在，则会创建该文件；如果没有指定描述符，则默认为 `0`，即 `stdin`。'
- en: '`x<&-`: This closes the file opened in read mode and associated with the descriptor
    `x`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x<&-`：这会关闭以读模式打开并与描述符 `x` 关联的文件。'
- en: '`0<&- or <&-`: This closes the file opened in read mode and associated with
    the descriptor `0`, the `stdin` , which is then closed.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0<&- 或 <&-`：这会关闭以读模式打开并与描述符 `0`（即 `stdin`）关联的文件，然后关闭该文件。'
- en: '`x>&-`: This closes the file opened in write mode and associated with the descriptor
    `x`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x>&-`：这会关闭以写模式打开并与描述符 `x` 关联的文件。'
- en: '`1>&- or >&-`: This closes the file opened in write mode and associated with
    the descriptor `1`, the `stdout`, which is then closed.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1>&- 或 >&-`：这会关闭以写模式打开并与描述符 `1`（即 `stdout`）关联的文件，然后关闭该文件。'
- en: 'If you want to see which file descriptors are associated with a process, you
    can explore the `/proc` directory and point to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看哪些文件描述符与进程相关，你可以探索 `/proc` 目录，并指向以下路径：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Under that path, change `PID` with the ID of the process you want to explore;
    you will find all the file descriptors associated with it, as in the following
    example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在该路径下，替换 `PID` 为你想要探索的进程的 ID；你将找到与该进程相关的所有文件描述符，如以下示例所示：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Nice, isn''t it? So, let us do something that is absolute fun:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，是吧？那么，让我们做一些绝对有趣的事情：
- en: 'First, let''s open a socket in read/write mode to the web server of a virtual
    machine created for this book and assign the descriptor `9`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们以读写模式打开一个虚拟机的网络服务器的套接字，并将描述符 `9` 分配给它：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, let us write something to it; nothing complex:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们往它写点东西；没有什么复杂的：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We just requested a simple HTML file created for this example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是请求了一个为此示例创建的简单 HTML 文件。
- en: 'And now let us read the file descriptor `9`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们读取文件描述符 `9`：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That's it! We connected the file descriptor to a remote server through a socket,
    we could write to it and read the response, redirecting the streams over the network.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们通过套接字将文件描述符连接到远程服务器，我们可以写入并读取响应，同时将数据流通过网络进行重定向。
- en: For dealing just with the command line, we have done a lot so far, but if we
    want to go further, we have to see how to script all these commands and make the
    most out of them. It is time for our first script!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅处理命令行，我们到目前为止已经做了很多，但是如果我们想更进一步，就必须看看如何将所有这些命令编写成脚本，并充分利用它们。是时候写我们的第一个脚本了！
- en: 'Time for the interpreter: the sha-bang'
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候了解解释器了：sha-bang
- en: When the game gets tougher, a few concatenations on the command line cannot
    be enough to perform the tasks we are meant to accomplish. Too many bits on single
    lines are too messy, and we lack clarity, so better to store our commands or `builtins`
    in a file and have it executed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务变得更复杂时，单纯的命令行连接可能不足以完成我们要完成的任务。单行中的太多内容显得杂乱无章，缺乏清晰性，因此最好将我们的命令或 `builtins`
    存储在文件中，并让它执行。
- en: When a script is executed, the system loader parses the first line looking for
    what is named the `sha-bang` or shebang, a sequence of characters.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本执行时，系统加载程序解析第一行，寻找被称为 `sha-bang` 或 shebang 的字符序列。
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will force the loader to treat the following characters as a path to the
    interpreter and its optional arguments to be used to further parse the script,
    which will then be passed as another argument to the interpreter itself. So, at
    the end, the interpreter will parse the script and, this time, we will ignore
    the `sha-bang`, since its first character is a hash, usually indicating a comment
    inside a script and comments do not get executed. To go a little further, the
    `sha-bang` is what we call a 2-bit magic number, a constant sequence of numbers
    or text values used in Unix to identify file or protocol types. So, `0x23 0x21`
    is actually the ASCII representation of `#!`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将强制加载程序将后续字符视为解释器的路径及其可选参数，用于进一步解析脚本，脚本将作为另一个参数传递给解释器。因此，最终，解释器将解析脚本，这次我们将忽略
    `sha-bang`，因为它的第一个字符是井号，通常表示脚本中的注释，而注释是不会被执行的。更进一步说，`sha-bang` 是我们称之为 2 位魔术数字的东西，它是一个常数数字或文本值序列，在
    Unix 中用于标识文件或协议类型。所以，`0x23 0x21` 实际上是 `#!` 的 ASCII 表示。
- en: 'So, let''s make a little experiment and create a tiny one line script:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们做个小实验，创建一个简单的一行脚本：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Just one line. Let''s have a look:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一行。我们来看看：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Nice, everything is as we expected. Has Linux something to say about our script?
    Let''s ask:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，一切都如我们预期的那样。Linux 对我们的脚本有什么看法吗？让我们问问看：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Well, the file utility says that it is a plain file, and this is a simple text
    file indeed. Time for a nice trick:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，文件工具说它是一个普通文件，事实上它确实是一个简单的文本文件。是时候来个小把戏：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Nothing special; we just added a `sha-bang` pointing to `/bin/sh`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么特别的；我们只是添加了一个指向 `/bin/sh` 的 `sha-bang`：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As expected, the `sha-bang` is there at the beginning of our file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`sha-bang` 出现在我们文件的开头：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'No way, now it is a script! The file utility makes three different tests to
    identify the type of file it is dealing with. In order: file system tests, magic
    number tests, and language tests. In our case, it identified the magic numbers
    that represent the `sha-bang`, and thus a script, and this is what it told us:
    it is a script.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不敢相信，现在它变成了一个脚本！文件工具进行三种不同的测试来识别它正在处理的文件类型。依次是：文件系统测试、魔术数字测试和语言测试。在我们的案例中，它识别出了表示
    `sha-bang` 的魔术数字，从而确定这是一个脚本，结果就是这样告诉我们的：它是一个脚本。
- en: Now, a couple of final notes before moving on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，几个最终的备注，之后我们将继续前进。
- en: You can omit the `sha-bang` if your script is not using a shell `builtins` or
    shell internals
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的脚本不使用 Shell `builtins` 或 Shell 内部命令，可以省略 `sha-bang`。
- en: 'Pay attention to `/bin/sh`, not everything that looks like an innocent executable
    is what it seems:'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意 `/bin/sh`，并不是所有看起来像无害可执行文件的东西都真的是它看起来的样子：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In some systems, `/bin/sh` is a symbolic link to a different kind of interpreter,
    and if you are using some internals or `builtins` of Bash, your script could have
    unwanted or unexpected outcomes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，`/bin/sh` 是指向不同类型解释器的符号链接，如果你使用的是 Bash 的一些内部命令或 `builtins`，你的脚本可能会产生不想要的或意外的结果。
- en: Calling your script
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用你的脚本
- en: 'Well, we have our two-line script; time to see if it really does what we want
    it to do:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们有了一个两行的脚本；是时候看看它是否真的按我们想要的方式执行了：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'No way! It is not executing, and from the error message, it seems related to
    the file permissions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 不行！它没有执行，从错误信息来看，似乎与文件权限有关：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Interesting. Let us recap what the file permissions are. As you can see, the
    line describing the properties of a file starts with a series of letters and lines.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣。让我们回顾一下文件权限是什么。正如你所看到的，描述文件属性的那一行以一系列字母和符号开头。
- en: '| **Type** | **User** | **Group** | **Others** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **用户** | **组** | **其他** |'
- en: '| `-` | `rw-` | `r--` | `r--` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `-` | `rw-` | `r--` | `r--` |'
- en: For type, we can have two main values, d - this is actually a directory, or
    `-` and means this is a regular file. Then, we can see what permissions are set
    for the user owning the file, for the group owning the file, and for all other
    users. As you may guess, `r` stands for permission to read; `w` stands for being
    able to write; `x` stands for permission to execute; and `-` means no right. These
    are all in the same order, first `r`, then `w`, then `x`. So  wherever you see
    a `-` instead of an `r`, `w`, or `x` , it means that particular right is not granted.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件类型，我们可以有两个主要值，`d` - 实际上是一个目录，或 `-`，表示这是一个常规文件。接着，我们可以看到为文件所有者、所属组和其他所有用户设置的权限。如你所猜，`r`
    代表读取权限；`w` 代表写入权限；`x` 代表执行权限；`-` 表示没有权限。这些权限是按顺序排列的，先是 `r`，然后是 `w`，再是 `x`。所以，无论你看到
    `-` 替代 `r`、`w` 或 `x`，就意味着该权限没有被授予。
- en: The same works for directory permission, except that `x` means you can traverse
    the directory; `r` means that you can enumerate the content of it; `w` means that
    you can modify the attributes of the directory and removes the entries that are
    eventually in it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的道理适用于目录权限，只是 `x` 代表你可以遍历该目录；`r` 代表你可以列出目录内容；`w` 代表你可以修改目录的属性并删除其中的条目。
- en: '| **Indicator** | **File type** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **指示符** | **文件类型** |'
- en: '| `-` | Regular file |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 常规文件 |'
- en: '| `b` | Block file (disk or partition) |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 块文件（磁盘或分区） |'
- en: '| `c` | Character file, like the terminal under /dev |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 字符文件，例如 /dev 下的终端 |'
- en: '| `d` | Directory |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 目录 |'
- en: '| `l` | Symbolic link |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 符号链接 |'
- en: '| `p` | Named pipe (FIFO) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `p` | 命名管道 (FIFO) |'
- en: '| `s` | Socket |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 套接字 |'
- en: 'So, going back to our file, we do not see any execution bit set. Why? Here,
    a shell `builtin` can help us:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，回到我们的文件，我们没有看到设置任何执行位。为什么？这里，shell `builtin` 可以帮助我们：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Does it make any sense to you? Well, it should, once we see how the permissions
    on files can be represented in numeric form. Think of permissions as bits of metadata
    pertaining to a file, one bit for each grant; no grant is `0`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你有意义吗？嗯，一旦我们看到如何用数字形式表示文件的权限，它就应该有意义了。把权限看作是与文件相关的元数据的位，每个权限对应一位；没有权限时是`0`：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s convert from binary to decimal:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从二进制转换为十进制：
- en: '| **Permission** | **Binary** | **Decimal** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **权限** | **二进制** | **十进制** |'
- en: '| `r` | `100` | 4 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `r` | `100` | 4 |'
- en: '| `w` | `010` | 2 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `w` | `010` | 2 |'
- en: '| `x` | `001` | 1 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `x` | `001` | 1 |'
- en: Now, just combine the decimal values to obtain the final permission, but remember
    that you have to calculate read, write, and execution grants in triplets - one
    set for the user owning the file, one for the group, and one for the others.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需将这些十进制值结合起来，得到最终的权限，但记住，你需要按三元组计算读、写和执行权限——一组用于文件所有者，一组用于所属组，另一组用于其他人。
- en: 'Back again to our file, we can change its permissions in a couple of ways.
    Let''s say we want it to be readable, writable, and executable by the user; readable
    and writable by the group; and only readable by the others. We can use the command
    `chmod` to accomplish this goal:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的文件，我们可以通过几种方式改变其权限。假设我们希望文件对用户可读、可写、可执行；对组可读、可写；对其他人仅可读。我们可以使用 `chmod`
    命令来实现这个目标：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, `+` or  `-` add or subtract the permissions to the file or directory pointed
    and `u`, `g`, `w` to define which of the three sets of attributes we are referring
    to.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`+` 或 `-` 用来添加或删除文件或目录的权限，`u`、`g`、`o` 用来定义我们指的是哪三组属性。
- en: 'But we can speed things up using the numeric values:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以使用数字值加快速度：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, the following command should do the trick in one line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，下面的命令应该能一行完成这项工作：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Time to verify:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候验证一下了：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here we are. So we just need to see whether our user can execute the file,
    as the permissions granted suggest:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到了。现在，我们只需要看看我们的用户是否能执行文件，因为授予的权限表明了这一点：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This should go under the `sha-bang`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该放在 `sha-bang` 下面。
- en: 'Great, it works. Well, the script is not that complex, but served our purposes.
    But we left one question behind*: Why was the file created with that set of permissions? *As
    a preliminary explanation, I ran the command `umask`, and the result was `0022`
     but did not go further.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，它工作了。虽然脚本并不复杂，但它满足了我们的目的。不过，我们留下了一个问题：为什么文件会以那组权限创建？*作为初步解释，我运行了 `umask`
    命令，结果是 `0022`，但没有进一步探讨。*
- en: 'Count the digits in `umask`, and those in the numeric modes for `chmod`. Four
    against three. What does that leading digit means? We have to introduce some special
    permission modes that enable some interesting features:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`umask`中的数字，以及`chmod`中的数字模式。四位与三位相对。那前导数字是什么意思呢？我们需要引入一些特殊的权限模式，以启用一些有趣的功能：
- en: 'Sticky bit. Think of it as a user right assertion on a file or directory. If
    a sticky bit is set on a directory, the files inside it can be deleted or renamed
    only by the file owner, the owner of the directory the file is in, or by root.
    Really useful in a shared directory to prevent one user from deleting or renaming
    some other user''s file. The sticky bit is represented by the t letter at the
    end of the of the list of permissions or by the octal digit 1 at the beginning.
    Let''s see how it works:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粘滞位。将其视为对文件或目录的用户权限声明。如果一个目录设置了粘滞位，目录中的文件只能由文件所有者、文件所在目录的所有者或root删除或重命名。在共享目录中非常有用，可以防止一个用户删除或重命名其他用户的文件。粘滞位通过权限列表末尾的`t`字母或八进制数字1在开头来表示。让我们看看它是如何工作的：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Interestingly, the t is capital, not lower, as we were talking about. Maybe
    this sequence of commands will make everything clearer:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有趣的是，t是大写的，而不是小写的，正如我们之前提到的。也许这一串命令能让一切更清楚：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You probably got it: the t attribute is a capital when, on the file or directory,
    the execution bix (x) is not set for the others (o).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你大概明白了：当文件或目录上的执行位（x）未设置给其他用户（o）时，t 属性会变为大写。
- en: 'And now, back to the origins:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，回到最初的情况：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We used the four-digit notations, and the leading `0` cleared out the `1` which
    referred to the sticky bit. Obviously, we could also use `chmod -t` to accomplish
    the same goal. One final note, if sticky bit and GUID are in conflicts, the sticky
    bit prevails in granting permissions.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了四位数字表示法，前导的`0`清除了表示粘滞位的`1`。显然，我们也可以使用`chmod -t`来实现相同的目标。最后一点，如果粘滞位和GUID发生冲突，粘滞位会优先授予权限。
- en: '**Set UID**: The **Set User ID** (**SUID** upon execution) marks an executable,
    so that when it runs, it will do so as the file owner, with his privileges, and
    not as the user invoking it. Another tricky use is that, if assigned to a directory,
    all the files created or moved to that directory will have the ownership changed
    to the owner of the directory and not to the user actually performing the operation.
    Visually, it is represented by an s in the position of the user execution rights.
    The octal number referring to it is 4:'
  id: totrans-203
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置 UID**：**SUID**（执行时设置用户ID）标记一个可执行文件，使其在运行时以文件所有者的身份执行，拥有他的权限，而不是执行它的用户身份。另一个棘手的用法是，如果将其分配给目录，所有创建或移动到该目录的文件都会将文件所有权更改为目录所有者，而不是实际执行操作的用户。从视觉上看，它表示为用户执行权限位置上的s。与之相关的八进制数字是4：'
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Set GID**: The **SGID** (**Set Group ID** upon execution) marks an executable,
    so that when it is run, it does as the user invoking it was in the group that
    owns the file. If applied to a directory, every file created or moved to the directory
    will have the group set to the group owning the directory rather than the one
    the user performing the operation belongs to. Visually, it is represented by an
    `s` in the position of the group execution rights. The octal number referring
    to it is 2.'
  id: totrans-205
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置 GID**：**SGID**（执行时设置组ID）标记一个可执行文件，使其在运行时以文件所属组的身份执行，而不是以执行它的用户身份。如果应用于目录，则每个创建或移动到该目录的文件都会将其组设置为拥有目录的组，而不是执行操作的用户所属的组。从视觉上看，它表示为组执行权限位置上的`s`。与之相关的八进制数字是2。'
- en: 'Let''s reset the permissions on our `test` file:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们重置`test`文件上的权限：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we apply SGID using the octal digit referring to it:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们使用表示SGID的八进制数字来应用它：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, the s is capital because we do not have the execution permission
    granted on the group; the same applies for SUID.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，s是大写的，因为我们没有在组上授予执行权限；SUID也是如此。
- en: 'So, now we can go back again to our umask, and at this point you probably already
    know what is the meaning of the four-digit notation is. It is a command that modifies
    the permissions on a file creation, denying the permission bits. Taking our default
    creation mask for directory:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们可以再次回到我们的umask，此时你可能已经知道四位数字表示法的含义了。它是一个在文件创建时修改权限的命令，拒绝设置权限位。以我们目录的默认创建掩码为例：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can think of  `umask` of `0022` as:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`umask`的`0022`理解为：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Do not pay attention to the first `0`; it is the sticky bit and simply subtracts
    from the default grant mask for a directory, `rwx` for user, group, and others,
    the value of the `umask`. The remaining value is the current permission mask for
    file creation. If you are not comfortable with the numeric notation, you can see
    the `umask` values in the familiar `rwx` notation using:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 不要关注第一个`0`；它是粘滞位，仅从目录的默认授予遮罩`rwx`（用户、组和其他）的值中减去`umask`的值。剩下的值就是文件创建的当前权限遮罩。如果你不习惯数字表示法，可以使用以下命令以熟悉的`rwx`表示法查看`umask`值：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For the files, the default mask is `666`, so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件，默认的遮罩是`666`，所以：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It is actually a tad more complicated than this, but this rule of thumb will
    let you calculate the masks quickly. Let us try to create a new `umask`. First,
    let''s reset the `umask` value:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上比这稍微复杂一点，但这个经验法则可以让你快速计算出遮罩。让我们尝试创建一个新的`umask`。首先，重置`umask`值：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As we can see, nothing gets subtracted:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，什么也没有被减去：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `test` file has `666` access rights and the directory `777`. This is really
    way too much:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`文件的访问权限是`666`，目录是`777`。这其实是过多了：'
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you can see, the permissions are 750 for directories and 640 for files.
    A bit of math will help:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，目录的权限是750，文件的权限是640。稍微做点数学就能理解：
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You would get the same result from the `umask` command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`umask`命令获得相同的结果：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: All these settings last as long as you are logged in to the session, so if you
    want to make them permanent, just add the `umask` call with the appropriate argument
    to`/etc/bash.bashrc`,  or `/etc/profile` for a system-wide effect or, for a single
    user mask, add it to the `.bashrc` file inside the user home directory.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些设置会在你登录会话期间生效，所以如果你想使它们永久生效，只需将适当参数的`umask`命令添加到`/etc/bash.bashrc`中，或者为了系统范围的效果，可以添加到`/etc/profile`中，或者对于单个用户的遮罩，可以将其添加到用户主目录中的`.bashrc`文件里。
- en: Something went wrong, let's trace it
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出现了问题，让我们追踪一下
- en: 'So, we have a new tiny script named `disk.sh`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有一个新的小脚本，名为`disk.sh`：
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Nothing special, a shebang, a couple of echoes on a new line just to have some
    vertical spacing, the output of `df -h` and the same command but parsed by `awk`
    to give us a meaningful message. Let''s run it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么特别的，只有一个shebang，在新的一行上添加几个echo来进行垂直间隔，输出`df -h`命令，以及同样的命令通过`awk`解析，以便给出有意义的信息。让我们运行一下：
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The total disk allocation for this system is:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的总磁盘分配为：
- en: '[PRE64]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Nothing too complicated, a bunch of easy commands, which in case of failure
    print an error message on the standard output. However, let''s think for a moment
    that we have a more flexible script, more lines, some variable assignments, loops,
    and other constructs, and something goes wrong, but the output does not tell us
    anything. In this case, be handy to see a method that is actually running inside
    our script so that we can see the output of the commands, the variable assignments,
    and so forth. In Bash, this is possible; thanks to the `set` command associated
    with the `-x` argument, which shows all the commands and arguments in the script
    printed to the `stdout`, after the commands have been expanded and before they
    are actually invoked. The same behavior can be obtained running a subshell with
    the `-x` argument. Let''s see what would happen if it was used with our script:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么复杂的，都是一些简单的命令，如果失败会在标准输出上打印错误信息。然而，让我们想象一下，假设我们有一个更灵活的脚本，更多的行，某些变量赋值、循环和其他结构，并且出现了问题，但输出什么也没告诉我们。在这种情况下，如果能够看到实际在我们脚本内部运行的方法，那就方便多了，这样我们就可以看到命令的输出、变量赋值等等。在Bash中，这是可能的；感谢`set`命令和`-x`参数的组合，它会在命令展开后、实际调用之前将所有的命令和参数打印到`stdout`。通过`-x`参数运行子shell也能获得相同的行为。让我们看看如果在我们的脚本中使用它会发生什么：
- en: '[PRE65]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now it is quite easy to understand how the stream of data flows inside the
    script: all the lines beginning with a `+` sign are commands, and the following
    lines are outputs.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在非常容易理解数据流是如何在脚本中流动的：所有以`+`号开头的行是命令，接下来的行是输出。
- en: 'Let''s think for a moment that we have longer scripts; for most parts, we are
    sure that things work fine. For some lines, we are not completely sure of the
    outcome. Debugging everything would be *noisy*. In this case, we can use `set-x`
    to enable the logging only for those lines we need to inspect, turning it off
    with `set+x` when it is no longer needed. Time to modify the script, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一想，我们有更长的脚本；对于大多数部分，我们确信事情进行得很顺利。对于某些行，我们并不完全确定结果。调试所有这些将会是*嘈杂的*。在这种情况下，我们可以使用`set-x`仅为需要检查的那些行启用日志记录，在不再需要时使用`set+x`关闭它。是时候修改脚本了，如下所示：
- en: '[PRE66]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And now, time to run it again, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候再次运行它了，如下所示：
- en: '[PRE67]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, we see the instructions given in the block marked by `set-x`,
    and we also see the `set+x` instruction given, but then, after this, the line
    with `awk` disappears and we see only its output, filtering out what was not so
    interesting for us and leaving only the part we want to focus on.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在由`set-x`标记的块中看到了给出的指令，我们还看到了给出的`set+x`指令，但随后，带有`awk`的行消失了，我们只看到了它的输出，过滤掉了对我们来说不太有趣的部分，只留下了我们想要关注的部分。
- en: This is not a powerful debugging system typical of more complex programming
    languages, but it can be really helpful in scripts of hundreds of lines where
    we can lose track of sophisticated structures, such as evaluations, cycles, or
    variable assignments, which make the scripts more expressive but even more difficult
    to get hold of and master. So, now that we are clear on how to debug a file, which
    permissions are needed to make it safely executable, and how to shell parse the
    command line, we are ready to spice things up looking at how we can use variables
    to add more flexibility to our hand-crafted tools.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是更复杂的编程语言典型的强大调试系统，但在数百行的脚本中，它确实非常有用，那些脚本可能会失去对于评估、循环或变量分配等复杂结构的追踪，这使得脚本更加表达但也更难掌握和掌控。因此，现在我们清楚了如何调试文件，需要哪些权限来安全地使其可执行，以及如何解析命令行，我们准备好看看如何使用变量为我们手工制作的工具增添更多的灵活性。
- en: Variables
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'What is a variable? We could answer that it is something not constant; nice
    joke, but it would not help us so much. Better to think of it as a bucket where
    we can store some information for later processing: at a certain point of your
    script you get a value, a piece of info that you do not want to process at that
    very moment, so you fit it into a variable that you will recall later in the script.
    This is, in an intuitive way, the use of a variable, a way to allocate a part
    of the system memory to hold your data.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是变量？我们可以回答说它不是常数；这个笑话很好，但对我们帮助不大。最好将其视为一个桶，我们可以在其中存储一些信息以供稍后处理：在脚本的某一点上，你获取一个值，一个信息片段，你不想在那一刻处理它，因此你将它放入一个变量中，稍后在脚本中调用它。这在直观上就是变量的使用方式，一种分配系统内存的方式来保存你的数据。
- en: 'So far, we have seen that our scripts could retrieve some pieces of information
    from the system and had to process them straight away, since, without the use
    of a variable, we had no way to further process the information except for concatenating
    or redirecting the output to another program. This forced us to have a linear
    execution, no flexibility, no complexity: once you get some data, you process
    it straight away redirecting the file descriptors, one link in the chain after
    the other.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们的脚本可以从系统中检索一些信息，并且必须立即处理它们，因为如果没有使用变量，我们没有办法进一步处理信息，除了将输出连接或重定向到另一个程序。这迫使我们进行线性执行，没有灵活性，没有复杂性：一旦获取了一些数据，就立即处理它们，将文件描述符依次重定向到链中的另一个。
- en: 'A variable is nothing really new; a lot of programming languages use them to
    store different types of data, integers, floating, strings, and you can see many
    different kinds of variables related to different kinds of data they hold. So,
    you have probably heard about casting a variable, which means, roughly, changing
    its type: you get a value as a string of numbers and you want to use it as an
    integer, so you cast it as an `int` and proceed processing it using some math
    functions.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 变量并不是什么新鲜事物；许多编程语言都使用它们来存储不同类型的数据，整数、浮点数、字符串，你可以看到许多与它们相关的不同类型的变量，它们持有不同类型的数据。所以，你可能听说过变量的类型转换，大致意思是改变它的类型：你得到一个数字字符串的值，你想把它用作整数，所以你将它转换为`int`，然后使用一些数学函数处理它。
- en: 'Our shell is not so sophisticated, and it has only one type of variable or,
    better, it has none: whatever you store in it can be later processed without any
    casting. This can be nice because you do not have to pay attention to what type
    of data you are holding; you get a number as a string and can process it straight
    away as an integer. Nice and easy, but we must remember that restrictions are
    in place not just to prevent us from doing something, but also to help us not
    do something that would be unhealthy for our code, and this is exactly the risk
    in having flat variables, to write some piece of code that simply does not work,
    cannot work.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Shell不太复杂，它只有一种类型的变量，或者更准确地说，它没有变量类型：你存储在其中的任何内容稍后都可以不经类型转换地进行处理。这可能很方便，因为你不需要关心所持数据的类型；你得到一个作为字符串的数字，可以直接作为整数处理。简单又轻松，但我们必须记住，限制不仅仅是为了防止我们做某事，也是在帮助我们避免做一些对代码不健康的事情，这正是拥有扁平化变量的风险——编写一些根本无法工作的代码，不能工作的代码。
- en: Assigning a variable
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值一个变量
- en: 'As we just saw, a variable is a way to store a value: we get a value, assign
    it to a variable and refer to the latter to access the former. The operation of
    retrieving the content of a variable is named **variable substitution**. A bit
    like, if you think about descriptors, the way that  you use them to access files.
    The way you assign a variable is quite straightforward:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，变量是一种存储值的方式：我们获取一个值，将其赋给一个变量，然后通过后者来访问前者。检索变量内容的操作叫做**变量替换**。有点像，如果你想象描述符，使用它们来访问文件。赋值变量的方式相当简单：
- en: '[PRE68]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`LABEL` can be any string, can have upper and lowercase, start with or contain
    numbers and underscores, and it is case sensitive.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL`可以是任何字符串，可以包含大写和小写字母，开始或包含数字和下划线，并且区分大小写。'
- en: 'The assignment is performed by the `=` character, which, be wary, is not the
    same as the *equal to *`==` sign; they are two different things and are used in
    different contexts. Finally, whatever you put at the right of the assignment operator
    becomes the value of the variable. So, let''s assign some value to our first variable:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值是通过`=`字符来进行的，注意，它与*等于*`==`符号不同；它们是两回事，并且用于不同的上下文。最后，无论你在赋值符号右边放什么，它就会成为变量的值。那么，让我们给第一个变量赋值：
- en: '[PRE69]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we can try to access the value trying to perform an action on the variable
    itself:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试通过对变量本身执行操作来访问值：
- en: '[PRE70]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Not exactly what we expected. We want the content, not the name of the variable.
    Have a look at this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是我们期望的结果。我们想要的是内容，而不是变量名。看看这个：
- en: '[PRE71]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This is better. Using the `$` character at the beginning of the variable name
    identified this as a variable and not a plain string, so we had access to the
    content. This means that, from now on, we can just use the variable with any commands
    instead of referring to the whole content of it. So, let us try again:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好。将`$`字符放在变量名的开头，使其被识别为变量而不是普通字符串，这样我们就可以访问其中的内容。这意味着，从现在开始，我们可以直接使用变量与任何命令，而不需要引用整个内容。所以，让我们再试一次：
- en: '[PRE72]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The output is null, and not 0; we will see later on that zero is not the same
    as null, since null is no value but zero is indeed a value, an integer. What does
    the previous output mean? Simply that our labels are case sensitive, change one
    character from upper to lower or vice versa, and you will have a new variable
    which, since you did not assign any value to it, does not hold any value, hence
    the null you receive once you try to access it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是null，而不是0；稍后我们会看到，零与null并不相同，因为null代表没有值，而0确实是一个值，一个整数。前面的输出是什么意思？简单来说，就是我们的标签区分大小写，只要改变一个字符的大小写，你就会得到一个新变量，由于没有给它赋值，它不包含任何值，因此你在尝试访问它时会得到null。
- en: Keep the variable name safe
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持变量名的安全
- en: 'We just saw that `$label` is the way we reference the content of a variable,
    but if you have a look at some scripts, you can find another way of retrieving
    variable content:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到`$label`是我们引用变量内容的方式，但是如果你查看一些脚本，你会发现另一种获取变量内容的方法：
- en: '[PRE73]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The two ways of referencing the content of a variable are both valid, and you
    can use the first, more compact, in any case except when concatenating the variable
    name to any characters, which could change the variable name itself. In this case,
    it becomes mandatory to use the extended version of the variable substitution,
    as the following example will make clear.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量内容的两种方式都是有效的，你可以在任何情况下使用第一种更紧凑的方式，除了在将变量名与任何字符连接时，这可能会改变变量名本身。在这种情况下，必须使用扩展版的变量替代方法，正如以下示例将明确说明的那样。
- en: 'Let''s start printing our variable again:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打印我们的变量：
- en: '[PRE74]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, let''s do it again using the extended version of substitution:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用扩展版的替代法再做一遍：
- en: '[PRE75]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Exactly the same output since, as we said, these two methods are equivalent.
    Now, let us add a string to our variable name:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 完全相同的输出，因为正如我们所说的，这两种方法是等效的。现在，让我们给变量名添加一个字符串：
- en: '[PRE76]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Nothing, and we can understand why the name of the variable changed; so we
    have no content to access to. But now, let us try the extended way:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 什么也没有，我们能理解为什么变量名改变了；所以我们没有内容可以访问。但现在，让我们尝试扩展方式：
- en: '[PRE77]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Bingo! The name of the variable has been preserved so that the shell was able
    to reference its value and then concatenated it to the `ly` string we added to
    the name.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！变量的名字被保留下来，以便 shell 能够引用它的值，然后将其与我们添加到名字中的 `ly` 字符串连接。
- en: Keep this difference in mind, because the graphs will be a handy way to concatenate
    strings to a variable to spice your scripts up and, as a good rule of thumb, refer
    to variables using the graphs. This will help you avoid unwanted hindrances.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个区别，因为图形将成为连接字符串与变量的一种便捷方式，可以为你的脚本增色。而且作为一个好习惯，建议使用图形引用变量。这样可以帮助你避免不必要的障碍。
- en: Variables with limited scope
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的作用域有限
- en: As we said before, variables have no type in shell, and this makes them somehow
    easy to use, but we must pay attention to some sorts of limits to their use.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，变量在 shell 中没有类型，这使得它们在某种程度上容易使用，但我们必须注意它们使用的一些限制。
- en: First, the content of a variable is accessible only after the value has been
    assigned
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，变量的内容只有在赋值后才可以访问。
- en: 'An example will make everything clearer:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个例子会让一切变得更清楚：
- en: '[PRE78]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We used the variable disk space to store the result of the `df` command and
    try to reference its value on the preceding and following lines. Let us run it
    in debug mode:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用变量 `disk_space` 来存储 `df` 命令的结果，并尝试在前后行引用它的值。让我们以调试模式运行它：
- en: '[PRE79]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As we can see, the flow of execution is sequential: you access the value of
    the variable only after it is instanced, not before. And bear in mind that the
    first line actually printed something: a null value. Well, now let us print the
    variable on the command line:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，执行流程是顺序的：只有在变量实例化之后，你才能访问它的值，而不是在之前。还要记住，第一行实际上打印了某些内容：一个空值。那么，现在让我们在命令行打印变量：
- en: '[PRE80]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The variable is instanced inside the script, and it is confined there, inside
    the shell spawned to invoke the command and nothing passed to our main shell.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在脚本内实例化，它被限制在那里面，存在于启动命令时生成的 shell 内，并且没有任何内容传递到我们的主 shell。
- en: 'We can ourselves impose some restrictions to a variable, as we will see with
    the next example. In this new case, we will introduce the use of a function, something
    that we are going to look at in more detail further in this book and the keyword
    local:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对一个变量施加一些限制，正如我们在下一个例子中将看到的那样。在这个新例子中，我们将引入函数的使用，这是本书后续部分会详细探讨的内容，以及关键字
    `local`：
- en: '[PRE81]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now let us run it:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行它：
- en: '[PRE82]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: What can we see here?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能看到什么？
- en: The content of variable `disk_space` is not available before the variable itself
    is instanced. We already knew this.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `disk_space` 的内容在变量本身实例化之前不可用。我们已经知道这一点。
- en: The content of a variable instanced inside a function is not available when
    it is defined in the function, but when the function itself is invoked.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在函数内部实例化后的内容，在函数定义时不可用，只有当函数本身被调用时才能访问。
- en: A variable marked by the keyword local and defined inside a function is available
    only inside the function and only when the function is invoked. Outside the block
    of code defined by the function itself; the local variable is not visible to the
    rest of the script. So, using local variables can be handy to write recursive
    code, even though not recommended.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `local` 关键字标记并在函数内部定义的变量，仅在函数内部且函数被调用时可用。在函数本身定义的代码块外，局部变量对脚本的其余部分不可见。因此，使用局部变量对编写递归代码很有帮助，尽管不推荐使用。
- en: So, we just saw a few ways to make a variable really limited in its scope, and
    we also noted that its content is not available outside the script it was instanced
    in. Wouldn't it be nice to have some variables with a broader scope, capable of
    influencing the execution of each and every script, something at environment level?
    It would, and from now on we are going to explore the environment variables.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们刚才看到了几种方法，可以将一个变量限制在特定的作用域内，我们还注意到它的内容在其实例化的脚本之外无法访问。是不是很希望能有一些作用域更广的变量，能够影响每一个脚本的执行，类似于环境级别的东西？是的，接下来我们将探索环境变量。
- en: Environment variables
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量
- en: 'As we discussed earlier, the shell comes with an environment, which dictates
    what it can do and what not, so let''s just have a look at what these variables
    are using the `env` command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，shell 带有一个环境，决定了它能做什么和不能做什么，所以下面我们就用 `env` 命令来看看这些变量到底是什么：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Some of the variables have been omitted for the sake of clarity; otherwise,
    the output would have been too long, but still we can see something interesting.
    We can have a look at the `PATH` variable content, which influences where the
    shell will look for a program or script to execute. We can see which shell is
    being currently used, by which user, what the current directory is and the previous
    one.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，一些变量被省略了，否则输出会太长，但我们仍然可以看到一些有趣的东西。我们可以查看 `PATH` 变量的内容，它决定了 shell 会在哪些地方查找要执行的程序或脚本。我们还可以看到当前正在使用的是哪个
    shell，哪个用户在使用它，当前目录是什么，以及上一个目录是什么。
- en: 'But environment variables can not only be read; they can be instanced using
    the export command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 但是环境变量不仅可以被读取，还可以通过 export 命令来实例化：
- en: '[PRE84]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, let us read it:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们读取它：
- en: '[PRE85]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'That is it, but since this was just a test, it is better to unset the variable
    so that we do not leave unwanted values around the shell environment:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，但由于这只是一个测试，最好取消设置变量，以免在 shell 环境中留下不必要的值：
- en: '[PRE86]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And now, let us try to get the content of the variable:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试着获取变量的内容：
- en: '[PRE87]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'No way! The variable content is no more, and as you will see now, the environment
    variables disappear once their shell is no more. Let''s have a look at the following
    script:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能！变量的内容不见了，正如你现在会看到的，一旦 shell 结束，它的环境变量就会消失。让我们看看下面的脚本：
- en: '[PRE88]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We simply instance a new variable, `grep` for it in the environment and then
    print its content to the `stdout`. What happens once invoked?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地实例化一个新变量，在环境中 `grep` 它，然后将其内容打印到 `stdout`。调用后会发生什么？
- en: '[PRE89]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We can easily see that the variable was grepped on the `env` output, so this
    means that the variable is actually instanced at the environment level and we
    could access its content and print it. But then we executed the echo of the content
    of `MYTEST` outside the script again, and we could just print a blank line. If
    you remember, when we execute a script, the shell forks a new shell and passes
    to it its full environment, thus the command inside the program shell can manipulate
    the environment. But then, once the program is terminated, the related shell is
    terminated, and its environment variables are lost; the child shell inherits the
    environment from the parent, the parent does not inherit the environment from
    the child.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地看到变量已经在 `env` 输出中被 grep，所以这意味着该变量实际上是以环境级别实例化的，我们可以访问它的内容并打印出来。但接下来我们再次执行了
    `MYTEST` 的内容回显，但却只是打印了一个空行。如果你还记得，当我们执行脚本时，shell 会派生一个新的 shell，并将其完整的环境传递给它，因此程序内的命令可以操作该环境。但一旦程序终止，相关的
    shell 也会终止，其环境变量也会丢失；子 shell 会继承父 shell 的环境，父 shell 并不会继承子 shell 的环境。
- en: 'Now, let us go back to our shell, and let us see how we can manipulate the
    environment to our advantage. If you remember, when the shell has to invoke a
    program or a script, it looks inside the content of the `PATH` environment variable
    to see if it can find it in one of the paths listed. If it is not there, the executable
    or the script cannot be invoked just with their names, they have to be called
    passing the full path to it. But have a look at what this script is capable of
    doing:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的 shell，看看如何利用环境来为我们所用。如果你还记得，当 shell 需要调用一个程序或脚本时，它会查看 `PATH` 环境变量的内容，看看能不能在列出的路径中找到它。如果找不到，无法仅凭名字调用可执行文件或脚本，必须传入完整路径。但看看这个脚本能做什么：
- en: '[PRE90]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We print our current user directory:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印当前用户目录：
- en: '[PRE91]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And now we print the content of the environment `PATH` variable:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打印环境中 `PATH` 变量的内容：
- en: '[PRE92]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This is a little tricky. Using the graphs, we preserve the content of the variable
    and add `a`, which is the delimiter for each path inside the list held by `PATH`,
    plus the `~/tmp`, which literally means the `tmp` directory inside the `home`
    directory of the current user:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点棘手。使用图表，我们保留了变量的内容，并添加了`a`，它是`PATH`列表中每个路径的分隔符，加上`~/tmp`，这字面意思是当前用户`home`目录下的`tmp`目录：
- en: '[PRE93]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And we actually found it. Well, you could also add some evaluation to make
    the `echo` conditional, but we will see such a thing later on. Time for something
    funny:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的找到了。好吧，你也可以添加一些评估来让`echo`变成条件语句，但我们稍后会看到这种用法。接下来是一些有趣的内容：
- en: '[PRE94]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Pay attention to the line starting with `env`; this command is able to overrun
    the `PATH` environment variable and to pass its own variable and related value.
    The same behavior can be obtained using export instead of `env`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以`env`开头的那行；这个命令能够覆盖`PATH`环境变量，并传递它自己的变量及相关值。使用`export`代替`env`也可以获得相同的行为：
- en: '[PRE95]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This last try is even worse. We modified the content of the `$PATH` variable
    which now points to a directory where we cannot find the script. So, not being
    in the `$PATH`, the script cannot be invoked by just its name:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的尝试甚至更糟。我们修改了`$PATH`变量的内容，它现在指向一个找不到脚本的目录。所以，脚本不在`$PATH`中，仅凭名字无法调用：
- en: '[PRE96]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We are in the directory:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在目录中：
- en: '[PRE97]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: What is our `PATH`?
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PATH`是什么？
- en: '[PRE98]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now we expand the path for all the shell.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为所有的shell扩展了路径。
- en: 'And now our `PATH` is:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`PATH`是：
- en: '[PRE99]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We are looking for the `setting.sh` script!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找`setting.sh`脚本！
- en: '[PRE100]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Found it!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 找到了！
- en: Time for magic!
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法时刻！
- en: We are looking for the `setting.sh` script!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找`setting.sh`脚本！
- en: BOOOO, nothing!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: BOOOO，什么都没有！
- en: Second try...
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次尝试…
- en: '`env`: ''which'': No such file or directory'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`env`：''which''：没有此类文件或目录'
- en: No way...
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能…
- en: '| **Environment variable** | **Use** |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| **环境变量** | **用途** |'
- en: '| `BASH_VERSION` | The version of the current Bash session |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `BASH_VERSION` | 当前Bash会话的版本 |'
- en: '| `HOME` | The home directory of the current user |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `HOME` | 当前用户的主目录 |'
- en: '| `HOSTNAME` | The name of the host |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `HOSTNAME` | 主机名 |'
- en: '| `LANG` | The locale used to manage the data |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `LANG` | 用于管理数据的地区设置 |'
- en: '| `PATH` | The search path for the shell |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `PATH` | shell的搜索路径 |'
- en: '| `PS1` | The prompt configuration |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `PS1` | 提示符配置 |'
- en: '| `PWD` | The path to the current directory |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `PWD` | 当前目录的路径 |'
- en: '| `USER` | The name of the currently logged in user |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `USER` | 当前登录用户的名字 |'
- en: '| `LOGNAME` | Same as user |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `LOGNAME` | 同`user` |'
- en: 'We can also use `env` with the `-i` argument to strip down all the environment
    variables and just pass to the process what we want, as we can see in the following
    examples. Let''s start with something easy:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用带有`-i`参数的`env`命令来剥离所有环境变量，只传递给进程我们想要的，就像我们在以下示例中看到的那样。让我们从简单的开始：
- en: '[PRE101]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Nothing too difficult, we modified the `PATH` variable passing a useless value
    because `HELLO` is not a searchable path, then we had to invoke `env` using the
    full path because `PATH` became useless. Finally, we piped everything to the input
    of `grep`, which will select all the rows (`^)` starting with the string `PATH`,
    printing that line and one line before and after:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么难的，我们修改了`PATH`变量，传递了一个无用的值，因为`HELLO`不是一个可搜索的路径，然后我们必须使用完整路径来调用`env`，因为`PATH`变得无效。最后，我们将所有内容传递给`grep`的输入，它会选择所有以字符串`PATH`开头的行（`^`），并打印出该行及其前后各一行：
- en: '[PRE102]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, let''s modify the script, adding `-i` to the first `env`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改脚本，给第一个`env`添加`-i`：
- en: '[PRE103]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'And now let us run it:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行它：
- en: '[PRE104]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Can you guess what happened? Another change will make everything clearer:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到发生了什么吗？再做一个更改，会让一切变得更加清晰：
- en: '[PRE105]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'No `grep`; we are able to see the complete output of the second `env` command:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`grep`；我们能够看到第二个`env`命令的完整输出：
- en: '[PRE106]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Just `PATH=HELLO env` with the argument `-i` passed to the second `env` process,
    a stripped down environment with only the variables specified on the command line:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅是将`PATH=HELLO env`作为参数传递给第二个`env`进程，这是一个简化的环境，仅包含命令行中指定的变量：
- en: '[PRE107]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Because we are engaged in stripping down, let us see how we can make a function
    disappear with the well-known `unset -f` command:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在进行简化，让我们看看如何使用著名的`unset -f`命令让一个函数消失：
- en: '[PRE108]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Time to verify what happens with the `unset` command:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 该是验证`unset`命令效果的时候了：
- en: '[PRE109]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The space left is:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的空间是：
- en: '[PRE110]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Unset done, now let us invoke the function:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 完成取消设置，现在让我们调用函数：
- en: '[PRE111]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The `print` function works well, as expected before we unset it, and also the
    variable content becomes no longer available. Speaking about variables, we can
    actually unset some of them on the same row using the following:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 函数表现正常，如预期那样，直到我们取消设置它，此时变量内容不再可用。说到变量，我们实际上可以在同一行上取消设置一些变量，方法如下：'
- en: '[PRE112]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: We saw how to modify an environment variable, but what if we want to make it
    read-only so to protect its content from an unwanted modification?
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到如何修改一个环境变量，但如果我们想使它成为只读，以防止其内容被意外修改呢？
- en: '[PRE113]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Look at the line `readonlyPATH`, and now let''s see what the execution of this
    script leads us to:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这一行 `readonlyPATH`，现在让我们看看执行这个脚本会带我们走向何处：
- en: '[PRE114]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'What happened is that our script tried to modify the `PATH` variable that was
    just made `readonly` a few lines before and failed. This failure then led us out
    of the screen with a failure, and this is confirmed by printing the value of the
    `$?` variable, which holds the exit state of the last command invoked:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是，我们的脚本尝试修改 `PATH` 变量，而这个变量在几行前刚刚被设置为 `readonly`，因此失败了。这次失败导致我们退出屏幕，显示错误，这可以通过打印
    `$?` 变量的值来确认，`$?` 变量保存了上一个命令的退出状态：
- en: '[PRE115]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We will see the use of such a kind of variable later, but now what interests
    us is to know what that `0` and `1` mean: the first time we issued the `echo`
    command, right after invoking the script, it gave us the exit code `1`, which
    means failure, and this makes sense because the script exited abruptly with an
    error. The second time we ran `echo`, it showed `0`, which means that the last
    command executed, the previous `echo` went well, without any errors.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到这种类型的变量的使用，但现在我们关心的是理解那个 `0` 和 `1` 的含义：第一次运行 `echo` 命令时，在调用脚本之后，它返回了退出代码
    `1`，表示失败，这很有道理，因为脚本因错误而中断退出。第二次运行 `echo` 时，它显示了 `0`，表示上一个命令成功执行，之前的 `echo` 没有任何错误。
- en: Variable expansion
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量扩展
- en: 'The variable expansion is the method we have to access and actually change
    the content of a variable or parameter. The simplest way to access or reference
    the variable value is as in the following example:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 变量扩展是我们访问并实际更改变量或参数内容的方法。访问或引用变量值的最简单方式如下所示：
- en: '[PRE116]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'So, we assigned a value to the variable `x` and then referenced the value preceding
    the variable name with the dollar sign `$.` So, `echo$x` prints the content of
    `x`, `1`, to the standard output. But we can do something even more subtle:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们给变量 `x` 赋了一个值，然后在变量名前加上美元符号 `$` 来引用该值。于是，`echo$x` 打印了 `x` 的内容，即 `1`，到标准输出。但我们还可以做得更微妙一些：
- en: '[PRE117]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'So, we gave a value to the variable `x`, then we instanced the variable `y`
    referencing the content of the variable `x`. So, `y` got its assignment referencing
    the value of `x` through the `$` character, not directly using a number after
    the `=` char. So far, we saw two different ways to reference a variable:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们给变量 `x` 赋了一个值，然后通过引用变量 `x` 的内容实例化了变量 `y`。因此，`y` 通过 `$` 符号引用 `x` 的值，而不是直接使用数字赋值。到目前为止，我们看到两种不同的引用变量的方式：
- en: '[PRE118]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The first one is terser, but it would be better to stick to the second way because
    it preserves the name of the variable and, as we saw a few pages before, it allows
    us to concatenate a string to the variable without losing the possibility of referencing
    it.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法简洁，但最好还是使用第二种方式，因为它保留了变量的名称，并且正如我们在前几页所见，它允许我们在不丢失引用变量的可能性的情况下，将字符串与变量连接起来。
- en: 'We just saw the simplest among different ways to manipulate the value held
    by a variable. What we are going to see now is how to thinker with a variable
    to have default values and messages, so we make the interaction with the variable
    more flexible. Before proceeding, just bear in mind that we can use two notations
    for our next example and they are equivalent:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的是不同方式中最简单的操作变量值的方法。接下来，我们将看到如何操作变量，使其具有默认值和消息，从而让我们与变量的交互更加灵活。在继续之前，请记住，我们可以使用两种符号表示法，它们是等价的：
- en: '[PRE119]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'So, you could see either of the two in a script, and both are correct:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在脚本中你可能会看到这两种方式，它们都是正确的：
- en: '[PRE120]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Simply, if a variable is not set, return a default value, as we can see in
    the following example:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，如果一个变量没有设置，则返回默认值，正如我们在下面的示例中看到的：
- en: '[PRE121]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now, let''s execute it:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行一下：
- en: '[PRE122]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: As mentioned before, the two notations, with or without the colon, are quite
    the same. Let us see what happens if in the previous script we substitute `${x:-somenumber}`
    with `${x-somenumber}`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，带冒号或不带冒号的两种符号是非常相似的。让我们看看如果在前面的脚本中将`${x:-somenumber}`替换为`${x-somenumber}`会发生什么。
- en: 'Let''s run the modified script:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行修改后的脚本：
- en: '[PRE123]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Everything is fine, but the last line. So what is the difference at play here?
    Simple:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都正常，但最后一行。那么，这里起作用的区别是什么呢？很简单：
- en: '`*${x-30}`: The notation with a colon forces a check on the existence of a
    value for the variable and this value may well be null. In case you have a value,
    it does print the value of the variable, ignoring the fallback.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*${x-30}`: 带冒号的符号强制检查变量的值是否存在，而这个值可能为null。如果有值，它会打印变量的值，忽略回退值。'
- en: '`unset -f x`: It unsets the variable, so it has no value and we have a fallback
    value'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unset -f x`: 它取消设置变量，因此它没有值，我们会得到一个回退值。'
- en: '`x=`: It gives a null to `x`; so the fallback does not come in to play, and
    we get back the variable value, for example, null'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x=`: 它给`x`赋值为null；因此回退机制不会起作用，我们得到变量的值，例如，null。'
- en: '`${x:-30}`: This forces a fallback value in case the value of a variable is
    null or nonexistent'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${x:-30}`: 如果变量的值为null或不存在，这强制使用回退值。'
- en: '`unset -f x`: It unsets the variable, so it has no value and we have a fallback
    value'
  id: totrans-409
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unset -f x`: 它取消设置变量，因此它没有值，我们会得到一个回退值。'
- en: '`x=`: It gives a null to `x`, but the fallback comes in to play and we get
    a default value'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x=`: 它给`x`赋值为null，但回退机制起作用，我们得到一个默认值。'
- en: 'Default values can be handy if you are writing a script which expects an input
    or the customer: if the customer does not provide a value, we can use a fallback
    default value and have our variable instanced with something meaningful:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值在编写需要输入的脚本时非常有用，尤其是当客户没有提供值时：如果客户没有提供值，我们可以使用回退默认值，并使变量实例化为有意义的内容：
- en: '[PRE124]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We ask the user for an input. If he gives us a value, we print it; otherwise,
    we fallback the value of the variable to `99` and print it:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求用户提供输入。如果他给我们一个值，我们打印它；否则，我们将变量的回退值设置为`99`并打印它：
- en: '[PRE125]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If the variable has a value, it is returned; otherwise, the variable has a
    default value assigned. In the previous case, we got back a value if the variable
    had no value; or null, here the variable is actually assigned a value. Better
    to see an example:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量有值，则返回该值；否则，变量将被分配一个默认值。在前一个案例中，如果变量没有值，我们得到一个返回的值；或者是null，这里变量实际上被赋予了一个值。最好看一个例子：
- en: '[PRE126]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We set a variable and then print its value. Then, we unset it and print its
    value, but because it is unset, we get back a default value. So we try to print
    the value of `x`, but since the number we got in the preceding operation was not
    obtained by an assignment, `x` is still unset. Finally, we use `echo "${x:=30}"`
    and get the value `30` assigned to the variable `x`, and indeed, when we print
    the value of the variable, we get something. Let us see the script in action:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置一个变量并打印其值。然后，我们取消设置它并打印其值，但因为它被取消设置，所以我们会得到一个默认值。然后，我们尝试打印`x`的值，但由于前面的操作中得到的数字不是通过赋值获得的，`x`仍然没有设置。最后，我们使用`echo
    "${x:=30}"`，并将值`30`赋给变量`x`，确实，当我们打印变量的值时，我们得到了一个值。让我们看看脚本的执行效果：
- en: '[PRE127]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Notice the blank line in the middle of the output: we just got a value from
    the preceding operation, not a real variable assignment:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中的空白行：我们刚刚从前面的操作中得到一个值，而不是一个真正的变量赋值：
- en: '[PRE128]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Force a check on the existence of a non null value for a variable. If it exists,
    it returns the default value; otherwise it returns null:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 强制检查变量是否有非null值。如果有值，返回默认值；否则返回null：
- en: '[PRE129]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, let us run it and check, as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行它并检查，如下所示：
- en: '[PRE130]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'As you can see, when the variable is correctly instanced, instead of returning
    its value, it returns a default `100` and this is double-checked in the following
    rows where we print the value of `x` and it is still `10`: the `100` we saw was
    not a value assignment but just a default returned instead of the real value:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当变量正确实例化时，它不会返回其值，而是返回一个默认的`100`，并且在后面的行中我们打印`x`的值，它仍然是`10`：我们看到的`100`并不是赋值，而只是作为默认值返回，而不是实际的值。
- en: '[PRE131]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The results are quite straightforward:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是相当直接的：
- en: '[PRE132]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'As we tried to access a `void` variable, but for the unset would have been
    the same, the script exited with an error and the message we got from the variable
    expansion. All good with the first line, `x` has a value and we printed it but,
    as you can see, we cannot arrive to the third line, which remains unparsed: the
    script exited abruptly with a default message printed.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问一个 `void` 变量时，由于未设置，情况应该是一样的，脚本因错误退出，并打印了我们从变量扩展中得到的消息。第一行没问题，`x` 有值并且我们打印了它，但如你所见，我们无法到达第三行，第三行保持未解析状态：脚本在打印默认消息后突然退出。
- en: Nice stuff, isn't it? Well, there is a lot more, we have to look at the pattern
    matching against variables.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，对吧？好吧，还有很多内容，我们需要继续探索模式匹配与变量的关系。
- en: Pattern matching against variables
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对变量进行模式匹配
- en: 'We have a few ways to fiddle with variables, and some of these have a really
    interesting use in scripts, as we will see later on in this book. Let''s briefly
    recap what we can do with variables and how to do it, but remember we are dealing
    with values that are returned, not assigned back to the variable:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方式可以操作变量，其中一些在脚本中有非常有趣的用途，稍后在本书中我们会看到。让我们简要回顾一下我们可以对变量做什么以及如何做，但记住我们处理的是返回的值，而不是回赋给变量：
- en: '[PRE133]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'It gives us the length of the variable, or if it is an array, the length of
    the first element of an array. Here is an example:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 它为我们提供了变量的长度，或者如果是数组，则为数组第一个元素的长度。这里有一个例子：
- en: '[PRE134]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'And indeed `thisisaverylongvalue` is made up of  `20` characters. Now, let
    us see an example with arrays:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，`thisisaverylongvalue` 是由 `20` 个字符组成的。现在，让我们来看一个关于数组的例子：
- en: '[PRE135]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Here, we instantiated an array with three elements `apple`, `pear`, and `banana`.
    We will see later in this book how to work with arrays in detail:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化了一个包含三个元素的数组：`apple`、`pear` 和 `banana`。稍后我们将在本书中看到如何详细处理数组：
- en: '[PRE136]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We printed the third element of the array. Arrays start with an index of 0,
    so the third element is at index `2`, and it is banana, a 6 characters long word:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印了数组的第三个元素。数组的索引从 0 开始，所以第三个元素在索引 `2` 处，它是 banana，一个长度为 6 个字符的单词：
- en: '[PRE137]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We print the second element of the array: pear,a 4 characters long word:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印了数组中的第二个元素：pear，一个长度为4个字符的单词：
- en: '[PRE138]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: And now, the first element, that is, apple is 5 characters long. Now, if the
    example we saw is true, the following command should return `5`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一个元素，即 apple 是 5 个字符长。现在，如果我们看到的例子是正确的，下面的命令应该返回 `5`。
- en: '[PRE139]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'And indeed, the length of the word apple is `5` characters:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，单词 apple 的长度是 `5` 个字符：
- en: '[PRE140]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'If you need to tear out your variable, for a part of it you can use a pattern
    and remove the shortest occurrence of the pattern from the beginning of the variable
    and return the resulting value. It is not a variable assignment, not so easy to
    grasp, but an example will make it clear:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从变量中提取一部分，可以使用模式并去除模式在变量开头的最短出现，然后返回结果值。这不是变量赋值，不是那么容易理解，但通过一个例子会更清楚：
- en: '[PRE141]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'This form is like the preceding one but with a slight difference, the pattern
    is used to remove its largest occurrence in the variable:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这个形式与前一个类似，但有一个小差异，模式用于移除变量中最大的一次出现：
- en: '[PRE142]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'We instanced the variable with a series of recurring digits:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一系列重复的数字实例化了变量：
- en: '[PRE143]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Then, we tried to match a pattern, which means any digit between a leading
    and ending 1, the shortest occurrence. So it took out 10102010103:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试匹配一个模式，即在前后都为1的情况下，最短的出现形式。结果是提取出了 10102010103：
- en: '[PRE144]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Now, we cut away the widest occurrence of the pattern, and so 10102010103,
    resulting in a meager `03` as the value returned:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们去除模式的最宽广出现，因此 10102010103，结果返回一个微不足道的 `03` 作为返回值：
- en: '[PRE145]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Here, we cut away the shortest occurrence of the pattern but now from the end
    of the variable value:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从变量值的末尾去除了模式的最短出现：
- en: '[PRE146]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'So, the shortest occurrence of the `1*3` pattern counted from the end of the
    file is `10102010103` so we get `10102010` back:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从文件末尾开始计算，`1*3` 模式的最短出现是 `10102010103`，所以我们返回 `10102010`：
- en: '[PRE147]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Similar to the previous example, with `##`, in this case, we cut away the longest
    occurrence of the pattern from the end of the variable value:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于前面的示例，使用 `##` 时，在这种情况下，我们从变量值的末尾去除模式的最长出现：
- en: '[PRE148]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Quite clear, isn''t it? The longest occurrence is `1*3` is `10102010103`, so
    we tear away everything and we return nothing, as this example which makes use
    of the evaluation of `-z` (is empty) will show:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 相当清楚，对吧？最长的出现 `1*3` 是 `10102010103`，所以我们去除了所有内容，什么也不返回，就像这个使用 `-z`（是否为空）评估的例子所展示的那样：
- en: '[PRE149]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The reader familiar with regular expressions probably already understood what
    the outcome is: replace the first occurrence of the pattern in the variable by
    substitution. If substitution does not exist, then delete the first occurrence
    of a pattern in variable:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉正则表达式的读者可能已经了解结果是什么：将变量中的模式的第一次出现替换为替换内容。如果替换不存在，则删除变量中模式的第一次出现：
- en: '[PRE150]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Not so nasty, and we were able to instance a variable with the output of our
    find and replace:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 并不那么讨厌，我们能够使用我们的查找和替换的输出实例化一个变量：
- en: '[PRE151]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Similar to the preceding, in this case, we are going to replace the occurrences
    of a pattern in the variable:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的情况类似，在这种情况下，我们将替换变量中模式的出现：
- en: '[PRE152]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Like the preceding example, if substitution is omitted, a pattern is deleted
    from the variable:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例类似，如果省略替换，则从变量中删除模式：
- en: '[PRE153]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'If the prefix of the variable matches, then replace the pattern with substitution
    in variable, so this is similar to the preceding but matches only at the beginning
    of the variable:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量的前缀匹配，则用替换替换变量中的模式，因此这与前面的类似，但仅在变量开头匹配：
- en: '[PRE154]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: As usual, omitting means deleting the occurrence of the pattern from the variable.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，省略意味着从变量中删除模式的出现。
- en: '[PRE155]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Once again, a positional replacement, this time at the end of the variable
    value:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一个位置的替换，这次是在变量值的末尾：
- en: '[PRE156]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'A lot of nonsense, but it makes sense:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 很多废话，但是有意义：
- en: '[PRE157]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Match the name of the variable names starting with the highlighted prefix:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配以突出显示的前缀开头的变量名：
- en: '[PRE158]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We can decide from which position we want to start the variable expansion,
    so determining what part of its value we want to get back:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以决定从哪个位置开始扩展变量，从而确定我们想要从其值中获取回来的部分：
- en: '[PRE159]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'So, we just took a part of the variable, and we decided the starting point,
    but we can also define for how long cherry-picking is done:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只取了变量的一部分，并确定了起始点，但我们也可以定义挑选的持续时间：
- en: '[PRE160]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: So we do not go further, start at a position and stop at the offset; this way,
    we can extract whatever consecutive characters/digits we want from the value of
    a variable.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不再继续，从一个位置开始并停在偏移处；这样，我们可以从变量值中提取任何连续的字符/数字。
- en: So far, we have seen many different ways to access and modify the content of
    a variable or, at least, of what we get from a variable. There is a class of very
    special variables left to look at, and these will be really handy when writing
    a script.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了许多不同的方式来访问和修改变量或者至少是从变量中获取的内容。还有一类非常特殊的变量需要查看，当编写脚本时，这些变量将非常方便。
- en: Special variables
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊变量
- en: 'Let''s see now some variables which have some spacial uses that we can benefit
    from:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些具有一些特殊用途的变量，我们可以从中受益：
- en: '[PRE161]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The first interesting variables we want to explore have a special role in our
    scripts because they will let us capture more than an argument on our first command-line
    execution. Have a look at this bunch of lines:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要探索的第一个有趣的变量在我们的脚本中有特殊作用，因为它们将允许我们在第一次命令行执行中捕获多个参数。看看这些行的一堆：
- en: '[PRE162]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Pay attention to `$1`, `$2`, `$3`:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`$1`，`$2`，`$3`：
- en: '[PRE163]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'First try, no arguments on the command line, we see nothing printed for the
    variables:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试，在命令行上没有参数，我们看不到打印变量的内容：
- en: '[PRE164]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Second try, we invoke the script and add three digits separated by spaces and,
    actually, we can see them printed. The first on the command line corresponds to
    `$1`, the second to `$2`, and the third to `$3`:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次尝试，我们调用脚本并添加由空格分隔的三个数字，实际上，我们可以看到它们被打印出来。命令行上的第一个对应于`$1`，第二个对应于`$2`，第三个对应于`$3`：
- en: '[PRE165]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The value of the first variable is `Green`; the second is `Yellow`; and the
    third is `Red`.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量的值是`Green`；第二个是`Yellow`；第三个是`Red`。
- en: 'Third try, we use words with the same results. But notice here:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次尝试，我们使用具有相同结果的单词。但请注意这里：
- en: '[PRE166]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'We used a double quote to prevent the space between one sentence and another
    being interpreted as a divider for the command-line bits, and in fact, the first
    and second sentences were added as a complete string to the variables, but the
    third came up just with an A because the subsequent spaces, not quoted, were considered
    to be separators and the following bits taken as `$4`, `$5`, and `$n`. Note that
    we could also mix the order of assignment, as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用双引号来防止一个句子和另一个之间的空格被解释为命令行位的分隔符，事实上，第一和第二句被添加为变量的完整字符串，但第三句只有一个A，因为后续未引用的空格被视为分隔符，并且接下来的位被视为`$4`，`$5`和`$n`。请注意，我们也可以混合分配顺序，如下所示：
- en: '[PRE167]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The result would be the same. What is important is not the position of the variable
    we declare, but what positional we associate with it.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一样的。重要的是，我们声明的变量的位置并不重要，而是我们将其与哪个位置关联。
- en: 'As you saw, we used two different methods to represent a positional variable:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了两种不同的方法来表示一个位置变量：
- en: '[PRE168]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Are they the same? Almost. Look here:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是一样的吗？差不多。看这里：
- en: '[PRE169]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Now, let''s execute the script:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行脚本：
- en: '[PRE170]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Interesting, the `eleventhvariable` has been interpreted as it were the positional
    `$1` and added a `1`. Odd, let''s rewrite the echo in the following way:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`eleventhvariable`被当作位置参数`$1`解释，并添加了一个`1`。奇怪，我们来按下面的方式重写echo：
- en: '[PRE171]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'And run the script again:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次运行脚本：
- en: '[PRE172]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Now we are correct. We did not pass an eleventh positional value on the command
    line, so the `eleventhvariable` has not been instantiated and we do not see anything
    printed to the video. Be cautious, always use `${}`; it will preserve the value
    of the variable in your complex scripts when having a grasp of every single detail
    would be really difficult:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们是正确的了。我们没有在命令行上传递第十一项位置参数，因此`eleventhvariable`没有被实例化，我们也没有看到任何输出到屏幕上的内容。小心，始终使用`${}`；它会在复杂脚本中保留变量的值，当你需要掌握每一个细节时，这会变得非常重要：
- en: '[PRE173]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'This expands to the full path to the script; it gives you a way to handle it
    in your script. So, let''s add the following line at the end of the script and
    execute it:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这个展开为脚本的完整路径；它为你提供了在脚本中处理它的方法。所以，我们来在脚本末尾添加以下一行并执行它：
- en: '[PRE174]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'In our case, the path is local, since we called the script from inside the
    directory that is holding it:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，路径是本地的，因为我们是从包含脚本的目录中调用的脚本：
- en: '[PRE175]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Expands into the number of the arguments passed to the script, showing us the
    number of arguments that have been passed on the command line to the script. So,
    let''s add the following line to our script and let''s see what comes out of it:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这个展开为传递给脚本的参数数量，显示了命令行上传递给脚本的参数个数。所以，让我们在脚本中添加以下一行，看看会输出什么：
- en: '[PRE176]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Gives us the list of arguments passed on the command line to the script, with
    one difference: `${@}` preserves the spaces, the second doesn''t:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 它给我们返回了传递给脚本的命令行参数列表，有一个不同点：`${@}`保留了空格，而第二种方法则没有：
- en: '[PRE177]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'We changed the characters used by the shell as a delimiter to identify single
    words. Now, let us execute the script:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改了shell使用的字符作为分隔符来识别单个词。现在，让我们执行脚本：
- en: '[PRE178]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Here, you can see the difference at play:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到差异的体现：
- en: '`*`: This expands to the positional parameters, starting from the first and
    when the expansion is within double quotes, it expands to a single word and separates each
    positional parameter using the first character of IFS. If the latter is null,
    a space is used, if it is null the words are concatenated without separators.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`：这个展开为位置参数，从第一个开始，当展开发生在双引号内时，它会展开为单一的词，并使用IFS的第一个字符分隔每个位置参数。如果IFS为空，则使用空格；如果IFS为null，则词语会被连接在一起，没有分隔符。'
- en: '`@`: This expands to the positional parameter, starting from the first, and
    if the expansion occurs within a double quote, each positional parameter is expanded
    to a word on its own:'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@`：这个展开为位置参数，从第一个开始，如果展开发生在双引号内，每个位置参数会被展开为独立的词：'
- en: '[PRE179]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'This special variable expands to the exit value of the last command executed,
    as we have already seen:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊变量展开为最后执行的命令的退出值，正如我们之前看到的那样：
- en: '[PRE180]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: The first command was successful, so the exit code is `0` ; the second gave
    an error `127command not found`, since such a command as `tt` does not exist.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令执行成功，因此退出代码是`0`；第二个命令报错`127command not found`，因为`tt`命令不存在。
- en: '`${$}` expands to the process number of the current shell and for a script
    is the shell in which it is running. Let us add the following line to our `positional.sh`
    script:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`${$}`展开为当前shell的进程号，对于脚本来说，就是它运行的shell。我们来给`positional.sh`脚本添加以下这一行：'
- en: '[PRE181]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Then let''s run it:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们运行它：
- en: '[PRE182]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Step by step, our script is telling us more and more:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 一步步地，脚本告诉我们越来越多的信息：
- en: '[PRE183]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'This is tricky; it expands to the process number of the last command executed
    in the background. Time to add some other lines to our script:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点棘手；它展开为最后一个后台命令的进程号。是时候在脚本中添加一些其他行了：
- en: '[PRE184]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'And now execute it:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行它：
- en: '[PRE185]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: We used `nohup ps &` to send the `ps` in the background (`&`) and detach it
    from the current terminal (`nohup`). We will see later, in more details the use
    of background commands; it suffices now to see how, before sending the process
    in to the background, we had no value to print for `${!}` ; it was instanced only
    after we sent `ps` in to the background.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`nohup ps &`将`ps`发送到后台（`&`），并将其从当前终端分离（`nohup`）。稍后我们会更详细地讨论后台命令的使用；现在只需要了解，在将进程发送到后台之前，`${!}`没有任何值可以打印；它仅在我们将`ps`发送到后台后才被实例化。
- en: Do you see that?
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到那个了吗？
- en: '[PRE186]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Well, for our purposes, it has no value, so how can we redirect this useless
    output and get rid of it during the execution of our script? You know what? It
    is a tiny exercise for you to do before you start reading the next chapter, which
    will deal with the operators and much more fun.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，它没有任何意义，那我们怎么在脚本执行过程中重定向这个无用的输出并将其去除呢？你知道吗？这是一个小练习，在你开始阅读下一章之前，自己做一下吧，那一章会涉及操作符以及更多有趣的内容。
- en: Summary
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we touched on some of the very basics of the shell, such as
    things that you should know how to deal with in the correct way. Failing to preserve
    variable names can, for instance, lead us to unwanted results and, on a different
    side, knowing how to access environment variables will help us create a better
    environment for our day-to-day tasks. As we said, basic but important things that
    a Bash master should know by heart, because unmasks, file descriptors, and fiddling
    with variables are what let you play awesome tricks and are the building blocks
    to becoming more advanced. So, do not just overlook them; they will help you.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些Shell的基础知识，比如你应该如何正确处理的内容。例如，不正确地保存变量名可能会导致我们得到不想要的结果；而另一方面，了解如何访问环境变量将有助于我们为日常任务创建更好的环境。正如我们所说，这些是Bash大师应该牢记的基本但重要的内容，因为解除屏蔽、文件描述符和操作变量是让你玩出高阶技巧的关键，也是成为高级用户的构建模块。所以，不要忽视它们，它们会帮助你。
